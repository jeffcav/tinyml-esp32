
build/main.elf:     file format elf32-xtensa-le


Disassembly of section .iram0.vectors:

40374000 <_WindowOverflow4>:

    .org    0x0
    .global _WindowOverflow4
_WindowOverflow4:

    s32e    a0, a5, -16     /* save a0 to call[j+1]'s stack frame */
40374000:	49c500        	s32e	a0, a5, -16
    s32e    a1, a5, -12     /* save a1 to call[j+1]'s stack frame */
40374003:	49d510        	s32e	a1, a5, -12
    s32e    a2, a5,  -8     /* save a2 to call[j+1]'s stack frame */
40374006:	49e520        	s32e	a2, a5, -8
    s32e    a3, a5,  -4     /* save a3 to call[j+1]'s stack frame */
40374009:	49f530        	s32e	a3, a5, -4
    rfwo                    /* rotates back to call[i] position */
4037400c:	003400        	rfwo
	...

40374040 <_WindowUnderflow4>:

    .org    0x40
    .global _WindowUnderflow4
_WindowUnderflow4:

    l32e    a0, a5, -16     /* restore a0 from call[i+1]'s stack frame */
40374040:	09c500        	l32e	a0, a5, -16
    l32e    a1, a5, -12     /* restore a1 from call[i+1]'s stack frame */
40374043:	09d510        	l32e	a1, a5, -12
    l32e    a2, a5,  -8     /* restore a2 from call[i+1]'s stack frame */
40374046:	09e520        	l32e	a2, a5, -8
    l32e    a3, a5,  -4     /* restore a3 from call[i+1]'s stack frame */
40374049:	09f530        	l32e	a3, a5, -4
    rfwu
4037404c:	003500        	rfwu
	...

40374050 <_xt_alloca_exc>:

    .align  4
    .global _xt_alloca_exc
_xt_alloca_exc:

    rsr     a0, WINDOWBASE  /* grab WINDOWBASE before rotw changes it */
40374050:	034800        	rsr.windowbase	a0
    rotw    -1              /* WINDOWBASE goes to a4, new a0-a3 are scratch */
40374053:	4080f0        	rotw	-1
    rsr     a2, PS
40374056:	03e620        	rsr.ps	a2
    extui   a3, a2, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
40374059:	343820        	extui	a3, a2, 8, 4
    xor     a3, a3, a4      /* bits changed from old to current windowbase */
4037405c:	303340        	xor	a3, a3, a4
    rsr     a4, EXCSAVE_1   /* restore original a0 (now in a4) */
4037405f:	03d140        	rsr.excsave1	a4
    slli    a3, a3, XCHAL_PS_OWB_SHIFT
40374062:	113380        	slli	a3, a3, 8
    xor     a2, a2, a3      /* flip changed bits in old window base */
40374065:	302230        	xor	a2, a2, a3
    wsr     a2, PS          /* update PS.OWB to new window base */
40374068:	13e620        	wsr.ps	a2
    rsync
4037406b:	002010        	rsync

    _bbci.l a4, 31, _WindowUnderflow4
4037406e:	ce74f7        	bbci	a4, 31, 40374040 <_WindowUnderflow4>
    rotw    -1              /* original a0 goes to a8 */
40374071:	4080f0        	rotw	-1
    _bbci.l a8, 30, _WindowUnderflow8
40374074:	4878e7        	bbci	a8, 30, 403740c0 <_WindowUnderflow8>
    rotw    -1
40374077:	4080f0        	rotw	-1
    j               _WindowUnderflow12
4037407a:	003086        	j	40374140 <_WindowUnderflow12>
4037407d:	000000        	ill

40374080 <_WindowOverflow8>:

    .org    0x80
    .global _WindowOverflow8
_WindowOverflow8:

    s32e    a0, a9, -16     /* save a0 to call[j+1]'s stack frame */
40374080:	49c900        	s32e	a0, a9, -16
    l32e    a0, a1, -12     /* a0 <- call[j-1]'s sp
40374083:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1, a9, -12     /* save a1 to call[j+1]'s stack frame */
40374086:	49d910        	s32e	a1, a9, -12
    s32e    a2, a9,  -8     /* save a2 to call[j+1]'s stack frame */
40374089:	49e920        	s32e	a2, a9, -8
    s32e    a3, a9,  -4     /* save a3 to call[j+1]'s stack frame */
4037408c:	49f930        	s32e	a3, a9, -4
    s32e    a4, a0, -32     /* save a4 to call[j]'s stack frame */
4037408f:	498040        	s32e	a4, a0, -32
    s32e    a5, a0, -28     /* save a5 to call[j]'s stack frame */
40374092:	499050        	s32e	a5, a0, -28
    s32e    a6, a0, -24     /* save a6 to call[j]'s stack frame */
40374095:	49a060        	s32e	a6, a0, -24
    s32e    a7, a0, -20     /* save a7 to call[j]'s stack frame */
40374098:	49b070        	s32e	a7, a0, -20
    rfwo                    /* rotates back to call[i] position */
4037409b:	003400        	rfwo
	...

403740c0 <_WindowUnderflow8>:

    .org    0xC0
    .global _WindowUnderflow8
_WindowUnderflow8:

    l32e    a0, a9, -16     /* restore a0 from call[i+1]'s stack frame */
403740c0:	09c900        	l32e	a0, a9, -16
    l32e    a1, a9, -12     /* restore a1 from call[i+1]'s stack frame */
403740c3:	09d910        	l32e	a1, a9, -12
    l32e    a2, a9,  -8     /* restore a2 from call[i+1]'s stack frame */
403740c6:	09e920        	l32e	a2, a9, -8
    l32e    a7, a1, -12     /* a7 <- call[i-1]'s sp
403740c9:	09d170        	l32e	a7, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3, a9,  -4     /* restore a3 from call[i+1]'s stack frame */
403740cc:	09f930        	l32e	a3, a9, -4
    l32e    a4, a7, -32     /* restore a4 from call[i]'s stack frame */
403740cf:	098740        	l32e	a4, a7, -32
    l32e    a5, a7, -28     /* restore a5 from call[i]'s stack frame */
403740d2:	099750        	l32e	a5, a7, -28
    l32e    a6, a7, -24     /* restore a6 from call[i]'s stack frame */
403740d5:	09a760        	l32e	a6, a7, -24
    l32e    a7, a7, -20     /* restore a7 from call[i]'s stack frame */
403740d8:	09b770        	l32e	a7, a7, -20
    rfwu
403740db:	003500        	rfwu
	...

40374100 <_WindowOverflow12>:

    .org    0x100
    .global _WindowOverflow12
_WindowOverflow12:

    s32e    a0,  a13, -16   /* save a0 to call[j+1]'s stack frame */
40374100:	49cd00        	s32e	a0, a13, -16
    l32e    a0,  a1,  -12   /* a0 <- call[j-1]'s sp
40374103:	09d100        	l32e	a0, a1, -12
                               (used to find end of call[j]'s frame) */
    s32e    a1,  a13, -12   /* save a1 to call[j+1]'s stack frame */
40374106:	49dd10        	s32e	a1, a13, -12
    s32e    a2,  a13,  -8   /* save a2 to call[j+1]'s stack frame */
40374109:	49ed20        	s32e	a2, a13, -8
    s32e    a3,  a13,  -4   /* save a3 to call[j+1]'s stack frame */
4037410c:	49fd30        	s32e	a3, a13, -4
    s32e    a4,  a0,  -48   /* save a4 to end of call[j]'s stack frame */
4037410f:	494040        	s32e	a4, a0, -48
    s32e    a5,  a0,  -44   /* save a5 to end of call[j]'s stack frame */
40374112:	495050        	s32e	a5, a0, -44
    s32e    a6,  a0,  -40   /* save a6 to end of call[j]'s stack frame */
40374115:	496060        	s32e	a6, a0, -40
    s32e    a7,  a0,  -36   /* save a7 to end of call[j]'s stack frame */
40374118:	497070        	s32e	a7, a0, -36
    s32e    a8,  a0,  -32   /* save a8 to end of call[j]'s stack frame */
4037411b:	498080        	s32e	a8, a0, -32
    s32e    a9,  a0,  -28   /* save a9 to end of call[j]'s stack frame */
4037411e:	499090        	s32e	a9, a0, -28
    s32e    a10, a0,  -24   /* save a10 to end of call[j]'s stack frame */
40374121:	49a0a0        	s32e	a10, a0, -24
    s32e    a11, a0,  -20   /* save a11 to end of call[j]'s stack frame */
40374124:	49b0b0        	s32e	a11, a0, -20
    rfwo                    /* rotates back to call[i] position */
40374127:	003400        	rfwo
	...

40374140 <_WindowUnderflow12>:

    .org 0x140
    .global _WindowUnderflow12
_WindowUnderflow12:

    l32e    a0,  a13, -16   /* restore a0 from call[i+1]'s stack frame */
40374140:	09cd00        	l32e	a0, a13, -16
    l32e    a1,  a13, -12   /* restore a1 from call[i+1]'s stack frame */
40374143:	09dd10        	l32e	a1, a13, -12
    l32e    a2,  a13,  -8   /* restore a2 from call[i+1]'s stack frame */
40374146:	09ed20        	l32e	a2, a13, -8
    l32e    a11, a1,  -12   /* a11 <- call[i-1]'s sp
40374149:	09d1b0        	l32e	a11, a1, -12
                               (used to find end of call[i]'s frame) */
    l32e    a3,  a13,  -4   /* restore a3 from call[i+1]'s stack frame */
4037414c:	09fd30        	l32e	a3, a13, -4
    l32e    a4,  a11, -48   /* restore a4 from end of call[i]'s stack frame */
4037414f:	094b40        	l32e	a4, a11, -48
    l32e    a5,  a11, -44   /* restore a5 from end of call[i]'s stack frame */
40374152:	095b50        	l32e	a5, a11, -44
    l32e    a6,  a11, -40   /* restore a6 from end of call[i]'s stack frame */
40374155:	096b60        	l32e	a6, a11, -40
    l32e    a7,  a11, -36   /* restore a7 from end of call[i]'s stack frame */
40374158:	097b70        	l32e	a7, a11, -36
    l32e    a8,  a11, -32   /* restore a8 from end of call[i]'s stack frame */
4037415b:	098b80        	l32e	a8, a11, -32
    l32e    a9,  a11, -28   /* restore a9 from end of call[i]'s stack frame */
4037415e:	099b90        	l32e	a9, a11, -28
    l32e    a10, a11, -24   /* restore a10 from end of call[i]'s stack frame */
40374161:	09aba0        	l32e	a10, a11, -24
    l32e    a11, a11, -20   /* restore a11 from end of call[i]'s stack frame */
40374164:	09bbb0        	l32e	a11, a11, -20
    rfwu
40374167:	003500        	rfwu
	...

40374180 <_Level2Vector>:
    wsr     a0, EXCSAVE_2                   /* preserve a0 */
40374180:	13d200        	wsr.excsave2	a0
    call0   _xt_medint2                     /* load interrupt handler */
40374183:	029a85        	call0	40376b2c <_xt_medint2>
	...

403741c0 <_Level3Vector>:
    wsr     a0, EXCSAVE_3                   /* preserve a0 */
403741c0:	13d300        	wsr.excsave3	a0
    call0   _xt_medint3                     /* load interrupt handler */
403741c3:	02a185        	call0	40376bdc <_xt_medint3>
	...

40374200 <_Level4Vector>:
    wsr     a0, EXCSAVE_4                   /* preserve a0 */
40374200:	13d400        	wsr.excsave4	a0
    call0   xt_highint4                    /* load interrupt handler */
40374203:	011ec5        	call0	403753f0 <xt_highint4>
	...

40374240 <_Level5Vector>:
    wsr     a0, EXCSAVE_5                   /* preserve a0 */
40374240:	13d500        	wsr.excsave5	a0
    call0   xt_highint5                    /* load interrupt handler */
40374243:	02aec5        	call0	40376d30 <xt_highint5>
	...

40374280 <_DebugExceptionVector>:
    wsr     a0, EXCSAVE+XCHAL_DEBUGLEVEL    /* preserve a0 */
40374280:	13d600        	wsr.excsave6	a0
    J   xt_debugexception            /* load exception handler */
40374283:	0aa246        	j	40376d10 <xt_debugexception>
	...

403742c0 <_NMIExceptionVector>:
    wsr     a0, EXCSAVE + XCHAL_NMILEVEL  _ /* preserve a0 */
403742c0:	13d700        	wsr.excsave7	a0
    call0   xt_nmi                         /* load interrupt handler */
403742c3:	02a745        	call0	40376d38 <_xt_nmi>
	...

40374300 <_KernelExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374300:	13d100        	wsr.excsave1	a0
    call0   _xt_kernel_exc                  /* kernel exception handler */
40374303:	023e85        	call0	403766ec <_xt_kernel_exc>
	...

40374340 <_UserExceptionVector>:
    wsr     a0, EXCSAVE_1                   /* preserve a0 */
40374340:	13d100        	wsr.excsave1	a0
    call0   _xt_user_exc                    /* user exception handler */
40374343:	023c85        	call0	4037670c <_xt_user_exc>
	...

403743c0 <_DoubleExceptionVector>:
    break   1, 4                            /* unhandled double exception */
403743c0:	004140        	break	1, 4
    movi    a0,PANIC_RSN_DOUBLEEXCEPTION
403743c3:	200c      	movi.n	a0, 2
    wsr     a0,EXCCAUSE
403743c5:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
403743c8:	03d405        	call0	4037810c <_xt_panic>
    rfde                                    /* make a0 point here not later */
403743cb:	003200        	rfde
	...

40374400 <_init>:
40374400:	008136        	entry	a1, 64

Disassembly of section .iram0.text:

40374404 <esp_app_get_elf_sha256-0xc58>:
40374404:	00 06 c9 3f 	
40374408:	20 00 02 3c 	
4037440c:	50 26 c9 3f 	
40374410:	00 40 37 40 	
40374414:	d8 e0 0c 60 	
40374418:	dc e0 0c 60 	
4037441c:	67 26 c9 3f 	
40374420:	65 26 c9 3f 	
40374424:	64 26 c9 3f 	
40374428:	6c 02 02 3c 	
4037442c:	20 07 00 40 	
40374430:	c4 85 00 42 	
40374434:	c0 06 00 40 	
40374438:	c4 0f 00 42 	
4037443c:	e8 12 00 42 	
40374440:	00 06 00 40 	
40374444:	f0 34 c9 3f 	
40374448:	50 26 c9 3f 	
4037444c:	00 00 00 50 	
40374450:	00 00 00 50 	
40374454:	20 00 02 3c 	
40374458:	60 ee 02 3c 	
4037445c:	ff ff 00 00 	
40374460:	00 00 0c 60 	
40374464:	f4 50 37 40 	
40374468:	90 26 c9 3f 	
4037446c:	20 01 02 3c 	
40374470:	7c 05 00 40 	
40374474:	e8 11 00 40 	
40374478:	1c 1a 00 40 	
4037447c:	b4 18 00 40 	
40374480:	28 1a 00 40 	
40374484:	c0 18 00 40 	
40374488:	5c 65 00 42 	
4037448c:	14 19 00 40 	
40374490:	cc 85 00 42 	
40374494:	ac 31 00 42 	
40374498:	50 19 00 40 	
4037449c:	4c 10 00 42 	
403744a0:	9c 11 00 42 	
403744a4:	64 25 00 42 	
403744a8:	9c 06 00 40 	
403744ac:	40 31 00 42 	
403744b0:	f4 11 00 40 	
403744b4:	5c 3b 00 42 	
403744b8:	ff ff ff fd 	
403744bc:	69 26 c9 3f 	
403744c0:	25 00 04 00 	
403744c4:	a8 54 37 40 	
403744c8:	f0 40 0c 60 	
403744cc:	fc 40 0c 60 	
403744d0:	0c 06 c9 3f 	
403744d4:	00 00 00 10 	
403744d8:	3c 00 0c 60 	
403744dc:	38 00 0c 60 	
403744e0:	b0 26 c9 3f 	
403744e4:	ac 26 c9 3f 	
403744e8:	a8 26 c9 3f 	
403744ec:	2c 06 c9 3f 	
403744f0:	6c 26 c9 3f 	
403744f4:	e0 0d 00 40 	
403744f8:	d4 0d 00 40 	
403744fc:	1c 0e 00 40 	
40374500:	ec 0d 00 40 	
40374504:	00 80 00 60 	
40374508:	74 26 c9 3f 	
4037450c:	88 26 c9 3f 	
40374510:	08 14 00 42 	
40374514:	c8 8b 01 42 	
40374518:	ac 15 00 42 	
4037451c:	7c 02 02 3c 	
40374520:	d0 05 00 40 	
40374524:	a7 02 02 3c 	
40374528:	04 03 02 3c 	
4037452c:	f5 02 02 3c 	
40374530:	c8 80 00 60 	
40374534:	20 03 02 3c 	
40374538:	28 03 02 3c 	
4037453c:	54 41 00 60 	
40374540:	58 41 00 60 	
40374544:	5c 41 00 60 	
40374548:	60 41 00 60 	
4037454c:	64 41 00 60 	
40374550:	68 41 00 60 	
40374554:	18 60 02 60 	
40374558:	af 3f 00 00 	
4037455c:	20 00 0c 60 	
40374560:	07 00 00 20 	
40374564:	24 00 0c 60 	
40374568:	44 00 0c 60 	
4037456c:	04 00 0c 60 	
40374570:	bc 0d 00 40 	
40374574:	28 0e 00 40 	
40374578:	04 0e 00 40 	
4037457c:	6c 18 00 40 	
40374580:	84 18 00 40 	
40374584:	24 06 c9 3f 	
40374588:	da 05 02 3c 	
4037458c:	ac 0a 02 3c 	
40374590:	b0 0a 02 3c 	
40374594:	48 1d 00 42 	
40374598:	70 1d 00 42 	
4037459c:	f0 7f 37 c0 	
403745a0:	e0 7f 07 00 	
403745a4:	00 20 f0 9f 	
403745a8:	ff 1f 00 00 	
403745ac:	ff ff ff 3f 	
403745b0:	fd ff ff bd 	
403745b4:	ff ff ff 01 	
403745b8:	fd ff c8 bf 	
403745bc:	ff ff 06 00 	
403745c0:	fd ff ff bf 	
403745c4:	ff a0 01 00 	
403745c8:	fd 1f f0 9f 	
403745cc:	bf 0a 02 3c 	
403745d0:	ce 0a 02 3c 	
403745d4:	dc 0a 02 3c 	
403745d8:	9d 02 02 3c 	
403745dc:	a4 26 c9 3f 	
403745e0:	b4 26 c9 3f 	
403745e4:	3c 27 c9 3f 	
403745e8:	38 27 c9 3f 	
403745ec:	b9 ff ce 3f 	
403745f0:	b8 ff ce 3f 	
403745f4:	e8 05 00 40 	
403745f8:	00 e0 02 60 	
403745fc:	00 00 00 60 	
40374600:	00 00 01 60 	
40374604:	ff ff 0f ff 	
40374608:	ff 0f f0 ff 	
4037460c:	00 80 00 60 	
40374610:	40 27 c9 3f 	
40374614:	44 27 c9 3f 	
40374618:	00 80 37 c0 	
4037461c:	ff 7f 06 00 	
40374620:	79 0b 02 3c 	
40374624:	08 0d 02 3c 	
40374628:	b5 0b 02 3c 	
4037462c:	fc 7f 37 c0 	
40374630:	c1 0b 02 3c 	
40374634:	e5 0b 02 3c 	
40374638:	f7 0b 02 3c 	
4037463c:	20 0d 02 3c 	
40374640:	44 06 c9 3f 	
40374644:	ef 0c 02 3c 	
40374648:	00 80 c8 bf 	
4037464c:	07 0c 02 3c 	
40374650:	af 0c 02 3c 	
40374654:	45 0c 02 3c 	
40374658:	be 0c 02 3c 	
4037465c:	7f 0c 02 3c 	
40374660:	9d 0c 02 3c 	
40374664:	d5 0c 02 3c 	
40374668:	8c 0c 02 3c 	
4037466c:	40 42 0f 00 	
40374670:	40 1a 00 40 	
40374674:	00 b4 c4 04 	
40374678:	ff b3 c4 04 	
4037467c:	50 06 c9 3f 	
40374680:	54 27 c9 3f 	
40374684:	48 27 c9 3f 	
40374688:	4c 27 c9 3f 	
4037468c:	54 1b 00 40 	
40374690:	8c 27 00 42 	
40374694:	7e 1a 02 3c 	
40374698:	ed 1a 02 3c 	
4037469c:	71 1a 02 3c 	
403746a0:	a0 27 00 42 	
403746a4:	48 80 00 60 	
403746a8:	d8 0d c9 3f 	
403746ac:	e0 0d c9 3f 	
403746b0:	4c 80 00 60 	
403746b4:	e4 0d c9 3f 	
403746b8:	e8 0d c9 3f 	
403746bc:	ec 0d c9 3f 	
403746c0:	60 06 c9 3f 	
403746c4:	54 5d 00 40 	
403746c8:	60 5d 00 40 	
403746cc:	6c 5d 00 40 	
403746d0:	01 d0 00 00 	
403746d4:	e8 10 0c 60 	
403746d8:	f4 10 0c 60 	
403746dc:	08 11 0c 60 	
403746e0:	18 11 0c 60 	
403746e4:	a0 11 0c 60 	
403746e8:	4c 12 0c 60 	
403746ec:	84 33 00 42 	
403746f0:	9c 43 00 42 	
403746f4:	78 06 c9 3f 	
403746f8:	c0 10 0c 60 	
403746fc:	d8 10 0c 60 	
40374700:	fc 10 0c 60 	
40374704:	b8 39 00 42 	
40374708:	dc 33 00 42 	
4037470c:	ec 3a 00 42 	
40374710:	b0 27 c9 3f 	
40374714:	24 00 04 00 	
40374718:	00 00 00 c0 	
4037471c:	f8 0a c9 3f 	
40374720:	a8 67 37 40 	
40374724:	90 2a c9 3f 	
40374728:	30 26 02 3c 	
4037472c:	90 06 c9 3f 	
40374730:	10 26 02 3c 	
40374734:	21 00 04 00 	
40374738:	ff 37 06 00 	
4037473c:	f8 08 c9 3f 	
40374740:	c8 6b 37 40 	
40374744:	22 00 04 00 	
40374748:	00 00 38 00 	
4037474c:	78 6c 37 40 	
40374750:	23 00 04 00 	
40374754:	00 88 c0 28 	
40374758:	ff ff ff 03 	
4037475c:	d0 27 c9 3f 	
40374760:	44 25 00 40 	
40374764:	b8 06 c9 3f 	
40374768:	c3 33 02 3c 	
4037476c:	c7 34 02 3c 	
40374770:	05 34 02 3c 	
40374774:	0d 34 02 3c 	
40374778:	ef 34 02 3c 	
4037477c:	8c c9 02 3c 	
40374780:	da 34 02 3c 	
40374784:	1e 34 02 3c 	
40374788:	04 35 02 3c 	
4037478c:	33 c4 10 bb 	
40374790:	ec 2a c9 3f 	
40374794:	98 2a c9 3f 	
40374798:	d0 ff ce 3f 	
4037479c:	e8 98 00 42 	
403747a0:	30 2c c9 3f 	
403747a4:	84 44 00 42 	
403747a8:	14 46 00 42 	
403747ac:	74 25 00 40 	
403747b0:	5c 07 c9 3f 	
403747b4:	5c 2c c9 3f 	
403747b8:	58 2c c9 3f 	
403747bc:	60 2c c9 3f 	
403747c0:	68 2c c9 3f 	
403747c4:	74 2c c9 3f 	
403747c8:	78 07 c9 3f 	
403747cc:	68 07 c9 3f 	
403747d0:	78 c4 02 3c 	
403747d4:	ba c6 02 3c 	
403747d8:	52 c7 02 3c 	
403747dc:	02 c7 02 3c 	
403747e0:	15 c7 02 3c 	
403747e4:	00 20 00 60 	
403747e8:	00 00 20 00 	
403747ec:	ff ff ff 0f 	
403747f0:	ff ff ff bf 	
403747f4:	e4 ff ce 3f 	
403747f8:	ff ff ff df 	
403747fc:	ff ff ff f7 	
40374800:	ff ff ff ef 	
40374804:	24 c7 02 3c 	
40374808:	37 c7 02 3c 	
4037480c:	ff ff ff 7f 	
40374810:	00 30 00 60 	
40374814:	00 70 00 60 	
40374818:	9c 18 00 40 	
4037481c:	a8 18 00 40 	
40374820:	5a 32 c9 3f 	
40374824:	5b 32 c9 3f 	
40374828:	60 32 c9 3f 	
4037482c:	ff 7f 07 00 	
40374830:	bc c7 02 3c 	
40374834:	fe c8 02 3c 	
40374838:	ae c7 02 3c 	
4037483c:	90 0d c9 3f 	
40374840:	e4 c7 02 3c 	
40374844:	f9 c7 02 3c 	
40374848:	74 75 37 40 	
4037484c:	0a c8 02 3c 	
40374850:	94 c7 02 3c 	
40374854:	54 c8 02 3c 	
40374858:	08 86 00 42 	
4037485c:	d4 89 00 42 	
40374860:	6e c8 02 3c 	
40374864:	cd c8 02 3c 	
40374868:	86 c8 02 3c 	
4037486c:	1c 86 00 42 	
40374870:	60 40 0c 60 	
40374874:	44 c9 02 3c 	
40374878:	66 ca 02 3c 	
4037487c:	5d c9 02 3c 	
40374880:	00 14 03 18 	
40374884:	6c 32 c9 3f 	
40374888:	00 50 0c 60 	
4037488c:	00 40 00 00 	
40374890:	5c 19 00 40 	
40374894:	68 19 00 40 	
40374898:	ff 9f 75 00 	
4037489c:	8e c9 02 3c 	
403748a0:	ad ca 02 3c 	
403748a4:	fc c9 02 3c 	
403748a8:	6c 34 c9 3f 	
403748ac:	68 32 c9 3f 	
403748b0:	b0 16 00 40 	
403748b4:	09 ca 02 3c 	
403748b8:	55 ca 02 3c 	
403748bc:	78 ca 02 3c 	
403748c0:	23 ca 02 3c 	
403748c4:	ff ff ff 00 	
403748c8:	70 34 c9 3f 	
403748cc:	04 1a c9 3f 	
403748d0:	94 0d c9 3f 	
403748d4:	04 80 01 42 	
403748d8:	03 60 00 00 	
403748dc:	05 60 00 00 	
403748e0:	f8 86 00 42 	
403748e4:	c8 21 00 42 	
403748e8:	c2 ca 02 3c 	
403748ec:	06 cb 02 3c 	
403748f0:	ee ca 02 3c 	
403748f4:	0f 27 00 00 	
403748f8:	1f 4e 00 00 	
403748fc:	b4 93 00 42 	
40374900:	d4 16 00 40 	
40374904:	30 00 0c 60 	
40374908:	34 00 0c 60 	
4037490c:	bc 0d c9 3f 	
40374910:	28 8b 00 42 	
40374914:	20 cb 02 3c 	
40374918:	6b cb 02 3c 	
4037491c:	57 cb 02 3c 	
40374920:	80 34 c9 3f 	
40374924:	99 cb 02 3c 	
40374928:	df cb 02 3c 	
4037492c:	cf cb 02 3c 	
40374930:	a8 34 c9 3f 	
40374934:	98 34 c9 3f 	
40374938:	90 34 c9 3f 	
4037493c:	88 34 c9 3f 	
40374940:	a0 34 c9 3f 	
40374944:	8c 1b 00 42 	
40374948:	5c 17 02 3c 	
4037494c:	da 17 02 3c 	
40374950:	a8 17 02 3c 	
40374954:	f8 17 02 3c 	
40374958:	bc 80 00 60 	
4037495c:	e8 17 02 3c 	
40374960:	94 27 c9 3f 	
40374964:	74 80 00 60 	
40374968:	50 1d c9 3f 	
4037496c:	af 1d c9 3f 	
40374970:	56 1d c9 3f 	
40374974:	68 06 c9 3f 	
40374978:	6c 06 c9 3f 	
4037497c:	60 00 0c 60 	
40374980:	8c 1d c9 3f 	
40374984:	98 1d c9 3f 	
40374988:	ff f3 ff ff 	
4037498c:	90 27 c9 3f 	
40374990:	fc 81 00 60 	
40374994:	ff 1f f8 ff 	
40374998:	4c 1a 00 40 	
4037499c:	60 80 00 60 	
403749a0:	ff ff f1 ff 	
403749a4:	ff 1f ff ff 	
403749a8:	ff e3 ff ff 	
403749ac:	c0 84 00 60 	
403749b0:	c4 84 00 60 	
403749b4:	ff ff fe ff 	
403749b8:	1c 80 00 60 	
403749bc:	3f c0 ff ff 	
403749c0:	40 13 02 00 	
403749c4:	07 0b 01 00 	
403749c8:	c0 80 00 60 	
403749cc:	10 00 0c 60 	
403749d0:	70 06 c9 3f 	
403749d4:	74 06 c9 3f 	
403749d8:	67 66 66 66 	
403749dc:	00 80 03 60 	
403749e0:	40 e0 00 60 	
403749e4:	60 07 0b 01 	
403749e8:	90 80 00 60 	
403749ec:	88 80 00 60 	
403749f0:	ff f7 ff ff 	
403749f4:	9c 60 02 60 	
403749f8:	54 d0 01 60 	
403749fc:	d4 cc 01 60 	
40374a00:	90 60 00 60 	
40374a04:	f0 50 00 60 	
40374a08:	b0 60 02 60 	
40374a0c:	07 c0 ff ff 	
40374a10:	68 f0 01 60 	
40374a14:	80 f0 01 60 	
40374a18:	ff 9f ff ff 	
40374a1c:	ff ef ff ff 	
40374a20:	00 00 ff 7f 	
40374a24:	ff ff 00 80 	
40374a28:	6c f0 01 60 	
40374a2c:	0c 80 00 60 	
40374a30:	10 80 00 60 	
40374a34:	14 80 00 60 	
40374a38:	f3 d3 02 3c 	
40374a3c:	5b dc 02 3c 	
40374a40:	a6 d4 02 3c 	
40374a44:	b0 d4 02 3c 	
40374a48:	10 d5 02 3c 	
40374a4c:	3f d5 02 3c 	
40374a50:	2d dc 02 3c 	
40374a54:	a5 d5 02 3c 	
40374a58:	02 dc 02 3c 	
40374a5c:	7f d9 02 3c 	
40374a60:	d7 d5 02 3c 	
40374a64:	f8 d5 02 3c 	
40374a68:	2c d6 02 3c 	
40374a6c:	64 d6 02 3c 	
40374a70:	9c d6 02 3c 	
40374a74:	e1 d6 02 3c 	
40374a78:	f0 db 02 3c 	
40374a7c:	fa d6 02 3c 	
40374a80:	3a d7 02 3c 	
40374a84:	a0 d7 02 3c 	
40374a88:	d1 d7 02 3c 	
40374a8c:	18 d8 02 3c 	
40374a90:	5e d8 02 3c 	
40374a94:	da db 02 3c 	
40374a98:	a1 d8 02 3c 	
40374a9c:	c3 db 02 3c 	
40374aa0:	c1 d8 02 3c 	
40374aa4:	f9 d8 02 3c 	
40374aa8:	ab db 02 3c 	
40374aac:	a0 95 37 40 	
40374ab0:	00 98 37 40 	
40374ab4:	54 93 37 40 	
40374ab8:	68 92 37 40 	
40374abc:	d0 9d 37 40 	
40374ac0:	3c 97 37 40 	
40374ac4:	08 9e 37 40 	
40374ac8:	14 92 37 40 	
40374acc:	c4 96 37 40 	
40374ad0:	84 91 37 40 	
40374ad4:	d0 99 37 40 	
40374ad8:	54 9e 37 40 	
40374adc:	ff ff 3f b3 	
40374ae0:	48 dc 02 3c 	
40374ae4:	17 dc 02 3c 	
40374ae8:	3f d9 02 3c 	
40374aec:	50 db 02 3c 	
40374af0:	53 d9 02 3c 	
40374af4:	1d db 02 3c 	
40374af8:	74 d9 02 3c 	
40374afc:	6d dc 02 3c 	
40374b00:	a0 d9 02 3c 	
40374b04:	cb d9 02 3c 	
40374b08:	9c db 02 3c 	
40374b0c:	ea d9 02 3c 	
40374b10:	82 dc 02 3c 	
40374b14:	fa d9 02 3c 	
40374b18:	19 da 02 3c 	
40374b1c:	8c db 02 3c 	
40374b20:	27 da 02 3c 	
40374b24:	75 db 02 3c 	
40374b28:	62 db 02 3c 	
40374b2c:	36 db 02 3c 	
40374b30:	07 db 02 3c 	
40374b34:	a8 da 02 3c 	
40374b38:	ea da 02 3c 	
40374b3c:	d8 da 02 3c 	
40374b40:	be da 02 3c 	
40374b44:	c7 1d c9 3f 	
40374b48:	e1 1d c9 3f 	
40374b4c:	e7 1d c9 3f 	
40374b50:	f3 1d c9 3f 	
40374b54:	1c 47 00 42 	
40374b58:	bc 9e 37 40 	
40374b5c:	1f 1e c9 3f 	
40374b60:	98 27 c9 3f 	
40374b64:	bc 27 c9 3f 	
40374b68:	f0 13 c9 3f 	
40374b6c:	f0 ff fb ff 	
40374b70:	20 00 04 00 	
40374b74:	c4 27 c9 3f 	
40374b78:	8c 6c 37 40 	
40374b7c:	2b 27 02 3c 	
40374b80:	f8 27 02 3c 	
40374b84:	ad 27 02 3c 	
40374b88:	f0 27 02 3c 	
40374b8c:	90 2b 00 42 	
40374b90:	08 2f 00 42 	
40374b94:	08 28 02 3c 	
40374b98:	2d 2d 02 3c 	
40374b9c:	46 28 02 3c 	
40374ba0:	4e 28 02 3c 	
40374ba4:	1b 0c 00 00 	
40374ba8:	95 28 02 3c 	
40374bac:	ba 2d 02 3c 	
40374bb0:	9d 28 02 3c 	
40374bb4:	a0 2d 02 3c 	
40374bb8:	bf 28 02 3c 	
40374bbc:	dc 28 02 3c 	
40374bc0:	1b 29 02 3c 	
40374bc4:	5a 29 02 3c 	
40374bc8:	8c 2d 02 3c 	
40374bcc:	75 29 02 3c 	
40374bd0:	c4 29 02 3c 	
40374bd4:	48 2d 02 3c 	
40374bd8:	02 2a 02 3c 	
40374bdc:	59 2a 02 3c 	
40374be0:	a6 2a 02 3c 	
40374be4:	f9 2a 02 3c 	
40374be8:	92 2b 02 3c 	
40374bec:	73 2d 02 3c 	
40374bf0:	14 2d 02 3c 	
40374bf4:	38 1c 00 40 	
40374bf8:	02 2d 02 3c 	
40374bfc:	9a 2b 02 3c 	
40374c00:	b3 2b 02 3c 	
40374c04:	14 2c 02 3c 	
40374c08:	ee 2c 02 3c 	
40374c0c:	5a 2d 02 3c 	
40374c10:	d9 2c 02 3c 	
40374c14:	7a 2c 02 3c 	
40374c18:	cc 2c 02 3c 	
40374c1c:	10 28 c9 3f 	
40374c20:	30 28 c9 3f 	
40374c24:	18 28 c9 3f 	
40374c28:	6c 28 c9 3f 	
40374c2c:	70 28 c9 3f 	
40374c30:	f0 27 c9 3f 	
40374c34:	cd 2d 02 3c 	
40374c38:	8c 33 02 3c 	
40374c3c:	fd 2d 02 3c 	
40374c40:	05 2e 02 3c 	
40374c44:	7f 33 02 3c 	
40374c48:	96 12 00 00 	
40374c4c:	f0 a3 00 42 	
40374c50:	b0 06 c9 3f 	
40374c54:	01 00 00 80 	
40374c58:	38 28 c9 3f 	
40374c5c:	2c 28 c9 3f 	
40374c60:	14 28 c9 3f 	
40374c64:	bc 1b 00 42 	
40374c68:	9c 28 c9 3f 	
40374c6c:	88 28 c9 3f 	
40374c70:	74 28 c9 3f 	
40374c74:	44 28 c9 3f 	
40374c78:	58 28 c9 3f 	
40374c7c:	08 28 c9 3f 	
40374c80:	f4 27 c9 3f 	
40374c84:	0c 28 c9 3f 	
40374c88:	37 2e 02 3c 	
40374c8c:	a5 33 02 3c 	
40374c90:	5b 2e 02 3c 	
40374c94:	82 2e 02 3c 	
40374c98:	b9 2e 02 3c 	
40374c9c:	e0 27 c9 3f 	
40374ca0:	d2 2e 02 3c 	
40374ca4:	23 33 02 3c 	
40374ca8:	e8 27 c9 3f 	
40374cac:	dc 2e 02 3c 	
40374cb0:	75 0b 00 00 	
40374cb4:	06 2f 02 3c 	
40374cb8:	10 33 02 3c 	
40374cbc:	15 0c 00 00 	
40374cc0:	1c 2f 02 3c 	
40374cc4:	37 0c 00 00 	
40374cc8:	f8 27 c9 3f 	
40374ccc:	fc 27 c9 3f 	
40374cd0:	04 28 c9 3f 	
40374cd4:	92 2f 02 3c 	
40374cd8:	40 33 02 3c 	
40374cdc:	bb 2f 02 3c 	
40374ce0:	f3 32 02 3c 	
40374ce4:	d8 27 c9 3f 	
40374ce8:	df 32 02 3c 	
40374cec:	c8 2f 02 3c 	
40374cf0:	be 32 02 3c 	
40374cf4:	05 0e 00 00 	
40374cf8:	0c 12 00 40 	
40374cfc:	e1 2f 02 3c 	
40374d00:	a8 32 02 3c 	
40374d04:	73 0e 00 00 	
40374d08:	ed 2f 02 3c 	
40374d0c:	8f 32 02 3c 	
40374d10:	d7 0e 00 00 	
40374d14:	fc 2f 02 3c 	
40374d18:	72 32 02 3c 	
40374d1c:	75 0f 00 00 	
40374d20:	5d 32 02 3c 	
40374d24:	06 30 02 3c 	
40374d28:	89 0f 00 00 	
40374d2c:	14 30 02 3c 	
40374d30:	63 33 02 3c 	
40374d34:	2f 30 02 3c 	
40374d38:	99 33 02 3c 	
40374d3c:	74 33 02 3c 	
40374d40:	60 30 02 3c 	
40374d44:	45 32 02 3c 	
40374d48:	88 30 02 3c 	
40374d4c:	71 13 00 00 	
40374d50:	21 32 02 3c 	
40374d54:	c2 13 00 00 	
40374d58:	9d 30 02 3c 	
40374d5c:	dd 13 00 00 	
40374d60:	c5 30 02 3c 	
40374d64:	09 32 02 3c 	
40374d68:	9d 15 00 00 	
40374d6c:	eb 30 02 3c 	
40374d70:	eb 31 02 3c 	
40374d74:	51 17 00 00 	
40374d78:	d7 30 02 3c 	
40374d7c:	52 17 00 00 	
40374d80:	2b 31 02 3c 	
40374d84:	d6 31 02 3c 	
40374d88:	a2 31 02 3c 	
40374d8c:	bf 31 02 3c 	
40374d90:	5c af 37 40 	
40374d94:	c4 31 02 3c 	
40374d98:	4f 33 02 3c 	
40374d9c:	60 ee 02 3c 	
40374da0:	60 ee 02 3c 	
40374da4:	30 00 05 00 	
40374da8:	10 00 00 00 	
40374dac:	20 01 02 3c 	
40374db0:	20 24 02 3c 	
40374db4:	ec 25 02 3c 	
40374db8:	76 24 02 3c 	
40374dbc:	80 24 02 3c 	
40374dc0:	db 25 02 3c 	
40374dc4:	b0 24 02 3c 	
40374dc8:	bc 24 02 3c 	
40374dcc:	e4 24 02 3c 	
40374dd0:	fc 24 02 3c 	
40374dd4:	66 66 00 00 	
40374dd8:	01 00 c0 4c 	
40374ddc:	10 25 02 3c 	
40374de0:	50 25 02 3c 	
40374de4:	a8 27 c9 3f 	
40374de8:	a0 27 c9 3f 	
40374dec:	ca 25 02 3c 	
40374df0:	64 25 02 3c 	
40374df4:	7c 25 02 3c 	
40374df8:	90 25 02 3c 	
40374dfc:	b6 25 02 3c 	
40374e00:	74 13 00 40 	
40374e04:	b8 27 c9 3f 	
40374e08:	60 26 02 3c 	
40374e0c:	f4 8b 01 42 	
40374e10:	65 26 02 3c 	
40374e14:	0e 27 02 3c 	
40374e18:	a6 26 02 3c 	
40374e1c:	80 13 00 42 	
40374e20:	dc 13 00 42 	
40374e24:	04 88 00 42 	
40374e28:	b4 26 02 3c 	
40374e2c:	e6 26 02 3c 	
40374e30:	cc 26 02 3c 	
40374e34:	4c 00 0c 60 	
40374e38:	44 c0 0c 60 	
40374e3c:	40 c0 0c 60 	
40374e40:	48 c0 0c 60 	
40374e44:	00 c0 0c 60 	
40374e48:	4c c0 0c 60 	
40374e4c:	58 c0 0c 60 	
40374e50:	50 c0 0c 60 	
40374e54:	54 c0 0c 60 	
40374e58:	ff ff fb ff 	
40374e5c:	ff ff 3f f8 	
40374e60:	ff ff c1 ff 	
40374e64:	ff ff ff 07 	
40374e68:	9f 3c ff ff 	
40374e6c:	ff cf ff ff 	
40374e70:	fc ff 00 00 	
40374e74:	fe ff 00 00 	
40374e78:	ff ff 03 00 	
40374e7c:	8f bd 6f fe 	
40374e80:	ff df ff ff 	
40374e84:	00 30 02 60 	
40374e88:	ff ff 0f 00 	
40374e8c:	2f 1e c9 3f 	
40374e90:	78 1e c9 3f 	
40374e94:	42 1e c9 3f 	
40374e98:	ef 0d 02 3c 	
40374e9c:	4e 0e 02 3c 	
40374ea0:	5b 0e 02 3c 	
40374ea4:	41 0e 02 3c 	
40374ea8:	1b 13 02 3c 	
40374eac:	a2 14 02 3c 	
40374eb0:	b0 0f 02 3c 	
40374eb4:	ac 0e 02 3c 	
40374eb8:	26 15 02 3c 	
40374ebc:	dd 0e 02 3c 	
40374ec0:	53 13 02 3c 	
40374ec4:	91 14 02 3c 	
40374ec8:	7f 13 02 3c 	
40374ecc:	d4 10 02 3c 	
40374ed0:	02 15 02 3c 	
40374ed4:	fe 10 02 3c 	
40374ed8:	c5 13 02 3c 	
40374edc:	84 14 02 3c 	
40374ee0:	00 00 00 00 	
40374ee4:	fc 13 02 3c 	
40374ee8:	73 14 02 3c 	
40374eec:	65 0f 02 3c 	
40374ef0:	14 15 02 3c 	
40374ef4:	b7 0f 02 3c 	
40374ef8:	9c 11 02 3c 	
40374efc:	c8 14 02 3c 	
40374f00:	d5 11 02 3c 	
40374f04:	de 14 02 3c 	
40374f08:	ef 11 02 3c 	
40374f0c:	b8 14 02 3c 	
40374f10:	1c 12 02 3c 	
40374f14:	ac 14 02 3c 	
40374f18:	90 12 02 3c 	
40374f1c:	d0 12 02 3c 	
40374f20:	66 14 02 3c 	
40374f24:	28 14 02 3c 	
40374f28:	56 14 02 3c 	
40374f2c:	bb 1e c9 3f 	
40374f30:	7c e7 37 40 	
40374f34:	95 1e c9 3f 	
40374f38:	b1 1e c9 3f 	
40374f3c:	c4 14 00 40 	
40374f40:	bd 1e c9 3f 	
40374f44:	cf 1e c9 3f 	
40374f48:	4e e8 37 40 	
40374f4c:	d1 1e c9 3f 	
40374f50:	df 1e c9 3f 	
40374f54:	e1 1e c9 3f 	
40374f58:	e3 1e c9 3f 	
40374f5c:	40 1e c9 3f 	
40374f60:	48 12 00 40 	
40374f64:	60 12 00 40 	
40374f68:	59 32 c9 3f 	
40374f6c:	58 32 c9 3f 	
40374f70:	01 00 00 ff 	
40374f74:	e8 1e c9 3f 	
40374f78:	81 1f c9 3f 	
40374f7c:	1d 1f c9 3f 	
40374f80:	69 1f c9 3f 	
40374f84:	32 1f c9 3f 	
40374f88:	50 1f c9 3f 	
40374f8c:	00 1b c9 3f 	
40374f90:	9c 1f c9 3f 	
40374f94:	90 91 00 42 	
40374f98:	01 00 ff ff 	
40374f9c:	10 f2 37 40 	
40374fa0:	98 f2 37 40 	
40374fa4:	b0 f2 37 40 	
40374fa8:	08 f3 37 40 	
40374fac:	ec 1a c9 3f 	
40374fb0:	f0 1a c9 3f 	
40374fb4:	cc 21 00 40 	
40374fb8:	74 34 c9 3f 	
40374fbc:	d4 1a c9 3f 	
40374fc0:	f7 20 c9 3f 	
40374fc4:	43 21 c9 3f 	
40374fc8:	2a 21 c9 3f 	
40374fcc:	35 75 7a 00 	
40374fd0:	e0 f2 37 40 	
40374fd4:	f0 f2 37 40 	
40374fd8:	04 fb 00 00 	
40374fdc:	06 f9 00 00 	
40374fe0:	60 9f ff ff 	
40374fe4:	21 de ff ff 	
40374fe8:	dc 23 00 00 	
40374fec:	12 ed ff ff 	
40374ff0:	ee 11 00 00 	
40374ff4:	f5 22 c9 3f 	
40374ff8:	af 23 c9 3f 	
40374ffc:	51 23 c9 3f 	
40375000:	9f 60 00 00 	
40375004:	d8 21 00 40 	
40375008:	71 8e ff ff 	
4037500c:	6b 23 c9 3f 	
40375010:	85 23 c9 3f 	
40375014:	16 40 5e 00 	
40375018:	60 09 00 40 	
4037501c:	ea bf 37 ff 	
40375020:	18 40 20 00 	
40375024:	16 40 20 00 	
40375028:	e9 bf 37 ff 	
4037502c:	85 25 c9 3f 	
40375030:	7c 34 c9 3f 	
40375034:	78 34 c9 3f 	
40375038:	e4 18 00 40 	
4037503c:	fc 18 00 40 	
40375040:	08 19 00 40 	
40375044:	f0 18 00 40 	
40375048:	03 00 06 00 	
4037504c:	e5 25 c9 3f 	
40375050:	28 26 c9 3f 	
40375054:	14 26 c9 3f 	
40375058:	00 00 00 80 	

4037505c <esp_app_get_elf_sha256>:
 * can lead to a complete lock-up of the CPU.
 * For this reason we do a reading of esp_app_desc.app_elf_sha256 while start up in esp_init_app_elf_sha256()
 * and keep it in the static s_app_elf_sha256 value.
 */
int IRAM_ATTR esp_app_get_elf_sha256(char* dst, size_t size)
{
4037505c:	004136        	entry	a1, 32
    static char s_app_elf_sha256[CONFIG_APP_RETRIEVE_LEN_ELF_SHA / 2];
    static bool first_call = true;
    if (first_call) {
4037505f:	fce981        	l32r	a8, 40374404 <_iram_text_start>
40375062:	000892        	l8ui	a9, a8, 0
40375065:	49ac      	beqz.n	a9, 4037508d <esp_app_get_elf_sha256+0x31>
        first_call = false;
40375067:	090c      	movi.n	a9, 0
40375069:	004892        	s8i	a9, a8, 0
        // At -O2 optimization level, GCC optimizes out the copying of the first byte of the app_elf_sha256,
        // because it is zero at compile time, and only modified afterwards by esptool.
        // Casting to volatile disables the optimization.
        const volatile uint8_t* src = (const volatile uint8_t*)esp_app_desc.app_elf_sha256;
        for (size_t i = 0; i < sizeof(s_app_elf_sha256); ++i) {
4037506c:	fce791        	l32r	a9, 40374408 <_iram_text_start+0x4>
4037506f:	90a0a2        	movi	a10, 144
            s_app_elf_sha256[i] = src[i];
40375072:	fce6d1        	l32r	a13, 4037440c <_iram_text_start+0x8>
40375075:	aa9a      	add.n	a10, a10, a9
        for (size_t i = 0; i < sizeof(s_app_elf_sha256); ++i) {
40375077:	080c      	movi.n	a8, 0
            s_app_elf_sha256[i] = src[i];
40375079:	890c      	movi.n	a9, 8
4037507b:	0e8976        	loop	a9, 4037508d <esp_app_get_elf_sha256+0x31>
4037507e:	ba8a      	add.n	a11, a10, a8
40375080:	0020c0        	memw
40375083:	000bc2        	l8ui	a12, a11, 0
40375086:	b8da      	add.n	a11, a8, a13
40375088:	004bc2        	s8i	a12, a11, 0
        for (size_t i = 0; i < sizeof(s_app_elf_sha256); ++i) {
4037508b:	881b      	addi.n	a8, a8, 1
        }
    }
    if (dst == NULL || size == 0) {
4037508d:	180c      	movi.n	a8, 1
4037508f:	090c      	movi.n	a9, 0
40375091:	839820        	moveqz	a9, a8, a2
40375094:	74a090        	extui	a10, a9, 0, 8
40375097:	052956        	bnez	a9, 403750ed <esp_app_get_elf_sha256+0x91>
4037509a:	938a30        	movnez	a8, a10, a3
4037509d:	04c856        	bnez	a8, 403750ed <esp_app_get_elf_sha256+0x91>
        return 0;
    }
    size_t n = MIN((size - 1) / 2, sizeof(s_app_elf_sha256));
403750a0:	330b      	addi.n	a3, a3, -1
403750a2:	f90c      	movi.n	a9, 15
403750a4:	880c      	movi.n	a8, 8
403750a6:	023937        	bltu	a9, a3, 403750ac <esp_app_get_elf_sha256+0x50>
403750a9:	418130        	srli	a8, a3, 1
    for (size_t i = 0; i < n; ++i) {
403750ac:	fcd8a1        	l32r	a10, 4037440c <_iram_text_start+0x8>
403750af:	388a      	add.n	a3, a8, a8
403750b1:	909820        	addx2	a9, a8, a2
    return (val < 10) ? ('0' + val) : ('a' + val - 10);
403750b4:	9c0c      	movi.n	a12, 9
    for (size_t i = 0; i < n; ++i) {
403750b6:	0b9297        	bne	a2, a9, 403750c5 <esp_app_get_elf_sha256+0x69>
        dst[2*i] = to_hex_digit(s_app_elf_sha256[i] >> 4);
        dst[2*i + 1] = to_hex_digit(s_app_elf_sha256[i] & 0xf);
    }
    dst[2*n] = 0;
403750b9:	080c      	movi.n	a8, 0
403750bb:	004282        	s8i	a8, a2, 0
    return 2*n + 1;
403750be:	231b      	addi.n	a2, a3, 1
}
403750c0:	f01d      	retw.n
403750c2:	00          	.byte 00
403750c3:	00          	.byte 00
403750c4:	00          	.byte 00
        dst[2*i] = to_hex_digit(s_app_elf_sha256[i] >> 4);
403750c5:	000a82        	l8ui	a8, a10, 0
403750c8:	41b480        	srli	a11, a8, 4
    return (val < 10) ? ('0' + val) : ('a' + val - 10);
403750cb:	57cbd2        	addi	a13, a11, 87
403750ce:	023cb7        	bltu	a12, a11, 403750d4 <esp_app_get_elf_sha256+0x78>
403750d1:	30cbd2        	addi	a13, a11, 48
403750d4:	348080        	extui	a8, a8, 0, 4
        dst[2*i] = to_hex_digit(s_app_elf_sha256[i] >> 4);
403750d7:	0042d2        	s8i	a13, a2, 0
    return (val < 10) ? ('0' + val) : ('a' + val - 10);
403750da:	57c8b2        	addi	a11, a8, 87
403750dd:	023c87        	bltu	a12, a8, 403750e3 <esp_app_get_elf_sha256+0x87>
403750e0:	30c8b2        	addi	a11, a8, 48
        dst[2*i + 1] = to_hex_digit(s_app_elf_sha256[i] & 0xf);
403750e3:	0142b2        	s8i	a11, a2, 1
    for (size_t i = 0; i < n; ++i) {
403750e6:	aa1b      	addi.n	a10, a10, 1
403750e8:	222b      	addi.n	a2, a2, 2
403750ea:	fff206        	j	403750b6 <esp_app_get_elf_sha256+0x5a>
        return 0;
403750ed:	020c      	movi.n	a2, 0
403750ef:	fff346        	j	403750c0 <esp_app_get_elf_sha256+0x64>
	...

403750f4 <call_start_cpu1>:
{
    s_resume_cores = true;
}

void IRAM_ATTR call_start_cpu1(void)
{
403750f4:	004136        	entry	a1, 32

// --------------- Interrupt Configuration -----------------

FORCE_INLINE_ATTR void xt_utils_set_vecbase(uint32_t vecbase)
{
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
403750f7:	fcc621        	l32r	a2, 40374410 <_iram_text_start+0xc>
403750fa:	13e720        	wsr.vecbase	a2
    esp_cpu_intr_set_ivt_addr(&_vector_table);

    ets_set_appcpu_boot_addr(0);
403750fd:	0a0c      	movi.n	a10, 0
403750ff:	fccb81        	l32r	a8, 4037442c <_iram_text_start+0x28>
40375102:	0008e0        	callx8	a8

    bootloader_init_mem();
40375105:	fcca81        	l32r	a8, 40374430 <_iram_text_start+0x2c>
40375108:	0008e0        	callx8	a8

#if CONFIG_ESP_CONSOLE_NONE
    esp_rom_install_channel_putc(1, NULL);
    esp_rom_install_channel_putc(2, NULL);
#else // CONFIG_ESP_CONSOLE_NONE
    esp_rom_install_uart_printf();
4037510b:	00a425        	call8	40375b4c <esp_rom_install_uart_printf>
    esp_rom_uart_set_as_console(CONFIG_ESP_CONSOLE_UART_NUM);
4037510e:	0a0c      	movi.n	a10, 0
40375110:	fcc981        	l32r	a8, 40374434 <_iram_text_start+0x30>
40375113:	0008e0        	callx8	a8

#if CONFIG_IDF_TARGET_ESP32
    DPORT_REG_SET_BIT(DPORT_APP_CPU_RECORD_CTRL_REG, DPORT_APP_CPU_PDEBUG_ENABLE | DPORT_APP_CPU_RECORD_ENABLE);
    DPORT_REG_CLR_BIT(DPORT_APP_CPU_RECORD_CTRL_REG, DPORT_APP_CPU_RECORD_ENABLE);
#else
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_PDEBUGENABLE_REG, 1);
40375116:	fcbf81        	l32r	a8, 40374414 <_iram_text_start+0x10>
40375119:	120c      	movi.n	a2, 1
4037511b:	0020c0        	memw
4037511e:	0829      	s32i.n	a2, a8, 0
    REG_WRITE(ASSIST_DEBUG_CORE_1_RCD_RECORDING_REG, 1);
40375120:	fcbe81        	l32r	a8, 40374418 <_iram_text_start+0x14>
40375123:	0020c0        	memw
40375126:	006822        	s32i	a2, a8, 0
#endif

    s_cpu_up[1] = true;
40375129:	fcbc81        	l32r	a8, 4037441c <_iram_text_start+0x18>
4037512c:	0020c0        	memw
4037512f:	014822        	s8i	a2, a8, 1
    ESP_EARLY_LOGI(TAG, "App cpu up.");

    // Clear interrupt matrix for APP CPU core
    core_intr_matrix_clear();
40375132:	fcc181        	l32r	a8, 40374438 <_iram_text_start+0x34>
40375135:	0008e0        	callx8	a8

    //Take care putting stuff here: if asked, FreeRTOS will happily tell you the scheduler
    //has started, but it isn't active *on this CPU* yet.
    esp_cache_err_int_init();
40375138:	fcc181        	l32r	a8, 4037443c <_iram_text_start+0x38>
4037513b:	0008e0        	callx8	a8
#if (CONFIG_IDF_TARGET_ESP32 && CONFIG_ESP32_TRAX_TWOBANKS) || \
    (CONFIG_IDF_TARGET_ESP32S3 && CONFIG_ESP32S3_TRAX_TWOBANKS)
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif

    s_cpu_inited[1] = true;
4037513e:	fcb881        	l32r	a8, 40374420 <_iram_text_start+0x1c>
40375141:	0020c0        	memw
40375144:	014822        	s8i	a2, a8, 1

    while (!s_resume_cores) {
40375147:	fcb731        	l32r	a3, 40374424 <_iram_text_start+0x20>
4037514a:	0020c0        	memw
4037514d:	000322        	l8ui	a2, a3, 0
40375150:	742020        	extui	a2, a2, 0, 8
40375153:	129c      	beqz.n	a2, 40375168 <call_start_cpu1+0x74>
    asm volatile (
40375155:	03eb20        	rsr.prid	a2
40375158:	042d20        	extui	a2, a2, 13, 1
        esp_rom_delay_us(100);
    }

    SYS_STARTUP_FN();
4037515b:	fcb381        	l32r	a8, 40374428 <_iram_text_start+0x24>
4037515e:	a02280        	addx4	a2, a2, a8
40375161:	0228      	l32i.n	a2, a2, 0
40375163:	0002e0        	callx8	a2
}
40375166:	f01d      	retw.n
        esp_rom_delay_us(100);
40375168:	64a0a2        	movi	a10, 100
4037516b:	fcb581        	l32r	a8, 40374440 <_iram_text_start+0x3c>
4037516e:	0008e0        	callx8	a8
40375171:	fff486        	j	40375147 <call_start_cpu1+0x53>

40375174 <call_start_cpu0>:
/*
 * We arrive here after the bootloader finished loading the program from flash. The hardware is mostly uninitialized,
 * and the app CPU is in reset. We do have a stack, so we can do the initialization in C.
 */
void IRAM_ATTR call_start_cpu0(void)
{
40375174:	00c136        	entry	a1, 96
    asm volatile ("wsr %0, vecbase" :: "r" (vecbase));
40375177:	fca621        	l32r	a2, 40374410 <_iram_text_start+0xc>
4037517a:	13e720        	wsr.vecbase	a2
#endif

    // Move exception vectors to IRAM
    esp_cpu_intr_set_ivt_addr(&_vector_table);

    rst_reas[0] = esp_rom_get_reset_reason(0);
4037517d:	00a0a2        	movi	a10, 0
40375180:	fcbc81        	l32r	a8, 40374470 <_iram_text_start+0x6c>
40375183:	0008e0        	callx8	a8
40375186:	0a4d      	mov.n	a4, a10
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    rst_reas[1] = esp_rom_get_reset_reason(1);
40375188:	1a0c      	movi.n	a10, 1
4037518a:	fcb981        	l32r	a8, 40374470 <_iram_text_start+0x6c>
4037518d:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
    }
#endif

    //Clear BSS. Please do not attempt to do any complex stuff (like early logging) before this.
    memset(&_bss_start, 0, (&_bss_end - &_bss_start) * sizeof(_bss_start));
40375190:	fcaea1        	l32r	a10, 40374448 <_iram_text_start+0x44>
40375193:	fcacc1        	l32r	a12, 40374444 <_iram_text_start+0x40>
40375196:	0b0c      	movi.n	a11, 0
40375198:	c0cca0        	sub	a12, a12, a10
4037519b:	fcb681        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037519e:	0008e0        	callx8	a8
    memset(&_iram_bss_start, 0, (&_iram_bss_end - &_iram_bss_start) * sizeof(_iram_bss_start));
#endif

#if SOC_RTC_FAST_MEM_SUPPORTED || SOC_RTC_SLOW_MEM_SUPPORTED
    /* Unless waking from deep sleep (implying RTC memory is intact), clear RTC bss */
    if (rst_reas[0] != RESET_REASON_CORE_DEEP_SLEEP) {
403751a1:	105426        	beqi	a4, 5, 403751b5 <call_start_cpu0+0x41>
        memset(&_rtc_bss_start, 0, (&_rtc_bss_end - &_rtc_bss_start) * sizeof(_rtc_bss_start));
403751a4:	fcaba1        	l32r	a10, 40374450 <_iram_text_start+0x4c>
403751a7:	fca9c1        	l32r	a12, 4037444c <_iram_text_start+0x48>
403751aa:	0b0c      	movi.n	a11, 0
403751ac:	c0cca0        	sub	a12, a12, a10
403751af:	fcb181        	l32r	a8, 40374474 <_iram_text_start+0x70>
403751b2:	0008e0        	callx8	a8
#endif

#if CONFIG_IDF_TARGET_ESP32S3
    /* Configure the mode of instruction cache : cache size, cache line size. */
    extern void rom_config_instruction_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_instruction_cache_mode(CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE, CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE);
403751b5:	01a0a2        	movi	a10, 1
403751b8:	20a0c2        	movi	a12, 32
403751bb:	08a0b2        	movi	a11, 8
403751be:	11aa20        	slli	a10, a10, 14
403751c1:	fcad81        	l32r	a8, 40374478 <_iram_text_start+0x74>
403751c4:	0008e0        	callx8	a8

    /* If we need use SPIRAM, we should use data cache.
       Configure the mode of data : cache size, cache line size.*/
    Cache_Suspend_DCache();
403751c7:	fcad81        	l32r	a8, 4037447c <_iram_text_start+0x78>
403751ca:	0008e0        	callx8	a8
    extern void rom_config_data_cache_mode(uint32_t cfg_cache_size, uint8_t cfg_cache_ways, uint8_t cfg_cache_line_size);
    rom_config_data_cache_mode(CONFIG_ESP32S3_DATA_CACHE_SIZE, CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS, CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE);
403751cd:	1a0c      	movi.n	a10, 1
403751cf:	0c2c      	movi.n	a12, 32
403751d1:	8b0c      	movi.n	a11, 8
403751d3:	11aa10        	slli	a10, a10, 15
403751d6:	fcaa81        	l32r	a8, 40374480 <_iram_text_start+0x7c>
403751d9:	0008e0        	callx8	a8
    Cache_Resume_DCache(0);
403751dc:	0a0c      	movi.n	a10, 0
403751de:	fca981        	l32r	a8, 40374484 <_iram_text_start+0x80>
403751e1:	0008e0        	callx8	a8
#endif // CONFIG_IDF_TARGET_ESP32S3

    if (esp_efuse_check_errors() != ESP_OK) {
403751e4:	fca981        	l32r	a8, 40374488 <_iram_text_start+0x84>
403751e7:	0008e0        	callx8	a8
403751ea:	002a16        	beqz	a10, 403751f0 <call_start_cpu0+0x7c>
        esp_restart();
403751ed:	003ce5        	call8	403755bc <esp_restart>

#if CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    /* Configure the Cache MMU size for instruction and rodata in flash. */
    extern uint32_t Cache_Set_IDROM_MMU_Size(uint32_t irom_size, uint32_t drom_size);
    extern int _rodata_reserved_start;
    uint32_t rodata_reserved_start_align = (uint32_t)&_rodata_reserved_start & ~(SPI_FLASH_MMU_PAGE_SIZE - 1);
403751f0:	fc9931        	l32r	a3, 40374454 <_iram_text_start+0x50>
403751f3:	f27c      	movi.n	a2, -1
403751f5:	112200        	slli	a2, a2, 16
    uint32_t cache_mmu_irom_size = ((rodata_reserved_start_align - SOC_DROM_LOW) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
403751f8:	1a7c      	movi.n	a10, -15
    uint32_t rodata_reserved_start_align = (uint32_t)&_rodata_reserved_start & ~(SPI_FLASH_MMU_PAGE_SIZE - 1);
403751fa:	102320        	and	a2, a3, a2
    uint32_t cache_mmu_irom_size = ((rodata_reserved_start_align - SOC_DROM_LOW) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
403751fd:	01aa60        	slli	a10, a10, 26
40375200:	a2aa      	add.n	a10, a2, a10
40375202:	f570a0        	extui	a7, a10, 16, 16
#if CONFIG_IDF_TARGET_ESP32S3
    extern int _rodata_reserved_end;
    uint32_t cache_mmu_drom_size = (((uint32_t)&_rodata_reserved_end - rodata_reserved_start_align + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
#endif

    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
40375205:	00a4b2        	movi	a11, 0x400
    uint32_t cache_mmu_irom_size = ((rodata_reserved_start_align - SOC_DROM_LOW) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375208:	41aea0        	srli	a10, a10, 14
    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
4037520b:	c0bba0        	sub	a11, a11, a10
    uint32_t cache_mmu_drom_size = (((uint32_t)&_rodata_reserved_end - rodata_reserved_start_align + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
4037520e:	fc9331        	l32r	a3, 4037445c <_iram_text_start+0x58>
40375211:	fc9151        	l32r	a5, 40374458 <_iram_text_start+0x54>
    Cache_Set_IDROM_MMU_Size(cache_mmu_irom_size, CACHE_DROM_MMU_MAX_END - cache_mmu_irom_size);
40375214:	fc9e81        	l32r	a8, 4037448c <_iram_text_start+0x88>
40375217:	0008e0        	callx8	a8
    if (!efuse_opflash_en) {
        ESP_EARLY_LOGE(TAG, "Octal Flash option selected, but EFUSE not configured!");
        abort();
    }
#endif
    esp_mspi_pin_init();
4037521a:	02fee5        	call8	40378208 <esp_mspi_pin_init>
    // For Octal flash, it's hard to implement a read_id function in OPI mode for all vendors.
    // So we have to read it here in SPI mode, before entering the OPI mode.
    bootloader_flash_update_id();
4037521d:	fc9c81        	l32r	a8, 40374490 <_iram_text_start+0x8c>
40375220:	0008e0        	callx8	a8
     *
     * In bootloader, we only init Flash (and MSPI) to a preliminary state, for being flexible to
     * different chips.
     * In this stage, we re-configure the Flash (and MSPI) to required configuration
     */
    spi_flash_init_chip_state();
40375223:	029c65        	call8	40377be8 <spi_flash_init_chip_state>
    uint32_t cache_mmu_drom_size = (((uint32_t)&_rodata_reserved_end - rodata_reserved_start_align + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
40375226:	353a      	add.n	a3, a5, a3
#if CONFIG_IDF_TARGET_ESP32S3
    //On other chips, this feature is not provided by HW, or hasn't been tested yet.
    spi_timing_flash_tuning();
40375228:	0b06a5        	call8	40380294 <spi_timing_flash_tuning>
    uint32_t cache_mmu_drom_size = (((uint32_t)&_rodata_reserved_end - rodata_reserved_start_align + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
4037522b:	c02320        	sub	a2, a3, a2
#endif

    bootloader_init_mem();
4037522e:	fc8081        	l32r	a8, 40374430 <_iram_text_start+0x2c>
40375231:	0008e0        	callx8	a8
#endif
    }
#endif

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_up[0] = true;
40375234:	fc7a31        	l32r	a3, 4037441c <_iram_text_start+0x18>
40375237:	180c      	movi.n	a8, 1
40375239:	0020c0        	memw
4037523c:	004382        	s8i	a8, a3, 0
    esp_chip_info(&chip_info);
4037523f:	01ad      	mov.n	a10, a1
40375241:	fc9481        	l32r	a8, 40374494 <_iram_text_start+0x90>
40375244:	0008e0        	callx8	a8
    if (!(chip_info.cores > 1)) {
40375247:	0a0182        	l8ui	a8, a1, 10
    uint32_t cache_mmu_drom_size = (((uint32_t)&_rodata_reserved_end - rodata_reserved_start_align + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE) * sizeof(uint32_t);
4037524a:	f52020        	extui	a2, a2, 16, 16
    if (!(chip_info.cores > 1)) {
4037524d:	0228f6        	bgeui	a8, 2, 40375253 <call_start_cpu0+0xdf>
        abort();
40375250:	0952a5        	call8	4037e77c <abort>
    esp_cpu_unstall(1);
40375253:	1a0c      	movi.n	a10, 1
40375255:	030d25        	call8	40378328 <esp_cpu_unstall>
    if (!REG_GET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN)) {
40375258:	fc8281        	l32r	a8, 40374460 <_iram_text_start+0x5c>
4037525b:	2a0c      	movi.n	a10, 2
4037525d:	0020c0        	memw
40375260:	0898      	l32i.n	a9, a8, 0
40375262:	3a89a7        	bany	a9, a10, 403752a0 <call_start_cpu0+0x12c>
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_CLKGATE_EN);
40375265:	0020c0        	memw
40375268:	0898      	l32i.n	a9, a8, 0
4037526a:	2099a0        	or	a9, a9, a10
4037526d:	0020c0        	memw
40375270:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RUNSTALL);
40375272:	0020c0        	memw
40375275:	0898      	l32i.n	a9, a8, 0
40375277:	ea7c      	movi.n	a10, -2
40375279:	1099a0        	and	a9, a9, a10
4037527c:	0020c0        	memw
4037527f:	0899      	s32i.n	a9, a8, 0
        REG_SET_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
40375281:	0020c0        	memw
40375284:	0898      	l32i.n	a9, a8, 0
40375286:	4a0c      	movi.n	a10, 4
40375288:	2099a0        	or	a9, a9, a10
4037528b:	0020c0        	memw
4037528e:	0899      	s32i.n	a9, a8, 0
        REG_CLR_BIT(SYSTEM_CORE_1_CONTROL_0_REG, SYSTEM_CONTROL_CORE_1_RESETING);
40375290:	0020c0        	memw
40375293:	0898      	l32i.n	a9, a8, 0
40375295:	ba7c      	movi.n	a10, -5
40375297:	1099a0        	and	a9, a9, a10
4037529a:	0020c0        	memw
4037529d:	006892        	s32i	a9, a8, 0
    ets_set_appcpu_boot_addr((uint32_t)call_start_cpu1);
403752a0:	fc71a1        	l32r	a10, 40374464 <_iram_text_start+0x60>
        esp_rom_delay_us(100);
403752a3:	64a062        	movi	a6, 100
    ets_set_appcpu_boot_addr((uint32_t)call_start_cpu1);
403752a6:	fc6181        	l32r	a8, 4037442c <_iram_text_start+0x28>
403752a9:	0008e0        	callx8	a8
            cpus_up &= s_cpu_up[i];
403752ac:	0020c0        	memw
403752af:	0003a2        	l8ui	a10, a3, 0
403752b2:	0020c0        	memw
403752b5:	010382        	l8ui	a8, a3, 1
403752b8:	748080        	extui	a8, a8, 0, 8
403752bb:	1058a0        	and	a5, a8, a10
        esp_rom_delay_us(100);
403752be:	20a660        	or	a10, a6, a6
403752c1:	fc5f81        	l32r	a8, 40374440 <_iram_text_start+0x3c>
403752c4:	0008e0        	callx8	a8
    while (!cpus_up) {
403752c7:	fe1516        	beqz	a5, 403752ac <call_start_cpu0+0x138>
    extern int rodata_flash2spiram_offset(void);
    s_rodata_flash2spiram_off = rodata_flash2spiram_offset();
#endif

    extern void Cache_Set_IDROM_MMU_Info(uint32_t instr_page_num, uint32_t rodata_page_num, uint32_t rodata_start, uint32_t rodata_end, int i_off, int ro_off);
    Cache_Set_IDROM_MMU_Info(cache_mmu_irom_size / sizeof(uint32_t), \
403752ca:	fc62c1        	l32r	a12, 40374454 <_iram_text_start+0x50>
403752cd:	0f0c      	movi.n	a15, 0
403752cf:	fc62d1        	l32r	a13, 40374458 <_iram_text_start+0x54>
403752d2:	0fed      	mov.n	a14, a15
403752d4:	02bd      	mov.n	a11, a2
403752d6:	07ad      	mov.n	a10, a7
403752d8:	fc7081        	l32r	a8, 40374498 <_iram_text_start+0x94>
403752db:	0008e0        	callx8	a8
    trax_enable(TRAX_ENA_PRO);
#endif
    trax_start_trace(TRAX_DOWNCOUNT_WORDS);
#endif // CONFIG_ESP32_TRAX || CONFIG_ESP32S2_TRAX || CONFIG_ESP32S3_TRAX

    esp_clk_init();
403752de:	fc6f81        	l32r	a8, 4037449c <_iram_text_start+0x98>
403752e1:	0008e0        	callx8	a8
    esp_perip_clk_init();
403752e4:	fc6f81        	l32r	a8, 403744a0 <_iram_text_start+0x9c>
403752e7:	0008e0        	callx8	a8

    // Now that the clocks have been set-up, set the startup time from RTC
    // and default RTC-backed system time provider.
    g_startup_time = esp_rtc_get_time_us();
403752ea:	fc6e81        	l32r	a8, 403744a4 <_iram_text_start+0xa0>
403752ed:	0008e0        	callx8	a8
403752f0:	fc5e21        	l32r	a2, 40374468 <_iram_text_start+0x64>
403752f3:	12b9      	s32i.n	a11, a2, 4
403752f5:	0062a2        	s32i	a10, a2, 0

    // Clear interrupt matrix for PRO CPU core
    core_intr_matrix_clear();
403752f8:	fc5081        	l32r	a8, 40374438 <_iram_text_start+0x34>
403752fb:	0008e0        	callx8	a8

#ifndef CONFIG_IDF_ENV_FPGA // TODO: on FPGA it should be possible to configure this, not currently working with APB_CLK_FREQ changed
#ifdef CONFIG_ESP_CONSOLE_UART
    uint32_t clock_hz = esp_clk_apb_freq();
403752fe:	00ca65        	call8	40375fa4 <esp_clk_apb_freq>
#if ESP_ROM_UART_CLK_IS_XTAL
    clock_hz = esp_clk_xtal_freq(); // From esp32-s3 on, UART clock source is selected to XTAL in ROM
40375301:	00cc65        	call8	40375fc8 <esp_clk_xtal_freq>
40375304:	0a2d      	mov.n	a2, a10
#endif
    esp_rom_uart_tx_wait_idle(CONFIG_ESP_CONSOLE_UART_NUM);
40375306:	00a0a2        	movi	a10, 0
40375309:	fc6781        	l32r	a8, 403744a8 <_iram_text_start+0xa4>
4037530c:	0008e0        	callx8	a8
    esp_rom_uart_set_clock_baudrate(CONFIG_ESP_CONSOLE_UART_NUM, clock_hz, CONFIG_ESP_CONSOLE_UART_BAUDRATE);
4037530f:	e1a0c2        	movi	a12, 225
40375312:	11cc70        	slli	a12, a12, 9
40375315:	02bd      	mov.n	a11, a2
40375317:	0a0c      	movi.n	a10, 0
40375319:	0084e5        	call8	40375b68 <esp_rom_uart_set_clock_baudrate>
#endif
#endif

    // Need to unhold the IOs that were hold right before entering deep sleep, which are used as wakeup pins
    if (rst_reas[0] == RESET_REASON_CORE_DEEP_SLEEP) {
4037531c:	055466        	bnei	a4, 5, 40375325 <call_start_cpu0+0x1b1>
        esp_deep_sleep_wakeup_io_reset();
4037531f:	fc6381        	l32r	a8, 403744ac <_iram_text_start+0xa8>
40375322:	0008e0        	callx8	a8
    }

    esp_cache_err_int_init();
40375325:	fc4581        	l32r	a8, 4037443c <_iram_text_start+0x38>
40375328:	0008e0        	callx8	a8
    // If such a situation appears, it is likely an malicious attempt to bypass the system safety setup -> print error & reset

#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_locked_any()) {
#else
    bool is_locked = false;
4037532b:	00a022        	movi	a2, 0
    if (esp_mprot_is_conf_locked_any(&is_locked) != ESP_OK || is_locked) {
4037532e:	31c1a2        	addi	a10, a1, 49
    bool is_locked = false;
40375331:	314122        	s8i	a2, a1, 49
    if (esp_mprot_is_conf_locked_any(&is_locked) != ESP_OK || is_locked) {
40375334:	011365        	call8	4037646c <esp_mprot_is_conf_locked_any>
40375337:	005a56        	bnez	a10, 40375340 <call_start_cpu0+0x1cc>
4037533a:	310122        	l8ui	a2, a1, 49
4037533d:	005216        	beqz	a2, 40375346 <call_start_cpu0+0x1d2>
#endif
        ESP_EARLY_LOGE(TAG, "Memprot feature locked after the system reset! Potential safety corruption, rebooting.");
        esp_restart_noos_dig();
40375340:	201110        	or	a1, a1, a1
40375343:	002325        	call8	40375574 <esp_restart_noos_dig>
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_LOCK, NULL);
#else
    memp_err = esp_memprot_set_prot(PANIC_HNDL_ON, MEMPROT_UNLOCK, NULL);
#endif
#else //CONFIG_IDF_TARGET_ESP32S2 specific end
    esp_memp_config_t memp_cfg = ESP_MEMPROT_DEFAULT_CONFIG();
40375346:	8c1c      	movi.n	a12, 24
40375348:	fc49b1        	l32r	a11, 4037446c <_iram_text_start+0x68>
4037534b:	80a1c0        	add	a10, a1, a12
4037534e:	fc5881        	l32r	a8, 403744b0 <_iram_text_start+0xac>
40375351:	0008e0        	callx8	a8
#if !CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK
    memp_cfg.lock_feature = false;
#endif
    memp_err = esp_mprot_set_prot(&memp_cfg);
40375354:	18c1a2        	addi	a10, a1, 24
40375357:	fc5781        	l32r	a8, 403744b4 <_iram_text_start+0xb0>
4037535a:	0008e0        	callx8	a8
4037535d:	0a2d      	mov.n	a2, a10
#endif //other IDF_TARGETS end

    if (memp_err != ESP_OK) {
4037535f:	fdda56        	bnez	a10, 40375340 <call_start_cpu0+0x1cc>
        esp_restart_noos_dig();
    }
#endif //CONFIG_ESP_SYSTEM_MEMPROT_FEATURE && !CONFIG_ESP_SYSTEM_MEMPROT_TEST

    // Read the application binary image header. This will also decrypt the header if the image is encrypted.
    __attribute__((unused)) esp_image_header_t fhdr = {0};
40375362:	0abd      	mov.n	a11, a10
40375364:	8c1c      	movi.n	a12, 24
40375366:	01ad      	mov.n	a10, a1
40375368:	fc4381        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037536b:	0008e0        	callx8	a8
#pragma GCC diagnostic push
#if     __GNUC__ >= 11
#pragma GCC diagnostic ignored "-Wstringop-overread"
#endif
#pragma GCC diagnostic ignored "-Warray-bounds"
    memcpy(&fhdr, (void *) SOC_DROM_LOW, sizeof(fhdr));
4037536e:	fb0c      	movi.n	a11, 15
40375370:	8c1c      	movi.n	a12, 24
40375372:	01bb60        	slli	a11, a11, 26
40375375:	01ad      	mov.n	a10, a1
40375377:	fc4e81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037537a:	0008e0        	callx8	a8
    }
    bootloader_flash_update_size(app_flash_size);
#endif //CONFIG_SPI_FLASH_SIZE_OVERRIDE

#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_cpu_inited[0] = true;
4037537d:	fc2831        	l32r	a3, 40374420 <_iram_text_start+0x1c>
40375380:	140c      	movi.n	a4, 1
40375382:	0020c0        	memw
40375385:	004342        	s8i	a4, a3, 0

    volatile bool cpus_inited = false;
40375388:	0020c0        	memw
4037538b:	304122        	s8i	a2, a1, 48

    while (!cpus_inited) {
4037538e:	0020c0        	memw
40375391:	300122        	l8ui	a2, a1, 48
40375394:	742020        	extui	a2, a2, 0, 8
40375397:	229c      	beqz.n	a2, 403753ad <call_start_cpu0+0x239>
    asm volatile (
40375399:	03eb20        	rsr.prid	a2
4037539c:	042d20        	extui	a2, a2, 13, 1
        }
        esp_rom_delay_us(100);
    }
#endif

    SYS_STARTUP_FN();
4037539f:	fc2231        	l32r	a3, 40374428 <_iram_text_start+0x24>
403753a2:	a02230        	addx4	a2, a2, a3
403753a5:	0228      	l32i.n	a2, a2, 0
403753a7:	0002e0        	callx8	a2
}
403753aa:	f01d      	retw.n
403753ac:	00          	.byte 00
        cpus_inited = true;
403753ad:	0020c0        	memw
403753b0:	304142        	s8i	a4, a1, 48
            cpus_inited &= s_cpu_inited[i];
403753b3:	0020c0        	memw
403753b6:	000352        	l8ui	a5, a3, 0
403753b9:	0020c0        	memw
403753bc:	300122        	l8ui	a2, a1, 48
        esp_rom_delay_us(100);
403753bf:	64a0a2        	movi	a10, 100
            cpus_inited &= s_cpu_inited[i];
403753c2:	742020        	extui	a2, a2, 0, 8
403753c5:	102250        	and	a2, a2, a5
403753c8:	0020c0        	memw
403753cb:	304122        	s8i	a2, a1, 48
403753ce:	0020c0        	memw
403753d1:	010352        	l8ui	a5, a3, 1
403753d4:	0020c0        	memw
403753d7:	300122        	l8ui	a2, a1, 48
403753da:	742020        	extui	a2, a2, 0, 8
403753dd:	102250        	and	a2, a2, a5
403753e0:	0020c0        	memw
403753e3:	304122        	s8i	a2, a1, 48
        esp_rom_delay_us(100);
403753e6:	fc1681        	l32r	a8, 40374440 <_iram_text_start+0x3c>
403753e9:	0008e0        	callx8	a8
403753ec:	ffe786        	j	4037538e <call_start_cpu0+0x21a>
	...

403753f0 <xt_highint4>:
    .align      4
xt_highint4:

#ifndef CONFIG_FREERTOS_UNICORE
    /* See if we're here for the IPC_ISR interrupt */
    rsr     a0, INTERRUPT
403753f0:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_IPC_ISR_INUM, 1
403753f3:	050c00        	extui	a0, a0, 28, 1
    bnez    a0, jump_to_esp_ipc_isr_handler
403753f6:	07f056        	bnez	a0, 40375479 <jump_to_esp_ipc_isr_handler>
#endif // not CONFIG_FREERTOS_UNICORE

    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
403753f9:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
403753fb:	ffd112        	addmi	a1, a1, 0xffffff00
403753fe:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40375401:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
40375403:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
40375406:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40375409:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_4                       /* save interruptee's PC */
4037540b:	03b400        	rsr.epc4	a0
    s32i    a0, sp, XT_STK_PC
4037540e:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_4                   /* save interruptee's a0 */
40375410:	03d400        	rsr.excsave4	a0
    s32i    a0, sp, XT_STK_A0
40375413:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
40375415:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
40375418:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
4037541a:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
4037541d:	04c705        	call0	4037a090 <_xt_context_save>

    /* Save vaddr into exception frame */
    rsr     a0, EXCVADDR
40375420:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40375423:	156102        	s32i	a0, a1, 84

    /* Figure out reason, save into EXCCAUSE reg */

    rsr     a0, INTERRUPT
40375426:	03e200        	rsr.interrupt	a0
    extui   a0, a0, ETS_CACHEERR_INUM, 1 /* get cacheerr int bit */
40375429:	050900        	extui	a0, a0, 25, 1
    beqz    a0, 1f
4037542c:	009c      	beqz.n	a0, 40375440 <xt_highint4+0x50>
    /* Kill this interrupt; we cannot reset it. */
    rsr     a0, INTENABLE
4037542e:	03e400        	rsr.intenable	a0
    movi    a4, ~(1<<ETS_CACHEERR_INUM)
40375431:	fc2141        	l32r	a4, 403744b8 <_iram_text_start+0xb4>
    and     a0, a4, a0
40375434:	100400        	and	a0, a4, a0
    wsr     a0, INTENABLE
40375437:	13e400        	wsr.intenable	a0
    movi    a0, PANIC_RSN_CACHEERR
4037543a:	700c      	movi.n	a0, 7
    j 9f
4037543c:	000406        	j	40375450 <xt_highint4+0x60>
4037543f:	00          	.byte 00

1:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    /* Check if the cause is the app cpu failing to tick.*/
    movi    a0, int_wdt_cpu1_ticked
40375440:	fc1f01        	l32r	a0, 403744bc <_iram_text_start+0xb8>
    l32i    a0, a0, 0
40375443:	0008      	l32i.n	a0, a0, 0
    bnez    a0, 2f
40375445:	40cc      	bnez.n	a0, 4037544d <xt_highint4+0x5d>
    /* It is. Modify cause. */
    movi    a0,PANIC_RSN_INTWDT_CPU1
40375447:	600c      	movi.n	a0, 6
    j 9f
40375449:	0000c6        	j	40375450 <xt_highint4+0x60>
4037544c:	00          	.byte 00
2:
#endif

    /* Set EXCCAUSE to reflect cause of the wdt int trigger */
    movi    a0,PANIC_RSN_INTWDT_CPU0
4037544d:	05a002        	movi	a0, 5
9:
    /* Found the reason, now save it. */
    s32i    a0, sp, XT_STK_EXCCAUSE
40375450:	146102        	s32i	a0, a1, 80

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(5) | PS_UM | PS_WOE
40375453:	fc1b01        	l32r	a0, 403744c0 <_iram_text_start+0xbc>
    wsr     a0, PS
40375456:	13e600        	wsr.ps	a0

    //Call panic handler
    mov     a6,sp
40375459:	206110        	or	a6, a1, a1
    call4   panicHandler
4037545c:	001e55        	call4	40375644 <panicHandler>

    call0   _xt_context_restore
4037545f:	04cd45        	call0	4037a134 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40375462:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40375464:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40375467:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_4
40375469:	13b400        	wsr.epc4	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
4037546c:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
4037546e:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
40375470:	002010        	rsync

    rsr     a0, EXCSAVE_4                   /* restore a0 */
40375473:	03d400        	rsr.excsave4	a0
    rfi     4
40375476:	003410        	rfi	4

40375479 <jump_to_esp_ipc_isr_handler>:

#ifdef CONFIG_ESP_IPC_ISR_ENABLE
jump_to_esp_ipc_isr_handler:
    /* Address of `esp_ipc_isr_handler_address` will always be in `movi` range
     * as it is defined right above. */
    movi    a0, esp_ipc_isr_handler
40375479:	fc1201        	l32r	a0, 403744c4 <_iram_text_start+0xc0>
    jx      a0
4037547c:	0000a0        	jx	a0

4037547f <ld_include_highint_hdl>:
	...

40375480 <esp_cache_err_get_cpuid>:

    ESP_INTR_ENABLE(ETS_CACHEERR_INUM);
}

int IRAM_ATTR esp_cache_err_get_cpuid(void)
{
40375480:	004136        	entry	a1, 32
 * @return            Status mask
 */
static inline uint32_t cache_ll_l1_get_access_error_intr_status(uint32_t cache_id, uint32_t mask)
{
    if (cache_id == 0) {
        return GET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ST_REG, mask);
40375483:	fc1121        	l32r	a2, 403744c8 <_iram_text_start+0xc4>
40375486:	0020c0        	memw
40375489:	0288      	l32i.n	a8, a2, 0
    if (cache_ll_l1_get_access_error_intr_status(0, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
        return PRO_CPU_NUM;
4037548b:	020c      	movi.n	a2, 0
4037548d:	448080        	extui	a8, a8, 0, 5
    if (cache_ll_l1_get_access_error_intr_status(0, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
40375490:	119827        	bne	a8, a2, 403754a5 <esp_cache_err_get_cpuid+0x25>
    } else {
        return GET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ST_REG, mask);
40375493:	fc0e21        	l32r	a2, 403744cc <_iram_text_start+0xc8>
    }

    if (cache_ll_l1_get_access_error_intr_status(1, CACHE_LL_L1_ACCESS_EVENT_MASK)) {
        return APP_CPU_NUM;
40375496:	190c      	movi.n	a9, 1
40375498:	0020c0        	memw
4037549b:	0288      	l32i.n	a8, a2, 0
4037549d:	f27c      	movi.n	a2, -1
4037549f:	448080        	extui	a8, a8, 0, 5
403754a2:	932980        	movnez	a2, a9, a8
    }

    return -1;
}
403754a5:	f01d      	retw.n
	...

403754a8 <esp_ipc_isr_handler>:
       allows one cpu to enter in the IPC_ISR section of the LX
       interrupt at one time, there's no need to have two
       _lx_intr_stack for each cpu */

    /* Save A0, A2, A3, A4 so we can use those registers further*/
    movi    a0, _lx_intr_stack
403754a8:	fc0a01        	l32r	a0, 403744d0 <_iram_text_start+0xcc>
    s32i    a2, a0, LX_INTR_A2_OFFSET
403754ab:	1029      	s32i.n	a2, a0, 4
    s32i    a3, a0, LX_INTR_A3_OFFSET
403754ad:	2039      	s32i.n	a3, a0, 8
    s32i    a4, a0, LX_INTR_A4_OFFSET
403754af:	3049      	s32i.n	a4, a0, 12
    rsr     a2, EXCSAVE_X
403754b1:	03d420        	rsr.excsave4	a2
    s32i    a2, a0, LX_INTR_A0_OFFSET
403754b4:	0029      	s32i.n	a2, a0, 0

    /* disable nested iterrupts */
    /* PS.EXCM is changed from 1 to 0 . It allows using usually exception handler instead of the Double exception handler. */
    /* PS_UM = 1 */
    movi    a0, PS_INTLEVEL(5) | PS_UM
403754b6:	502c      	movi.n	a0, 37
    wsr     a0, PS
403754b8:	13e600        	wsr.ps	a0
    rsync
403754bb:	002010        	rsync
#if CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5
    /* This int is level-triggered and doesn't need clearing.
       Do nothing here and clear int status by peripheral register later.*/
#elif CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4
    /* This int is edge-triggered and needs clearing. */
    movi    a3, (1 << ETS_IPC_ISR_INUM)
403754be:	fc0531        	l32r	a3, 403744d4 <_iram_text_start+0xd0>
    wsr     a3, INTCLEAR
403754c1:	13e330        	wsr.intclear	a3
#endif /* CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_5 */

    /* get CORE_ID */
    getcoreid   a3
403754c4:	03eb30        	rsr.prid	a3
403754c7:	043d30        	extui	a3, a3, 13, 1
    beqz    a3, 1f
403754ca:	a38c      	beqz.n	a3, 403754d8 <esp_ipc_isr_handler+0x30>

    /* current cpu is 1 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_3_REG
403754cc:	fc0331        	l32r	a3, 403744d8 <_iram_text_start+0xd4>
    movi    a4, 0
403754cf:	040c      	movi.n	a4, 0
    s32i    a4, a3, 0   /* clear intr */
403754d1:	0349      	s32i.n	a4, a3, 0
    j       2f
403754d3:	000206        	j	403754df <esp_ipc_isr_handler+0x37>
403754d6:	00          	.byte 00
403754d7:	00          	.byte 00
1:
    /* current cpu is 0 */
    movi    a3, SYSTEM_CPU_INTR_FROM_CPU_2_REG
403754d8:	fc0131        	l32r	a3, 403744dc <_iram_text_start+0xd8>
    movi    a4, 0
403754db:	040c      	movi.n	a4, 0
    s32i    a4, a3, 0   /* clear intr */
403754dd:	0349      	s32i.n	a4, a3, 0
2:

    /* set the start flag */
    movi    a0, esp_ipc_isr_start_fl
403754df:	fc0001        	l32r	a0, 403744e0 <_iram_text_start+0xdc>
    s32i    a0, a0, 0
403754e2:	0009      	s32i.n	a0, a0, 0

    /* Call the esp_ipc_function(void* arg) */
    movi    a0, esp_ipc_func
403754e4:	fc0001        	l32r	a0, 403744e4 <_iram_text_start+0xe0>
    l32i    a0, a0, 0
403754e7:	0008      	l32i.n	a0, a0, 0
    movi    a2, esp_ipc_func_arg
403754e9:	fbff21        	l32r	a2, 403744e8 <_iram_text_start+0xe4>
    l32i    a2, a2, 0
403754ec:	0228      	l32i.n	a2, a2, 0
    callx0  a0
403754ee:	0000c0        	callx0	a0

    /* Done. Restore registers and return. */
    movi    a0, _lx_intr_stack
403754f1:	fbf701        	l32r	a0, 403744d0 <_iram_text_start+0xcc>
    l32i    a2, a0, LX_INTR_A2_OFFSET
403754f4:	1028      	l32i.n	a2, a0, 4
    l32i    a3, a0, LX_INTR_A3_OFFSET
403754f6:	2038      	l32i.n	a3, a0, 8
    l32i    a4, a0, LX_INTR_A4_OFFSET
403754f8:	3048      	l32i.n	a4, a0, 12

    /* set the end flag */
    movi    a0, esp_ipc_isr_end_fl
403754fa:	fbfc01        	l32r	a0, 403744ec <_iram_text_start+0xe8>
    s32i    a0, a0, 0
403754fd:	0009      	s32i.n	a0, a0, 0

    /* restore a0 */
    rsr     a0, EXCSAVE_X
403754ff:	03d400        	rsr.excsave4	a0
    /* restores PS from EPS[X] and jumps to the address in EPC[X] */
    rfi     RFI_X
40375502:	003410        	rfi	4
40375505:	000000        	ill

40375508 <tick_hook>:
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
volatile bool int_wdt_cpu1_ticked = false;
#endif

static void IRAM_ATTR tick_hook(void)
{
40375508:	004136        	entry	a1, 32
4037550b:	03eb40        	rsr.prid	a4
4037550e:	044d40        	extui	a4, a4, 13, 1
    return id;
40375511:	fbea31        	l32r	a3, 403744bc <_iram_text_start+0xb8>
#if CONFIG_ESP_INT_WDT_CHECK_CPU1
    if (esp_cpu_get_core_id() != 0) {
40375514:	948c      	beqz.n	a4, 40375521 <tick_hook+0x19>
        int_wdt_cpu1_ticked = true;
40375516:	120c      	movi.n	a2, 1
40375518:	0020c0        	memw
4037551b:	004322        	s8i	a2, a3, 0
        wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
        wdt_hal_feed(&iwdt_context);
        wdt_hal_write_protect_enable(&iwdt_context);
    }
#endif // CONFIG_ESP_INT_WDT_CHECK_CPU1
}
4037551e:	f01d      	retw.n
40375520:	00          	.byte 00
        if (int_wdt_cpu1_ticked) {
40375521:	0020c0        	memw
40375524:	000322        	l8ui	a2, a3, 0
40375527:	742020        	extui	a2, a2, 0, 8
4037552a:	ff0216        	beqz	a2, 4037551e <tick_hook+0x16>
            wdt_hal_write_protect_disable(&iwdt_context);
4037552d:	fbf021        	l32r	a2, 403744f0 <_iram_text_start+0xec>
40375530:	20a220        	or	a10, a2, a2
40375533:	fbf081        	l32r	a8, 403744f4 <_iram_text_start+0xf0>
40375536:	0008e0        	callx8	a8
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);          // Set timeout before interrupt
40375539:	1d0c      	movi.n	a13, 1
4037553b:	58a2c2        	movi	a12, 0x258
4037553e:	04bd      	mov.n	a11, a4
40375540:	20a220        	or	a10, a2, a2
40375543:	fbed81        	l32r	a8, 403744f8 <_iram_text_start+0xf4>
40375546:	0008e0        	callx8	a8
            wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, 2 * CONFIG_ESP_INT_WDT_TIMEOUT_MS * 1000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); // Set timeout before reset
40375549:	3d0c      	movi.n	a13, 3
4037554b:	b0a4c2        	movi	a12, 0x4b0
4037554e:	1b0c      	movi.n	a11, 1
40375550:	02ad      	mov.n	a10, a2
40375552:	fbe981        	l32r	a8, 403744f8 <_iram_text_start+0xf4>
40375555:	0008e0        	callx8	a8
            wdt_hal_feed(&iwdt_context);
40375558:	02ad      	mov.n	a10, a2
4037555a:	fbe881        	l32r	a8, 403744fc <_iram_text_start+0xf8>
4037555d:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&iwdt_context);
40375560:	02ad      	mov.n	a10, a2
40375562:	fbe781        	l32r	a8, 40374500 <_iram_text_start+0xfc>
40375565:	0008e0        	callx8	a8
            int_wdt_cpu1_ticked = false;
40375568:	0020c0        	memw
4037556b:	004342        	s8i	a4, a3, 0
}
4037556e:	ffeb06        	j	4037551e <tick_hook+0x16>
40375571:	000000        	ill

40375574 <esp_restart_noos_dig>:
#define SHUTDOWN_HANDLERS_NO 5

static shutdown_handler_t shutdown_handlers[SHUTDOWN_HANDLERS_NO];

void IRAM_ATTR esp_restart_noos_dig(void)
{
40375574:	004136        	entry	a1, 32
    // (for example, by entering a critical section), disable all the
    // interrupts (e.g. from watchdogs) here.
#ifdef CONFIG_IDF_TARGET_ARCH_RISCV
    rv_utils_intr_global_disable();
#else
    xt_ints_off(0xFFFFFFFF);
40375577:	ffafa2        	movi	a10, -1
4037557a:	0af9e5        	call8	40380518 <xt_ints_off>
#endif

    // make sure all the panic handler output is sent from UART FIFO
    if (CONFIG_ESP_CONSOLE_UART_NUM >= 0) {
        esp_rom_uart_tx_wait_idle(CONFIG_ESP_CONSOLE_UART_NUM);
4037557d:	00a0a2        	movi	a10, 0
40375580:	fbca81        	l32r	a8, 403744a8 <_iram_text_start+0xa4>
40375583:	0008e0        	callx8	a8
    }

    // switch to XTAL (otherwise we will keep running from the PLL)
    rtc_clk_cpu_freq_set_xtal();
40375586:	034725        	call8	403789f8 <rtc_clk_cpu_freq_set_xtal>
    asm volatile (
40375589:	03eb20        	rsr.prid	a2
4037558c:	042d20        	extui	a2, a2, 13, 1
    // we need to release them here
#if !CONFIG_FREERTOS_UNICORE
    // Unstall all other cores
    int core_id = esp_cpu_get_core_id();
    for (uint32_t i = 0; i < SOC_CPU_CORES_NUM; i++) {
        if (i != core_id) {
4037558f:	01d256        	bnez	a2, 403755b0 <esp_restart_noos_dig+0x3c>
            esp_cpu_unstall(i);
40375592:	01a0a2        	movi	a10, 1
40375595:	02d925        	call8	40378328 <esp_cpu_unstall>
        }
    }
#endif
    // generate core reset
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_SW_SYS_RST);
40375598:	fbdba1        	l32r	a10, 40374504 <_iram_text_start+0x100>
4037559b:	f97c      	movi.n	a9, -1
4037559d:	0020c0        	memw
403755a0:	0a88      	l32i.n	a8, a10, 0
403755a2:	019910        	slli	a9, a9, 31
403755a5:	208890        	or	a8, a8, a9
403755a8:	0020c0        	memw
403755ab:	0a89      	s32i.n	a8, a10, 0
    while (true) {
403755ad:	ffff06        	j	403755ad <esp_restart_noos_dig+0x39>
            esp_cpu_unstall(i);
403755b0:	0a0c      	movi.n	a10, 0
403755b2:	02d765        	call8	40378328 <esp_cpu_unstall>
        if (i != core_id) {
403755b5:	df1226        	beqi	a2, 1, 40375598 <esp_restart_noos_dig+0x24>
403755b8:	fff586        	j	40375592 <esp_restart_noos_dig+0x1e>
	...

403755bc <esp_restart>:
    return ESP_ERR_INVALID_STATE;
}


void IRAM_ATTR esp_restart(void)
{
403755bc:	006136        	entry	a1, 48
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
403755bf:	fbd231        	l32r	a3, 40374508 <_iram_text_start+0x104>
403755c2:	04a022        	movi	a2, 4
        if (shutdown_handlers[i]) {
403755c5:	4388      	l32i.n	a8, a3, 16
403755c7:	188c      	beqz.n	a8, 403755cc <esp_restart+0x10>
            shutdown_handlers[i]();
403755c9:	0008e0        	callx8	a8
    for (int i = SHUTDOWN_HANDLERS_NO - 1; i >= 0; i--) {
403755cc:	220b      	addi.n	a2, a2, -1
403755ce:	fcc332        	addi	a3, a3, -4
403755d1:	f00266        	bnei	a2, -1, 403755c5 <esp_restart+0x9>
#ifdef CONFIG_FREERTOS_SMP
    //Note: Scheduler suspension behavior changed in FreeRTOS SMP
    vTaskPreemptionDisable(NULL);
#else
    // Disable scheduler on this core.
    vTaskSuspendAll();
403755d4:	05d365        	call8	4037b30c <vTaskSuspendAll>
#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_intr_ena_any() || esp_memprot_is_locked_any()) {
        digital_reset_needed = true;
    }
#else
    bool is_on = false;
403755d7:	00a022        	movi	a2, 0
    if (esp_mprot_is_intr_ena_any(&is_on) != ESP_OK || is_on) {
403755da:	20a110        	or	a10, a1, a1
    bool is_on = false;
403755dd:	004122        	s8i	a2, a1, 0
    if (esp_mprot_is_intr_ena_any(&is_on) != ESP_OK || is_on) {
403755e0:	010065        	call8	403765e8 <esp_mprot_is_intr_ena_any>
403755e3:	2adc      	bnez.n	a10, 403755f9 <esp_restart+0x3d>
403755e5:	000122        	l8ui	a2, a1, 0
403755e8:	d2cc      	bnez.n	a2, 403755f9 <esp_restart+0x3d>
        digital_reset_needed = true;
    } else if (esp_mprot_is_conf_locked_any(&is_on) != ESP_OK || is_on) {
403755ea:	01ad      	mov.n	a10, a1
403755ec:	00e7e5        	call8	4037646c <esp_mprot_is_conf_locked_any>
403755ef:	6acc      	bnez.n	a10, 403755f9 <esp_restart+0x3d>
403755f1:	000122        	l8ui	a2, a1, 0
403755f4:	12cc      	bnez.n	a2, 403755f9 <esp_restart+0x3d>
#endif
#endif
    if (digital_reset_needed) {
        esp_restart_noos_dig();
    }
    esp_restart_noos();
403755f6:	000fe5        	call8	403756f4 <esp_restart_noos>
        esp_restart_noos_dig();
403755f9:	fff7a5        	call8	40375574 <esp_restart_noos_dig>

403755fc <start_cpu_other_cores>:

/* This function has to be in IRAM, as while it is running on CPU1, CPU0 may do some flash operations
 * (e.g. initialize the core dump), which means that cache will be disabled.
 */
static void IRAM_ATTR start_cpu_other_cores_default(void)
{
403755fc:	004136        	entry	a1, 32
    do_system_init_fn();
403755ff:	fbc481        	l32r	a8, 40374510 <_iram_text_start+0x10c>
40375602:	0008e0        	callx8	a8

    while (!s_system_full_inited) {
40375605:	fbc121        	l32r	a2, 4037450c <_iram_text_start+0x108>
40375608:	0020c0        	memw
4037560b:	000282        	l8ui	a8, a2, 0
4037560e:	748080        	extui	a8, a8, 0, 8
40375611:	488c      	beqz.n	a8, 40375619 <start_cpu_other_cores+0x1d>
        esp_rom_delay_us(100);
    }

    esp_startup_start_app_other_cores();
40375613:	fbc081        	l32r	a8, 40374514 <_iram_text_start+0x110>
40375616:	0008e0        	callx8	a8
        esp_rom_delay_us(100);
40375619:	64a0a2        	movi	a10, 100
4037561c:	fb8981        	l32r	a8, 40374440 <_iram_text_start+0x3c>
4037561f:	0008e0        	callx8	a8
40375622:	fff7c6        	j	40375605 <start_cpu_other_cores+0x9>
40375625:	000000        	ill

40375628 <panic_enable_cache>:
/**
 * This function must always be in IRAM as it is required to
 * re-enable the flash cache.
 */
static void IRAM_ATTR panic_enable_cache(void)
{
40375628:	004136        	entry	a1, 32
4037562b:	03eb20        	rsr.prid	a2
4037562e:	042d20        	extui	a2, a2, 13, 1
    int core_id = esp_cpu_get_core_id();

    if (!spi_flash_cache_enabled()) {
40375631:	020fa5        	call8	4037772c <spi_flash_cache_enabled>
40375634:	008a56        	bnez	a10, 40375640 <panic_enable_cache+0x18>
        esp_ipc_isr_stall_abort();
40375637:	004c25        	call8	40375af8 <esp_ipc_isr_stall_abort>
        spi_flash_enable_cache(core_id);
4037563a:	20a220        	or	a10, a2, a2
4037563d:	020fe5        	call8	4037773c <spi_flash_enable_cache>
    }
}
40375640:	f01d      	retw.n
	...

40375644 <panicHandler>:

void IRAM_ATTR panicHandler(void *frame)
{
40375644:	004136        	entry	a1, 32

    panic_enable_cache();
40375647:	fffe25        	call8	40375628 <panic_enable_cache>
    // This panic handler gets called for when the double exception vector,
    // kernel exception vector gets used; as well as handling interrupt-based
    // faults cache error, wdt expiry. EXCAUSE register gets written with
    // one of PANIC_RSN_* values.
    panic_handler(frame, true);
4037564a:	1b0c      	movi.n	a11, 1
4037564c:	02ad      	mov.n	a10, a2
4037564e:	fbb281        	l32r	a8, 40374518 <_iram_text_start+0x114>
40375651:	0008e0        	callx8	a8
}
40375654:	f01d      	retw.n
	...

40375658 <xt_unhandled_exception>:

void IRAM_ATTR xt_unhandled_exception(void *frame)
{
40375658:	004136        	entry	a1, 32
    panic_enable_cache();
4037565b:	fffce5        	call8	40375628 <panic_enable_cache>
    panic_handler(frame, false);
4037565e:	0b0c      	movi.n	a11, 0
40375660:	02ad      	mov.n	a10, a2
40375662:	fbad81        	l32r	a8, 40374518 <_iram_text_start+0x114>
40375665:	0008e0        	callx8	a8
}
40375668:	f01d      	retw.n
	...

4037566c <rtc_brownout_isr_handler>:
#define BROWNOUT_DET_LVL 0
#endif

#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
IRAM_ATTR static void rtc_brownout_isr_handler(void *arg)
{
4037566c:	004136        	entry	a1, 32
    /* Normally RTC ISR clears the interrupt flag after the application-supplied
     * handler returns. Since restart is called here, the flag needs to be
     * cleared manually.
     */
    brownout_hal_intr_clear();
4037566f:	0058a5        	call8	40375bf8 <brownout_hal_intr_clear>
40375672:	03eb90        	rsr.prid	a9
40375675:	049d90        	extui	a9, a9, 13, 1

    // Stop the other core.
#if !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    const uint32_t core_id = esp_cpu_get_core_id();
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
40375678:	00a082        	movi	a8, 0
4037567b:	01a0a2        	movi	a10, 1
4037567e:	93a890        	movnez	a10, a8, a9
    esp_cpu_stall(other_core_id);
40375681:	02c1a5        	call8	4037829c <esp_cpu_stall>
#endif

    esp_reset_reason_set_hint(ESP_RST_BROWNOUT);
40375684:	9a0c      	movi.n	a10, 9
40375686:	0001a5        	call8	403756a0 <esp_reset_reason_set_hint>
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    if (spi_flash_brownout_need_reset()) {
40375689:	0933e5        	call8	4037e9c8 <spi_flash_brownout_need_reset>
4037568c:	4a8c      	beqz.n	a10, 40375694 <rtc_brownout_isr_handler+0x28>
        bootloader_flash_reset_chip();
4037568e:	01df25        	call8	40377480 <bootloader_flash_reset_chip>
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET
    {
        esp_rom_printf("\r\nBrownout detector was triggered\r\n\r\n");
    }

    esp_restart_noos();
40375691:	000625        	call8	403756f4 <esp_restart_noos>
        esp_rom_printf("\r\nBrownout detector was triggered\r\n\r\n");
40375694:	fba2a1        	l32r	a10, 4037451c <_iram_text_start+0x118>
40375697:	fba281        	l32r	a8, 40374520 <_iram_text_start+0x11c>
4037569a:	0008e0        	callx8	a8
4037569d:	fffc06        	j	40375691 <rtc_brownout_isr_handler+0x25>

403756a0 <esp_reset_reason_set_hint>:
#define RST_REASON_MASK 0x7FFF
#define RST_REASON_SHIFT 16

/* in IRAM, can be called from panic handler */
void IRAM_ATTR esp_reset_reason_set_hint(esp_reset_reason_t hint)
{
403756a0:	004136        	entry	a1, 32
    assert((hint & (~RST_REASON_MASK)) == 0);
403756a3:	f87c      	movi.n	a8, -1
403756a5:	118810        	slli	a8, a8, 15
403756a8:	110287        	bnone	a2, a8, 403756bd <esp_reset_reason_set_hint+0x1d>
403756ab:	fb9ed1        	l32r	a13, 40374524 <_iram_text_start+0x120>
403756ae:	fb9ec1        	l32r	a12, 40374528 <_iram_text_start+0x124>
403756b1:	fb9ea1        	l32r	a10, 4037452c <_iram_text_start+0x128>
403756b4:	61a0b2        	movi	a11, 97
403756b7:	201110        	or	a1, a1, a1
403756ba:	091525        	call8	4037e80c <__assert_func>
    uint32_t val = hint | (hint << RST_REASON_SHIFT) | RST_REASON_BIT;
403756bd:	118200        	slli	a8, a2, 16
403756c0:	f97c      	movi.n	a9, -1
403756c2:	208820        	or	a8, a8, a2
403756c5:	019910        	slli	a9, a9, 31
    REG_WRITE(RTC_RESET_CAUSE_REG, val);
403756c8:	fb9a21        	l32r	a2, 40374530 <_iram_text_start+0x12c>
    uint32_t val = hint | (hint << RST_REASON_SHIFT) | RST_REASON_BIT;
403756cb:	208890        	or	a8, a8, a9
    REG_WRITE(RTC_RESET_CAUSE_REG, val);
403756ce:	0020c0        	memw
403756d1:	0289      	s32i.n	a8, a2, 0
}
403756d3:	f01d      	retw.n
403756d5:	000000        	ill

403756d8 <esp_reset_reason_get_hint>:

/* in IRAM, can be called from panic handler */
esp_reset_reason_t IRAM_ATTR esp_reset_reason_get_hint(void)
{
403756d8:	004136        	entry	a1, 32
    uint32_t reset_reason_hint = REG_READ(RTC_RESET_CAUSE_REG);
403756db:	fb9521        	l32r	a2, 40374530 <_iram_text_start+0x12c>
403756de:	0020c0        	memw
403756e1:	002282        	l32i	a8, a2, 0
    uint32_t high = (reset_reason_hint >> RST_REASON_SHIFT) & RST_REASON_MASK;
    uint32_t low = reset_reason_hint & RST_REASON_MASK;
403756e4:	e42080        	extui	a2, a8, 0, 15
    uint32_t high = (reset_reason_hint >> RST_REASON_SHIFT) & RST_REASON_MASK;
403756e7:	e59080        	extui	a9, a8, 16, 15
    if ((reset_reason_hint & RST_REASON_BIT) == 0 || high != low) {
403756ea:	029927        	bne	a9, a2, 403756f0 <esp_reset_reason_get_hint+0x18>
403756ed:	001896        	bltz	a8, 403756f2 <esp_reset_reason_get_hint+0x1a>
        return ESP_RST_UNKNOWN;
403756f0:	020c      	movi.n	a2, 0
    }
    return (esp_reset_reason_t) low;
}
403756f2:	f01d      	retw.n

403756f4 <esp_restart_noos>:
/* "inner" restart function for after RTOS, interrupts & anything else on this
 * core are already stopped. Stalls other core, resets hardware,
 * triggers restart.
*/
void IRAM_ATTR esp_restart_noos(void)
{
403756f4:	008136        	entry	a1, 64
    // Disable interrupts
    xt_ints_off(0xFFFFFFFF);
403756f7:	fa7c      	movi.n	a10, -1
403756f9:	0ae1e5        	call8	40380518 <xt_ints_off>

    // Enable RTC watchdog for 1 second
    wdt_hal_context_t rtc_wdt_ctx;
    wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
403756fc:	0d0c      	movi.n	a13, 0
403756fe:	0dcd      	mov.n	a12, a13
40375700:	0dbd      	mov.n	a11, a13
40375702:	10c1a2        	addi	a10, a1, 16
40375705:	fb9a81        	l32r	a8, 40374570 <_iram_text_start+0x16c>
40375708:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(1000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
4037570b:	02f9e5        	call8	403786a8 <rtc_clk_slow_freq_get_hz>
4037570e:	0a2d      	mov.n	a2, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
40375710:	10c1a2        	addi	a10, a1, 16
40375713:	fb7881        	l32r	a8, 403744f4 <_iram_text_start+0xf0>
40375716:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
40375719:	02cd      	mov.n	a12, a2
4037571b:	10c1a2        	addi	a10, a1, 16
4037571e:	3d0c      	movi.n	a13, 3
40375720:	0b0c      	movi.n	a11, 0
40375722:	fb7581        	l32r	a8, 403744f8 <_iram_text_start+0xf4>
40375725:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE1, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
40375728:	02cd      	mov.n	a12, a2
4037572a:	4d0c      	movi.n	a13, 4
4037572c:	10c1a2        	addi	a10, a1, 16
4037572f:	1b0c      	movi.n	a11, 1
40375731:	fb7181        	l32r	a8, 403744f8 <_iram_text_start+0xf4>
40375734:	0008e0        	callx8	a8
    //Enable flash boot mode so that flash booting after restart is protected by the RTC WDT.
    wdt_hal_set_flashboot_en(&rtc_wdt_ctx, true);
40375737:	1b0c      	movi.n	a11, 1
40375739:	10c1a2        	addi	a10, a1, 16
4037573c:	fb8e81        	l32r	a8, 40374574 <_iram_text_start+0x170>
4037573f:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
40375742:	10c1a2        	addi	a10, a1, 16
40375745:	fb6e81        	l32r	a8, 40374500 <_iram_text_start+0xfc>
40375748:	0008e0        	callx8	a8


    // Disable TG0/TG1 watchdogs
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
4037574b:	fb7a21        	l32r	a2, 40374534 <_iram_text_start+0x130>
    wdt_hal_write_protect_disable(&wdt0_context);
4037574e:	a18b      	addi.n	a10, a1, 8
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
40375750:	0238      	l32i.n	a3, a2, 0
40375752:	1228      	l32i.n	a2, a2, 4
40375754:	2139      	s32i.n	a3, a1, 8
40375756:	3129      	s32i.n	a2, a1, 12
    wdt_hal_write_protect_disable(&wdt0_context);
40375758:	fb6781        	l32r	a8, 403744f4 <_iram_text_start+0xf0>
4037575b:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
4037575e:	a18b      	addi.n	a10, a1, 8
40375760:	fb8681        	l32r	a8, 40374578 <_iram_text_start+0x174>
40375763:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
40375766:	a18b      	addi.n	a10, a1, 8
40375768:	fb6681        	l32r	a8, 40374500 <_iram_text_start+0xfc>
4037576b:	0008e0        	callx8	a8

    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
4037576e:	fb7221        	l32r	a2, 40374538 <_iram_text_start+0x134>
    wdt_hal_write_protect_disable(&wdt1_context);
40375771:	01ad      	mov.n	a10, a1
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
40375773:	0238      	l32i.n	a3, a2, 0
40375775:	1228      	l32i.n	a2, a2, 4
40375777:	0139      	s32i.n	a3, a1, 0
40375779:	1129      	s32i.n	a2, a1, 4
    wdt_hal_write_protect_disable(&wdt1_context);
4037577b:	fb5e81        	l32r	a8, 403744f4 <_iram_text_start+0xf0>
4037577e:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
40375781:	01ad      	mov.n	a10, a1
40375783:	fb7d81        	l32r	a8, 40374578 <_iram_text_start+0x174>
40375786:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
40375789:	01ad      	mov.n	a10, a1
4037578b:	fb5d81        	l32r	a8, 40374500 <_iram_text_start+0xfc>
4037578e:	0008e0        	callx8	a8

    // Flush any data left in UART FIFOs
    esp_rom_uart_tx_wait_idle(0);
40375791:	0a0c      	movi.n	a10, 0
40375793:	fb4581        	l32r	a8, 403744a8 <_iram_text_start+0xa4>
40375796:	0008e0        	callx8	a8
    esp_rom_uart_tx_wait_idle(1);
40375799:	1a0c      	movi.n	a10, 1
4037579b:	fb4381        	l32r	a8, 403744a8 <_iram_text_start+0xa4>
4037579e:	0008e0        	callx8	a8
        SET_STACK(new_sp);
    }
#endif

    // Disable cache
    Cache_Disable_ICache();
403757a1:	fb7681        	l32r	a8, 4037457c <_iram_text_start+0x178>
403757a4:	0008e0        	callx8	a8
    Cache_Disable_DCache();
403757a7:	fb7681        	l32r	a8, 40374580 <_iram_text_start+0x17c>
403757aa:	0008e0        	callx8	a8
403757ad:	03eb40        	rsr.prid	a4
403757b0:	044d40        	extui	a4, a4, 13, 1
    // CPU must be reset before stalling, in case it was running a s32c1i
    // instruction. This would cause memory pool to be locked by arbiter
    // to the stalled CPU, preventing current CPU from accessing this pool.
    const uint32_t core_id = esp_cpu_get_core_id();
#if !CONFIG_FREERTOS_UNICORE
    const uint32_t other_core_id = (core_id == 0) ? 1 : 0;
403757b3:	020c      	movi.n	a2, 0
403757b5:	130c      	movi.n	a3, 1
403757b7:	025d      	mov.n	a5, a2
403757b9:	835340        	moveqz	a5, a3, a4
    esp_cpu_reset(other_core_id);
403757bc:	05ad      	mov.n	a10, a5
403757be:	02aae5        	call8	4037826c <esp_cpu_reset>
    esp_cpu_stall(other_core_id);
403757c1:	05ad      	mov.n	a10, a5
403757c3:	02ada5        	call8	4037829c <esp_cpu_stall>
#endif

    // 2nd stage bootloader reconfigures SPI flash signals.
    // Reset them to the defaults expected by ROM.
    WRITE_PERI_REG(GPIO_FUNC0_IN_SEL_CFG_REG, 0x30);
403757c6:	fb5d51        	l32r	a5, 4037453c <_iram_text_start+0x138>
403757c9:	083c      	movi.n	a8, 48
403757cb:	0020c0        	memw
403757ce:	0589      	s32i.n	a8, a5, 0
    WRITE_PERI_REG(GPIO_FUNC1_IN_SEL_CFG_REG, 0x30);
403757d0:	fb5c51        	l32r	a5, 40374540 <_iram_text_start+0x13c>
403757d3:	0020c0        	memw
403757d6:	0589      	s32i.n	a8, a5, 0
    WRITE_PERI_REG(GPIO_FUNC2_IN_SEL_CFG_REG, 0x30);
403757d8:	fb5b51        	l32r	a5, 40374544 <_iram_text_start+0x140>
403757db:	0020c0        	memw
403757de:	0589      	s32i.n	a8, a5, 0
    WRITE_PERI_REG(GPIO_FUNC3_IN_SEL_CFG_REG, 0x30);
403757e0:	fb5a51        	l32r	a5, 40374548 <_iram_text_start+0x144>
403757e3:	0020c0        	memw
403757e6:	0589      	s32i.n	a8, a5, 0
    WRITE_PERI_REG(GPIO_FUNC4_IN_SEL_CFG_REG, 0x30);
403757e8:	fb5951        	l32r	a5, 4037454c <_iram_text_start+0x148>
403757eb:	0020c0        	memw
403757ee:	0589      	s32i.n	a8, a5, 0
    WRITE_PERI_REG(GPIO_FUNC5_IN_SEL_CFG_REG, 0x30);
403757f0:	fb5851        	l32r	a5, 40374550 <_iram_text_start+0x14c>
403757f3:	0020c0        	memw
403757f6:	0589      	s32i.n	a8, a5, 0

    // Reset wifi/bluetooth/ethernet/sdio (bb/mac)
    SET_PERI_REG_MASK(SYSTEM_CORE_RST_EN_REG,
403757f8:	fb5781        	l32r	a8, 40374554 <_iram_text_start+0x150>
403757fb:	fb5751        	l32r	a5, 40374558 <_iram_text_start+0x154>
403757fe:	0020c0        	memw
40375801:	0898      	l32i.n	a9, a8, 0
40375803:	209950        	or	a9, a9, a5
40375806:	0020c0        	memw
40375809:	0899      	s32i.n	a9, a8, 0
                      SYSTEM_WIFIBB_RST | SYSTEM_FE_RST | SYSTEM_WIFIMAC_RST |
                      SYSTEM_SDIO_RST | SYSTEM_EMAC_RST | SYSTEM_MACPWR_RST |
                      SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST |
                      SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
    REG_WRITE(SYSTEM_CORE_RST_EN_REG, 0);
4037580b:	0020c0        	memw
4037580e:	0829      	s32i.n	a2, a8, 0

    // Reset timer/spi/uart
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG,
40375810:	fb5381        	l32r	a8, 4037455c <_iram_text_start+0x158>
40375813:	fb5351        	l32r	a5, 40374560 <_iram_text_start+0x15c>
40375816:	0020c0        	memw
40375819:	0898      	l32i.n	a9, a8, 0
4037581b:	209950        	or	a9, a9, a5
4037581e:	0020c0        	memw
40375821:	0899      	s32i.n	a9, a8, 0
                      SYSTEM_TIMERS_RST | SYSTEM_SPI01_RST | SYSTEM_UART_RST | SYSTEM_SYSTIMER_RST);
    REG_WRITE(SYSTEM_PERIP_RST_EN0_REG, 0);
40375823:	0020c0        	memw
40375826:	0829      	s32i.n	a2, a8, 0

    // Reset dma
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_DMA_RST);
40375828:	fb4f81        	l32r	a8, 40374564 <_iram_text_start+0x160>
4037582b:	054c      	movi.n	a5, 64
4037582d:	0020c0        	memw
40375830:	0898      	l32i.n	a9, a8, 0
40375832:	209950        	or	a9, a9, a5
40375835:	0020c0        	memw
40375838:	0899      	s32i.n	a9, a8, 0
    REG_WRITE(SYSTEM_PERIP_RST_EN1_REG, 0);
4037583a:	0020c0        	memw
4037583d:	0829      	s32i.n	a2, a8, 0

    SET_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
4037583f:	fb4a81        	l32r	a8, 40374568 <_iram_text_start+0x164>
40375842:	250c      	movi.n	a5, 2
40375844:	0020c0        	memw
40375847:	0898      	l32i.n	a9, a8, 0
40375849:	209950        	or	a9, a9, a5
4037584c:	0020c0        	memw
4037584f:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_EDMA_CTRL_REG, SYSTEM_EDMA_RESET);
40375851:	0020c0        	memw
40375854:	0898      	l32i.n	a9, a8, 0
40375856:	d57c      	movi.n	a5, -3
40375858:	109950        	and	a9, a9, a5
4037585b:	0020c0        	memw
4037585e:	0899      	s32i.n	a9, a8, 0

    // Set CPU back to XTAL source, no PLL, same as hard reset
#if !CONFIG_IDF_ENV_FPGA
    rtc_clk_cpu_freq_set_xtal();
40375860:	031965        	call8	403789f8 <rtc_clk_cpu_freq_set_xtal>
#endif

#if !CONFIG_FREERTOS_UNICORE
    // Clear entry point for APP CPU
    REG_WRITE(SYSTEM_CORE_1_CONTROL_1_REG, 0);
40375863:	fb4251        	l32r	a5, 4037456c <_iram_text_start+0x168>
40375866:	0020c0        	memw
40375869:	0529      	s32i.n	a2, a5, 0
#endif

    // Reset CPUs
    if (core_id == 0) {
4037586b:	0d9427        	bne	a4, a2, 4037587c <esp_restart_noos+0x188>
        // Running on PRO CPU: APP CPU is stalled. Can reset both CPUs.
#if !CONFIG_FREERTOS_UNICORE
        esp_cpu_reset(1);
4037586e:	03ad      	mov.n	a10, a3
40375870:	029fa5        	call8	4037826c <esp_cpu_reset>
#endif
        esp_cpu_reset(0);
40375873:	04ad      	mov.n	a10, a4
40375875:	029f65        	call8	4037826c <esp_cpu_reset>
        esp_cpu_reset(0);
        esp_cpu_unstall(0);
        esp_cpu_reset(1);
    }
#endif
    while (true) {
40375878:	ffff06        	j	40375878 <esp_restart_noos+0x184>
4037587b:	00          	.byte 00
        esp_cpu_reset(0);
4037587c:	20a220        	or	a10, a2, a2
4037587f:	029ee5        	call8	4037826c <esp_cpu_reset>
        esp_cpu_unstall(0);
40375882:	02ad      	mov.n	a10, a2
40375884:	02aa25        	call8	40378328 <esp_cpu_unstall>
        esp_cpu_reset(1);
40375887:	03ad      	mov.n	a10, a3
40375889:	029e25        	call8	4037826c <esp_cpu_reset>
4037588c:	fffa06        	j	40375878 <esp_restart_noos+0x184>
	...

40375890 <apb_backup_dma_unlock>:
        portENTER_CRITICAL(&s_apb_backup_dma_mutex);
    }
}

static void IRAM_ATTR apb_backup_dma_unlock(void)
{
40375890:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40375893:	06cfa5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(&s_apb_backup_dma_mutex);
40375896:	fb3ba1        	l32r	a10, 40374584 <_iram_text_start+0x180>
40375899:	06e4a5        	call8	4037c6e4 <vPortExitCritical>
    } else {
        portEXIT_CRITICAL(&s_apb_backup_dma_mutex);
    }
}
4037589c:	f01d      	retw.n
	...

403758a0 <apb_backup_dma_lock>:
{
403758a0:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403758a3:	06cea5        	call8	4037c58c <xPortInIsrContext>

// ------------------ Critical Sections --------------------

static inline void __attribute__((always_inline)) vPortEnterCritical(portMUX_TYPE *mux)
{
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403758a6:	fb37a1        	l32r	a10, 40374584 <_iram_text_start+0x180>
403758a9:	ffafb2        	movi	a11, -1
403758ac:	06d025        	call8	4037c5b0 <xPortEnterCriticalTimeout>
}
403758af:	000090        	retw
	...

403758b4 <print_entry>:
    //Return true if both sp and pc of frame(i-1) are sane, false otherwise
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
}

static void IRAM_ATTR print_entry(uint32_t pc, uint32_t sp, bool panic)
{
403758b4:	004136        	entry	a1, 32
    if (panic) {
403758b7:	54ac      	beqz.n	a4, 403758e0 <print_entry+0x2c>
        panic_print_str(" 0x");
403758b9:	fb33a1        	l32r	a10, 40374588 <_iram_text_start+0x184>
403758bc:	fb3681        	l32r	a8, 40374594 <_iram_text_start+0x190>
403758bf:	0008e0        	callx8	a8
        panic_print_hex(pc);
403758c2:	02ad      	mov.n	a10, a2
403758c4:	fb3581        	l32r	a8, 40374598 <_iram_text_start+0x194>
403758c7:	0008e0        	callx8	a8
        panic_print_str(":0x");
403758ca:	fb30a1        	l32r	a10, 4037458c <_iram_text_start+0x188>
403758cd:	fb3181        	l32r	a8, 40374594 <_iram_text_start+0x190>
403758d0:	0008e0        	callx8	a8
        panic_print_hex(sp);
403758d3:	20a330        	or	a10, a3, a3
403758d6:	fb3081        	l32r	a8, 40374598 <_iram_text_start+0x194>
403758d9:	0008e0        	callx8	a8
    } else {
        esp_rom_printf(" 0x%08X:0x%08X", pc, sp);
    }
}
403758dc:	f01d      	retw.n
403758de:	00          	.byte 00
403758df:	00          	.byte 00
        esp_rom_printf(" 0x%08X:0x%08X", pc, sp);
403758e0:	fb2ca1        	l32r	a10, 40374590 <_iram_text_start+0x18c>
403758e3:	03cd      	mov.n	a12, a3
403758e5:	02bd      	mov.n	a11, a2
403758e7:	fb0e81        	l32r	a8, 40374520 <_iram_text_start+0x11c>
403758ea:	0008e0        	callx8	a8
}
403758ed:	fffac6        	j	403758dc <print_entry+0x28>

403758f0 <print_str>:

static void IRAM_ATTR print_str(const char* str, bool panic)
{
403758f0:	004136        	entry	a1, 32
403758f3:	02ad      	mov.n	a10, a2
    if (panic) {
403758f5:	738c      	beqz.n	a3, 40375900 <print_str+0x10>
        panic_print_str(str);
403758f7:	fb2781        	l32r	a8, 40374594 <_iram_text_start+0x190>
403758fa:	0008e0        	callx8	a8
    } else {
        esp_rom_printf(str);
    }
}
403758fd:	f01d      	retw.n
403758ff:	00          	.byte 00
        esp_rom_printf(str);
40375900:	fb0881        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40375903:	0008e0        	callx8	a8
}
40375906:	fffcc6        	j	403758fd <print_str+0xd>
40375909:	000000        	ill

4037590c <esp_backtrace_get_next_frame>:
{
4037590c:	004136        	entry	a1, 32
    void *base_save = (void *)frame->sp;     //Base save area consists of 4 words under SP
4037590f:	1298      	l32i.n	a9, a2, 4
    frame->pc = frame->next_pc;
40375911:	2288      	l32i.n	a8, a2, 8
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
40375913:	f0c9a2        	addi	a10, a9, -16
    frame->pc = frame->next_pc;
40375916:	0289      	s32i.n	a8, a2, 0
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
40375918:	0aa8      	l32i.n	a10, a10, 0
    frame->sp =  *((uint32_t *)(base_save - 12));
4037591a:	f4c992        	addi	a9, a9, -12
    frame->next_pc = *((uint32_t *)(base_save - 16));     //If next_pc = 0, indicates frame(i-1) is the last frame on the stack
4037591d:	22a9      	s32i.n	a10, a2, 8
    frame->sp =  *((uint32_t *)(base_save - 12));
4037591f:	0998      	l32i.n	a9, a9, 0
 */
__attribute__((always_inline))
inline static bool esp_stack_ptr_in_dram(uint32_t sp)
{
    //Check if stack ptr is in between SOC_DRAM_LOW and SOC_DRAM_HIGH, and 16 byte aligned.
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375921:	fb1fa1        	l32r	a10, 403745a0 <_iram_text_start+0x19c>
40375924:	1299      	s32i.n	a9, a2, 4
40375926:	fb1d21        	l32r	a2, 4037459c <_iram_text_start+0x198>
40375929:	292a      	add.n	a2, a9, a2
4037592b:	11ba27        	bgeu	a10, a2, 40375940 <esp_backtrace_get_next_frame+0x34>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037592e:	fb1d21        	l32r	a2, 403745a4 <_iram_text_start+0x1a0>
40375931:	992a      	add.n	a9, a9, a2
    return (esp_stack_ptr_is_sane(frame->sp) && esp_ptr_executable((void*)esp_cpu_process_stack_pc(frame->pc)));
40375933:	fb1d21        	l32r	a2, 403745a8 <_iram_text_start+0x1a4>
40375936:	0eb297        	bgeu	a2, a9, 40375948 <esp_backtrace_get_next_frame+0x3c>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375939:	020c      	movi.n	a2, 0
4037593b:	001246        	j	40375988 <esp_backtrace_get_next_frame+0x7c>
4037593e:	00          	.byte 00
4037593f:	00          	.byte 00
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375940:	349090        	extui	a9, a9, 0, 4
40375943:	020c      	movi.n	a2, 0
    return esp_stack_ptr_in_dram(sp)
#if CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY
        || esp_stack_ptr_in_extram(sp)
#endif
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375945:	3f9927        	bne	a9, a2, 40375988 <esp_backtrace_get_next_frame+0x7c>
 * @param pc PC value of the current backtrace frame
 *
 */
static inline uint32_t esp_cpu_process_stack_pc(uint32_t pc)
{
    if (pc & 0x80000000) {
40375948:	00d8d6        	bgez	a8, 40375959 <esp_backtrace_get_next_frame+0x4d>
        //Top two bits of a0 (return address) specify window increment. Overwrite to map to address space.
        pc = (pc & 0x3fffffff) | 0x40000000;
4037594b:	fb1821        	l32r	a2, 403745ac <_iram_text_start+0x1a8>
4037594e:	102820        	and	a2, a8, a2
40375951:	180c      	movi.n	a8, 1
40375953:	018820        	slli	a8, a8, 30
40375956:	208280        	or	a8, a2, a8
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
40375959:	fb1521        	l32r	a2, 403745b0 <_iram_text_start+0x1ac>
4037595c:	fb1691        	l32r	a9, 403745b4 <_iram_text_start+0x1b0>
4037595f:	282a      	add.n	a2, a8, a2
40375961:	28b927        	bgeu	a9, a2, 4037598d <esp_backtrace_get_next_frame+0x81>
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
40375964:	fb1521        	l32r	a2, 403745b8 <_iram_text_start+0x1b4>
40375967:	fb1591        	l32r	a9, 403745bc <_iram_text_start+0x1b8>
4037596a:	282a      	add.n	a2, a8, a2
4037596c:	1db927        	bgeu	a9, a2, 4037598d <esp_backtrace_get_next_frame+0x81>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
4037596f:	fb1491        	l32r	a9, 403745c0 <_iram_text_start+0x1bc>
40375972:	fb14a1        	l32r	a10, 403745c4 <_iram_text_start+0x1c0>
40375975:	989a      	add.n	a9, a8, a9
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375977:	120c      	movi.n	a2, 1
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375979:	0bba97        	bgeu	a10, a9, 40375988 <esp_backtrace_get_next_frame+0x7c>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
4037597c:	fb1391        	l32r	a9, 403745c8 <_iram_text_start+0x1c4>
4037597f:	808890        	add	a8, a8, a9
40375982:	fb0991        	l32r	a9, 403745a8 <_iram_text_start+0x1a4>
40375985:	b03987        	bltu	a9, a8, 40375939 <esp_backtrace_get_next_frame+0x2d>
}
40375988:	042020        	extui	a2, a2, 0, 1
4037598b:	f01d      	retw.n
4037598d:	120c      	movi.n	a2, 1
4037598f:	fffd46        	j	40375988 <esp_backtrace_get_next_frame+0x7c>
	...

40375994 <esp_backtrace_print_from_frame>:

esp_err_t IRAM_ATTR esp_backtrace_print_from_frame(int depth, const esp_backtrace_frame_t* frame, bool panic)
{
40375994:	006136        	entry	a1, 48
40375997:	025d      	mov.n	a5, a2
40375999:	744040        	extui	a4, a4, 0, 8
    //Check arguments
    if (depth <= 0) {
        return ESP_ERR_INVALID_ARG;
4037599c:	02a122        	movi	a2, 0x102
    if (depth <= 0) {
4037599f:	0215e6        	bgei	a5, 1, 403759a5 <esp_backtrace_print_from_frame+0x11>
403759a2:	002dc6        	j	40375a5d <esp_backtrace_print_from_frame+0xc9>
    }

    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t stk_frame = { 0 };
    memcpy(&stk_frame, frame, sizeof(esp_backtrace_frame_t));
403759a5:	0c1c      	movi.n	a12, 16
403759a7:	03bd      	mov.n	a11, a3
403759a9:	01ad      	mov.n	a10, a1
403759ab:	fac181        	l32r	a8, 403744b0 <_iram_text_start+0xac>
403759ae:	0008e0        	callx8	a8

    print_str("\r\n\r\nBacktrace:", panic);
403759b1:	fb06a1        	l32r	a10, 403745cc <_iram_text_start+0x1c8>
403759b4:	04bd      	mov.n	a11, a4
403759b6:	fff3a5        	call8	403758f0 <print_str>
    print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
403759b9:	0128      	l32i.n	a2, a1, 0
    if (pc & 0x80000000) {
403759bb:	00d2d6        	bgez	a2, 403759cc <esp_backtrace_print_from_frame+0x38>
        pc = (pc & 0x3fffffff) | 0x40000000;
403759be:	fafb31        	l32r	a3, 403745ac <_iram_text_start+0x1a8>
403759c1:	103230        	and	a3, a2, a3
403759c4:	120c      	movi.n	a2, 1
403759c6:	012220        	slli	a2, a2, 30
403759c9:	202320        	or	a2, a3, a2
403759cc:	1138      	l32i.n	a3, a1, 4
403759ce:	04cd      	mov.n	a12, a4
403759d0:	03bd      	mov.n	a11, a3
403759d2:	fdc2a2        	addi	a10, a2, -3
403759d5:	ffede5        	call8	403758b4 <print_entry>
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
403759d8:	faf181        	l32r	a8, 4037459c <_iram_text_start+0x198>
403759db:	faf191        	l32r	a9, 403745a0 <_iram_text_start+0x19c>
403759de:	838a      	add.n	a8, a3, a8
403759e0:	51b987        	bgeu	a9, a8, 40375a35 <esp_backtrace_print_from_frame+0xa1>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403759e3:	faf081        	l32r	a8, 403745a4 <_iram_text_start+0x1a0>

    //Check if first frame is valid
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
403759e6:	1a0c      	movi.n	a10, 1
403759e8:	338a      	add.n	a3, a3, a8
403759ea:	faef81        	l32r	a8, 403745a8 <_iram_text_start+0x1a4>
403759ed:	4d3837        	bltu	a8, a3, 40375a3e <esp_backtrace_print_from_frame+0xaa>
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
403759f0:	faf031        	l32r	a3, 403745b0 <_iram_text_start+0x1ac>
403759f3:	faf081        	l32r	a8, 403745b4 <_iram_text_start+0x1b0>
403759f6:	323a      	add.n	a3, a2, a3
403759f8:	64b837        	bgeu	a8, a3, 40375a60 <esp_backtrace_print_from_frame+0xcc>
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
403759fb:	faef31        	l32r	a3, 403745b8 <_iram_text_start+0x1b4>
403759fe:	faef81        	l32r	a8, 403745bc <_iram_text_start+0x1b8>
40375a01:	323a      	add.n	a3, a2, a3
40375a03:	59b837        	bgeu	a8, a3, 40375a60 <esp_backtrace_print_from_frame+0xcc>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
40375a06:	faee31        	l32r	a3, 403745c0 <_iram_text_start+0x1bc>
40375a09:	faee91        	l32r	a9, 403745c4 <_iram_text_start+0x1c0>
40375a0c:	080c      	movi.n	a8, 0
40375a0e:	323a      	add.n	a3, a2, a3
40375a10:	08ad      	mov.n	a10, a8
40375a12:	28b937        	bgeu	a9, a3, 40375a3e <esp_backtrace_print_from_frame+0xaa>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
40375a15:	faec31        	l32r	a3, 403745c8 <_iram_text_start+0x1c4>
40375a18:	223a      	add.n	a2, a2, a3
40375a1a:	fae331        	l32r	a3, 403745a8 <_iram_text_start+0x1a4>
40375a1d:	1db327        	bgeu	a3, a2, 40375a3e <esp_backtrace_print_from_frame+0xaa>
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
                        /* Ignore the first corrupted PC in case of InstrFetchProhibited */
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375a20:	3128      	l32i.n	a2, a1, 12
40375a22:	1a0c      	movi.n	a10, 1
                       (esp_ptr_executable((void *)esp_cpu_process_stack_pc(stk_frame.pc)) ||
40375a24:	161287        	beq	a2, a8, 40375a3e <esp_backtrace_print_from_frame+0xaa>
                        (stk_frame.exc_frame && ((XtExcFrame *)stk_frame.exc_frame)->exccause == EXCCAUSE_INSTR_PROHIBITED)));
40375a27:	142222        	l32i	a2, a2, 80
40375a2a:	ecc222        	addi	a2, a2, -20
40375a2d:	83a820        	moveqz	a10, a8, a2
40375a30:	000286        	j	40375a3e <esp_backtrace_print_from_frame+0xaa>
40375a33:	00          	.byte 00
40375a34:	00          	.byte 00
    return !(sp < SOC_DRAM_LOW + 0x10 || sp > SOC_DRAM_HIGH - 0x10 || ((sp & 0xF) != 0));
40375a35:	343030        	extui	a3, a3, 0, 4
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375a38:	01a0a2        	movi	a10, 1
        || esp_ptr_in_rtc_dram_fast((void*) sp)
40375a3b:	fb1316        	beqz	a3, 403759f0 <esp_backtrace_print_from_frame+0x5c>
40375a3e:	0a3d      	mov.n	a3, a10

    uint32_t i = (depth <= 0) ? INT32_MAX : depth;
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
        if (!esp_backtrace_get_next_frame(&stk_frame)) {    //Get previous stack frame
40375a40:	120c      	movi.n	a2, 1
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375a42:	2188      	l32i.n	a8, a1, 8
40375a44:	060816        	beqz	a8, 40375aa8 <esp_backtrace_print_from_frame+0x114>
40375a47:	a39c      	beqz.n	a3, 40375a65 <esp_backtrace_print_from_frame+0xd1>
    }

    //Print backtrace termination marker
    esp_err_t ret = ESP_OK;
    if (corrupted) {
        print_str(" |<-CORRUPTED", panic);
40375a49:	fae1a1        	l32r	a10, 403745d0 <_iram_text_start+0x1cc>
40375a4c:	20b440        	or	a11, a4, a4
40375a4f:	ffea25        	call8	403758f0 <print_str>
        ret =  ESP_FAIL;
40375a52:	ffaf22        	movi	a2, -1
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
        print_str(" |<-CONTINUES", panic);
    }
    print_str("\r\n\r\n", panic);
40375a55:	fae0a1        	l32r	a10, 403745d8 <_iram_text_start+0x1d4>
40375a58:	04bd      	mov.n	a11, a4
40375a5a:	ffe965        	call8	403758f0 <print_str>
    return ret;
}
40375a5d:	f01d      	retw.n
40375a5f:	00          	.byte 00
    bool corrupted = !(esp_stack_ptr_is_sane(stk_frame.sp) &&
40375a60:	0a0c      	movi.n	a10, 0
40375a62:	fff606        	j	40375a3e <esp_backtrace_print_from_frame+0xaa>
        if (!esp_backtrace_get_next_frame(&stk_frame)) {    //Get previous stack frame
40375a65:	20a110        	or	a10, a1, a1
40375a68:	ffea25        	call8	4037590c <esp_backtrace_get_next_frame>
40375a6b:	30aa20        	xor	a10, a10, a2
40375a6e:	7430a0        	extui	a3, a10, 0, 8
        print_entry(esp_cpu_process_stack_pc(stk_frame.pc), stk_frame.sp, panic);
40375a71:	01a8      	l32i.n	a10, a1, 0
    if (pc & 0x80000000) {
40375a73:	00dad6        	bgez	a10, 40375a84 <esp_backtrace_print_from_frame+0xf0>
        pc = (pc & 0x3fffffff) | 0x40000000;
40375a76:	facd81        	l32r	a8, 403745ac <_iram_text_start+0x1a8>
40375a79:	10aa80        	and	a10, a10, a8
40375a7c:	180c      	movi.n	a8, 1
40375a7e:	018820        	slli	a8, a8, 30
40375a81:	20aa80        	or	a10, a10, a8
40375a84:	11b8      	l32i.n	a11, a1, 4
40375a86:	04cd      	mov.n	a12, a4
40375a88:	fdcaa2        	addi	a10, a10, -3
40375a8b:	550b      	addi.n	a5, a5, -1
40375a8d:	ffe265        	call8	403758b4 <print_entry>
    while (i-- > 0 && stk_frame.next_pc != 0 && !corrupted) {
40375a90:	fae556        	bnez	a5, 40375a42 <esp_backtrace_print_from_frame+0xae>
    if (corrupted) {
40375a93:	fb2356        	bnez	a3, 40375a49 <esp_backtrace_print_from_frame+0xb5>
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
40375a96:	2158      	l32i.n	a5, a1, 8
    esp_err_t ret = ESP_OK;
40375a98:	032d      	mov.n	a2, a3
    } else if (stk_frame.next_pc != 0) {    //Backtrace continues
40375a9a:	fb7516        	beqz	a5, 40375a55 <esp_backtrace_print_from_frame+0xc1>
        print_str(" |<-CONTINUES", panic);
40375a9d:	facda1        	l32r	a10, 403745d4 <_iram_text_start+0x1d0>
40375aa0:	04bd      	mov.n	a11, a4
40375aa2:	ffe4e5        	call8	403758f0 <print_str>
40375aa5:	ffeb06        	j	40375a55 <esp_backtrace_print_from_frame+0xc1>
    esp_err_t ret = ESP_OK;
40375aa8:	032d      	mov.n	a2, a3
    if (corrupted) {
40375aaa:	fa7316        	beqz	a3, 40375a55 <esp_backtrace_print_from_frame+0xc1>
40375aad:	ffe606        	j	40375a49 <esp_backtrace_print_from_frame+0xb5>

40375ab0 <esp_backtrace_print>:

esp_err_t IRAM_ATTR esp_backtrace_print(int depth)
{
40375ab0:	006136        	entry	a1, 48
    //Initialize stk_frame with first frame of stack
    esp_backtrace_frame_t start = { 0 };
40375ab3:	10a0c2        	movi	a12, 16
40375ab6:	00a0b2        	movi	a11, 0
40375ab9:	20a110        	or	a10, a1, a1
40375abc:	fa6e81        	l32r	a8, 40374474 <_iram_text_start+0x70>
40375abf:	0008e0        	callx8	a8
    esp_backtrace_get_start(&(start.pc), &(start.sp), &(start.next_pc));
40375ac2:	c18b      	addi.n	a12, a1, 8
40375ac4:	b14b      	addi.n	a11, a1, 4
40375ac6:	01ad      	mov.n	a10, a1
40375ac8:	0000e5        	call8	40375ad8 <esp_backtrace_get_start>
    return esp_backtrace_print_from_frame(depth, &start, false);
40375acb:	0c0c      	movi.n	a12, 0
40375acd:	01bd      	mov.n	a11, a1
40375acf:	02ad      	mov.n	a10, a2
40375ad1:	ffec25        	call8	40375994 <esp_backtrace_print_from_frame>
}
40375ad4:	0a2d      	mov.n	a2, a10
40375ad6:	f01d      	retw.n

40375ad8 <esp_backtrace_get_start>:
    .section    .iram1, "ax"
    .align      4
    .global     esp_backtrace_get_start
    .type       esp_backtrace_get_start, @function
esp_backtrace_get_start:
    entry   a1, 32
40375ad8:	004136        	entry	a1, 32
    call8   xthal_window_spill  //Spill registers onto stack (excluding this function)
40375adb:	0a9a25        	call8	4038047c <xthal_window_spill>
    //a2, a3, a4 should be out arguments for i SP, i PC, i-1 PC respectively. Use a5 and a6 as scratch
    l32e    a5, sp, -16         //Get i PC, which is ret addres of i+1
40375ade:	09c150        	l32e	a5, a1, -16
    s32i    a5, a2, 0           //Store i PC to arg *pc
40375ae1:	006252        	s32i	a5, a2, 0
    l32e    a6, sp, -12         //Get i+1 SP. Used to access i BS
40375ae4:	09d160        	l32e	a6, a1, -12
    l32e    a5, a6, -12         //Get i SP
40375ae7:	09d650        	l32e	a5, a6, -12
    s32i    a5, a3, 0           //Store i SP to arg *sp
40375aea:	006352        	s32i	a5, a3, 0
    l32e    a5, a6, -16         //Get i-1 PC, which is ret address of i
40375aed:	09c650        	l32e	a5, a6, -16
    s32i    a5, a4, 0           //Store i-1 PC to arg *next_pc
40375af0:	006452        	s32i	a5, a4, 0
    retw
40375af3:	f01d      	retw.n
40375af5:	000000        	ill

40375af8 <esp_ipc_isr_stall_abort>:
    s_stall_state = STALL_STATE_IDLE;
    IPC_ISR_EXIT_CRITICAL();
}

void IRAM_ATTR esp_ipc_isr_stall_abort(void)
{
40375af8:	004136        	entry	a1, 32
    //Note: We don't enter a critical section here as we are calling this from a panic.
    s_stall_state = STALL_STATE_IDLE;
40375afb:	fab881        	l32r	a8, 403745dc <_iram_text_start+0x1d8>
40375afe:	090c      	movi.n	a9, 0
40375b00:	0020c0        	memw
40375b03:	0899      	s32i.n	a9, a8, 0
}
40375b05:	f01d      	retw.n
	...

40375b08 <esp_vApplicationTickHook>:
static portMUX_TYPE hooks_spinlock = portMUX_INITIALIZER_UNLOCKED;
static esp_freertos_idle_cb_t idle_cb[portNUM_PROCESSORS][MAX_HOOKS]={0};
static esp_freertos_tick_cb_t tick_cb[portNUM_PROCESSORS][MAX_HOOKS]={0};

void IRAM_ATTR esp_vApplicationTickHook(void)
{
40375b08:	004136        	entry	a1, 32
40375b0b:	03eb20        	rsr.prid	a2
40375b0e:	042d20        	extui	a2, a2, 13, 1
    int n;
    int core = xPortGetCoreID();
    for (n=0; n<MAX_HOOKS; n++) {
40375b11:	fab331        	l32r	a3, 403745e0 <_iram_text_start+0x1dc>
40375b14:	1122b0        	slli	a2, a2, 5
40375b17:	802230        	add	a2, a2, a3
40375b1a:	00a032        	movi	a3, 0
        if (tick_cb[core][n]!=NULL) {
40375b1d:	0288      	l32i.n	a8, a2, 0
40375b1f:	188c      	beqz.n	a8, 40375b24 <esp_vApplicationTickHook+0x1c>
            tick_cb[core][n]();
40375b21:	0008e0        	callx8	a8
    for (n=0; n<MAX_HOOKS; n++) {
40375b24:	331b      	addi.n	a3, a3, 1
40375b26:	224b      	addi.n	a2, a2, 4
40375b28:	f18366        	bnei	a3, 8, 40375b1d <esp_vApplicationTickHook+0x15>
        }
    }
}
40375b2b:	f01d      	retw.n
40375b2d:	000000        	ill

40375b30 <panic_abort>:
#endif /* CONFIG_ESP_SYSTEM_PANIC_GDBSTUB */
}


void IRAM_ATTR __attribute__((noreturn, no_sanitize_undefined)) panic_abort(const char *details)
{
40375b30:	004136        	entry	a1, 32
    g_panic_abort = true;
40375b33:	faac81        	l32r	a8, 403745e4 <_iram_text_start+0x1e0>
40375b36:	190c      	movi.n	a9, 1
40375b38:	004892        	s8i	a9, a8, 0
    s_panic_abort_details = (char *) details;
40375b3b:	faab81        	l32r	a8, 403745e8 <_iram_text_start+0x1e4>
40375b3e:	0829      	s32i.n	a2, a8, 0
    esp_apptrace_flush_nolock(ESP_APPTRACE_DEST_TRAX, CONFIG_APPTRACE_POSTMORTEM_FLUSH_THRESH,
                              APPTRACE_ONPANIC_HOST_FLUSH_TMO);
#endif
#endif

    *((volatile int *) 0) = 0; // NOLINT(clang-analyzer-core.NullDereference) should be an invalid operation on targets
40375b40:	080c      	movi.n	a8, 0
40375b42:	0020c0        	memw
40375b45:	0889      	s32i.n	a8, a8, 0
40375b47:	0041f0        	break	1, 15
	...

40375b4c <esp_rom_install_uart_printf>:
    }
}

#if ESP_ROM_HAS_ETS_PRINTF_BUG
IRAM_ATTR void esp_rom_install_uart_printf(void)
{
40375b4c:	004136        	entry	a1, 32
    extern void ets_install_uart_printf(void);
    extern bool g_uart_print;
    extern bool g_usb_print;
    // If ROM log is disabled permanently via eFuse or temporarily via RTC storage register,
    // this ROM symbol will be set to false, and cause ``esp_rom_printf`` can't work on esp-idf side.
    g_uart_print = true;
40375b4f:	faa791        	l32r	a9, 403745ec <_iram_text_start+0x1e8>
40375b52:	01a082        	movi	a8, 1
40375b55:	004982        	s8i	a8, a9, 0
    g_usb_print = true;
40375b58:	faa691        	l32r	a9, 403745f0 <_iram_text_start+0x1ec>
40375b5b:	004982        	s8i	a8, a9, 0
    ets_install_uart_printf();
40375b5e:	faa581        	l32r	a8, 403745f4 <_iram_text_start+0x1f0>
40375b61:	0008e0        	callx8	a8
}
40375b64:	f01d      	retw.n
	...

40375b68 <esp_rom_uart_set_clock_baudrate>:
    while (!uart_ll_is_tx_idle(UART_LL_GET_HW(uart_no))) {};
}
#endif

IRAM_ATTR void esp_rom_uart_set_clock_baudrate(uint8_t uart_no, uint32_t clock_hz, uint32_t baud_rate)
{
40375b68:	006136        	entry	a1, 48
40375b6b:	742020        	extui	a2, a2, 0, 8
    uart_ll_set_baudrate(UART_LL_GET_HW(uart_no), baud_rate, clock_hz);
40375b6e:	faa391        	l32r	a9, 403745fc <_iram_text_start+0x1f8>
40375b71:	728c      	beqz.n	a2, 40375b7c <esp_rom_uart_set_clock_baudrate+0x14>
40375b73:	faa391        	l32r	a9, 40374600 <_iram_text_start+0x1fc>
40375b76:	021226        	beqi	a2, 1, 40375b7c <esp_rom_uart_set_clock_baudrate+0x14>
40375b79:	fa9f91        	l32r	a9, 403745f8 <_iram_text_start+0x1f4>
 */
FORCE_INLINE_ATTR void uart_ll_set_baudrate(uart_dev_t *hw, uint32_t baud, uint32_t sclk_freq)
{
#define DIV_UP(a, b)    (((a) + (b) - 1) / (b))
    const uint32_t max_div = BIT(12) - 1;   // UART divider integer part only has 12 bits
    int sclk_div = DIV_UP(sclk_freq, max_div * baud);
40375b7c:	11a440        	slli	a10, a4, 12
40375b7f:	c0aa40        	sub	a10, a10, a4
40375b82:	830b      	addi.n	a8, a3, -1
40375b84:	88aa      	add.n	a8, a8, a10
40375b86:	c288a0        	quou	a8, a8, a10

    uint32_t clk_div = ((sclk_freq) << 4) / (baud * sclk_div);
40375b89:	824480        	mull	a4, a4, a8
40375b8c:	1133c0        	slli	a3, a3, 4
    // The baud rate configuration register is divided into
    // an integer part and a fractional part.
    hw->clkdiv.clkdiv = clk_div >> 4;
40375b8f:	0020c0        	memw
40375b92:	59a8      	l32i.n	a10, a9, 20
    uint32_t clk_div = ((sclk_freq) << 4) / (baud * sclk_div);
40375b94:	c23340        	quou	a3, a3, a4
    hw->clkdiv.clkdiv = clk_div >> 4;
40375b97:	f47c      	movi.n	a4, -1
40375b99:	114440        	slli	a4, a4, 12
40375b9c:	b42430        	extui	a2, a3, 4, 12
40375b9f:	10aa40        	and	a10, a10, a4
40375ba2:	20aa20        	or	a10, a10, a2
40375ba5:	0020c0        	memw
40375ba8:	59a9      	s32i.n	a10, a9, 20
    hw->clkdiv.clkdiv_frag = clk_div &  0xf;
40375baa:	0020c0        	memw
40375bad:	59a8      	l32i.n	a10, a9, 20
40375baf:	fa9521        	l32r	a2, 40374604 <_iram_text_start+0x200>
40375bb2:	343030        	extui	a3, a3, 0, 4
40375bb5:	10aa20        	and	a10, a10, a2
40375bb8:	0133c0        	slli	a3, a3, 20
40375bbb:	203a30        	or	a3, a10, a3
40375bbe:	0020c0        	memw
40375bc1:	5939      	s32i.n	a3, a9, 20
    HAL_FORCE_MODIFY_U32_REG_FIELD(hw->clk_conf, sclk_div_num, sclk_div - 1);
40375bc3:	0020c0        	memw
40375bc6:	1e2922        	l32i	a2, a9, 120
40375bc9:	880b      	addi.n	a8, a8, -1
40375bcb:	0020c0        	memw
40375bce:	0129      	s32i.n	a2, a1, 0
40375bd0:	0020c0        	memw
40375bd3:	0138      	l32i.n	a3, a1, 0
40375bd5:	fa8c21        	l32r	a2, 40374608 <_iram_text_start+0x204>
40375bd8:	748080        	extui	a8, a8, 0, 8
40375bdb:	103320        	and	a3, a3, a2
40375bde:	118840        	slli	a8, a8, 12
40375be1:	203380        	or	a3, a3, a8
40375be4:	0020c0        	memw
40375be7:	0139      	s32i.n	a3, a1, 0
40375be9:	0020c0        	memw
40375bec:	0128      	l32i.n	a2, a1, 0
40375bee:	0020c0        	memw
40375bf1:	1e6922        	s32i	a2, a9, 120
}
40375bf4:	f01d      	retw.n
	...

40375bf8 <brownout_hal_intr_clear>:
{
    RTCCNTL.int_ena.rtc_brown_out = enable;
}

IRAM_ATTR void brownout_hal_intr_clear(void)
{
40375bf8:	004136        	entry	a1, 32
    RTCCNTL.int_clr.rtc_brown_out = 1;
40375bfb:	fa8491        	l32r	a9, 4037460c <_iram_text_start+0x208>
40375bfe:	00a2a2        	movi	a10, 0x200
40375c01:	0020c0        	memw
40375c04:	132982        	l32i	a8, a9, 76
40375c07:	2088a0        	or	a8, a8, a10
40375c0a:	0020c0        	memw
40375c0d:	136982        	s32i	a8, a9, 76
}
40375c10:	f01d      	retw.n
	...

40375c14 <heap_caps_alloc_failed>:
    *iptr = dstart;
    return iptr + 1;
}

IRAM_ATTR NOINLINE_ATTR static void heap_caps_alloc_failed(size_t requested_size, uint32_t caps, const char *function_name)
{
40375c14:	004136        	entry	a1, 32
    if (alloc_failed_callback) {
40375c17:	fa7e81        	l32r	a8, 40374610 <_iram_text_start+0x20c>
{
40375c1a:	02ad      	mov.n	a10, a2
    if (alloc_failed_callback) {
40375c1c:	0888      	l32i.n	a8, a8, 0
{
40375c1e:	03bd      	mov.n	a11, a3
40375c20:	04cd      	mov.n	a12, a4
    if (alloc_failed_callback) {
40375c22:	002816        	beqz	a8, 40375c28 <heap_caps_alloc_failed+0x14>
        alloc_failed_callback(requested_size, caps, function_name);
40375c25:	0008e0        	callx8	a8
#ifdef CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS
    char buf[48];
    fmt_abort_str(buf, requested_size, caps);
    esp_system_abort(buf);
#endif
}
40375c28:	f01d      	retw.n
	...

40375c2c <find_containing_heap>:

   (This confirms if ptr is inside the heap's region, doesn't confirm if 'ptr'
   is an allocated block or is some other random address inside the heap.)
*/
IRAM_ATTR static heap_t *find_containing_heap(void *ptr )
{
40375c2c:	004136        	entry	a1, 32
    intptr_t p = (intptr_t)ptr;
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
40375c2f:	fa7981        	l32r	a8, 40374614 <_iram_text_start+0x210>
40375c32:	0888      	l32i.n	a8, a8, 0
40375c34:	28cc      	bnez.n	a8, 40375c3a <find_containing_heap+0xe>
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
            return heap;
        }
    }
    return NULL;
}
40375c36:	082d      	mov.n	a2, a8
40375c38:	f01d      	retw.n
        if (heap->heap != NULL && p >= heap->start && p < heap->end) {
40375c3a:	7898      	l32i.n	a9, a8, 28
40375c3c:	898c      	beqz.n	a9, 40375c48 <find_containing_heap+0x1c>
40375c3e:	3898      	l32i.n	a9, a8, 12
40375c40:	042297        	blt	a2, a9, 40375c48 <find_containing_heap+0x1c>
40375c43:	4898      	l32i.n	a9, a8, 16
40375c45:	ed2297        	blt	a2, a9, 40375c36 <find_containing_heap+0xa>
    SLIST_FOREACH(heap, &registered_heaps, next) {
40375c48:	8888      	l32i.n	a8, a8, 32
40375c4a:	fff986        	j	40375c34 <find_containing_heap+0x8>
40375c4d:	000000        	ill

40375c50 <heap_caps_malloc_base>:
{
40375c50:	006136        	entry	a1, 48
    if (size > HEAP_SIZE_MAX) {
40375c53:	fa5851        	l32r	a5, 403745b4 <_iram_text_start+0x1b0>
40375c56:	420b      	addi.n	a4, a2, -1
40375c58:	2e3547        	bltu	a5, a4, 40375c8a <heap_caps_malloc_base+0x3a>
    if (caps & MALLOC_CAP_EXEC) {
40375c5b:	156307        	bbci	a3, 0, 40375c74 <heap_caps_malloc_base+0x24>
        if ((caps & MALLOC_CAP_8BIT) || (caps & MALLOC_CAP_DMA)) {
40375c5e:	c40c      	movi.n	a4, 12
40375c60:	268347        	bany	a3, a4, 40375c8a <heap_caps_malloc_base+0x3a>
        caps |= MALLOC_CAP_32BIT; // IRAM is 32-bit accessible RAM
40375c63:	240c      	movi.n	a4, 2
40375c65:	203340        	or	a3, a3, a4
        size = (size + 3) & (~3); // int overflow checked above
40375c68:	223b      	addi.n	a2, a2, 3
40375c6a:	c47c      	movi.n	a4, -4
40375c6c:	102240        	and	a2, a2, a4
40375c6f:	000106        	j	40375c77 <heap_caps_malloc_base+0x27>
40375c72:	00          	.byte 00
40375c73:	00          	.byte 00
    if (caps & MALLOC_CAP_32BIT) {
40375c74:	f0e317        	bbsi	a3, 1, 40375c68 <heap_caps_malloc_base+0x18>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40375c77:	050c      	movi.n	a5, 0
        SLIST_FOREACH(heap, &registered_heaps, next) {
40375c79:	fa6661        	l32r	a6, 40374614 <_iram_text_start+0x210>
            if ((heap->caps[prio] & caps) != 0) {
40375c7c:	1185e0        	slli	a8, a5, 2
        SLIST_FOREACH(heap, &registered_heaps, next) {
40375c7f:	0648      	l32i.n	a4, a6, 0
            if ((heap->caps[prio] & caps) != 0) {
40375c81:	0189      	s32i.n	a8, a1, 0
        SLIST_FOREACH(heap, &registered_heaps, next) {
40375c83:	94cc      	bnez.n	a4, 40375c90 <heap_caps_malloc_base+0x40>
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
40375c85:	551b      	addi.n	a5, a5, 1
40375c87:	ee3566        	bnei	a5, 3, 40375c79 <heap_caps_malloc_base+0x29>
        return NULL;
40375c8a:	0a0c      	movi.n	a10, 0
40375c8c:	002606        	j	40375d28 <heap_caps_malloc_base+0xd8>
40375c8f:	00          	.byte 00
            if (heap->heap == NULL) {
40375c90:	74a8      	l32i.n	a10, a4, 28
40375c92:	3acc      	bnez.n	a10, 40375c99 <heap_caps_malloc_base+0x49>
        SLIST_FOREACH(heap, &registered_heaps, next) {
40375c94:	8448      	l32i.n	a4, a4, 32
40375c96:	fffa46        	j	40375c83 <heap_caps_malloc_base+0x33>
            if ((heap->caps[prio] & caps) != 0) {
40375c99:	002182        	l32i	a8, a1, 0
40375c9c:	806480        	add	a6, a4, a8
40375c9f:	0668      	l32i.n	a6, a6, 0
40375ca1:	ef0367        	bnone	a3, a6, 40375c94 <heap_caps_malloc_base+0x44>
    if (heap->heap == NULL) {
        return 0;
    }
    uint32_t all_caps = 0;
    for (int prio = 0; prio < SOC_MEMORY_TYPE_NO_PRIOS; prio++) {
        all_caps |= heap->caps[prio];
40375ca4:	1478      	l32i.n	a7, a4, 4
40375ca6:	0468      	l32i.n	a6, a4, 0
40375ca8:	206670        	or	a6, a6, a7
40375cab:	2478      	l32i.n	a7, a4, 8
40375cad:	206670        	or	a6, a6, a7
                if ((get_all_caps(heap) & caps) == caps) {
40375cb0:	106630        	and	a6, a6, a3
40375cb3:	dd9637        	bne	a6, a3, 40375c94 <heap_caps_malloc_base+0x44>
                    if ((caps & MALLOC_CAP_EXEC) && esp_ptr_in_diram_dram((void *)heap->start)) {
40375cb6:	726307        	bbci	a3, 0, 40375d2c <heap_caps_malloc_base+0xdc>
    return ((intptr_t)p >= SOC_DIRAM_DRAM_LOW && (intptr_t)p < SOC_DIRAM_DRAM_HIGH);
40375cb9:	3478      	l32i.n	a7, a4, 12
40375cbb:	fa5761        	l32r	a6, 40374618 <_iram_text_start+0x214>
40375cbe:	fa5791        	l32r	a9, 4037461c <_iram_text_start+0x218>
40375cc1:	776a      	add.n	a7, a7, a6
40375cc3:	653977        	bltu	a9, a7, 40375d2c <heap_caps_malloc_base+0xdc>
                        ret = multi_heap_malloc(heap->heap, size + 4);  // int overflow checked above
40375cc6:	724b      	addi.n	a7, a2, 4
40375cc8:	07bd      	mov.n	a11, a7
40375cca:	1199      	s32i.n	a9, a1, 4
40375ccc:	07faa5        	call8	4037dc78 <multi_heap_malloc>
                        if (ret != NULL) {
40375ccf:	1198      	l32i.n	a9, a1, 4
40375cd1:	fbfa16        	beqz	a10, 40375c94 <heap_caps_malloc_base+0x44>
40375cd4:	6a6a      	add.n	a6, a10, a6
    uintptr_t dend __attribute__((unused)) = dstart + len - 4; //Last word
40375cd6:	77aa      	add.n	a7, a7, a10
    assert(esp_ptr_in_diram_dram((void *)dstart));
40375cd8:	0db967        	bgeu	a9, a6, 40375ce9 <heap_caps_malloc_base+0x99>
40375cdb:	fa51d1        	l32r	a13, 40374620 <_iram_text_start+0x21c>
40375cde:	fa51c1        	l32r	a12, 40374624 <_iram_text_start+0x220>
40375ce1:	1b4c      	movi.n	a11, 65
    assert(esp_ptr_in_diram_dram((void *)dend));
40375ce3:	fa51a1        	l32r	a10, 40374628 <_iram_text_start+0x224>
40375ce6:	08b265        	call8	4037e80c <__assert_func>
40375ce9:	fa5021        	l32r	a2, 4037462c <_iram_text_start+0x228>
40375cec:	272a      	add.n	a2, a7, a2
40375cee:	0ab927        	bgeu	a9, a2, 40375cfc <heap_caps_malloc_base+0xac>
40375cf1:	fa4fd1        	l32r	a13, 40374630 <_iram_text_start+0x22c>
40375cf4:	fa4cc1        	l32r	a12, 40374624 <_iram_text_start+0x220>
40375cf7:	2b4c      	movi.n	a11, 66
40375cf9:	fff986        	j	40375ce3 <heap_caps_malloc_base+0x93>
    assert((dstart & 3) == 0);
40375cfc:	1420a0        	extui	a2, a10, 0, 2
40375cff:	928c      	beqz.n	a2, 40375d0c <heap_caps_malloc_base+0xbc>
40375d01:	fa4cd1        	l32r	a13, 40374634 <_iram_text_start+0x230>
40375d04:	fa48c1        	l32r	a12, 40374624 <_iram_text_start+0x220>
40375d07:	3b4c      	movi.n	a11, 67
40375d09:	fff586        	j	40375ce3 <heap_caps_malloc_base+0x93>
    assert((dend & 3) == 0);
40375d0c:	147070        	extui	a7, a7, 0, 2
40375d0f:	978c      	beqz.n	a7, 40375d1c <heap_caps_malloc_base+0xcc>
40375d11:	fa49d1        	l32r	a13, 40374638 <_iram_text_start+0x234>
40375d14:	fa44c1        	l32r	a12, 40374624 <_iram_text_start+0x220>
40375d17:	4b4c      	movi.n	a11, 68
40375d19:	fff186        	j	40375ce3 <heap_caps_malloc_base+0x93>
    return (void *) ( SOC_DIRAM_IRAM_LOW + ((intptr_t)p - SOC_DIRAM_DRAM_LOW) );
40375d1c:	6fa082        	movi	a8, 111
40375d1f:	118800        	slli	a8, a8, 16
40375d22:	8a8a      	add.n	a8, a10, a8
    *iptr = dstart;
40375d24:	08a9      	s32i.n	a10, a8, 0
    return iptr + 1;
40375d26:	a84b      	addi.n	a10, a8, 4
}
40375d28:	0a2d      	mov.n	a2, a10
40375d2a:	f01d      	retw.n
                        ret = multi_heap_malloc(heap->heap, size);
40375d2c:	02bd      	mov.n	a11, a2
40375d2e:	07f4a5        	call8	4037dc78 <multi_heap_malloc>
                        if (ret != NULL) {
40375d31:	f5fa16        	beqz	a10, 40375c94 <heap_caps_malloc_base+0x44>
40375d34:	fffc06        	j	40375d28 <heap_caps_malloc_base+0xd8>
	...

40375d38 <heap_caps_malloc>:
IRAM_ATTR void *heap_caps_malloc( size_t size, uint32_t caps){
40375d38:	004136        	entry	a1, 32
    void* ptr = heap_caps_malloc_base(size, caps);
40375d3b:	20b330        	or	a11, a3, a3
40375d3e:	20a220        	or	a10, a2, a2
40375d41:	fff0e5        	call8	40375c50 <heap_caps_malloc_base>
40375d44:	0a4d      	mov.n	a4, a10
    if (!ptr && size > 0){
40375d46:	aacc      	bnez.n	a10, 40375d54 <heap_caps_malloc+0x1c>
40375d48:	828c      	beqz.n	a2, 40375d54 <heap_caps_malloc+0x1c>
        heap_caps_alloc_failed(size, caps, __func__);
40375d4a:	fa3cc1        	l32r	a12, 4037463c <_iram_text_start+0x238>
40375d4d:	03bd      	mov.n	a11, a3
40375d4f:	02ad      	mov.n	a10, a2
40375d51:	ffec25        	call8	40375c14 <heap_caps_alloc_failed>
}
40375d54:	042d      	mov.n	a2, a4
40375d56:	f01d      	retw.n

40375d58 <heap_caps_malloc_default>:
{
40375d58:	004136        	entry	a1, 32
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375d5b:	fa3931        	l32r	a3, 40374640 <_iram_text_start+0x23c>
40375d5e:	002332        	l32i	a3, a3, 0
40375d61:	110366        	bnei	a3, -1, 40375d76 <heap_caps_malloc_default+0x1e>
        return heap_caps_malloc( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375d64:	03a0b2        	movi	a11, 3
40375d67:	11bb50        	slli	a11, a11, 11
40375d6a:	20a220        	or	a10, a2, a2
40375d6d:	fffca5        	call8	40375d38 <heap_caps_malloc>
40375d70:	0a3d      	mov.n	a3, a10
}
40375d72:	032d      	mov.n	a2, a3
40375d74:	f01d      	retw.n
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375d76:	3b0c      	movi.n	a11, 3
40375d78:	11bb50        	slli	a11, a11, 11
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375d7b:	05b327        	bgeu	a3, a2, 40375d84 <heap_caps_malloc_default+0x2c>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM );
40375d7e:	05a0b2        	movi	a11, 5
40375d81:	11bb60        	slli	a11, a11, 10
40375d84:	02ad      	mov.n	a10, a2
40375d86:	ffeca5        	call8	40375c50 <heap_caps_malloc_base>
40375d89:	0a3d      	mov.n	a3, a10
        if (r==NULL && size > 0) {
40375d8b:	fe3a56        	bnez	a10, 40375d72 <heap_caps_malloc_default+0x1a>
40375d8e:	fe0216        	beqz	a2, 40375d72 <heap_caps_malloc_default+0x1a>
            r=heap_caps_malloc_base( size, MALLOC_CAP_DEFAULT );
40375d91:	140c      	movi.n	a4, 1
40375d93:	114440        	slli	a4, a4, 12
40375d96:	04bd      	mov.n	a11, a4
40375d98:	02ad      	mov.n	a10, a2
40375d9a:	ffeb65        	call8	40375c50 <heap_caps_malloc_base>
40375d9d:	0a3d      	mov.n	a3, a10
        if (r==NULL && size > 0){
40375d9f:	fcfa56        	bnez	a10, 40375d72 <heap_caps_malloc_default+0x1a>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375da2:	fa28c1        	l32r	a12, 40374644 <_iram_text_start+0x240>
40375da5:	04bd      	mov.n	a11, a4
40375da7:	02ad      	mov.n	a10, a2
40375da9:	ffe6a5        	call8	40375c14 <heap_caps_alloc_failed>
40375dac:	fff086        	j	40375d72 <heap_caps_malloc_default+0x1a>
	...

40375db0 <heap_caps_free>:

IRAM_ATTR void heap_caps_free( void *ptr)
{
40375db0:	004136        	entry	a1, 32
    if (ptr == NULL) {
40375db3:	02e216        	beqz	a2, 40375de5 <heap_caps_free+0x35>
    return ((intptr_t)p >= SOC_DIRAM_IRAM_LOW && (intptr_t)p < SOC_DIRAM_IRAM_HIGH);
40375db6:	fa2481        	l32r	a8, 40374648 <_iram_text_start+0x244>
        return;
    }

    if (esp_ptr_in_diram_iram(ptr)) {
40375db9:	fa1891        	l32r	a9, 4037461c <_iram_text_start+0x218>
40375dbc:	808280        	add	a8, a2, a8
40375dbf:	053987        	bltu	a9, a8, 40375dc8 <heap_caps_free+0x18>
        //Memory allocated here is actually allocated in the DRAM alias region and
        //cannot be de-allocated as usual. dram_alloc_to_iram_addr stores a pointer to
        //the equivalent DRAM address, though; free that.
        uint32_t *dramAddrPtr = (uint32_t *)ptr;
        ptr = (void *)dramAddrPtr[-1];
40375dc2:	fcc222        	addi	a2, a2, -4
40375dc5:	002222        	l32i	a2, a2, 0
    }

    heap_t *heap = find_containing_heap(ptr);
40375dc8:	02ad      	mov.n	a10, a2
40375dca:	ffe625        	call8	40375c2c <find_containing_heap>
    assert(heap != NULL && "free() target pointer is outside heap areas");
40375dcd:	dacc      	bnez.n	a10, 40375dde <heap_caps_free+0x2e>
40375dcf:	fa1fd1        	l32r	a13, 4037464c <_iram_text_start+0x248>
40375dd2:	fa1fc1        	l32r	a12, 40374650 <_iram_text_start+0x24c>
40375dd5:	fa14a1        	l32r	a10, 40374628 <_iram_text_start+0x224>
40375dd8:	75a1b2        	movi	a11, 0x175
40375ddb:	08a325        	call8	4037e80c <__assert_func>
    multi_heap_free(heap->heap, ptr);
40375dde:	7aa8      	l32i.n	a10, a10, 28
40375de0:	02bd      	mov.n	a11, a2
40375de2:	07e265        	call8	4037dc08 <multi_heap_aligned_free>
}
40375de5:	f01d      	retw.n
	...

40375de8 <heap_caps_realloc_base>:
/*
This function should not be called directly as it does not
check for failure / call heap_caps_alloc_failed()
*/
IRAM_ATTR static void *heap_caps_realloc_base( void *ptr, size_t size, uint32_t caps)
{
40375de8:	006136        	entry	a1, 48
    bool ptr_in_diram_case = false;
    heap_t *heap = NULL;
    void *dram_ptr = NULL;

    if (ptr == NULL) {
40375deb:	b2cc      	bnez.n	a2, 40375dfa <heap_caps_realloc_base+0x12>
        return heap_caps_malloc_base(size, caps);
40375ded:	04bd      	mov.n	a11, a4
40375def:	03ad      	mov.n	a10, a3
40375df1:	ffe5e5        	call8	40375c50 <heap_caps_malloc_base>
40375df4:	0a5d      	mov.n	a5, a10
        heap_caps_free(ptr);
        return new_p;
    }

    return NULL;
}
40375df6:	052d      	mov.n	a2, a5
40375df8:	f01d      	retw.n
    if (size == 0) {
40375dfa:	b3cc      	bnez.n	a3, 40375e09 <heap_caps_realloc_base+0x21>
        heap_caps_free(ptr);
40375dfc:	02ad      	mov.n	a10, a2
40375dfe:	fffb25        	call8	40375db0 <heap_caps_free>
        return NULL;
40375e01:	050c      	movi.n	a5, 0
40375e03:	fffbc6        	j	40375df6 <heap_caps_realloc_base+0xe>
40375e06:	00          	.byte 00
40375e07:	00          	.byte 00
40375e08:	00          	.byte 00
    if (size > HEAP_SIZE_MAX) {
40375e09:	01a052        	movi	a5, 1
40375e0c:	015570        	slli	a5, a5, 25
40375e0f:	ee3537        	bltu	a5, a3, 40375e01 <heap_caps_realloc_base+0x19>
40375e12:	fa0d51        	l32r	a5, 40374648 <_iram_text_start+0x244>
    if(esp_ptr_in_diram_iram((void *)ptr)) {
40375e15:	fa0161        	l32r	a6, 4037461c <_iram_text_start+0x218>
40375e18:	805250        	add	a5, a2, a5
40375e1b:	1e3657        	bltu	a6, a5, 40375e3d <heap_caps_realloc_base+0x55>
        dram_ptr  = (void *)dram_addr[-1];
40375e1e:	fcc252        	addi	a5, a2, -4
40375e21:	0578      	l32i.n	a7, a5, 0
        heap = find_containing_heap(dram_ptr);
40375e23:	07ad      	mov.n	a10, a7
40375e25:	ffe065        	call8	40375c2c <find_containing_heap>
40375e28:	0a6d      	mov.n	a6, a10
        ptr_in_diram_case = true;
40375e2a:	180c      	movi.n	a8, 1
        assert(heap != NULL && "realloc() pointer is outside heap areas");
40375e2c:	aaec      	bnez.n	a10, 40375e5a <heap_caps_realloc_base+0x72>
40375e2e:	fa09d1        	l32r	a13, 40374654 <_iram_text_start+0x250>
40375e31:	fa09c1        	l32r	a12, 40374658 <_iram_text_start+0x254>
40375e34:	97a1b2        	movi	a11, 0x197
        assert(heap != NULL && "realloc() pointer is outside heap areas");
40375e37:	f9fca1        	l32r	a10, 40374628 <_iram_text_start+0x224>
40375e3a:	089d25        	call8	4037e80c <__assert_func>
        heap = find_containing_heap(ptr);
40375e3d:	20a220        	or	a10, a2, a2
40375e40:	ffdea5        	call8	40375c2c <find_containing_heap>
    void *dram_ptr = NULL;
40375e43:	00a072        	movi	a7, 0
        heap = find_containing_heap(ptr);
40375e46:	206aa0        	or	a6, a10, a10
    bool ptr_in_diram_case = false;
40375e49:	078d      	mov.n	a8, a7
        assert(heap != NULL && "realloc() pointer is outside heap areas");
40375e4b:	0b9a77        	bne	a10, a7, 40375e5a <heap_caps_realloc_base+0x72>
40375e4e:	fa01d1        	l32r	a13, 40374654 <_iram_text_start+0x250>
40375e51:	fa01c1        	l32r	a12, 40374658 <_iram_text_start+0x254>
40375e54:	a0a1b2        	movi	a11, 0x1a0
40375e57:	fff706        	j	40375e37 <heap_caps_realloc_base+0x4f>
    if (heap->heap == NULL) {
40375e5a:	76a8      	l32i.n	a10, a6, 28
        return 0;
40375e5c:	0a5d      	mov.n	a5, a10
    if (heap->heap == NULL) {
40375e5e:	ba8c      	beqz.n	a10, 40375e6d <heap_caps_realloc_base+0x85>
        all_caps |= heap->caps[prio];
40375e60:	1698      	l32i.n	a9, a6, 4
40375e62:	0658      	l32i.n	a5, a6, 0
40375e64:	205590        	or	a5, a5, a9
40375e67:	022692        	l32i	a9, a6, 8
40375e6a:	205590        	or	a5, a5, a9
    bool compatible_caps = (caps & get_all_caps(heap)) == caps;
40375e6d:	105450        	and	a5, a4, a5
40375e70:	190c      	movi.n	a9, 1
    if (compatible_caps && !ptr_in_diram_case) {
40375e72:	029547        	bne	a5, a4, 40375e78 <heap_caps_realloc_base+0x90>
40375e75:	2c9897        	bne	a8, a9, 40375ea5 <heap_caps_realloc_base+0xbd>
    void *new_p = heap_caps_malloc_base(size, caps);
40375e78:	04bd      	mov.n	a11, a4
40375e7a:	03ad      	mov.n	a10, a3
40375e7c:	006182        	s32i	a8, a1, 0
40375e7f:	ffdd25        	call8	40375c50 <heap_caps_malloc_base>
    if (new_p != NULL) {
40375e82:	0188      	l32i.n	a8, a1, 0
    void *new_p = heap_caps_malloc_base(size, caps);
40375e84:	0a5d      	mov.n	a5, a10
    if (new_p != NULL) {
40375e86:	f77a16        	beqz	a10, 40375e01 <heap_caps_realloc_base+0x19>
            old_size = multi_heap_get_allocated_size(heap->heap, dram_ptr);
40375e89:	76a8      	l32i.n	a10, a6, 28
40375e8b:	07bd      	mov.n	a11, a7
        if(ptr_in_diram_case) {
40375e8d:	08cc      	bnez.n	a8, 40375e91 <heap_caps_realloc_base+0xa9>
            old_size = multi_heap_get_allocated_size(heap->heap, ptr);
40375e8f:	02bd      	mov.n	a11, a2
40375e91:	07dbe5        	call8	4037dc50 <multi_heap_get_allocated_size>
        assert(old_size > 0);
40375e94:	4aec      	bnez.n	a10, 40375ebc <heap_caps_realloc_base+0xd4>
40375e96:	f9f1d1        	l32r	a13, 4037465c <_iram_text_start+0x258>
40375e99:	f9efc1        	l32r	a12, 40374658 <_iram_text_start+0x254>
40375e9c:	bea1b2        	movi	a11, 0x1be
40375e9f:	ffe506        	j	40375e37 <heap_caps_realloc_base+0x4f>
40375ea2:	00          	.byte 00
40375ea3:	00          	.byte 00
40375ea4:	00          	.byte 00
        void *r = multi_heap_realloc(heap->heap, ptr, size);
40375ea5:	20c330        	or	a12, a3, a3
40375ea8:	20b220        	or	a11, a2, a2
40375eab:	006182        	s32i	a8, a1, 0
40375eae:	07e225        	call8	4037dcd0 <multi_heap_realloc>
        if (r != NULL) {
40375eb1:	0188      	l32i.n	a8, a1, 0
        void *r = multi_heap_realloc(heap->heap, ptr, size);
40375eb3:	0a5d      	mov.n	a5, a10
        if (r != NULL) {
40375eb5:	f3da56        	bnez	a10, 40375df6 <heap_caps_realloc_base+0xe>
40375eb8:	ffef06        	j	40375e78 <heap_caps_realloc_base+0x90>
40375ebb:	00          	.byte 00
        memcpy(new_p, ptr, MIN(size, old_size));
40375ebc:	63ca30        	minu	a12, a10, a3
40375ebf:	20b220        	or	a11, a2, a2
40375ec2:	20a550        	or	a10, a5, a5
40375ec5:	f97a81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
40375ec8:	0008e0        	callx8	a8
        heap_caps_free(ptr);
40375ecb:	20a220        	or	a10, a2, a2
40375ece:	ffee25        	call8	40375db0 <heap_caps_free>
        return new_p;
40375ed1:	ffc846        	j	40375df6 <heap_caps_realloc_base+0xe>

40375ed4 <heap_caps_realloc>:

IRAM_ATTR void *heap_caps_realloc( void *ptr, size_t size, uint32_t caps)
{
40375ed4:	004136        	entry	a1, 32
    ptr = heap_caps_realloc_base(ptr, size, caps);
40375ed7:	02ad      	mov.n	a10, a2
40375ed9:	04cd      	mov.n	a12, a4
40375edb:	03bd      	mov.n	a11, a3
40375edd:	fff0a5        	call8	40375de8 <heap_caps_realloc_base>
40375ee0:	0a2d      	mov.n	a2, a10

    if (ptr == NULL && size > 0){
40375ee2:	aacc      	bnez.n	a10, 40375ef0 <heap_caps_realloc+0x1c>
40375ee4:	838c      	beqz.n	a3, 40375ef0 <heap_caps_realloc+0x1c>
        heap_caps_alloc_failed(size, caps, __func__);
40375ee6:	f9dec1        	l32r	a12, 40374660 <_iram_text_start+0x25c>
40375ee9:	04bd      	mov.n	a11, a4
40375eeb:	03ad      	mov.n	a10, a3
40375eed:	ffd265        	call8	40375c14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375ef0:	f01d      	retw.n
	...

40375ef4 <heap_caps_realloc_default>:
{
40375ef4:	004136        	entry	a1, 32
40375ef7:	205220        	or	a5, a2, a2
    if (malloc_alwaysinternal_limit==MALLOC_DISABLE_EXTERNAL_ALLOCS) {
40375efa:	f9d121        	l32r	a2, 40374640 <_iram_text_start+0x23c>
40375efd:	002222        	l32i	a2, a2, 0
40375f00:	100266        	bnei	a2, -1, 40375f14 <heap_caps_realloc_default+0x20>
        return heap_caps_realloc( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL );
40375f03:	03a0c2        	movi	a12, 3
40375f06:	11cc50        	slli	a12, a12, 11
40375f09:	03bd      	mov.n	a11, a3
40375f0b:	05ad      	mov.n	a10, a5
40375f0d:	fffc65        	call8	40375ed4 <heap_caps_realloc>
40375f10:	0a2d      	mov.n	a2, a10
}
40375f12:	f01d      	retw.n
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
40375f14:	3c0c      	movi.n	a12, 3
40375f16:	11cc50        	slli	a12, a12, 11
        if (size <= (size_t)malloc_alwaysinternal_limit) {
40375f19:	05b237        	bgeu	a2, a3, 40375f22 <heap_caps_realloc_default+0x2e>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM);
40375f1c:	05a0c2        	movi	a12, 5
40375f1f:	11cc60        	slli	a12, a12, 10
40375f22:	20b330        	or	a11, a3, a3
40375f25:	05ad      	mov.n	a10, a5
40375f27:	ffec25        	call8	40375de8 <heap_caps_realloc_base>
40375f2a:	0a2d      	mov.n	a2, a10
        if (r==NULL && size>0) {
40375f2c:	fe2a56        	bnez	a10, 40375f12 <heap_caps_realloc_default+0x1e>
40375f2f:	fdf316        	beqz	a3, 40375f12 <heap_caps_realloc_default+0x1e>
            r=heap_caps_realloc_base( ptr, size, MALLOC_CAP_DEFAULT);
40375f32:	140c      	movi.n	a4, 1
40375f34:	114440        	slli	a4, a4, 12
40375f37:	04cd      	mov.n	a12, a4
40375f39:	03bd      	mov.n	a11, a3
40375f3b:	20a550        	or	a10, a5, a5
40375f3e:	ffeaa5        	call8	40375de8 <heap_caps_realloc_base>
40375f41:	0a2d      	mov.n	a2, a10
        if (r==NULL && size>0){
40375f43:	fcba56        	bnez	a10, 40375f12 <heap_caps_realloc_default+0x1e>
            heap_caps_alloc_failed(size, MALLOC_CAP_DEFAULT, __func__);
40375f46:	f9c7c1        	l32r	a12, 40374664 <_iram_text_start+0x260>
40375f49:	04bd      	mov.n	a11, a4
40375f4b:	03ad      	mov.n	a10, a3
40375f4d:	ffcc65        	call8	40375c14 <heap_caps_alloc_failed>
40375f50:	ffef86        	j	40375f12 <heap_caps_realloc_default+0x1e>
	...

40375f54 <heap_caps_calloc>:
    }
    return result;
}

IRAM_ATTR void *heap_caps_calloc( size_t n, size_t size, uint32_t caps)
{
40375f54:	004136        	entry	a1, 32
    if (__builtin_mul_overflow(n, size, &size_bytes)) {
40375f57:	a25230        	muluh	a5, a2, a3
40375f5a:	826230        	mull	a6, a2, a3
40375f5d:	95ec      	bnez.n	a5, 40375f8a <heap_caps_calloc+0x36>
    result = heap_caps_malloc_base(size_bytes, caps);
40375f5f:	04bd      	mov.n	a11, a4
40375f61:	06ad      	mov.n	a10, a6
40375f63:	ffcee5        	call8	40375c50 <heap_caps_malloc_base>
40375f66:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
40375f68:	da8c      	beqz.n	a10, 40375f79 <heap_caps_calloc+0x25>
        bzero(result, size_bytes);
40375f6a:	20c660        	or	a12, a6, a6
40375f6d:	20b550        	or	a11, a5, a5
40375f70:	f94181        	l32r	a8, 40374474 <_iram_text_start+0x70>
40375f73:	0008e0        	callx8	a8
    void* ptr = heap_caps_calloc_base(n, size, caps);

    if (!ptr && size > 0){
40375f76:	00e256        	bnez	a2, 40375f88 <heap_caps_calloc+0x34>
40375f79:	00b316        	beqz	a3, 40375f88 <heap_caps_calloc+0x34>
        heap_caps_alloc_failed(size, caps, __func__);
40375f7c:	f9bbc1        	l32r	a12, 40374668 <_iram_text_start+0x264>
40375f7f:	20b440        	or	a11, a4, a4
40375f82:	20a330        	or	a10, a3, a3
40375f85:	ffc8e5        	call8	40375c14 <heap_caps_alloc_failed>
    }

    return ptr;
}
40375f88:	f01d      	retw.n
        return NULL;
40375f8a:	020c      	movi.n	a2, 0
40375f8c:	fff986        	j	40375f76 <heap_caps_calloc+0x22>
	...

40375f90 <esp_clk_cpu_freq>:
    return g_ticks_per_us_pro;
#endif
}

int IRAM_ATTR esp_clk_cpu_freq(void)
{
40375f90:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
40375f93:	f9b781        	l32r	a8, 40374670 <_iram_text_start+0x26c>
40375f96:	0008e0        	callx8	a8
    return s_get_cpu_freq_mhz() * MHZ;
}
40375f99:	f9b421        	l32r	a2, 4037466c <_iram_text_start+0x268>
40375f9c:	822a20        	mull	a2, a10, a2
40375f9f:	f01d      	retw.n
40375fa1:	000000        	ill

40375fa4 <esp_clk_apb_freq>:

int IRAM_ATTR esp_clk_apb_freq(void)
{
40375fa4:	004136        	entry	a1, 32
    return esp_rom_get_cpu_ticks_per_us();
40375fa7:	f9b281        	l32r	a8, 40374670 <_iram_text_start+0x26c>
40375faa:	0008e0        	callx8	a8
    return MIN(s_get_cpu_freq_mhz() * MHZ, APB_CLK_FREQ);
40375fad:	f9af31        	l32r	a3, 4037466c <_iram_text_start+0x268>
40375fb0:	f9b281        	l32r	a8, 40374678 <_iram_text_start+0x274>
40375fb3:	82aa30        	mull	a10, a10, a3
40375fb6:	f9af21        	l32r	a2, 40374674 <_iram_text_start+0x270>
40375fb9:	0828a7        	blt	a8, a10, 40375fc5 <esp_clk_apb_freq+0x21>
    return esp_rom_get_cpu_ticks_per_us();
40375fbc:	f9ad81        	l32r	a8, 40374670 <_iram_text_start+0x26c>
40375fbf:	0008e0        	callx8	a8
    return MIN(s_get_cpu_freq_mhz() * MHZ, APB_CLK_FREQ);
40375fc2:	822a30        	mull	a2, a10, a3
}
40375fc5:	f01d      	retw.n
	...

40375fc8 <esp_clk_xtal_freq>:

int IRAM_ATTR esp_clk_xtal_freq(void)
{
40375fc8:	004136        	entry	a1, 32
    return rtc_clk_xtal_freq_get() * MHZ;
40375fcb:	0273a5        	call8	40378704 <rtc_clk_xtal_freq_get>
}
40375fce:	f9a721        	l32r	a2, 4037466c <_iram_text_start+0x268>
40375fd1:	822a20        	mull	a2, a10, a2
40375fd4:	f01d      	retw.n
	...

40375fd8 <shared_intr_isr>:
    return best;
}

//Common shared isr handler. Chain-call all ISRs.
static void IRAM_ATTR shared_intr_isr(void *arg)
{
40375fd8:	004136        	entry	a1, 32
40375fdb:	f9a831        	l32r	a3, 4037467c <_iram_text_start+0x278>
40375fde:	ffafb2        	movi	a11, -1
40375fe1:	20a330        	or	a10, a3, a3
    vector_desc_t *vd = (vector_desc_t*)arg;
    shared_vector_desc_t *sh_vec = vd->shared_vec_info;
40375fe4:	1228      	l32i.n	a2, a2, 4
40375fe6:	065ca5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL_ISR(&spinlock);
    while(sh_vec) {
40375fe9:	72cc      	bnez.n	a2, 40375ff4 <shared_intr_isr+0x1c>
                }
            }
        }
        sh_vec = sh_vec->next;
    }
    portEXIT_CRITICAL_ISR(&spinlock);
40375feb:	03ad      	mov.n	a10, a3
40375fed:	066f65        	call8	4037c6e4 <vPortExitCritical>
}
40375ff0:	f01d      	retw.n
40375ff2:	00          	.byte 00
40375ff3:	00          	.byte 00
        if (!sh_vec->disabled) {
40375ff4:	001282        	l16ui	a8, a2, 0
40375ff7:	15e807        	bbsi	a8, 0, 40376010 <shared_intr_isr+0x38>
            if ((sh_vec->statusreg == NULL) || (*sh_vec->statusreg & sh_vec->statusmask)) {
40375ffa:	1288      	l32i.n	a8, a2, 4
40375ffc:	988c      	beqz.n	a8, 40376009 <shared_intr_isr+0x31>
40375ffe:	0020c0        	memw
40376001:	0898      	l32i.n	a9, a8, 0
40376003:	022282        	l32i	a8, a2, 8
40376006:	060987        	bnone	a9, a8, 40376010 <shared_intr_isr+0x38>
                sh_vec->isr(sh_vec->arg);
40376009:	3288      	l32i.n	a8, a2, 12
4037600b:	42a8      	l32i.n	a10, a2, 16
4037600d:	0008e0        	callx8	a8
        sh_vec = sh_vec->next;
40376010:	5228      	l32i.n	a2, a2, 20
40376012:	fff4c6        	j	40375fe9 <shared_intr_isr+0x11>
40376015:	000000        	ill

40376018 <esp_intr_noniram_disable>:
    portEXIT_CRITICAL_SAFE(&spinlock);
    return ESP_OK;
}

void IRAM_ATTR esp_intr_noniram_disable(void)
{
40376018:	004136        	entry	a1, 32
}

static inline BaseType_t __attribute__((always_inline)) xPortEnterCriticalTimeoutSafe(portMUX_TYPE *mux, BaseType_t timeout)
{
    BaseType_t ret;
    if (xPortInIsrContext()) {
4037601b:	065725        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037601e:	f99741        	l32r	a4, 4037467c <_iram_text_start+0x278>
40376021:	ffafb2        	movi	a11, -1
40376024:	20a440        	or	a10, a4, a4
40376027:	0658a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037602a:	03eb30        	rsr.prid	a3
4037602d:	043d30        	extui	a3, a3, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t oldint;
    uint32_t cpu = esp_cpu_get_core_id();
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
    if (non_iram_int_disabled_flag[cpu]) {
40376030:	f99581        	l32r	a8, 40374684 <_iram_text_start+0x280>
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
40376033:	f99321        	l32r	a2, 40374680 <_iram_text_start+0x27c>
    if (non_iram_int_disabled_flag[cpu]) {
40376036:	808830        	add	a8, a8, a3
40376039:	000852        	l8ui	a5, a8, 0
    uint32_t non_iram_ints = non_iram_int_mask[cpu];
4037603c:	a02320        	addx4	a2, a3, a2
4037603f:	0228      	l32i.n	a2, a2, 0
40376041:	1163e0        	slli	a6, a3, 2
    if (non_iram_int_disabled_flag[cpu]) {
40376044:	158c      	beqz.n	a5, 40376049 <esp_intr_noniram_disable+0x31>
        abort();
40376046:	087365        	call8	4037e77c <abort>
    }
    non_iram_int_disabled_flag[cpu] = true;
40376049:	150c      	movi.n	a5, 1
4037604b:	004852        	s8i	a5, a8, 0
// ------------------ Interrupt Control --------------------

FORCE_INLINE_ATTR uint32_t xt_utils_intr_get_enabled_mask(void)
{
    uint32_t intr_mask;
    RSR(INTENABLE, intr_mask);
4037604e:	03e450        	rsr.intenable	a5
 * @param intr_mask Bit mask of the interrupts to disable
 */
FORCE_INLINE_ATTR void esp_cpu_intr_disable(uint32_t intr_mask)
{
#ifdef __XTENSA__
    xt_ints_off(intr_mask);
40376051:	02ad      	mov.n	a10, a2
40376053:	0a4c65        	call8	40380518 <xt_ints_off>
    oldint = esp_cpu_intr_get_enabled_mask();
    esp_cpu_intr_disable(non_iram_ints);
    // Disable the RTC bit which don't want to be put in IRAM.
    rtc_isr_noniram_disable(cpu);
40376056:	03ad      	mov.n	a10, a3
40376058:	001ea5        	call8	40376244 <rtc_isr_noniram_disable>
    // Save disabled ints
    non_iram_int_disabled[cpu] = oldint & non_iram_ints;
4037605b:	f98b31        	l32r	a3, 40374688 <_iram_text_start+0x284>
4037605e:	102250        	and	a2, a2, a5
40376061:	336a      	add.n	a3, a3, a6
40376063:	0329      	s32i.n	a2, a3, 0
    xPortEnterCriticalTimeoutSafe(mux, portMUX_NO_TIMEOUT);
}

static inline void __attribute__((always_inline)) vPortExitCriticalSafe(portMUX_TYPE *mux)
{
    if (xPortInIsrContext()) {
40376065:	065265        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
40376068:	04ad      	mov.n	a10, a4
4037606a:	0667a5        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
4037606d:	f01d      	retw.n
	...

40376070 <esp_intr_noniram_enable>:

void IRAM_ATTR esp_intr_noniram_enable(void)
{
40376070:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40376073:	0651a5        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376076:	f98131        	l32r	a3, 4037467c <_iram_text_start+0x278>
40376079:	ffafb2        	movi	a11, -1
4037607c:	20a330        	or	a10, a3, a3
4037607f:	065325        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    asm volatile (
40376082:	03eb20        	rsr.prid	a2
40376085:	042d20        	extui	a2, a2, 13, 1
    portENTER_CRITICAL_SAFE(&spinlock);
    uint32_t cpu = esp_cpu_get_core_id();
    int non_iram_ints = non_iram_int_disabled[cpu];
40376088:	f98081        	l32r	a8, 40374688 <_iram_text_start+0x284>
4037608b:	a08280        	addx4	a8, a2, a8
4037608e:	0028a2        	l32i	a10, a8, 0
    if (!non_iram_int_disabled_flag[cpu]) {
40376091:	f97c81        	l32r	a8, 40374684 <_iram_text_start+0x280>
40376094:	882a      	add.n	a8, a8, a2
40376096:	000892        	l8ui	a9, a8, 0
40376099:	19cc      	bnez.n	a9, 4037609e <esp_intr_noniram_enable+0x2e>
        abort();
4037609b:	086e25        	call8	4037e77c <abort>
    }
    non_iram_int_disabled_flag[cpu] = false;
4037609e:	090c      	movi.n	a9, 0
403760a0:	004892        	s8i	a9, a8, 0
    xt_ints_on(intr_mask);
403760a3:	0a45e5        	call8	40380500 <xt_ints_on>
    esp_cpu_intr_enable(non_iram_ints);
    rtc_isr_noniram_enable(cpu);
403760a6:	02ad      	mov.n	a10, a2
403760a8:	001ce5        	call8	40376278 <rtc_isr_noniram_enable>
    if (xPortInIsrContext()) {
403760ab:	064e25        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
403760ae:	20a330        	or	a10, a3, a3
403760b1:	066325        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&spinlock);
}
403760b4:	f01d      	retw.n
	...

403760b8 <esp_intr_enable>:
{
403760b8:	004136        	entry	a1, 32
        return ESP_ERR_INVALID_ARG;
403760bb:	02a132        	movi	a3, 0x102
    if (!handle) {
403760be:	06e216        	beqz	a2, 40376130 <esp_intr_enable+0x78>
    if (xPortInIsrContext()) {
403760c1:	064ca5        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403760c4:	f96e31        	l32r	a3, 4037467c <_iram_text_start+0x278>
403760c7:	ffafb2        	movi	a11, -1
403760ca:	20a330        	or	a10, a3, a3
403760cd:	064e25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
403760d0:	1288      	l32i.n	a8, a2, 4
403760d2:	28bc      	beqz.n	a8, 40376108 <esp_intr_enable+0x50>
        handle->shared_vector_desc->disabled = 0;
403760d4:	001892        	l16ui	a9, a8, 0
403760d7:	ea7c      	movi.n	a10, -2
403760d9:	1099a0        	and	a9, a9, a10
403760dc:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
403760df:	08b8      	l32i.n	a11, a8, 0
403760e1:	01bb90        	slli	a11, a11, 23
        source=handle->vector_desc->source;
403760e4:	31b8b0        	srai	a11, a11, 24
    if (source >= 0) {
403760e7:	0228      	l32i.n	a2, a2, 0
403760e9:	028b96        	bltz	a11, 40376115 <esp_intr_enable+0x5d>
        esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, handle->vector_desc->intno);
403760ec:	02a8      	l32i.n	a10, a2, 0
403760ee:	45c1a0        	extui	a12, a10, 17, 5
403760f1:	05a0a0        	extui	a10, a10, 16, 1
403760f4:	f96681        	l32r	a8, 4037468c <_iram_text_start+0x288>
403760f7:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
403760fa:	064925        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
403760fd:	03ad      	mov.n	a10, a3
403760ff:	065e65        	call8	4037c6e4 <vPortExitCritical>
    return ESP_OK;
40376102:	030c      	movi.n	a3, 0
40376104:	000a06        	j	40376130 <esp_intr_enable+0x78>
40376107:	00          	.byte 00
        source=handle->vector_desc->source;
40376108:	0288      	l32i.n	a8, a2, 0
4037610a:	08b8      	l32i.n	a11, a8, 0
4037610c:	11bbe0        	slli	a11, a11, 2
4037610f:	fff446        	j	403760e4 <esp_intr_enable+0x2c>
40376112:	00          	.byte 00
40376113:	00          	.byte 00
40376114:	00          	.byte 00
40376115:	03eb80        	rsr.prid	a8
40376118:	048d80        	extui	a8, a8, 13, 1
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
4037611b:	0022a2        	l32i	a10, a2, 0
4037611e:	0520a0        	extui	a2, a10, 16, 1
40376121:	0f1287        	beq	a2, a8, 40376134 <esp_intr_enable+0x7c>
    if (xPortInIsrContext()) {
40376124:	064665        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
40376127:	20a330        	or	a10, a3, a3
4037612a:	065ba5        	call8	4037c6e4 <vPortExitCritical>
            return ESP_ERR_INVALID_ARG; //Can only enable these ints on this cpu
4037612d:	02a132        	movi	a3, 0x102
}
40376130:	032d      	mov.n	a2, a3
40376132:	f01d      	retw.n
        ESP_INTR_ENABLE(handle->vector_desc->intno);
40376134:	45a1a0        	extui	a10, a10, 17, 5
40376137:	f95681        	l32r	a8, 40374690 <_iram_text_start+0x28c>
4037613a:	0008e0        	callx8	a8
4037613d:	ffee46        	j	403760fa <esp_intr_enable+0x42>

40376140 <esp_intr_disable>:
{
40376140:	004136        	entry	a1, 32
    if (!handle) {
40376143:	0a7216        	beqz	a2, 403761ee <esp_intr_disable+0xae>
    if (xPortInIsrContext()) {
40376146:	064465        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376149:	f94c31        	l32r	a3, 4037467c <_iram_text_start+0x278>
4037614c:	ffafb2        	movi	a11, -1
4037614f:	03ad      	mov.n	a10, a3
40376151:	0645e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if (handle->shared_vector_desc) {
40376154:	1288      	l32i.n	a8, a2, 4
40376156:	05e816        	beqz	a8, 403761b8 <esp_intr_disable+0x78>
        handle->shared_vector_desc->disabled = 1;
40376159:	001892        	l16ui	a9, a8, 0
4037615c:	1a0c      	movi.n	a10, 1
4037615e:	2099a0        	or	a9, a9, a10
40376161:	005892        	s16i	a9, a8, 0
        source=handle->shared_vector_desc->source;
40376164:	08b8      	l32i.n	a11, a8, 0
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
40376166:	0288      	l32i.n	a8, a2, 0
        source=handle->shared_vector_desc->source;
40376168:	74b1b0        	extui	a11, a11, 1, 8
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
4037616b:	1888      	l32i.n	a8, a8, 4
        source=handle->shared_vector_desc->source;
4037616d:	23bb00        	sext	a11, a11, 7
        assert(svd != NULL);
40376170:	d8cc      	bnez.n	a8, 40376181 <esp_intr_disable+0x41>
40376172:	f948d1        	l32r	a13, 40374694 <_iram_text_start+0x290>
40376175:	f948c1        	l32r	a12, 40374698 <_iram_text_start+0x294>
40376178:	f949a1        	l32r	a10, 4037469c <_iram_text_start+0x298>
4037617b:	35a3b2        	movi	a11, 0x335
4037617e:	0868e5        	call8	4037e80c <__assert_func>
            if (svd->source == source && svd->disabled == 0) {
40376181:	0898      	l32i.n	a9, a8, 0
40376183:	019990        	slli	a9, a9, 23
40376186:	319890        	srai	a9, a9, 24
40376189:	0599b7        	bne	a9, a11, 40376192 <esp_intr_disable+0x52>
4037618c:	001892        	l16ui	a9, a8, 0
4037618f:	3e6907        	bbci	a9, 0, 403761d1 <esp_intr_disable+0x91>
            svd = svd->next;
40376192:	5888      	l32i.n	a8, a8, 20
        while(svd) {
40376194:	fe9856        	bnez	a8, 40376181 <esp_intr_disable+0x41>
    if (source >= 0) {
40376197:	039b96        	bltz	a11, 403761d4 <esp_intr_disable+0x94>
            esp_rom_route_intr_matrix(handle->vector_desc->cpu, source, INT_MUX_DISABLED_INTNO);
4037619a:	0228      	l32i.n	a2, a2, 0
4037619c:	6c0c      	movi.n	a12, 6
4037619e:	02a8      	l32i.n	a10, a2, 0
403761a0:	05a0a0        	extui	a10, a10, 16, 1
403761a3:	f93a81        	l32r	a8, 4037468c <_iram_text_start+0x288>
403761a6:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
403761a9:	063e25        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
403761ac:	20a330        	or	a10, a3, a3
403761af:	065365        	call8	4037c6e4 <vPortExitCritical>
    return ESP_OK;
403761b2:	00a022        	movi	a2, 0
}
403761b5:	000090        	retw
        source=handle->vector_desc->source;
403761b8:	0288      	l32i.n	a8, a2, 0
403761ba:	08b8      	l32i.n	a11, a8, 0
403761bc:	11bbe0        	slli	a11, a11, 2
403761bf:	31b8b0        	srai	a11, a11, 24
403761c2:	fff446        	j	40376197 <esp_intr_disable+0x57>
        ESP_INTR_DISABLE(handle->vector_desc->intno);
403761c5:	45a1a0        	extui	a10, a10, 17, 5
403761c8:	f93681        	l32r	a8, 403746a0 <_iram_text_start+0x29c>
403761cb:	0008e0        	callx8	a8
403761ce:	fff5c6        	j	403761a9 <esp_intr_disable+0x69>
    if (source >= 0) {
403761d1:	fd4bd6        	bgez	a11, 403761a9 <esp_intr_disable+0x69>
        if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
403761d4:	002282        	l32i	a8, a2, 0
403761d7:	03eb20        	rsr.prid	a2
403761da:	042d20        	extui	a2, a2, 13, 1
403761dd:	0028a2        	l32i	a10, a8, 0
403761e0:	0580a0        	extui	a8, a10, 16, 1
403761e3:	de1827        	beq	a8, a2, 403761c5 <esp_intr_disable+0x85>
    if (xPortInIsrContext()) {
403761e6:	063a65        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
403761e9:	03ad      	mov.n	a10, a3
403761eb:	064fa5        	call8	4037c6e4 <vPortExitCritical>
        return ESP_ERR_INVALID_ARG;
403761ee:	02a122        	movi	a2, 0x102
403761f1:	fff006        	j	403761b5 <esp_intr_disable+0x75>

403761f4 <rtc_isr>:
        SLIST_HEAD_INITIALIZER(s_rtc_isr_handler_list);
static DRAM_ATTR portMUX_TYPE s_rtc_isr_handler_list_lock = portMUX_INITIALIZER_UNLOCKED;
static intr_handle_t s_rtc_isr_handle;

IRAM_ATTR static void rtc_isr(void* arg)
{
403761f4:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
403761f7:	f92c31        	l32r	a3, 403746a8 <_iram_text_start+0x2a4>
    uint32_t status = REG_READ(RTC_CNTL_INT_ST_REG);
403761fa:	f92a21        	l32r	a2, 403746a4 <_iram_text_start+0x2a0>
403761fd:	ffafb2        	movi	a11, -1
40376200:	20a330        	or	a10, a3, a3
40376203:	0020c0        	memw
40376206:	0248      	l32i.n	a4, a2, 0
40376208:	063a65        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    rtc_isr_handler_t* it;
    portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
4037620b:	f92821        	l32r	a2, 403746ac <_iram_text_start+0x2a8>
4037620e:	f57c      	movi.n	a5, -1
40376210:	0228      	l32i.n	a2, a2, 0
40376212:	e2cc      	bnez.n	a2, 40376224 <rtc_isr+0x30>
            portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
            (*it->handler)(it->handler_arg);
            portENTER_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
        }
    }
    portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
40376214:	03ad      	mov.n	a10, a3
40376216:	064ce5        	call8	4037c6e4 <vPortExitCritical>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, status);
40376219:	f92521        	l32r	a2, 403746b0 <_iram_text_start+0x2ac>
4037621c:	0020c0        	memw
4037621f:	0249      	s32i.n	a4, a2, 0
}
40376221:	f01d      	retw.n
40376223:	00          	.byte 00
        if (it->mask & status) {
40376224:	002282        	l32i	a8, a2, 0
40376227:	130487        	bnone	a4, a8, 4037623e <rtc_isr+0x4a>
            portEXIT_CRITICAL_ISR(&s_rtc_isr_handler_list_lock);
4037622a:	20a330        	or	a10, a3, a3
4037622d:	064b65        	call8	4037c6e4 <vPortExitCritical>
            (*it->handler)(it->handler_arg);
40376230:	22a8      	l32i.n	a10, a2, 8
40376232:	1288      	l32i.n	a8, a2, 4
40376234:	0008e0        	callx8	a8
40376237:	05bd      	mov.n	a11, a5
40376239:	03ad      	mov.n	a10, a3
4037623b:	063765        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    SLIST_FOREACH(it, &s_rtc_isr_handler_list, next) {
4037623e:	4228      	l32i.n	a2, a2, 16
40376240:	fff386        	j	40376212 <rtc_isr+0x1e>
	...

40376244 <rtc_isr_noniram_disable>:
{
    rtc_intr_cache &= ~rtc_intr_mask;
}

IRAM_ATTR void rtc_isr_noniram_disable(uint32_t cpu)
{
40376244:	004136        	entry	a1, 32
    if (rtc_isr_cpu == cpu) {
40376247:	f91b81        	l32r	a8, 403746b4 <_iram_text_start+0x2b0>
4037624a:	0888      	l32i.n	a8, a8, 0
4037624c:	269827        	bne	a8, a2, 40376276 <rtc_isr_noniram_disable+0x32>
        rtc_intr_enabled |= RTCCNTL.int_ena.val;
4037624f:	f8ef81        	l32r	a8, 4037460c <_iram_text_start+0x208>
40376252:	f919a1        	l32r	a10, 403746b8 <_iram_text_start+0x2b4>
40376255:	0020c0        	memw
40376258:	1028b2        	l32i	a11, a8, 64
4037625b:	0a98      	l32i.n	a9, a10, 0
4037625d:	2099b0        	or	a9, a9, a11
40376260:	0a99      	s32i.n	a9, a10, 0
        RTCCNTL.int_ena.val &= rtc_intr_cache;
40376262:	f916a1        	l32r	a10, 403746bc <_iram_text_start+0x2b8>
40376265:	0020c0        	memw
40376268:	102892        	l32i	a9, a8, 64
4037626b:	0aa8      	l32i.n	a10, a10, 0
4037626d:	1099a0        	and	a9, a9, a10
40376270:	0020c0        	memw
40376273:	106892        	s32i	a9, a8, 64
    }
}
40376276:	f01d      	retw.n

40376278 <rtc_isr_noniram_enable>:

IRAM_ATTR void rtc_isr_noniram_enable(uint32_t cpu)
{
40376278:	004136        	entry	a1, 32
    if (rtc_isr_cpu == cpu) {
4037627b:	f90e81        	l32r	a8, 403746b4 <_iram_text_start+0x2b0>
4037627e:	0888      	l32i.n	a8, a8, 0
40376280:	119827        	bne	a8, a2, 40376295 <rtc_isr_noniram_enable+0x1d>
        RTCCNTL.int_ena.val = rtc_intr_enabled;
40376283:	f90d81        	l32r	a8, 403746b8 <_iram_text_start+0x2b4>
40376286:	f8e191        	l32r	a9, 4037460c <_iram_text_start+0x208>
40376289:	08a8      	l32i.n	a10, a8, 0
4037628b:	0020c0        	memw
4037628e:	1069a2        	s32i	a10, a9, 64
        rtc_intr_enabled = 0;
40376291:	090c      	movi.n	a9, 0
40376293:	0899      	s32i.n	a9, a8, 0
    }
}
40376295:	f01d      	retw.n
	...

40376298 <regi2c_ctrl_read_reg_mask>:
    portEXIT_CRITICAL_SAFE(&mux);
    return value;
}

uint8_t IRAM_ATTR regi2c_ctrl_read_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb)
{
40376298:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
4037629b:	062f25        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4037629e:	f90871        	l32r	a7, 403746c0 <_iram_text_start+0x2bc>
403762a1:	ffafb2        	movi	a11, -1
403762a4:	20a770        	or	a10, a7, a7
403762a7:	0630a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
403762aa:	742020        	extui	a2, a2, 0, 8
403762ad:	743030        	extui	a3, a3, 0, 8
403762b0:	744040        	extui	a4, a4, 0, 8
403762b3:	745050        	extui	a5, a5, 0, 8
403762b6:	746060        	extui	a6, a6, 0, 8
    portENTER_CRITICAL_SAFE(&mux);
    uint8_t value = regi2c_read_reg_mask_raw(block, host_id, reg_add, msb, lsb);
403762b9:	06ed      	mov.n	a14, a6
403762bb:	05dd      	mov.n	a13, a5
403762bd:	04cd      	mov.n	a12, a4
403762bf:	03bd      	mov.n	a11, a3
403762c1:	20a220        	or	a10, a2, a2
403762c4:	f90081        	l32r	a8, 403746c4 <_iram_text_start+0x2c0>
403762c7:	0008e0        	callx8	a8
403762ca:	0a2d      	mov.n	a2, a10
    if (xPortInIsrContext()) {
403762cc:	062be5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
403762cf:	07ad      	mov.n	a10, a7
403762d1:	064125        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
    return value;
}
403762d4:	f01d      	retw.n
	...

403762d8 <regi2c_ctrl_write_reg>:

void IRAM_ATTR regi2c_ctrl_write_reg(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t data)
{
403762d8:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403762db:	062b25        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403762de:	f8f861        	l32r	a6, 403746c0 <_iram_text_start+0x2bc>
403762e1:	fb7c      	movi.n	a11, -1
403762e3:	06ad      	mov.n	a10, a6
403762e5:	062ca5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
403762e8:	742020        	extui	a2, a2, 0, 8
403762eb:	743030        	extui	a3, a3, 0, 8
403762ee:	744040        	extui	a4, a4, 0, 8
403762f1:	745050        	extui	a5, a5, 0, 8
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_raw(block, host_id, reg_add, data);
403762f4:	05dd      	mov.n	a13, a5
403762f6:	04cd      	mov.n	a12, a4
403762f8:	03bd      	mov.n	a11, a3
403762fa:	02ad      	mov.n	a10, a2
403762fc:	f8f381        	l32r	a8, 403746c8 <_iram_text_start+0x2c4>
403762ff:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376302:	0628a5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
40376305:	06ad      	mov.n	a10, a6
40376307:	063de5        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
}
4037630a:	f01d      	retw.n

4037630c <regi2c_ctrl_write_reg_mask>:

void IRAM_ATTR regi2c_ctrl_write_reg_mask(uint8_t block, uint8_t host_id, uint8_t reg_add, uint8_t msb, uint8_t lsb, uint8_t data)
{
4037630c:	006136        	entry	a1, 48
    if (xPortInIsrContext()) {
4037630f:	0627e5        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
40376312:	f8eb81        	l32r	a8, 403746c0 <_iram_text_start+0x2bc>
40376315:	fb7c      	movi.n	a11, -1
40376317:	08ad      	mov.n	a10, a8
40376319:	006182        	s32i	a8, a1, 0
4037631c:	742020        	extui	a2, a2, 0, 8
4037631f:	062925        	call8	4037c5b0 <xPortEnterCriticalTimeout>
40376322:	743030        	extui	a3, a3, 0, 8
40376325:	744040        	extui	a4, a4, 0, 8
40376328:	745050        	extui	a5, a5, 0, 8
4037632b:	746060        	extui	a6, a6, 0, 8
4037632e:	747070        	extui	a7, a7, 0, 8
    portENTER_CRITICAL_SAFE(&mux);
    regi2c_write_reg_mask_raw(block, host_id, reg_add, msb, lsb, data);
40376331:	07fd      	mov.n	a15, a7
40376333:	06ed      	mov.n	a14, a6
40376335:	05dd      	mov.n	a13, a5
40376337:	04cd      	mov.n	a12, a4
40376339:	03bd      	mov.n	a11, a3
4037633b:	02ad      	mov.n	a10, a2
4037633d:	f8e381        	l32r	a8, 403746cc <_iram_text_start+0x2c8>
40376340:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
40376343:	0624a5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
40376346:	0188      	l32i.n	a8, a1, 0
40376348:	08ad      	mov.n	a10, a8
4037634a:	0639a5        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&mux);
}
4037634d:	f01d      	retw.n
	...

40376350 <esp_mprot_monitor_clear_intr>:

    return ESP_OK;
}

esp_err_t IRAM_ATTR esp_mprot_monitor_clear_intr(esp_mprot_mem_t mem_type, const int core)
{
40376350:	004136        	entry	a1, 32
    esp_err_t err;
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
40376353:	20a330        	or	a10, a3, a3
40376356:	f8e581        	l32r	a8, 403746ec <_iram_text_start+0x2e8>
40376359:	0008e0        	callx8	a8
4037635c:	9aec      	bnez.n	a10, 40376389 <esp_mprot_monitor_clear_intr+0x39>

    switch (mem_type) {
4037635e:	6e2226        	beqi	a2, 2, 403763d0 <esp_mprot_monitor_clear_intr+0x80>
40376361:	024266        	bnei	a2, 4, 40376367 <esp_mprot_monitor_clear_intr+0x17>
40376364:	002b86        	j	40376416 <esp_mprot_monitor_clear_intr+0xc6>
40376367:	021226        	beqi	a2, 1, 4037636d <esp_mprot_monitor_clear_intr+0x1d>
4037636a:	003d86        	j	40376464 <esp_mprot_monitor_clear_intr+0x114>
    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_iram0_set_monitor_intrclr(const int core)
{
    switch (core) {
4037636d:	c39c      	beqz.n	a3, 4037638d <esp_mprot_monitor_clear_intr+0x3d>
4037636f:	2d1326        	beqi	a3, 1, 403763a0 <esp_mprot_monitor_clear_intr+0x50>
40376372:	7a0c      	movi.n	a10, 7
    case MEMPROT_TYPE_IRAM0_SRAM:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_set_monitor_intrclr(core)))
40376374:	f8df81        	l32r	a8, 403746f0 <_iram_text_start+0x2ec>
40376377:	0008e0        	callx8	a8
4037637a:	bacc      	bnez.n	a10, 40376389 <esp_mprot_monitor_clear_intr+0x39>
    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_iram0_reset_monitor_intrclr(const int core)
{
    switch (core) {
4037637c:	43bc      	beqz.n	a3, 403763b4 <esp_mprot_monitor_clear_intr+0x64>
4037637e:	471326        	beqi	a3, 1, 403763c9 <esp_mprot_monitor_clear_intr+0x79>
    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_rtcfast_reset_monitor_intrclr(const int core)
{
    switch (core) {
40376381:	7a0c      	movi.n	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_intrclr(core)))
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_reset_monitor_intrclr(core)))
        break;
    case MEMPROT_TYPE_IRAM0_RTCFAST:
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_intrclr(core)))
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_reset_monitor_intrclr(core)))
40376383:	f8db81        	l32r	a8, 403746f0 <_iram_text_start+0x2ec>
40376386:	0008e0        	callx8	a8
    default:
        return ESP_ERR_MEMPROT_MEMORY_TYPE_INVALID;
    }

    return ESP_OK;
}
40376389:	0a2d      	mov.n	a2, a10
4037638b:	f01d      	retw.n
            REG_SET_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
4037638d:	f8d191        	l32r	a9, 403746d4 <_iram_text_start+0x2d0>
40376390:	0020c0        	memw
40376393:	0988      	l32i.n	a8, a9, 0
40376395:	208820        	or	a8, a8, a2
40376398:	0020c0        	memw
4037639b:	0989      	s32i.n	a8, a9, 0
            break;
4037639d:	fff4c6        	j	40376374 <esp_mprot_monitor_clear_intr+0x24>
            REG_SET_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
403763a0:	f8ce81        	l32r	a8, 403746d8 <_iram_text_start+0x2d4>
403763a3:	0020c0        	memw
403763a6:	0828      	l32i.n	a2, a8, 0
403763a8:	202230        	or	a2, a2, a3
403763ab:	0020c0        	memw
403763ae:	0829      	s32i.n	a2, a8, 0
            break;
403763b0:	fff006        	j	40376374 <esp_mprot_monitor_clear_intr+0x24>
403763b3:	00          	.byte 00
            REG_CLR_BIT(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR);
403763b4:	f8c831        	l32r	a3, 403746d4 <_iram_text_start+0x2d0>
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
403763b7:	0020c0        	memw
403763ba:	0328      	l32i.n	a2, a3, 0
403763bc:	e87c      	movi.n	a8, -2
403763be:	102280        	and	a2, a2, a8
403763c1:	0020c0        	memw
403763c4:	0329      	s32i.n	a2, a3, 0
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
403763c6:	ffee46        	j	40376383 <esp_mprot_monitor_clear_intr+0x33>
            REG_CLR_BIT(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR);
403763c9:	f8c331        	l32r	a3, 403746d8 <_iram_text_start+0x2d4>
403763cc:	fff9c6        	j	403763b7 <esp_mprot_monitor_clear_intr+0x67>
403763cf:	00          	.byte 00
    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_dram0_set_monitor_intrclr(const int core)
{
    switch (core) {
403763d0:	839c      	beqz.n	a3, 403763ec <esp_mprot_monitor_clear_intr+0x9c>
403763d2:	2b1326        	beqi	a3, 1, 40376401 <esp_mprot_monitor_clear_intr+0xb1>
403763d5:	7a0c      	movi.n	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_set_monitor_intrclr(core)))
403763d7:	f8c681        	l32r	a8, 403746f0 <_iram_text_start+0x2ec>
403763da:	0008e0        	callx8	a8
403763dd:	fa8a56        	bnez	a10, 40376389 <esp_mprot_monitor_clear_intr+0x39>
    return MEMP_HAL_OK;
}

static inline memprot_hal_err_t memprot_ll_dram0_reset_monitor_intrclr(const int core)
{
    switch (core) {
403763e0:	c3ac      	beqz.n	a3, 40376410 <esp_mprot_monitor_clear_intr+0xc0>
403763e2:	9b1366        	bnei	a3, 1, 40376381 <esp_mprot_monitor_clear_intr+0x31>
#ifdef PMS_DEBUG_ASSERTIONS
            HAL_ASSERT((REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR) == 0) && "Value not stored to required register");
#endif
            break;
        case APP_CPU_NUM:
            REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
403763e5:	f8be31        	l32r	a3, 403746e0 <_iram_text_start+0x2dc>
403763e8:	fff2c6        	j	403763b7 <esp_mprot_monitor_clear_intr+0x67>
403763eb:	00          	.byte 00
            REG_SET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
403763ec:	f8bc81        	l32r	a8, 403746dc <_iram_text_start+0x2d8>
403763ef:	190c      	movi.n	a9, 1
403763f1:	0020c0        	memw
403763f4:	0828      	l32i.n	a2, a8, 0
403763f6:	202290        	or	a2, a2, a9
            REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
403763f9:	0020c0        	memw
403763fc:	0829      	s32i.n	a2, a8, 0
            break;
403763fe:	fff546        	j	403763d7 <esp_mprot_monitor_clear_intr+0x87>
            REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR);
40376401:	f8b781        	l32r	a8, 403746e0 <_iram_text_start+0x2dc>
40376404:	0020c0        	memw
40376407:	0828      	l32i.n	a2, a8, 0
40376409:	202230        	or	a2, a2, a3
4037640c:	fffa46        	j	403763f9 <esp_mprot_monitor_clear_intr+0xa9>
4037640f:	00          	.byte 00
            REG_CLR_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR);
40376410:	f8b331        	l32r	a3, 403746dc <_iram_text_start+0x2d8>
40376413:	ffe806        	j	403763b7 <esp_mprot_monitor_clear_intr+0x67>
    switch (core) {
40376416:	b39c      	beqz.n	a3, 40376435 <esp_mprot_monitor_clear_intr+0xe5>
40376418:	301326        	beqi	a3, 1, 4037644c <esp_mprot_monitor_clear_intr+0xfc>
4037641b:	07a0a2        	movi	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_intrclr(core)))
4037641e:	f8b481        	l32r	a8, 403746f0 <_iram_text_start+0x2ec>
40376421:	0008e0        	callx8	a8
40376424:	f61a56        	bnez	a10, 40376389 <esp_mprot_monitor_clear_intr+0x39>
    switch (core) {
40376427:	13bc      	beqz.n	a3, 4037645c <esp_mprot_monitor_clear_intr+0x10c>
40376429:	021326        	beqi	a3, 1, 4037642f <esp_mprot_monitor_clear_intr+0xdf>
4037642c:	ffd446        	j	40376381 <esp_mprot_monitor_clear_intr+0x31>
            REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
4037642f:	f8ae31        	l32r	a3, 403746e8 <_iram_text_start+0x2e4>
40376432:	ffe046        	j	403763b7 <esp_mprot_monitor_clear_intr+0x67>
            REG_SET_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
40376435:	f8ab81        	l32r	a8, 403746e4 <_iram_text_start+0x2e0>
40376438:	190c      	movi.n	a9, 1
4037643a:	0020c0        	memw
4037643d:	0828      	l32i.n	a2, a8, 0
4037643f:	202290        	or	a2, a2, a9
            REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
40376442:	0020c0        	memw
40376445:	0829      	s32i.n	a2, a8, 0
            break;
40376447:	fff4c6        	j	4037641e <esp_mprot_monitor_clear_intr+0xce>
4037644a:	00          	.byte 00
4037644b:	00          	.byte 00
            REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR);
4037644c:	f8a781        	l32r	a8, 403746e8 <_iram_text_start+0x2e4>
4037644f:	0020c0        	memw
40376452:	0828      	l32i.n	a2, a8, 0
40376454:	202230        	or	a2, a2, a3
40376457:	fff9c6        	j	40376442 <esp_mprot_monitor_clear_intr+0xf2>
4037645a:	00          	.byte 00
4037645b:	00          	.byte 00
            REG_CLR_BIT(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR);
4037645c:	f8a231        	l32r	a3, 403746e4 <_iram_text_start+0x2e0>
4037645f:	ffd506        	j	403763b7 <esp_mprot_monitor_clear_intr+0x67>
40376462:	00          	.byte 00
40376463:	00          	.byte 00
    switch (mem_type) {
40376464:	f89ba1        	l32r	a10, 403746d0 <_iram_text_start+0x2cc>
40376467:	ffc786        	j	40376389 <esp_mprot_monitor_clear_intr+0x39>
	...

4037646c <esp_mprot_is_conf_locked_any>:

esp_err_t IRAM_ATTR esp_mprot_is_conf_locked_any(bool *locked)
{
4037646c:	006136        	entry	a1, 48
    if (locked == NULL) {
        return ESP_ERR_INVALID_ARG;
4037646f:	02a1a2        	movi	a10, 0x102
    if (locked == NULL) {
40376472:	0f6216        	beqz	a2, 4037656c <esp_mprot_is_conf_locked_any+0x100>
    }

    bool lock_on = false;
40376475:	030c      	movi.n	a3, 0
40376477:	004132        	s8i	a3, a1, 0
    esp_err_t err;

    //IRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM) {
4037647a:	f89e31        	l32r	a3, 403746f4 <_iram_text_start+0x2f0>
4037647d:	2348      	l32i.n	a4, a3, 8
4037647f:	6d6407        	bbci	a4, 0, 403764f0 <esp_mprot_is_conf_locked_any+0x84>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
40376482:	f89d41        	l32r	a4, 403746f8 <_iram_text_start+0x2f4>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
40376485:	0c0c      	movi.n	a12, 0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
40376487:	0020c0        	memw
4037648a:	0498      	l32i.n	a9, a4, 0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
4037648c:	f89c41        	l32r	a4, 403746fc <_iram_text_start+0x2f8>
4037648f:	0c8d      	mov.n	a8, a12
40376491:	0020c0        	memw
40376494:	04a8      	l32i.n	a10, a4, 0
40376496:	140c      	movi.n	a4, 1
40376498:	aa0b      	addi.n	a10, a10, -1
4037649a:	8384a0        	moveqz	a8, a4, a10
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
4037649d:	990b      	addi.n	a9, a9, -1
4037649f:	0cad      	mov.n	a10, a12

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
        *locked |= lock_on;
403764a1:	000252        	l8ui	a5, a2, 0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
403764a4:	748080        	extui	a8, a8, 0, 8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
403764a7:	83a490        	moveqz	a10, a4, a9
        *locked = memprot_ll_iram0_get_pms_lock();
403764aa:	004182        	s8i	a8, a1, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
        *locked |= lock_on;
403764ad:	2088a0        	or	a8, a8, a10
403764b0:	205580        	or	a5, a5, a8
403764b3:	004252        	s8i	a5, a2, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, PRO_CPU_NUM))
403764b6:	01bd      	mov.n	a11, a1
403764b8:	04ad      	mov.n	a10, a4
403764ba:	f89281        	l32r	a8, 40374704 <_iram_text_start+0x300>
403764bd:	0008e0        	callx8	a8
403764c0:	0a8a56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
        *locked |= lock_on;
403764c3:	000252        	l8ui	a5, a2, 0
403764c6:	000182        	l8ui	a8, a1, 0
403764c9:	205580        	or	a5, a5, a8
403764cc:	004252        	s8i	a5, a2, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
403764cf:	3358      	l32i.n	a5, a3, 12
403764d1:	1b25b6        	bltui	a5, 2, 403764f0 <esp_mprot_is_conf_locked_any+0x84>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &lock_on, APP_CPU_NUM))
403764d4:	04cd      	mov.n	a12, a4
403764d6:	01bd      	mov.n	a11, a1
403764d8:	20a440        	or	a10, a4, a4
403764db:	f88a81        	l32r	a8, 40374704 <_iram_text_start+0x300>
403764de:	0008e0        	callx8	a8
403764e1:	087a56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
            *locked |= lock_on;
403764e4:	000242        	l8ui	a4, a2, 0
403764e7:	000152        	l8ui	a5, a1, 0
403764ea:	204450        	or	a4, a4, a5
403764ed:	004242        	s8i	a4, a2, 0
        }
    }

    //DRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM) {
403764f0:	2358      	l32i.n	a5, a3, 8
403764f2:	240c      	movi.n	a4, 2
403764f4:	6a0457        	bnone	a4, a5, 40376562 <esp_mprot_is_conf_locked_any+0xf6>
403764f7:	f88051        	l32r	a5, 403746f8 <_iram_text_start+0x2f4>
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
403764fa:	0c0c      	movi.n	a12, 0
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
403764fc:	0020c0        	memw
403764ff:	05a8      	l32i.n	a10, a5, 0
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
40376501:	f87f51        	l32r	a5, 40374700 <_iram_text_start+0x2fc>
40376504:	0c8d      	mov.n	a8, a12
40376506:	0020c0        	memw
40376509:	05b8      	l32i.n	a11, a5, 0
4037650b:	150c      	movi.n	a5, 1
4037650d:	bb0b      	addi.n	a11, a11, -1
4037650f:	8385b0        	moveqz	a8, a5, a11
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
40376512:	aa0b      	addi.n	a10, a10, -1
40376514:	0cbd      	mov.n	a11, a12
40376516:	83b5a0        	moveqz	a11, a5, a10

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_split_addr_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
        *locked |= lock_on;
40376519:	000292        	l8ui	a9, a2, 0
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
4037651c:	748080        	extui	a8, a8, 0, 8
        *locked = memprot_ll_dram0_get_pms_lock();
4037651f:	004182        	s8i	a8, a1, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, DEFAULT_CPU_NUM))
        *locked |= lock_on;
40376522:	2088b0        	or	a8, a8, a11
40376525:	208980        	or	a8, a9, a8
40376528:	004282        	s8i	a8, a2, 0

        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, PRO_CPU_NUM));
4037652b:	01bd      	mov.n	a11, a1
4037652d:	04ad      	mov.n	a10, a4
4037652f:	f87581        	l32r	a8, 40374704 <_iram_text_start+0x300>
40376532:	0008e0        	callx8	a8
40376535:	3afc      	bnez.n	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
        *locked |= lock_on;
40376537:	000282        	l8ui	a8, a2, 0
4037653a:	000192        	l8ui	a9, a1, 0
4037653d:	208890        	or	a8, a8, a9
40376540:	004282        	s8i	a8, a2, 0

        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
40376543:	3388      	l32i.n	a8, a3, 12
40376545:	193847        	bltu	a8, a4, 40376562 <esp_mprot_is_conf_locked_any+0xf6>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &lock_on, APP_CPU_NUM));
40376548:	05cd      	mov.n	a12, a5
4037654a:	01bd      	mov.n	a11, a1
4037654c:	04ad      	mov.n	a10, a4
4037654e:	f86d81        	l32r	a8, 40374704 <_iram_text_start+0x300>
40376551:	0008e0        	callx8	a8
40376554:	4adc      	bnez.n	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
            *locked |= lock_on;
40376556:	000242        	l8ui	a4, a2, 0
40376559:	000152        	l8ui	a5, a1, 0
4037655c:	204450        	or	a4, a4, a5
4037655f:	004242        	s8i	a4, a2, 0
        }
    }

    //RTCFAST
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST) {
40376562:	2358      	l32i.n	a5, a3, 8
40376564:	04a042        	movi	a4, 4
40376567:	078457        	bany	a4, a5, 40376572 <esp_mprot_is_conf_locked_any+0x106>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
            *locked |= lock_on;
        }
    }

    return ESP_OK;
4037656a:	0a0c      	movi.n	a10, 0
}
4037656c:	0a2d      	mov.n	a2, a10
4037656e:	f01d      	retw.n
40376570:	00          	.byte 00
40376571:	00          	.byte 00
    switch (mem_type) {
40376572:	0b0c      	movi.n	a11, 0
40376574:	20a110        	or	a10, a1, a1
40376577:	f86481        	l32r	a8, 40374708 <_iram_text_start+0x304>
4037657a:	0008e0        	callx8	a8
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM))
4037657d:	feba56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
        *locked |= lock_on;
40376580:	000282        	l8ui	a8, a2, 0
40376583:	000152        	l8ui	a5, a1, 0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM));
40376586:	0acd      	mov.n	a12, a10
        *locked |= lock_on;
40376588:	208850        	or	a8, a8, a5
4037658b:	004282        	s8i	a8, a2, 0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, PRO_CPU_NUM));
4037658e:	01bd      	mov.n	a11, a1
40376590:	04ad      	mov.n	a10, a4
40376592:	f85c81        	l32r	a8, 40374704 <_iram_text_start+0x300>
40376595:	0008e0        	callx8	a8
40376598:	fd0a56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
        *locked |= lock_on;
4037659b:	000282        	l8ui	a8, a2, 0
4037659e:	000152        	l8ui	a5, a1, 0
        if (s_memp_cfg.target_cpu_count > 1) {
403765a1:	032332        	l32i	a3, a3, 12
        *locked |= lock_on;
403765a4:	208850        	or	a8, a8, a5
403765a7:	004282        	s8i	a8, a2, 0
        if (s_memp_cfg.target_cpu_count > 1) {
403765aa:	bc23b6        	bltui	a3, 2, 4037656a <esp_mprot_is_conf_locked_any+0xfe>
    switch (mem_type) {
403765ad:	01a0b2        	movi	a11, 1
403765b0:	20a110        	or	a10, a1, a1
403765b3:	f85581        	l32r	a8, 40374708 <_iram_text_start+0x304>
403765b6:	0008e0        	callx8	a8
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM))
403765b9:	fafa56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
            *locked |= lock_on;
403765bc:	000232        	l8ui	a3, a2, 0
403765bf:	000152        	l8ui	a5, a1, 0
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
403765c2:	1c0c      	movi.n	a12, 1
            *locked |= lock_on;
403765c4:	203350        	or	a3, a3, a5
403765c7:	004232        	s8i	a3, a2, 0
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, &lock_on, APP_CPU_NUM));
403765ca:	01bd      	mov.n	a11, a1
403765cc:	04ad      	mov.n	a10, a4
403765ce:	f84d81        	l32r	a8, 40374704 <_iram_text_start+0x300>
403765d1:	0008e0        	callx8	a8
403765d4:	f94a56        	bnez	a10, 4037656c <esp_mprot_is_conf_locked_any+0x100>
            *locked |= lock_on;
403765d7:	000232        	l8ui	a3, a2, 0
403765da:	000142        	l8ui	a4, a1, 0
403765dd:	203340        	or	a3, a3, a4
403765e0:	004232        	s8i	a3, a2, 0
403765e3:	ffe146        	j	4037656c <esp_mprot_is_conf_locked_any+0x100>
	...

403765e8 <esp_mprot_is_intr_ena_any>:

esp_err_t IRAM_ATTR esp_mprot_is_intr_ena_any(bool *enabled)
{
403765e8:	006136        	entry	a1, 48
    if (enabled == NULL) {
        return ESP_ERR_INVALID_ARG;
403765eb:	02a1a2        	movi	a10, 0x102
    if (enabled == NULL) {
403765ee:	098216        	beqz	a2, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
    }

    bool ena_on = false;
403765f1:	030c      	movi.n	a3, 0
403765f3:	004132        	s8i	a3, a1, 0
    esp_err_t err;

    //IRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM) {
403765f6:	f83f31        	l32r	a3, 403746f4 <_iram_text_start+0x2f0>
403765f9:	2348      	l32i.n	a4, a3, 8
403765fb:	3d6407        	bbci	a4, 0, 4037663c <esp_mprot_is_intr_ena_any+0x54>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &ena_on, PRO_CPU_NUM))
403765fe:	0c0c      	movi.n	a12, 0
40376600:	20b110        	or	a11, a1, a1
40376603:	01a0a2        	movi	a10, 1
40376606:	f84181        	l32r	a8, 4037470c <_iram_text_start+0x308>
40376609:	0008e0        	callx8	a8
4037660c:	07aa56        	bnez	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
        *enabled |= ena_on;
4037660f:	000242        	l8ui	a4, a2, 0
40376612:	000182        	l8ui	a8, a1, 0
40376615:	204480        	or	a4, a4, a8
40376618:	004242        	s8i	a4, a2, 0
        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
4037661b:	3348      	l32i.n	a4, a3, 12
4037661d:	1b24b6        	bltui	a4, 2, 4037663c <esp_mprot_is_intr_ena_any+0x54>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &ena_on, APP_CPU_NUM))
40376620:	1c0c      	movi.n	a12, 1
40376622:	01bd      	mov.n	a11, a1
40376624:	20acc0        	or	a10, a12, a12
40376627:	f83981        	l32r	a8, 4037470c <_iram_text_start+0x308>
4037662a:	0008e0        	callx8	a8
4037662d:	059a56        	bnez	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
            *enabled |= ena_on;
40376630:	000242        	l8ui	a4, a2, 0
40376633:	000182        	l8ui	a8, a1, 0
40376636:	204480        	or	a4, a4, a8
40376639:	004242        	s8i	a4, a2, 0
        }
    }

    //DRAM0
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM) {
4037663c:	2388      	l32i.n	a8, a3, 8
4037663e:	240c      	movi.n	a4, 2
40376640:	3c0487        	bnone	a4, a8, 40376680 <esp_mprot_is_intr_ena_any+0x98>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &ena_on, PRO_CPU_NUM))
40376643:	00a0c2        	movi	a12, 0
40376646:	20b110        	or	a11, a1, a1
40376649:	20a440        	or	a10, a4, a4
4037664c:	f83081        	l32r	a8, 4037470c <_iram_text_start+0x308>
4037664f:	0008e0        	callx8	a8
40376652:	4afc      	bnez.n	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
        *enabled |= ena_on;
40376654:	000282        	l8ui	a8, a2, 0
40376657:	000192        	l8ui	a9, a1, 0
4037665a:	208890        	or	a8, a8, a9
4037665d:	004282        	s8i	a8, a2, 0
        //2-core
        if (s_memp_cfg.target_cpu_count > 1) {
40376660:	3388      	l32i.n	a8, a3, 12
40376662:	1a3847        	bltu	a8, a4, 40376680 <esp_mprot_is_intr_ena_any+0x98>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &ena_on, APP_CPU_NUM))
40376665:	1c0c      	movi.n	a12, 1
40376667:	01bd      	mov.n	a11, a1
40376669:	20a440        	or	a10, a4, a4
4037666c:	f82881        	l32r	a8, 4037470c <_iram_text_start+0x308>
4037666f:	0008e0        	callx8	a8
40376672:	4adc      	bnez.n	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
            *enabled |= ena_on;
40376674:	000242        	l8ui	a4, a2, 0
40376677:	000182        	l8ui	a8, a1, 0
4037667a:	204480        	or	a4, a4, a8
4037667d:	004242        	s8i	a4, a2, 0
        }
    }

    //RTCFAST
    if (s_memp_cfg.mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST) {
40376680:	2388      	l32i.n	a8, a3, 8
40376682:	04a042        	movi	a4, 4
40376685:	058487        	bany	a4, a8, 4037668e <esp_mprot_is_intr_ena_any+0xa6>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, &ena_on, APP_CPU_NUM))
            *enabled |= ena_on;
        }
    }

    return ESP_OK;
40376688:	0a0c      	movi.n	a10, 0
}
4037668a:	0a2d      	mov.n	a2, a10
4037668c:	f01d      	retw.n
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, &ena_on, PRO_CPU_NUM))
4037668e:	0c0c      	movi.n	a12, 0
40376690:	20b110        	or	a11, a1, a1
40376693:	20a440        	or	a10, a4, a4
40376696:	f81d81        	l32r	a8, 4037470c <_iram_text_start+0x308>
40376699:	0008e0        	callx8	a8
4037669c:	feaa56        	bnez	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
        *enabled |= ena_on;
4037669f:	000282        	l8ui	a8, a2, 0
403766a2:	000192        	l8ui	a9, a1, 0
        if (s_memp_cfg.target_cpu_count > 1) {
403766a5:	3338      	l32i.n	a3, a3, 12
        *enabled |= ena_on;
403766a7:	208890        	or	a8, a8, a9
403766aa:	004282        	s8i	a8, a2, 0
        if (s_memp_cfg.target_cpu_count > 1) {
403766ad:	d723b6        	bltui	a3, 2, 40376688 <esp_mprot_is_intr_ena_any+0xa0>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, &ena_on, APP_CPU_NUM))
403766b0:	1c0c      	movi.n	a12, 1
403766b2:	01bd      	mov.n	a11, a1
403766b4:	04ad      	mov.n	a10, a4
403766b6:	f81581        	l32r	a8, 4037470c <_iram_text_start+0x308>
403766b9:	0008e0        	callx8	a8
403766bc:	fcaa56        	bnez	a10, 4037668a <esp_mprot_is_intr_ena_any+0xa2>
            *enabled |= ena_on;
403766bf:	000232        	l8ui	a3, a2, 0
403766c2:	000142        	l8ui	a4, a1, 0
403766c5:	203340        	or	a3, a3, a4
403766c8:	004232        	s8i	a3, a2, 0
403766cb:	ffeec6        	j	4037668a <esp_mprot_is_intr_ena_any+0xa2>
	...

403766d0 <xPortInterruptedFromISRContext>:
{
    configASSERT(xPortInIsrContext());
}

BaseType_t IRAM_ATTR xPortInterruptedFromISRContext(void)
{
403766d0:	004136        	entry	a1, 32
403766d3:	03eb20        	rsr.prid	a2
403766d6:	042d20        	extui	a2, a2, 13, 1
    return (port_interruptNesting[xPortGetCoreID()] != 0);
403766d9:	f80d81        	l32r	a8, 40374710 <_iram_text_start+0x30c>
403766dc:	a02280        	addx4	a2, a2, a8
403766df:	0298      	l32i.n	a9, a2, 0
403766e1:	080c      	movi.n	a8, 0
403766e3:	120c      	movi.n	a2, 1
403766e5:	832890        	moveqz	a2, a8, a9
}
403766e8:	f01d      	retw.n
	...

403766ec <_xt_kernel_exc>:
    break   1, 0                            /* unhandled kernel exception */
403766ec:	004100        	break	1, 0
    movi    a0,PANIC_RSN_KERNELEXCEPTION
403766ef:	300c      	movi.n	a0, 3
    wsr     a0,EXCCAUSE
403766f1:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* does not return */
403766f4:	01a145        	call0	4037810c <_xt_panic>
    rfe                                     /* make a0 point here not there */
403766f7:	003000        	rfe
	...

403766fc <_xt_to_alloca_exc>:
    call0   _xt_alloca_exc                  /* in window vectors section */
403766fc:	201110        	or	a1, a1, a1
403766ff:	fd9505        	call0	40374050 <_xt_alloca_exc>
	...

40376704 <_xt_to_syscall_exc>:
    call0   _xt_syscall_exc
40376704:	000b45        	call0	403767bc <_xt_syscall_exc>
	...

40376708 <_xt_to_coproc_exc>:
    call0   _xt_coproc_exc
40376708:	000f85        	call0	40376804 <_xt_coproc_exc>
	...

4037670c <_xt_user_exc>:
    rsr     a0, EXCCAUSE
4037670c:	03e800        	rsr.exccause	a0
    beqi    a0, EXCCAUSE_LEVEL1INTERRUPT, _xt_lowint1
4037670f:	024066        	bnei	a0, 4, 40376715 <_xt_user_exc+0x9>
40376712:	00de86        	j	40376a90 <_xt_lowint1>
    bgeui   a0, EXCCAUSE_CP0_DISABLED, _xt_to_coproc_exc
40376715:	efc0f6        	bgeui	a0, 32, 40376708 <_xt_to_coproc_exc>
    beqi    a0, EXCCAUSE_ALLOCA,  _xt_to_alloca_exc
40376718:	e05026        	beqi	a0, 5, 403766fc <_xt_to_alloca_exc>
    beqi    a0, EXCCAUSE_SYSCALL, _xt_to_syscall_exc
4037671b:	e51026        	beqi	a0, 1, 40376704 <_xt_to_syscall_exc>
    mov     a0, sp
4037671e:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ
40376721:	ffd112        	addmi	a1, a1, 0xffffff00
40376724:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40376727:	046102        	s32i	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
4037672a:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
4037672d:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376730:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376732:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376735:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376737:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
4037673a:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
4037673c:	49c100        	s32e	a0, a1, -16
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
4037673f:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
40376742:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40376745:	039485        	call0	4037a090 <_xt_context_save>
    rsr     a0, EXCCAUSE
40376748:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
4037674b:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
4037674e:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
40376751:	156102        	s32i	a0, a1, 84
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
40376754:	f7f001        	l32r	a0, 40374714 <_iram_text_start+0x310>
    wsr     a0, PS
40376757:	13e600        	wsr.ps	a0
    l32i    a3, sp, XT_STK_A0               /* Copy pre-exception a0 (return address) */
4037675a:	3138      	l32i.n	a3, a1, 12
    s32e    a3, sp, -16
4037675c:	49c130        	s32e	a3, a1, -16
    l32i    a3, sp, XT_STK_A1               /* Copy pre-exception a1 (stack pointer) */
4037675f:	4138      	l32i.n	a3, a1, 16
    s32e    a3, sp, -12
40376761:	49d130        	s32e	a3, a1, -12
    rsr     a0, EPC_1                       /* return address for debug backtrace */
40376764:	03b100        	rsr.epc1	a0
    movi    a5, 0xC0000000                  /* constant with top 2 bits set (call size) */
40376767:	f7ec51        	l32r	a5, 40374718 <_iram_text_start+0x314>
    rsync                                   /* wait for WSR.PS to complete */
4037676a:	002010        	rsync
    or      a0, a0, a5                      /* set top 2 bits */
4037676d:	200050        	or	a0, a0, a5
    addx2   a0, a5, a0                      /* clear top bit -- thus simulating call4 size */
40376770:	900500        	addx2	a0, a5, a0
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376773:	03e820        	rsr.exccause	a2
    rsr     a2, EXCCAUSE                    /* recover exc cause */
40376776:	03e820        	rsr.exccause	a2
    movi    a3, _xt_exception_table
40376779:	f7e831        	l32r	a3, 4037471c <_iram_text_start+0x318>
    get_percpu_entry_for a2, a4
4037677c:	03eb40        	rsr.prid	a4
4037677f:	044d40        	extui	a4, a4, 13, 1
40376782:	902240        	addx2	a2, a2, a4
    addx4   a4, a2, a3                      /* a4 = address of exception table entry */
40376785:	a04230        	addx4	a4, a2, a3
    l32i    a4, a4, 0                       /* a4 = handler address */
40376788:	0448      	l32i.n	a4, a4, 0
    mov     a6, sp                          /* a6 = pointer to exc frame */
4037678a:	016d      	mov.n	a6, a1
    callx4  a4                              /* call handler */
4037678c:	0004d0        	callx4	a4
    call0   _xt_context_restore
4037678f:	039a45        	call0	4037a134 <_xt_context_restore>
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376792:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
40376794:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376797:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
40376799:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
4037679c:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove exception frame */
4037679e:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
403767a0:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
403767a3:	003000        	rfe
	...

403767a8 <_xt_user_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
403767a8:	2108      	l32i.n	a0, a1, 8
    wsr     a0, PS
403767aa:	13e600        	wsr.ps	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
403767ad:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_1
403767af:	13b100        	wsr.epc1	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
403767b2:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
403767b4:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure PS and EPC written */
403767b6:	002010        	rsync
    rfe                                     /* PS.EXCM is cleared */
403767b9:	003000        	rfe

403767bc <_xt_syscall_exc>:
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
403767bc:	ffd112        	addmi	a1, a1, 0xffffff00
403767bf:	40c112        	addi	a1, a1, 64
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
403767c2:	0f61c2        	s32i	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
403767c5:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
403767c8:	038c45        	call0	4037a090 <_xt_context_save>
    rsr     a2, EPC_1                       /* a2 = PC of 'syscall' */
403767cb:	03b120        	rsr.epc1	a2
    addi    a3, a2, 3                       /* ++PC                 */
403767ce:	03c232        	addi	a3, a2, 3
    rsr     a0, LEND                        /* if (PC == LEND       */
403767d1:	030100        	rsr.lend	a0
    bne     a3, a0, 1f
403767d4:	0d9307        	bne	a3, a0, 403767e5 <_xt_syscall_exc+0x29>
    rsr     a0, LCOUNT                      /*     && LCOUNT != 0)  */
403767d7:	030200        	rsr.lcount	a0
    beqz    a0, 1f                          /* {                    */
403767da:	007016        	beqz	a0, 403767e5 <_xt_syscall_exc+0x29>
    addi    a0, a0, -1                      /*   --LCOUNT           */
403767dd:	000b      	addi.n	a0, a0, -1
    rsr     a3, LBEG                        /*   PC = LBEG          */
403767df:	030030        	rsr.lbeg	a3
    wsr     a0, LCOUNT                      /* }                    */
403767e2:	130200        	wsr.lcount	a0
1:  wsr     a3, EPC_1                       /* update PC            */
403767e5:	13b130        	wsr.epc1	a3
    call0   _xt_context_restore
403767e8:	039485        	call0	4037a134 <_xt_context_restore>
    addi    sp, sp, XT_STK_FRMSZ
403767eb:	01d112        	addmi	a1, a1, 0x100
403767ee:	c0c112        	addi	a1, a1, -64
    movi    a0, -1
403767f1:	f07c      	movi.n	a0, -1
    movnez  a2, a0, a2                      /* return -1 if not syscall 0 */
403767f3:	932020        	movnez	a2, a0, a2
    rsr     a0, EXCSAVE_1
403767f6:	03d100        	rsr.excsave1	a0
    rfe
403767f9:	003000        	rfe
    j   .L_xt_coproc_invalid    /* not in a thread (invalid) */
403767fc:	00a146        	j	40376a85 <_xt_coproc_exc+0x281>
403767ff:	00          	.byte 00
    j   .L_xt_coproc_done
40376800:	009206        	j	40376a4c <_xt_coproc_exc+0x248>
	...

40376804 <_xt_coproc_exc>:
    mov     a0, sp                          /* sp == a1 */
40376804:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376806:	ffd112        	addmi	a1, a1, 0xffffff00
40376809:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
4037680c:	4109      	s32i.n	a0, a1, 16
    s32e    a0, sp, -12                     /* for debug backtrace */
4037680e:	49d100        	s32e	a0, a1, -12
    rsr     a0, PS                          /* save interruptee's PS */
40376811:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376814:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376816:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376819:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
4037681b:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
4037681e:	3109      	s32i.n	a0, a1, 12
    s32e    a0, sp, -16                     /* for debug backtrace */
40376820:	49c100        	s32e	a0, a1, -16
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
40376823:	f7bf01        	l32r	a0, 40374720 <_iram_text_start+0x31c>
    s32i    a0, sp, XT_STK_EXIT
40376826:	0109      	s32i.n	a0, a1, 0
    rsr     a0, EXCCAUSE
40376828:	03e800        	rsr.exccause	a0
    s32i    a5, sp, XT_STK_A5               /* save a5 */
4037682b:	8159      	s32i.n	a5, a1, 32
    addi    a5, a0, -EXCCAUSE_CP0_DISABLED  /* a5 = CP index */
4037682d:	e0c052        	addi	a5, a0, -32
    s32i    a2,  sp, XT_STK_A2
40376830:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
40376832:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
40376834:	7149      	s32i.n	a4, a1, 28
    s32i    a15, sp, XT_STK_A15
40376836:	1261f2        	s32i	a15, a1, 72
    call0   XT_RTOS_CP_STATE                /* a15 = new owner's save area */
40376839:	038285        	call0	4037a064 <_frxt_task_coproc_state>
    beqz    a15, .L_goto_invalid            /* not in a thread (invalid) */
4037683c:	fbcf16        	beqz	a15, 403767fc <_xt_syscall_exc+0x40>
    movi    a2, pxCurrentTCB
4037683f:	f7b921        	l32r	a2, 40374724 <_iram_text_start+0x320>
    getcoreid a3                            /* a3 = current core ID */
40376842:	03eb30        	rsr.prid	a3
40376845:	043d30        	extui	a3, a3, 13, 1
    addx4   a2, a3, a2
40376848:	a02320        	addx4	a2, a3, a2
    l32i    a2, a2, 0                       /* a2 = start of pxCurrentTCB[cpuid] */
4037684b:	0228      	l32i.n	a2, a2, 0
    addi    a2, a2, TASKTCB_XCOREID_OFFSET  /* a2 = &TCB.xCoreID */
4037684d:	48c222        	addi	a2, a2, 72
    s32i    a3, a2, 0                       /* TCB.xCoreID = current core ID */
40376850:	0239      	s32i.n	a3, a2, 0
    movi    a0, _xt_coproc_mask
40376852:	f7b501        	l32r	a0, 40374728 <_iram_text_start+0x324>
    rsr     a4, CPENABLE                    /* a4 = CPENABLE */
40376855:	03e040        	rsr.cpenable	a4
    addx4   a0, a5, a0                      /* a0 = &_xt_coproc_mask[n] */
40376858:	a00500        	addx4	a0, a5, a0
    l32i    a0, a0, 0                       /* a0 = (n << 16) | (1 << n) */
4037685b:	0008      	l32i.n	a0, a0, 0
    extui   a2, a0, 0, 16                   /* coprocessor bitmask portion */
4037685d:	f42000        	extui	a2, a0, 0, 16
    or      a4, a4, a2                      /* a4 = CPENABLE | (1 << n) */
40376860:	204420        	or	a4, a4, a2
    wsr     a4, CPENABLE
40376863:	13e040        	wsr.cpenable	a4
    movi    a2, XCHAL_CP_MAX << 2
40376866:	021c      	movi.n	a2, 16
    mull    a2, a2, a3                      /* multiply by current processor id */
40376868:	822230        	mull	a2, a2, a3
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of owner array */
4037686b:	f7b031        	l32r	a3, 4037472c <_iram_text_start+0x328>
    add     a3, a3, a2                      /* a3 = owner area needed for this processor */
4037686e:	332a      	add.n	a3, a3, a2
    addx4   a3,  a5, a3                      /* a3 = &_xt_coproc_owner_sa[n] */
40376870:	a03530        	addx4	a3, a5, a3
    l32i    a2,  a3, 0                       /* a2 = old owner's save area */
40376873:	0328      	l32i.n	a2, a3, 0
    s32i    a15, a3, 0                       /* _xt_coproc_owner_sa[n] = new */
40376875:	03f9      	s32i.n	a15, a3, 0
    rsync                                    /* ensure wsr.CPENABLE is complete */
40376877:	002010        	rsync
    beq     a15, a2, .L_goto_done           /* new owner == old, we're done */
4037687a:	029f27        	bne	a15, a2, 40376880 <_xt_coproc_exc+0x7c>
4037687d:	ffdfc6        	j	40376800 <_xt_syscall_exc+0x44>
    beqz    a2, .L_check_new
40376880:	0e8216        	beqz	a2, 4037696c <_xt_coproc_exc+0x168>
    l16ui   a4,  a2,  XT_CPENABLE           /* a4 = old owner's CPENABLE */
40376883:	001242        	l16ui	a4, a2, 0
    bnone   a4,  a0,  .L_check_new          /* old owner not using CP    */
40376886:	028407        	bany	a4, a0, 4037688c <_xt_coproc_exc+0x88>
40376889:	0037c6        	j	4037696c <_xt_coproc_exc+0x168>
    movi    a5, _xt_coproc_sa_offset
4037688c:	f7a951        	l32r	a5, 40374730 <_iram_text_start+0x32c>
    xor     a4,  a4,  a0                    /* clear CP bit in CPENABLE    */
4037688f:	304400        	xor	a4, a4, a0
    s16i    a4,  a2,  XT_CPENABLE           /* update old owner's CPENABLE */
40376892:	005242        	s16i	a4, a2, 0
    extui   a4,  a0,  16,  5                /* a4 = CP index = n */
40376895:	454000        	extui	a4, a0, 16, 5
    addx4   a5,  a4,  a5                    /* a5 = &_xt_coproc_sa_offset[n] */
40376898:	a05450        	addx4	a5, a4, a5
    l16ui   a4,  a2,  XT_CPSTORED           /* a4 = old owner's CPSTORED */
4037689b:	011242        	l16ui	a4, a2, 2
    l32i    a5,  a5,  0                     /* a5 = XT_CP[n]_SA offset */
4037689e:	0558      	l32i.n	a5, a5, 0
    or      a4,  a4,  a0                    /* set CP in old owner's CPSTORED */
403768a0:	204400        	or	a4, a4, a0
    s16i    a4,  a2,  XT_CPSTORED           /* update old owner's CPSTORED */
403768a3:	015242        	s16i	a4, a2, 2
    l32i    a2, a2, XT_CP_ASA               /* ptr to actual (aligned) save area */
403768a6:	2228      	l32i.n	a2, a2, 8
    extui   a3, a0, 16, 5                   /* a3 = CP index = n */
403768a8:	453000        	extui	a3, a0, 16, 5
    add     a2, a2, a5                      /* a2 = old owner's area for CP n */
403768ab:	225a      	add.n	a2, a2, a5
    xchal_cpi_store_funcbody
403768ad:	b3fc      	bnez.n	a3, 403768ec <_xt_coproc_exc+0xe8>
403768af:	e33e80        	rur.fcr	a3
403768b2:	0239      	s32i.n	a3, a2, 0
403768b4:	e33e90        	rur.fsr	a3
403768b7:	1239      	s32i.n	a3, a2, 4
403768b9:	024203        	ssi	f0, a2, 8
403768bc:	034213        	ssi	f1, a2, 12
403768bf:	044223        	ssi	f2, a2, 16
403768c2:	054233        	ssi	f3, a2, 20
403768c5:	064243        	ssi	f4, a2, 24
403768c8:	074253        	ssi	f5, a2, 28
403768cb:	084263        	ssi	f6, a2, 32
403768ce:	094273        	ssi	f7, a2, 36
403768d1:	0a4283        	ssi	f8, a2, 40
403768d4:	0b4293        	ssi	f9, a2, 44
403768d7:	0c42a3        	ssi	f10, a2, 48
403768da:	0d42b3        	ssi	f11, a2, 52
403768dd:	0e42c3        	ssi	f12, a2, 56
403768e0:	0f42d3        	ssi	f13, a2, 60
403768e3:	1042e3        	ssi	f14, a2, 64
403768e6:	1142f3        	ssi	f15, a2, 68
403768e9:	001fc6        	j	4037696c <_xt_coproc_exc+0x168>
403768ec:	7c3366        	bnei	a3, 3, 4037696c <_xt_coproc_exc+0x168>
403768ef:	e33000        	rur.accx_0	a3
403768f2:	0239      	s32i.n	a3, a2, 0
403768f4:	e33010        	rur.accx_1	a3
403768f7:	1239      	s32i.n	a3, a2, 4
403768f9:	e33020        	rur.qacc_h_0	a3
403768fc:	2239      	s32i.n	a3, a2, 8
403768fe:	e33030        	rur.qacc_h_1	a3
40376901:	3239      	s32i.n	a3, a2, 12
40376903:	e33040        	rur.qacc_h_2	a3
40376906:	4239      	s32i.n	a3, a2, 16
40376908:	e33050        	rur.qacc_h_3	a3
4037690b:	5239      	s32i.n	a3, a2, 20
4037690d:	e33060        	rur.qacc_h_4	a3
40376910:	6239      	s32i.n	a3, a2, 24
40376912:	e33070        	rur.qacc_l_0	a3
40376915:	7239      	s32i.n	a3, a2, 28
40376917:	e33080        	rur.qacc_l_1	a3
4037691a:	8239      	s32i.n	a3, a2, 32
4037691c:	e33090        	rur.qacc_l_2	a3
4037691f:	9239      	s32i.n	a3, a2, 36
40376921:	e330a0        	rur.qacc_l_3	a3
40376924:	a239      	s32i.n	a3, a2, 40
40376926:	e330b0        	rur.qacc_l_4	a3
40376929:	b239      	s32i.n	a3, a2, 44
4037692b:	e330d0        	rur.sar_byte	a3
4037692e:	c239      	s32i.n	a3, a2, 48
40376930:	e330e0        	rur.fft_bit_width	a3
40376933:	d239      	s32i.n	a3, a2, 52
40376935:	e330f0        	rur.ua_state_0	a3
40376938:	e239      	s32i.n	a3, a2, 56
4037693a:	e33100        	rur.ua_state_1	a3
4037693d:	f239      	s32i.n	a3, a2, 60
4037693f:	e33110        	rur.ua_state_2	a3
40376942:	106232        	s32i	a3, a2, 64
40376945:	e33120        	rur.ua_state_3	a3
40376948:	116232        	s32i	a3, a2, 68
4037694b:	cd6524        	st.qr	q0, a2, 80
4037694e:	cde624        	st.qr	q1, a2, 96
40376951:	dd6724        	st.qr	q2, a2, 112
40376954:	01d222        	addmi	a2, a2, 0x100
40376957:	80c222        	addi	a2, a2, -128
4037695a:	dde024        	st.qr	q3, a2, 0
4037695d:	ed6124        	st.qr	q4, a2, 16
40376960:	ede224        	st.qr	q5, a2, 32
40376963:	fd6324        	st.qr	q6, a2, 48
40376966:	fde424        	st.qr	q7, a2, 64
40376969:	ffffc6        	j	4037696c <_xt_coproc_exc+0x168>
    beqz    a15, .L_xt_coproc_done
4037696c:	0dcf16        	beqz	a15, 40376a4c <_xt_coproc_exc+0x248>
    l16ui   a3,  a15, XT_CPSTORED           /* a3 = new owner's CPSTORED */
4037696f:	011f32        	l16ui	a3, a15, 2
    movi    a4, _xt_coproc_sa_offset
40376972:	f76f41        	l32r	a4, 40374730 <_iram_text_start+0x32c>
    bnone   a3,  a0,  .L_check_cs           /* full CP not saved, check callee-saved */
40376975:	028307        	bany	a3, a0, 4037697b <_xt_coproc_exc+0x177>
40376978:	003806        	j	40376a5c <_xt_coproc_exc+0x258>
    xor     a3,  a3,  a0                    /* CPSTORED bit is set, clear it */
4037697b:	303300        	xor	a3, a3, a0
    s16i    a3,  a15, XT_CPSTORED           /* update new owner's CPSTORED */
4037697e:	015f32        	s16i	a3, a15, 2
    extui   a3,  a0, 16, 5                  /* a3 = CP index = n */
40376981:	453000        	extui	a3, a0, 16, 5
    addx4   a4,  a3, a4                     /* a4 = &_xt_coproc_sa_offset[n] */
40376984:	a04340        	addx4	a4, a3, a4
    l32i    a4,  a4, 0                      /* a4 = XT_CP[n]_SA */
40376987:	0448      	l32i.n	a4, a4, 0
    l32i    a5, a15, XT_CP_ASA              /* ptr to actual (aligned) save area */
40376989:	2f58      	l32i.n	a5, a15, 8
    add     a2,  a4, a5                     /* a2 = new owner's area for CP */
4037698b:	245a      	add.n	a2, a4, a5
    xchal_cpi_load_funcbody
4037698d:	b3fc      	bnez.n	a3, 403769cc <_xt_coproc_exc+0x1c8>
4037698f:	0238      	l32i.n	a3, a2, 0
40376991:	f3e830        	wur.fcr	a3
40376994:	1238      	l32i.n	a3, a2, 4
40376996:	f3e930        	wur.fsr	a3
40376999:	020203        	lsi	f0, a2, 8
4037699c:	030213        	lsi	f1, a2, 12
4037699f:	040223        	lsi	f2, a2, 16
403769a2:	050233        	lsi	f3, a2, 20
403769a5:	060243        	lsi	f4, a2, 24
403769a8:	070253        	lsi	f5, a2, 28
403769ab:	080263        	lsi	f6, a2, 32
403769ae:	090273        	lsi	f7, a2, 36
403769b1:	0a0283        	lsi	f8, a2, 40
403769b4:	0b0293        	lsi	f9, a2, 44
403769b7:	0c02a3        	lsi	f10, a2, 48
403769ba:	0d02b3        	lsi	f11, a2, 52
403769bd:	0e02c3        	lsi	f12, a2, 56
403769c0:	0f02d3        	lsi	f13, a2, 60
403769c3:	1002e3        	lsi	f14, a2, 64
403769c6:	1102f3        	lsi	f15, a2, 68
403769c9:	001fc6        	j	40376a4c <_xt_coproc_exc+0x248>
403769cc:	7c3366        	bnei	a3, 3, 40376a4c <_xt_coproc_exc+0x248>
403769cf:	0238      	l32i.n	a3, a2, 0
403769d1:	f30030        	wur.accx_0	a3
403769d4:	1238      	l32i.n	a3, a2, 4
403769d6:	f30130        	wur.accx_1	a3
403769d9:	2238      	l32i.n	a3, a2, 8
403769db:	f30230        	wur.qacc_h_0	a3
403769de:	3238      	l32i.n	a3, a2, 12
403769e0:	f30330        	wur.qacc_h_1	a3
403769e3:	4238      	l32i.n	a3, a2, 16
403769e5:	f30430        	wur.qacc_h_2	a3
403769e8:	5238      	l32i.n	a3, a2, 20
403769ea:	f30530        	wur.qacc_h_3	a3
403769ed:	6238      	l32i.n	a3, a2, 24
403769ef:	f30630        	wur.qacc_h_4	a3
403769f2:	7238      	l32i.n	a3, a2, 28
403769f4:	f30730        	wur.qacc_l_0	a3
403769f7:	8238      	l32i.n	a3, a2, 32
403769f9:	f30830        	wur.qacc_l_1	a3
403769fc:	9238      	l32i.n	a3, a2, 36
403769fe:	f30930        	wur.qacc_l_2	a3
40376a01:	a238      	l32i.n	a3, a2, 40
40376a03:	f30a30        	wur.qacc_l_3	a3
40376a06:	b238      	l32i.n	a3, a2, 44
40376a08:	f30b30        	wur.qacc_l_4	a3
40376a0b:	c238      	l32i.n	a3, a2, 48
40376a0d:	f30d30        	wur.sar_byte	a3
40376a10:	d238      	l32i.n	a3, a2, 52
40376a12:	f30e30        	wur.fft_bit_width	a3
40376a15:	e238      	l32i.n	a3, a2, 56
40376a17:	f30f30        	wur.ua_state_0	a3
40376a1a:	f238      	l32i.n	a3, a2, 60
40376a1c:	f31030        	wur.ua_state_1	a3
40376a1f:	102232        	l32i	a3, a2, 64
40376a22:	f31130        	wur.ua_state_2	a3
40376a25:	112232        	l32i	a3, a2, 68
40376a28:	f31230        	wur.ua_state_3	a3
40376a2b:	cd2524        	ld.qr	q0, a2, 80
40376a2e:	cda624        	ld.qr	q1, a2, 96
40376a31:	dd2724        	ld.qr	q2, a2, 112
40376a34:	01d222        	addmi	a2, a2, 0x100
40376a37:	80c222        	addi	a2, a2, -128
40376a3a:	dda024        	ld.qr	q3, a2, 0
40376a3d:	ed2124        	ld.qr	q4, a2, 16
40376a40:	eda224        	ld.qr	q5, a2, 32
40376a43:	fd2324        	ld.qr	q6, a2, 48
40376a46:	fda424        	ld.qr	q7, a2, 64
40376a49:	ffffc6        	j	40376a4c <_xt_coproc_exc+0x248>
    l32i    a15, sp, XT_STK_A15
40376a4c:	1221f2        	l32i	a15, a1, 72
    l32i    a5,  sp, XT_STK_A5
40376a4f:	8158      	l32i.n	a5, a1, 32
    l32i    a4,  sp, XT_STK_A4
40376a51:	7148      	l32i.n	a4, a1, 28
    l32i    a3,  sp, XT_STK_A3
40376a53:	062132        	l32i	a3, a1, 24
    l32i    a2,  sp, XT_STK_A2
40376a56:	052122        	l32i	a2, a1, 20
    call0   _xt_user_exit                   /* return via exit dispatcher */
40376a59:	ffd4c5        	call0	403767a8 <_xt_user_exit>
    l16ui   a2, a15, XT_CP_CS_ST            /* a2 = mask of CPs saved    */
40376a5c:	021f22        	l16ui	a2, a15, 4
    bnone   a2,  a0, .L_xt_coproc_done      /* if no match then done     */
40376a5f:	e90207        	bnone	a2, a0, 40376a4c <_xt_coproc_exc+0x248>
    and     a2,  a2, a0                     /* a2 = which CPs to restore */
40376a62:	102200        	and	a2, a2, a0
    extui   a2,  a2, 0, 8                   /* extract low 8 bits        */
40376a65:	742020        	extui	a2, a2, 0, 8
    s32i    a6,  sp, XT_STK_A6              /* save extra needed regs    */
40376a68:	096162        	s32i	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
40376a6b:	0a6172        	s32i	a7, a1, 40
    s32i    a13, sp, XT_STK_A13
40376a6e:	1061d2        	s32i	a13, a1, 64
    s32i    a14, sp, XT_STK_A14
40376a71:	1161e2        	s32i	a14, a1, 68
    call0   _xt_coproc_restorecs            /* restore CP registers      */
40376a74:	037705        	call0	4037a1e8 <_xt_coproc_restorecs>
    l32i    a6,  sp, XT_STK_A6              /* restore saved registers   */
40376a77:	092162        	l32i	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
40376a7a:	a178      	l32i.n	a7, a1, 40
    l32i    a13, sp, XT_STK_A13
40376a7c:	1021d2        	l32i	a13, a1, 64
    l32i    a14, sp, XT_STK_A14
40376a7f:	1121e2        	l32i	a14, a1, 68
    j       .L_xt_coproc_done
40376a82:	fff186        	j	40376a4c <_xt_coproc_exc+0x248>
    movi    a0,PANIC_RSN_COPROCEXCEPTION
40376a85:	400c      	movi.n	a0, 4
    wsr     a0,EXCCAUSE
40376a87:	13e800        	wsr.exccause	a0
    call0   _xt_panic                       /* not in a thread (invalid) */
40376a8a:	201110        	or	a1, a1, a1
40376a8d:	0167c5        	call0	4037810c <_xt_panic>

40376a90 <_xt_lowint1>:
    mov     a0, sp                          /* sp == a1 */
40376a90:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376a93:	ffd112        	addmi	a1, a1, 0xffffff00
40376a96:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376a99:	046102        	s32i	a0, a1, 16
    rsr     a0, PS                          /* save interruptee's PS */
40376a9c:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
40376a9f:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
40376aa2:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40376aa5:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40376aa7:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40376aaa:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_user_exit               /* save exit point for dispatch */
40376aac:	f71d01        	l32r	a0, 40374720 <_iram_text_start+0x31c>
    s32i    a0, sp, XT_STK_EXIT
40376aaf:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40376ab1:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_1
40376ab3:	13d100        	wsr.excsave1	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40376ab6:	034585        	call0	40379f10 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(1) | PS_UM | PS_WOE
40376ab9:	f71e01        	l32r	a0, 40374734 <_iram_text_start+0x330>
    wsr     a0, PS
40376abc:	13e600        	wsr.ps	a0
    rsync
40376abf:	002010        	rsync
    dispatch_c_isr 1 XCHAL_INTLEVEL1_MASK
40376ac2:	03e420        	rsr.intenable	a2
40376ac5:	03e230        	rsr.interrupt	a3
40376ac8:	f71c41        	l32r	a4, 40374738 <_iram_text_start+0x334>
40376acb:	102230        	and	a2, a2, a3
40376ace:	102240        	and	a2, a2, a4
40376ad1:	04f216        	beqz	a2, 40376b24 <_xt_lowint1+0x94>
40376ad4:	03d100        	rsr.excsave1	a0
40376ad7:	3038      	l32i.n	a3, a0, 12
40376ad9:	49c130        	s32e	a3, a1, -16
40376adc:	4038      	l32i.n	a3, a0, 16
40376ade:	49d130        	s32e	a3, a1, -12
40376ae1:	03b100        	rsr.epc1	a0
40376ae4:	f70d41        	l32r	a4, 40374718 <_iram_text_start+0x314>
40376ae7:	200040        	or	a0, a0, a4
40376aea:	900400        	addx2	a0, a4, a0
40376aed:	420b      	addi.n	a4, a2, -1
40376aef:	102240        	and	a2, a2, a4
40376af2:	ff7256        	bnez	a2, 40376aed <_xt_lowint1+0x5d>
40376af5:	441b      	addi.n	a4, a4, 1
40376af7:	13e340        	wsr.intclear	a4
40376afa:	f31c      	movi.n	a3, 31
40376afc:	40f440        	nsau	a4, a4
40376aff:	c03340        	sub	a3, a3, a4
40376b02:	03ebc0        	rsr.prid	a12
40376b05:	04cdc0        	extui	a12, a12, 13, 1
40376b08:	9033c0        	addx2	a3, a3, a12
40376b0b:	f70c41        	l32r	a4, 4037473c <_iram_text_start+0x338>
40376b0e:	b03340        	addx8	a3, a3, a4
40376b11:	0348      	l32i.n	a4, a3, 0
40376b13:	202660        	or	a2, a6, a6
40376b16:	012362        	l32i	a6, a3, 4
40376b19:	0004d0        	callx4	a4
40376b1c:	ffe886        	j	40376ac2 <_xt_lowint1+0x32>
40376b1f:	00          	.byte 00
40376b20:	00          	.byte 00
40376b21:	ffe746        	j	40376ac2 <_xt_lowint1+0x32>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40376b24:	201110        	or	a1, a1, a1
40376b27:	0342c5        	call0	40379f54 <_frxt_int_exit>
	...

40376b2c <_xt_medint2>:
    mov     a0, sp                          /* sp == a1 */
40376b2c:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376b2f:	ffd112        	addmi	a1, a1, 0xffffff00
40376b32:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376b35:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_2                       /* save interruptee's PS */
40376b38:	03c200        	rsr.eps2	a0
    s32i    a0, sp, XT_STK_PS
40376b3b:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_2                       /* save interruptee's PC */
40376b3e:	03b200        	rsr.epc2	a0
    s32i    a0, sp, XT_STK_PC
40376b41:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_2                   /* save interruptee's a0 */
40376b43:	03d200        	rsr.excsave2	a0
    s32i    a0, sp, XT_STK_A0
40376b46:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint2_exit            /* save exit point for dispatch */
40376b48:	f6fe01        	l32r	a0, 40374740 <_iram_text_start+0x33c>
    s32i    a0, sp, XT_STK_EXIT
40376b4b:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40376b4d:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_2
40376b4f:	13d200        	wsr.excsave2	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40376b52:	033bc5        	call0	40379f10 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(2) | PS_UM | PS_WOE
40376b55:	f6fb01        	l32r	a0, 40374744 <_iram_text_start+0x340>
    wsr     a0, PS
40376b58:	13e600        	wsr.ps	a0
    rsync
40376b5b:	002010        	rsync
    dispatch_c_isr 2 XCHAL_INTLEVEL2_MASK
40376b5e:	03e420        	rsr.intenable	a2
40376b61:	03e230        	rsr.interrupt	a3
40376b64:	f6f941        	l32r	a4, 40374748 <_iram_text_start+0x344>
40376b67:	102230        	and	a2, a2, a3
40376b6a:	102240        	and	a2, a2, a4
40376b6d:	04f216        	beqz	a2, 40376bc0 <_xt_medint2+0x94>
40376b70:	03d200        	rsr.excsave2	a0
40376b73:	3038      	l32i.n	a3, a0, 12
40376b75:	49c130        	s32e	a3, a1, -16
40376b78:	4038      	l32i.n	a3, a0, 16
40376b7a:	49d130        	s32e	a3, a1, -12
40376b7d:	03b200        	rsr.epc2	a0
40376b80:	f6e641        	l32r	a4, 40374718 <_iram_text_start+0x314>
40376b83:	200040        	or	a0, a0, a4
40376b86:	900400        	addx2	a0, a4, a0
40376b89:	420b      	addi.n	a4, a2, -1
40376b8b:	102240        	and	a2, a2, a4
40376b8e:	ff7256        	bnez	a2, 40376b89 <_xt_medint2+0x5d>
40376b91:	441b      	addi.n	a4, a4, 1
40376b93:	13e340        	wsr.intclear	a4
40376b96:	f31c      	movi.n	a3, 31
40376b98:	40f440        	nsau	a4, a4
40376b9b:	c03340        	sub	a3, a3, a4
40376b9e:	03ebc0        	rsr.prid	a12
40376ba1:	04cdc0        	extui	a12, a12, 13, 1
40376ba4:	9033c0        	addx2	a3, a3, a12
40376ba7:	f6e541        	l32r	a4, 4037473c <_iram_text_start+0x338>
40376baa:	b03340        	addx8	a3, a3, a4
40376bad:	0348      	l32i.n	a4, a3, 0
40376baf:	202660        	or	a2, a6, a6
40376bb2:	012362        	l32i	a6, a3, 4
40376bb5:	0004d0        	callx4	a4
40376bb8:	ffe886        	j	40376b5e <_xt_medint2+0x32>
40376bbb:	00          	.byte 00
40376bbc:	00          	.byte 00
40376bbd:	ffe746        	j	40376b5e <_xt_medint2+0x32>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40376bc0:	201110        	or	a1, a1, a1
40376bc3:	033905        	call0	40379f54 <_frxt_int_exit>
	...

40376bc8 <_xt_medint2_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376bc8:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_2
40376bca:	13c200        	wsr.eps2	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376bcd:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_2
40376bcf:	13b200        	wsr.epc2	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376bd2:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40376bd4:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
40376bd6:	002010        	rsync
    rfi     2
40376bd9:	003210        	rfi	2

40376bdc <_xt_medint3>:
    mov     a0, sp                          /* sp == a1 */
40376bdc:	200110        	or	a0, a1, a1
    addi    sp, sp, -XT_STK_FRMSZ           /* allocate interrupt stack frame */
40376bdf:	ffd112        	addmi	a1, a1, 0xffffff00
40376be2:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1               /* save pre-interrupt SP */
40376be5:	046102        	s32i	a0, a1, 16
    rsr     a0, EPS_3                       /* save interruptee's PS */
40376be8:	03c300        	rsr.eps3	a0
    s32i    a0, sp, XT_STK_PS
40376beb:	026102        	s32i	a0, a1, 8
    rsr     a0, EPC_3                       /* save interruptee's PC */
40376bee:	03b300        	rsr.epc3	a0
    s32i    a0, sp, XT_STK_PC
40376bf1:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_3                   /* save interruptee's a0 */
40376bf3:	03d300        	rsr.excsave3	a0
    s32i    a0, sp, XT_STK_A0
40376bf6:	3109      	s32i.n	a0, a1, 12
    movi    a0, _xt_medint3_exit            /* save exit point for dispatch */
40376bf8:	f6d501        	l32r	a0, 4037474c <_iram_text_start+0x348>
    s32i    a0, sp, XT_STK_EXIT
40376bfb:	0109      	s32i.n	a0, a1, 0
    mov     a0, sp
40376bfd:	010d      	mov.n	a0, a1
    wsr     a0, EXCSAVE_3
40376bff:	13d300        	wsr.excsave3	a0
    call0   XT_RTOS_INT_ENTER               /* common RTOS interrupt entry */
40376c02:	0330c5        	call0	40379f10 <_frxt_int_enter>
    movi    a0, PS_INTLEVEL(3) | PS_UM | PS_WOE
40376c05:	f6d201        	l32r	a0, 40374750 <_iram_text_start+0x34c>
    wsr     a0, PS
40376c08:	13e600        	wsr.ps	a0
    rsync
40376c0b:	002010        	rsync
    dispatch_c_isr 3 XCHAL_INTLEVEL3_MASK
40376c0e:	03e420        	rsr.intenable	a2
40376c11:	03e230        	rsr.interrupt	a3
40376c14:	f6d041        	l32r	a4, 40374754 <_iram_text_start+0x350>
40376c17:	102230        	and	a2, a2, a3
40376c1a:	102240        	and	a2, a2, a4
40376c1d:	04f216        	beqz	a2, 40376c70 <_xt_medint3+0x94>
40376c20:	03d300        	rsr.excsave3	a0
40376c23:	3038      	l32i.n	a3, a0, 12
40376c25:	49c130        	s32e	a3, a1, -16
40376c28:	4038      	l32i.n	a3, a0, 16
40376c2a:	49d130        	s32e	a3, a1, -12
40376c2d:	03b300        	rsr.epc3	a0
40376c30:	f6ba41        	l32r	a4, 40374718 <_iram_text_start+0x314>
40376c33:	200040        	or	a0, a0, a4
40376c36:	900400        	addx2	a0, a4, a0
40376c39:	420b      	addi.n	a4, a2, -1
40376c3b:	102240        	and	a2, a2, a4
40376c3e:	ff7256        	bnez	a2, 40376c39 <_xt_medint3+0x5d>
40376c41:	441b      	addi.n	a4, a4, 1
40376c43:	13e340        	wsr.intclear	a4
40376c46:	f31c      	movi.n	a3, 31
40376c48:	40f440        	nsau	a4, a4
40376c4b:	c03340        	sub	a3, a3, a4
40376c4e:	03ebc0        	rsr.prid	a12
40376c51:	04cdc0        	extui	a12, a12, 13, 1
40376c54:	9033c0        	addx2	a3, a3, a12
40376c57:	f6b941        	l32r	a4, 4037473c <_iram_text_start+0x338>
40376c5a:	b03340        	addx8	a3, a3, a4
40376c5d:	0348      	l32i.n	a4, a3, 0
40376c5f:	202660        	or	a2, a6, a6
40376c62:	012362        	l32i	a6, a3, 4
40376c65:	0004d0        	callx4	a4
40376c68:	ffe886        	j	40376c0e <_xt_medint3+0x32>
40376c6b:	00          	.byte 00
40376c6c:	00          	.byte 00
40376c6d:	ffe746        	j	40376c0e <_xt_medint3+0x32>
    call0   XT_RTOS_INT_EXIT                /* does not return directly here */
40376c70:	201110        	or	a1, a1, a1
40376c73:	032e05        	call0	40379f54 <_frxt_int_exit>
	...

40376c78 <_xt_medint3_exit>:
    l32i    a0, sp, XT_STK_PS               /* retrieve interruptee's PS */
40376c78:	2108      	l32i.n	a0, a1, 8
    wsr     a0, EPS_3
40376c7a:	13c300        	wsr.eps3	a0
    l32i    a0, sp, XT_STK_PC               /* retrieve interruptee's PC */
40376c7d:	1108      	l32i.n	a0, a1, 4
    wsr     a0, EPC_3
40376c7f:	13b300        	wsr.epc3	a0
    l32i    a0, sp, XT_STK_A0               /* retrieve interruptee's A0 */
40376c82:	3108      	l32i.n	a0, a1, 12
    l32i    sp, sp, XT_STK_A1               /* remove interrupt stack frame */
40376c84:	4118      	l32i.n	a1, a1, 16
    rsync                                   /* ensure EPS and EPC written */
40376c86:	002010        	rsync
    rfi     3
40376c89:	003310        	rfi	3

40376c8c <SysTickIsrHandler>:
 *
 * The Systimer interrupt for SysTick works in periodic mode no need to calc the next alarm.
 * If a timer interrupt is ever serviced more than one tick late, it is necessary to process multiple ticks.
 */
IRAM_ATTR void SysTickIsrHandler(void *arg)
{
40376c8c:	004136        	entry	a1, 32
40376c8f:	03eb30        	rsr.prid	a3
40376c92:	043d30        	extui	a3, a3, 13, 1

    uint32_t alarm_id = SYSTIMER_LL_ALARM_OS_TICK_CORE0 + cpuid;
    do {
        systimer_ll_clear_alarm_int(systimer_hal->dev, alarm_id);

        uint32_t diff = systimer_hal_get_counter_value(systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK) / systimer_ll_get_alarm_period(systimer_hal->dev, alarm_id) - s_handled_systicks[cpuid];
40376c95:	f6b161        	l32r	a6, 4037475c <_iram_text_start+0x358>
    dev->target_conf[alarm_id].target_period = period;
}

__attribute__((always_inline)) static inline uint32_t systimer_ll_get_alarm_period(systimer_dev_t *dev, uint32_t alarm_id)
{
    return dev->target_conf[alarm_id].target_period;
40376c98:	0cc352        	addi	a5, a3, 12
    return dev->int_st.val & (1 << alarm_id);
}

__attribute__((always_inline)) static inline void systimer_ll_clear_alarm_int(systimer_dev_t *dev, uint32_t alarm_id)
{
    dev->int_clr.val |= 1 << alarm_id;
40376c9b:	01a042        	movi	a4, 1
40376c9e:	401300        	ssl	a3
40376ca1:	a14400        	sll	a4, a4
40376ca4:	1173e0        	slli	a7, a3, 2
    return dev->target_conf[alarm_id].target_period;
40376ca7:	1155e0        	slli	a5, a5, 2
40376caa:	a03360        	addx4	a3, a3, a6
        systimer_ll_clear_alarm_int(systimer_hal->dev, alarm_id);
40376cad:	0298      	l32i.n	a9, a2, 0
        uint32_t diff = systimer_hal_get_counter_value(systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK) / systimer_ll_get_alarm_period(systimer_hal->dev, alarm_id) - s_handled_systicks[cpuid];
40376caf:	1b0c      	movi.n	a11, 1
    dev->int_clr.val |= 1 << alarm_id;
40376cb1:	0020c0        	memw
40376cb4:	1b2982        	l32i	a8, a9, 108
40376cb7:	02ad      	mov.n	a10, a2
40376cb9:	208840        	or	a8, a8, a4
40376cbc:	0020c0        	memw
40376cbf:	1b6982        	s32i	a8, a9, 108
40376cc2:	06ca25        	call8	4037d964 <systimer_hal_get_counter_value>
40376cc5:	0288      	l32i.n	a8, a2, 0
40376cc7:	0d0c      	movi.n	a13, 0
    return dev->target_conf[alarm_id].target_period;
40376cc9:	885a      	add.n	a8, a8, a5
40376ccb:	0020c0        	memw
40376cce:	18c8      	l32i.n	a12, a8, 4
40376cd0:	f6a281        	l32r	a8, 40374758 <_iram_text_start+0x354>
40376cd3:	10cc80        	and	a12, a12, a8
40376cd6:	f6a281        	l32r	a8, 40374760 <_iram_text_start+0x35c>
40376cd9:	0008e0        	callx8	a8
40376cdc:	03b8      	l32i.n	a11, a3, 0
40376cde:	c09ab0        	sub	a9, a10, a11
        if (diff > 0) {
40376ce1:	191ab7        	beq	a10, a11, 40376cfe <SysTickIsrHandler+0x72>
            if (s_handled_systicks[cpuid] == 0) {
                s_handled_systicks[cpuid] = diff;
                diff = 1;
40376ce4:	160c      	movi.n	a6, 1
            if (s_handled_systicks[cpuid] == 0) {
40376ce6:	3b8c      	beqz.n	a11, 40376ced <SysTickIsrHandler+0x61>
40376ce8:	096d      	mov.n	a6, a9
            } else {
                s_handled_systicks[cpuid] += diff;
40376cea:	209aa0        	or	a9, a10, a10
40376ced:	f69b81        	l32r	a8, 4037475c <_iram_text_start+0x358>
40376cf0:	a87a      	add.n	a10, a8, a7
40376cf2:	006a92        	s32i	a9, a10, 0
            }

            do {
                xPortSysTickHandler();
            } while (--diff);
40376cf5:	ffc662        	addi	a6, a6, -1
                xPortSysTickHandler();
40376cf8:	035fe5        	call8	4037a2f8 <xPortSysTickHandler>
            } while (--diff);
40376cfb:	ff6656        	bnez	a6, 40376cf5 <SysTickIsrHandler+0x69>
        }
    } while (systimer_ll_is_alarm_int_fired(systimer_hal->dev, alarm_id));
40376cfe:	002282        	l32i	a8, a2, 0
    return dev->int_st.val & (1 << alarm_id);
40376d01:	0020c0        	memw
40376d04:	1c2882        	l32i	a8, a8, 112
40376d07:	a28487        	bany	a4, a8, 40376cad <SysTickIsrHandler+0x21>

#ifdef CONFIG_PM_TRACE
    ESP_PM_TRACE_EXIT(TICK, cpuid);
#endif
}
40376d0a:	000090        	retw
40376d0d:	000000        	ill

40376d10 <xt_debugexception>:
    extui   a0, a0, XT_DEBUGCAUSE_DI, 1
    bnez    a0, _xt_debug_di_exc
1:
#endif //(CONFIG_ESP32_ECO3_CACHE_LOCK_FIX && CONFIG_BTDM_CTRL_HLI)

    movi    a0,PANIC_RSN_DEBUGEXCEPTION
40376d10:	100c      	movi.n	a0, 1
    wsr     a0,EXCCAUSE
40376d12:	13e800        	wsr.exccause	a0
    /* _xt_panic assumes a level 1 exception. As we're
       crashing anyhow, copy EPC & EXCSAVE from DEBUGLEVEL
       to level 1. */
    rsr     a0,(EPC + XCHAL_DEBUGLEVEL)
40376d15:	03b600        	rsr.epc6	a0
    wsr     a0,EPC_1
40376d18:	13b100        	wsr.epc1	a0
    rsr     a0,(EXCSAVE + XCHAL_DEBUGLEVEL)
40376d1b:	03d600        	rsr.excsave6	a0
    wsr     a0,EXCSAVE_1
40376d1e:	13d100        	wsr.excsave1	a0
#if CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
    J   _xt_panic_gdbstub                   /* For gdbstub we make jump */
#else
    call0   _xt_panic                       /* does not return */
40376d21:	013e85        	call0	4037810c <_xt_panic>
#endif // CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
    rfi     XCHAL_DEBUGLEVEL
40376d24:	003610        	rfi	6
	...

40376d28 <_xt_highint4>:

    /* Default handler does nothing; just returns */

    .align  4
.L_xt_highint4_exit:
    rsr     a0, EXCSAVE_4                   /* restore a0 */
40376d28:	03d400        	rsr.excsave4	a0
    rfi     4
40376d2b:	003410        	rfi	4
	...

40376d30 <xt_highint5>:

    /* Default handler does nothing; just returns */

    .align  4
.L_xt_highint5_exit:
    rsr     a0, EXCSAVE_5                   /* restore a0 */
40376d30:	03d500        	rsr.excsave5	a0
    rfi     5
40376d33:	003510        	rfi	5
	...

40376d38 <_xt_nmi>:

    /* Default handler does nothing; just returns */

    .align  4
.L_xt_nmi_exit:
    rsr     a0, EXCSAVE + XCHAL_NMILEVEL    /* restore a0 */
40376d38:	03d700        	rsr.excsave7	a0
    rfi     XCHAL_NMILEVEL
40376d3b:	003710        	rfi	7
	...

40376d40 <lock_init_generic>:
   as the _lock_t value.

   Called by _lock_init*, also called by _lock_acquire* to lazily initialize locks that might have
   been initialised (to zero only) before the RTOS scheduler started.
*/
static void IRAM_ATTR lock_init_generic(_lock_t *lock, uint8_t mutex_type) {
40376d40:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40376d43:	f68841        	l32r	a4, 40374764 <_iram_text_start+0x360>
40376d46:	ffafb2        	movi	a11, -1
40376d49:	04ad      	mov.n	a10, a4
40376d4b:	058665        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL(&lock_init_spinlock);
    if (*lock) {
40376d4e:	0288      	l32i.n	a8, a2, 0
40376d50:	b8cc      	bnez.n	a8, 40376d5f <lock_init_generic+0x1f>
           implements these as macros instead of inline functions
           (*party like it's 1998!*) it's not possible to do this
           without writing wrappers. Doing it this way seems much less
           spaghetti-like.
        */
        SemaphoreHandle_t new_sem = xQueueCreateMutex(mutex_type);
40376d52:	03ad      	mov.n	a10, a3
40376d54:	03b925        	call8	4037a8e8 <xQueueCreateMutex>
        if (!new_sem) {
40376d57:	1acc      	bnez.n	a10, 40376d5c <lock_init_generic+0x1c>
            abort(); /* No more semaphores available or OOM */
40376d59:	07a225        	call8	4037e77c <abort>
        }
        *lock = (_lock_t)new_sem;
40376d5c:	0062a2        	s32i	a10, a2, 0
    }
    portEXIT_CRITICAL(&lock_init_spinlock);
40376d5f:	20a440        	or	a10, a4, a4
40376d62:	059825        	call8	4037c6e4 <vPortExitCritical>
}
40376d65:	000090        	retw

40376d68 <check_lock_nonzero>:
    _lock_close_recursive(&lock);
}

/* Separate function, to prevent generating multiple assert strings */
static void IRAM_ATTR check_lock_nonzero(_LOCK_T lock)
{
40376d68:	004136        	entry	a1, 32
    assert(lock != NULL && "Uninitialized lock used");
40376d6b:	00e256        	bnez	a2, 40376d7d <check_lock_nonzero+0x15>
40376d6e:	f67ed1        	l32r	a13, 40374768 <_iram_text_start+0x364>
40376d71:	f67ec1        	l32r	a12, 4037476c <_iram_text_start+0x368>
40376d74:	f67fa1        	l32r	a10, 40374770 <_iram_text_start+0x36c>
40376d77:	2ca1b2        	movi	a11, 0x12c
40376d7a:	07a925        	call8	4037e80c <__assert_func>
}
40376d7d:	f01d      	retw.n
	...

40376d80 <lock_acquire_generic>:
static int IRAM_ATTR lock_acquire_generic(_lock_t *lock, uint32_t delay, uint8_t mutex_type) {
40376d80:	008136        	entry	a1, 64
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
40376d83:	0258      	l32i.n	a5, a2, 0
    if (!h) {
40376d85:	75ec      	bnez.n	a5, 40376db0 <lock_acquire_generic+0x30>
        if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376d87:	04ef25        	call8	4037bc78 <xTaskGetSchedulerState>
40376d8a:	061a66        	bnei	a10, 1, 40376d94 <lock_acquire_generic+0x14>
            return 0; /* locking is a no-op before scheduler is up, so this "succeeds" */
40376d8d:	020c      	movi.n	a2, 0
}
40376d8f:	f01d      	retw.n
40376d91:	00          	.byte 00
40376d92:	00          	.byte 00
40376d93:	00          	.byte 00
        lock_init_generic(lock, mutex_type);
40376d94:	20b440        	or	a11, a4, a4
40376d97:	20a220        	or	a10, a2, a2
40376d9a:	fffa65        	call8	40376d40 <lock_init_generic>
        h = (SemaphoreHandle_t)(*lock);
40376d9d:	0258      	l32i.n	a5, a2, 0
        configASSERT(h != NULL);
40376d9f:	d5cc      	bnez.n	a5, 40376db0 <lock_acquire_generic+0x30>
40376da1:	f674d1        	l32r	a13, 40374774 <_iram_text_start+0x370>
40376da4:	f675c1        	l32r	a12, 40374778 <_iram_text_start+0x374>
40376da7:	f672a1        	l32r	a10, 40374770 <_iram_text_start+0x36c>
40376daa:	78a0b2        	movi	a11, 120
40376dad:	07a5e5        	call8	4037e80c <__assert_func>
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376db0:	201110        	or	a1, a1, a1
40376db3:	04ec65        	call8	4037bc78 <xTaskGetSchedulerState>
40376db6:	d31a26        	beqi	a10, 1, 40376d8d <lock_acquire_generic+0xd>
FORCE_INLINE_ATTR bool xPortCanYield(void)
{
    uint32_t ps_reg = 0;

    //Get the current value of PS (processor status) register
    RSR(PS, ps_reg);
40376db9:	03e620        	rsr.ps	a2
     * excm  = (ps_reg >> 4) & 0x1;
     * CINTLEVEL is max(excm * EXCMLEVEL, INTLEVEL), where EXCMLEVEL is 3.
     * However, just return true, only intlevel is zero.
     */

    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
40376dbc:	342020        	extui	a2, a2, 0, 4
    if (!xPortCanYield()) {
40376dbf:	52bc      	beqz.n	a2, 40376df8 <lock_acquire_generic+0x78>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376dc1:	054466        	bnei	a4, 4, 40376dca <lock_acquire_generic+0x4a>
            abort(); /* recursive mutexes make no sense in ISR context */
40376dc4:	201110        	or	a1, a1, a1
40376dc7:	079b65        	call8	4037e77c <abort>
        BaseType_t higher_task_woken = false;
40376dca:	0b0c      	movi.n	a11, 0
        success = xSemaphoreTakeFromISR(h, &higher_task_woken);
40376dcc:	01cd      	mov.n	a12, a1
40376dce:	05ad      	mov.n	a10, a5
        BaseType_t higher_task_woken = false;
40376dd0:	01b9      	s32i.n	a11, a1, 0
        success = xSemaphoreTakeFromISR(h, &higher_task_woken);
40376dd2:	03ec25        	call8	4037ac94 <xQueueReceiveFromISR>
        if (!success && delay > 0) {
40376dd5:	1acc      	bnez.n	a10, 40376dda <lock_acquire_generic+0x5a>
40376dd7:	fe9356        	bnez	a3, 40376dc4 <lock_acquire_generic+0x44>
        if (higher_task_woken) {
40376dda:	002122        	l32i	a2, a1, 0
40376ddd:	007216        	beqz	a2, 40376de8 <lock_acquire_generic+0x68>
            portYIELD_FROM_ISR();
40376de0:	0461a2        	s32i	a10, a1, 16
40376de3:	031165        	call8	40379ef8 <_frxt_setup_switch>
40376de6:	41a8      	l32i.n	a10, a1, 16
    return (success == pdTRUE) ? 0 : -1;
40376de8:	aa0b      	addi.n	a10, a10, -1
40376dea:	120c      	movi.n	a2, 1
40376dec:	030c      	movi.n	a3, 0
40376dee:	8323a0        	moveqz	a2, a3, a10
40376df1:	602020        	neg	a2, a2
40376df4:	ffe5c6        	j	40376d8f <lock_acquire_generic+0xf>
40376df7:	00          	.byte 00
            success = xSemaphoreTakeRecursive(h, delay);
40376df8:	03bd      	mov.n	a11, a3
40376dfa:	05ad      	mov.n	a10, a5
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376dfc:	084466        	bnei	a4, 4, 40376e08 <lock_acquire_generic+0x88>
            success = xSemaphoreTakeRecursive(h, delay);
40376dff:	03e565        	call8	4037ac54 <xQueueTakeMutexRecursive>
40376e02:	fff886        	j	40376de8 <lock_acquire_generic+0x68>
40376e05:	00          	.byte 00
40376e06:	00          	.byte 00
40376e07:	00          	.byte 00
            success = xSemaphoreTake(h, delay);
40376e08:	03cc65        	call8	4037aad0 <xQueueSemaphoreTake>
40376e0b:	fff646        	j	40376de8 <lock_acquire_generic+0x68>
	...

40376e10 <lock_release_generic>:
static void IRAM_ATTR lock_release_generic(_lock_t *lock, uint8_t mutex_type) {
40376e10:	006136        	entry	a1, 48
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40376e13:	04e665        	call8	4037bc78 <xTaskGetSchedulerState>
40376e16:	361a26        	beqi	a10, 1, 40376e50 <lock_release_generic+0x40>
    SemaphoreHandle_t h = (SemaphoreHandle_t)(*lock);
40376e19:	0022a2        	l32i	a10, a2, 0
    assert(h);
40376e1c:	00ea56        	bnez	a10, 40376e2e <lock_release_generic+0x1e>
40376e1f:	f657d1        	l32r	a13, 4037477c <_iram_text_start+0x378>
40376e22:	f657c1        	l32r	a12, 40374780 <_iram_text_start+0x37c>
40376e25:	f652a1        	l32r	a10, 40374770 <_iram_text_start+0x36c>
40376e28:	b1a0b2        	movi	a11, 177
40376e2b:	079e25        	call8	4037e80c <__assert_func>
    RSR(PS, ps_reg);
40376e2e:	03e6b0        	rsr.ps	a11
    return ((ps_reg & PS_INTLEVEL_MASK) == 0);
40376e31:	34b0b0        	extui	a11, a11, 0, 4
    if (!xPortCanYield()) {
40376e34:	01cb16        	beqz	a11, 40376e54 <lock_release_generic+0x44>
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376e37:	024366        	bnei	a3, 4, 40376e3d <lock_release_generic+0x2d>
            abort(); /* indicates logic bug, it shouldn't be possible to lock recursively in ISR */
40376e3a:	079425        	call8	4037e77c <abort>
        BaseType_t higher_task_woken = false;
40376e3d:	00a032        	movi	a3, 0
        xSemaphoreGiveFromISR(h, &higher_task_woken);
40376e40:	20b110        	or	a11, a1, a1
        BaseType_t higher_task_woken = false;
40376e43:	006132        	s32i	a3, a1, 0
        xSemaphoreGiveFromISR(h, &higher_task_woken);
40376e46:	03bb65        	call8	4037a9fc <xQueueGiveFromISR>
        if (higher_task_woken) {
40376e49:	0138      	l32i.n	a3, a1, 0
40376e4b:	138c      	beqz.n	a3, 40376e50 <lock_release_generic+0x40>
            portYIELD_FROM_ISR();
40376e4d:	030aa5        	call8	40379ef8 <_frxt_setup_switch>
}
40376e50:	f01d      	retw.n
40376e52:	00          	.byte 00
40376e53:	00          	.byte 00
        if (mutex_type == queueQUEUE_TYPE_RECURSIVE_MUTEX) {
40376e54:	064366        	bnei	a3, 4, 40376e5e <lock_release_generic+0x4e>
            xSemaphoreGiveRecursive(h);
40376e57:	03a5a5        	call8	4037a8b0 <xQueueGiveMutexRecursive>
40376e5a:	fffc86        	j	40376e50 <lock_release_generic+0x40>
40376e5d:	00          	.byte 00
            xSemaphoreGive(h);
40376e5e:	0bdd      	mov.n	a13, a11
40376e60:	0bcd      	mov.n	a12, a11
40376e62:	0388a5        	call8	4037a6ec <xQueueGenericSend>
40376e65:	fff9c6        	j	40376e50 <lock_release_generic+0x40>

40376e68 <_lock_close>:
void IRAM_ATTR _lock_close(_lock_t *lock) {
40376e68:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40376e6b:	f63e41        	l32r	a4, 40374764 <_iram_text_start+0x360>
40376e6e:	ffafb2        	movi	a11, -1
40376e71:	04ad      	mov.n	a10, a4
40376e73:	0573e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if (*lock) {
40376e76:	0238      	l32i.n	a3, a2, 0
40376e78:	f39c      	beqz.n	a3, 40376e9b <_lock_close+0x33>
        configASSERT(xSemaphoreGetMutexHolder(h) == NULL); /* mutex should not be held */
40376e7a:	03ad      	mov.n	a10, a3
40376e7c:	038465        	call8	4037a6c4 <xQueueGetMutexHolder>
40376e7f:	0a5d      	mov.n	a5, a10
40376e81:	da8c      	beqz.n	a10, 40376e92 <_lock_close+0x2a>
40376e83:	f640d1        	l32r	a13, 40374784 <_iram_text_start+0x380>
40376e86:	f640c1        	l32r	a12, 40374788 <_iram_text_start+0x384>
40376e89:	f639a1        	l32r	a10, 40374770 <_iram_text_start+0x36c>
40376e8c:	62a0b2        	movi	a11, 98
40376e8f:	0797e5        	call8	4037e80c <__assert_func>
        vSemaphoreDelete(h);
40376e92:	20a330        	or	a10, a3, a3
40376e95:	03eaa5        	call8	4037ad40 <vQueueDelete>
        *lock = 0;
40376e98:	006252        	s32i	a5, a2, 0
    portEXIT_CRITICAL(&lock_init_spinlock);
40376e9b:	04ad      	mov.n	a10, a4
40376e9d:	058465        	call8	4037c6e4 <vPortExitCritical>
}
40376ea0:	f01d      	retw.n
	...

40376ea4 <_lock_acquire>:
void IRAM_ATTR _lock_acquire(_lock_t *lock) {
40376ea4:	004136        	entry	a1, 32
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_MUTEX);
40376ea7:	1c0c      	movi.n	a12, 1
40376ea9:	fb7c      	movi.n	a11, -1
40376eab:	02ad      	mov.n	a10, a2
40376ead:	ffed25        	call8	40376d80 <lock_acquire_generic>
}
40376eb0:	f01d      	retw.n
	...

40376eb4 <_lock_acquire_recursive>:
void IRAM_ATTR _lock_acquire_recursive(_lock_t *lock) {
40376eb4:	004136        	entry	a1, 32
    lock_acquire_generic(lock, portMAX_DELAY, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376eb7:	4c0c      	movi.n	a12, 4
40376eb9:	fb7c      	movi.n	a11, -1
40376ebb:	02ad      	mov.n	a10, a2
40376ebd:	ffec25        	call8	40376d80 <lock_acquire_generic>
}
40376ec0:	f01d      	retw.n
	...

40376ec4 <_lock_try_acquire>:
int IRAM_ATTR _lock_try_acquire(_lock_t *lock) {
40376ec4:	004136        	entry	a1, 32
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_MUTEX);
40376ec7:	1c0c      	movi.n	a12, 1
40376ec9:	0b0c      	movi.n	a11, 0
40376ecb:	02ad      	mov.n	a10, a2
40376ecd:	ffeb25        	call8	40376d80 <lock_acquire_generic>
}
40376ed0:	0a2d      	mov.n	a2, a10
40376ed2:	f01d      	retw.n

40376ed4 <_lock_try_acquire_recursive>:
int IRAM_ATTR _lock_try_acquire_recursive(_lock_t *lock) {
40376ed4:	004136        	entry	a1, 32
    return lock_acquire_generic(lock, 0, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376ed7:	4c0c      	movi.n	a12, 4
40376ed9:	0b0c      	movi.n	a11, 0
40376edb:	02ad      	mov.n	a10, a2
40376edd:	ffea25        	call8	40376d80 <lock_acquire_generic>
}
40376ee0:	0a2d      	mov.n	a2, a10
40376ee2:	f01d      	retw.n

40376ee4 <_lock_release>:
void IRAM_ATTR _lock_release(_lock_t *lock) {
40376ee4:	004136        	entry	a1, 32
    lock_release_generic(lock, queueQUEUE_TYPE_MUTEX);
40376ee7:	01a0b2        	movi	a11, 1
40376eea:	20a220        	or	a10, a2, a2
40376eed:	fff225        	call8	40376e10 <lock_release_generic>
}
40376ef0:	000090        	retw
	...

40376ef4 <_lock_release_recursive>:
void IRAM_ATTR _lock_release_recursive(_lock_t *lock) {
40376ef4:	004136        	entry	a1, 32
    lock_release_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376ef7:	04a0b2        	movi	a11, 4
40376efa:	20a220        	or	a10, a2, a2
40376efd:	fff125        	call8	40376e10 <lock_release_generic>
}
40376f00:	000090        	retw
	...

40376f04 <__retarget_lock_init>:
{
40376f04:	004136        	entry	a1, 32
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376f07:	00a082        	movi	a8, 0
{
40376f0a:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376f0d:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_MUTEX);
40376f10:	1b0c      	movi.n	a11, 1
40376f12:	ffe2e5        	call8	40376d40 <lock_init_generic>
}
40376f15:	f01d      	retw.n
	...

40376f18 <__retarget_lock_init_recursive>:
{
40376f18:	004136        	entry	a1, 32
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376f1b:	00a082        	movi	a8, 0
{
40376f1e:	20a220        	or	a10, a2, a2
    *lock = NULL;  /* In case lock's memory is uninitialized */
40376f21:	006282        	s32i	a8, a2, 0
    lock_init_generic(lock, queueQUEUE_TYPE_RECURSIVE_MUTEX);
40376f24:	4b0c      	movi.n	a11, 4
40376f26:	ffe1a5        	call8	40376d40 <lock_init_generic>
}
40376f29:	f01d      	retw.n
	...

40376f2c <__retarget_lock_close>:
{
40376f2c:	006136        	entry	a1, 48
    _lock_close(&lock);
40376f2f:	20a110        	or	a10, a1, a1
{
40376f32:	006122        	s32i	a2, a1, 0
    _lock_close(&lock);
40376f35:	fff325        	call8	40376e68 <_lock_close>
}
40376f38:	000090        	retw
	...

40376f3c <__retarget_lock_close_recursive>:
{
40376f3c:	006136        	entry	a1, 48
    _lock_close_recursive(&lock);
40376f3f:	20a110        	or	a10, a1, a1
{
40376f42:	006122        	s32i	a2, a1, 0
    _lock_close_recursive(&lock);
40376f45:	fff225        	call8	40376e68 <_lock_close>
}
40376f48:	000090        	retw
	...

40376f4c <__retarget_lock_acquire>:

void IRAM_ATTR __retarget_lock_acquire(_LOCK_T lock)
{
40376f4c:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376f4f:	20a220        	or	a10, a2, a2
{
40376f52:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376f55:	ffe125        	call8	40376d68 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376f58:	f60d81        	l32r	a8, 4037478c <_iram_text_start+0x388>
40376f5b:	002232        	l32i	a3, a2, 0
40376f5e:	049387        	bne	a3, a8, 40376f66 <__retarget_lock_acquire+0x1a>
40376f61:	f60b31        	l32r	a3, 40374790 <_iram_text_start+0x38c>
40376f64:	0139      	s32i.n	a3, a1, 0
    _lock_acquire(&lock);
40376f66:	01ad      	mov.n	a10, a1
40376f68:	fff3a5        	call8	40376ea4 <_lock_acquire>
}
40376f6b:	f01d      	retw.n
40376f6d:	000000        	ill

40376f70 <__retarget_lock_acquire_recursive>:

void IRAM_ATTR __retarget_lock_acquire_recursive(_LOCK_T lock)
{
40376f70:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376f73:	20a220        	or	a10, a2, a2
{
40376f76:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376f79:	ffdee5        	call8	40376d68 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376f7c:	f60481        	l32r	a8, 4037478c <_iram_text_start+0x388>
40376f7f:	002232        	l32i	a3, a2, 0
40376f82:	049387        	bne	a3, a8, 40376f8a <__retarget_lock_acquire_recursive+0x1a>
40376f85:	f60331        	l32r	a3, 40374794 <_iram_text_start+0x390>
40376f88:	0139      	s32i.n	a3, a1, 0
    _lock_acquire_recursive(&lock);
40376f8a:	01ad      	mov.n	a10, a1
40376f8c:	fff265        	call8	40376eb4 <_lock_acquire_recursive>
}
40376f8f:	f01d      	retw.n
40376f91:	000000        	ill

40376f94 <__retarget_lock_try_acquire>:

int IRAM_ATTR __retarget_lock_try_acquire(_LOCK_T lock)
{
40376f94:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376f97:	20a220        	or	a10, a2, a2
{
40376f9a:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376f9d:	ffdca5        	call8	40376d68 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_mutex);
40376fa0:	f5fb81        	l32r	a8, 4037478c <_iram_text_start+0x388>
40376fa3:	002232        	l32i	a3, a2, 0
40376fa6:	049387        	bne	a3, a8, 40376fae <__retarget_lock_try_acquire+0x1a>
40376fa9:	f5f931        	l32r	a3, 40374790 <_iram_text_start+0x38c>
40376fac:	0139      	s32i.n	a3, a1, 0
    return _lock_try_acquire(&lock);
40376fae:	20a110        	or	a10, a1, a1
40376fb1:	fff125        	call8	40376ec4 <_lock_try_acquire>
}
40376fb4:	202aa0        	or	a2, a10, a10
40376fb7:	000090        	retw
	...

40376fbc <__retarget_lock_try_acquire_recursive>:

int IRAM_ATTR __retarget_lock_try_acquire_recursive(_LOCK_T lock)
{
40376fbc:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376fbf:	20a220        	or	a10, a2, a2
{
40376fc2:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376fc5:	ffda25        	call8	40376d68 <check_lock_nonzero>
    MAYBE_OVERRIDE_LOCK(lock, &s_common_recursive_mutex);
40376fc8:	f5f181        	l32r	a8, 4037478c <_iram_text_start+0x388>
40376fcb:	002232        	l32i	a3, a2, 0
40376fce:	049387        	bne	a3, a8, 40376fd6 <__retarget_lock_try_acquire_recursive+0x1a>
40376fd1:	f5f031        	l32r	a3, 40374794 <_iram_text_start+0x390>
40376fd4:	0139      	s32i.n	a3, a1, 0
    return _lock_try_acquire_recursive(&lock);
40376fd6:	20a110        	or	a10, a1, a1
40376fd9:	ffefa5        	call8	40376ed4 <_lock_try_acquire_recursive>
}
40376fdc:	202aa0        	or	a2, a10, a10
40376fdf:	000090        	retw
	...

40376fe4 <__retarget_lock_release>:

void IRAM_ATTR __retarget_lock_release(_LOCK_T lock)
{
40376fe4:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376fe7:	20a220        	or	a10, a2, a2
{
40376fea:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40376fed:	ffd7a5        	call8	40376d68 <check_lock_nonzero>
    _lock_release(&lock);
40376ff0:	01ad      	mov.n	a10, a1
40376ff2:	ffef25        	call8	40376ee4 <_lock_release>
}
40376ff5:	f01d      	retw.n
	...

40376ff8 <__retarget_lock_release_recursive>:

void IRAM_ATTR __retarget_lock_release_recursive(_LOCK_T lock)
{
40376ff8:	006136        	entry	a1, 48
    check_lock_nonzero(lock);
40376ffb:	20a220        	or	a10, a2, a2
{
40376ffe:	006122        	s32i	a2, a1, 0
    check_lock_nonzero(lock);
40377001:	ffd665        	call8	40376d68 <check_lock_nonzero>
    _lock_release_recursive(&lock);
40377004:	01ad      	mov.n	a10, a1
40377006:	ffeee5        	call8	40376ef4 <_lock_release_recursive>
}
40377009:	f01d      	retw.n
	...

4037700c <esp_reent_init>:
 * is a bit too much on a small embedded system. So we point streams
 * to the streams of the global struct _reent, which are initialized in
 * startup code.
 */
void IRAM_ATTR esp_reent_init(struct _reent* r)
{
4037700c:	004136        	entry	a1, 32
    memset(r, 0, sizeof(*r));
4037700f:	f0a0c2        	movi	a12, 240
40377012:	0b0c      	movi.n	a11, 0
40377014:	02ad      	mov.n	a10, a2
40377016:	f51781        	l32r	a8, 40374474 <_iram_text_start+0x70>
40377019:	0008e0        	callx8	a8
    r->_stdout = _GLOBAL_REENT->_stdout;
4037701c:	f5df81        	l32r	a8, 40374798 <_iram_text_start+0x394>
4037701f:	0888      	l32i.n	a8, a8, 0
40377021:	2898      	l32i.n	a9, a8, 8
40377023:	2299      	s32i.n	a9, a2, 8
    r->_stderr = _GLOBAL_REENT->_stderr;
40377025:	3898      	l32i.n	a9, a8, 12
    r->_stdin  = _GLOBAL_REENT->_stdin;
40377027:	1888      	l32i.n	a8, a8, 4
    r->_stderr = _GLOBAL_REENT->_stderr;
40377029:	3299      	s32i.n	a9, a2, 12
    r->_stdin  = _GLOBAL_REENT->_stdin;
4037702b:	1289      	s32i.n	a8, a2, 4
    r->__cleanup = &_cleanup_r;
4037702d:	f5db81        	l32r	a8, 4037479c <_iram_text_start+0x398>
40377030:	a289      	s32i.n	a8, a2, 40
    r->__sdidinit = 1;
40377032:	180c      	movi.n	a8, 1
40377034:	6289      	s32i.n	a8, a2, 24
    r->__sglue._next = NULL;
    r->__sglue._niobs = 0;
    r->__sglue._iobs = NULL;
}
40377036:	f01d      	retw.n

40377038 <_gettimeofday_r>:
    _gettimeofday_r(r, &tv, NULL);
    return (clock_t) tv.tv_sec;
}

int IRAM_ATTR _gettimeofday_r(struct _reent *r, struct timeval *tv, void *tz)
{
40377038:	004136        	entry	a1, 32
    (void) tz;

#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
4037703b:	04f316        	beqz	a3, 4037708e <_gettimeofday_r+0x56>
    _lock_acquire(&s_time_lock);
4037703e:	f5d821        	l32r	a2, 403747a0 <_iram_text_start+0x39c>
40377041:	02ad      	mov.n	a10, a2
40377043:	ffe625        	call8	40376ea4 <_lock_acquire>
    uint64_t adjust_time = adjust_boot_time();
40377046:	f5d781        	l32r	a8, 403747a4 <_iram_text_start+0x3a0>
40377049:	0008e0        	callx8	a8
4037704c:	0a4d      	mov.n	a4, a10
    _lock_release(&s_time_lock);
4037704e:	02ad      	mov.n	a10, a2
    uint64_t adjust_time = adjust_boot_time();
40377050:	0b5d      	mov.n	a5, a11
    _lock_release(&s_time_lock);
40377052:	ffe925        	call8	40376ee4 <_lock_release>
        uint64_t microseconds = get_adjusted_boot_time() + esp_time_impl_get_time_since_boot();
40377055:	f5d481        	l32r	a8, 403747a8 <_iram_text_start+0x3a4>
40377058:	0008e0        	callx8	a8
4037705b:	4a4a      	add.n	a4, a10, a4
4037705d:	120c      	movi.n	a2, 1
4037705f:	0134a7        	bltu	a4, a10, 40377064 <_gettimeofday_r+0x2c>
40377062:	020c      	movi.n	a2, 0
40377064:	bb5a      	add.n	a11, a11, a5
        tv->tv_sec = microseconds / 1000000;
40377066:	f581c1        	l32r	a12, 4037466c <_iram_text_start+0x268>
        uint64_t microseconds = get_adjusted_boot_time() + esp_time_impl_get_time_since_boot();
40377069:	22ba      	add.n	a2, a2, a11
        tv->tv_sec = microseconds / 1000000;
4037706b:	0d0c      	movi.n	a13, 0
4037706d:	20a440        	or	a10, a4, a4
40377070:	20b220        	or	a11, a2, a2
40377073:	f5bb81        	l32r	a8, 40374760 <_iram_text_start+0x35c>
40377076:	0008e0        	callx8	a8
        tv->tv_usec = microseconds % 1000000;
40377079:	f57cc1        	l32r	a12, 4037466c <_iram_text_start+0x268>
        tv->tv_sec = microseconds / 1000000;
4037707c:	03a9      	s32i.n	a10, a3, 0
4037707e:	13b9      	s32i.n	a11, a3, 4
        tv->tv_usec = microseconds % 1000000;
40377080:	0d0c      	movi.n	a13, 0
40377082:	04ad      	mov.n	a10, a4
40377084:	02bd      	mov.n	a11, a2
40377086:	f5c981        	l32r	a8, 403747ac <_iram_text_start+0x3a8>
40377089:	0008e0        	callx8	a8
4037708c:	23a9      	s32i.n	a10, a3, 8
    return 0;
#else
    __errno_r(r) = ENOSYS;
    return -1;
#endif
}
4037708e:	020c      	movi.n	a2, 0
40377090:	f01d      	retw.n
	...

40377094 <_times_r>:
{
40377094:	006136        	entry	a1, 48
    clock_t t = xTaskGetTickCount() * (portTICK_PERIOD_MS * CLK_TCK / 1000);
40377097:	0429e5        	call8	4037b334 <xTaskGetTickCount>
4037709a:	a0aaa0        	addx4	a10, a10, a10
    ptms->tms_cstime = 0;
4037709d:	00a0c2        	movi	a12, 0
    clock_t t = xTaskGetTickCount() * (portTICK_PERIOD_MS * CLK_TCK / 1000);
403770a0:	80aaa0        	add	a10, a10, a10
    ptms->tms_stime = t;
403770a3:	13a9      	s32i.n	a10, a3, 4
    ptms->tms_cstime = 0;
403770a5:	33c9      	s32i.n	a12, a3, 12
    ptms->tms_cutime = 0;
403770a7:	23c9      	s32i.n	a12, a3, 8
    ptms->tms_utime = 0;
403770a9:	03c9      	s32i.n	a12, a3, 0
    _gettimeofday_r(r, &tv, NULL);
403770ab:	01bd      	mov.n	a11, a1
403770ad:	02ad      	mov.n	a10, a2
    struct timeval tv = {0, 0};
403770af:	01c9      	s32i.n	a12, a1, 0
403770b1:	11c9      	s32i.n	a12, a1, 4
403770b3:	21c9      	s32i.n	a12, a1, 8
    _gettimeofday_r(r, &tv, NULL);
403770b5:	fff825        	call8	40377038 <_gettimeofday_r>
}
403770b8:	0128      	l32i.n	a2, a1, 0
403770ba:	f01d      	retw.n

403770bc <timer_list_lock>:
{
    return timer->alarm > 0;
}

static IRAM_ATTR void timer_list_lock(esp_timer_dispatch_t timer_type)
{
403770bc:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403770bf:	054ce5        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
403770c2:	f5bba1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac>
403770c5:	fb7c      	movi.n	a11, -1
403770c7:	b0a2a0        	addx8	a10, a2, a10
403770ca:	054e65        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    portENTER_CRITICAL_SAFE(&s_timer_lock[timer_type]);
}
403770cd:	f01d      	retw.n
	...

403770d0 <timer_insert>:
{
403770d0:	004136        	entry	a1, 32
    esp_timer_dispatch_t dispatch_method = timer->flags & FL_ISR_DISPATCH_METHOD;
403770d3:	0f02c2        	l8ui	a12, a2, 15
    if (LIST_FIRST(&s_timers[dispatch_method]) == NULL) {
403770d6:	f5b791        	l32r	a9, 403747b4 <_iram_text_start+0x3b0>
403770d9:	04c0c0        	extui	a12, a12, 0, 1
403770dc:	a0ac90        	addx4	a10, a12, a9
403770df:	002a82        	l32i	a8, a10, 0
403770e2:	11dce0        	slli	a13, a12, 2
403770e5:	013856        	bnez	a8, 403770fc <timer_insert+0x2c>
        LIST_INSERT_HEAD(&s_timers[dispatch_method], timer, list_entry);
403770e8:	066282        	s32i	a8, a2, 24
403770eb:	0a29      	s32i.n	a2, a10, 0
403770ed:	72a9      	s32i.n	a10, a2, 28
    if (without_update_alarm == false && timer == LIST_FIRST(&s_timers[dispatch_method])) {
403770ef:	53cc      	bnez.n	a3, 403770f8 <timer_insert+0x28>
        esp_timer_impl_set_alarm_id(timer->alarm, dispatch_method);
403770f1:	02a8      	l32i.n	a10, a2, 0
403770f3:	12b8      	l32i.n	a11, a2, 4
403770f5:	000de5        	call8	403771d4 <esp_timer_impl_set_alarm_id>
}
403770f8:	020c      	movi.n	a2, 0
403770fa:	f01d      	retw.n
            if (timer->alarm < it->alarm) {
403770fc:	02e8      	l32i.n	a14, a2, 0
403770fe:	12b8      	l32i.n	a11, a2, 4
40377100:	18a8      	l32i.n	a10, a8, 4
40377102:	073ba7        	bltu	a11, a10, 4037710d <timer_insert+0x3d>
40377105:	249ab7        	bne	a10, a11, 4037712d <timer_insert+0x5d>
40377108:	08a8      	l32i.n	a10, a8, 0
4037710a:	1fbea7        	bgeu	a14, a10, 4037712d <timer_insert+0x5d>
                LIST_INSERT_BEFORE(it, timer, list_entry);
4037710d:	78a8      	l32i.n	a10, a8, 28
4037710f:	6289      	s32i.n	a8, a2, 24
40377111:	72a9      	s32i.n	a10, a2, 28
40377113:	0a29      	s32i.n	a2, a10, 0
40377115:	18c2a2        	addi	a10, a2, 24
40377118:	78a9      	s32i.n	a10, a8, 28
    if (without_update_alarm == false && timer == LIST_FIRST(&s_timers[dispatch_method])) {
4037711a:	fda356        	bnez	a3, 403770f8 <timer_insert+0x28>
4037711d:	99da      	add.n	a9, a9, a13
4037711f:	0938      	l32i.n	a3, a9, 0
40377121:	d39327        	bne	a3, a2, 403770f8 <timer_insert+0x28>
40377124:	fff246        	j	403770f1 <timer_insert+0x21>
40377127:	00          	.byte 00
40377128:	0a8d      	mov.n	a8, a10
4037712a:	fff486        	j	40377100 <timer_insert+0x30>
        LIST_FOREACH(it, &s_timers[dispatch_method], list_entry) {
4037712d:	68a8      	l32i.n	a10, a8, 24
4037712f:	ff5a56        	bnez	a10, 40377128 <timer_insert+0x58>
            LIST_INSERT_AFTER(last, timer, list_entry);
40377132:	62a9      	s32i.n	a10, a2, 24
40377134:	6829      	s32i.n	a2, a8, 24
40377136:	18c882        	addi	a8, a8, 24
40377139:	7289      	s32i.n	a8, a2, 28
4037713b:	fff6c6        	j	4037711a <timer_insert+0x4a>
	...

40377140 <timer_list_unlock>:

static IRAM_ATTR void timer_list_unlock(esp_timer_dispatch_t timer_type)
{
40377140:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
40377143:	0544a5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL(mux);
40377146:	f59aa1        	l32r	a10, 403747b0 <_iram_text_start+0x3ac>
40377149:	b0a2a0        	addx8	a10, a2, a10
4037714c:	055965        	call8	4037c6e4 <vPortExitCritical>
    portEXIT_CRITICAL_SAFE(&s_timer_lock[timer_type]);
}
4037714f:	f01d      	retw.n
40377151:	000000        	ill

40377154 <timer_alarm_handler>:
    s_isr_dispatch_need_yield = pdTRUE;
}
#endif

static void IRAM_ATTR timer_alarm_handler(void* arg)
{
40377154:	006136        	entry	a1, 48
    xHigherPriorityTaskWoken = s_isr_dispatch_need_yield;
    s_isr_dispatch_need_yield = pdFALSE;
#endif

    if (isr_timers_processed == false) {
        vTaskNotifyGiveFromISR(s_timer_task, &xHigherPriorityTaskWoken);
40377157:	f59881        	l32r	a8, 403747b8 <_iram_text_start+0x3b4>
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
4037715a:	00a0b2        	movi	a11, 0
        vTaskNotifyGiveFromISR(s_timer_task, &xHigherPriorityTaskWoken);
4037715d:	0028a2        	l32i	a10, a8, 0
40377160:	01cd      	mov.n	a12, a1
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
40377162:	0061b2        	s32i	a11, a1, 0
        vTaskNotifyGiveFromISR(s_timer_task, &xHigherPriorityTaskWoken);
40377165:	04fb65        	call8	4037c11c <vTaskGenericNotifyGiveFromISR>
    }
    if (xHigherPriorityTaskWoken == pdTRUE) {
40377168:	0188      	l32i.n	a8, a1, 0
4037716a:	021866        	bnei	a8, 1, 40377170 <timer_alarm_handler+0x1c>
        portYIELD_FROM_ISR();
4037716d:	02d8a5        	call8	40379ef8 <_frxt_setup_switch>
    }
}
40377170:	f01d      	retw.n
	...

40377174 <esp_system_get_time>:
    }
#endif
}

int64_t IRAM_ATTR esp_system_get_time(void)
{
40377174:	004136        	entry	a1, 32
    return esp_timer_get_time() + s_correction_us;
40377177:	000465        	call8	403771bc <esp_timer_get_time>
4037717a:	f59031        	l32r	a3, 403747bc <_iram_text_start+0x3b8>
4037717d:	002322        	l32i	a2, a3, 0
40377180:	012382        	l32i	a8, a3, 4
40377183:	802a20        	add	a2, a10, a2
40377186:	130c      	movi.n	a3, 1
40377188:	0132a7        	bltu	a2, a10, 4037718d <esp_system_get_time+0x19>
4037718b:	030c      	movi.n	a3, 0
4037718d:	bb8a      	add.n	a11, a11, a8
}
4037718f:	33ba      	add.n	a3, a3, a11
40377191:	f01d      	retw.n
	...

40377194 <timer_alarm_isr>:
{
    esp_timer_impl_set_alarm_id(timestamp, 0);
}

static void IRAM_ATTR timer_alarm_isr(void *arg)
{
40377194:	004136        	entry	a1, 32
    // clear the interrupt
    systimer_ll_clear_alarm_int(systimer_hal.dev, SYSTIMER_LL_ALARM_CLOCK);
40377197:	f58a81        	l32r	a8, 403747c0 <_iram_text_start+0x3bc>
    dev->int_clr.val |= 1 << alarm_id;
4037719a:	4a0c      	movi.n	a10, 4
4037719c:	0898      	l32i.n	a9, a8, 0
4037719e:	0020c0        	memw
403771a1:	1b2982        	l32i	a8, a9, 108
403771a4:	2088a0        	or	a8, a8, a10
403771a7:	0020c0        	memw
403771aa:	1b6982        	s32i	a8, a9, 108
    /* Call the upper layer handler */
    (*s_alarm_handler)(arg);
403771ad:	f58581        	l32r	a8, 403747c4 <_iram_text_start+0x3c0>
403771b0:	02ad      	mov.n	a10, a2
403771b2:	002882        	l32i	a8, a8, 0
403771b5:	0008e0        	callx8	a8
}
403771b8:	f01d      	retw.n
	...

403771bc <esp_timer_get_time>:
{
403771bc:	004136        	entry	a1, 32
    return systimer_hal.ticks_to_us(systimer_hal_get_counter_value(&systimer_hal, SYSTIMER_LL_COUNTER_CLOCK));
403771bf:	f580a1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc>
403771c2:	0b0c      	movi.n	a11, 0
403771c4:	1a28      	l32i.n	a2, a10, 4
403771c6:	0679e5        	call8	4037d964 <systimer_hal_get_counter_value>
403771c9:	0002e0        	callx8	a2
}
403771cc:	0a2d      	mov.n	a2, a10
403771ce:	0b3d      	mov.n	a3, a11
403771d0:	f01d      	retw.n
	...

403771d4 <esp_timer_impl_set_alarm_id>:
{
403771d4:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
403771d7:	053b65        	call8	4037c58c <xPortInIsrContext>
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
403771da:	f57b51        	l32r	a5, 403747c8 <_iram_text_start+0x3c4>
403771dd:	fb7c      	movi.n	a11, -1
403771df:	05ad      	mov.n	a10, a5
403771e1:	053ce5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    timestamp_id[alarm_id] = timestamp;
403771e4:	f57a81        	l32r	a8, 403747cc <_iram_text_start+0x3c8>
403771e7:	b04480        	addx8	a4, a4, a8
403771ea:	0429      	s32i.n	a2, a4, 0
403771ec:	1439      	s32i.n	a3, a4, 4
    timestamp = MIN(timestamp_id[0], timestamp_id[1]);
403771ee:	1898      	l32i.n	a9, a8, 4
403771f0:	38d8      	l32i.n	a13, a8, 12
403771f2:	0848      	l32i.n	a4, a8, 0
403771f4:	0228c2        	l32i	a12, a8, 8
403771f7:	0539d7        	bltu	a9, a13, 40377200 <esp_timer_impl_set_alarm_id+0x2c>
403771fa:	079d97        	bne	a13, a9, 40377205 <esp_timer_impl_set_alarm_id+0x31>
403771fd:	04b4c7        	bgeu	a4, a12, 40377205 <esp_timer_impl_set_alarm_id+0x31>
40377200:	20c440        	or	a12, a4, a4
40377203:	09dd      	mov.n	a13, a9
    if (timestamp != UINT64_MAX) {
40377205:	020c66        	bnei	a12, -1, 4037720b <esp_timer_impl_set_alarm_id+0x37>
40377208:	070d26        	beqi	a13, -1, 40377213 <esp_timer_impl_set_alarm_id+0x3f>
        systimer_hal_set_alarm_target(&systimer_hal, SYSTIMER_LL_ALARM_CLOCK, timestamp);
4037720b:	f56da1        	l32r	a10, 403747c0 <_iram_text_start+0x3bc>
4037720e:	2b0c      	movi.n	a11, 2
40377210:	0679e5        	call8	4037d9b0 <systimer_hal_set_alarm_target>
    if (xPortInIsrContext()) {
40377213:	0537a5        	call8	4037c58c <xPortInIsrContext>
        portEXIT_CRITICAL_ISR(mux);
40377216:	20a550        	or	a10, a5, a5
40377219:	054ca5        	call8	4037c6e4 <vPortExitCritical>
}
4037721c:	f01d      	retw.n
	...

40377220 <xt_unhandled_interrupt>:

/*
  Default handler for unhandled interrupts.
*/
void IRAM_ATTR xt_unhandled_interrupt(void * arg)
{
40377220:	004136        	entry	a1, 32
40377223:	02bd      	mov.n	a11, a2
40377225:	03ebc0        	rsr.prid	a12
40377228:	04cdc0        	extui	a12, a12, 13, 1
    esp_rom_printf("Unhandled interrupt %d on cpu %d!\n", (int)arg, xPortGetCoreID());
4037722b:	f569a1        	l32r	a10, 403747d0 <_iram_text_start+0x3cc>
4037722e:	f4bc81        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40377231:	0008e0        	callx8	a8
}
40377234:	f01d      	retw.n
	...

40377238 <bootloader_flash_execute_command_common>:
    uint8_t command,
    uint32_t addr_len, uint32_t address,
    uint8_t dummy_len,
    uint8_t mosi_len, uint32_t mosi_data,
    uint8_t miso_len)
{
40377238:	004136        	entry	a1, 32
4037723b:	746060        	extui	a6, a6, 0, 8
    assert(mosi_len <= 32);
4037723e:	082c      	movi.n	a8, 32
{
40377240:	200192        	l8ui	a9, a1, 32
40377243:	742020        	extui	a2, a2, 0, 8
40377246:	745050        	extui	a5, a5, 0, 8
    assert(mosi_len <= 32);
40377249:	0eb867        	bgeu	a8, a6, 4037725b <bootloader_flash_execute_command_common+0x23>
4037724c:	f562d1        	l32r	a13, 403747d4 <_iram_text_start+0x3d0>
4037724f:	f562c1        	l32r	a12, 403747d8 <_iram_text_start+0x3d4>
40377252:	fda1b2        	movi	a11, 0x1fd
    assert(miso_len <= 32);
40377255:	f561a1        	l32r	a10, 403747dc <_iram_text_start+0x3d8>
40377258:	075b25        	call8	4037e80c <__assert_func>
4037725b:	0eb897        	bgeu	a8, a9, 4037726d <bootloader_flash_execute_command_common+0x35>
4037725e:	f560d1        	l32r	a13, 403747e0 <_iram_text_start+0x3dc>
40377261:	f55dc1        	l32r	a12, 403747d8 <_iram_text_start+0x3d4>
40377264:	fea1b2        	movi	a11, 0x1fe
40377267:	fffa86        	j	40377255 <bootloader_flash_execute_command_common+0x1d>
4037726a:	00          	.byte 00
4037726b:	00          	.byte 00
4037726c:	00          	.byte 00
    uint32_t old_ctrl_reg = SPIFLASH.ctrl.val;
4037726d:	f55d81        	l32r	a8, 403747e4 <_iram_text_start+0x3e0>
    uint32_t old_user_reg = SPIFLASH.user.val;
    uint32_t old_user1_reg = SPIFLASH.user1.val;
#if CONFIG_IDF_TARGET_ESP32
    SPIFLASH.ctrl.val = SPI_WP_REG_M; // keep WP high while idle, otherwise leave DIO mode
#else
    SPIFLASH.ctrl.val = SPI_MEM_WP_REG_M; // keep WP high while idle, otherwise leave DIO mode
40377270:	f55ea1        	l32r	a10, 403747e8 <_iram_text_start+0x3e4>
    uint32_t old_ctrl_reg = SPIFLASH.ctrl.val;
40377273:	0020c0        	memw
40377276:	28d8      	l32i.n	a13, a8, 8
    uint32_t old_user_reg = SPIFLASH.user.val;
40377278:	0020c0        	memw
4037727b:	68c8      	l32i.n	a12, a8, 24
    uint32_t old_user1_reg = SPIFLASH.user1.val;
4037727d:	0020c0        	memw
40377280:	78b8      	l32i.n	a11, a8, 28
    SPIFLASH.ctrl.val = SPI_MEM_WP_REG_M; // keep WP high while idle, otherwise leave DIO mode
40377282:	0020c0        	memw
40377285:	28a9      	s32i.n	a10, a8, 8
#endif
    //command phase
    SPIFLASH.user.usr_command = 1;
40377287:	0020c0        	memw
4037728a:	68a8      	l32i.n	a10, a8, 24
4037728c:	fe7c      	movi.n	a14, -1
4037728e:	01ee10        	slli	a14, a14, 31
40377291:	20aae0        	or	a10, a10, a14
40377294:	0020c0        	memw
40377297:	68a9      	s32i.n	a10, a8, 24
    SPIFLASH.user2.usr_command_bitlen = 7;
40377299:	0020c0        	memw
4037729c:	88a8      	l32i.n	a10, a8, 32
4037729e:	f553e1        	l32r	a14, 403747ec <_iram_text_start+0x3e8>
403772a1:	10aae0        	and	a10, a10, a14
403772a4:	7e0c      	movi.n	a14, 7
403772a6:	01ee40        	slli	a14, a14, 28
403772a9:	20aae0        	or	a10, a10, a14
403772ac:	0020c0        	memw
403772af:	88a9      	s32i.n	a10, a8, 32
    SPIFLASH.user2.usr_command_value = command;
403772b1:	0020c0        	memw
403772b4:	88a8      	l32i.n	a10, a8, 32
403772b6:	fe7c      	movi.n	a14, -1
403772b8:	11ee00        	slli	a14, a14, 16
403772bb:	10aae0        	and	a10, a10, a14
403772be:	20aa20        	or	a10, a10, a2
403772c1:	0020c0        	memw
403772c4:	88a9      	s32i.n	a10, a8, 32
    //addr phase
    SPIFLASH.user.usr_addr = addr_len > 0;
403772c6:	020c      	movi.n	a2, 0
403772c8:	1e0c      	movi.n	a14, 1
403772ca:	0020c0        	memw
403772cd:	68a8      	l32i.n	a10, a8, 24
403772cf:	83e230        	moveqz	a14, a2, a3
403772d2:	f54721        	l32r	a2, 403747f0 <_iram_text_start+0x3ec>
403772d5:	01ee20        	slli	a14, a14, 30
403772d8:	10aa20        	and	a10, a10, a2
403772db:	20aae0        	or	a10, a10, a14
403772de:	0020c0        	memw
403772e1:	68a9      	s32i.n	a10, a8, 24
    SPIFLASH.user1.usr_addr_bitlen = addr_len - 1;
403772e3:	0020c0        	memw
403772e6:	78a8      	l32i.n	a10, a8, 28
403772e8:	f51c21        	l32r	a2, 40374758 <_iram_text_start+0x354>
403772eb:	330b      	addi.n	a3, a3, -1
403772ed:	013360        	slli	a3, a3, 26
403772f0:	10aa20        	and	a10, a10, a2
403772f3:	203a30        	or	a3, a10, a3
403772f6:	0020c0        	memw
403772f9:	7839      	s32i.n	a3, a8, 28
#if CONFIG_IDF_TARGET_ESP32
    SPIFLASH.addr = (addr_len > 0)? (address << (32-addr_len)) : 0;
#else
    SPIFLASH.addr = address;
403772fb:	0020c0        	memw
403772fe:	1849      	s32i.n	a4, a8, 4
#endif
    //dummy phase
    uint32_t total_dummy = dummy_len;
    if (miso_len > 0) {
40377300:	898c      	beqz.n	a9, 4037730c <bootloader_flash_execute_command_common+0xd4>
        total_dummy += g_rom_spiflash_dummy_len_plus[1];
40377302:	f53c21        	l32r	a2, 403747f4 <_iram_text_start+0x3f0>
40377305:	0228      	l32i.n	a2, a2, 0
40377307:	190222        	l8ui	a2, a2, 25
4037730a:	552a      	add.n	a5, a5, a2
    }
    SPIFLASH.user.usr_dummy = total_dummy > 0;
4037730c:	0a0c      	movi.n	a10, 0
4037730e:	0020c0        	memw
40377311:	6838      	l32i.n	a3, a8, 24
40377313:	1e0c      	movi.n	a14, 1
40377315:	f53841        	l32r	a4, 403747f8 <_iram_text_start+0x3f4>
40377318:	0a2d      	mov.n	a2, a10
4037731a:	932e50        	movnez	a2, a14, a5
4037731d:	012230        	slli	a2, a2, 29
40377320:	103340        	and	a3, a3, a4
40377323:	203320        	or	a3, a3, a2
40377326:	0020c0        	memw
40377329:	6839      	s32i.n	a3, a8, 24
    SPIFLASH.user1.usr_dummy_cyclelen = total_dummy - 1;
4037732b:	0020c0        	memw
4037732e:	7838      	l32i.n	a3, a8, 28
40377330:	c0af22        	movi	a2, -64
40377333:	550b      	addi.n	a5, a5, -1
40377335:	103320        	and	a3, a3, a2
40377338:	545050        	extui	a5, a5, 0, 6
4037733b:	203350        	or	a3, a3, a5
4037733e:	0020c0        	memw
40377341:	7839      	s32i.n	a3, a8, 28
    //output data
    SPIFLASH.user.usr_mosi = mosi_len > 0;
40377343:	0020c0        	memw
40377346:	6838      	l32i.n	a3, a8, 24
40377348:	f52d21        	l32r	a2, 403747fc <_iram_text_start+0x3f8>
4037734b:	83ea60        	moveqz	a14, a10, a6
4037734e:	01ee50        	slli	a14, a14, 27
40377351:	103320        	and	a3, a3, a2
40377354:	2033e0        	or	a3, a3, a14
40377357:	0020c0        	memw
4037735a:	6839      	s32i.n	a3, a8, 24
#if CONFIG_IDF_TARGET_ESP32
    SPIFLASH.mosi_dlen.usr_mosi_dbitlen = mosi_len ? (mosi_len - 1) : 0;
#else
    SPIFLASH.mosi_dlen.usr_mosi_bit_len = mosi_len ? (mosi_len - 1) : 0;
4037735c:	0416a7        	beq	a6, a10, 40377364 <bootloader_flash_execute_command_common+0x12c>
4037735f:	660b      	addi.n	a6, a6, -1
40377361:	94a060        	extui	a10, a6, 0, 10
40377364:	0020c0        	memw
40377367:	9838      	l32i.n	a3, a8, 36
40377369:	00ac22        	movi	a2, 0xfffffc00
4037736c:	103320        	and	a3, a3, a2
4037736f:	2033a0        	or	a3, a3, a10
40377372:	0020c0        	memw
40377375:	9839      	s32i.n	a3, a8, 36
#endif
    SPIFLASH.data_buf[0] = mosi_data;
40377377:	0020c0        	memw
4037737a:	166872        	s32i	a7, a8, 88
    //input data
    SPIFLASH.user.usr_miso = miso_len > 0;
4037737d:	0020c0        	memw
40377380:	6838      	l32i.n	a3, a8, 24
40377382:	f51f21        	l32r	a2, 40374800 <_iram_text_start+0x3fc>
40377385:	050c      	movi.n	a5, 0
40377387:	01a042        	movi	a4, 1
4037738a:	834590        	moveqz	a4, a5, a9
4037738d:	014440        	slli	a4, a4, 28
40377390:	103320        	and	a3, a3, a2
40377393:	203340        	or	a3, a3, a4
40377396:	0020c0        	memw
40377399:	6839      	s32i.n	a3, a8, 24
#if CONFIG_IDF_TARGET_ESP32
    SPIFLASH.miso_dlen.usr_miso_dbitlen = miso_len ? (miso_len - 1) : 0;
#else
    SPIFLASH.miso_dlen.usr_miso_bit_len = miso_len ? (miso_len - 1) : 0;
4037739b:	051957        	beq	a9, a5, 403773a4 <bootloader_flash_execute_command_common+0x16c>
4037739e:	ffc952        	addi	a5, a9, -1
403773a1:	945050        	extui	a5, a5, 0, 10
403773a4:	0020c0        	memw
403773a7:	a838      	l32i.n	a3, a8, 40
403773a9:	00ac22        	movi	a2, 0xfffffc00
403773ac:	103320        	and	a3, a3, a2
403773af:	203350        	or	a3, a3, a5
403773b2:	0020c0        	memw
403773b5:	a839      	s32i.n	a3, a8, 40
#endif

    SPIFLASH.cmd.usr = 1;
403773b7:	0020c0        	memw
403773ba:	0828      	l32i.n	a2, a8, 0
403773bc:	130c      	movi.n	a3, 1
403773be:	0133e0        	slli	a3, a3, 18
403773c1:	202230        	or	a2, a2, a3
403773c4:	0020c0        	memw
403773c7:	0829      	s32i.n	a2, a8, 0
    while (SPIFLASH.cmd.usr != 0) {
403773c9:	0020c0        	memw
403773cc:	0828      	l32i.n	a2, a8, 0
403773ce:	f7f227        	bbsi	a2, 18, 403773c9 <bootloader_flash_execute_command_common+0x191>
    }
    SPIFLASH.ctrl.val = old_ctrl_reg;
403773d1:	0020c0        	memw
403773d4:	28d9      	s32i.n	a13, a8, 8
    SPIFLASH.user.val = old_user_reg;
403773d6:	0020c0        	memw
403773d9:	68c9      	s32i.n	a12, a8, 24
    SPIFLASH.user1.val = old_user1_reg;
403773db:	0020c0        	memw
403773de:	78b9      	s32i.n	a11, a8, 28

    uint32_t ret = SPIFLASH.data_buf[0];
403773e0:	0020c0        	memw
403773e3:	162822        	l32i	a2, a8, 88
    if (miso_len < 32) {
403773e6:	0ec926        	beqi	a9, 32, 403773f8 <bootloader_flash_execute_command_common+0x1c0>
        //set unused bits to 0
        ret &= ~(UINT32_MAX << miso_len);
403773e9:	ffaf32        	movi	a3, -1
403773ec:	401900        	ssl	a9
403773ef:	a18300        	sll	a8, a3
403773f2:	303380        	xor	a3, a3, a8
403773f5:	102230        	and	a2, a2, a3
    }
    return ret;
}
403773f8:	f01d      	retw.n
	...

403773fc <bootloader_execute_flash_command>:

uint32_t IRAM_ATTR bootloader_execute_flash_command(uint8_t command, uint32_t mosi_data, uint8_t mosi_len, uint8_t miso_len)
{
403773fc:	006136        	entry	a1, 48
    const uint8_t addr_len = 0;
    const uint8_t address = 0;
    const uint8_t dummy_len = 0;

    return bootloader_flash_execute_command_common(command, addr_len, address,
403773ff:	00a0d2        	movi	a13, 0
{
40377402:	745050        	extui	a5, a5, 0, 8
    return bootloader_flash_execute_command_common(command, addr_len, address,
40377405:	006152        	s32i	a5, a1, 0
40377408:	20f330        	or	a15, a3, a3
4037740b:	74e040        	extui	a14, a4, 0, 8
4037740e:	0dcd      	mov.n	a12, a13
40377410:	0dbd      	mov.n	a11, a13
40377412:	74a020        	extui	a10, a2, 0, 8
40377415:	ffe225        	call8	40377238 <bootloader_flash_execute_command_common>
            dummy_len, mosi_len, mosi_data, miso_len);
}
40377418:	0a2d      	mov.n	a2, a10
4037741a:	f01d      	retw.n

4037741c <bootloader_flash_read_sfdp>:

// cmd(0x5A) + 24bit address + 8 cycles dummy
uint32_t IRAM_ATTR bootloader_flash_read_sfdp(uint32_t sfdp_addr, unsigned int miso_byte_num)
{
4037741c:	006136        	entry	a1, 48
4037741f:	20c220        	or	a12, a2, a2
    assert(miso_byte_num <= 4);
40377422:	0e53b6        	bltui	a3, 5, 40377434 <bootloader_flash_read_sfdp+0x18>
40377425:	f4f7d1        	l32r	a13, 40374804 <_iram_text_start+0x400>
40377428:	f4f8c1        	l32r	a12, 40374808 <_iram_text_start+0x404>
4037742b:	f4eca1        	l32r	a10, 403747dc <_iram_text_start+0x3d8>
4037742e:	46a2b2        	movi	a11, 0x246
40377431:	073da5        	call8	4037e80c <__assert_func>
    const uint8_t command = CMD_RDSFDP;
    const uint8_t addr_len = 24;
    const uint8_t dummy_len = 8;
    const uint8_t mosi_len = 0;
    const uint32_t mosi_data = 0;
    const uint8_t miso_len = miso_byte_num * 8;
40377434:	1133d0        	slli	a3, a3, 3

    return bootloader_flash_execute_command_common(command, addr_len, sfdp_addr,
40377437:	00a0f2        	movi	a15, 0
4037743a:	743030        	extui	a3, a3, 0, 8
4037743d:	0139      	s32i.n	a3, a1, 0
4037743f:	0fed      	mov.n	a14, a15
40377441:	8d0c      	movi.n	a13, 8
40377443:	8b1c      	movi.n	a11, 24
40377445:	aa5c      	movi.n	a10, 90
40377447:	ffdf25        	call8	40377238 <bootloader_flash_execute_command_common>
            dummy_len, mosi_len, mosi_data, miso_len);
}
4037744a:	0a2d      	mov.n	a2, a10
4037744c:	f01d      	retw.n
	...

40377450 <bootloader_read_flash_id>:
{
    bootloader_execute_flash_command(CMD_WRDI, 0, 0, 0);   /* Exit OTP mode */
}

uint32_t IRAM_ATTR bootloader_read_flash_id(void)
{
40377450:	004136        	entry	a1, 32
    uint32_t id = bootloader_execute_flash_command(CMD_RDID, 0, 0, 24);
40377453:	0c0c      	movi.n	a12, 0
40377455:	8d1c      	movi.n	a13, 24
40377457:	20bcc0        	or	a11, a12, a12
4037745a:	9fa0a2        	movi	a10, 159
4037745d:	fff9e5        	call8	403773fc <bootloader_execute_flash_command>
    id = ((id & 0xff) << 16) | ((id >> 16) & 0xff) | (id & 0xff00);
40377460:	ffa082        	movi	a8, 255
40377463:	112a00        	slli	a2, a10, 16
40377466:	118800        	slli	a8, a8, 16
40377469:	102280        	and	a2, a2, a8
4037746c:	7580a0        	extui	a8, a10, 16, 8
4037746f:	202280        	or	a2, a2, a8
40377472:	ffa082        	movi	a8, 255
40377475:	118880        	slli	a8, a8, 8
40377478:	10aa80        	and	a10, a10, a8
    return id;
}
4037747b:	2022a0        	or	a2, a2, a10
4037747e:	f01d      	retw.n

40377480 <bootloader_flash_reset_chip>:
    SPIMEM0.ctrl2.sync_reset = 0;
#endif
}

esp_err_t IRAM_ATTR bootloader_flash_reset_chip(void)
{
40377480:	004136        	entry	a1, 32
    SPIMEM1.ctrl2.sync_reset = 0;
40377483:	f4d831        	l32r	a3, 403747e4 <_iram_text_start+0x3e0>
40377486:	f4e191        	l32r	a9, 4037480c <_iram_text_start+0x408>
40377489:	0020c0        	memw
4037748c:	042382        	l32i	a8, a3, 16
    bootloader_mspi_reset();
    // Seems that sync_reset cannot make host totally idle.'
    // Sending an extra(useless) command to make the host idle in order to send reset command.
    bootloader_execute_flash_command(0x05, 0, 0, 0);
4037748f:	0d0c      	movi.n	a13, 0
    SPIMEM1.ctrl2.sync_reset = 0;
40377491:	108890        	and	a8, a8, a9
40377494:	0020c0        	memw
40377497:	4389      	s32i.n	a8, a3, 16
    SPIMEM0.ctrl2.sync_reset = 0;
40377499:	f4dd81        	l32r	a8, 40374810 <_iram_text_start+0x40c>
    bootloader_execute_flash_command(0x05, 0, 0, 0);
4037749c:	0dcd      	mov.n	a12, a13
    SPIMEM0.ctrl2.sync_reset = 0;
4037749e:	0020c0        	memw
403774a1:	48a8      	l32i.n	a10, a8, 16
    if (SPIMEM1.fsm.st != 0)
#else
    if (SPIMEM1.fsm.spi0_mst_st != 0)
#endif
    {
        return ESP_FAIL;
403774a3:	f27c      	movi.n	a2, -1
    SPIMEM0.ctrl2.sync_reset = 0;
403774a5:	10aa90        	and	a10, a10, a9
403774a8:	0020c0        	memw
403774ab:	48a9      	s32i.n	a10, a8, 16
    SPIMEM1.ctrl2.sync_reset = 1;
403774ad:	0020c0        	memw
403774b0:	43b8      	l32i.n	a11, a3, 16
403774b2:	fa7c      	movi.n	a10, -1
403774b4:	01aa10        	slli	a10, a10, 31
403774b7:	20bba0        	or	a11, a11, a10
403774ba:	0020c0        	memw
403774bd:	43b9      	s32i.n	a11, a3, 16
    SPIMEM0.ctrl2.sync_reset = 1;
403774bf:	0020c0        	memw
403774c2:	48b8      	l32i.n	a11, a8, 16
403774c4:	20aba0        	or	a10, a11, a10
403774c7:	0020c0        	memw
403774ca:	48a9      	s32i.n	a10, a8, 16
    SPIMEM1.ctrl2.sync_reset = 0;
403774cc:	0020c0        	memw
403774cf:	43a8      	l32i.n	a10, a3, 16
    bootloader_execute_flash_command(0x05, 0, 0, 0);
403774d1:	0dbd      	mov.n	a11, a13
    SPIMEM1.ctrl2.sync_reset = 0;
403774d3:	10aa90        	and	a10, a10, a9
403774d6:	0020c0        	memw
403774d9:	43a9      	s32i.n	a10, a3, 16
    SPIMEM0.ctrl2.sync_reset = 0;
403774db:	0020c0        	memw
403774de:	48a8      	l32i.n	a10, a8, 16
403774e0:	109a90        	and	a9, a10, a9
403774e3:	0020c0        	memw
403774e6:	046892        	s32i	a9, a8, 16
    bootloader_execute_flash_command(0x05, 0, 0, 0);
403774e9:	5a0c      	movi.n	a10, 5
403774eb:	fff125        	call8	403773fc <bootloader_execute_flash_command>
    if (SPIMEM1.fsm.st != 0)
403774ee:	0020c0        	memw
403774f1:	152332        	l32i	a3, a3, 84
403774f4:	243030        	extui	a3, a3, 0, 3
403774f7:	93dc      	bnez.n	a3, 40377514 <bootloader_flash_reset_chip+0x94>
    }
    bootloader_execute_flash_command(0x66, 0, 0, 0);
403774f9:	03dd      	mov.n	a13, a3
403774fb:	03cd      	mov.n	a12, a3
403774fd:	03bd      	mov.n	a11, a3
403774ff:	66a0a2        	movi	a10, 102
40377502:	ffefa5        	call8	403773fc <bootloader_execute_flash_command>
    bootloader_execute_flash_command(0x99, 0, 0, 0);
40377505:	03dd      	mov.n	a13, a3
40377507:	03cd      	mov.n	a12, a3
40377509:	20b330        	or	a11, a3, a3
4037750c:	99a0a2        	movi	a10, 153
4037750f:	ffeee5        	call8	403773fc <bootloader_execute_flash_command>

    return ESP_OK;
40377512:	032d      	mov.n	a2, a3
}
40377514:	f01d      	retw.n
	...

40377518 <esp_flash_encryption_enabled>:
 * would require the caller component to include `efuse` as part of its `REQUIRES` or
 * `PRIV_REQUIRES` entries.
 * Attribute IRAM_ATTR must be specified for the app build.
 */
bool IRAM_ATTR esp_flash_encryption_enabled(void)
{
40377518:	004136        	entry	a1, 32

/******************* eFuse fields *************************/

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_flash_crypt_cnt(void)
{
    return EFUSE.rd_repeat_data1.reg_spi_boot_crypt_cnt;
4037751b:	f4be21        	l32r	a2, 40374814 <_iram_text_start+0x410>
#endif
    /* __builtin_parity is in flash, so we calculate parity inline */
    bool enabled = false;
    while (flash_crypt_cnt) {
        if (flash_crypt_cnt & 1) {
            enabled = !enabled;
4037751e:	190c      	movi.n	a9, 1
40377520:	0020c0        	memw
40377523:	d288      	l32i.n	a8, a2, 52
    bool enabled = false;
40377525:	020c      	movi.n	a2, 0
40377527:	258280        	extui	a8, a8, 18, 3
    while (flash_crypt_cnt) {
4037752a:	28cc      	bnez.n	a8, 40377530 <esp_flash_encryption_enabled+0x18>
        }
        flash_crypt_cnt >>= 1;
    }
    return enabled;
}
4037752c:	f01d      	retw.n
4037752e:	00          	.byte 00
4037752f:	00          	.byte 00
        if (flash_crypt_cnt & 1) {
40377530:	056807        	bbci	a8, 0, 40377539 <esp_flash_encryption_enabled+0x21>
            enabled = !enabled;
40377533:	302290        	xor	a2, a2, a9
40377536:	742020        	extui	a2, a2, 0, 8
        flash_crypt_cnt >>= 1;
40377539:	418180        	srli	a8, a8, 1
4037753c:	fffa86        	j	4037752a <esp_flash_encryption_enabled+0x12>
	...

40377540 <spi_flash_disable_cache$constprop$0>:
/**
 * The following two functions are replacements for Cache_Read_Disable and Cache_Read_Enable
 * function in ROM. They are used to work around a bug where Cache_Read_Disable requires a call to
 * Cache_Flush before Cache_Read_Enable, even if cached data was not modified.
 */
static void IRAM_ATTR spi_flash_disable_cache(uint32_t cpuid, uint32_t *saved_state)
40377540:	004136        	entry	a1, 32
    *saved_state = ret;
#elif CONFIG_IDF_TARGET_ESP32S2
    *saved_state = Cache_Suspend_ICache();
#elif CONFIG_IDF_TARGET_ESP32S3
    uint32_t icache_state, dcache_state;
    icache_state = Cache_Suspend_ICache() << 16;
40377543:	f4b581        	l32r	a8, 40374818 <_iram_text_start+0x414>
40377546:	0008e0        	callx8	a8
40377549:	0a3d      	mov.n	a3, a10
    dcache_state = Cache_Suspend_DCache();
4037754b:	f3cc81        	l32r	a8, 4037447c <_iram_text_start+0x78>
4037754e:	0008e0        	callx8	a8
    icache_state = Cache_Suspend_ICache() << 16;
40377551:	118300        	slli	a8, a3, 16
    *saved_state = icache_state | dcache_state;
40377554:	20a8a0        	or	a10, a8, a10
40377557:	02a9      	s32i.n	a10, a2, 0
#elif CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    uint32_t icache_state;
    icache_state = Cache_Suspend_ICache() << 16;
    *saved_state = icache_state;
#endif
}
40377559:	f01d      	retw.n
	...

4037755c <spi_flash_restore_cache$constprop$0>:

static void IRAM_ATTR spi_flash_restore_cache(uint32_t cpuid, uint32_t saved_state)
4037755c:	004136        	entry	a1, 32
    }
#endif
#elif CONFIG_IDF_TARGET_ESP32S2
    Cache_Resume_ICache(saved_state);
#elif CONFIG_IDF_TARGET_ESP32S3
    Cache_Resume_DCache(saved_state & 0xffff);
4037755f:	f4a020        	extui	a10, a2, 0, 16
40377562:	f3c881        	l32r	a8, 40374484 <_iram_text_start+0x80>
40377565:	0008e0        	callx8	a8
    Cache_Resume_ICache(saved_state >> 16);
40377568:	f5a020        	extui	a10, a2, 16, 16
4037756b:	f4ac81        	l32r	a8, 4037481c <_iram_text_start+0x418>
4037756e:	0008e0        	callx8	a8
#elif CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    Cache_Resume_ICache(saved_state >> 16);
#endif
}
40377571:	f01d      	retw.n
	...

40377574 <spi_flash_op_block_func>:
{
40377574:	004136        	entry	a1, 32
    vTaskSuspendAll();
40377577:	03d965        	call8	4037b30c <vTaskSuspendAll>
    esp_intr_noniram_disable();
4037757a:	fea9e5        	call8	40376018 <esp_intr_noniram_disable>
    s_flash_op_complete = false;
4037757d:	f4a891        	l32r	a9, 40374820 <_iram_text_start+0x41c>
40377580:	00a082        	movi	a8, 0
40377583:	0020c0        	memw
40377586:	004982        	s8i	a8, a9, 0
    s_flash_op_can_start = true;
40377589:	f4a681        	l32r	a8, 40374824 <_iram_text_start+0x420>
4037758c:	01a0a2        	movi	a10, 1
4037758f:	0020c0        	memw
40377592:	0048a2        	s8i	a10, a8, 0
    while (!s_flash_op_complete) {
40377595:	0020c0        	memw
40377598:	000982        	l8ui	a8, a9, 0
4037759b:	748080        	extui	a8, a8, 0, 8
4037759e:	ff3816        	beqz	a8, 40377595 <spi_flash_op_block_func+0x21>
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
403775a1:	f4a181        	l32r	a8, 40374828 <_iram_text_start+0x424>
403775a4:	a02280        	addx4	a2, a2, a8
403775a7:	0022a2        	l32i	a10, a2, 0
403775aa:	fffb25        	call8	4037755c <spi_flash_restore_cache$constprop$0>
    esp_intr_noniram_enable();
403775ad:	feac25        	call8	40376070 <esp_intr_noniram_enable>
    xTaskResumeAll();
403775b0:	03f465        	call8	4037b4f8 <xTaskResumeAll>
}
403775b3:	000090        	retw
	...

403775b8 <spi_flash_disable_interrupts_caches_and_other_cpu>:
{
403775b8:	006136        	entry	a1, 48
    asm volatile ("mov %0, sp;" : "=r" (sp));
403775bb:	202110        	or	a2, a1, a1
    return ((intptr_t)p >= SOC_DRAM_LOW && (intptr_t)p < SOC_DRAM_HIGH);
403775be:	f41631        	l32r	a3, 40374618 <_iram_text_start+0x214>
        || esp_ptr_in_rtc_dram_fast(sp)
403775c1:	f49a41        	l32r	a4, 4037482c <_iram_text_start+0x428>
403775c4:	803230        	add	a3, a2, a3
403775c7:	1ab437        	bgeu	a4, a3, 403775e5 <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    return ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403775ca:	f3f631        	l32r	a3, 403745a4 <_iram_text_start+0x1a0>
403775cd:	802230        	add	a2, a2, a3
403775d0:	f3f631        	l32r	a3, 403745a8 <_iram_text_start+0x1a4>
403775d3:	0eb327        	bgeu	a3, a2, 403775e5 <spi_flash_disable_interrupts_caches_and_other_cpu+0x2d>
    assert(esp_task_stack_is_sane_cache_disabled());
403775d6:	f496d1        	l32r	a13, 40374830 <_iram_text_start+0x42c>
403775d9:	f496c1        	l32r	a12, 40374834 <_iram_text_start+0x430>
403775dc:	98a0b2        	movi	a11, 152
    assert(s_flash_op_cpu == -1);
403775df:	f496a1        	l32r	a10, 40374838 <_iram_text_start+0x434>
403775e2:	0722a5        	call8	4037e80c <__assert_func>
    spi_flash_op_lock();
403775e5:	f49c81        	l32r	a8, 40374858 <_iram_text_start+0x454>
403775e8:	0008e0        	callx8	a8
    asm volatile (
403775eb:	03eb30        	rsr.prid	a3
403775ee:	043d30        	extui	a3, a3, 13, 1
    assert(s_flash_op_cpu == -1);
403775f1:	f49241        	l32r	a4, 4037483c <_iram_text_start+0x438>
    const uint32_t other_cpuid = (cpuid == 0) ? 1 : 0;
403775f4:	050c      	movi.n	a5, 0
    assert(s_flash_op_cpu == -1);
403775f6:	0020c0        	memw
403775f9:	0488      	l32i.n	a8, a4, 0
    const uint32_t other_cpuid = (cpuid == 0) ? 1 : 0;
403775fb:	120c      	movi.n	a2, 1
403775fd:	932530        	movnez	a2, a5, a3
    assert(s_flash_op_cpu == -1);
40377600:	0d0826        	beqi	a8, -1, 40377611 <spi_flash_disable_interrupts_caches_and_other_cpu+0x59>
40377603:	f48fd1        	l32r	a13, 40374840 <_iram_text_start+0x43c>
40377606:	f48bc1        	l32r	a12, 40374834 <_iram_text_start+0x430>
40377609:	a0a0b2        	movi	a11, 160
4037760c:	fff3c6        	j	403775df <spi_flash_disable_interrupts_caches_and_other_cpu+0x27>
4037760f:	00          	.byte 00
40377610:	00          	.byte 00
    s_flash_op_cpu = cpuid;
40377611:	0020c0        	memw
40377614:	0439      	s32i.n	a3, a4, 0
    if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED) {
40377616:	046625        	call8	4037bc78 <xTaskGetSchedulerState>
40377619:	111a66        	bnei	a10, 1, 4037762e <spi_flash_disable_interrupts_caches_and_other_cpu+0x76>
        assert(other_cpuid == 1);
4037761c:	065316        	beqz	a3, 40377685 <spi_flash_disable_interrupts_caches_and_other_cpu+0xcd>
4037761f:	f489d1        	l32r	a13, 40374844 <_iram_text_start+0x440>
40377622:	f484c1        	l32r	a12, 40374834 <_iram_text_start+0x430>
40377625:	aaa0b2        	movi	a11, 170
40377628:	ffecc6        	j	403775df <spi_flash_disable_interrupts_caches_and_other_cpu+0x27>
4037762b:	00          	.byte 00
4037762c:	00          	.byte 00
4037762d:	00          	.byte 00
        prvTaskPriorityRaise(&SavedPriority, configMAX_PRIORITIES - 1);
4037762e:	8b1c      	movi.n	a11, 24
40377630:	01ad      	mov.n	a10, a1
40377632:	04c465        	call8	4037c278 <prvTaskPriorityRaise>
        ESP_ERROR_CHECK(esp_ipc_call(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid));
40377635:	f484b1        	l32r	a11, 40374848 <_iram_text_start+0x444>
        s_flash_op_can_start = false;
40377638:	f47b41        	l32r	a4, 40374824 <_iram_text_start+0x420>
        ESP_ERROR_CHECK(esp_ipc_call(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid));
4037763b:	02cd      	mov.n	a12, a2
4037763d:	02ad      	mov.n	a10, a2
        s_flash_op_can_start = false;
4037763f:	0020c0        	memw
40377642:	004452        	s8i	a5, a4, 0
        ESP_ERROR_CHECK(esp_ipc_call(other_cpuid, &spi_flash_op_block_func, (void *) other_cpuid));
40377645:	f48581        	l32r	a8, 4037485c <_iram_text_start+0x458>
40377648:	0008e0        	callx8	a8
4037764b:	da8c      	beqz.n	a10, 4037765c <spi_flash_disable_interrupts_caches_and_other_cpu+0xa4>
4037764d:	f47fe1        	l32r	a14, 4037484c <_iram_text_start+0x448>
40377650:	f479d1        	l32r	a13, 40374834 <_iram_text_start+0x430>
40377653:	f47fb1        	l32r	a11, 40374850 <_iram_text_start+0x44c>
40377656:	b4a0c2        	movi	a12, 180
40377659:	028625        	call8	40379ebc <_esp_error_check_failed>
        while (!s_flash_op_can_start) {
4037765c:	0020c0        	memw
4037765f:	000482        	l8ui	a8, a4, 0
40377662:	748080        	extui	a8, a8, 0, 8
40377665:	ff3816        	beqz	a8, 4037765c <spi_flash_disable_interrupts_caches_and_other_cpu+0xa4>
        vTaskSuspendAll();
40377668:	03ca25        	call8	4037b30c <vTaskSuspendAll>
        prvTaskPriorityRestore(&SavedPriority);
4037766b:	01ad      	mov.n	a10, a1
4037766d:	04c925        	call8	4037c300 <prvTaskPriorityRestore>
40377670:	03eb40        	rsr.prid	a4
40377673:	044d40        	extui	a4, a4, 13, 1
        assert(xPortGetCoreID() == cpuid);
40377676:	0b1347        	beq	a3, a4, 40377685 <spi_flash_disable_interrupts_caches_and_other_cpu+0xcd>
40377679:	f476d1        	l32r	a13, 40374854 <_iram_text_start+0x450>
4037767c:	f46ec1        	l32r	a12, 40374834 <_iram_text_start+0x430>
4037767f:	c5a0b2        	movi	a11, 197
40377682:	ffd646        	j	403775df <spi_flash_disable_interrupts_caches_and_other_cpu+0x27>
    esp_intr_noniram_disable();
40377685:	fe9925        	call8	40376018 <esp_intr_noniram_disable>
    spi_flash_disable_cache(cpuid, &s_flash_op_cache_state[cpuid]);
40377688:	f46841        	l32r	a4, 40374828 <_iram_text_start+0x424>
4037768b:	a0a340        	addx4	a10, a3, a4
4037768e:	ffeb25        	call8	40377540 <spi_flash_disable_cache$constprop$0>
    spi_flash_disable_cache(other_cpuid, &s_flash_op_cache_state[other_cpuid]);
40377691:	a0a240        	addx4	a10, a2, a4
40377694:	ffeaa5        	call8	40377540 <spi_flash_disable_cache$constprop$0>
}
40377697:	000090        	retw
	...

4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>:
{
4037769c:	004136        	entry	a1, 32
4037769f:	03eb30        	rsr.prid	a3
403776a2:	043d30        	extui	a3, a3, 13, 1
    const uint32_t other_cpuid = (cpuid == 0) ? 1 : 0;
403776a5:	00a042        	movi	a4, 0
403776a8:	01a022        	movi	a2, 1
403776ab:	932430        	movnez	a2, a4, a3
    assert(cpuid == s_flash_op_cpu);
403776ae:	f46341        	l32r	a4, 4037483c <_iram_text_start+0x438>
403776b1:	0020c0        	memw
403776b4:	002452        	l32i	a5, a4, 0
403776b7:	0e1537        	beq	a5, a3, 403776c9 <spi_flash_enable_interrupts_caches_and_other_cpu+0x2d>
403776ba:	f469d1        	l32r	a13, 40374860 <_iram_text_start+0x45c>
403776bd:	f469c1        	l32r	a12, 40374864 <_iram_text_start+0x460>
403776c0:	d7a0b2        	movi	a11, 215
    assert(!(xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED && cpuid != 0));
403776c3:	f45da1        	l32r	a10, 40374838 <_iram_text_start+0x434>
403776c6:	071465        	call8	4037e80c <__assert_func>
403776c9:	045ae5        	call8	4037bc78 <xTaskGetSchedulerState>
403776cc:	059c      	beqz.n	a5, 403776e0 <spi_flash_enable_interrupts_caches_and_other_cpu+0x44>
403776ce:	0e1a66        	bnei	a10, 1, 403776e0 <spi_flash_enable_interrupts_caches_and_other_cpu+0x44>
403776d1:	f465d1        	l32r	a13, 40374868 <_iram_text_start+0x464>
403776d4:	f464c1        	l32r	a12, 40374864 <_iram_text_start+0x460>
403776d7:	d9a0b2        	movi	a11, 217
403776da:	fff946        	j	403776c3 <spi_flash_enable_interrupts_caches_and_other_cpu+0x27>
403776dd:	00          	.byte 00
403776de:	00          	.byte 00
403776df:	00          	.byte 00
    s_flash_op_cpu = -1;
403776e0:	ffaf52        	movi	a5, -1
403776e3:	0020c0        	memw
403776e6:	0459      	s32i.n	a5, a4, 0
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
403776e8:	f45041        	l32r	a4, 40374828 <_iram_text_start+0x424>
403776eb:	a03340        	addx4	a3, a3, a4
403776ee:	03a8      	l32i.n	a10, a3, 0
    spi_flash_restore_cache(other_cpuid, s_flash_op_cache_state[other_cpuid]);
403776f0:	a02240        	addx4	a2, a2, a4
    spi_flash_restore_cache(cpuid, s_flash_op_cache_state[cpuid]);
403776f3:	ffe6a5        	call8	4037755c <spi_flash_restore_cache$constprop$0>
    spi_flash_restore_cache(other_cpuid, s_flash_op_cache_state[other_cpuid]);
403776f6:	02a8      	l32i.n	a10, a2, 0
403776f8:	ffe625        	call8	4037755c <spi_flash_restore_cache$constprop$0>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
403776fb:	0457e5        	call8	4037bc78 <xTaskGetSchedulerState>
403776fe:	0a1a26        	beqi	a10, 1, 4037770c <spi_flash_enable_interrupts_caches_and_other_cpu+0x70>
        s_flash_op_complete = true;
40377701:	f44721        	l32r	a2, 40374820 <_iram_text_start+0x41c>
40377704:	130c      	movi.n	a3, 1
40377706:	0020c0        	memw
40377709:	004232        	s8i	a3, a2, 0
    esp_intr_noniram_enable();
4037770c:	201110        	or	a1, a1, a1
4037770f:	fe9625        	call8	40376070 <esp_intr_noniram_enable>
    if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
40377712:	201110        	or	a1, a1, a1
40377715:	045625        	call8	4037bc78 <xTaskGetSchedulerState>
40377718:	051a26        	beqi	a10, 1, 40377721 <spi_flash_enable_interrupts_caches_and_other_cpu+0x85>
        xTaskResumeAll();
4037771b:	201110        	or	a1, a1, a1
4037771e:	03dda5        	call8	4037b4f8 <xTaskResumeAll>
    spi_flash_op_unlock();
40377721:	f45281        	l32r	a8, 4037486c <_iram_text_start+0x468>
40377724:	0008e0        	callx8	a8
}
40377727:	f01d      	retw.n
40377729:	000000        	ill

4037772c <spi_flash_cache_enabled>:

IRAM_ATTR bool spi_flash_cache_enabled(void)
{
4037772c:	004136        	entry	a1, 32
    result = result && (DPORT_REG_GET_BIT(DPORT_APP_CACHE_CTRL_REG, DPORT_APP_CACHE_ENABLE) != 0);
#endif
#elif CONFIG_IDF_TARGET_ESP32S2
    bool result = (REG_GET_BIT(EXTMEM_PRO_ICACHE_CTRL_REG, EXTMEM_PRO_ICACHE_ENABLE) != 0);
#elif CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    bool result = (REG_GET_BIT(EXTMEM_ICACHE_CTRL_REG, EXTMEM_ICACHE_ENABLE) != 0);
4037772f:	f45021        	l32r	a2, 40374870 <_iram_text_start+0x46c>
40377732:	0020c0        	memw
40377735:	0228      	l32i.n	a2, a2, 0
#endif
    return result;
}
40377737:	042020        	extui	a2, a2, 0, 1
4037773a:	f01d      	retw.n

4037773c <spi_flash_enable_cache>:
    return ESP_OK;
}
#endif // CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2

void IRAM_ATTR spi_flash_enable_cache(uint32_t cpuid)
{
4037773c:	004136        	entry	a1, 32
    cache_value &= DPORT_CACHE_GET_MASK(cpuid);

    // Re-enable cache on this CPU
    spi_flash_restore_cache(cpuid, cache_value);
#else
    spi_flash_restore_cache(0, 0); // TODO cache_value should be non-zero
4037773f:	0a0c      	movi.n	a10, 0
40377741:	ffe1a5        	call8	4037755c <spi_flash_restore_cache$constprop$0>
#endif
}
40377744:	f01d      	retw.n
	...

40377748 <spi_flash_protected_read_mmu_entry>:
    spi_flash_mmap_init();
    spi_flash_enable_interrupts_caches_and_other_cpu();
}

static uint32_t IRAM_ATTR NOINLINE_ATTR spi_flash_protected_read_mmu_entry(int index)
{
40377748:	004136        	entry	a1, 32
    uint32_t value;
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037774b:	201110        	or	a1, a1, a1
4037774e:	ffe6a5        	call8	403775b8 <spi_flash_disable_interrupts_caches_and_other_cpu>
 */
__attribute__((always_inline))
static inline uint32_t mmu_ll_read_entry(uint32_t mmu_id, uint32_t entry_id)
{
    (void)mmu_id;
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
40377751:	ffa182        	movi	a8, 0x1ff
40377754:	11a827        	bge	a8, a2, 40377769 <spi_flash_protected_read_mmu_entry+0x21>
40377757:	f447d1        	l32r	a13, 40374874 <_iram_text_start+0x470>
4037775a:	f447c1        	l32r	a12, 40374878 <_iram_text_start+0x474>
4037775d:	f447a1        	l32r	a10, 4037487c <_iram_text_start+0x478>
40377760:	a0a0b2        	movi	a11, 160
40377763:	201110        	or	a1, a1, a1
40377766:	070a65        	call8	4037e80c <__assert_func>

    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
40377769:	f44581        	l32r	a8, 40374880 <_iram_text_start+0x47c>
4037776c:	802280        	add	a2, a2, a8
4037776f:	1122e0        	slli	a2, a2, 2
40377772:	002222        	l32i	a2, a2, 0
    value = mmu_ll_read_entry(MMU_TABLE_CORE0, index);
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377775:	fff265        	call8	4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>
    return value;
}
40377778:	000090        	retw
	...

4037777c <spi_flash_mmap_init>:
{
4037777c:	004136        	entry	a1, 32
    if (s_mmap_page_refcnt[SOC_MMU_DROM0_PAGES_START] != 0) {
4037777f:	f44481        	l32r	a8, 40374890 <_iram_text_start+0x48c>
40377782:	0008e0        	callx8	a8
40377785:	f43f41        	l32r	a4, 40374884 <_iram_text_start+0x480>
40377788:	41a2a0        	srli	a10, a10, 2
4037778b:	a4aa      	add.n	a10, a4, a10
4037778d:	000a22        	l8ui	a2, a10, 0
40377790:	42fc      	bnez.n	a2, 403777c8 <spi_flash_mmap_init+0x4c>
40377792:	f43d31        	l32r	a3, 40374888 <_iram_text_start+0x484>
40377795:	a05230        	addx4	a5, a2, a3
40377798:	0568      	l32i.n	a6, a5, 0
        if (!entry_pro_invalid && (i == SOC_MMU_DROM0_PAGES_START || i == SOC_MMU_PRO_IRAM0_FIRST_USABLE_PAGE || entry_pro != 0)) {
4037779a:	043e60        	extui	a3, a6, 14, 1
4037779d:	b3ec      	bnez.n	a3, 403777cc <spi_flash_mmap_init+0x50>
4037779f:	f43c81        	l32r	a8, 40374890 <_iram_text_start+0x48c>
403777a2:	0008e0        	callx8	a8
403777a5:	41a2a0        	srli	a10, a10, 2
403777a8:	0d1a27        	beq	a10, a2, 403777b9 <spi_flash_mmap_init+0x3d>
403777ab:	180c      	movi.n	a8, 1
403777ad:	833820        	moveqz	a3, a8, a2
403777b0:	005356        	bnez	a3, 403777b9 <spi_flash_mmap_init+0x3d>
403777b3:	838360        	moveqz	a8, a3, a6
403777b6:	012816        	beqz	a8, 403777cc <spi_flash_mmap_init+0x50>
            s_mmap_page_refcnt[i] = 1;
403777b9:	342a      	add.n	a3, a4, a2
403777bb:	150c      	movi.n	a5, 1
403777bd:	004352        	s8i	a5, a3, 0
    for (int i = 0; i < SOC_MMU_REGIONS_COUNT * SOC_MMU_PAGES_PER_REGION; ++i) {
403777c0:	221b      	addi.n	a2, a2, 1
403777c2:	00a232        	movi	a3, 0x200
403777c5:	c99237        	bne	a2, a3, 40377792 <spi_flash_mmap_init+0x16>
}
403777c8:	f01d      	retw.n
403777ca:	00          	.byte 00
403777cb:	00          	.byte 00
static inline void mmu_ll_set_entry_invalid(uint32_t mmu_id, uint32_t entry_id)
{
    (void)mmu_id;
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);

    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = MMU_INVALID;
403777cc:	f43031        	l32r	a3, 4037488c <_iram_text_start+0x488>
403777cf:	0539      	s32i.n	a3, a5, 0
}
403777d1:	fffac6        	j	403777c0 <spi_flash_mmap_init+0x44>

403777d4 <get_mmu_region>:
{
403777d4:	004136        	entry	a1, 32
    if (memory == SPI_FLASH_MMAP_DATA) {
403777d7:	72fc      	bnez.n	a2, 40377812 <get_mmu_region+0x3e>
        *out_begin = SOC_MMU_DROM0_PAGES_START;
403777d9:	f42d81        	l32r	a8, 40374890 <_iram_text_start+0x48c>
403777dc:	0008e0        	callx8	a8
403777df:	41a2a0        	srli	a10, a10, 2
403777e2:	03a9      	s32i.n	a10, a3, 0
        *out_size = DROM0_PAGES_NUM;
403777e4:	f42c81        	l32r	a8, 40374894 <_iram_text_start+0x490>
403777e7:	0008e0        	callx8	a8
403777ea:	0a2d      	mov.n	a2, a10
403777ec:	f42981        	l32r	a8, 40374890 <_iram_text_start+0x48c>
403777ef:	0008e0        	callx8	a8
403777f2:	41a2a0        	srli	a10, a10, 2
403777f5:	418220        	srli	a8, a2, 2
403777f8:	c088a0        	sub	a8, a8, a10
403777fb:	006482        	s32i	a8, a4, 0
        *region_addr = SOC_MMU_VADDR0_START_ADDR;
403777fe:	f42481        	l32r	a8, 40374890 <_iram_text_start+0x48c>
40377801:	0008e0        	callx8	a8
40377804:	41a2a0        	srli	a10, a10, 2
40377807:	3cdaa2        	addmi	a10, a10, 0x3c00
4037780a:	11aa00        	slli	a10, a10, 16
4037780d:	05a9      	s32i.n	a10, a5, 0
}
4037780f:	f01d      	retw.n
40377811:	00          	.byte 00
        *out_begin = SOC_MMU_PRO_IRAM0_FIRST_USABLE_PAGE;
40377812:	020c      	movi.n	a2, 0
40377814:	0329      	s32i.n	a2, a3, 0
        *out_size = SOC_MMU_IROM0_PAGES_END - *out_begin;
40377816:	f41e81        	l32r	a8, 40374890 <_iram_text_start+0x48c>
40377819:	0008e0        	callx8	a8
4037781c:	0328      	l32i.n	a2, a3, 0
4037781e:	41a2a0        	srli	a10, a10, 2
40377821:	c0aa20        	sub	a10, a10, a2
40377824:	04a9      	s32i.n	a10, a4, 0
40377826:	1a2c      	movi.n	a10, 33
40377828:	01aa70        	slli	a10, a10, 25
4037782b:	fff786        	j	4037780d <get_mmu_region+0x39>
	...

40377830 <is_page_mapped_in_cache$constprop$0>:
    }
    spi_flash_enable_interrupts_caches_and_other_cpu();
    return NULL;
}

static bool IRAM_ATTR is_page_mapped_in_cache(uint32_t phys_page, const void **out_ptr)
40377830:	004136        	entry	a1, 32
{
    int start[2], end[2];

    *out_ptr = NULL;
40377833:	040c      	movi.n	a4, 0
40377835:	0349      	s32i.n	a4, a3, 0

    /* SPI_FLASH_MMAP_DATA */
    start[0] = SOC_MMU_DROM0_PAGES_START;
40377837:	f41681        	l32r	a8, 40374890 <_iram_text_start+0x48c>
4037783a:	0008e0        	callx8	a8
4037783d:	4152a0        	srli	a5, a10, 2
    end[0] = SOC_MMU_DROM0_PAGES_END;
40377840:	f41581        	l32r	a8, 40374894 <_iram_text_start+0x490>
40377843:	0008e0        	callx8	a8
40377846:	4162a0        	srli	a6, a10, 2

    /* SPI_FLASH_MMAP_INST */
    start[1] = SOC_MMU_PRO_IRAM0_FIRST_USABLE_PAGE;
    end[1] = SOC_MMU_IROM0_PAGES_END;
40377849:	f41181        	l32r	a8, 40374890 <_iram_text_start+0x48c>
4037784c:	0008e0        	callx8	a8
    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
4037784f:	f40e91        	l32r	a9, 40374888 <_iram_text_start+0x484>
40377852:	41a2a0        	srli	a10, a10, 2

    for (int j = 0; j < 2; j++) {
        for (int i = start[j]; i < end[j]; i++) {
40377855:	054d      	mov.n	a4, a5
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
40377857:	ffa182        	movi	a8, 0x1ff
4037785a:	36a467        	bge	a4, a6, 40377894 <is_page_mapped_in_cache$constprop$0+0x64>
4037785d:	0f2847        	blt	a8, a4, 40377870 <is_page_mapped_in_cache$constprop$0+0x40>
    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
40377860:	a0b490        	addx4	a11, a4, a9
            uint32_t entry_pro = mmu_ll_read_entry(MMU_TABLE_CORE0, i);
            if (entry_pro == SOC_MMU_PAGE_IN_FLASH(phys_page)) {
40377863:	0bb8      	l32i.n	a11, a11, 0
40377865:	3712b7        	beq	a2, a11, 403778a0 <is_page_mapped_in_cache$constprop$0+0x70>
        for (int i = start[j]; i < end[j]; i++) {
40377868:	441b      	addi.n	a4, a4, 1
4037786a:	fffb06        	j	4037785a <is_page_mapped_in_cache$constprop$0+0x2a>
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
4037786d:	0e9457        	bne	a4, a5, 4037787f <is_page_mapped_in_cache$constprop$0+0x4f>
40377870:	f401d1        	l32r	a13, 40374874 <_iram_text_start+0x470>
40377873:	f401c1        	l32r	a12, 40374878 <_iram_text_start+0x474>
40377876:	f401a1        	l32r	a10, 4037487c <_iram_text_start+0x478>
40377879:	a0a0b2        	movi	a11, 160
4037787c:	06f8e5        	call8	4037e80c <__assert_func>
    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
4037787f:	a09480        	addx4	a9, a4, a8
            if (entry_pro == SOC_MMU_PAGE_IN_FLASH(phys_page)) {
40377882:	002992        	l32i	a9, a9, 0
40377885:	331927        	beq	a9, a2, 403778bc <is_page_mapped_in_cache$constprop$0+0x8c>
        for (int i = start[j]; i < end[j]; i++) {
40377888:	01c442        	addi	a4, a4, 1
4037788b:	de24a7        	blt	a4, a10, 4037786d <is_page_mapped_in_cache$constprop$0+0x3d>
#endif
                return true;
            }
        }
    }
    return false;
4037788e:	00a022        	movi	a2, 0
}
40377891:	f01d      	retw.n
40377893:	00          	.byte 00
40377894:	f3fd81        	l32r	a8, 40374888 <_iram_text_start+0x484>
        for (int i = start[j]; i < end[j]; i++) {
40377897:	040c      	movi.n	a4, 0
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
40377899:	00a252        	movi	a5, 0x200
4037789c:	fffac6        	j	4037788b <is_page_mapped_in_cache$constprop$0+0x5b>
4037789f:	00          	.byte 00
                    *out_ptr = (const void *)(SOC_MMU_VADDR0_START_ADDR + SPI_FLASH_MMU_PAGE_SIZE * (i - start[0]));
403778a0:	f3fc81        	l32r	a8, 40374890 <_iram_text_start+0x48c>
403778a3:	0008e0        	callx8	a8
403778a6:	41a2a0        	srli	a10, a10, 2
403778a9:	3cdaa2        	addmi	a10, a10, 0x3c00
403778ac:	c04450        	sub	a4, a4, a5
403778af:	44aa      	add.n	a4, a4, a10
                    *out_ptr = (const void *)(SOC_MMU_VADDR1_FIRST_USABLE_ADDR + SPI_FLASH_MMU_PAGE_SIZE * (i - start[1]));
403778b1:	114400        	slli	a4, a4, 16
403778b4:	0349      	s32i.n	a4, a3, 0
                return true;
403778b6:	120c      	movi.n	a2, 1
403778b8:	fff546        	j	40377891 <is_page_mapped_in_cache$constprop$0+0x61>
403778bb:	00          	.byte 00
                    *out_ptr = (const void *)(SOC_MMU_VADDR1_FIRST_USABLE_ADDR + SPI_FLASH_MMU_PAGE_SIZE * (i - start[1]));
403778bc:	42d442        	addmi	a4, a4, 0x4200
403778bf:	fffb86        	j	403778b1 <is_page_mapped_in_cache$constprop$0+0x81>
	...

403778c4 <spi_flash_mmap_pages>:
{
403778c4:	00a136        	entry	a1, 80
    const void* temp_ptr = *out_ptr = NULL;
403778c7:	070c      	movi.n	a7, 0
403778c9:	0579      	s32i.n	a7, a5, 0
    spi_flash_mmap_handle_t temp_handle = *out_handle = (spi_flash_mmap_handle_t)NULL;
403778cb:	0679      	s32i.n	a7, a6, 0
    if (!page_count) {
403778cd:	341377        	beq	a3, a7, 40377905 <spi_flash_mmap_pages+0x41>
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
403778d0:	f35291        	l32r	a9, 40374618 <_iram_text_start+0x214>
403778d3:	f3f1a1        	l32r	a10, 40374898 <_iram_text_start+0x494>
403778d6:	4129      	s32i.n	a2, a1, 16
403778d8:	929a      	add.n	a9, a2, a9
403778da:	180c      	movi.n	a8, 1
403778dc:	02ba97        	bgeu	a10, a9, 403778e2 <spi_flash_mmap_pages+0x1e>
403778df:	208770        	or	a8, a7, a7
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
403778e2:	b77c      	movi.n	a7, -5
403778e4:	017740        	slli	a7, a7, 28
403778e7:	f330a1        	l32r	a10, 403745a8 <_iram_text_start+0x1a4>
403778ea:	727a      	add.n	a7, a2, a7
403778ec:	190c      	movi.n	a9, 1
403778ee:	02ba77        	bgeu	a10, a7, 403778f4 <spi_flash_mmap_pages+0x30>
403778f1:	00a092        	movi	a9, 0
    if (!esp_ptr_internal(pages)) {
403778f4:	208890        	or	a8, a8, a9
403778f7:	11e807        	bbsi	a8, 0, 4037790c <spi_flash_mmap_pages+0x48>
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
403778fa:	f32a71        	l32r	a7, 403745a4 <_iram_text_start+0x1a0>
403778fd:	f32a81        	l32r	a8, 403745a8 <_iram_text_start+0x1a4>
40377900:	727a      	add.n	a7, a2, a7
40377902:	06b877        	bgeu	a8, a7, 4037790c <spi_flash_mmap_pages+0x48>
        return ESP_ERR_INVALID_ARG;
40377905:	02a122        	movi	a2, 0x102
40377908:	003c86        	j	403779fe <spi_flash_mmap_pages+0x13a>
4037790b:	00          	.byte 00
        if (pages[i] < 0 || pages[i]*SPI_FLASH_MMU_PAGE_SIZE >= g_rom_flashchip.chip_size) {
4037790c:	f3ba71        	l32r	a7, 403747f4 <_iram_text_start+0x3f0>
    for (int i = 0; i < page_count; i++) {
4037790f:	090c      	movi.n	a9, 0
        if (pages[i] < 0 || pages[i]*SPI_FLASH_MMU_PAGE_SIZE >= g_rom_flashchip.chip_size) {
40377911:	07a8      	l32i.n	a10, a7, 0
    for (int i = 0; i < page_count; i++) {
40377913:	038d      	mov.n	a8, a3
40377915:	148876        	loop	a8, 4037792d <spi_flash_mmap_pages+0x69>
        if (pages[i] < 0 || pages[i]*SPI_FLASH_MMU_PAGE_SIZE >= g_rom_flashchip.chip_size) {
40377918:	a07920        	addx4	a7, a9, a2
4037791b:	002772        	l32i	a7, a7, 0
4037791e:	fe3796        	bltz	a7, 40377905 <spi_flash_mmap_pages+0x41>
40377921:	012ab2        	l32i	a11, a10, 4
40377924:	117700        	slli	a7, a7, 16
40377927:	dab7b7        	bgeu	a7, a11, 40377905 <spi_flash_mmap_pages+0x41>
    for (int i = 0; i < page_count; i++) {
4037792a:	01c992        	addi	a9, a9, 1
    mmap_entry_t* new_entry = (mmap_entry_t*) heap_caps_malloc(sizeof(mmap_entry_t), MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
4037792d:	01a2b2        	movi	a11, 0x201
40377930:	11bbe0        	slli	a11, a11, 2
40377933:	4a1c      	movi.n	a10, 20
40377935:	fe4025        	call8	40375d38 <heap_caps_malloc>
40377938:	0a7d      	mov.n	a7, a10
    if (new_entry == 0) {
4037793a:	7a9c      	beqz.n	a10, 40377955 <spi_flash_mmap_pages+0x91>
    spi_flash_disable_interrupts_caches_and_other_cpu();
4037793c:	ffc7a5        	call8	403775b8 <spi_flash_disable_interrupts_caches_and_other_cpu>
    spi_flash_mmap_init();
4037793f:	ffe3e5        	call8	4037777c <spi_flash_mmap_init>
    get_mmu_region(memory,&region_begin,&region_size,&region_addr);
40377942:	01dd      	mov.n	a13, a1
40377944:	c14b      	addi.n	a12, a1, 4
40377946:	b18b      	addi.n	a11, a1, 8
40377948:	04ad      	mov.n	a10, a4
4037794a:	ffe8a5        	call8	403777d4 <get_mmu_region>
    if (region_size < page_count) {
4037794d:	1188      	l32i.n	a8, a1, 4
4037794f:	09b837        	bgeu	a8, a3, 4037795c <spi_flash_mmap_pages+0x98>
        spi_flash_enable_interrupts_caches_and_other_cpu();
40377952:	ffd4a5        	call8	4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>
        return ESP_ERR_NO_MEM;
40377955:	01a122        	movi	a2, 0x101
40377958:	002886        	j	403779fe <spi_flash_mmap_pages+0x13a>
4037795b:	00          	.byte 00
    int end = region_begin + region_size - page_count + 1;
4037795c:	21a8      	l32i.n	a10, a1, 8
4037795e:	ffa1d2        	movi	a13, 0x1ff
40377961:	88aa      	add.n	a8, a8, a10
40377963:	881b      	addi.n	a8, a8, 1
40377965:	c08830        	sub	a8, a8, a3
    for (start = region_begin; start < end; ++start) {
40377968:	0a4d      	mov.n	a4, a10
4037796a:	02a487        	bge	a4, a8, 40377970 <spi_flash_mmap_pages+0xac>
4037796d:	0023c6        	j	40377a00 <spi_flash_mmap_pages+0x13c>
    if (start == end) {
40377970:	3f9487        	bne	a4, a8, 403779b3 <spi_flash_mmap_pages+0xef>
    spi_flash_mmap_handle_t temp_handle = *out_handle = (spi_flash_mmap_handle_t)NULL;
40377973:	040c      	movi.n	a4, 0
    const void* temp_ptr = *out_ptr = NULL;
40377975:	043d      	mov.n	a3, a4
        ret = ESP_ERR_NO_MEM;
40377977:	01a122        	movi	a2, 0x101
4037797a:	001c86        	j	403779f0 <spi_flash_mmap_pages+0x12c>
4037797d:	0ebd97        	bgeu	a13, a9, 4037798f <spi_flash_mmap_pages+0xcb>
40377980:	f3bdd1        	l32r	a13, 40374874 <_iram_text_start+0x470>
40377983:	f3bdc1        	l32r	a12, 40374878 <_iram_text_start+0x474>
40377986:	f3bda1        	l32r	a10, 4037487c <_iram_text_start+0x478>
40377989:	a0a0b2        	movi	a11, 160
            assert(s_mmap_page_refcnt[i] == 0 ||
4037798c:	06e7e5        	call8	4037e80c <__assert_func>
            uint8_t refcnt = s_mmap_page_refcnt[pos];
4037798f:	f3bdf1        	l32r	a15, 40374884 <_iram_text_start+0x480>
40377992:	c9fa      	add.n	a12, a9, a15
            if (refcnt != 0 && table_val != SOC_MMU_PAGE_IN_FLASH(pages[pageno])) {
40377994:	000cc2        	l8ui	a12, a12, 0
40377997:	bc8c      	beqz.n	a12, 403779a6 <spi_flash_mmap_pages+0xe2>
    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
40377999:	f3bbf1        	l32r	a15, 40374888 <_iram_text_start+0x484>
4037799c:	a0c9f0        	addx4	a12, a9, a15
4037799f:	0cc8      	l32i.n	a12, a12, 0
403779a1:	0bf8      	l32i.n	a15, a11, 0
403779a3:	069fc7        	bne	a15, a12, 403779ad <spi_flash_mmap_pages+0xe9>
        for (pos = start; pos < start + page_count; ++pos, ++pageno) {
403779a6:	991b      	addi.n	a9, a9, 1
403779a8:	bb4b      	addi.n	a11, a11, 4
403779aa:	cf39e7        	bltu	a9, a14, 4037797d <spi_flash_mmap_pages+0xb9>
        if (pos - start == page_count) {
403779ad:	c09940        	sub	a9, a9, a4
403779b0:	559937        	bne	a9, a3, 40377a09 <spi_flash_mmap_pages+0x145>
403779b3:	f3b481        	l32r	a8, 40374884 <_iram_text_start+0x480>
403779b6:	c024a0        	sub	a2, a4, a10
403779b9:	848a      	add.n	a8, a4, a8
403779bb:	11c200        	slli	a12, a2, 16
    for (start = region_begin; start < end; ++start) {
403779be:	049d      	mov.n	a9, a4
        for (int i = start; i != start + page_count; ++i, ++pageno) {
403779c0:	d34a      	add.n	a13, a3, a4
403779c2:	4a99d7        	bne	a9, a13, 40377a10 <spi_flash_mmap_pages+0x14c>
        LIST_INSERT_HEAD(&s_mmap_entries_head, new_entry, entries);
403779c5:	f3b881        	l32r	a8, 403748a8 <_iram_text_start+0x4a4>
403779c8:	0898      	l32i.n	a9, a8, 0
403779ca:	3799      	s32i.n	a9, a7, 12
403779cc:	298c      	beqz.n	a9, 403779d2 <spi_flash_mmap_pages+0x10e>
403779ce:	a7cb      	addi.n	a10, a7, 12
403779d0:	49a9      	s32i.n	a10, a9, 16
        new_entry->count = page_count;
403779d2:	026732        	s32i	a3, a7, 8
        new_entry->handle = ++s_mmap_last_handle;
403779d5:	f3b531        	l32r	a3, 403748ac <_iram_text_start+0x4a8>
        new_entry->page = start;
403779d8:	016742        	s32i	a4, a7, 4
        new_entry->handle = ++s_mmap_last_handle;
403779db:	0348      	l32i.n	a4, a3, 0
        temp_ptr = (void*) (region_addr + (start - region_begin) * SPI_FLASH_MMU_PAGE_SIZE);
403779dd:	112200        	slli	a2, a2, 16
        new_entry->handle = ++s_mmap_last_handle;
403779e0:	441b      	addi.n	a4, a4, 1
403779e2:	0349      	s32i.n	a4, a3, 0
        temp_ptr = (void*) (region_addr + (start - region_begin) * SPI_FLASH_MMU_PAGE_SIZE);
403779e4:	0138      	l32i.n	a3, a1, 0
        LIST_INSERT_HEAD(&s_mmap_entries_head, new_entry, entries);
403779e6:	0879      	s32i.n	a7, a8, 0
        temp_ptr = (void*) (region_addr + (start - region_begin) * SPI_FLASH_MMU_PAGE_SIZE);
403779e8:	323a      	add.n	a3, a2, a3
        LIST_INSERT_HEAD(&s_mmap_entries_head, new_entry, entries);
403779ea:	4789      	s32i.n	a8, a7, 16
        new_entry->handle = ++s_mmap_last_handle;
403779ec:	0749      	s32i.n	a4, a7, 0
        ret = ESP_OK;
403779ee:	020c      	movi.n	a2, 0
    spi_flash_enable_interrupts_caches_and_other_cpu();
403779f0:	ffcaa5        	call8	4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>
    if (temp_ptr == NULL) {
403779f3:	33cc      	bnez.n	a3, 403779fa <spi_flash_mmap_pages+0x136>
        free(new_entry);
403779f5:	07ad      	mov.n	a10, a7
403779f7:	06f365        	call8	4037e92c <cfree>
    *out_ptr = temp_ptr;
403779fa:	0539      	s32i.n	a3, a5, 0
    *out_handle = temp_handle;
403779fc:	0649      	s32i.n	a4, a6, 0
}
403779fe:	f01d      	retw.n
40377a00:	02bd      	mov.n	a11, a2
40377a02:	049d      	mov.n	a9, a4
        for (pos = start; pos < start + page_count; ++pos, ++pageno) {
40377a04:	e43a      	add.n	a14, a4, a3
40377a06:	ffe806        	j	403779aa <spi_flash_mmap_pages+0xe6>
    for (start = region_begin; start < end; ++start) {
40377a09:	441b      	addi.n	a4, a4, 1
40377a0b:	ffd6c6        	j	4037796a <spi_flash_mmap_pages+0xa6>
40377a0e:	00          	.byte 00
40377a0f:	00          	.byte 00
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
40377a10:	ffa1a2        	movi	a10, 0x1ff
40377a13:	02ba97        	bgeu	a10, a9, 40377a19 <spi_flash_mmap_pages+0x155>
40377a16:	ffd986        	j	40377980 <spi_flash_mmap_pages+0xbc>
    return *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4);
40377a19:	f39ba1        	l32r	a10, 40374888 <_iram_text_start+0x484>
            assert(s_mmap_page_refcnt[i] == 0 ||
40377a1c:	41e8      	l32i.n	a14, a1, 16
40377a1e:	0008f2        	l8ui	a15, a8, 0
40377a21:	a0a9a0        	addx4	a10, a9, a10
40377a24:	0eb8      	l32i.n	a11, a14, 0
40377a26:	0ae8      	l32i.n	a14, a10, 0
40377a28:	0f9c      	beqz.n	a15, 40377a3c <spi_flash_mmap_pages+0x178>
40377a2a:	321be7        	beq	a11, a14, 40377a60 <spi_flash_mmap_pages+0x19c>
40377a2d:	f39bd1        	l32r	a13, 4037489c <_iram_text_start+0x498>
40377a30:	f39cc1        	l32r	a12, 403748a0 <_iram_text_start+0x49c>
40377a33:	f39ca1        	l32r	a10, 403748a4 <_iram_text_start+0x4a0>
40377a36:	dea0b2        	movi	a11, 222
40377a39:	ffd3c6        	j	4037798c <spi_flash_mmap_pages+0xc8>
                if (entry_pro != SOC_MMU_PAGE_IN_FLASH(pages[pageno])
40377a3c:	201be7        	beq	a11, a14, 40377a60 <spi_flash_mmap_pages+0x19c>
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = mmu_val | target_code | MMU_VALID;
40377a3f:	0ab9      	s32i.n	a11, a10, 0
                    Cache_Invalidate_Addr(region_addr + (i - region_begin) * SPI_FLASH_MMU_PAGE_SIZE, SPI_FLASH_MMU_PAGE_SIZE);
40377a41:	01a8      	l32i.n	a10, a1, 0
40377a43:	1b0c      	movi.n	a11, 1
40377a45:	acaa      	add.n	a10, a12, a10
40377a47:	11bb00        	slli	a11, a11, 16
40377a4a:	7189      	s32i.n	a8, a1, 28
40377a4c:	6199      	s32i.n	a9, a1, 24
40377a4e:	51c9      	s32i.n	a12, a1, 20
40377a50:	81d9      	s32i.n	a13, a1, 32
40377a52:	f39781        	l32r	a8, 403748b0 <_iram_text_start+0x4ac>
40377a55:	0008e0        	callx8	a8
40377a58:	81d8      	l32i.n	a13, a1, 32
40377a5a:	51c8      	l32i.n	a12, a1, 20
40377a5c:	6198      	l32i.n	a9, a1, 24
40377a5e:	7188      	l32i.n	a8, a1, 28
            ++s_mmap_page_refcnt[i];
40377a60:	0008a2        	l8ui	a10, a8, 0
40377a63:	41f8      	l32i.n	a15, a1, 16
40377a65:	aa1b      	addi.n	a10, a10, 1
40377a67:	0048a2        	s8i	a10, a8, 0
        for (int i = start; i != start + page_count; ++i, ++pageno) {
40377a6a:	1a0c      	movi.n	a10, 1
40377a6c:	11aa00        	slli	a10, a10, 16
40377a6f:	ff4b      	addi.n	a15, a15, 4
40377a71:	991b      	addi.n	a9, a9, 1
40377a73:	881b      	addi.n	a8, a8, 1
40377a75:	ccaa      	add.n	a12, a12, a10
40377a77:	41f9      	s32i.n	a15, a1, 16
40377a79:	ffd146        	j	403779c2 <spi_flash_mmap_pages+0xfe>

40377a7c <spi_flash_mmap>:
{
40377a7c:	006136        	entry	a1, 48
    if (src_addr & INVALID_PHY_PAGE(CONFIG_MMU_PAGE_SIZE)) {
40377a7f:	f47020        	extui	a7, a2, 0, 16
{
40377a82:	208220        	or	a8, a2, a2
40377a85:	20d550        	or	a13, a5, a5
40377a88:	20e660        	or	a14, a6, a6
        return ESP_ERR_INVALID_ARG;
40377a8b:	02a122        	movi	a2, 0x102
    if (src_addr & INVALID_PHY_PAGE(CONFIG_MMU_PAGE_SIZE)) {
40377a8e:	27fc      	bnez.n	a7, 40377ac4 <spi_flash_mmap+0x48>
    if ((src_addr + size) > g_rom_flashchip.chip_size) {
40377a90:	f35961        	l32r	a6, 403747f4 <_iram_text_start+0x3f0>
40377a93:	583a      	add.n	a5, a8, a3
40377a95:	0668      	l32i.n	a6, a6, 0
40377a97:	1668      	l32i.n	a6, a6, 4
40377a99:	273657        	bltu	a6, a5, 40377ac4 <spi_flash_mmap+0x48>
    int page_count = (size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE;
40377a9c:	f27021        	l32r	a2, 4037445c <_iram_text_start+0x58>
    int *pages = heap_caps_malloc(sizeof(int)*page_count, MALLOC_CAP_INTERNAL);
40377a9f:	1b0c      	movi.n	a11, 1
    int page_count = (size + SPI_FLASH_MMU_PAGE_SIZE - 1) / SPI_FLASH_MMU_PAGE_SIZE;
40377aa1:	332a      	add.n	a3, a3, a2
40377aa3:	f53030        	extui	a3, a3, 16, 16
    int *pages = heap_caps_malloc(sizeof(int)*page_count, MALLOC_CAP_INTERNAL);
40377aa6:	11bb50        	slli	a11, a11, 11
40377aa9:	11a3e0        	slli	a10, a3, 2
    int phys_page = src_addr / SPI_FLASH_MMU_PAGE_SIZE;
40377aac:	f55080        	extui	a5, a8, 16, 16
    int *pages = heap_caps_malloc(sizeof(int)*page_count, MALLOC_CAP_INTERNAL);
40377aaf:	01d9      	s32i.n	a13, a1, 0
40377ab1:	11e9      	s32i.n	a14, a1, 4
40377ab3:	fe2865        	call8	40375d38 <heap_caps_malloc>
    if (pages == NULL) {
40377ab6:	01d8      	l32i.n	a13, a1, 0
40377ab8:	11e8      	l32i.n	a14, a1, 4
    int *pages = heap_caps_malloc(sizeof(int)*page_count, MALLOC_CAP_INTERNAL);
40377aba:	0a6d      	mov.n	a6, a10
        return ESP_ERR_NO_MEM;
40377abc:	01a122        	movi	a2, 0x101
    for (int i = 0; i < page_count; i++) {
40377abf:	078d      	mov.n	a8, a7
    if (pages == NULL) {
40377ac1:	00ca56        	bnez	a10, 40377ad1 <spi_flash_mmap+0x55>
}
40377ac4:	f01d      	retw.n
40377ac6:	00          	.byte 00
40377ac7:	00          	.byte 00
        pages[i] = (phys_page+i);
40377ac8:	a02860        	addx4	a2, a8, a6
40377acb:	758a      	add.n	a7, a5, a8
40377acd:	0279      	s32i.n	a7, a2, 0
    for (int i = 0; i < page_count; i++) {
40377acf:	881b      	addi.n	a8, a8, 1
40377ad1:	f32837        	blt	a8, a3, 40377ac8 <spi_flash_mmap+0x4c>
    ret = spi_flash_mmap_pages(pages, page_count, memory, out_ptr, out_handle);
40377ad4:	04cd      	mov.n	a12, a4
40377ad6:	03bd      	mov.n	a11, a3
40377ad8:	06ad      	mov.n	a10, a6
40377ada:	ffdea5        	call8	403778c4 <spi_flash_mmap_pages>
40377add:	0a2d      	mov.n	a2, a10
    free(pages);
40377adf:	06ad      	mov.n	a10, a6
40377ae1:	06e4a5        	call8	4037e92c <cfree>
    return ret;
40377ae4:	fff706        	j	40377ac4 <spi_flash_mmap+0x48>
	...

40377ae8 <spi_flash_munmap>:
{
40377ae8:	004136        	entry	a1, 32
    spi_flash_disable_interrupts_caches_and_other_cpu();
40377aeb:	fface5        	call8	403775b8 <spi_flash_disable_interrupts_caches_and_other_cpu>
    for (it = LIST_FIRST(&s_mmap_entries_head); it != NULL; it = LIST_NEXT(it, entries)) {
40377aee:	f36e31        	l32r	a3, 403748a8 <_iram_text_start+0x4a4>
40377af1:	002332        	l32i	a3, a3, 0
40377af4:	02a316        	beqz	a3, 40377b22 <spi_flash_munmap+0x3a>
        if (it->handle == handle) {
40377af7:	002382        	l32i	a8, a3, 0
40377afa:	7a9827        	bne	a8, a2, 40377b78 <spi_flash_munmap+0x90>
            for (int i = it->page; i < it->page + it->count; ++i) {
40377afd:	1398      	l32i.n	a9, a3, 4
40377aff:	f361a1        	l32r	a10, 40374884 <_iram_text_start+0x480>
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = MMU_INVALID;
40377b02:	f361c1        	l32r	a12, 40374888 <_iram_text_start+0x484>
40377b05:	f361d1        	l32r	a13, 4037488c <_iram_text_start+0x488>
40377b08:	a9aa      	add.n	a10, a9, a10
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
40377b0a:	ffa1b2        	movi	a11, 0x1ff
40377b0d:	1388      	l32i.n	a8, a3, 4
40377b0f:	2328      	l32i.n	a2, a3, 8
40377b11:	882a      	add.n	a8, a8, a2
40377b13:	202987        	blt	a9, a8, 40377b37 <spi_flash_munmap+0x4f>
            LIST_REMOVE(it, entries);
40377b16:	3388      	l32i.n	a8, a3, 12
40377b18:	288c      	beqz.n	a8, 40377b1e <spi_flash_munmap+0x36>
40377b1a:	4328      	l32i.n	a2, a3, 16
40377b1c:	4829      	s32i.n	a2, a8, 16
40377b1e:	4328      	l32i.n	a2, a3, 16
40377b20:	0289      	s32i.n	a8, a2, 0
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377b22:	ffb7a5        	call8	4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>
    if (it == NULL) {
40377b25:	054356        	bnez	a3, 40377b7d <spi_flash_munmap+0x95>
        assert(0 && "invalid handle, or handle already unmapped");
40377b28:	f366d1        	l32r	a13, 403748c0 <_iram_text_start+0x4bc>
40377b2b:	f363c1        	l32r	a12, 403748b8 <_iram_text_start+0x4b4>
40377b2e:	34a1b2        	movi	a11, 0x134
40377b31:	000406        	j	40377b45 <spi_flash_munmap+0x5d>
40377b34:	00          	.byte 00
40377b35:	00          	.byte 00
40377b36:	00          	.byte 00
                assert(s_mmap_page_refcnt[i] > 0);
40377b37:	000a82        	l8ui	a8, a10, 0
40377b3a:	f8cc      	bnez.n	a8, 40377b4d <spi_flash_munmap+0x65>
40377b3c:	f35ed1        	l32r	a13, 403748b4 <_iram_text_start+0x4b0>
40377b3f:	f35ec1        	l32r	a12, 403748b8 <_iram_text_start+0x4b4>
40377b42:	26a1b2        	movi	a11, 0x126
        assert(0 && "invalid handle, or handle already unmapped");
40377b45:	f357a1        	l32r	a10, 403748a4 <_iram_text_start+0x4a0>
40377b48:	000686        	j	40377b66 <spi_flash_munmap+0x7e>
40377b4b:	00          	.byte 00
40377b4c:	00          	.byte 00
                if (--s_mmap_page_refcnt[i] == 0) {
40377b4d:	880b      	addi.n	a8, a8, -1
40377b4f:	748080        	extui	a8, a8, 0, 8
40377b52:	004a82        	s8i	a8, a10, 0
40377b55:	58dc      	bnez.n	a8, 40377b6e <spi_flash_munmap+0x86>
40377b57:	0ebb97        	bgeu	a11, a9, 40377b69 <spi_flash_munmap+0x81>
40377b5a:	f346d1        	l32r	a13, 40374874 <_iram_text_start+0x470>
40377b5d:	f357c1        	l32r	a12, 403748bc <_iram_text_start+0x4b8>
40377b60:	f347a1        	l32r	a10, 4037487c <_iram_text_start+0x478>
40377b63:	afa0b2        	movi	a11, 175
40377b66:	06ca65        	call8	4037e80c <__assert_func>
    *(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) = MMU_INVALID;
40377b69:	a029c0        	addx4	a2, a9, a12
40377b6c:	02d9      	s32i.n	a13, a2, 0
            for (int i = it->page; i < it->page + it->count; ++i) {
40377b6e:	991b      	addi.n	a9, a9, 1
40377b70:	aa1b      	addi.n	a10, a10, 1
40377b72:	ffe5c6        	j	40377b0d <spi_flash_munmap+0x25>
40377b75:	00          	.byte 00
40377b76:	00          	.byte 00
40377b77:	00          	.byte 00
    for (it = LIST_FIRST(&s_mmap_entries_head); it != NULL; it = LIST_NEXT(it, entries)) {
40377b78:	3338      	l32i.n	a3, a3, 12
40377b7a:	ffdd86        	j	40377af4 <spi_flash_munmap+0xc>
    free(it);
40377b7d:	03ad      	mov.n	a10, a3
40377b7f:	06dae5        	call8	4037e92c <cfree>
}
40377b82:	f01d      	retw.n

40377b84 <spi_flash_check_and_flush_cache>:

/* Validates if given flash address has corresponding cache mapping, if yes, flushes cache memories */
IRAM_ATTR bool spi_flash_check_and_flush_cache(size_t start_addr, size_t length)
{
40377b84:	006136        	entry	a1, 48
    bool ret = false;
    /* align start_addr & length to full MMU pages */
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
    length += (start_addr - page_start_addr);
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377b87:	f23581        	l32r	a8, 4037445c <_iram_text_start+0x58>
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377b8a:	f97c      	movi.n	a9, -1
40377b8c:	119900        	slli	a9, a9, 16
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377b8f:	338a      	add.n	a3, a3, a8
    uint32_t page_start_addr = start_addr & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377b91:	104290        	and	a4, a2, a9
    length = (length + SPI_FLASH_MMU_PAGE_SIZE - 1) & ~(SPI_FLASH_MMU_PAGE_SIZE-1);
40377b94:	332a      	add.n	a3, a3, a2
40377b96:	c03340        	sub	a3, a3, a4
40377b99:	103390        	and	a3, a3, a9
    bool ret = false;
40377b9c:	020c      	movi.n	a2, 0
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377b9e:	343a      	add.n	a3, a4, a3
40377ba0:	0cb437        	bgeu	a4, a3, 40377bb0 <spi_flash_check_and_flush_cache+0x2c>
        uint32_t page = addr / SPI_FLASH_MMU_PAGE_SIZE;
        // TODO: IDF-4969
        if (page >= 256) {
40377ba3:	f34881        	l32r	a8, 403748c4 <_iram_text_start+0x4c0>
        uint32_t page = addr / SPI_FLASH_MMU_PAGE_SIZE;
40377ba6:	f5a040        	extui	a10, a4, 16, 16
        if (page >= 256) {
40377ba9:	050c      	movi.n	a5, 0
40377bab:	05b847        	bgeu	a8, a4, 40377bb4 <spi_flash_check_and_flush_cache+0x30>
            return false; /* invalid address */
40377bae:	052d      	mov.n	a2, a5
#endif // CONFIG_IDF_TARGET_ESP32

        }
    }
    return ret;
}
40377bb0:	f01d      	retw.n
40377bb2:	00          	.byte 00
40377bb3:	00          	.byte 00
        if (is_page_mapped_in_cache(page, &vaddr)) {
40377bb4:	01bd      	mov.n	a11, a1
        const void *vaddr = NULL;
40377bb6:	0159      	s32i.n	a5, a1, 0
        if (is_page_mapped_in_cache(page, &vaddr)) {
40377bb8:	ffc765        	call8	40377830 <is_page_mapped_in_cache$constprop$0>
40377bbb:	0a5d      	mov.n	a5, a10
40377bbd:	fa8c      	beqz.n	a10, 40377bd0 <spi_flash_check_and_flush_cache+0x4c>
            if (vaddr != NULL) {
40377bbf:	01a8      	l32i.n	a10, a1, 0
40377bc1:	ba8c      	beqz.n	a10, 40377bd0 <spi_flash_check_and_flush_cache+0x4c>
                Cache_Invalidate_Addr((uint32_t)vaddr, SPI_FLASH_MMU_PAGE_SIZE);
40377bc3:	1b0c      	movi.n	a11, 1
40377bc5:	11bb00        	slli	a11, a11, 16
40377bc8:	f33a81        	l32r	a8, 403748b0 <_iram_text_start+0x4ac>
40377bcb:	0008e0        	callx8	a8
                ret = true;
40377bce:	052d      	mov.n	a2, a5
    for (uint32_t addr = page_start_addr; addr < page_start_addr + length; addr += SPI_FLASH_MMU_PAGE_SIZE) {
40377bd0:	180c      	movi.n	a8, 1
40377bd2:	118800        	slli	a8, a8, 16
40377bd5:	448a      	add.n	a4, a4, a8
40377bd7:	fff146        	j	40377ba0 <spi_flash_check_and_flush_cache+0x1c>
	...

40377bdc <spi_flash_guard_set>:
};

static const spi_flash_guard_funcs_t *s_flash_guard_ops;

void IRAM_ATTR spi_flash_guard_set(const spi_flash_guard_funcs_t *funcs)
{
40377bdc:	004136        	entry	a1, 32
    s_flash_guard_ops = funcs;
40377bdf:	f33a81        	l32r	a8, 403748c8 <_iram_text_start+0x4c4>
40377be2:	0829      	s32i.n	a2, a8, 0
}
40377be4:	f01d      	retw.n
	...

40377be8 <spi_flash_init_chip_state>:
    //Set F4R4 board pin drive strength. TODO: IDF-3663
#endif
}

esp_err_t IRAM_ATTR spi_flash_init_chip_state(void)
{
40377be8:	004136        	entry	a1, 32
#if CONFIG_ESPTOOLPY_OCT_FLASH
    return esp_opiflash_init(rom_spiflash_legacy_data->chip.device_id);
#else
#if CONFIG_IDF_TARGET_ESP32S3
    // Currently, only esp32s3 allows high performance mode.
    return spi_flash_enable_high_performance_mode();
40377beb:	084c65        	call8	403800b0 <spi_flash_enable_high_performance_mode>
#else
    return ESP_OK;
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // CONFIG_ESPTOOLPY_OCT_FLASH
}
40377bee:	0a2d      	mov.n	a2, a10
40377bf0:	f01d      	retw.n
	...

40377bf4 <flash_end_flush_cache>:
    }
    return ESP_OK;
}

static IRAM_ATTR esp_err_t flash_end_flush_cache(esp_flash_t* chip, esp_err_t err, bool bus_acquired, uint32_t address, uint32_t length)
{
40377bf4:	004136        	entry	a1, 32
40377bf7:	744040        	extui	a4, a4, 0, 8
40377bfa:	f33471        	l32r	a7, 403748cc <_iram_text_start+0x4c8>
    if (!bus_acquired) {
40377bfd:	04dc      	bnez.n	a4, 40377c11 <flash_end_flush_cache+0x1d>
        // Try to acquire the bus again to flush the cache before exit.
        esp_err_t acquire_err = rom_spiflash_api_funcs->start(chip);
40377bff:	0788      	l32i.n	a8, a7, 0
40377c01:	02ad      	mov.n	a10, a2
40377c03:	0888      	l32i.n	a8, a8, 0
40377c05:	0008e0        	callx8	a8
        if (acquire_err != ESP_OK) {
40377c08:	5a8c      	beqz.n	a10, 40377c11 <flash_end_flush_cache+0x1d>
            return (err == ESP_OK)? acquire_err: err;
40377c0a:	93a330        	movnez	a10, a3, a3
        if (err == ESP_OK) {
            err = flush_err;
        }
    }
    return rom_spiflash_api_funcs->end(chip, err);
}
40377c0d:	0a2d      	mov.n	a2, a10
40377c0f:	f01d      	retw.n
    if (chip->host->driver->flush_cache) {
40377c11:	02a8      	l32i.n	a10, a2, 0
40377c13:	0a88      	l32i.n	a8, a10, 0
40377c15:	112882        	l32i	a8, a8, 68
40377c18:	888c      	beqz.n	a8, 40377c24 <flash_end_flush_cache+0x30>
        esp_err_t flush_err = chip->host->driver->flush_cache(chip->host, address, length);
40377c1a:	06cd      	mov.n	a12, a6
40377c1c:	20b550        	or	a11, a5, a5
40377c1f:	0008e0        	callx8	a8
        if (err == ESP_OK) {
40377c22:	038c      	beqz.n	a3, 40377c26 <flash_end_flush_cache+0x32>
{
40377c24:	03ad      	mov.n	a10, a3
    return rom_spiflash_api_funcs->end(chip, err);
40377c26:	0738      	l32i.n	a3, a7, 0
40377c28:	0abd      	mov.n	a11, a10
40377c2a:	1338      	l32i.n	a3, a3, 4
40377c2c:	02ad      	mov.n	a10, a2
40377c2e:	0003e0        	callx8	a3
40377c31:	fff606        	j	40377c0d <flash_end_flush_cache+0x19>

40377c34 <detect_spi_flash_chip>:

    return read_unique_id(chip, out_uid);
}

static esp_err_t IRAM_ATTR detect_spi_flash_chip(esp_flash_t *chip)
{
40377c34:	004136        	entry	a1, 32
    esp_err_t err;
    uint32_t flash_id = chip->chip_id;
40377c37:	6278      	l32i.n	a7, a2, 24
{
40377c39:	204220        	or	a4, a2, a2

    // Detect the chip and set the chip_drv structure for it
    const spi_flash_chip_t **drivers = esp_flash_registered_chips;
40377c3c:	f32521        	l32r	a2, 403748d0 <_iram_text_start+0x4cc>
        chip->chip_drv = *drivers;
        // start/end SPI operation each time, for multitasking
        // and also so esp_flash_registered_flash_drivers can live in flash
        ESP_LOGD(TAG, "trying chip: %s", chip->chip_drv->name);

        err = rom_spiflash_api_funcs->start(chip);
40377c3f:	f32361        	l32r	a6, 403748cc <_iram_text_start+0x4c8>
    const spi_flash_chip_t **drivers = esp_flash_registered_chips;
40377c42:	0258      	l32i.n	a5, a2, 0
    while (*drivers != NULL && !esp_flash_chip_driver_initialized(chip)) {
40377c44:	0538      	l32i.n	a3, a5, 0
40377c46:	04ad      	mov.n	a10, a4
40377c48:	f32381        	l32r	a8, 403748d4 <_iram_text_start+0x4d0>
40377c4b:	0008e0        	callx8	a8
40377c4e:	a3bc      	beqz.n	a3, 40377c8c <detect_spi_flash_chip+0x58>
40377c50:	3a8c      	beqz.n	a10, 40377c57 <detect_spi_flash_chip+0x23>
    }
    if (!esp_flash_chip_driver_initialized(chip)) {
        return ESP_ERR_NOT_FOUND;
    }
    ESP_LOGI(TAG, "detected chip: %s", chip->chip_drv->name);
    return ESP_OK;
40377c52:	020c      	movi.n	a2, 0
40377c54:	000c06        	j	40377c88 <detect_spi_flash_chip+0x54>
        err = rom_spiflash_api_funcs->start(chip);
40377c57:	0628      	l32i.n	a2, a6, 0
        chip->chip_drv = *drivers;
40377c59:	1439      	s32i.n	a3, a4, 4
        err = rom_spiflash_api_funcs->start(chip);
40377c5b:	0228      	l32i.n	a2, a2, 0
40377c5d:	04ad      	mov.n	a10, a4
40377c5f:	0002e0        	callx8	a2
40377c62:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377c64:	0aec      	bnez.n	a10, 40377c88 <detect_spi_flash_chip+0x54>
        if (chip->chip_drv->probe(chip, flash_id) != ESP_OK) {
40377c66:	1438      	l32i.n	a3, a4, 4
40377c68:	07bd      	mov.n	a11, a7
40377c6a:	2338      	l32i.n	a3, a3, 8
40377c6c:	20a440        	or	a10, a4, a4
40377c6f:	0003e0        	callx8	a3
40377c72:	0a8c      	beqz.n	a10, 40377c76 <detect_spi_flash_chip+0x42>
            chip->chip_drv = NULL;
40377c74:	1429      	s32i.n	a2, a4, 4
        err = rom_spiflash_api_funcs->end(chip, err);
40377c76:	0628      	l32i.n	a2, a6, 0
40377c78:	0b0c      	movi.n	a11, 0
40377c7a:	1228      	l32i.n	a2, a2, 4
40377c7c:	04ad      	mov.n	a10, a4
40377c7e:	0002e0        	callx8	a2
        drivers++;
40377c81:	554b      	addi.n	a5, a5, 4
        err = rom_spiflash_api_funcs->end(chip, err);
40377c83:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377c85:	fbba16        	beqz	a10, 40377c44 <detect_spi_flash_chip+0x10>
}
40377c88:	f01d      	retw.n
40377c8a:	00          	.byte 00
40377c8b:	00          	.byte 00
        return ESP_ERR_NOT_FOUND;
40377c8c:	05a122        	movi	a2, 0x105
40377c8f:	9323a0        	movnez	a2, a3, a10
40377c92:	fffc86        	j	40377c88 <detect_spi_flash_chip+0x54>
40377c95:	000000        	ill

40377c98 <read_id_core>:
{
40377c98:	006136        	entry	a1, 48
    bool installed = esp_flash_chip_driver_initialized(chip);
40377c9b:	20a220        	or	a10, a2, a2
40377c9e:	f30d81        	l32r	a8, 403748d4 <_iram_text_start+0x4d0>
40377ca1:	0008e0        	callx8	a8
    esp_err_t err = rom_spiflash_api_funcs->start(chip);
40377ca4:	f30a61        	l32r	a6, 403748cc <_iram_text_start+0x4c8>
    bool installed = esp_flash_chip_driver_initialized(chip);
40377ca7:	0a5d      	mov.n	a5, a10
    esp_err_t err = rom_spiflash_api_funcs->start(chip);
40377ca9:	0678      	l32i.n	a7, a6, 0
40377cab:	02ad      	mov.n	a10, a2
40377cad:	0778      	l32i.n	a7, a7, 0
40377caf:	0007e0        	callx8	a7
    if (err != ESP_OK) {
40377cb2:	eafc      	bnez.n	a10, 40377cf4 <read_id_core+0x5c>
    if (installed && chip->chip_drv->read_id) {
40377cb4:	a58c      	beqz.n	a5, 40377cc2 <read_id_core+0x2a>
40377cb6:	012252        	l32i	a5, a2, 4
40377cb9:	207220        	or	a7, a2, a2
40377cbc:	182552        	l32i	a5, a5, 96
40377cbf:	007556        	bnez	a5, 40377cca <read_id_core+0x32>
        read_id_func = (void*)chip->host->driver->read_id;
40377cc2:	0278      	l32i.n	a7, a2, 0
40377cc4:	002752        	l32i	a5, a7, 0
40377cc7:	022552        	l32i	a5, a5, 8
    err = read_id_func(read_id_arg, out_id);
40377cca:	03bd      	mov.n	a11, a3
40377ccc:	20a770        	or	a10, a7, a7
40377ccf:	0005e0        	callx8	a5
    if (sanity_check && err == ESP_OK) {
40377cd2:	3adc      	bnez.n	a10, 40377ce9 <read_id_core+0x51>
40377cd4:	149c      	beqz.n	a4, 40377ce9 <read_id_core+0x51>
        err = read_id_func(read_id_arg, &new_id);
40377cd6:	01bd      	mov.n	a11, a1
40377cd8:	07ad      	mov.n	a10, a7
40377cda:	0005e0        	callx8	a5
        if (err == ESP_OK && (new_id != *out_id)) {
40377cdd:	8acc      	bnez.n	a10, 40377ce9 <read_id_core+0x51>
40377cdf:	0348      	l32i.n	a4, a3, 0
40377ce1:	0138      	l32i.n	a3, a1, 0
40377ce3:	021437        	beq	a4, a3, 40377ce9 <read_id_core+0x51>
            err = ESP_ERR_FLASH_NOT_INITIALISED;
40377ce6:	f2fca1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4>
    return rom_spiflash_api_funcs->end(chip, err);
40377ce9:	0638      	l32i.n	a3, a6, 0
40377ceb:	0abd      	mov.n	a11, a10
40377ced:	1338      	l32i.n	a3, a3, 4
40377cef:	02ad      	mov.n	a10, a2
40377cf1:	0003e0        	callx8	a3
}
40377cf4:	0a2d      	mov.n	a2, a10
40377cf6:	f01d      	retw.n

40377cf8 <esp_flash_get_physical_size>:

esp_err_t IRAM_ATTR esp_flash_get_physical_size(esp_flash_t *chip, uint32_t *flash_size)
{
40377cf8:	008136        	entry	a1, 64
40377cfb:	4129      	s32i.n	a2, a1, 16
    esp_err_t err = rom_spiflash_api_funcs->chip_check(&chip);
40377cfd:	f2f321        	l32r	a2, 403748cc <_iram_text_start+0x4c8>
40377d00:	10c1a2        	addi	a10, a1, 16
40377d03:	0288      	l32i.n	a8, a2, 0
40377d05:	2888      	l32i.n	a8, a8, 8
40377d07:	0008e0        	callx8	a8
    if (err != ESP_OK) {
40377d0a:	eafc      	bnez.n	a10, 40377d4c <esp_flash_get_physical_size+0x54>
        return err;
    }
    VERIFY_CHIP_OP(detect_size);
40377d0c:	4188      	l32i.n	a8, a1, 16
40377d0e:	f2f3a1        	l32r	a10, 403748dc <_iram_text_start+0x4d8>
40377d11:	1898      	l32i.n	a9, a8, 4
40377d13:	4998      	l32i.n	a9, a9, 16
40377d15:	39bc      	beqz.n	a9, 40377d4c <esp_flash_get_physical_size+0x54>
    if (flash_size == NULL) {
        return ESP_ERR_INVALID_ARG;
40377d17:	02a1a2        	movi	a10, 0x102
    if (flash_size == NULL) {
40377d1a:	e3ac      	beqz.n	a3, 40377d4c <esp_flash_get_physical_size+0x54>
    }

    err = rom_spiflash_api_funcs->start(chip);
40377d1c:	0298      	l32i.n	a9, a2, 0
40377d1e:	08ad      	mov.n	a10, a8
40377d20:	0998      	l32i.n	a9, a9, 0
40377d22:	0009e0        	callx8	a9
    if (err != ESP_OK) {
40377d25:	3aec      	bnez.n	a10, 40377d4c <esp_flash_get_physical_size+0x54>
        return err;
    }
    uint32_t detect_size;
    err = chip->chip_drv->detect_size(chip, &detect_size);
40377d27:	41a8      	l32i.n	a10, a1, 16
40377d29:	01bd      	mov.n	a11, a1
40377d2b:	1a88      	l32i.n	a8, a10, 4
40377d2d:	4888      	l32i.n	a8, a8, 16
40377d2f:	0008e0        	callx8	a8
    if (err == ESP_OK) {
40377d32:	aacc      	bnez.n	a10, 40377d40 <esp_flash_get_physical_size+0x48>
        if (chip->size == 0) {
40377d34:	4198      	l32i.n	a9, a1, 16
            // chip->size will not be changed if detected, it will always be equal to configured flash size.
            chip->size = detect_size;
40377d36:	0188      	l32i.n	a8, a1, 0
        if (chip->size == 0) {
40377d38:	59b8      	l32i.n	a11, a9, 20
40377d3a:	0bcc      	bnez.n	a11, 40377d3e <esp_flash_get_physical_size+0x46>
            chip->size = detect_size;
40377d3c:	5989      	s32i.n	a8, a9, 20
        }
        *flash_size = detect_size;
40377d3e:	0389      	s32i.n	a8, a3, 0
    }
    return rom_spiflash_api_funcs->end(chip, err);
40377d40:	0228      	l32i.n	a2, a2, 0
40377d42:	0abd      	mov.n	a11, a10
40377d44:	1228      	l32i.n	a2, a2, 4
40377d46:	0421a2        	l32i	a10, a1, 16
40377d49:	0002e0        	callx8	a2
}
40377d4c:	0a2d      	mov.n	a2, a10
40377d4e:	f01d      	retw.n

40377d50 <esp_flash_init_main>:
{
40377d50:	006136        	entry	a1, 48
40377d53:	023d      	mov.n	a3, a2
        return ESP_ERR_INVALID_ARG;
40377d55:	02a122        	movi	a2, 0x102
    if (chip == NULL || chip->host == NULL || chip->host->driver == NULL ||
40377d58:	0b8316        	beqz	a3, 40377e14 <esp_flash_init_main+0xc4>
40377d5b:	0348      	l32i.n	a4, a3, 0
40377d5d:	0b3416        	beqz	a4, 40377e14 <esp_flash_init_main+0xc4>
40377d60:	0458      	l32i.n	a5, a4, 0
40377d62:	0ae516        	beqz	a5, 40377e14 <esp_flash_init_main+0xc4>
40377d65:	1448      	l32i.n	a4, a4, 4
40377d67:	0a9416        	beqz	a4, 40377e14 <esp_flash_init_main+0xc4>
    uint32_t flash_id = 0;
40377d6a:	020c      	movi.n	a2, 0
    octal_mode = (chip->read_mode >= SPI_FLASH_OPI_FLAG);
40377d6c:	4358      	l32i.n	a5, a3, 16
    uint32_t flash_id = 0;
40377d6e:	1129      	s32i.n	a2, a1, 4
    if (octal_mode) {
40377d70:	f20c      	movi.n	a2, 15
40377d72:	023257        	bltu	a2, a5, 40377d78 <esp_flash_init_main+0x28>
40377d75:	002046        	j	40377dfa <esp_flash_init_main+0xaa>
        flash_id = g_rom_flashchip.device_id;
40377d78:	f29f21        	l32r	a2, 403747f4 <_iram_text_start+0x3f0>
40377d7b:	0228      	l32i.n	a2, a2, 0
40377d7d:	0228      	l32i.n	a2, a2, 0
40377d7f:	1129      	s32i.n	a2, a1, 4
    chip->chip_id = flash_id;
40377d81:	1128      	l32i.n	a2, a1, 4
    if (!esp_flash_chip_driver_initialized(chip)) {
40377d83:	03ad      	mov.n	a10, a3
    chip->chip_id = flash_id;
40377d85:	6329      	s32i.n	a2, a3, 24
    if (!esp_flash_chip_driver_initialized(chip)) {
40377d87:	f2d381        	l32r	a8, 403748d4 <_iram_text_start+0x4d0>
40377d8a:	0008e0        	callx8	a8
40377d8d:	08da16        	beqz	a10, 40377e1e <esp_flash_init_main+0xce>
    err = esp_flash_get_physical_size(chip, &size);
40377d90:	01bd      	mov.n	a11, a1
40377d92:	03ad      	mov.n	a10, a3
40377d94:	fff625        	call8	40377cf8 <esp_flash_get_physical_size>
40377d97:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377d99:	077a56        	bnez	a10, 40377e14 <esp_flash_init_main+0xc4>
    if (chip->chip_drv->get_chip_caps == NULL) {
40377d9c:	1328      	l32i.n	a2, a3, 4
40377d9e:	1d2222        	l32i	a2, a2, 116
40377da1:	013216        	beqz	a2, 40377db8 <esp_flash_init_main+0x68>
        if (((chip->chip_drv->get_chip_caps(chip) & SPI_FLASH_CHIP_CAP_32MB_SUPPORT) == 0) && (size > (16 *1024 * 1024))) {
40377da4:	03ad      	mov.n	a10, a3
40377da6:	0002e0        	callx8	a2
40377da9:	0bea17        	bbsi	a10, 1, 40377db8 <esp_flash_init_main+0x68>
40377dac:	120c      	movi.n	a2, 1
40377dae:	0148      	l32i.n	a4, a1, 0
40377db0:	012280        	slli	a2, a2, 24
40377db3:	01b247        	bgeu	a2, a4, 40377db8 <esp_flash_init_main+0x68>
            size = (16 * 1024 * 1024);
40377db6:	0129      	s32i.n	a2, a1, 0
    err = rom_spiflash_api_funcs->start(chip);
40377db8:	f2c541        	l32r	a4, 403748cc <_iram_text_start+0x4c8>
40377dbb:	03ad      	mov.n	a10, a3
40377dbd:	0428      	l32i.n	a2, a4, 0
40377dbf:	0228      	l32i.n	a2, a2, 0
40377dc1:	0002e0        	callx8	a2
40377dc4:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
40377dc6:	04aa56        	bnez	a10, 40377e14 <esp_flash_init_main+0xc4>
    if (err == ESP_OK && !octal_mode) {
40377dc9:	f80c      	movi.n	a8, 15
40377dcb:	173857        	bltu	a8, a5, 40377de6 <esp_flash_init_main+0x96>
        err = chip->chip_drv->set_io_mode(chip);
40377dce:	1358      	l32i.n	a5, a3, 4
40377dd0:	03ad      	mov.n	a10, a3
40377dd2:	162552        	l32i	a5, a5, 88
40377dd5:	0005e0        	callx8	a5
        if (err == ESP_ERR_FLASH_NO_RESPONSE && !esp_flash_is_quad_mode(chip)) {
40377dd8:	08a152        	movi	a5, 0x108
40377ddb:	0a9a57        	bne	a10, a5, 40377de9 <esp_flash_init_main+0x99>
 *
 * @return true if flash works in quad mode, otherwise false
 */
static inline bool esp_flash_is_quad_mode(const esp_flash_t *chip)
{
    return (chip->read_mode == SPI_FLASH_QIO) || (chip->read_mode == SPI_FLASH_QOUT);
40377dde:	4388      	l32i.n	a8, a3, 16
40377de0:	fcc882        	addi	a8, a8, -4
40377de3:	0228b6        	bltui	a8, 2, 40377de9 <esp_flash_init_main+0x99>
            err = ESP_OK;
40377de6:	20a220        	or	a10, a2, a2
    return rom_spiflash_api_funcs->end(chip, err);
40377de9:	0428      	l32i.n	a2, a4, 0
40377deb:	0abd      	mov.n	a11, a10
40377ded:	1228      	l32i.n	a2, a2, 4
40377def:	03ad      	mov.n	a10, a3
40377df1:	0002e0        	callx8	a2
40377df4:	0a2d      	mov.n	a2, a10
40377df6:	000686        	j	40377e14 <esp_flash_init_main+0xc4>
40377df9:	00          	.byte 00
40377dfa:	b40c      	movi.n	a4, 11
            err = esp_flash_read_chip_id(chip, &flash_id);
40377dfc:	b14b      	addi.n	a11, a1, 4
40377dfe:	03ad      	mov.n	a10, a3
40377e00:	f2b881        	l32r	a8, 403748e0 <_iram_text_start+0x4dc>
40377e03:	0008e0        	callx8	a8
        } while (err == ESP_ERR_FLASH_NOT_INITIALISED && retries-- > 0);
40377e06:	f2b481        	l32r	a8, 403748d8 <_iram_text_start+0x4d4>
            err = esp_flash_read_chip_id(chip, &flash_id);
40377e09:	0a2d      	mov.n	a2, a10
        } while (err == ESP_ERR_FLASH_NOT_INITIALISED && retries-- > 0);
40377e0b:	099a87        	bne	a10, a8, 40377e18 <esp_flash_init_main+0xc8>
40377e0e:	ffc442        	addi	a4, a4, -1
40377e11:	fe7456        	bnez	a4, 40377dfc <esp_flash_init_main+0xac>
}
40377e14:	f01d      	retw.n
40377e16:	00          	.byte 00
40377e17:	00          	.byte 00
    if (err != ESP_OK) {
40377e18:	f65a16        	beqz	a10, 40377d81 <esp_flash_init_main+0x31>
40377e1b:	fffd46        	j	40377e14 <esp_flash_init_main+0xc4>
        err = detect_spi_flash_chip(chip);
40377e1e:	03ad      	mov.n	a10, a3
40377e20:	ffe125        	call8	40377c34 <detect_spi_flash_chip>
40377e23:	0a2d      	mov.n	a2, a10
        if (err != ESP_OK) {
40377e25:	f67a16        	beqz	a10, 40377d90 <esp_flash_init_main+0x40>
40377e28:	fffa06        	j	40377e14 <esp_flash_init_main+0xc4>
	...

40377e2c <release_buffer_malloc>:
    *out_size = (ret != NULL? read_chunk_size: 0);
    return ret;
}

static IRAM_ATTR void release_buffer_malloc(void* arg, void *temp_buf)
{
40377e2c:	004136        	entry	a1, 32
    free(temp_buf);
40377e2f:	03ad      	mov.n	a10, a3
40377e31:	06afa5        	call8	4037e92c <cfree>
}
40377e34:	f01d      	retw.n
	...

40377e38 <get_buffer_malloc>:
{
40377e38:	004136        	entry	a1, 32
40377e3b:	650c      	movi.n	a5, 6
        read_chunk_size = (read_chunk_size + 3) & ~3;
40377e3d:	fcaf62        	movi	a6, -4
    while(ret == NULL && retries--) {
40377e40:	550b      	addi.n	a5, a5, -1
40377e42:	75cc      	bnez.n	a5, 40377e4d <get_buffer_malloc+0x15>
    *out_size = (ret != NULL? read_chunk_size: 0);
40377e44:	053d      	mov.n	a3, a5
40377e46:	052d      	mov.n	a2, a5
40377e48:	000d86        	j	40377e82 <get_buffer_malloc+0x4a>
40377e4b:	00          	.byte 00
40377e4c:	00          	.byte 00
        read_chunk_size = MIN(read_chunk_size, heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT));
40377e4d:	01a222        	movi	a2, 0x201
40377e50:	1122e0        	slli	a2, a2, 2
40377e53:	20a220        	or	a10, a2, a2
40377e56:	f2a381        	l32r	a8, 403748e4 <_iram_text_start+0x4e0>
40377e59:	0008e0        	callx8	a8
40377e5c:	0a33a7        	bltu	a3, a10, 40377e6a <get_buffer_malloc+0x32>
40377e5f:	20a220        	or	a10, a2, a2
40377e62:	f2a081        	l32r	a8, 403748e4 <_iram_text_start+0x4e0>
40377e65:	0008e0        	callx8	a8
40377e68:	0a3d      	mov.n	a3, a10
        read_chunk_size = (read_chunk_size + 3) & ~3;
40377e6a:	03c332        	addi	a3, a3, 3
40377e6d:	103360        	and	a3, a3, a6
        ret = heap_caps_malloc(read_chunk_size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
40377e70:	01a2b2        	movi	a11, 0x201
40377e73:	11bbe0        	slli	a11, a11, 2
40377e76:	20a330        	or	a10, a3, a3
40377e79:	fdebe5        	call8	40375d38 <heap_caps_malloc>
40377e7c:	202aa0        	or	a2, a10, a10
    while(ret == NULL && retries--) {
40377e7f:	fbda16        	beqz	a10, 40377e40 <get_buffer_malloc+0x8>
    *out_size = (ret != NULL? read_chunk_size: 0);
40377e82:	0439      	s32i.n	a3, a4, 0
}
40377e84:	f01d      	retw.n
	...

40377e88 <delay_us>:
{
40377e88:	004136        	entry	a1, 32
    esp_rom_delay_us(us);
40377e8b:	20a330        	or	a10, a3, a3
40377e8e:	f16c81        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40377e91:	0008e0        	callx8	a8
}
40377e94:	020c      	movi.n	a2, 0
40377e96:	f01d      	retw.n

40377e98 <main_flash_op_status>:
    }
}


static IRAM_ATTR void main_flash_op_status(uint32_t op_status)
{
40377e98:	004136        	entry	a1, 32
    bool is_erasing = op_status & SPI_FLASH_OS_IS_ERASING_STATUS_FLAG;
    spi_flash_set_erasing_flag(is_erasing);
40377e9b:	04a020        	extui	a10, a2, 0, 1
40377e9e:	06b1e5        	call8	4037e9bc <spi_flash_set_erasing_flag>
}
40377ea1:	f01d      	retw.n
	...

40377ea4 <spi1_flash_os_yield>:
{
40377ea4:	004136        	entry	a1, 32
    if (likely(xTaskGetSchedulerState() == taskSCHEDULER_RUNNING)) {
40377ea7:	03dd25        	call8	4037bc78 <xTaskGetSchedulerState>
40377eaa:	052a66        	bnei	a10, 2, 40377eb3 <spi1_flash_os_yield+0xf>
        vTaskDelay(CONFIG_SPI_FLASH_ERASE_YIELD_TICKS);
40377ead:	01a0a2        	movi	a10, 1
40377eb0:	03ee25        	call8	4037bd94 <vTaskDelay>
    // in that function instead.
}

static inline IRAM_ATTR void on_spi1_yielded(spi1_app_func_arg_t* ctx)
{
    uint32_t time = esp_system_get_time();
40377eb3:	ff2c25        	call8	40377174 <esp_system_get_time>
40377eb6:	22a9      	s32i.n	a10, a2, 8
}
40377eb8:	020c      	movi.n	a2, 0
40377eba:	f01d      	retw.n

40377ebc <spi1_flash_os_check_yield>:
{
40377ebc:	004136        	entry	a1, 32
    assert (chip_status == 0);  //TODO: support suspend
40377ebf:	00e316        	beqz	a3, 40377ed1 <spi1_flash_os_check_yield+0x15>
40377ec2:	f289d1        	l32r	a13, 403748e8 <_iram_text_start+0x4e4>
40377ec5:	f289c1        	l32r	a12, 403748ec <_iram_text_start+0x4e8>
40377ec8:	f28aa1        	l32r	a10, 403748f0 <_iram_text_start+0x4ec>
40377ecb:	79a0b2        	movi	a11, 121
40377ece:	0693e5        	call8	4037e80c <__assert_func>
    uint32_t time = esp_system_get_time();
40377ed1:	ff2a25        	call8	40377174 <esp_system_get_time>
    if ((time - ctx->released_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_TICKS * portTICK_PERIOD_MS * 1000) {
40377ed4:	3288      	l32i.n	a8, a2, 12
40377ed6:	f28791        	l32r	a9, 403748f4 <_iram_text_start+0x4f0>
40377ed9:	c08a80        	sub	a8, a10, a8
40377edc:	0ab987        	bgeu	a9, a8, 40377eea <spi1_flash_os_check_yield+0x2e>
        ctx->acquired_since_us = time;
40377edf:	22a9      	s32i.n	a10, a2, 8
    esp_err_t ret = ESP_ERR_TIMEOUT;    //Nothing happened
40377ee1:	07a122        	movi	a2, 0x107
    if (out_request) {
40377ee4:	048c      	beqz.n	a4, 40377ee8 <spi1_flash_os_check_yield+0x2c>
        *out_request = request;
40377ee6:	0439      	s32i.n	a3, a4, 0
}
40377ee8:	f01d      	retw.n
    } else if ((time - ctx->acquired_since_us) >= CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS * 1000) {
40377eea:	2228      	l32i.n	a2, a2, 8
40377eec:	c0aa20        	sub	a10, a10, a2
40377eef:	f28221        	l32r	a2, 403748f8 <_iram_text_start+0x4f4>
40377ef2:	ebb2a7        	bgeu	a2, a10, 40377ee1 <spi1_flash_os_check_yield+0x25>
        request = SPI_FLASH_YIELD_REQ_YIELD;
40377ef5:	130c      	movi.n	a3, 1
        ret = ESP_OK;
40377ef7:	020c      	movi.n	a2, 0
40377ef9:	fff9c6        	j	40377ee4 <spi1_flash_os_check_yield+0x28>

40377efc <main_flash_region_protected>:
{
40377efc:	004136        	entry	a1, 32
    if (((spi1_app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40377eff:	040222        	l8ui	a2, a2, 4
{
40377f02:	20a330        	or	a10, a3, a3
40377f05:	20b440        	or	a11, a4, a4
    if (((spi1_app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40377f08:	00a256        	bnez	a2, 40377f16 <main_flash_region_protected+0x1a>
40377f0b:	f27c81        	l32r	a8, 403748fc <_iram_text_start+0x4f8>
40377f0e:	0008e0        	callx8	a8
        return ESP_ERR_NOT_SUPPORTED;
40377f11:	06a122        	movi	a2, 0x106
    if (((spi1_app_func_arg_t*)arg)->no_protect || esp_partition_main_flash_region_safe(start_addr, size)) {
40377f14:	0a8c      	beqz.n	a10, 40377f18 <main_flash_region_protected+0x1c>
        return ESP_OK;
40377f16:	020c      	movi.n	a2, 0
}
40377f18:	f01d      	retw.n
	...

40377f1c <cache_disable$constprop$0>:
IRAM_ATTR static void cache_disable(void* arg)
40377f1c:	004136        	entry	a1, 32
    spi_flash_disable_interrupts_caches_and_other_cpu();
40377f1f:	ff69a5        	call8	403775b8 <spi_flash_disable_interrupts_caches_and_other_cpu>
}
40377f22:	f01d      	retw.n

40377f24 <spi1_start>:
{
40377f24:	004136        	entry	a1, 32
    cache_disable(NULL);
40377f27:	ffff65        	call8	40377f1c <cache_disable$constprop$0>
}
40377f2a:	020c      	movi.n	a2, 0
40377f2c:	f01d      	retw.n
	...

40377f30 <cache_enable$constprop$0>:
IRAM_ATTR static void cache_enable(void* arg)
40377f30:	004136        	entry	a1, 32
    spi_flash_enable_interrupts_caches_and_other_cpu();
40377f33:	ff76a5        	call8	4037769c <spi_flash_enable_interrupts_caches_and_other_cpu>
}
40377f36:	f01d      	retw.n

40377f38 <spi1_end>:
{
40377f38:	004136        	entry	a1, 32
    cache_enable(NULL);
40377f3b:	ffff65        	call8	40377f30 <cache_enable$constprop$0>
    ctx->released_since_us = esp_system_get_time();
40377f3e:	ff2365        	call8	40377174 <esp_system_get_time>
40377f41:	0362a2        	s32i	a10, a2, 12
}
40377f44:	00a022        	movi	a2, 0
40377f47:	f01d      	retw.n
40377f49:	000000        	ill

40377f4c <delay_us>:
#endif
    return ESP_OK;
}

static IRAM_ATTR esp_err_t delay_us(void *arg, uint32_t us)
{
40377f4c:	004136        	entry	a1, 32
    esp_rom_delay_us(us);
40377f4f:	20a330        	or	a10, a3, a3
40377f52:	f13b81        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40377f55:	0008e0        	callx8	a8
    return ESP_OK;
}
40377f58:	020c      	movi.n	a2, 0
40377f5a:	f01d      	retw.n

40377f5c <end>:
{
40377f5c:	004136        	entry	a1, 32
    Cache_Invalidate_ICache_All();
40377f5f:	f26881        	l32r	a8, 40374900 <_iram_text_start+0x4fc>
40377f62:	0008e0        	callx8	a8
    Cache_Resume_ICache(spi_arg->icache_autoload);
40377f65:	0022a2        	l32i	a10, a2, 0
40377f68:	f22d81        	l32r	a8, 4037481c <_iram_text_start+0x418>
40377f6b:	0008e0        	callx8	a8
    Cache_Resume_DCache(spi_arg->dcache_autoload);
40377f6e:	12a8      	l32i.n	a10, a2, 4
}
40377f70:	020c      	movi.n	a2, 0
    Cache_Resume_DCache(spi_arg->dcache_autoload);
40377f72:	f14481        	l32r	a8, 40374484 <_iram_text_start+0x80>
40377f75:	0008e0        	callx8	a8
}
40377f78:	f01d      	retw.n
	...

40377f7c <start>:
{
40377f7c:	004136        	entry	a1, 32
    spi_arg->icache_autoload = Cache_Suspend_ICache();
40377f7f:	f22681        	l32r	a8, 40374818 <_iram_text_start+0x414>
40377f82:	0008e0        	callx8	a8
40377f85:	02a9      	s32i.n	a10, a2, 0
    spi_arg->dcache_autoload = Cache_Suspend_DCache();
40377f87:	f13d81        	l32r	a8, 4037447c <_iram_text_start+0x78>
40377f8a:	0008e0        	callx8	a8
40377f8d:	12a9      	s32i.n	a10, a2, 4
}
40377f8f:	020c      	movi.n	a2, 0
40377f91:	f01d      	retw.n
	...

40377f94 <esp_crosscore_isr>:
static inline void IRAM_ATTR esp_crosscore_isr_handle_yield(void)
{
    portYIELD_FROM_ISR();
}

static void IRAM_ATTR esp_crosscore_isr(void *arg) {
40377f94:	004136        	entry	a1, 32
40377f97:	03eb30        	rsr.prid	a3
40377f9a:	043d30        	extui	a3, a3, 13, 1
        DPORT_WRITE_PERI_REG(DPORT_CPU_INTR_FROM_CPU_1_REG, 0);
    }
#elif CONFIG_IDF_TARGET_ESP32S2
    DPORT_WRITE_PERI_REG(DPORT_CPU_INTR_FROM_CPU_0_REG, 0);
#elif CONFIG_IDF_TARGET_ESP32S3
    if (esp_cpu_get_core_id()==0) {
40377f9d:	03f356        	bnez	a3, 40377fe0 <esp_crosscore_isr+0x4c>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, 0);
40377fa0:	f25941        	l32r	a4, 40374904 <_iram_text_start+0x500>
40377fa3:	0020c0        	memw
40377fa6:	0439      	s32i.n	a3, a4, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
40377fa8:	f25941        	l32r	a4, 4037490c <_iram_text_start+0x508>
40377fab:	fb7c      	movi.n	a11, -1
40377fad:	04ad      	mov.n	a10, a4
40377faf:	046025        	call8	4037c5b0 <xPortEnterCriticalTimeout>
#endif

    //Grab the reason and clear it.
    portENTER_CRITICAL_ISR(&reason_spinlock);
    my_reason_val=*my_reason;
    *my_reason=0;
40377fb2:	080c      	movi.n	a8, 0
    my_reason_val=*my_reason;
40377fb4:	0020c0        	memw
40377fb7:	0238      	l32i.n	a3, a2, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40377fb9:	04ad      	mov.n	a10, a4
    *my_reason=0;
40377fbb:	0020c0        	memw
40377fbe:	0289      	s32i.n	a8, a2, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40377fc0:	047225        	call8	4037c6e4 <vPortExitCritical>

    //Check what we need to do.
    if (my_reason_val & REASON_YIELD) {
40377fc3:	026307        	bbci	a3, 0, 40377fc9 <esp_crosscore_isr+0x35>
    portYIELD_FROM_ISR();
40377fc6:	01f325        	call8	40379ef8 <_frxt_setup_switch>
    if (my_reason_val & REASON_GDB_CALL) {
        update_breakpoints();
    }
#endif // !CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME
#if CONFIG_IDF_TARGET_ARCH_XTENSA // IDF-2986
    if (my_reason_val & REASON_PRINT_BACKTRACE) {
40377fc9:	056327        	bbci	a3, 2, 40377fd2 <esp_crosscore_isr+0x3e>
        esp_backtrace_print(100);
40377fcc:	64a0a2        	movi	a10, 100
40377fcf:	fdae25        	call8	40375ab0 <esp_backtrace_print>
    }

#if CONFIG_ESP_TASK_WDT_EN
    if (my_reason_val & REASON_TWDT_ABORT) {
40377fd2:	076347        	bbci	a3, 4, 40377fdd <esp_crosscore_isr+0x49>
        extern void task_wdt_timeout_abort_xtensa(bool);
        /* Called from a crosscore interrupt, thus, we are not the core that received
         * the TWDT interrupt, call the function with `false` as a parameter. */
        task_wdt_timeout_abort_xtensa(false);
40377fd5:	0a0c      	movi.n	a10, 0
40377fd7:	f24e81        	l32r	a8, 40374910 <_iram_text_start+0x50c>
40377fda:	0008e0        	callx8	a8
    }
#endif // CONFIG_ESP_TASK_WDT_EN
#endif // CONFIG_IDF_TARGET_ARCH_XTENSA
}
40377fdd:	f01d      	retw.n
40377fdf:	00          	.byte 00
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, 0);
40377fe0:	f24a31        	l32r	a3, 40374908 <_iram_text_start+0x504>
40377fe3:	040c      	movi.n	a4, 0
40377fe5:	0020c0        	memw
40377fe8:	0349      	s32i.n	a4, a3, 0
40377fea:	ffee86        	j	40377fa8 <esp_crosscore_isr+0x14>
40377fed:	000000        	ill

40377ff0 <esp_crosscore_int_send>:
    err = esp_intr_alloc(ETS_FROM_CPU_INTR0_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[0], NULL);
#endif
    ESP_ERROR_CHECK(err);
}

static void IRAM_ATTR esp_crosscore_int_send(int core_id, uint32_t reason_mask) {
40377ff0:	004136        	entry	a1, 32
    assert(core_id<portNUM_PROCESSORS);
40377ff3:	0e22a6        	blti	a2, 2, 40378005 <_diram_i_start+0x5>
40377ff6:	f247d1        	l32r	a13, 40374914 <_iram_text_start+0x510>
40377ff9:	f247c1        	l32r	a12, 40374918 <_iram_text_start+0x514>
40377ffc:	f248a1        	l32r	a10, 4037491c <_iram_text_start+0x518>
40377fff:	82a0b2        	movi	a11, 130
40378002:	0680a5        	call8	4037e80c <__assert_func>
40378005:	f24141        	l32r	a4, 4037490c <_iram_text_start+0x508>
40378008:	ffafb2        	movi	a11, -1
4037800b:	04ad      	mov.n	a10, a4
4037800d:	045a25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    //Mark the reason we interrupt the other CPU
    portENTER_CRITICAL_ISR(&reason_spinlock);
    reason[core_id] |= reason_mask;
40378010:	f24481        	l32r	a8, 40374920 <_iram_text_start+0x51c>
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40378013:	04ad      	mov.n	a10, a4
    reason[core_id] |= reason_mask;
40378015:	a08280        	addx4	a8, a2, a8
40378018:	0020c0        	memw
4037801b:	0898      	l32i.n	a9, a8, 0
4037801d:	209930        	or	a9, a9, a3
40378020:	0020c0        	memw
40378023:	0899      	s32i.n	a9, a8, 0
    portEXIT_CRITICAL_ISR(&reason_spinlock);
40378025:	046be5        	call8	4037c6e4 <vPortExitCritical>
        DPORT_WRITE_PERI_REG(DPORT_CPU_INTR_FROM_CPU_1_REG, DPORT_CPU_INTR_FROM_CPU_1);
    }
#elif CONFIG_IDF_TARGET_ESP32S2
    DPORT_WRITE_PERI_REG(DPORT_CPU_INTR_FROM_CPU_0_REG, DPORT_CPU_INTR_FROM_CPU_0);
#elif CONFIG_IDF_TARGET_ESP32S3
    if (core_id==0) {
40378028:	180c      	movi.n	a8, 1
4037802a:	a2cc      	bnez.n	a2, 40378038 <_diram_i_start+0x38>
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, SYSTEM_CPU_INTR_FROM_CPU_0);
4037802c:	f23621        	l32r	a2, 40374904 <_iram_text_start+0x500>
    } else {
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, SYSTEM_CPU_INTR_FROM_CPU_1);
4037802f:	0020c0        	memw
40378032:	0289      	s32i.n	a8, a2, 0
    }
#elif CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_0_REG, SYSTEM_CPU_INTR_FROM_CPU_0);
#endif
}
40378034:	f01d      	retw.n
40378036:	00          	.byte 00
40378037:	00          	.byte 00
        WRITE_PERI_REG(SYSTEM_CPU_INTR_FROM_CPU_1_REG, SYSTEM_CPU_INTR_FROM_CPU_1);
40378038:	f23421        	l32r	a2, 40374908 <_iram_text_start+0x504>
4037803b:	fffc06        	j	4037802f <_diram_i_start+0x2f>
	...

40378040 <esp_crosscore_int_send_yield>:

void IRAM_ATTR esp_crosscore_int_send_yield(int core_id)
{
40378040:	004136        	entry	a1, 32
    esp_crosscore_int_send(core_id, REASON_YIELD);
40378043:	01a0b2        	movi	a11, 1
40378046:	20a220        	or	a10, a2, a2
40378049:	fffa65        	call8	40377ff0 <esp_crosscore_int_send>
}
4037804c:	000090        	retw
	...

40378050 <esp_crosscore_int_send_print_backtrace>:
    esp_crosscore_int_send(core_id, REASON_GDB_CALL);
}

#if !CONFIG_IDF_TARGET_ESP32C3 && !CONFIG_IDF_TARGET_ESP32H2 && !IDF_TARGET_ESP32C2
void IRAM_ATTR esp_crosscore_int_send_print_backtrace(int core_id)
{
40378050:	004136        	entry	a1, 32
    esp_crosscore_int_send(core_id, REASON_PRINT_BACKTRACE);
40378053:	04a0b2        	movi	a11, 4
40378056:	20a220        	or	a10, a2, a2
40378059:	fff965        	call8	40377ff0 <esp_crosscore_int_send>
}
4037805c:	000090        	retw
	...

40378060 <esp_crosscore_int_send_twdt_abort>:

#if CONFIG_ESP_TASK_WDT_EN
void IRAM_ATTR esp_crosscore_int_send_twdt_abort(int core_id) {
40378060:	004136        	entry	a1, 32
    esp_crosscore_int_send(core_id, REASON_TWDT_ABORT);
40378063:	10a0b2        	movi	a11, 16
40378066:	20a220        	or	a10, a2, a2
40378069:	fff865        	call8	40377ff0 <esp_crosscore_int_send>
}
4037806c:	000090        	retw
	...

40378070 <ipc_task>:
static volatile esp_ipc_func_t s_gcov_func = NULL;           // Gcov dump starter function which should be called by high priority task
static void * volatile s_gcov_func_arg;                      // Argument to pass into s_gcov_func
#endif

static void IRAM_ATTR ipc_task(void* arg)
{
40378070:	004136        	entry	a1, 32
40378073:	03eb30        	rsr.prid	a3
40378076:	043d30        	extui	a3, a3, 13, 1
    const int cpuid = (int) arg;
    assert(cpuid == xPortGetCoreID());
40378079:	101237        	beq	a2, a3, 4037808d <ipc_task+0x1d>
4037807c:	f22ad1        	l32r	a13, 40374924 <_iram_text_start+0x520>
4037807f:	f22ac1        	l32r	a12, 40374928 <_iram_text_start+0x524>
40378082:	f22aa1        	l32r	a10, 4037492c <_iram_text_start+0x528>
40378085:	8b3c      	movi.n	a11, 56
40378087:	201110        	or	a1, a1, a1
4037808a:	067825        	call8	4037e80c <__assert_func>
#ifdef CONFIG_ESP_IPC_ISR_ENABLE
    esp_ipc_isr_init();
4037808d:	f22d81        	l32r	a8, 40374944 <_iram_text_start+0x540>
40378090:	0008e0        	callx8	a8
#endif
    while (true) {
        // Wait for IPC to be initiated.
        // This will be indicated by giving the semaphore corresponding to
        // this CPU.
        if (xSemaphoreTake(s_ipc_sem[cpuid], portMAX_DELAY) != pdTRUE) {
40378093:	f22751        	l32r	a5, 40374930 <_iram_text_start+0x52c>
            s_gcov_func = NULL;
            /* we can not interfer with IPC calls so no need for further processing */
            continue;
        }
#endif
        if (s_func[cpuid]) {
40378096:	f22731        	l32r	a3, 40374934 <_iram_text_start+0x530>
        if (xSemaphoreTake(s_ipc_sem[cpuid], portMAX_DELAY) != pdTRUE) {
40378099:	1142e0        	slli	a4, a2, 2
4037809c:	a05250        	addx4	a5, a2, a5
        if (s_func[cpuid]) {
4037809f:	a02230        	addx4	a2, a2, a3
        if (xSemaphoreTake(s_ipc_sem[cpuid], portMAX_DELAY) != pdTRUE) {
403780a2:	0025a2        	l32i	a10, a5, 0
403780a5:	ffafb2        	movi	a11, -1
403780a8:	02a265        	call8	4037aad0 <xQueueSemaphoreTake>
403780ab:	021a26        	beqi	a10, 1, 403780b1 <ipc_task+0x41>
            abort();
403780ae:	066ce5        	call8	4037e77c <abort>
        if (s_func[cpuid]) {
403780b1:	0020c0        	memw
403780b4:	002232        	l32i	a3, a2, 0
403780b7:	fe7316        	beqz	a3, 403780a2 <ipc_task+0x32>
            // we need to cache s_func, s_func_arg and s_ipc_wait variables locally because they can be changed by a subsequent IPC call.
            esp_ipc_func_t func = s_func[cpuid];
            s_func[cpuid] = NULL;
403780ba:	00a032        	movi	a3, 0
            esp_ipc_func_t func = s_func[cpuid];
403780bd:	0020c0        	memw
403780c0:	002262        	l32i	a6, a2, 0
            s_func[cpuid] = NULL;
403780c3:	0020c0        	memw
403780c6:	0239      	s32i.n	a3, a2, 0
            void* arg = s_func_arg[cpuid];
403780c8:	f21c31        	l32r	a3, 40374938 <_iram_text_start+0x534>
403780cb:	334a      	add.n	a3, a3, a4
403780cd:	0020c0        	memw
403780d0:	0378      	l32i.n	a7, a3, 0
            esp_ipc_wait_t ipc_wait = s_ipc_wait[cpuid];
403780d2:	f21a31        	l32r	a3, 4037493c <_iram_text_start+0x538>
403780d5:	334a      	add.n	a3, a3, a4
403780d7:	0020c0        	memw
403780da:	0338      	l32i.n	a3, a3, 0

            if (ipc_wait == IPC_WAIT_FOR_START) {
403780dc:	e3cc      	bnez.n	a3, 403780ee <ipc_task+0x7e>
                xSemaphoreGive(s_ipc_ack[cpuid]);
403780de:	f21881        	l32r	a8, 40374940 <_iram_text_start+0x53c>
403780e1:	03dd      	mov.n	a13, a3
403780e3:	884a      	add.n	a8, a8, a4
403780e5:	08a8      	l32i.n	a10, a8, 0
403780e7:	03cd      	mov.n	a12, a3
403780e9:	03bd      	mov.n	a11, a3
403780eb:	026025        	call8	4037a6ec <xQueueGenericSend>
            }
            (*func)(arg);
403780ee:	20a770        	or	a10, a7, a7
403780f1:	0006e0        	callx8	a6
            if (ipc_wait == IPC_WAIT_FOR_END) {
403780f4:	aa1366        	bnei	a3, 1, 403780a2 <ipc_task+0x32>
                xSemaphoreGive(s_ipc_ack[cpuid]);
403780f7:	f21231        	l32r	a3, 40374940 <_iram_text_start+0x53c>
403780fa:	00a0d2        	movi	a13, 0
403780fd:	803340        	add	a3, a3, a4
40378100:	03a8      	l32i.n	a10, a3, 0
40378102:	0dcd      	mov.n	a12, a13
40378104:	0dbd      	mov.n	a11, a13
40378106:	025e65        	call8	4037a6ec <xQueueGenericSend>
40378109:	ffe546        	j	403780a2 <ipc_task+0x32>

4037810c <_xt_panic>:
    .literal_position
    .align      4

_xt_panic:
    /* Allocate exception frame and save minimal context. */
    mov     a0, sp
4037810c:	010d      	mov.n	a0, a1
    addi    sp, sp, -XT_STK_FRMSZ
4037810e:	ffd112        	addmi	a1, a1, 0xffffff00
40378111:	40c112        	addi	a1, a1, 64
    s32i    a0, sp, XT_STK_A1
40378114:	4109      	s32i.n	a0, a1, 16
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -12                     /* for debug backtrace */
40378116:	49d100        	s32e	a0, a1, -12
    #endif
    rsr     a0, PS                          /* save interruptee's PS */
40378119:	03e600        	rsr.ps	a0
    s32i    a0, sp, XT_STK_PS
4037811c:	2109      	s32i.n	a0, a1, 8
    rsr     a0, EPC_1                       /* save interruptee's PC */
4037811e:	03b100        	rsr.epc1	a0
    s32i    a0, sp, XT_STK_PC
40378121:	1109      	s32i.n	a0, a1, 4
    rsr     a0, EXCSAVE_1                   /* save interruptee's a0 */
40378123:	03d100        	rsr.excsave1	a0
    s32i    a0, sp, XT_STK_A0
40378126:	3109      	s32i.n	a0, a1, 12
    #if XCHAL_HAVE_WINDOWED
    s32e    a0, sp, -16                     /* for debug backtrace */
40378128:	49c100        	s32e	a0, a1, -16
    #endif
    s32i    a12, sp, XT_STK_A12             /* _xt_context_save requires A12- */
4037812b:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, sp, XT_STK_A13             /* A13 to have already been saved */
4037812d:	1061d2        	s32i	a13, a1, 64
    call0   _xt_context_save
40378130:	01f5c5        	call0	4037a090 <_xt_context_save>

    /* Save exc cause and vaddr into exception frame */
    rsr     a0, EXCCAUSE
40378133:	03e800        	rsr.exccause	a0
    s32i    a0, sp, XT_STK_EXCCAUSE
40378136:	146102        	s32i	a0, a1, 80
    rsr     a0, EXCVADDR
40378139:	03ee00        	rsr.excvaddr	a0
    s32i    a0, sp, XT_STK_EXCVADDR
4037813c:	156102        	s32i	a0, a1, 84

    /* Set up PS for C, disable all interrupts except NMI and debug, and clear EXCM. */
    movi    a0, PS_INTLEVEL(XCHAL_DEBUGLEVEL - 2) | PS_UM | PS_WOE
4037813f:	f17501        	l32r	a0, 40374714 <_iram_text_start+0x310>
    wsr     a0, PS
40378142:	13e600        	wsr.ps	a0

    //Call panic handler
    mov     a6,sp
40378145:	016d      	mov.n	a6, a1
    call4 panicHandler
40378147:	fd4fd5        	call4	40375644 <panicHandler>

    ret
4037814a:	f00d      	ret.n

4037814c <efuse_hal_chip_revision>:
    *((uint32_t*)&mac[0]) = efuse_ll_get_mac0();
    *((uint16_t*)&mac[4]) = (uint16_t) efuse_ll_get_mac1();
}

IRAM_ATTR uint32_t efuse_hal_chip_revision(void)
{
4037814c:	004136        	entry	a1, 32
    return efuse_hal_get_major_chip_version() * 100 + efuse_hal_get_minor_chip_version();
4037814f:	000165        	call8	40378164 <efuse_hal_get_major_chip_version>
40378152:	202aa0        	or	a2, a10, a10
40378155:	a02220        	addx4	a2, a2, a2
40378158:	000465        	call8	403781a0 <efuse_hal_get_minor_chip_version>
4037815b:	a02220        	addx4	a2, a2, a2
}
4037815e:	a022a0        	addx4	a2, a2, a10
40378161:	000090        	retw

40378164 <efuse_hal_get_major_chip_version>:
    return ((minor_raw & 0x7) == 0 &&
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
}

IRAM_ATTR uint32_t efuse_hal_get_major_chip_version(void)
{
40378164:	004136        	entry	a1, 32
}

// use efuse_hal_get_minor_chip_version() to get minor chip version
__attribute__((always_inline)) static inline uint32_t efuse_ll_get_chip_wafer_version_minor(void)
{
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_high << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_low;
40378167:	f1ab81        	l32r	a8, 40374814 <_iram_text_start+0x410>
4037816a:	0020c0        	memw
4037816d:	162822        	l32i	a2, a8, 88
40378170:	0020c0        	memw
40378173:	142822        	l32i	a2, a8, 80
    return ((minor_raw & 0x7) == 0 &&
40378176:	252220        	extui	a2, a2, 18, 3
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
40378179:	017256        	bnez	a2, 40378194 <efuse_hal_get_major_chip_version+0x30>
    return EFUSE.rd_repeat_data4.disable_wafer_version_major;
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_major(void)
{
    return EFUSE.rd_sys_part1_data4.blk_version_major;
4037817c:	0020c0        	memw
4037817f:	1b2892        	l32i	a9, a8, 108
40378182:	149090        	extui	a9, a9, 0, 2
    return ((minor_raw & 0x7) == 0 &&
40378185:	0b1966        	bnei	a9, 1, 40378194 <efuse_hal_get_major_chip_version+0x30>
}

__attribute__((always_inline)) static inline uint32_t efuse_ll_get_blk_version_minor(void)
{
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
40378188:	0020c0        	memw
4037818b:	142892        	l32i	a9, a8, 80
4037818e:	259890        	extui	a9, a9, 24, 3
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
40378191:	081926        	beqi	a9, 1, 4037819d <efuse_hal_get_major_chip_version+0x39>
    return EFUSE.rd_mac_spi_sys_5.wafer_version_major;
40378194:	0020c0        	memw
40378197:	162822        	l32i	a2, a8, 88
4037819a:	152820        	extui	a2, a2, 24, 2
        return 0;
    }
    return efuse_ll_get_chip_wafer_version_major();
}
4037819d:	f01d      	retw.n
	...

403781a0 <efuse_hal_get_minor_chip_version>:

IRAM_ATTR uint32_t efuse_hal_get_minor_chip_version(void)
{
403781a0:	004136        	entry	a1, 32
    return (EFUSE.rd_mac_spi_sys_5.wafer_version_minor_high << 3) + EFUSE.rd_mac_spi_sys_3.wafer_version_minor_low;
403781a3:	f19c91        	l32r	a9, 40374814 <_iram_text_start+0x410>
403781a6:	0020c0        	memw
403781a9:	162922        	l32i	a2, a9, 88
403781ac:	0020c0        	memw
403781af:	142982        	l32i	a8, a9, 80
403781b2:	052720        	extui	a2, a2, 23, 1
403781b5:	258280        	extui	a8, a8, 18, 3
403781b8:	b02280        	addx8	a2, a2, a8
            efuse_ll_get_blk_version_major() == 1 && efuse_ll_get_blk_version_minor() == 1);
403781bb:	98dc      	bnez.n	a8, 403781d8 <efuse_hal_get_minor_chip_version+0x38>
    return EFUSE.rd_sys_part1_data4.blk_version_major;
403781bd:	0020c0        	memw
403781c0:	1b29a2        	l32i	a10, a9, 108
403781c3:	14a0a0        	extui	a10, a10, 0, 2
    return ((minor_raw & 0x7) == 0 &&
403781c6:	0e1a66        	bnei	a10, 1, 403781d8 <efuse_hal_get_minor_chip_version+0x38>
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
403781c9:	0020c0        	memw
403781cc:	142992        	l32i	a9, a9, 80
403781cf:	259890        	extui	a9, a9, 24, 3
    uint32_t minor_raw = efuse_ll_get_chip_wafer_version_minor();

    if (is_eco0(minor_raw)) {
        return 0;
403781d2:	ffc992        	addi	a9, a9, -1
403781d5:	832890        	moveqz	a2, a8, a9
    }
    return minor_raw;
}
403781d8:	f01d      	retw.n
	...

403781dc <bootloader_read_status_8b_rdsr3>:
{
    return bootloader_execute_flash_command(CMD_RDSR2, 0, 0, 8);
}

IRAM_ATTR unsigned bootloader_read_status_8b_rdsr3(void)
{
403781dc:	004136        	entry	a1, 32
    return bootloader_execute_flash_command(CMD_RDSR3, 0, 0, 8);
403781df:	00a0c2        	movi	a12, 0
403781e2:	08a0d2        	movi	a13, 8
403781e5:	20bcc0        	or	a11, a12, a12
403781e8:	5a1c      	movi.n	a10, 21
403781ea:	ff2125        	call8	403773fc <bootloader_execute_flash_command>
}
403781ed:	0a2d      	mov.n	a2, a10
403781ef:	f01d      	retw.n
403781f1:	000000        	ill

403781f4 <bootloader_write_status_8b_wrsr3>:
{
    bootloader_execute_flash_command(CMD_WRSR2, new_status, 8, 0);
}

IRAM_ATTR void bootloader_write_status_8b_wrsr3(unsigned new_status)
{
403781f4:	004136        	entry	a1, 32
    bootloader_execute_flash_command(CMD_WRSR3, new_status, 8, 0);
403781f7:	00a0d2        	movi	a13, 0
403781fa:	08a0c2        	movi	a12, 8
403781fd:	20b220        	or	a11, a2, a2
40378200:	1a1c      	movi.n	a10, 17
40378202:	ff1fa5        	call8	403773fc <bootloader_execute_flash_command>
}
40378205:	f01d      	retw.n
	...

40378208 <esp_mspi_pin_init>:
{
40378208:	004136        	entry	a1, 32
}
4037820b:	f01d      	retw.n
4037820d:	000000        	ill

40378210 <spiflash_start_default>:
{
40378210:	004136        	entry	a1, 32
    if (chip->os_func != NULL && chip->os_func->start != NULL) {
40378213:	2288      	l32i.n	a8, a2, 8
40378215:	011856        	bnez	a8, 4037822a <spiflash_start_default+0x1a>
    chip->host->driver->dev_config(chip->host);
40378218:	02a8      	l32i.n	a10, a2, 0
4037821a:	0a28      	l32i.n	a2, a10, 0
4037821c:	0228      	l32i.n	a2, a2, 0
4037821e:	0002e0        	callx8	a2
    return ESP_OK;
40378221:	0a0c      	movi.n	a10, 0
}
40378223:	0a2d      	mov.n	a2, a10
40378225:	f01d      	retw.n
40378227:	00          	.byte 00
40378228:	00          	.byte 00
40378229:	00          	.byte 00
    if (chip->os_func != NULL && chip->os_func->start != NULL) {
4037822a:	0888      	l32i.n	a8, a8, 0
4037822c:	fe8816        	beqz	a8, 40378218 <spiflash_start_default+0x8>
        esp_err_t err = chip->os_func->start(chip->os_func_data);
4037822f:	32a8      	l32i.n	a10, a2, 12
40378231:	0008e0        	callx8	a8
        if (err != ESP_OK) {
40378234:	fe0a16        	beqz	a10, 40378218 <spiflash_start_default+0x8>
40378237:	fffa06        	j	40378223 <spiflash_start_default+0x13>
	...

4037823c <spiflash_end_default>:
{
4037823c:	004136        	entry	a1, 32
    if (chip->os_func != NULL
4037823f:	2288      	l32i.n	a8, a2, 8
40378241:	988c      	beqz.n	a8, 4037824e <spiflash_end_default+0x12>
        && chip->os_func->end != NULL) {
40378243:	1888      	l32i.n	a8, a8, 4
40378245:	588c      	beqz.n	a8, 4037824e <spiflash_end_default+0x12>
        esp_err_t end_err = chip->os_func->end(chip->os_func_data);
40378247:	32a8      	l32i.n	a10, a2, 12
40378249:	0008e0        	callx8	a8
        if (err == ESP_OK) {
4037824c:	038c      	beqz.n	a3, 40378250 <spiflash_end_default+0x14>
{
4037824e:	03ad      	mov.n	a10, a3
}
40378250:	0a2d      	mov.n	a2, a10
40378252:	f01d      	retw.n

40378254 <esp_cpu_compare_and_set>:
#if __XTENSA__ && XCHAL_HAVE_S32C1I && CONFIG_SPIRAM
static DRAM_ATTR uint32_t external_ram_cas_lock = 0;
#endif

bool esp_cpu_compare_and_set(volatile uint32_t *addr, uint32_t compare_value, uint32_t new_value)
{
40378254:	004136        	entry	a1, 32
    temp = *addr;
    *addr = temp;
#endif
    // Atomic compare and set using S32C1I instruction
    uint32_t old_value = new_value;
    __asm__ __volatile__ (
40378257:	130c30        	wsr.scompare1	a3
4037825a:	00e242        	s32c1i	a4, a2, 0
        "S32C1I %0, %1, 0 \n"
        :"=r"(old_value)
        :"r"(addr), "r"(compare_value), "0"(old_value)
    );

    return (old_value == compare_value);
4037825d:	120c      	movi.n	a2, 1
4037825f:	c03340        	sub	a3, a3, a4
40378262:	040c      	movi.n	a4, 0
40378264:	932430        	movnez	a2, a4, a3
    return ret;
#else // __XTENSA__
    // Single core targets don't have atomic CAS instruction. So access method is the same for internal and external RAM
    return rv_utils_compare_and_set(addr, compare_value, new_value);
#endif
}
40378267:	f01d      	retw.n
40378269:	000000        	ill

4037826c <esp_cpu_reset>:
{
4037826c:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
4037826f:	0d22b6        	bltui	a2, 2, 40378280 <esp_cpu_reset+0x14>
40378272:	f1b5d1        	l32r	a13, 40374948 <_iram_text_start+0x544>
40378275:	f1b5c1        	l32r	a12, 4037494c <_iram_text_start+0x548>
40378278:	f1b6a1        	l32r	a10, 40374950 <_iram_text_start+0x54c>
4037827b:	4b5c      	movi.n	a11, 84
4037827d:	0658e5        	call8	4037e80c <__assert_func>
    int rtc_cntl_rst_m = (core_id == 0) ? RTC_CNTL_SW_PROCPU_RST_M : RTC_CNTL_SW_APPCPU_RST_M;
40378280:	091c      	movi.n	a9, 16
40378282:	082c      	movi.n	a8, 32
40378284:	938920        	movnez	a8, a9, a2
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_rst_m);
40378287:	f09f91        	l32r	a9, 40374504 <_iram_text_start+0x100>
4037828a:	0020c0        	memw
4037828d:	0928      	l32i.n	a2, a9, 0
4037828f:	208820        	or	a8, a8, a2
40378292:	0020c0        	memw
40378295:	0989      	s32i.n	a8, a9, 0
}
40378297:	f01d      	retw.n
40378299:	000000        	ill

4037829c <esp_cpu_stall>:
{
4037829c:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
4037829f:	0d22b6        	bltui	a2, 2, 403782b0 <esp_cpu_stall+0x14>
403782a2:	f1a9d1        	l32r	a13, 40374948 <_iram_text_start+0x544>
403782a5:	f1abc1        	l32r	a12, 40374954 <_iram_text_start+0x550>
403782a8:	f1aaa1        	l32r	a10, 40374950 <_iram_text_start+0x54c>
403782ab:	8b2c      	movi.n	a11, 40
403782ad:	0655e5        	call8	4037e80c <__assert_func>
    int rtc_cntl_c0_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
403782b0:	390c      	movi.n	a9, 3
403782b2:	c80c      	movi.n	a8, 12
403782b4:	938920        	movnez	a8, a9, a2
    int rtc_cntl_c0_s = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_S : RTC_CNTL_SW_STALL_APPCPU_C0_S;
403782b7:	190c      	movi.n	a9, 1
403782b9:	302290        	xor	a2, a2, a9
403782bc:	d22a      	add.n	a13, a2, a2
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
403782be:	5ae207        	bbsi	a2, 0, 4037831c <esp_cpu_stall+0x80>
403782c1:	fa3c      	movi.n	a10, 63
403782c3:	01aac0        	slli	a10, a10, 20
    int rtc_cntl_c1_s = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
403782c6:	4c1c      	movi.n	a12, 20
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0_m);
403782c8:	f08fb1        	l32r	a11, 40374504 <_iram_text_start+0x100>
403782cb:	f97c      	movi.n	a9, -1
403782cd:	0020c0        	memw
403782d0:	0b28      	l32i.n	a2, a11, 0
403782d2:	308980        	xor	a8, a9, a8
403782d5:	108820        	and	a8, a8, a2
403782d8:	0020c0        	memw
403782db:	0b89      	s32i.n	a8, a11, 0
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, 2 << rtc_cntl_c0_s);
403782dd:	0020c0        	memw
403782e0:	0b88      	l32i.n	a8, a11, 0
403782e2:	220c      	movi.n	a2, 2
403782e4:	401d00        	ssl	a13
403782e7:	a12200        	sll	a2, a2
403782ea:	202280        	or	a2, a2, a8
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
403782ed:	f19a81        	l32r	a8, 40374958 <_iram_text_start+0x554>
    SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, 2 << rtc_cntl_c0_s);
403782f0:	0020c0        	memw
403782f3:	0b29      	s32i.n	a2, a11, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
403782f5:	0020c0        	memw
403782f8:	0828      	l32i.n	a2, a8, 0
403782fa:	3099a0        	xor	a9, a9, a10
403782fd:	109920        	and	a9, a9, a2
40378300:	0020c0        	memw
40378303:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, 0x21 << rtc_cntl_c1_s);
40378305:	0020c0        	memw
40378308:	0898      	l32i.n	a9, a8, 0
4037830a:	122c      	movi.n	a2, 33
4037830c:	401c00        	ssl	a12
4037830f:	a12200        	sll	a2, a2
40378312:	202290        	or	a2, a2, a9
40378315:	0020c0        	memw
40378318:	0829      	s32i.n	a2, a8, 0
}
4037831a:	f01d      	retw.n
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
4037831c:	fa7c      	movi.n	a10, -1
4037831e:	01aa60        	slli	a10, a10, 26
    int rtc_cntl_c1_s = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_S : RTC_CNTL_SW_STALL_APPCPU_C1_S;
40378321:	ac1c      	movi.n	a12, 26
40378323:	ffe846        	j	403782c8 <esp_cpu_stall+0x2c>
	...

40378328 <esp_cpu_unstall>:
{
40378328:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
4037832b:	0d22b6        	bltui	a2, 2, 4037833c <esp_cpu_unstall+0x14>
4037832e:	f186d1        	l32r	a13, 40374948 <_iram_text_start+0x544>
40378331:	f18ac1        	l32r	a12, 4037495c <_iram_text_start+0x558>
40378334:	f187a1        	l32r	a10, 40374950 <_iram_text_start+0x54c>
40378337:	0b4c      	movi.n	a11, 64
40378339:	064d25        	call8	4037e80c <__assert_func>
    int rtc_cntl_c0_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
4037833c:	02bc      	beqz.n	a2, 40378370 <esp_cpu_unstall+0x48>
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
4037833e:	f93c      	movi.n	a9, 63
    int rtc_cntl_c0_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40378340:	3a0c      	movi.n	a10, 3
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40378342:	0199c0        	slli	a9, a9, 20
    CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, rtc_cntl_c0_m);
40378345:	f06fb1        	l32r	a11, 40374504 <_iram_text_start+0x100>
40378348:	f87c      	movi.n	a8, -1
4037834a:	0020c0        	memw
4037834d:	0b28      	l32i.n	a2, a11, 0
4037834f:	30a8a0        	xor	a10, a8, a10
40378352:	10aa20        	and	a10, a10, a2
40378355:	0020c0        	memw
40378358:	0ba9      	s32i.n	a10, a11, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_SW_CPU_STALL_REG, rtc_cntl_c1_m);
4037835a:	f17fa1        	l32r	a10, 40374958 <_iram_text_start+0x554>
4037835d:	308890        	xor	a8, a8, a9
40378360:	0020c0        	memw
40378363:	0a28      	l32i.n	a2, a10, 0
40378365:	108820        	and	a8, a8, a2
40378368:	0020c0        	memw
4037836b:	0a89      	s32i.n	a8, a10, 0
}
4037836d:	f01d      	retw.n
4037836f:	00          	.byte 00
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40378370:	f97c      	movi.n	a9, -1
    int rtc_cntl_c0_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C0_M : RTC_CNTL_SW_STALL_APPCPU_C0_M;
40378372:	ca0c      	movi.n	a10, 12
    int rtc_cntl_c1_m = (core_id == 0) ? RTC_CNTL_SW_STALL_PROCPU_C1_M : RTC_CNTL_SW_STALL_APPCPU_C1_M;
40378374:	019960        	slli	a9, a9, 26
40378377:	fff286        	j	40378345 <esp_cpu_unstall+0x1d>
	...

4037837c <esp_cpu_wait_for_intr>:
{
4037837c:	004136        	entry	a1, 32
    asm volatile ("waiti 0\n");
4037837f:	007000        	waiti	0
}
40378382:	f01d      	retw.n

40378384 <esp_ptr_byte_accessible>:
    return false;
#endif  //CONFIG_SPIRAM
}

bool esp_ptr_byte_accessible(const void *p)
{
40378384:	004136        	entry	a1, 32
    r = (ip >= SOC_BYTE_ACCESSIBLE_LOW && ip < SOC_BYTE_ACCESSIBLE_HIGH);
#if CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP
    /* For ESP32 case, RTC fast memory is accessible to PRO cpu only and hence
     * for single core configuration (where it gets added to system heap) following
     * additional check is required */
    r |= (ip >= SOC_RTC_DRAM_LOW && ip < SOC_RTC_DRAM_HIGH);
40378387:	f08791        	l32r	a9, 403745a4 <_iram_text_start+0x1a0>
4037838a:	f087a1        	l32r	a10, 403745a8 <_iram_text_start+0x1a4>
4037838d:	809290        	add	a9, a2, a9
40378390:	01a082        	movi	a8, 1
40378393:	02ba97        	bgeu	a10, a9, 40378399 <esp_ptr_byte_accessible+0x15>
40378396:	00a082        	movi	a8, 0
    r = (ip >= SOC_BYTE_ACCESSIBLE_LOW && ip < SOC_BYTE_ACCESSIBLE_HIGH);
40378399:	f09f91        	l32r	a9, 40374618 <_iram_text_start+0x214>
4037839c:	f124a1        	l32r	a10, 4037482c <_iram_text_start+0x428>
4037839f:	229a      	add.n	a2, a2, a9
403783a1:	190c      	movi.n	a9, 1
403783a3:	01ba27        	bgeu	a10, a2, 403783a8 <esp_ptr_byte_accessible+0x24>
403783a6:	090c      	movi.n	a9, 0
#endif
#if CONFIG_SPIRAM
    r |= esp_psram_check_ptr_addr(p);
#endif
    return r;
403783a8:	202890        	or	a2, a8, a9
}
403783ab:	042020        	extui	a2, a2, 0, 1
403783ae:	f01d      	retw.n

403783b0 <rtc_clk_bbpll_disable>:
{
    return clk_ll_rtc_fast_get_src();
}

static void rtc_clk_bbpll_disable(void)
{
403783b0:	004136        	entry	a1, 32
/**
 * @brief Power down BBPLL circuit
 */
static inline __attribute__((always_inline)) void clk_ll_bbpll_disable(void)
{
    REG_SET_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
403783b3:	f05491        	l32r	a9, 40374504 <_iram_text_start+0x100>
403783b6:	40a5a2        	movi	a10, 0x540
403783b9:	0020c0        	memw
403783bc:	0988      	l32i.n	a8, a9, 0
403783be:	2088a0        	or	a8, a8, a10
403783c1:	0020c0        	memw
403783c4:	0989      	s32i.n	a8, a9, 0
    clk_ll_bbpll_disable();
    s_cur_pll_freq = 0;
403783c6:	f16681        	l32r	a8, 40374960 <_iram_text_start+0x55c>
403783c9:	090c      	movi.n	a9, 0
403783cb:	0899      	s32i.n	a9, a8, 0
}
403783cd:	f01d      	retw.n
	...

403783d0 <clk_ll_rtc_slow_get_src>:
 * @brief Get the clock source for RTC_SLOW_CLK
 *
 * @return Currently selected clock source (one of soc_rtc_slow_clk_src_t values)
 */
static inline soc_rtc_slow_clk_src_t clk_ll_rtc_slow_get_src(void)
{
403783d0:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL);
403783d3:	f16421        	l32r	a2, 40374964 <_iram_text_start+0x560>
403783d6:	0020c0        	memw
403783d9:	0228      	l32i.n	a2, a2, 0
403783db:	152e20        	extui	a2, a2, 30, 2
    switch (clk_sel) {
403783de:	131226        	beqi	a2, 1, 403783f5 <clk_ll_rtc_slow_get_src+0x25>
403783e1:	102226        	beqi	a2, 2, 403783f5 <clk_ll_rtc_slow_get_src+0x25>
403783e4:	d28c      	beqz.n	a2, 403783f5 <clk_ll_rtc_slow_get_src+0x25>
        return SOC_RTC_SLOW_CLK_SRC_XTAL32K;
    case 2:
        return SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256;
    default:
        // Invalid ANA_CLK_RTC_SEL value
        HAL_ASSERT(false);
403783e6:	f160d1        	l32r	a13, 40374968 <_iram_text_start+0x564>
403783e9:	f160c1        	l32r	a12, 4037496c <_iram_text_start+0x568>
403783ec:	f161a1        	l32r	a10, 40374970 <_iram_text_start+0x56c>
403783ef:	19a2b2        	movi	a11, 0x219
403783f2:	0641a5        	call8	4037e80c <__assert_func>
        return SOC_RTC_SLOW_CLK_SRC_INVALID;
    }
}
403783f5:	f01d      	retw.n
	...

403783f8 <rtc_clk_cpu_freq_to_xtal>:
/**
 * Switch to XTAL frequency. Does not disable the PLL.
 * Public function for testing only.
 */
static void rtc_clk_cpu_freq_to_xtal(int freq, int div)
{
403783f8:	004136        	entry	a1, 32
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
403783fb:	f15e81        	l32r	a8, 40374974 <_iram_text_start+0x570>
403783fe:	4d0c      	movi.n	a13, 4
40378400:	0008f2        	l8ui	a15, a8, 0
40378403:	0dcd      	mov.n	a12, a13
40378405:	0e0c      	movi.n	a14, 0
40378407:	1b0c      	movi.n	a11, 1
40378409:	6da0a2        	movi	a10, 109
4037840c:	fdefe5        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
4037840f:	f15a81        	l32r	a8, 40374978 <_iram_text_start+0x574>
40378412:	0e0c      	movi.n	a14, 0
40378414:	0008f2        	l8ui	a15, a8, 0
40378417:	4d0c      	movi.n	a13, 4
40378419:	6c0c      	movi.n	a12, 6
4037841b:	01a0b2        	movi	a11, 1
4037841e:	6da0a2        	movi	a10, 109
40378421:	fdeea5        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    esp_rom_delay_us(40);
40378424:	8a2c      	movi.n	a10, 40
40378426:	f00681        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378429:	0008e0        	callx8	a8
    ets_update_cpu_frequency(freq);
4037842c:	02ad      	mov.n	a10, a2
4037842e:	f15a81        	l32r	a8, 40374998 <_iram_text_start+0x594>
40378431:	0008e0        	callx8	a8
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378434:	f15281        	l32r	a8, 4037497c <_iram_text_start+0x578>
40378437:	00aca2        	movi	a10, 0xfffffc00
4037843a:	0020c0        	memw
4037843d:	0898      	l32i.n	a9, a8, 0
4037843f:	1099a0        	and	a9, a9, a10
40378442:	0020c0        	memw
40378445:	0899      	s32i.n	a9, a8, 0
    HAL_ASSERT(divider > 0);
40378447:	d3cc      	bnez.n	a3, 40378458 <rtc_clk_cpu_freq_to_xtal+0x60>
40378449:	f14dd1        	l32r	a13, 40374980 <_iram_text_start+0x57c>
4037844c:	f14ec1        	l32r	a12, 40374984 <_iram_text_start+0x580>
4037844f:	f148a1        	l32r	a10, 40374970 <_iram_text_start+0x56c>
40378452:	e3a1b2        	movi	a11, 0x1e3
40378455:	063b65        	call8	4037e80c <__assert_func>
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378458:	0020c0        	memw
4037845b:	0898      	l32i.n	a9, a8, 0
4037845d:	330b      	addi.n	a3, a3, -1
4037845f:	1099a0        	and	a9, a9, a10
40378462:	943030        	extui	a3, a3, 0, 10
40378465:	203390        	or	a3, a3, a9
40378468:	0020c0        	memw
4037846b:	0839      	s32i.n	a3, a8, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 0);
4037846d:	0020c0        	memw
40378470:	0838      	l32i.n	a3, a8, 0
40378472:	f14591        	l32r	a9, 40374988 <_iram_text_start+0x584>
40378475:	103390        	and	a3, a3, a9
40378478:	0020c0        	memw
4037847b:	0839      	s32i.n	a3, a8, 0
    /* Set divider from XTAL to APB clock. Need to set divider to 1 (reg. value 0) first. */
    clk_ll_cpu_set_divider(1);
    clk_ll_cpu_set_divider(div);
    /* switch clock source */
    clk_ll_cpu_set_src(SOC_CPU_CLK_SRC_XTAL);
    rtc_clk_apb_freq_update(freq * MHZ);
4037847d:	f07b31        	l32r	a3, 4037466c <_iram_text_start+0x268>
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378480:	f14481        	l32r	a8, 40374990 <_iram_text_start+0x58c>
    rtc_clk_apb_freq_update(freq * MHZ);
40378483:	822230        	mull	a2, a2, a3
    clk_ll_xtal_store_freq_mhz(xtal_freq);
}

void rtc_clk_apb_freq_update(uint32_t apb_freq)
{
    s_apb_freq = apb_freq;
40378486:	f14131        	l32r	a3, 4037498c <_iram_text_start+0x588>
40378489:	0329      	s32i.n	a2, a3, 0
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
4037848b:	0020c0        	memw
4037848e:	0838      	l32i.n	a3, a8, 0
40378490:	f14121        	l32r	a2, 40374994 <_iram_text_start+0x590>
40378493:	103320        	and	a3, a3, a2
40378496:	720c      	movi.n	a2, 7
40378498:	112230        	slli	a2, a2, 13
4037849b:	203320        	or	a3, a3, a2
4037849e:	0020c0        	memw
403784a1:	0839      	s32i.n	a3, a8, 0
}
403784a3:	f01d      	retw.n
403784a5:	000000        	ill

403784a8 <clk_ll_xtal32k_enable$constprop$0>:
static inline void clk_ll_xtal32k_enable(clk_ll_xtal32k_enable_mode_t mode)
403784a8:	004136        	entry	a1, 32
    REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DAC_XTAL_32K, cfg.dac);
403784ab:	f13c81        	l32r	a8, 4037499c <_iram_text_start+0x598>
403784ae:	f13ca1        	l32r	a10, 403749a0 <_iram_text_start+0x59c>
403784b1:	0020c0        	memw
403784b4:	0898      	l32i.n	a9, a8, 0
403784b6:	1099a0        	and	a9, a9, a10
403784b9:	3a0c      	movi.n	a10, 3
403784bb:	01aaf0        	slli	a10, a10, 17
403784be:	2099a0        	or	a9, a9, a10
403784c1:	0020c0        	memw
403784c4:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DRES_XTAL_32K, cfg.dres);
403784c6:	0020c0        	memw
403784c9:	0898      	l32i.n	a9, a8, 0
403784cb:	f136a1        	l32r	a10, 403749a4 <_iram_text_start+0x5a0>
403784ce:	1099a0        	and	a9, a9, a10
403784d1:	3a0c      	movi.n	a10, 3
403784d3:	11aa30        	slli	a10, a10, 13
403784d6:	2099a0        	or	a9, a9, a10
403784d9:	0020c0        	memw
403784dc:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DGM_XTAL_32K, cfg.dgm);
403784de:	0020c0        	memw
403784e1:	0898      	l32i.n	a9, a8, 0
403784e3:	f131a1        	l32r	a10, 403749a8 <_iram_text_start+0x5a4>
403784e6:	1099a0        	and	a9, a9, a10
403784e9:	3a0c      	movi.n	a10, 3
403784eb:	11aa60        	slli	a10, a10, 10
403784ee:	2099a0        	or	a9, a9, a10
403784f1:	0020c0        	memw
403784f4:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_DBUF_XTAL_32K, cfg.dbuf);
403784f6:	0020c0        	memw
403784f9:	0898      	l32i.n	a9, a8, 0
403784fb:	00a2a2        	movi	a10, 0x200
403784fe:	2099a0        	or	a9, a9, a10
40378501:	0020c0        	memw
40378504:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
40378506:	0020c0        	memw
40378509:	0898      	l32i.n	a9, a8, 0
4037850b:	1a0c      	movi.n	a10, 1
4037850d:	11aa00        	slli	a10, a10, 16
40378510:	2099a0        	or	a9, a9, a10
40378513:	0020c0        	memw
40378516:	0899      	s32i.n	a9, a8, 0
}
40378518:	f01d      	retw.n
	...

4037851c <rtc_clk_32k_enable$part$0>:
void rtc_clk_32k_enable(bool enable)
4037851c:	004136        	entry	a1, 32
        SET_PERI_REG_MASK(RTC_IO_XTAL_32P_PAD_REG, RTC_IO_X32P_MUX_SEL);
4037851f:	f123a1        	l32r	a10, 403749ac <_iram_text_start+0x5a8>
40378522:	01a082        	movi	a8, 1
40378525:	0020c0        	memw
40378528:	002a92        	l32i	a9, a10, 0
4037852b:	0188d0        	slli	a8, a8, 19
4037852e:	209980        	or	a9, a9, a8
40378531:	0020c0        	memw
40378534:	006a92        	s32i	a9, a10, 0
        SET_PERI_REG_MASK(RTC_IO_XTAL_32N_PAD_REG, RTC_IO_X32N_MUX_SEL);
40378537:	f11ea1        	l32r	a10, 403749b0 <_iram_text_start+0x5ac>
4037853a:	0020c0        	memw
4037853d:	0a98      	l32i.n	a9, a10, 0
4037853f:	208980        	or	a8, a9, a8
40378542:	0020c0        	memw
40378545:	0a89      	s32i.n	a8, a10, 0
        clk_ll_xtal32k_enable(CLK_LL_XTAL32K_ENABLE_MODE_CRYSTAL);
40378547:	fff625        	call8	403784a8 <clk_ll_xtal32k_enable$constprop$0>
}
4037854a:	f01d      	retw.n

4037854c <rtc_clk_32k_enable>:
{
4037854c:	004136        	entry	a1, 32
4037854f:	742020        	extui	a2, a2, 0, 8
    if (enable) {
40378552:	628c      	beqz.n	a2, 4037855c <rtc_clk_32k_enable+0x10>
40378554:	fffc65        	call8	4037851c <rtc_clk_32k_enable$part$0>
}
40378557:	f01d      	retw.n
40378559:	00          	.byte 00
4037855a:	00          	.byte 00
4037855b:	00          	.byte 00
    SET_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XTAL32K_XPD_FORCE);
4037855c:	f11081        	l32r	a8, 4037499c <_iram_text_start+0x598>
4037855f:	80a0a2        	movi	a10, 128
40378562:	0020c0        	memw
40378565:	0898      	l32i.n	a9, a8, 0
40378567:	2099a0        	or	a9, a9, a10
4037856a:	0020c0        	memw
4037856d:	0899      	s32i.n	a9, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_XTL_CONF_REG, RTC_CNTL_XPD_XTAL_32K);
4037856f:	0020c0        	memw
40378572:	0898      	l32i.n	a9, a8, 0
40378574:	f110a1        	l32r	a10, 403749b4 <_iram_text_start+0x5b0>
40378577:	1099a0        	and	a9, a9, a10
4037857a:	0020c0        	memw
4037857d:	0899      	s32i.n	a9, a8, 0
4037857f:	fff506        	j	40378557 <rtc_clk_32k_enable+0xb>
	...

40378584 <rtc_clk_8m_enable>:
{
40378584:	004136        	entry	a1, 32
    if (clk_8m_en) {
40378587:	f0f781        	l32r	a8, 40374964 <_iram_text_start+0x560>
{
4037858a:	742020        	extui	a2, a2, 0, 8
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
4037858d:	0020c0        	memw
40378590:	08a8      	l32i.n	a10, a8, 0
40378592:	f10991        	l32r	a9, 403749b8 <_iram_text_start+0x5b4>
40378595:	743030        	extui	a3, a3, 0, 8
    if (clk_8m_en) {
40378598:	f2bc      	beqz.n	a2, 403785db <rtc_clk_8m_enable+0x57>
4037859a:	bfafb2        	movi	a11, -65
4037859d:	10aab0        	and	a10, a10, a11
403785a0:	0020c0        	memw
403785a3:	08a9      	s32i.n	a10, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, RTC_CK8M_ENABLE_WAIT_DEFAULT);
403785a5:	0020c0        	memw
403785a8:	0988      	l32i.n	a8, a9, 0
403785aa:	f104a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8>
403785ad:	1088a0        	and	a8, a8, a10
403785b0:	40a1a2        	movi	a10, 0x140
403785b3:	2088a0        	or	a8, a8, a10
403785b6:	0020c0        	memw
403785b9:	0989      	s32i.n	a8, a9, 0
        esp_rom_delay_us(SOC_DELAY_RC_FAST_ENABLE);
403785bb:	32a0a2        	movi	a10, 50
403785be:	efa081        	l32r	a8, 40374440 <_iram_text_start+0x3c>
403785c1:	0008e0        	callx8	a8
    if (d256_en) {
403785c4:	f0e881        	l32r	a8, 40374964 <_iram_text_start+0x560>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403785c7:	0020c0        	memw
403785ca:	0898      	l32i.n	a9, a8, 0
403785cc:	03bc      	beqz.n	a3, 40378600 <rtc_clk_8m_enable+0x7c>
403785ce:	7faf32        	movi	a3, -129
403785d1:	109930        	and	a9, a9, a3
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
403785d4:	0020c0        	memw
403785d7:	0899      	s32i.n	a9, a8, 0
}
403785d9:	f01d      	retw.n
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M);
403785db:	0b4c      	movi.n	a11, 64
403785dd:	20aab0        	or	a10, a10, a11
403785e0:	0020c0        	memw
403785e3:	08a9      	s32i.n	a10, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, RTC_CNTL_CK8M_WAIT_DEFAULT);
403785e5:	0020c0        	memw
403785e8:	0988      	l32i.n	a8, a9, 0
403785ea:	f0f4a1        	l32r	a10, 403749bc <_iram_text_start+0x5b8>
403785ed:	1088a0        	and	a8, a8, a10
403785f0:	00a5a2        	movi	a10, 0x500
403785f3:	2088a0        	or	a8, a8, a10
403785f6:	0020c0        	memw
403785f9:	0989      	s32i.n	a8, a9, 0
}
403785fb:	fff146        	j	403785c4 <rtc_clk_8m_enable+0x40>
403785fe:	00          	.byte 00
403785ff:	00          	.byte 00
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV);
40378600:	80a032        	movi	a3, 128
40378603:	209930        	or	a9, a9, a3
40378606:	fff286        	j	403785d4 <rtc_clk_8m_enable+0x50>
40378609:	000000        	ill

4037860c <rtc_clk_8md256_enabled>:
{
4037860c:	004136        	entry	a1, 32
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
4037860f:	f0d521        	l32r	a2, 40374964 <_iram_text_start+0x560>
40378612:	0020c0        	memw
40378615:	0288      	l32i.n	a8, a2, 0
}
40378617:	120c      	movi.n	a2, 1
40378619:	048780        	extui	a8, a8, 7, 1
4037861c:	302820        	xor	a2, a8, a2
4037861f:	f01d      	retw.n
40378621:	000000        	ill

40378624 <rtc_clk_slow_src_set>:
{
40378624:	004136        	entry	a1, 32
    switch (in_sel) {
40378627:	f0cf81        	l32r	a8, 40374964 <_iram_text_start+0x560>
4037862a:	efe0a1        	l32r	a10, 403745ac <_iram_text_start+0x1a8>
4037862d:	231226        	beqi	a2, 1, 40378654 <rtc_clk_slow_src_set+0x30>
40378630:	502226        	beqi	a2, 2, 40378684 <rtc_clk_slow_src_set+0x60>
40378633:	061256        	bnez	a2, 40378698 <rtc_clk_slow_src_set+0x74>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 0);
40378636:	0020c0        	memw
40378639:	0828      	l32i.n	a2, a8, 0
4037863b:	1022a0        	and	a2, a2, a10
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 2);
4037863e:	0020c0        	memw
40378641:	0829      	s32i.n	a2, a8, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378643:	f0c881        	l32r	a8, 40374964 <_iram_text_start+0x560>
40378646:	ffae92        	movi	a9, 0xfffffeff
40378649:	0020c0        	memw
4037864c:	0828      	l32i.n	a2, a8, 0
4037864e:	102290        	and	a2, a2, a9
40378651:	000746        	j	40378672 <rtc_clk_slow_src_set+0x4e>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 1);
40378654:	0020c0        	memw
40378657:	0898      	l32i.n	a9, a8, 0
40378659:	012220        	slli	a2, a2, 30
4037865c:	1099a0        	and	a9, a9, a10
4037865f:	209920        	or	a9, a9, a2
40378662:	0020c0        	memw
40378665:	0899      	s32i.n	a9, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378667:	0020c0        	memw
4037866a:	0828      	l32i.n	a2, a8, 0
4037866c:	00a192        	movi	a9, 0x100
4037866f:	202290        	or	a2, a2, a9
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378672:	0020c0        	memw
40378675:	0829      	s32i.n	a2, a8, 0
    esp_rom_delay_us(SOC_DELAY_RTC_SLOW_CLK_SWITCH);
40378677:	2ca1a2        	movi	a10, 0x12c
4037867a:	ef7181        	l32r	a8, 40374440 <_iram_text_start+0x3c>
4037867d:	0008e0        	callx8	a8
}
40378680:	f01d      	retw.n
40378682:	00          	.byte 00
40378683:	00          	.byte 00
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ANA_CLK_RTC_SEL, 2);
40378684:	0020c0        	memw
40378687:	0828      	l32i.n	a2, a8, 0
40378689:	f97c      	movi.n	a9, -1
4037868b:	1022a0        	and	a2, a2, a10
4037868e:	019910        	slli	a9, a9, 31
40378691:	202290        	or	a2, a2, a9
40378694:	ffe986        	j	4037863e <rtc_clk_slow_src_set+0x1a>
40378697:	00          	.byte 00
        abort();
40378698:	060e25        	call8	4037e77c <abort>
	...

4037869c <rtc_clk_slow_src_get>:
{
4037869c:	004136        	entry	a1, 32
    return clk_ll_rtc_slow_get_src();
4037869f:	ffd325        	call8	403783d0 <clk_ll_rtc_slow_get_src>
}
403786a2:	0a2d      	mov.n	a2, a10
403786a4:	f01d      	retw.n
	...

403786a8 <rtc_clk_slow_freq_get_hz>:
{
403786a8:	004136        	entry	a1, 32
    return clk_ll_rtc_slow_get_src();
403786ab:	ffd265        	call8	403783d0 <clk_ll_rtc_slow_get_src>
    switch (rtc_clk_slow_src_get()) {
403786ae:	112a10        	slli	a2, a10, 15
403786b1:	0d1a26        	beqi	a10, 1, 403786c2 <rtc_clk_slow_freq_get_hz+0x1a>
    case SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: return SOC_CLK_RC_FAST_D256_FREQ_APPROX;
403786b4:	f0c421        	l32r	a2, 403749c4 <_iram_text_start+0x5c0>
    switch (rtc_clk_slow_src_get()) {
403786b7:	072a26        	beqi	a10, 2, 403786c2 <rtc_clk_slow_freq_get_hz+0x1a>
    default: return 0;
403786ba:	020c      	movi.n	a2, 0
    switch (rtc_clk_slow_src_get()) {
403786bc:	029a27        	bne	a10, a2, 403786c2 <rtc_clk_slow_freq_get_hz+0x1a>
    case SOC_RTC_SLOW_CLK_SRC_RC_SLOW: return SOC_CLK_RC_SLOW_FREQ_APPROX;
403786bf:	f0c021        	l32r	a2, 403749c0 <_iram_text_start+0x5bc>
}
403786c2:	f01d      	retw.n

403786c4 <rtc_clk_fast_src_set>:
{
403786c4:	004136        	entry	a1, 32
 *
 * @param in_sel One of the clock sources in soc_rtc_fast_clk_src_t
 */
static inline void clk_ll_rtc_fast_set_src(soc_rtc_fast_clk_src_t in_sel)
{
    switch (in_sel) {
403786c7:	f0a781        	l32r	a8, 40374964 <_iram_text_start+0x560>
403786ca:	728c      	beqz.n	a2, 403786d5 <rtc_clk_fast_src_set+0x11>
403786cc:	201226        	beqi	a2, 1, 403786f0 <rtc_clk_fast_src_set+0x2c>
    case SOC_RTC_FAST_CLK_SRC_RC_FAST:
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 1);
        break;
    default:
        // Unsupported RTC_FAST_CLK mux input sel
        abort();
403786cf:	201110        	or	a1, a1, a1
403786d2:	060aa5        	call8	4037e77c <abort>
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 0);
403786d5:	0020c0        	memw
403786d8:	0828      	l32i.n	a2, a8, 0
403786da:	f04791        	l32r	a9, 403747f8 <_iram_text_start+0x3f4>
403786dd:	102290        	and	a2, a2, a9
403786e0:	0020c0        	memw
403786e3:	0829      	s32i.n	a2, a8, 0
    esp_rom_delay_us(SOC_DELAY_RTC_FAST_CLK_SWITCH);
403786e5:	3a0c      	movi.n	a10, 3
403786e7:	ef5681        	l32r	a8, 40374440 <_iram_text_start+0x3c>
403786ea:	0008e0        	callx8	a8
}
403786ed:	f01d      	retw.n
403786ef:	00          	.byte 00
        REG_SET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_FAST_CLK_RTC_SEL, 1);
403786f0:	0020c0        	memw
403786f3:	0898      	l32i.n	a9, a8, 0
403786f5:	012230        	slli	a2, a2, 29
403786f8:	209920        	or	a9, a9, a2
403786fb:	0020c0        	memw
403786fe:	0899      	s32i.n	a9, a8, 0
        break;
40378700:	fff846        	j	403786e5 <rtc_clk_fast_src_set+0x21>
	...

40378704 <rtc_clk_xtal_freq_get>:
{
40378704:	004136        	entry	a1, 32
 * @return XTAL frequency, in MHz. Returns 0 if value in reg is invalid.
 */
static inline __attribute__((always_inline)) uint32_t clk_ll_xtal_load_freq_mhz(void)
{
    // Read from the RTC storage register
    uint32_t xtal_freq_reg = READ_PERI_REG(RTC_XTAL_FREQ_REG);
40378707:	f0b021        	l32r	a2, 403749c8 <_iram_text_start+0x5c4>
4037870a:	0020c0        	memw
4037870d:	0288      	l32i.n	a8, a2, 0
    if ((xtal_freq_reg & 0xFFFF) == ((xtal_freq_reg >> 16) & 0xFFFF) &&
4037870f:	f42080        	extui	a2, a8, 0, 16
40378712:	f59080        	extui	a9, a8, 16, 16
40378715:	099297        	bne	a2, a9, 40378722 <rtc_clk_xtal_freq_get+0x1e>
        xtal_freq_reg != 0 && xtal_freq_reg != UINT32_MAX) {
40378718:	880b      	addi.n	a8, a8, -1
4037871a:	d97c      	movi.n	a9, -3
4037871c:	023987        	bltu	a9, a8, 40378722 <rtc_clk_xtal_freq_get+0x1e>
    if (xtal_freq_mhz == 0) {
4037871f:	001256        	bnez	a2, 40378724 <rtc_clk_xtal_freq_get+0x20>
        return RTC_XTAL_FREQ_40M;
40378722:	822c      	movi.n	a2, 40
}
40378724:	f01d      	retw.n
	...

40378728 <rtc_clk_cpu_freq_mhz_to_config>:
{
40378728:	004136        	entry	a1, 32
4037872b:	024d      	mov.n	a4, a2
    uint32_t xtal_freq = (uint32_t)rtc_clk_xtal_freq_get();
4037872d:	fffd65        	call8	40378704 <rtc_clk_xtal_freq_get>
    if (freq_mhz <= xtal_freq && freq_mhz != 0) {
40378730:	220b      	addi.n	a2, a2, -1
40378732:	1eb2a7        	bgeu	a2, a10, 40378754 <rtc_clk_cpu_freq_mhz_to_config+0x2c>
        divider = xtal_freq / freq_mhz;
40378735:	c29a40        	quou	a9, a10, a4
        real_freq_mhz = (xtal_freq + divider / 2) / divider; /* round */
40378738:	418190        	srli	a8, a9, 1
4037873b:	88aa      	add.n	a8, a8, a10
4037873d:	c28890        	quou	a8, a8, a9
            return false;
40378740:	020c      	movi.n	a2, 0
        if (real_freq_mhz != freq_mhz) {
40378742:	239487        	bne	a4, a8, 40378769 <rtc_clk_cpu_freq_mhz_to_config+0x41>
        source = SOC_CPU_CLK_SRC_XTAL;
40378745:	028d      	mov.n	a8, a2
    *out_config = (rtc_cpu_freq_config_t) {
40378747:	0389      	s32i.n	a8, a3, 0
40378749:	13a9      	s32i.n	a10, a3, 4
4037874b:	2399      	s32i.n	a9, a3, 8
4037874d:	3349      	s32i.n	a4, a3, 12
    return true;
4037874f:	120c      	movi.n	a2, 1
40378751:	000506        	j	40378769 <rtc_clk_cpu_freq_mhz_to_config+0x41>
    } else if (freq_mhz == 80) {
40378754:	025c      	movi.n	a2, 80
40378756:	121427        	beq	a4, a2, 4037876c <rtc_clk_cpu_freq_mhz_to_config+0x44>
    } else if (freq_mhz == 160) {
40378759:	a0a022        	movi	a2, 160
4037875c:	161427        	beq	a4, a2, 40378776 <rtc_clk_cpu_freq_mhz_to_config+0x4e>
    } else if (freq_mhz == 240) {
4037875f:	f0a082        	movi	a8, 240
            return false;
40378762:	020c      	movi.n	a2, 0
        divider = 2;
40378764:	290c      	movi.n	a9, 2
    } else if (freq_mhz == 240) {
40378766:	041487        	beq	a4, a8, 4037876e <rtc_clk_cpu_freq_mhz_to_config+0x46>
}
40378769:	f01d      	retw.n
4037876b:	00          	.byte 00
        divider = 6;
4037876c:	690c      	movi.n	a9, 6
        source = SOC_CPU_CLK_SRC_PLL;
4037876e:	180c      	movi.n	a8, 1
        source_freq_mhz = CLK_LL_PLL_480M_FREQ_MHZ;
40378770:	e0a1a2        	movi	a10, 0x1e0
40378773:	fff406        	j	40378747 <rtc_clk_cpu_freq_mhz_to_config+0x1f>
        divider = 3;
40378776:	390c      	movi.n	a9, 3
40378778:	fffc86        	j	4037876e <rtc_clk_cpu_freq_mhz_to_config+0x46>
	...

4037877c <rtc_clk_cpu_freq_get_config>:
{
4037877c:	004136        	entry	a1, 32
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
4037877f:	f07f31        	l32r	a3, 4037497c <_iram_text_start+0x578>
40378782:	0020c0        	memw
40378785:	002342        	l32i	a4, a3, 0
40378788:	144a40        	extui	a4, a4, 10, 2
    switch (clk_sel) {
4037878b:	211426        	beqi	a4, 1, 403787b0 <rtc_clk_cpu_freq_get_config+0x34>
4037878e:	662426        	beqi	a4, 2, 403787f8 <rtc_clk_cpu_freq_get_config+0x7c>
40378791:	018456        	bnez	a4, 403787ad <rtc_clk_cpu_freq_get_config+0x31>
    return REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT) + 1;
40378794:	0020c0        	memw
40378797:	002332        	l32i	a3, a3, 0
        source_freq_mhz = (uint32_t)rtc_clk_xtal_freq_get();
4037879a:	fff6a5        	call8	40378704 <rtc_clk_xtal_freq_get>
4037879d:	943030        	extui	a3, a3, 0, 10
403787a0:	331b      	addi.n	a3, a3, 1
        freq_mhz = source_freq_mhz / div;
403787a2:	c28a30        	quou	a8, a10, a3
    *out_config = (rtc_cpu_freq_config_t) {
403787a5:	0249      	s32i.n	a4, a2, 0
403787a7:	12a9      	s32i.n	a10, a2, 4
403787a9:	2239      	s32i.n	a3, a2, 8
403787ab:	3289      	s32i.n	a8, a2, 12
}
403787ad:	f01d      	retw.n
403787af:	00          	.byte 00
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
403787b0:	f08791        	l32r	a9, 403749cc <_iram_text_start+0x5c8>
    switch (cpu_freq_sel) {
403787b3:	a0a082        	movi	a8, 160
    uint32_t cpu_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL);
403787b6:	0020c0        	memw
403787b9:	0938      	l32i.n	a3, a9, 0
403787bb:	143030        	extui	a3, a3, 0, 2
    switch (cpu_freq_sel) {
403787be:	0e1326        	beqi	a3, 1, 403787d0 <rtc_clk_cpu_freq_get_config+0x54>
        return CLK_LL_PLL_240M_FREQ_MHZ;
403787c1:	f0a082        	movi	a8, 240
    switch (cpu_freq_sel) {
403787c4:	082326        	beqi	a3, 2, 403787d0 <rtc_clk_cpu_freq_get_config+0x54>
        return CLK_LL_PLL_80M_FREQ_MHZ;
403787c7:	00a082        	movi	a8, 0
403787ca:	50a0a2        	movi	a10, 80
403787cd:	838a30        	moveqz	a8, a10, a3
    uint32_t pll_freq_sel = REG_GET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL);
403787d0:	0020c0        	memw
403787d3:	0938      	l32i.n	a3, a9, 0
403787d5:	095c      	movi.n	a9, 80
403787d7:	043230        	extui	a3, a3, 2, 1
    switch (pll_freq_sel) {
403787da:	b3ac      	beqz.n	a3, 40378809 <rtc_clk_cpu_freq_get_config+0x8d>
        if (freq_mhz == CLK_LL_PLL_80M_FREQ_MHZ) {
403787dc:	3c9897        	bne	a8, a9, 4037881c <rtc_clk_cpu_freq_get_config+0xa0>
        return SOC_CPU_CLK_SRC_PLL;
403787df:	034d      	mov.n	a4, a3
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
403787e1:	630c      	movi.n	a3, 6
403787e3:	0002c6        	j	403787f2 <rtc_clk_cpu_freq_get_config+0x76>
403787e6:	00          	.byte 00
403787e7:	00          	.byte 00
        } else if (freq_mhz == CLK_LL_PLL_240M_FREQ_MHZ  && source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
403787e8:	f0a042        	movi	a4, 240
403787eb:	be9847        	bne	a8, a4, 403787ad <rtc_clk_cpu_freq_get_config+0x31>
403787ee:	034d      	mov.n	a4, a3
            div = 2;
403787f0:	230c      	movi.n	a3, 2
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
403787f2:	e0a1a2        	movi	a10, 0x1e0
403787f5:	ffeb06        	j	403787a5 <rtc_clk_cpu_freq_get_config+0x29>
    switch (clk_sel) {
403787f8:	481c      	movi.n	a8, 20
403787fa:	130c      	movi.n	a3, 1
403787fc:	08ad      	mov.n	a10, a8
403787fe:	ffe8c6        	j	403787a5 <rtc_clk_cpu_freq_get_config+0x29>
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 6 : 4;
40378801:	430c      	movi.n	a3, 4
        return CLK_LL_PLL_320M_FREQ_MHZ;
40378803:	40a1a2        	movi	a10, 0x140
40378806:	ffe6c6        	j	403787a5 <rtc_clk_cpu_freq_get_config+0x29>
        if (freq_mhz == CLK_LL_PLL_80M_FREQ_MHZ) {
40378809:	f41897        	beq	a8, a9, 40378801 <rtc_clk_cpu_freq_get_config+0x85>
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
4037880c:	a0a092        	movi	a9, 160
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
4037880f:	230c      	movi.n	a3, 2
40378811:	40a1a2        	movi	a10, 0x140
        } else if (freq_mhz == CLK_LL_PLL_160M_FREQ_MHZ) {
40378814:	8d1897        	beq	a8, a9, 403787a5 <rtc_clk_cpu_freq_get_config+0x29>
40378817:	ffe486        	j	403787ad <rtc_clk_cpu_freq_get_config+0x31>
4037881a:	00          	.byte 00
4037881b:	00          	.byte 00
4037881c:	a0a042        	movi	a4, 160
4037881f:	c59847        	bne	a8, a4, 403787e8 <rtc_clk_cpu_freq_get_config+0x6c>
        return SOC_CPU_CLK_SRC_PLL;
40378822:	034d      	mov.n	a4, a3
            div = (source_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) ? 3 : 2;
40378824:	330c      	movi.n	a3, 3
40378826:	fff206        	j	403787f2 <rtc_clk_cpu_freq_get_config+0x76>
40378829:	000000        	ill

4037882c <rtc_clk_cpu_freq_to_pll_mhz>:
{
4037882c:	006136        	entry	a1, 48
    if (cpu_freq_mhz != 240) {
4037882f:	f0a032        	movi	a3, 240
40378832:	029237        	bne	a2, a3, 40378838 <rtc_clk_cpu_freq_to_pll_mhz+0xc>
40378835:	003506        	j	4037890d <rtc_clk_cpu_freq_to_pll_mhz+0xe1>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378838:	f04f31        	l32r	a3, 40374974 <_iram_text_start+0x570>
4037883b:	4d0c      	movi.n	a13, 4
4037883d:	0003f2        	l8ui	a15, a3, 0
40378840:	0e0c      	movi.n	a14, 0
40378842:	0dcd      	mov.n	a12, a13
40378844:	1b0c      	movi.n	a11, 1
40378846:	6da0a2        	movi	a10, 109
40378849:	fdac25        	call8	4037630c <regi2c_ctrl_write_reg_mask>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
4037884c:	f04b31        	l32r	a3, 40374978 <_iram_text_start+0x574>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_240m);
4037884f:	0003f2        	l8ui	a15, a3, 0
40378852:	0e0c      	movi.n	a14, 0
40378854:	4d0c      	movi.n	a13, 4
40378856:	6c0c      	movi.n	a12, 6
40378858:	1b0c      	movi.n	a11, 1
4037885a:	6da0a2        	movi	a10, 109
4037885d:	fdaae5        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    esp_rom_delay_us(40);
40378860:	8a2c      	movi.n	a10, 40
40378862:	eef781        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378865:	0008e0        	callx8	a8
    int pd_slave = cpu_freq_mhz / 80;
40378868:	f05c31        	l32r	a3, 403749d8 <_iram_text_start+0x5d4>
4037886b:	318f20        	srai	a8, a2, 31
4037886e:	b23230        	mulsh	a3, a2, a3
    rtc_clk_cpu_freq_get_config(&cur_config);
40378871:	20a110        	or	a10, a1, a1
    int pd_slave = cpu_freq_mhz / 80;
40378874:	213530        	srai	a3, a3, 5
40378877:	c03380        	sub	a3, a3, a8
    rtc_clk_cpu_freq_get_config(&cur_config);
4037887a:	fff025        	call8	4037877c <rtc_clk_cpu_freq_get_config>
    if (cpu_freq_mhz > cur_config.freq_mhz) {
4037887d:	3188      	l32i.n	a8, a1, 12
4037887f:	f043a1        	l32r	a10, 4037498c <_iram_text_start+0x588>
40378882:	023827        	bltu	a8, a2, 40378888 <rtc_clk_cpu_freq_to_pll_mhz+0x5c>
40378885:	0032c6        	j	40378954 <rtc_clk_cpu_freq_to_pll_mhz+0x128>
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
40378888:	f042b1        	l32r	a11, 40374990 <_iram_text_start+0x58c>
4037888b:	780c      	movi.n	a8, 7
4037888d:	0020c0        	memw
40378890:	0b98      	l32i.n	a9, a11, 0
40378892:	400300        	ssr	a3
40378895:	b13080        	sra	a3, a8
40378898:	f03f81        	l32r	a8, 40374994 <_iram_text_start+0x590>
4037889b:	113330        	slli	a3, a3, 13
4037889e:	108980        	and	a8, a9, a8
403788a1:	203380        	or	a3, a3, a8
403788a4:	0020c0        	memw
403788a7:	0b39      	s32i.n	a3, a11, 0
    switch (cpu_mhz) {
403788a9:	a0a082        	movi	a8, 160
403788ac:	f04831        	l32r	a3, 403749cc <_iram_text_start+0x5c8>
403788af:	791287        	beq	a2, a8, 4037892c <rtc_clk_cpu_freq_to_pll_mhz+0x100>
403788b2:	f0a082        	movi	a8, 240
403788b5:	029287        	bne	a2, a8, 403788bb <rtc_clk_cpu_freq_to_pll_mhz+0x8f>
403788b8:	002106        	j	40378940 <rtc_clk_cpu_freq_to_pll_mhz+0x114>
403788bb:	085c      	movi.n	a8, 80
403788bd:	021287        	beq	a2, a8, 403788c3 <rtc_clk_cpu_freq_to_pll_mhz+0x97>
403788c0:	002346        	j	40378951 <rtc_clk_cpu_freq_to_pll_mhz+0x125>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 0);
403788c3:	0020c0        	memw
403788c6:	0388      	l32i.n	a8, a3, 0
403788c8:	c97c      	movi.n	a9, -4
403788ca:	108890        	and	a8, a8, a9
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
403788cd:	0020c0        	memw
403788d0:	0389      	s32i.n	a8, a3, 0
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
403788d2:	f02a81        	l32r	a8, 4037497c <_iram_text_start+0x578>
403788d5:	00ac92        	movi	a9, 0xfffffc00
403788d8:	0020c0        	memw
403788db:	0838      	l32i.n	a3, a8, 0
403788dd:	103390        	and	a3, a3, a9
403788e0:	0020c0        	memw
403788e3:	0839      	s32i.n	a3, a8, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 1);
403788e5:	0020c0        	memw
403788e8:	0838      	l32i.n	a3, a8, 0
403788ea:	f02791        	l32r	a9, 40374988 <_iram_text_start+0x584>
403788ed:	103390        	and	a3, a3, a9
403788f0:	00a492        	movi	a9, 0x400
403788f3:	203390        	or	a3, a3, a9
403788f6:	0020c0        	memw
403788f9:	0839      	s32i.n	a3, a8, 0
    s_apb_freq = apb_freq;
403788fb:	ef5e31        	l32r	a3, 40374674 <_iram_text_start+0x270>
403788fe:	0a39      	s32i.n	a3, a10, 0
        ets_update_cpu_frequency(cpu_freq_mhz);
40378900:	02ad      	mov.n	a10, a2
40378902:	f02581        	l32r	a8, 40374998 <_iram_text_start+0x594>
40378905:	0008e0        	callx8	a8
}
40378908:	f01d      	retw.n
4037890a:	00          	.byte 00
4037890b:	00          	.byte 00
4037890c:	00          	.byte 00
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_240m);
4037890d:	f03031        	l32r	a3, 403749d0 <_iram_text_start+0x5cc>
40378910:	04a0d2        	movi	a13, 4
40378913:	0003f2        	l8ui	a15, a3, 0
40378916:	00a0e2        	movi	a14, 0
40378919:	20cdd0        	or	a12, a13, a13
4037891c:	1b0c      	movi.n	a11, 1
4037891e:	6da0a2        	movi	a10, 109
40378921:	fd9ea5        	call8	4037630c <regi2c_ctrl_write_reg_mask>
        REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_240m);
40378924:	f02c31        	l32r	a3, 403749d4 <_iram_text_start+0x5d0>
40378927:	ffc906        	j	4037884f <rtc_clk_cpu_freq_to_pll_mhz+0x23>
4037892a:	00          	.byte 00
4037892b:	00          	.byte 00
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 1);
4037892c:	0020c0        	memw
4037892f:	0388      	l32i.n	a8, a3, 0
40378931:	c97c      	movi.n	a9, -4
40378933:	108890        	and	a8, a8, a9
40378936:	190c      	movi.n	a9, 1
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
40378938:	208890        	or	a8, a8, a9
4037893b:	ffe386        	j	403788cd <rtc_clk_cpu_freq_to_pll_mhz+0xa1>
4037893e:	00          	.byte 00
4037893f:	00          	.byte 00
40378940:	0020c0        	memw
40378943:	0388      	l32i.n	a8, a3, 0
40378945:	c97c      	movi.n	a9, -4
40378947:	108890        	and	a8, a8, a9
4037894a:	290c      	movi.n	a9, 2
4037894c:	fffa06        	j	40378938 <rtc_clk_cpu_freq_to_pll_mhz+0x10c>
4037894f:	00          	.byte 00
40378950:	00          	.byte 00
        abort();
40378951:	05e2a5        	call8	4037e77c <abort>
    switch (cpu_mhz) {
40378954:	a0a092        	movi	a9, 160
40378957:	f01d81        	l32r	a8, 403749cc <_iram_text_start+0x5c8>
4037895a:	761297        	beq	a2, a9, 403789d4 <rtc_clk_cpu_freq_to_pll_mhz+0x1a8>
4037895d:	f0a092        	movi	a9, 240
40378960:	029297        	bne	a2, a9, 40378966 <rtc_clk_cpu_freq_to_pll_mhz+0x13a>
40378963:	002046        	j	403789e8 <rtc_clk_cpu_freq_to_pll_mhz+0x1bc>
40378966:	095c      	movi.n	a9, 80
40378968:	e59297        	bne	a2, a9, 40378951 <rtc_clk_cpu_freq_to_pll_mhz+0x125>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 0);
4037896b:	0020c0        	memw
4037896e:	0898      	l32i.n	a9, a8, 0
40378970:	cb7c      	movi.n	a11, -4
40378972:	1099b0        	and	a9, a9, a11
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
40378975:	0020c0        	memw
40378978:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
4037897a:	f00091        	l32r	a9, 4037497c <_iram_text_start+0x578>
4037897d:	00acb2        	movi	a11, 0xfffffc00
40378980:	0020c0        	memw
40378983:	0988      	l32i.n	a8, a9, 0
40378985:	1088b0        	and	a8, a8, a11
40378988:	0020c0        	memw
4037898b:	0989      	s32i.n	a8, a9, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 1);
4037898d:	0020c0        	memw
40378990:	0988      	l32i.n	a8, a9, 0
40378992:	effdb1        	l32r	a11, 40374988 <_iram_text_start+0x584>
40378995:	1088b0        	and	a8, a8, a11
40378998:	00a4b2        	movi	a11, 0x400
4037899b:	2088b0        	or	a8, a8, a11
4037899e:	0020c0        	memw
403789a1:	0989      	s32i.n	a8, a9, 0
    s_apb_freq = apb_freq;
403789a3:	ef3481        	l32r	a8, 40374674 <_iram_text_start+0x270>
403789a6:	0a89      	s32i.n	a8, a10, 0
        ets_update_cpu_frequency(cpu_freq_mhz);
403789a8:	02ad      	mov.n	a10, a2
403789aa:	effb81        	l32r	a8, 40374998 <_iram_text_start+0x594>
403789ad:	0008e0        	callx8	a8
        REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE >> pd_slave);
403789b0:	eff891        	l32r	a9, 40374990 <_iram_text_start+0x58c>
403789b3:	720c      	movi.n	a2, 7
403789b5:	0020c0        	memw
403789b8:	0988      	l32i.n	a8, a9, 0
403789ba:	400300        	ssr	a3
403789bd:	b12020        	sra	a2, a2
403789c0:	eff531        	l32r	a3, 40374994 <_iram_text_start+0x590>
403789c3:	112230        	slli	a2, a2, 13
403789c6:	103830        	and	a3, a8, a3
403789c9:	202230        	or	a2, a2, a3
403789cc:	0020c0        	memw
403789cf:	0929      	s32i.n	a2, a9, 0
}
403789d1:	ffccc6        	j	40378908 <rtc_clk_cpu_freq_to_pll_mhz+0xdc>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 1);
403789d4:	0020c0        	memw
403789d7:	0898      	l32i.n	a9, a8, 0
403789d9:	cb7c      	movi.n	a11, -4
403789db:	1099b0        	and	a9, a9, a11
403789de:	1b0c      	movi.n	a11, 1
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPUPERIOD_SEL, 2);
403789e0:	2099b0        	or	a9, a9, a11
403789e3:	ffe386        	j	40378975 <rtc_clk_cpu_freq_to_pll_mhz+0x149>
403789e6:	00          	.byte 00
403789e7:	00          	.byte 00
403789e8:	0020c0        	memw
403789eb:	0898      	l32i.n	a9, a8, 0
403789ed:	cb7c      	movi.n	a11, -4
403789ef:	1099b0        	and	a9, a9, a11
403789f2:	2b0c      	movi.n	a11, 2
403789f4:	fffa06        	j	403789e0 <rtc_clk_cpu_freq_to_pll_mhz+0x1b4>
	...

403789f8 <rtc_clk_cpu_freq_set_xtal>:
{
403789f8:	004136        	entry	a1, 32
    int freq_mhz = (int)rtc_clk_xtal_freq_get();
403789fb:	ffd0a5        	call8	40378704 <rtc_clk_xtal_freq_get>
    rtc_clk_cpu_freq_to_xtal(freq_mhz, 1);
403789fe:	01a0b2        	movi	a11, 1
40378a01:	ff9f65        	call8	403783f8 <rtc_clk_cpu_freq_to_xtal>
 *
 * @return 0 if no data available, 1 if data available
 */
static inline int usb_serial_jtag_ll_txfifo_writable(void)
{
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
40378a04:	eff681        	l32r	a8, 403749dc <_iram_text_start+0x5d8>
40378a07:	0020c0        	memw
40378a0a:	1888      	l32i.n	a8, a8, 4
    user selects the `RTC_CLOCK_BBPLL_POWER_ON_WITH_USB` as well as
    the USB_SERIAL_JTAG is connected with PC.
    */
    bool is_bbpll_on = false;
#if CONFIG_RTC_CLOCK_BBPLL_POWER_ON_WITH_USB
    if (usb_serial_jtag_ll_txfifo_writable() == 1) {
40378a0c:	02e817        	bbsi	a8, 1, 40378a12 <rtc_clk_cpu_freq_set_xtal+0x1a>
        rtc_clk_bbpll_disable();
40378a0f:	ff9a25        	call8	403783b0 <rtc_clk_bbpll_disable>
}
40378a12:	f01d      	retw.n

40378a14 <rtc_clk_cpu_freq_set_config>:
{
40378a14:	006136        	entry	a1, 48
    uint32_t clk_sel = REG_GET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL);
40378a17:	efd931        	l32r	a3, 4037497c <_iram_text_start+0x578>
40378a1a:	0020c0        	memw
40378a1d:	002342        	l32i	a4, a3, 0
40378a20:	144a40        	extui	a4, a4, 10, 2
    switch (clk_sel) {
40378a23:	081426        	beqi	a4, 1, 40378a2f <rtc_clk_cpu_freq_set_config+0x1b>
40378a26:	052426        	beqi	a4, 2, 40378a2f <rtc_clk_cpu_freq_set_config+0x1b>
40378a29:	002416        	beqz	a4, 40378a2f <rtc_clk_cpu_freq_set_config+0x1b>
        return SOC_CPU_CLK_SRC_INVALID;
40378a2c:	03a042        	movi	a4, 3
    if (config->source == SOC_CPU_CLK_SRC_XTAL) {
40378a2f:	002232        	l32i	a3, a2, 0
40378a32:	83dc      	bnez.n	a3, 40378a4e <rtc_clk_cpu_freq_set_config+0x3a>
        rtc_clk_cpu_freq_to_xtal(config->freq_mhz, config->div);
40378a34:	22b8      	l32i.n	a11, a2, 8
40378a36:	32a8      	l32i.n	a10, a2, 12
40378a38:	ff9be5        	call8	403783f8 <rtc_clk_cpu_freq_to_xtal>
        if ((old_cpu_clk_src == SOC_CPU_CLK_SRC_PLL) && !rtc_clk_set_bbpll_always_on()) {
40378a3b:	0d1466        	bnei	a4, 1, 40378a4c <rtc_clk_cpu_freq_set_config+0x38>
40378a3e:	efe721        	l32r	a2, 403749dc <_iram_text_start+0x5d8>
40378a41:	0020c0        	memw
40378a44:	1228      	l32i.n	a2, a2, 4
    if (usb_serial_jtag_ll_txfifo_writable() == 1) {
40378a46:	02e217        	bbsi	a2, 1, 40378a4c <rtc_clk_cpu_freq_set_config+0x38>
            rtc_clk_bbpll_disable();
40378a49:	ff9665        	call8	403783b0 <rtc_clk_bbpll_disable>
}
40378a4c:	f01d      	retw.n
    } else if (config->source == SOC_CPU_CLK_SRC_PLL) {
40378a4e:	021326        	beqi	a3, 1, 40378a54 <rtc_clk_cpu_freq_set_config+0x40>
40378a51:	005806        	j	40378bb5 <rtc_clk_cpu_freq_set_config+0x1a1>
        if (old_cpu_clk_src != SOC_CPU_CLK_SRC_PLL) {
40378a54:	021466        	bnei	a4, 1, 40378a5a <rtc_clk_cpu_freq_set_config+0x46>
40378a57:	004706        	j	40378b77 <rtc_clk_cpu_freq_set_config+0x163>
    REG_CLR_BIT(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PD |
40378a5a:	eeaa41        	l32r	a4, 40374504 <_iram_text_start+0x100>
40378a5d:	bfaa52        	movi	a5, 0xfffffabf
40378a60:	0020c0        	memw
40378a63:	0438      	l32i.n	a3, a4, 0
40378a65:	103350        	and	a3, a3, a5
40378a68:	0020c0        	memw
40378a6b:	0439      	s32i.n	a3, a4, 0
            rtc_clk_bbpll_configure(rtc_clk_xtal_freq_get(), config->source_freq_mhz);
40378a6d:	ffc965        	call8	40378704 <rtc_clk_xtal_freq_get>
40378a70:	1248      	l32i.n	a4, a2, 4
    switch (pll_freq_mhz) {
40378a72:	40a152        	movi	a5, 0x140
40378a75:	efd531        	l32r	a3, 403749cc <_iram_text_start+0x5c8>
40378a78:	0b1457        	beq	a4, a5, 40378a87 <rtc_clk_cpu_freq_set_config+0x73>
40378a7b:	e0a152        	movi	a5, 0x1e0
40378a7e:	029457        	bne	a4, a5, 40378a84 <rtc_clk_cpu_freq_set_config+0x70>
40378a81:	003ec6        	j	40378b80 <rtc_clk_cpu_freq_set_config+0x16c>
        abort();
40378a84:	05cf65        	call8	4037e77c <abort>
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 0);
40378a87:	0020c0        	memw
40378a8a:	0358      	l32i.n	a5, a3, 0
40378a8c:	b67c      	movi.n	a6, -5
40378a8e:	105560        	and	a5, a5, a6
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 1);
40378a91:	0020c0        	memw
40378a94:	0359      	s32i.n	a5, a3, 0
/**
 * @brief Start BBPLL self-calibration
 */
static inline __attribute__((always_inline)) void regi2c_ctrl_ll_bbpll_calibration_start(void)
{
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
40378a96:	efd231        	l32r	a3, 403749e0 <_iram_text_start+0x5dc>
40378a99:	b67c      	movi.n	a6, -5
40378a9b:	0020c0        	memw
40378a9e:	0358      	l32i.n	a5, a3, 0
40378aa0:	105560        	and	a5, a5, a6
40378aa3:	0020c0        	memw
40378aa6:	0359      	s32i.n	a5, a3, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
40378aa8:	0020c0        	memw
40378aab:	0368      	l32i.n	a6, a3, 0
40378aad:	850c      	movi.n	a5, 8
40378aaf:	206650        	or	a6, a6, a5
40378ab2:	0020c0        	memw
40378ab5:	0369      	s32i.n	a6, a3, 0
    if (pll_freq_mhz == CLK_LL_PLL_480M_FREQ_MHZ) {
40378ab7:	e0a132        	movi	a3, 0x1e0
40378aba:	021437        	beq	a4, a3, 40378ac0 <rtc_clk_cpu_freq_set_config+0xac>
40378abd:	003306        	j	40378b8d <rtc_clk_cpu_freq_set_config+0x179>
            dcur = 0;
40378ac0:	4c0c      	movi.n	a12, 4
40378ac2:	e0caa2        	addi	a10, a10, -32
40378ac5:	070c      	movi.n	a7, 0
40378ac7:	5d0c      	movi.n	a13, 5
40378ac9:	0c8d      	mov.n	a8, a12
40378acb:	a31c      	movi.n	a3, 26
40378acd:	1b0c      	movi.n	a11, 1
40378acf:	360c      	movi.n	a6, 3
40378ad1:	938da0        	movnez	a8, a13, a10
40378ad4:	8367a0        	moveqz	a6, a7, a10
40378ad7:	8353a0        	moveqz	a5, a3, a10
40378ada:	837ba0        	moveqz	a7, a11, a10
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x6B);
40378add:	6ba0d2        	movi	a13, 107
40378ae0:	66a0a2        	movi	a10, 102
40378ae3:	0189      	s32i.n	a8, a1, 0
40378ae5:	fd7f25        	call8	403762d8 <regi2c_ctrl_write_reg>
40378ae8:	0188      	l32i.n	a8, a1, 0
40378aea:	073d      	mov.n	a3, a7
    uint8_t i2c_bbpll_lref  = (dchgp << I2C_BBPLL_OC_DCHGP_LSB) | (div_ref);
40378aec:	11d8c0        	slli	a13, a8, 4
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_REF_DIV, i2c_bbpll_lref);
40378aef:	20d7d0        	or	a13, a7, a13
40378af2:	2c0c      	movi.n	a12, 2
40378af4:	1b0c      	movi.n	a11, 1
40378af6:	66a0a2        	movi	a10, 102
40378af9:	fd7de5        	call8	403762d8 <regi2c_ctrl_write_reg>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DIV_7_0, i2c_bbpll_div_7_0);
40378afc:	05dd      	mov.n	a13, a5
40378afe:	3c0c      	movi.n	a12, 3
40378b00:	1b0c      	movi.n	a11, 1
40378b02:	66a0a2        	movi	a10, 102
40378b05:	fd7d25        	call8	403762d8 <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR1, dr1);
40378b08:	03fd      	mov.n	a15, a3
40378b0a:	0e0c      	movi.n	a14, 0
40378b0c:	2d0c      	movi.n	a13, 2
40378b0e:	5c0c      	movi.n	a12, 5
40378b10:	1b0c      	movi.n	a11, 1
40378b12:	66a0a2        	movi	a10, 102
40378b15:	fd7f65        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_DR3, dr3);
40378b18:	03fd      	mov.n	a15, a3
40378b1a:	4e0c      	movi.n	a14, 4
40378b1c:	6d0c      	movi.n	a13, 6
40378b1e:	5c0c      	movi.n	a12, 5
40378b20:	1b0c      	movi.n	a11, 1
40378b22:	66a0a2        	movi	a10, 102
40378b25:	fd7e65        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_OC_DCUR, i2c_bbpll_dcur);
40378b28:	70a0d2        	movi	a13, 112
40378b2b:	20d6d0        	or	a13, a6, a13
40378b2e:	6c0c      	movi.n	a12, 6
40378b30:	1b0c      	movi.n	a11, 1
40378b32:	66a0a2        	movi	a10, 102
40378b35:	fd7a25        	call8	403762d8 <regi2c_ctrl_write_reg>
    REGI2C_WRITE_MASK(I2C_BBPLL, I2C_BBPLL_OC_VCO_DBIAS, dbias);
40378b38:	1d0c      	movi.n	a13, 1
40378b3a:	2f0c      	movi.n	a15, 2
40378b3c:	0e0c      	movi.n	a14, 0
40378b3e:	9c0c      	movi.n	a12, 9
40378b40:	20bdd0        	or	a11, a13, a13
40378b43:	66a0a2        	movi	a10, 102
40378b46:	fd7c65        	call8	4037630c <regi2c_ctrl_write_reg_mask>
 *
 * @return True if calibration is done; otherwise false
 */
static inline __attribute__((always_inline)) bool regi2c_ctrl_ll_bbpll_calibration_is_done(void)
{
    return REG_GET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_CAL_DONE);
40378b49:	efa531        	l32r	a3, 403749e0 <_iram_text_start+0x5dc>
40378b4c:	0020c0        	memw
40378b4f:	0358      	l32i.n	a5, a3, 0
    while(!regi2c_ctrl_ll_bbpll_calibration_is_done());
40378b51:	f77587        	bbci	a5, 24, 40378b4c <rtc_clk_cpu_freq_set_config+0x138>
    REG_CLR_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_LOW);
40378b54:	0020c0        	memw
40378b57:	0358      	l32i.n	a5, a3, 0
40378b59:	767c      	movi.n	a6, -9
40378b5b:	105560        	and	a5, a5, a6
40378b5e:	0020c0        	memw
40378b61:	0359      	s32i.n	a5, a3, 0
    REG_SET_BIT(I2C_MST_ANA_CONF0_REG, I2C_MST_BBPLL_STOP_FORCE_HIGH);
40378b63:	0020c0        	memw
40378b66:	0358      	l32i.n	a5, a3, 0
40378b68:	460c      	movi.n	a6, 4
40378b6a:	205560        	or	a5, a5, a6
40378b6d:	0020c0        	memw
40378b70:	0359      	s32i.n	a5, a3, 0
    s_cur_pll_freq = pll_freq;
40378b72:	ef7b31        	l32r	a3, 40374960 <_iram_text_start+0x55c>
40378b75:	0349      	s32i.n	a4, a3, 0
        rtc_clk_cpu_freq_to_pll_mhz(config->freq_mhz);
40378b77:	32a8      	l32i.n	a10, a2, 12
40378b79:	ffcb25        	call8	4037882c <rtc_clk_cpu_freq_to_pll_mhz>
40378b7c:	ffb306        	j	40378a4c <rtc_clk_cpu_freq_set_config+0x38>
40378b7f:	00          	.byte 00
        REG_SET_FIELD(SYSTEM_CPU_PER_CONF_REG, SYSTEM_PLL_FREQ_SEL, 1);
40378b80:	0020c0        	memw
40378b83:	0358      	l32i.n	a5, a3, 0
40378b85:	460c      	movi.n	a6, 4
40378b87:	205560        	or	a5, a5, a6
40378b8a:	ffc0c6        	j	40378a91 <rtc_clk_cpu_freq_set_config+0x7d>
            div7_0 = 6;
40378b8d:	01a0b2        	movi	a11, 1
40378b90:	e0caa2        	addi	a10, a10, -32
40378b93:	04a0c2        	movi	a12, 4
40378b96:	206bb0        	or	a6, a11, a11
40378b99:	650c      	movi.n	a5, 6
40378b9b:	030c      	movi.n	a3, 0
40378b9d:	9363a0        	movnez	a6, a3, a10
40378ba0:	935ca0        	movnez	a5, a12, a10
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x69);
40378ba3:	69a0d2        	movi	a13, 105
40378ba6:	66a0a2        	movi	a10, 102
40378ba9:	fd72e5        	call8	403762d8 <regi2c_ctrl_write_reg>
            div7_0 = 6;
40378bac:	067d      	mov.n	a7, a6
        REGI2C_WRITE(I2C_BBPLL, I2C_BBPLL_MODE_HF, 0x69);
40378bae:	580c      	movi.n	a8, 5
40378bb0:	360c      	movi.n	a6, 3
40378bb2:	ffcd86        	j	40378aec <rtc_clk_cpu_freq_set_config+0xd8>
    } else if (config->source == SOC_CPU_CLK_SRC_RC_FAST) {
40378bb5:	022326        	beqi	a3, 2, 40378bbb <rtc_clk_cpu_freq_set_config+0x1a7>
40378bb8:	ffa406        	j	40378a4c <rtc_clk_cpu_freq_set_config+0x38>
    ets_update_cpu_frequency(20);
40378bbb:	4a1c      	movi.n	a10, 20
40378bbd:	ef7681        	l32r	a8, 40374998 <_iram_text_start+0x594>
40378bc0:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
40378bc3:	ef6c21        	l32r	a2, 40374974 <_iram_text_start+0x570>
40378bc6:	4d0c      	movi.n	a13, 4
40378bc8:	0002f2        	l8ui	a15, a2, 0
40378bcb:	0dcd      	mov.n	a12, a13
40378bcd:	0e0c      	movi.n	a14, 0
40378bcf:	1b0c      	movi.n	a11, 1
40378bd1:	6da0a2        	movi	a10, 109
40378bd4:	fd7365        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
40378bd7:	ef6821        	l32r	a2, 40374978 <_iram_text_start+0x574>
40378bda:	0e0c      	movi.n	a14, 0
40378bdc:	0002f2        	l8ui	a15, a2, 0
40378bdf:	4d0c      	movi.n	a13, 4
40378be1:	6c0c      	movi.n	a12, 6
40378be3:	01a0b2        	movi	a11, 1
40378be6:	6da0a2        	movi	a10, 109
40378be9:	fd7225        	call8	4037630c <regi2c_ctrl_write_reg_mask>
    esp_rom_delay_us(40);
40378bec:	8a2c      	movi.n	a10, 40
40378bee:	ee1481        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378bf1:	0008e0        	callx8	a8
    REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_PRE_DIV_CNT, divider - 1);
40378bf4:	ef6221        	l32r	a2, 4037497c <_iram_text_start+0x578>
40378bf7:	00ac52        	movi	a5, 0xfffffc00
40378bfa:	0020c0        	memw
40378bfd:	0238      	l32i.n	a3, a2, 0
40378bff:	103350        	and	a3, a3, a5
40378c02:	0020c0        	memw
40378c05:	0239      	s32i.n	a3, a2, 0
        REG_SET_FIELD(SYSTEM_SYSCLK_CONF_REG, SYSTEM_SOC_CLK_SEL, 2);
40378c07:	0020c0        	memw
40378c0a:	0238      	l32i.n	a3, a2, 0
40378c0c:	ef5f51        	l32r	a5, 40374988 <_iram_text_start+0x584>
40378c0f:	103350        	and	a3, a3, a5
40378c12:	150c      	movi.n	a5, 1
40378c14:	115550        	slli	a5, a5, 11
40378c17:	203350        	or	a3, a3, a5
40378c1a:	0020c0        	memw
40378c1d:	0239      	s32i.n	a3, a2, 0
    s_apb_freq = apb_freq;
40378c1f:	ef5b21        	l32r	a2, 4037498c <_iram_text_start+0x588>
40378c22:	ef7031        	l32r	a3, 403749e4 <_iram_text_start+0x5e0>
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378c25:	ef5a51        	l32r	a5, 40374990 <_iram_text_start+0x58c>
    s_apb_freq = apb_freq;
40378c28:	0239      	s32i.n	a3, a2, 0
    REG_SET_FIELD(RTC_CNTL_DATE_REG, RTC_CNTL_SLAVE_PD,  DEFAULT_LDO_SLAVE);
40378c2a:	0020c0        	memw
40378c2d:	0538      	l32i.n	a3, a5, 0
40378c2f:	ef5921        	l32r	a2, 40374994 <_iram_text_start+0x590>
40378c32:	103320        	and	a3, a3, a2
40378c35:	720c      	movi.n	a2, 7
40378c37:	112230        	slli	a2, a2, 13
40378c3a:	203320        	or	a3, a3, a2
40378c3d:	0020c0        	memw
40378c40:	0539      	s32i.n	a3, a5, 0
        if ((old_cpu_clk_src == SOC_CPU_CLK_SRC_PLL) && !rtc_clk_set_bbpll_always_on()) {
40378c42:	ff7d46        	j	40378a3b <rtc_clk_cpu_freq_set_config+0x27>
40378c45:	000000        	ill

40378c48 <rtc_dig_clk8m_enable>:
{
40378c48:	004136        	entry	a1, 32
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_EN_M);
40378c4b:	ef4691        	l32r	a9, 40374964 <_iram_text_start+0x560>
40378c4e:	00a4a2        	movi	a10, 0x400
40378c51:	0020c0        	memw
40378c54:	0988      	l32i.n	a8, a9, 0
40378c56:	2088a0        	or	a8, a8, a10
40378c59:	0020c0        	memw
40378c5c:	0989      	s32i.n	a8, a9, 0
    esp_rom_delay_us(SOC_DELAY_RC_FAST_DIGI_SWITCH);
40378c5e:	5a0c      	movi.n	a10, 5
40378c60:	edf881        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378c63:	0008e0        	callx8	a8
}
40378c66:	f01d      	retw.n

40378c68 <rtc_dig_clk8m_disable>:
{
40378c68:	004136        	entry	a1, 32
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_EN_M);
40378c6b:	ef3e91        	l32r	a9, 40374964 <_iram_text_start+0x560>
40378c6e:	ffaba2        	movi	a10, 0xfffffbff
40378c71:	0020c0        	memw
40378c74:	0988      	l32i.n	a8, a9, 0
40378c76:	1088a0        	and	a8, a8, a10
40378c79:	0020c0        	memw
40378c7c:	0989      	s32i.n	a8, a9, 0
    esp_rom_delay_us(SOC_DELAY_RC_FAST_DIGI_SWITCH);
40378c7e:	5a0c      	movi.n	a10, 5
40378c80:	edf081        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378c83:	0008e0        	callx8	a8
}
40378c86:	f01d      	retw.n

40378c88 <rtc_sleep_pu>:
/**
 * Configure whether certain peripherals are powered up in sleep
 * @param cfg power down flags as rtc_sleep_pu_config_t structure
 */
void rtc_sleep_pu(rtc_sleep_pu_config_t cfg)
{
40378c88:	004136        	entry	a1, 32
    REG_SET_FIELD(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_LSLP_MEM_FORCE_PU, cfg.dig_fpu);
40378c8b:	ef5731        	l32r	a3, 403749e8 <_iram_text_start+0x5e4>
40378c8e:	fe6c      	movi.n	a14, -17
40378c90:	0020c0        	memw
40378c93:	03f8      	l32i.n	a15, a3, 0
40378c95:	049020        	extui	a9, a2, 0, 1
40378c98:	10ffe0        	and	a15, a15, a14
40378c9b:	1199c0        	slli	a9, a9, 4
40378c9e:	2099f0        	or	a9, a9, a15
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_LPU, cfg.rtc_fpu);
40378ca1:	ef52f1        	l32r	a15, 403749ec <_iram_text_start+0x5e8>
    REG_SET_FIELD(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_LSLP_MEM_FORCE_PU, cfg.dig_fpu);
40378ca4:	0020c0        	memw
40378ca7:	0399      	s32i.n	a9, a3, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_FASTMEM_FORCE_LPU, cfg.rtc_fpu);
40378ca9:	0020c0        	memw
40378cac:	0f98      	l32i.n	a9, a15, 0
40378cae:	04b120        	extui	a11, a2, 1, 1
40378cb1:	ffae32        	movi	a3, 0xfffffeff
40378cb4:	109930        	and	a9, a9, a3
40378cb7:	113b80        	slli	a3, a11, 8
40378cba:	209930        	or	a9, a9, a3
40378cbd:	0020c0        	memw
40378cc0:	0f99      	s32i.n	a9, a15, 0
    REG_SET_FIELD(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_LPU, cfg.rtc_fpu);
40378cc2:	0020c0        	memw
40378cc5:	0f98      	l32i.n	a9, a15, 0
40378cc7:	ef4a31        	l32r	a3, 403749f0 <_iram_text_start+0x5ec>
40378cca:	11bb50        	slli	a11, a11, 11
40378ccd:	109930        	and	a9, a9, a3
40378cd0:	2099b0        	or	a9, a9, a11
40378cd3:	0020c0        	memw
40378cd6:	0f99      	s32i.n	a9, a15, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_DC_MEM_FORCE_PU, cfg.fe_fpu);
40378cd8:	ef4791        	l32r	a9, 403749f4 <_iram_text_start+0x5f0>
40378cdb:	048620        	extui	a8, a2, 6, 1
40378cde:	0020c0        	memw
40378ce1:	09b8      	l32i.n	a11, a9, 0
40378ce3:	1138c0        	slli	a3, a8, 4
40378ce6:	10bbe0        	and	a11, a11, a14
40378ce9:	20bb30        	or	a11, a11, a3
40378cec:	0020c0        	memw
40378cef:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_PBUS_MEM_FORCE_PU, cfg.fe_fpu);
40378cf1:	0020c0        	memw
40378cf4:	09b8      	l32i.n	a11, a9, 0
40378cf6:	b37c      	movi.n	a3, -5
40378cf8:	10bb30        	and	a11, a11, a3
40378cfb:	1138e0        	slli	a3, a8, 2
40378cfe:	20bb30        	or	a11, a11, a3
40378d01:	0020c0        	memw
40378d04:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(SYSCON_FRONT_END_MEM_PD_REG, SYSCON_AGC_MEM_FORCE_PU, cfg.fe_fpu);
40378d06:	0020c0        	memw
40378d09:	09b8      	l32i.n	a11, a9, 0
40378d0b:	e37c      	movi.n	a3, -2
40378d0d:	10bb30        	and	a11, a11, a3
40378d10:	20bb80        	or	a11, a11, a8
40378d13:	0020c0        	memw
40378d16:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(BBPD_CTRL, BB_FFT_FORCE_PU, cfg.bb_fpu);
40378d18:	ef38b1        	l32r	a11, 403749f8 <_iram_text_start+0x5f4>
40378d1b:	04d420        	extui	a13, a2, 4, 1
40378d1e:	0020c0        	memw
40378d21:	0b98      	l32i.n	a9, a11, 0
40378d23:	7f7c      	movi.n	a15, -9
40378d25:	113dd0        	slli	a3, a13, 3
40378d28:	1099f0        	and	a9, a9, a15
40378d2b:	209930        	or	a9, a9, a3
40378d2e:	0020c0        	memw
40378d31:	0b99      	s32i.n	a9, a11, 0
    REG_SET_FIELD(BBPD_CTRL, BB_DC_EST_FORCE_PU, cfg.bb_fpu);
40378d33:	0020c0        	memw
40378d36:	0b98      	l32i.n	a9, a11, 0
40378d38:	de7c      	movi.n	a14, -3
40378d3a:	ddda      	add.n	a13, a13, a13
40378d3c:	1099e0        	and	a9, a9, a14
40378d3f:	2099d0        	or	a9, a9, a13
40378d42:	0020c0        	memw
40378d45:	0b99      	s32i.n	a9, a11, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_RX_ROT_FORCE_PU, cfg.nrx_fpu);
40378d47:	ef2d91        	l32r	a9, 403749fc <_iram_text_start+0x5f8>
40378d4a:	04c520        	extui	a12, a2, 5, 1
40378d4d:	0020c0        	memw
40378d50:	09b8      	l32i.n	a11, a9, 0
40378d52:	dfafd2        	movi	a13, -33
40378d55:	113cb0        	slli	a3, a12, 5
40378d58:	10bbd0        	and	a11, a11, a13
40378d5b:	20bb30        	or	a11, a11, a3
40378d5e:	0020c0        	memw
40378d61:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_VIT_FORCE_PU, cfg.nrx_fpu);
40378d63:	0020c0        	memw
40378d66:	09b8      	l32i.n	a11, a9, 0
40378d68:	113cd0        	slli	a3, a12, 3
40378d6b:	10bbf0        	and	a11, a11, a15
40378d6e:	20bb30        	or	a11, a11, a3
40378d71:	0020c0        	memw
40378d74:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(NRXPD_CTRL, NRX_DEMAP_FORCE_PU, cfg.nrx_fpu);
40378d76:	0020c0        	memw
40378d79:	09b8      	l32i.n	a11, a9, 0
40378d7b:	ccca      	add.n	a12, a12, a12
40378d7d:	10bbe0        	and	a11, a11, a14
40378d80:	20bbc0        	or	a11, a11, a12
40378d83:	0020c0        	memw
40378d86:	09b9      	s32i.n	a11, a9, 0
    REG_SET_FIELD(FE_GEN_CTRL, FE_IQ_EST_FORCE_PU, cfg.fe_fpu);
40378d88:	ef1eb1        	l32r	a11, 40374a00 <_iram_text_start+0x5fc>
40378d8b:	1138b0        	slli	a3, a8, 5
40378d8e:	0020c0        	memw
40378d91:	0b98      	l32i.n	a9, a11, 0
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40378d93:	118860        	slli	a8, a8, 10
    REG_SET_FIELD(FE_GEN_CTRL, FE_IQ_EST_FORCE_PU, cfg.fe_fpu);
40378d96:	1099d0        	and	a9, a9, a13
40378d99:	209930        	or	a9, a9, a3
40378d9c:	0020c0        	memw
40378d9f:	0b99      	s32i.n	a9, a11, 0
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40378da1:	ef18b1        	l32r	a11, 40374a04 <_iram_text_start+0x600>
40378da4:	ffab32        	movi	a3, 0xfffffbff
40378da7:	0020c0        	memw
40378daa:	0b98      	l32i.n	a9, a11, 0
40378dac:	74a020        	extui	a10, a2, 0, 8
40378daf:	109930        	and	a9, a9, a3
40378db2:	208980        	or	a8, a9, a8
    if (cfg.sram_fpu) {
40378db5:	72a032        	movi	a3, 114
    REG_SET_FIELD(FE2_TX_INTERP_CTRL, FE2_TX_INF_FORCE_PU, cfg.fe_fpu);
40378db8:	0020c0        	memw
40378dbb:	0b89      	s32i.n	a8, a11, 0
    if (cfg.sram_fpu) {
40378dbd:	8daf82        	movi	a8, -115
40378dc0:	108280        	and	a8, a2, a8
40378dc3:	10aa30        	and	a10, a10, a3
40378dc6:	2088a0        	or	a8, a8, a10
40378dc9:	00af92        	movi	a9, 0xffffff00
40378dcc:	109290        	and	a9, a2, a9
40378dcf:	748080        	extui	a8, a8, 0, 8
40378dd2:	80a032        	movi	a3, 128
40378dd5:	202980        	or	a2, a9, a8
40378dd8:	ef0c91        	l32r	a9, 40374a08 <_iram_text_start+0x604>
40378ddb:	290837        	bnone	a8, a3, 40378e08 <rtc_sleep_pu+0x180>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, SYSCON_SRAM_POWER_UP);
40378dde:	0020c0        	memw
40378de1:	0988      	l32i.n	a8, a9, 0
40378de3:	ffa7a2        	movi	a10, 0x7ff
40378de6:	11aad0        	slli	a10, a10, 3
40378de9:	2088a0        	or	a8, a8, a10
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, 0);
40378dec:	0020c0        	memw
40378def:	0989      	s32i.n	a8, a9, 0
    }
    if (cfg.rom_ram_fpu) {
40378df1:	ef0581        	l32r	a8, 40374a08 <_iram_text_start+0x604>
40378df4:	206287        	bbci	a2, 8, 40378e18 <rtc_sleep_pu+0x190>
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, SYSCON_ROM_POWER_UP);
40378df7:	0020c0        	memw
40378dfa:	0828      	l32i.n	a2, a8, 0
40378dfc:	730c      	movi.n	a3, 7
40378dfe:	202230        	or	a2, a2, a3
    } else {
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, 0);
40378e01:	0020c0        	memw
40378e04:	0829      	s32i.n	a2, a8, 0
    }
}
40378e06:	f01d      	retw.n
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_SRAM_POWER_UP, 0);
40378e08:	0020c0        	memw
40378e0b:	0988      	l32i.n	a8, a9, 0
40378e0d:	eeff31        	l32r	a3, 40374a0c <_iram_text_start+0x608>
40378e10:	108830        	and	a8, a8, a3
40378e13:	fff546        	j	40378dec <rtc_sleep_pu+0x164>
40378e16:	00          	.byte 00
40378e17:	00          	.byte 00
        REG_SET_FIELD(SYSCON_MEM_POWER_UP_REG, SYSCON_ROM_POWER_UP, 0);
40378e18:	0020c0        	memw
40378e1b:	0828      	l32i.n	a2, a8, 0
40378e1d:	837c      	movi.n	a3, -8
40378e1f:	102230        	and	a2, a2, a3
40378e22:	fff6c6        	j	40378e01 <rtc_sleep_pu+0x179>
40378e25:	000000        	ill

40378e28 <rtc_clk_cal_internal>:
 * @param cal_clk which clock to calibrate
 * @param slowclk_cycles number of slow clock cycles to count
 * @return number of XTAL clock cycles within the given number of slow clock cycles
 */
uint32_t rtc_clk_cal_internal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
40378e28:	006136        	entry	a1, 48
40378e2b:	024d      	mov.n	a4, a2
40378e2d:	208330        	or	a8, a3, a3
    /* On ESP32S3, choosing RTC_CAL_RTC_MUX results in calibration of
     * the 150k RTC clock regardless of the currenlty selected SLOW_CLK.
     * On the ESP32, it used the currently selected SLOW_CLK.
     * The following code emulates ESP32 behavior:
     */
    if (cal_clk == RTC_CAL_RTC_MUX) {
40378e30:	194256        	bnez	a2, 40378fc8 <rtc_clk_cal_internal+0x1a0>
        soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
40378e33:	006132        	s32i	a3, a1, 0
40378e36:	ff8665        	call8	4037869c <rtc_clk_slow_src_get>
        if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
40378e39:	0188      	l32i.n	a8, a1, 0
40378e3b:	021a66        	bnei	a10, 1, 40378e41 <rtc_clk_cal_internal+0x19>
40378e3e:	006486        	j	40378fd4 <rtc_clk_cal_internal+0x1ac>
            cal_clk = RTC_CAL_32K_XTAL;
        } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
40378e41:	fecaa2        	addi	a10, a10, -2
40378e44:	120c      	movi.n	a2, 1
40378e46:	8342a0        	moveqz	a4, a2, a10
    return REG_GET_FIELD(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN);
40378e49:	eec621        	l32r	a2, 40374964 <_iram_text_start+0x560>
        cal_clk = RTC_CAL_RTC_MUX;
    }

    /* Enable requested clock (150k clock is always on) */
    bool dig_32k_xtal_enabled = clk_ll_xtal32k_digi_is_enabled();
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
40378e4c:	150c      	movi.n	a5, 1
40378e4e:	0020c0        	memw
40378e51:	0238      	l32i.n	a3, a2, 0
40378e53:	fec472        	addi	a7, a4, -2
40378e56:	043830        	extui	a3, a3, 8, 1
40378e59:	303350        	xor	a3, a3, a5
40378e5c:	160c      	movi.n	a6, 1
40378e5e:	050c      	movi.n	a5, 0
40378e60:	936570        	movnez	a6, a5, a7
40378e63:	106630        	and	a6, a6, a3
40378e66:	0f1657        	beq	a6, a5, 40378e79 <rtc_clk_cal_internal+0x51>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378e69:	0020c0        	memw
40378e6c:	0238      	l32i.n	a3, a2, 0
40378e6e:	00a152        	movi	a5, 0x100
40378e71:	203350        	or	a3, a3, a5
40378e74:	0020c0        	memw
40378e77:	0239      	s32i.n	a3, a2, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
40378e79:	0020c0        	memw
40378e7c:	0278      	l32i.n	a7, a2, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
40378e7e:	0020c0        	memw
40378e81:	0238      	l32i.n	a3, a2, 0
        clk_ll_xtal32k_digi_enable();
    }

    bool rc_fast_enabled = clk_ll_rc_fast_is_enabled();
    bool rc_fast_d256_enabled = clk_ll_rc_fast_d256_is_enabled();
    if (cal_clk == RTC_CAL_8MD256) {
40378e83:	1d1466        	bnei	a4, 1, 40378ea4 <rtc_clk_cal_internal+0x7c>
        rtc_clk_8m_enable(true, true);
40378e86:	04bd      	mov.n	a11, a4
40378e88:	20a440        	or	a10, a4, a4
40378e8b:	0189      	s32i.n	a8, a1, 0
40378e8d:	ff6f65        	call8	40378584 <rtc_clk_8m_enable>
    SET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40378e90:	0020c0        	memw
40378e93:	002252        	l32i	a5, a2, 0
40378e96:	00a292        	movi	a9, 0x200
40378e99:	205590        	or	a5, a5, a9
40378e9c:	002182        	l32i	a8, a1, 0
40378e9f:	0020c0        	memw
40378ea2:	0259      	s32i.n	a5, a2, 0
        clk_ll_rc_fast_d256_digi_enable();
    }
    /* There may be another calibration process already running during we call this function,
     * so we should wait the last process is done.
     */
    if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING)) {
40378ea4:	eedb91        	l32r	a9, 40374a10 <_iram_text_start+0x60c>
40378ea7:	0020c0        	memw
40378eaa:	0928      	l32i.n	a2, a9, 0
40378eac:	2562c7        	bbci	a2, 12, 40378ed5 <rtc_clk_cal_internal+0xad>
        /**
         * Set a small timeout threshold to accelerate the generation of timeout.
         * The internal circuit will be reset when the timeout occurs and will not affect the next calibration.
         */
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, 1);
40378eaf:	eed951        	l32r	a5, 40374a14 <_iram_text_start+0x610>
40378eb2:	80a0a2        	movi	a10, 128
40378eb5:	0020c0        	memw
40378eb8:	0528      	l32i.n	a2, a5, 0
40378eba:	742020        	extui	a2, a2, 0, 8
40378ebd:	2022a0        	or	a2, a2, a10
40378ec0:	0020c0        	memw
40378ec3:	0529      	s32i.n	a2, a5, 0
        while (!GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)
40378ec5:	0020c0        	memw
40378ec8:	0928      	l32i.n	a2, a9, 0
               && !GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT));
40378eca:	07e2f7        	bbsi	a2, 15, 40378ed5 <rtc_clk_cal_internal+0xad>
40378ecd:	0020c0        	memw
40378ed0:	0528      	l32i.n	a2, a5, 0
40378ed2:	ef6207        	bbci	a2, 0, 40378ec5 <rtc_clk_cal_internal+0x9d>
    }

    /* Prepare calibration */
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_CLK_SEL, cal_clk);
40378ed5:	eece51        	l32r	a5, 40374a10 <_iram_text_start+0x60c>
40378ed8:	3a0c      	movi.n	a10, 3
40378eda:	11aa30        	slli	a10, a10, 13
40378edd:	112430        	slli	a2, a4, 13
40378ee0:	0020c0        	memw
40378ee3:	0598      	l32i.n	a9, a5, 0
40378ee5:	1022a0        	and	a2, a2, a10
40378ee8:	eecca1        	l32r	a10, 40374a18 <_iram_text_start+0x614>
40378eeb:	1099a0        	and	a9, a9, a10
40378eee:	202290        	or	a2, a2, a9
40378ef1:	0020c0        	memw
40378ef4:	0529      	s32i.n	a2, a5, 0
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);
40378ef6:	0020c0        	memw
40378ef9:	0528      	l32i.n	a2, a5, 0
40378efb:	eec891        	l32r	a9, 40374a1c <_iram_text_start+0x618>
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);
40378efe:	eec8a1        	l32r	a10, 40374a20 <_iram_text_start+0x61c>
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START_CYCLING);
40378f01:	102290        	and	a2, a2, a9
40378f04:	0020c0        	memw
40378f07:	0529      	s32i.n	a2, a5, 0
    REG_SET_FIELD(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_MAX, slowclk_cycles);
40378f09:	112800        	slli	a2, a8, 16
40378f0c:	0020c0        	memw
40378f0f:	0598      	l32i.n	a9, a5, 0
40378f11:	1022a0        	and	a2, a2, a10
40378f14:	eec4a1        	l32r	a10, 40374a24 <_iram_text_start+0x620>
40378f17:	1099a0        	and	a9, a9, a10
40378f1a:	202290        	or	a2, a2, a9
40378f1d:	0020c0        	memw
40378f20:	0529      	s32i.n	a2, a5, 0
    /* Figure out how long to wait for calibration to finish */

    /* Set timeout reg and expect time delay*/
    uint32_t expected_freq;
    if (cal_clk == RTC_CAL_32K_XTAL) {
40378f22:	eebc21        	l32r	a2, 40374a14 <_iram_text_start+0x610>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
40378f25:	0020c0        	memw
40378f28:	0258      	l32i.n	a5, a2, 0
40378f2a:	645050        	extui	a5, a5, 0, 7
    if (cal_clk == RTC_CAL_32K_XTAL) {
40378f2d:	022426        	beqi	a4, 2, 40378f33 <rtc_clk_cal_internal+0x10b>
40378f30:	002946        	j	40378fd9 <rtc_clk_cal_internal+0x1b1>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
40378f33:	0198d0        	slli	a9, a8, 19
40378f36:	205590        	or	a5, a5, a9
        expected_freq = SOC_CLK_XTAL32K_FREQ_APPROX;
40378f39:	1c0c      	movi.n	a12, 1
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_X32K_CAL_TIMEOUT_THRES(slowclk_cycles));
40378f3b:	0020c0        	memw
40378f3e:	0259      	s32i.n	a5, a2, 0
        expected_freq = SOC_CLK_XTAL32K_FREQ_APPROX;
40378f40:	11cc10        	slli	a12, a12, 15
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
    }
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
    /* Start calibration */
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40378f43:	eeb351        	l32r	a5, 40374a10 <_iram_text_start+0x60c>
40378f46:	ee3191        	l32r	a9, 4037480c <_iram_text_start+0x408>
40378f49:	0020c0        	memw
40378f4c:	0528      	l32i.n	a2, a5, 0
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
40378f4e:	edc7a1        	l32r	a10, 4037466c <_iram_text_start+0x268>
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40378f51:	102290        	and	a2, a2, a9
40378f54:	0020c0        	memw
40378f57:	0529      	s32i.n	a2, a5, 0
    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40378f59:	0020c0        	memw
40378f5c:	0528      	l32i.n	a2, a5, 0
40378f5e:	f97c      	movi.n	a9, -1
40378f60:	019910        	slli	a9, a9, 31
40378f63:	202290        	or	a2, a2, a9
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
40378f66:	a2b8a0        	muluh	a11, a8, a10
40378f69:	82a8a0        	mull	a10, a8, a10
40378f6c:	0d0c      	movi.n	a13, 0
    SET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40378f6e:	0020c0        	memw
40378f71:	0529      	s32i.n	a2, a5, 0
    uint32_t us_time_estimate = (uint32_t) (((uint64_t) slowclk_cycles) * MHZ / expected_freq);
40378f73:	edfb81        	l32r	a8, 40374760 <_iram_text_start+0x35c>
40378f76:	0008e0        	callx8	a8

    /* Wait for calibration to finish up to another us_time_estimate */
    esp_rom_delay_us(us_time_estimate);
40378f79:	ed3181        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40378f7c:	0008e0        	callx8	a8
    while (true) {
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)) {
            cal_val = REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);
            break;
        }
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT)) {
40378f7f:	eea591        	l32r	a9, 40374a14 <_iram_text_start+0x610>
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_RDY)) {
40378f82:	0020c0        	memw
40378f85:	0528      	l32i.n	a2, a5, 0
40378f87:	180c      	movi.n	a8, 1
40378f89:	118810        	slli	a8, a8, 15
40378f8c:	102280        	and	a2, a2, a8
40378f8f:	06d216        	beqz	a2, 40379000 <rtc_clk_cal_internal+0x1d8>
            cal_val = REG_GET_FIELD(TIMG_RTCCALICFG1_REG(0), TIMG_RTC_CALI_VALUE);
40378f92:	eea521        	l32r	a2, 40374a28 <_iram_text_start+0x624>
40378f95:	0020c0        	memw
40378f98:	0228      	l32i.n	a2, a2, 0
40378f9a:	412720        	srli	a2, a2, 7
            cal_val = 0;
            break;
        }
    }
    CLEAR_PERI_REG_MASK(TIMG_RTCCALICFG_REG(0), TIMG_RTC_CALI_START);
40378f9d:	0020c0        	memw
40378fa0:	0588      	l32i.n	a8, a5, 0
40378fa2:	ee1a91        	l32r	a9, 4037480c <_iram_text_start+0x408>
40378fa5:	108890        	and	a8, a8, a9
40378fa8:	0020c0        	memw
40378fab:	0589      	s32i.n	a8, a5, 0

    /* if dig_32k_xtal was originally off and enabled due to calibration, then set back to off state */
    if (cal_clk == RTC_CAL_32K_XTAL && !dig_32k_xtal_enabled) {
40378fad:	05f616        	beqz	a6, 40379010 <rtc_clk_cal_internal+0x1e8>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_XTAL32K_EN_M);
40378fb0:	ee6d41        	l32r	a4, 40374964 <_iram_text_start+0x560>
40378fb3:	ffae52        	movi	a5, 0xfffffeff
40378fb6:	0020c0        	memw
40378fb9:	0438      	l32i.n	a3, a4, 0
40378fbb:	103350        	and	a3, a3, a5
40378fbe:	0020c0        	memw
40378fc1:	006432        	s32i	a3, a4, 0
        clk_ll_rc_fast_d256_digi_disable();
        rtc_clk_8m_enable(rc_fast_enabled, rc_fast_d256_enabled);
    }

    return cal_val;
}
40378fc4:	f01d      	retw.n
40378fc6:	00          	.byte 00
40378fc7:	00          	.byte 00
    } else if (cal_clk == RTC_CAL_INTERNAL_OSC) {
40378fc8:	023226        	beqi	a2, 3, 40378fce <rtc_clk_cal_internal+0x1a6>
40378fcb:	ff9e86        	j	40378e49 <rtc_clk_cal_internal+0x21>
        cal_clk = RTC_CAL_RTC_MUX;
40378fce:	040c      	movi.n	a4, 0
40378fd0:	ff9d46        	j	40378e49 <rtc_clk_cal_internal+0x21>
40378fd3:	00          	.byte 00
            cal_clk = RTC_CAL_32K_XTAL;
40378fd4:	240c      	movi.n	a4, 2
40378fd6:	ff9bc6        	j	40378e49 <rtc_clk_cal_internal+0x21>
    } else if (cal_clk == RTC_CAL_8MD256) {
40378fd9:	101466        	bnei	a4, 1, 40378fed <rtc_clk_cal_internal+0x1c5>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_8MD256_CAL_TIMEOUT_THRES(slowclk_cycles));
40378fdc:	0198d0        	slli	a9, a8, 19
40378fdf:	205590        	or	a5, a5, a9
        expected_freq = SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40378fe2:	ee78c1        	l32r	a12, 403749c4 <_iram_text_start+0x5c0>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_8MD256_CAL_TIMEOUT_THRES(slowclk_cycles));
40378fe5:	0020c0        	memw
40378fe8:	0259      	s32i.n	a5, a2, 0
        expected_freq = SOC_CLK_RC_FAST_D256_FREQ_APPROX;
40378fea:	ffd546        	j	40378f43 <rtc_clk_cal_internal+0x11b>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
40378fed:	0198f0        	slli	a9, a8, 17
40378ff0:	205590        	or	a5, a5, a9
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
40378ff3:	ee73c1        	l32r	a12, 403749c0 <_iram_text_start+0x5bc>
        REG_SET_FIELD(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT_THRES, RTC_SLOW_CLK_150K_CAL_TIMEOUT_THRES(slowclk_cycles));
40378ff6:	0020c0        	memw
40378ff9:	0259      	s32i.n	a5, a2, 0
        expected_freq = SOC_CLK_RC_SLOW_FREQ_APPROX;
40378ffb:	ffd106        	j	40378f43 <rtc_clk_cal_internal+0x11b>
40378ffe:	00          	.byte 00
40378fff:	00          	.byte 00
        if (GET_PERI_REG_MASK(TIMG_RTCCALICFG2_REG(0), TIMG_RTC_CALI_TIMEOUT)) {
40379000:	0020c0        	memw
40379003:	0988      	l32i.n	a8, a9, 0
40379005:	02e807        	bbsi	a8, 0, 4037900b <rtc_clk_cal_internal+0x1e3>
40379008:	ffdd86        	j	40378f82 <rtc_clk_cal_internal+0x15a>
4037900b:	ffe386        	j	40378f9d <rtc_clk_cal_internal+0x175>
4037900e:	00          	.byte 00
4037900f:	00          	.byte 00
    if (cal_clk == RTC_CAL_8MD256) {
40379010:	b01466        	bnei	a4, 1, 40378fc4 <rtc_clk_cal_internal+0x19c>
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40379013:	ee5461        	l32r	a6, 40374964 <_iram_text_start+0x560>
40379016:	ffad82        	movi	a8, 0xfffffdff
40379019:	0020c0        	memw
4037901c:	0658      	l32i.n	a5, a6, 0
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
4037901e:	41b730        	srli	a11, a3, 7
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
40379021:	41a670        	srli	a10, a7, 6
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
40379024:	105580        	and	a5, a5, a8
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M_DIV) == 0;
40379027:	30bb40        	xor	a11, a11, a4
    return GET_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_ENB_CK8M) == 0;
4037902a:	30aa40        	xor	a10, a10, a4
    CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_DIG_CLK8M_D256_EN_M);
4037902d:	0020c0        	memw
40379030:	006652        	s32i	a5, a6, 0
        rtc_clk_8m_enable(rc_fast_enabled, rc_fast_d256_enabled);
40379033:	04b0b0        	extui	a11, a11, 0, 1
40379036:	04a0a0        	extui	a10, a10, 0, 1
40379039:	ff54a5        	call8	40378584 <rtc_clk_8m_enable>
    return cal_val;
4037903c:	ffe106        	j	40378fc4 <rtc_clk_cal_internal+0x19c>
	...

40379040 <rtc_clk_cal>:
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
}

uint32_t rtc_clk_cal(rtc_cal_sel_t cal_clk, uint32_t slowclk_cycles)
{
40379040:	004136        	entry	a1, 32
    rtc_xtal_freq_t xtal_freq = rtc_clk_xtal_freq_get();
40379043:	ff6c25        	call8	40378704 <rtc_clk_xtal_freq_get>
40379046:	0a7d      	mov.n	a7, a10
    uint64_t xtal_cycles = rtc_clk_cal_internal(cal_clk, slowclk_cycles);
40379048:	03bd      	mov.n	a11, a3
4037904a:	02ad      	mov.n	a10, a2
4037904c:	ffdda5        	call8	40378e28 <rtc_clk_cal_internal>
4037904f:	824730        	mull	a4, a7, a3
40379052:	0a5d      	mov.n	a5, a10
40379054:	a23730        	muluh	a3, a7, a3
40379057:	060c      	movi.n	a6, 0

    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid(xtal_freq, slowclk_cycles, xtal_cycles)) {
40379059:	542266        	bnei	a2, 2, 403790b1 <rtc_clk_cal+0x71>
    uint64_t expected_xtal_cycles = (xtal_freq * 1000000ULL * slowclk_cycles) >> 15; // xtal_freq(hz) * slowclk_cycles / 32768
4037905c:	ed8481        	l32r	a8, 4037466c <_iram_text_start+0x268>
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
4037905f:	d0a7c2        	movi	a12, 0x7d0
    uint64_t expected_xtal_cycles = (xtal_freq * 1000000ULL * slowclk_cycles) >> 15; // xtal_freq(hz) * slowclk_cycles / 32768
40379062:	822380        	mull	a2, a3, a8
40379065:	827480        	mull	a7, a4, a8
40379068:	a28480        	muluh	a8, a4, a8
4037906b:	417f70        	srli	a7, a7, 15
4037906e:	228a      	add.n	a2, a2, a8
40379070:	0182f0        	slli	a8, a2, 17
40379073:	207870        	or	a7, a8, a7
40379076:	412f20        	srli	a2, a2, 15
    uint64_t delta = expected_xtal_cycles / 2000;                                    // 5/10000
40379079:	06dd      	mov.n	a13, a6
4037907b:	07ad      	mov.n	a10, a7
4037907d:	02bd      	mov.n	a11, a2
4037907f:	edb881        	l32r	a8, 40374760 <_iram_text_start+0x35c>
40379082:	0008e0        	callx8	a8
    return (actual_xtal_cycles >= (expected_xtal_cycles - delta)) && (actual_xtal_cycles <= (expected_xtal_cycles + delta));
40379085:	c097a0        	sub	a9, a7, a10
40379088:	180c      	movi.n	a8, 1
4037908a:	023797        	bltu	a7, a9, 40379090 <rtc_clk_cal+0x50>
4037908d:	208660        	or	a8, a6, a6
40379090:	c0c2b0        	sub	a12, a2, a11
40379093:	c0dc80        	sub	a13, a12, a8
40379096:	529c87        	bne	a12, a8, 403790ec <rtc_clk_cal+0xac>
40379099:	4f3597        	bltu	a5, a9, 403790ec <rtc_clk_cal+0xac>
4037909c:	87aa      	add.n	a8, a7, a10
4037909e:	190c      	movi.n	a9, 1
403790a0:	013877        	bltu	a8, a7, 403790a5 <rtc_clk_cal+0x65>
403790a3:	0d9d      	mov.n	a9, a13
403790a5:	22ba      	add.n	a2, a2, a11
403790a7:	992a      	add.n	a9, a9, a2
    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid(xtal_freq, slowclk_cycles, xtal_cycles)) {
403790a9:	049697        	bne	a6, a9, 403790b1 <rtc_clk_cal+0x71>
        return 0;
403790ac:	020c      	movi.n	a2, 0
    if ((cal_clk == RTC_CAL_32K_XTAL) && !rtc_clk_cal_32k_valid(xtal_freq, slowclk_cycles, xtal_cycles)) {
403790ae:	383857        	bltu	a8, a5, 403790ea <rtc_clk_cal+0xaa>
    }

    uint64_t divider = ((uint64_t)xtal_freq) * slowclk_cycles;
    uint64_t period_64 = ((xtal_cycles << RTC_CLK_CAL_FRACT) + divider / 2 - 1) / divider;
403790b1:	01a5d0        	slli	a10, a5, 19
403790b4:	412d50        	srli	a2, a5, 13
403790b7:	5a0b      	addi.n	a5, a10, -1
403790b9:	160c      	movi.n	a6, 1
403790bb:	0135a7        	bltu	a5, a10, 403790c0 <rtc_clk_cal+0x80>
403790be:	060c      	movi.n	a6, 0
403790c0:	220b      	addi.n	a2, a2, -1
403790c2:	262a      	add.n	a2, a6, a2
403790c4:	41a140        	srli	a10, a4, 1
403790c7:	016310        	slli	a6, a3, 31
403790ca:	20a6a0        	or	a10, a6, a10
403790cd:	a5aa      	add.n	a10, a5, a10
403790cf:	416130        	srli	a6, a3, 1
403790d2:	1b0c      	movi.n	a11, 1
403790d4:	023a57        	bltu	a10, a5, 403790da <rtc_clk_cal+0x9a>
403790d7:	00a0b2        	movi	a11, 0
403790da:	226a      	add.n	a2, a2, a6
403790dc:	bb2a      	add.n	a11, a11, a2
403790de:	04cd      	mov.n	a12, a4
403790e0:	03dd      	mov.n	a13, a3
403790e2:	ed9f81        	l32r	a8, 40374760 <_iram_text_start+0x35c>
403790e5:	0008e0        	callx8	a8
403790e8:	0a2d      	mov.n	a2, a10
    uint32_t period = (uint32_t)(period_64 & UINT32_MAX);
    return period;
}
403790ea:	f01d      	retw.n
        return 0;
403790ec:	020c      	movi.n	a2, 0
403790ee:	fffe06        	j	403790ea <rtc_clk_cal+0xaa>
403790f1:	000000        	ill

403790f4 <rtc_time_us_to_slowclk>:

uint64_t rtc_time_us_to_slowclk(uint64_t time_in_us, uint32_t period)
{
403790f4:	004136        	entry	a1, 32
    /* Overflow will happen in this function if time_in_us >= 2^45, which is about 400 days.
     * TODO: fix overflow.
     */
    return (time_in_us << RTC_CLK_CAL_FRACT) / period;
403790f7:	41bd20        	srli	a11, a2, 13
403790fa:	0133d0        	slli	a3, a3, 19
403790fd:	04cd      	mov.n	a12, a4
403790ff:	0d0c      	movi.n	a13, 0
40379101:	01a2d0        	slli	a10, a2, 19
40379104:	20bb30        	or	a11, a11, a3
40379107:	ed9681        	l32r	a8, 40374760 <_iram_text_start+0x35c>
4037910a:	0008e0        	callx8	a8
}
4037910d:	0a2d      	mov.n	a2, a10
4037910f:	0b3d      	mov.n	a3, a11
40379111:	f01d      	retw.n
	...

40379114 <rtc_time_get>:
{
    return (rtc_cycles * period) >> RTC_CLK_CAL_FRACT;
}

uint64_t rtc_time_get(void)
{
40379114:	004136        	entry	a1, 32
    SET_PERI_REG_MASK(RTC_CNTL_TIME_UPDATE_REG, RTC_CNTL_TIME_UPDATE);
40379117:	ee45a1        	l32r	a10, 40374a2c <_iram_text_start+0x628>
4037911a:	f97c      	movi.n	a9, -1
4037911c:	0020c0        	memw
4037911f:	0a88      	l32i.n	a8, a10, 0
40379121:	019910        	slli	a9, a9, 31
    uint64_t t = READ_PERI_REG(RTC_CNTL_TIME0_REG);
40379124:	ee4321        	l32r	a2, 40374a30 <_iram_text_start+0x62c>
    t |= ((uint64_t) READ_PERI_REG(RTC_CNTL_TIME1_REG)) << 32;
40379127:	ee4331        	l32r	a3, 40374a34 <_iram_text_start+0x630>
    SET_PERI_REG_MASK(RTC_CNTL_TIME_UPDATE_REG, RTC_CNTL_TIME_UPDATE);
4037912a:	208890        	or	a8, a8, a9
4037912d:	0020c0        	memw
40379130:	0a89      	s32i.n	a8, a10, 0
    uint64_t t = READ_PERI_REG(RTC_CNTL_TIME0_REG);
40379132:	0020c0        	memw
40379135:	0228      	l32i.n	a2, a2, 0
    t |= ((uint64_t) READ_PERI_REG(RTC_CNTL_TIME1_REG)) << 32;
40379137:	0020c0        	memw
4037913a:	0338      	l32i.n	a3, a3, 0
    return t;
}
4037913c:	f01d      	retw.n
	...

40379140 <rtc_clk_freq_cal>:
        esp_rom_delay_us(1);
    }
}

uint32_t rtc_clk_freq_cal(uint32_t cal_val)
{
40379140:	004136        	entry	a1, 32
    if (cal_val == 0) {
40379143:	329c      	beqz.n	a2, 4037915a <rtc_clk_freq_cal+0x1a>
        return 0;   // cal_val will be denominator, return 0 as the symbol of failure.
    }
    return 1000000ULL * (1 << RTC_CLK_CAL_FRACT) / cal_val;
40379145:	9a0c      	movi.n	a10, 9
40379147:	20c220        	or	a12, a2, a2
4037914a:	0d0c      	movi.n	a13, 0
4037914c:	01aa70        	slli	a10, a10, 25
4037914f:	7aa0b2        	movi	a11, 122
40379152:	ed8381        	l32r	a8, 40374760 <_iram_text_start+0x35c>
40379155:	0008e0        	callx8	a8
40379158:	0a2d      	mov.n	a2, a10
}
4037915a:	f01d      	retw.n

4037915c <systimer_ticks_to_us>:
 * @brief systimer's clock source is fixed to XTAL (40MHz), and has a fixed fractional divider (2.5).
 *        So the resolution of the systimer is 40MHz/2.5 = 16MHz.
 */

uint64_t systimer_ticks_to_us(uint64_t ticks)
{
4037915c:	004136        	entry	a1, 32
    return ticks / 16;
4037915f:	018340        	slli	a8, a3, 28
40379162:	412420        	srli	a2, a2, 4
}
40379165:	202820        	or	a2, a8, a2
40379168:	413430        	srli	a3, a3, 4
4037916b:	f01d      	retw.n
4037916d:	000000        	ill

40379170 <systimer_us_to_ticks>:

uint64_t systimer_us_to_ticks(uint64_t us)
{
40379170:	004136        	entry	a1, 32
    return us * 16;
40379173:	358c20        	extui	a8, a2, 28, 4
40379176:	1133c0        	slli	a3, a3, 4
}
40379179:	1122c0        	slli	a2, a2, 4
4037917c:	203830        	or	a3, a8, a3
4037917f:	f01d      	retw.n
40379181:	000000        	ill

40379184 <prvGetItemByteBuf>:

static void *prvGetItemByteBuf(Ringbuffer_t *pxRingbuffer,
                               BaseType_t *pxUnusedParam,
                               size_t xMaxSize,
                               size_t *pxItemSize)
{
40379184:	004136        	entry	a1, 32
40379187:	028d      	mov.n	a8, a2
    //Check arguments and buffer state
    configASSERT((pxRingbuffer->xItemsWaiting > 0) && ((pxRingbuffer->pucRead != pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG)));   //Check there are items to be read
40379189:	e228      	l32i.n	a2, a2, 56
4037918b:	0d12a6        	blti	a2, 1, 4037919c <prvGetItemByteBuf+0x18>
4037918e:	a828      	l32i.n	a2, a8, 40
40379190:	0928a2        	l32i	a10, a8, 36
40379193:	1792a7        	bne	a2, a10, 403791ae <prvGetItemByteBuf+0x2a>
40379196:	022892        	l32i	a9, a8, 8
40379199:	11e927        	bbsi	a9, 2, 403791ae <prvGetItemByteBuf+0x2a>
4037919c:	ee27d1        	l32r	a13, 40374a38 <_iram_text_start+0x634>
4037919f:	ee27c1        	l32r	a12, 40374a3c <_iram_text_start+0x638>
403791a2:	43a2b2        	movi	a11, 0x243
    configASSERT(pxRingbuffer->pucRead >= pxRingbuffer->pucHead && pxRingbuffer->pucRead < pxRingbuffer->pucTail);    //Check read pointer is within bounds
403791a5:	ee26a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403791a8:	201110        	or	a1, a1, a1
403791ab:	056625        	call8	4037e80c <__assert_func>
403791ae:	c8b8      	l32i.n	a11, a8, 48
403791b0:	0432b7        	bltu	a2, a11, 403791b8 <prvGetItemByteBuf+0x34>
403791b3:	d898      	l32i.n	a9, a8, 52
403791b5:	0b3297        	bltu	a2, a9, 403791c4 <prvGetItemByteBuf+0x40>
403791b8:	ee23d1        	l32r	a13, 40374a44 <_iram_text_start+0x640>
403791bb:	ee20c1        	l32r	a12, 40374a3c <_iram_text_start+0x638>
403791be:	44a2b2        	movi	a11, 0x244
403791c1:	fff806        	j	403791a5 <prvGetItemByteBuf+0x21>
    configASSERT(pxRingbuffer->pucRead == pxRingbuffer->pucFree);
403791c4:	b8c8      	l32i.n	a12, a8, 44
403791c6:	0b12c7        	beq	a2, a12, 403791d5 <prvGetItemByteBuf+0x51>
403791c9:	ee1fd1        	l32r	a13, 40374a48 <_iram_text_start+0x644>
403791cc:	ee1cc1        	l32r	a12, 40374a3c <_iram_text_start+0x638>
403791cf:	45a2b2        	movi	a11, 0x245
403791d2:	fff3c6        	j	403791a5 <prvGetItemByteBuf+0x21>

    uint8_t *ret = pxRingbuffer->pucRead;
    if ((pxRingbuffer->pucRead > pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG)) {     //Available data wraps around
403791d5:	043a27        	bltu	a10, a2, 403791dd <prvGetItemByteBuf+0x59>
403791d8:	28c8      	l32i.n	a12, a8, 8
403791da:	166c27        	bbci	a12, 2, 403791f4 <prvGetItemByteBuf+0x70>
        //Return contiguous piece from read pointer until buffer tail, or xMaxSize
        if (xMaxSize == 0 || pxRingbuffer->pucTail - pxRingbuffer->pucRead <= xMaxSize) {
403791dd:	c0a920        	sub	a10, a9, a2
403791e0:	148c      	beqz.n	a4, 403791e5 <prvGetItemByteBuf+0x61>
403791e2:	2034a7        	bltu	a4, a10, 40379206 <prvGetItemByteBuf+0x82>
            //All contiguous data from read pointer to tail
            *pxItemSize = pxRingbuffer->pucTail - pxRingbuffer->pucRead;
403791e5:	05a9      	s32i.n	a10, a5, 0
            pxRingbuffer->xItemsWaiting -= pxRingbuffer->pucTail - pxRingbuffer->pucRead;
403791e7:	e898      	l32i.n	a9, a8, 56
403791e9:	c099a0        	sub	a9, a9, a10
            pxRingbuffer->pucRead = pxRingbuffer->pucHead;  //Wrap around read pointer
403791ec:	0bad      	mov.n	a10, a11
        } else {
            //Return xMaxSize amount of data
            *pxItemSize = xMaxSize;
            pxRingbuffer->xItemsWaiting -= xMaxSize;
403791ee:	e899      	s32i.n	a9, a8, 56
            pxRingbuffer->pucRead += xMaxSize;  //Advance read pointer past retrieved data
403791f0:	a8a9      	s32i.n	a10, a8, 40
            pxRingbuffer->pucRead += xMaxSize;  //Advance read pointer past retrieved data

        }
    }
    return (void *)ret;
}
403791f2:	f01d      	retw.n
        if (xMaxSize == 0 || pxRingbuffer->pucWrite - pxRingbuffer->pucRead <= xMaxSize) {
403791f4:	c0ba20        	sub	a11, a10, a2
403791f7:	148c      	beqz.n	a4, 403791fc <prvGetItemByteBuf+0x78>
403791f9:	0934b7        	bltu	a4, a11, 40379206 <prvGetItemByteBuf+0x82>
            *pxItemSize = pxRingbuffer->pucWrite - pxRingbuffer->pucRead;
403791fc:	05b9      	s32i.n	a11, a5, 0
            pxRingbuffer->xItemsWaiting -= pxRingbuffer->pucWrite - pxRingbuffer->pucRead;
403791fe:	e898      	l32i.n	a9, a8, 56
40379200:	c099b0        	sub	a9, a9, a11
            pxRingbuffer->pucRead = pxRingbuffer->pucWrite;
40379203:	fff9c6        	j	403791ee <prvGetItemByteBuf+0x6a>
            *pxItemSize = xMaxSize;
40379206:	0549      	s32i.n	a4, a5, 0
            pxRingbuffer->xItemsWaiting -= xMaxSize;
40379208:	e898      	l32i.n	a9, a8, 56
            pxRingbuffer->pucRead += xMaxSize;  //Advance read pointer past retrieved data
4037920a:	a24a      	add.n	a10, a2, a4
            pxRingbuffer->xItemsWaiting -= xMaxSize;
4037920c:	c09940        	sub	a9, a9, a4
            pxRingbuffer->pucRead += xMaxSize;  //Advance read pointer past retrieved data
4037920f:	fff6c6        	j	403791ee <prvGetItemByteBuf+0x6a>
	...

40379214 <prvCheckItemFitsByteBuffer>:
{
40379214:	004136        	entry	a1, 32
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check acquire pointer is within bounds
40379217:	8298      	l32i.n	a9, a2, 32
40379219:	0c2282        	l32i	a8, a2, 48
4037921c:	043987        	bltu	a9, a8, 40379224 <prvCheckItemFitsByteBuffer+0x10>
4037921f:	d288      	l32i.n	a8, a2, 52
40379221:	113987        	bltu	a9, a8, 40379236 <prvCheckItemFitsByteBuffer+0x22>
40379224:	ee0ad1        	l32r	a13, 40374a4c <_iram_text_start+0x648>
40379227:	ee0ac1        	l32r	a12, 40374a50 <_iram_text_start+0x64c>
4037922a:	ee05a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
4037922d:	47a1b2        	movi	a11, 0x147
40379230:	201110        	or	a1, a1, a1
40379233:	055da5        	call8	4037e80c <__assert_func>
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
40379236:	b2a8      	l32i.n	a10, a2, 44
40379238:	180c      	movi.n	a8, 1
4037923a:	0a99a7        	bne	a9, a10, 40379248 <prvCheckItemFitsByteBuffer+0x34>
        return (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) ? pdFALSE : pdTRUE;
4037923d:	2228      	l32i.n	a2, a2, 8
4037923f:	042220        	extui	a2, a2, 2, 1
40379242:	302280        	xor	a2, a2, a8
}
40379245:	f01d      	retw.n
40379247:	00          	.byte 00
    if (pxRingbuffer->pucFree > pxRingbuffer->pucAcquire) {
40379248:	0ab9a7        	bgeu	a9, a10, 40379256 <prvCheckItemFitsByteBuffer+0x42>
        return (xItemSize <= pxRingbuffer->pucFree - pxRingbuffer->pucAcquire) ? pdTRUE : pdFALSE;
4037924b:	c0aa90        	sub	a10, a10, a9
4037924e:	0fba37        	bgeu	a10, a3, 40379261 <prvCheckItemFitsByteBuffer+0x4d>
    return (xItemSize <= pxRingbuffer->xSize - (pxRingbuffer->pucAcquire - pxRingbuffer->pucFree)) ? pdTRUE : pdFALSE;
40379251:	080c      	movi.n	a8, 0
40379253:	000286        	j	40379261 <prvCheckItemFitsByteBuffer+0x4d>
40379256:	0228      	l32i.n	a2, a2, 0
40379258:	c099a0        	sub	a9, a9, a10
4037925b:	c02290        	sub	a2, a2, a9
4037925e:	ef3237        	bltu	a2, a3, 40379251 <prvCheckItemFitsByteBuffer+0x3d>
40379261:	082d      	mov.n	a2, a8
40379263:	fff786        	j	40379245 <prvCheckItemFitsByteBuffer+0x31>
	...

40379268 <prvReturnItemDefault>:

static void prvReturnItemDefault(Ringbuffer_t *pxRingbuffer, uint8_t *pucItem)
{
40379268:	004136        	entry	a1, 32
    //Check arguments and buffer state
    configASSERT(rbCHECK_ALIGNED(pucItem));
4037926b:	148030        	extui	a8, a3, 0, 2
4037926e:	089c      	beqz.n	a8, 40379282 <prvReturnItemDefault+0x1a>
40379270:	edf9d1        	l32r	a13, 40374a54 <_iram_text_start+0x650>
40379273:	edf9c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
40379276:	69a2b2        	movi	a11, 0x269
    configASSERT(pucItem >= pxRingbuffer->pucHead);
40379279:	edf1a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
4037927c:	201110        	or	a1, a1, a1
4037927f:	0558e5        	call8	4037e80c <__assert_func>
40379282:	c298      	l32i.n	a9, a2, 48
40379284:	0cb397        	bgeu	a3, a9, 40379294 <prvReturnItemDefault+0x2c>
40379287:	edf5d1        	l32r	a13, 40374a5c <_iram_text_start+0x658>
4037928a:	edf3c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
4037928d:	6aa2b2        	movi	a11, 0x26a
40379290:	fff946        	j	40379279 <prvReturnItemDefault+0x11>
40379293:	00          	.byte 00
    configASSERT(pucItem <= pxRingbuffer->pucTail);     //Inclusive of pucTail in the case of zero length item at the very end
40379294:	d2a8      	l32i.n	a10, a2, 52
40379296:	0bba37        	bgeu	a10, a3, 403792a5 <prvReturnItemDefault+0x3d>
40379299:	edf1d1        	l32r	a13, 40374a60 <_iram_text_start+0x65c>
4037929c:	edefc1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
4037929f:	6ba2b2        	movi	a11, 0x26b
403792a2:	fff4c6        	j	40379279 <prvReturnItemDefault+0x11>

    //Get and check header of the item
    ItemHeader_t *pxCurHeader = (ItemHeader_t *)(pucItem - rbHEADER_SIZE);
    configASSERT(pxCurHeader->xItemLen <= pxRingbuffer->xMaxItemSize);
403792a5:	f8c332        	addi	a3, a3, -8
403792a8:	0388      	l32i.n	a8, a3, 0
403792aa:	12b8      	l32i.n	a11, a2, 4
403792ac:	0cbb87        	bgeu	a11, a8, 403792bc <prvReturnItemDefault+0x54>
403792af:	ededd1        	l32r	a13, 40374a64 <_iram_text_start+0x660>
403792b2:	ede9c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
403792b5:	6fa2b2        	movi	a11, 0x26f
403792b8:	ffef46        	j	40379279 <prvReturnItemDefault+0x11>
403792bb:	00          	.byte 00
    configASSERT((pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) == 0); //Dummy items should never have been read
403792bc:	1388      	l32i.n	a8, a3, 4
403792be:	2b0c      	movi.n	a11, 2
403792c0:	0c08b7        	bnone	a8, a11, 403792d0 <prvReturnItemDefault+0x68>
403792c3:	ede9d1        	l32r	a13, 40374a68 <_iram_text_start+0x664>
403792c6:	ede4c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
403792c9:	70a2b2        	movi	a11, 0x270
403792cc:	ffea46        	j	40379279 <prvReturnItemDefault+0x11>
403792cf:	00          	.byte 00
    configASSERT((pxCurHeader->uxItemFlags & rbITEM_FREE_FLAG) == 0);       //Indicates item has already been returned before
403792d0:	0c6807        	bbci	a8, 0, 403792e0 <prvReturnItemDefault+0x78>
403792d3:	ede6d1        	l32r	a13, 40374a6c <_iram_text_start+0x668>
403792d6:	ede0c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
403792d9:	71a2b2        	movi	a11, 0x271
403792dc:	ffe646        	j	40379279 <prvReturnItemDefault+0x11>
403792df:	00          	.byte 00
    pxCurHeader->uxItemFlags &= ~rbITEM_SPLIT_FLAG;                         //Clear wrap flag if set (not strictly necessary)
403792e0:	bc7c      	movi.n	a12, -5
403792e2:	1088c0        	and	a8, a8, a12
    pxCurHeader->uxItemFlags |= rbITEM_FREE_FLAG;                           //Mark as free
403792e5:	1c0c      	movi.n	a12, 1
403792e7:	2088c0        	or	a8, a8, a12
     * Items might not be returned in the order they were retrieved. Move the free pointer
     * up to the next item that has not been marked as free (by free flag) or up
     * till the read pointer. When advancing the free pointer, items that have already been
     * freed or items with dummy data should be skipped over
     */
    pxCurHeader = (ItemHeader_t *)pxRingbuffer->pucFree;
403792ea:	b2e8      	l32i.n	a14, a2, 44
    pxCurHeader->uxItemFlags |= rbITEM_FREE_FLAG;                           //Mark as free
403792ec:	1389      	s32i.n	a8, a3, 4
        if (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) {
            pxCurHeader->uxItemFlags |= rbITEM_FREE_FLAG;   //Mark as freed (not strictly necessary but adds redundancy)
            pxRingbuffer->pucFree = pxRingbuffer->pucHead;    //Wrap around due to dummy data
        } else {
            //Item with data that has already been freed, advance free pointer past this item
            size_t xAlignedItemSize = rbALIGN_SIZE(pxCurHeader->xItemLen);
403792ee:	cd7c      	movi.n	a13, -4
    while (((pxCurHeader->uxItemFlags & rbITEM_FREE_FLAG) || (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG)) && pxRingbuffer->pucFree != pxRingbuffer->pucRead) {
403792f0:	1e38      	l32i.n	a3, a14, 4
403792f2:	148030        	extui	a8, a3, 0, 2
403792f5:	588c      	beqz.n	a8, 403792fe <prvReturnItemDefault+0x96>
403792f7:	b288      	l32i.n	a8, a2, 44
403792f9:	a2f8      	l32i.n	a15, a2, 40
403792fb:	1598f7        	bne	a8, a15, 40379314 <prvReturnItemDefault+0xac>
        }
        pxCurHeader = (ItemHeader_t *)pxRingbuffer->pucFree;      //Update header to point to item
    }

    //Check if the buffer full flag should be reset
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
403792fe:	2238      	l32i.n	a3, a2, 8
40379300:	4e6327        	bbci	a3, 2, 40379352 <prvReturnItemDefault+0xea>
        if (pxRingbuffer->pucFree != pxRingbuffer->pucAcquire) {
40379303:	b288      	l32i.n	a8, a2, 44
40379305:	8298      	l32i.n	a9, a2, 32
40379307:	421897        	beq	a8, a9, 4037934d <prvReturnItemDefault+0xe5>
            pxRingbuffer->uxRingbufferFlags &= ~rbBUFFER_FULL_FLAG;
        } else if (pxRingbuffer->pucFree == pxRingbuffer->pucAcquire && pxRingbuffer->pucFree == pxRingbuffer->pucRead) {
            //Special case where a full buffer is completely freed in one go
            pxRingbuffer->uxRingbufferFlags &= ~rbBUFFER_FULL_FLAG;
4037930a:	b87c      	movi.n	a8, -5
4037930c:	103380        	and	a3, a3, a8
4037930f:	2239      	s32i.n	a3, a2, 8
        }
    }
}
40379311:	000f46        	j	40379352 <prvReturnItemDefault+0xea>
        if (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) {
40379314:	1503b7        	bnone	a3, a11, 4037932d <prvReturnItemDefault+0xc5>
            pxCurHeader->uxItemFlags |= rbITEM_FREE_FLAG;   //Mark as freed (not strictly necessary but adds redundancy)
40379317:	2033c0        	or	a3, a3, a12
4037931a:	1e39      	s32i.n	a3, a14, 4
            pxRingbuffer->pucFree = pxRingbuffer->pucHead;    //Wrap around due to dummy data
4037931c:	b299      	s32i.n	a9, a2, 44
        if ((pxRingbuffer->pucTail - pxRingbuffer->pucFree) < rbHEADER_SIZE) {
4037931e:	b238      	l32i.n	a3, a2, 44
40379320:	c03a30        	sub	a3, a10, a3
40379323:	0183f6        	bgeui	a3, 8, 40379328 <prvReturnItemDefault+0xc0>
            pxRingbuffer->pucFree = pxRingbuffer->pucHead;
40379326:	b299      	s32i.n	a9, a2, 44
        pxCurHeader = (ItemHeader_t *)pxRingbuffer->pucFree;      //Update header to point to item
40379328:	b2e8      	l32i.n	a14, a2, 44
4037932a:	fff086        	j	403792f0 <prvReturnItemDefault+0x88>
            size_t xAlignedItemSize = rbALIGN_SIZE(pxCurHeader->xItemLen);
4037932d:	0e38      	l32i.n	a3, a14, 0
4037932f:	333b      	addi.n	a3, a3, 3
40379331:	1033d0        	and	a3, a3, a13
            pxRingbuffer->pucFree += xAlignedItemSize + rbHEADER_SIZE;
40379334:	338b      	addi.n	a3, a3, 8
40379336:	883a      	add.n	a8, a8, a3
            configASSERT(pxRingbuffer->pucFree <= pxRingbuffer->pucHead + pxRingbuffer->xSize);
40379338:	0238      	l32i.n	a3, a2, 0
            pxRingbuffer->pucFree += xAlignedItemSize + rbHEADER_SIZE;
4037933a:	b289      	s32i.n	a8, a2, 44
            configASSERT(pxRingbuffer->pucFree <= pxRingbuffer->pucHead + pxRingbuffer->xSize);
4037933c:	393a      	add.n	a3, a9, a3
4037933e:	dcb387        	bgeu	a3, a8, 4037931e <prvReturnItemDefault+0xb6>
40379341:	edcbd1        	l32r	a13, 40374a70 <_iram_text_start+0x66c>
40379344:	edc5c1        	l32r	a12, 40374a58 <_iram_text_start+0x654>
40379347:	86a2b2        	movi	a11, 0x286
4037934a:	ffcac6        	j	40379279 <prvReturnItemDefault+0x11>
        } else if (pxRingbuffer->pucFree == pxRingbuffer->pucAcquire && pxRingbuffer->pucFree == pxRingbuffer->pucRead) {
4037934d:	a298      	l32i.n	a9, a2, 40
4037934f:	b71897        	beq	a8, a9, 4037930a <prvReturnItemDefault+0xa2>
}
40379352:	f01d      	retw.n

40379354 <prvGetItemDefault>:
{
40379354:	004136        	entry	a1, 32
    ItemHeader_t *pxHeader = (ItemHeader_t *)pxRingbuffer->pucRead;
40379357:	a298      	l32i.n	a9, a2, 40
{
40379359:	028d      	mov.n	a8, a2
    configASSERT(pxIsSplit != NULL);
4037935b:	00e356        	bnez	a3, 4037936d <prvGetItemDefault+0x19>
4037935e:	edc5d1        	l32r	a13, 40374a74 <_iram_text_start+0x670>
40379361:	edc5c1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
40379364:	1ba2b2        	movi	a11, 0x21b
    configASSERT((pxRingbuffer->xItemsWaiting > 0) && ((pxRingbuffer->pucRead != pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG)));   //Check there are items to be read
40379367:	edb6a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
4037936a:	054a25        	call8	4037e80c <__assert_func>
4037936d:	e228      	l32i.n	a2, a2, 56
4037936f:	0912a6        	blti	a2, 1, 4037937c <prvGetItemDefault+0x28>
40379372:	9828      	l32i.n	a2, a8, 36
40379374:	109297        	bne	a2, a9, 40379388 <prvGetItemDefault+0x34>
40379377:	2828      	l32i.n	a2, a8, 8
40379379:	0be227        	bbsi	a2, 2, 40379388 <prvGetItemDefault+0x34>
4037937c:	edafd1        	l32r	a13, 40374a38 <_iram_text_start+0x634>
4037937f:	edbec1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
40379382:	1ca2b2        	movi	a11, 0x21c
40379385:	fff786        	j	40379367 <prvGetItemDefault+0x13>
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucRead));           //pucRead is always aligned in split ring buffers
40379388:	142090        	extui	a2, a9, 0, 2
4037938b:	b28c      	beqz.n	a2, 4037939a <prvGetItemDefault+0x46>
4037938d:	edbbd1        	l32r	a13, 40374a7c <_iram_text_start+0x678>
40379390:	edbac1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
40379393:	1da2b2        	movi	a11, 0x21d
40379396:	fff346        	j	40379367 <prvGetItemDefault+0x13>
40379399:	00          	.byte 00
    configASSERT(pxRingbuffer->pucRead >= pxRingbuffer->pucHead && pxRingbuffer->pucRead < pxRingbuffer->pucTail);      //Check read pointer is within bounds
4037939a:	c8a8      	l32i.n	a10, a8, 48
4037939c:	0439a7        	bltu	a9, a10, 403793a4 <prvGetItemDefault+0x50>
4037939f:	d8b8      	l32i.n	a11, a8, 52
403793a1:	0b39b7        	bltu	a9, a11, 403793b0 <prvGetItemDefault+0x5c>
403793a4:	eda8d1        	l32r	a13, 40374a44 <_iram_text_start+0x640>
403793a7:	edb4c1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
403793aa:	1ea2b2        	movi	a11, 0x21e
403793ad:	ffed86        	j	40379367 <prvGetItemDefault+0x13>
    configASSERT((pxHeader->xItemLen <= pxRingbuffer->xMaxItemSize) || (pxHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG));
403793b0:	19d8      	l32i.n	a13, a9, 4
403793b2:	220c      	movi.n	a2, 2
403793b4:	1022d0        	and	a2, a2, a13
403793b7:	18c8      	l32i.n	a12, a8, 4
403793b9:	09d8      	l32i.n	a13, a9, 0
403793bb:	0dbcd7        	bgeu	a12, a13, 403793cc <prvGetItemDefault+0x78>
403793be:	c2cc      	bnez.n	a2, 403793ce <prvGetItemDefault+0x7a>
403793c0:	edb0d1        	l32r	a13, 40374a80 <_iram_text_start+0x67c>
403793c3:	edadc1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
403793c6:	1fa2b2        	movi	a11, 0x21f
403793c9:	ffe686        	j	40379367 <prvGetItemDefault+0x13>
    if (pxHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) {
403793cc:	429c      	beqz.n	a2, 403793e4 <prvGetItemDefault+0x90>
        configASSERT(pxHeader->xItemLen <= pxRingbuffer->xMaxItemSize);
403793ce:	0a28      	l32i.n	a2, a10, 0
        pxRingbuffer->pucRead = pxRingbuffer->pucHead;
403793d0:	a8a9      	s32i.n	a10, a8, 40
        configASSERT(pxHeader->xItemLen <= pxRingbuffer->xMaxItemSize);
403793d2:	0a9d      	mov.n	a9, a10
403793d4:	0cbc27        	bgeu	a12, a2, 403793e4 <prvGetItemDefault+0x90>
403793d7:	edabd1        	l32r	a13, 40374a84 <_iram_text_start+0x680>
403793da:	eda7c1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
403793dd:	27a2b2        	movi	a11, 0x227
403793e0:	ffe0c6        	j	40379367 <prvGetItemDefault+0x13>
403793e3:	00          	.byte 00
    pcReturn = pxRingbuffer->pucRead + rbHEADER_SIZE;    //Get pointer to part of item containing data (point past the header)
403793e4:	a8c8      	l32i.n	a12, a8, 40
    if (pxHeader->xItemLen == 0) {
403793e6:	09e8      	l32i.n	a14, a9, 0
    pcReturn = pxRingbuffer->pucRead + rbHEADER_SIZE;    //Get pointer to part of item containing data (point past the header)
403793e8:	2c8b      	addi.n	a2, a12, 8
        configASSERT(pcReturn >= pxRingbuffer->pucHead && pcReturn <= pxRingbuffer->pucTail);
403793ea:	1d0c      	movi.n	a13, 1
403793ec:	0132a7        	bltu	a2, a10, 403793f1 <prvGetItemDefault+0x9d>
403793ef:	0d0c      	movi.n	a13, 0
403793f1:	74d0d0        	extui	a13, a13, 0, 8
    if (pxHeader->xItemLen == 0) {
403793f4:	0edc      	bnez.n	a14, 40379408 <prvGetItemDefault+0xb4>
        configASSERT(pcReturn >= pxRingbuffer->pucHead && pcReturn <= pxRingbuffer->pucTail);
403793f6:	023b27        	bltu	a11, a2, 403793fc <prvGetItemDefault+0xa8>
403793f9:	01cd16        	beqz	a13, 40379419 <prvGetItemDefault+0xc5>
403793fc:	eda3d1        	l32r	a13, 40374a88 <_iram_text_start+0x684>
403793ff:	ed9ec1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
40379402:	2ca2b2        	movi	a11, 0x22c
40379405:	ffd786        	j	40379367 <prvGetItemDefault+0x13>
        configASSERT(pcReturn >= pxRingbuffer->pucHead && pcReturn < pxRingbuffer->pucTail);
40379408:	01b2b7        	bgeu	a2, a11, 4037940d <prvGetItemDefault+0xb9>
4037940b:	ad8c      	beqz.n	a13, 40379419 <prvGetItemDefault+0xc5>
4037940d:	ed9fd1        	l32r	a13, 40374a8c <_iram_text_start+0x688>
40379410:	ed9ac1        	l32r	a12, 40374a78 <_iram_text_start+0x674>
40379413:	2fa2b2        	movi	a11, 0x22f
40379416:	ffd346        	j	40379367 <prvGetItemDefault+0x13>
    *pxItemSize = pxHeader->xItemLen;   //Get length of item
40379419:	05e9      	s32i.n	a14, a5, 0
    pxRingbuffer->xItemsWaiting --;     //Update item count
4037941b:	e8d8      	l32i.n	a13, a8, 56
4037941d:	dd0b      	addi.n	a13, a13, -1
4037941f:	e8d9      	s32i.n	a13, a8, 56
    *pxIsSplit = (pxHeader->uxItemFlags & rbITEM_SPLIT_FLAG) ? pdTRUE : pdFALSE;
40379421:	19d8      	l32i.n	a13, a9, 4
40379423:	04d2d0        	extui	a13, a13, 2, 1
40379426:	03d9      	s32i.n	a13, a3, 0
    pxRingbuffer->pucRead += rbHEADER_SIZE + rbALIGN_SIZE(pxHeader->xItemLen);   //Update pucRead
40379428:	0998      	l32i.n	a9, a9, 0
4037942a:	c37c      	movi.n	a3, -4
4037942c:	993b      	addi.n	a9, a9, 3
4037942e:	109930        	and	a9, a9, a3
40379431:	998b      	addi.n	a9, a9, 8
40379433:	9c9a      	add.n	a9, a12, a9
    if ((pxRingbuffer->pucTail - pxRingbuffer->pucRead) < rbHEADER_SIZE) {
40379435:	c0bb90        	sub	a11, a11, a9
40379438:	018bb6        	bltui	a11, 8, 4037943d <prvGetItemDefault+0xe9>
        pxRingbuffer->pucRead = pxRingbuffer->pucHead;
4037943b:	09ad      	mov.n	a10, a9
4037943d:	a8a9      	s32i.n	a10, a8, 40
}
4037943f:	f01d      	retw.n
40379441:	000000        	ill

40379444 <prvAcquireItemNoSplit>:
{
40379444:	004136        	entry	a1, 32
    size_t xRemLen = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;    //Length from pucAcquire until end of buffer
40379447:	082292        	l32i	a9, a2, 32
4037944a:	0d22c2        	l32i	a12, a2, 52
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucAcquire));              //pucAcquire is always aligned in no-split ring buffers
4037944d:	14d090        	extui	a13, a9, 0, 2
{
40379450:	208220        	or	a8, a2, a2
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucAcquire));              //pucAcquire is always aligned in no-split ring buffers
40379453:	dd8c      	beqz.n	a13, 40379464 <prvAcquireItemNoSplit+0x20>
40379455:	ed8ed1        	l32r	a13, 40374a90 <_iram_text_start+0x68c>
40379458:	ed8fc1        	l32r	a12, 40374a94 <_iram_text_start+0x690>
4037945b:	5aa1b2        	movi	a11, 0x15a
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check write pointer is within bounds
4037945e:	ed78a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379461:	053aa5        	call8	4037e80c <__assert_func>
40379464:	c2b8      	l32i.n	a11, a2, 48
40379466:	1639b7        	bltu	a9, a11, 40379480 <prvAcquireItemNoSplit+0x3c>
40379469:	13b9c7        	bgeu	a9, a12, 40379480 <prvAcquireItemNoSplit+0x3c>
    size_t xRemLen = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;    //Length from pucAcquire until end of buffer
4037946c:	c0ec90        	sub	a14, a12, a9
    configASSERT(xRemLen >= rbHEADER_SIZE);                             //Remaining length must be able to at least fit an item header
4037946f:	198ef6        	bgeui	a14, 8, 4037948c <prvAcquireItemNoSplit+0x48>
40379472:	ed89d1        	l32r	a13, 40374a98 <_iram_text_start+0x694>
40379475:	ed87c1        	l32r	a12, 40374a94 <_iram_text_start+0x690>
40379478:	5ca1b2        	movi	a11, 0x15c
4037947b:	fff7c6        	j	4037945e <prvAcquireItemNoSplit+0x1a>
4037947e:	00          	.byte 00
4037947f:	00          	.byte 00
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check write pointer is within bounds
40379480:	ed73d1        	l32r	a13, 40374a4c <_iram_text_start+0x648>
40379483:	ed84c1        	l32r	a12, 40374a94 <_iram_text_start+0x690>
40379486:	5ba1b2        	movi	a11, 0x15b
40379489:	fff446        	j	4037945e <prvAcquireItemNoSplit+0x1a>
    size_t xAlignedItemSize = rbALIGN_SIZE(xItemSize);                  //Rounded up aligned item size
4037948c:	a33b      	addi.n	a10, a3, 3
4037948e:	c27c      	movi.n	a2, -4
40379490:	10aa20        	and	a10, a10, a2
    if (xRemLen < xAlignedItemSize + rbHEADER_SIZE) {
40379493:	aa8b      	addi.n	a10, a10, 8
40379495:	07bea7        	bgeu	a14, a10, 403794a0 <prvAcquireItemNoSplit+0x5c>
        pxDummy->uxItemFlags = rbITEM_DUMMY_DATA_FLAG;      //Set remaining length as dummy data
40379498:	220c      	movi.n	a2, 2
4037949a:	1929      	s32i.n	a2, a9, 4
        pxDummy->xItemLen = 0;                              //Dummy data should have no length
4037949c:	09d9      	s32i.n	a13, a9, 0
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;     //Reset acquire pointer to wrap around
4037949e:	88b9      	s32i.n	a11, a8, 32
    ItemHeader_t *pxHeader = (ItemHeader_t *)pxRingbuffer->pucAcquire;
403794a0:	8898      	l32i.n	a9, a8, 32
    pxHeader->uxItemFlags = 0;
403794a2:	020c      	movi.n	a2, 0
403794a4:	1929      	s32i.n	a2, a9, 4
    pxHeader->xItemLen = xItemSize;
403794a6:	0939      	s32i.n	a3, a9, 0
    uint8_t* item_address = pxRingbuffer->pucAcquire + rbHEADER_SIZE;
403794a8:	298b      	addi.n	a2, a9, 8
    pxRingbuffer->pucAcquire += rbHEADER_SIZE + xAlignedItemSize;    //Advance pucAcquire past header and the item to next aligned address
403794aa:	99aa      	add.n	a9, a9, a10
    if (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire < rbHEADER_SIZE) {
403794ac:	c0cc90        	sub	a12, a12, a9
403794af:	018cb6        	bltui	a12, 8, 403794b4 <prvAcquireItemNoSplit+0x70>
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;   //Wrap around pucAcquire
403794b2:	09bd      	mov.n	a11, a9
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
403794b4:	b838      	l32i.n	a3, a8, 44
403794b6:	88b9      	s32i.n	a11, a8, 32
403794b8:	089b37        	bne	a11, a3, 403794c4 <prvAcquireItemNoSplit+0x80>
        pxRingbuffer->uxRingbufferFlags |= rbBUFFER_FULL_FLAG;
403794bb:	2898      	l32i.n	a9, a8, 8
403794bd:	430c      	movi.n	a3, 4
403794bf:	209930        	or	a9, a9, a3
403794c2:	2899      	s32i.n	a9, a8, 8
}
403794c4:	f01d      	retw.n
	...

403794c8 <prvSendItemDoneNoSplit>:
{
403794c8:	004136        	entry	a1, 32
    configASSERT(rbCHECK_ALIGNED(pucItem));
403794cb:	148030        	extui	a8, a3, 0, 2
403794ce:	089c      	beqz.n	a8, 403794e2 <prvSendItemDoneNoSplit+0x1a>
403794d0:	ed61d1        	l32r	a13, 40374a54 <_iram_text_start+0x650>
403794d3:	ed72c1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
403794d6:	7fa1b2        	movi	a11, 0x17f
    configASSERT(pucItem >= pxRingbuffer->pucHead);
403794d9:	ed59a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403794dc:	201110        	or	a1, a1, a1
403794df:	0532e5        	call8	4037e80c <__assert_func>
403794e2:	c298      	l32i.n	a9, a2, 48
403794e4:	0cb397        	bgeu	a3, a9, 403794f4 <prvSendItemDoneNoSplit+0x2c>
403794e7:	ed5dd1        	l32r	a13, 40374a5c <_iram_text_start+0x658>
403794ea:	ed6cc1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
403794ed:	80a1b2        	movi	a11, 0x180
403794f0:	fff946        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
403794f3:	00          	.byte 00
    configASSERT(pucItem <= pxRingbuffer->pucTail);     //Inclusive of pucTail in the case of zero length item at the very end
403794f4:	d2b8      	l32i.n	a11, a2, 52
403794f6:	0bbb37        	bgeu	a11, a3, 40379505 <prvSendItemDoneNoSplit+0x3d>
403794f9:	ed59d1        	l32r	a13, 40374a60 <_iram_text_start+0x65c>
403794fc:	ed68c1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
403794ff:	81a1b2        	movi	a11, 0x181
40379502:	fff4c6        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
    configASSERT(pxCurHeader->xItemLen <= pxRingbuffer->xMaxItemSize);
40379505:	f8c332        	addi	a3, a3, -8
40379508:	0388      	l32i.n	a8, a3, 0
4037950a:	12a8      	l32i.n	a10, a2, 4
4037950c:	0cba87        	bgeu	a10, a8, 4037951c <prvSendItemDoneNoSplit+0x54>
4037950f:	ed55d1        	l32r	a13, 40374a64 <_iram_text_start+0x660>
40379512:	ed62c1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
40379515:	85a1b2        	movi	a11, 0x185
40379518:	ffef46        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
4037951b:	00          	.byte 00
    configASSERT((pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) == 0); //Dummy items should never have been written
4037951c:	1388      	l32i.n	a8, a3, 4
4037951e:	2c0c      	movi.n	a12, 2
40379520:	0b08c7        	bnone	a8, a12, 4037952f <prvSendItemDoneNoSplit+0x67>
40379523:	ed51d1        	l32r	a13, 40374a68 <_iram_text_start+0x664>
40379526:	ed5dc1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
40379529:	86a1b2        	movi	a11, 0x186
4037952c:	ffea46        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
    configASSERT((pxCurHeader->uxItemFlags & rbITEM_WRITTEN_FLAG) == 0);       //Indicates item has already been written before
4037952f:	8a0c      	movi.n	a10, 8
40379531:	0b08a7        	bnone	a8, a10, 40379540 <prvSendItemDoneNoSplit+0x78>
40379534:	ed5bd1        	l32r	a13, 40374aa0 <_iram_text_start+0x69c>
40379537:	ed59c1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
4037953a:	87a1b2        	movi	a11, 0x187
4037953d:	ffe606        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
    pxCurHeader->uxItemFlags &= ~rbITEM_SPLIT_FLAG;                         //Clear wrap flag if set (not strictly necessary)
40379540:	bd7c      	movi.n	a13, -5
40379542:	1088d0        	and	a8, a8, a13
    pxCurHeader->uxItemFlags |= rbITEM_WRITTEN_FLAG;                           //Mark as written
40379545:	2088a0        	or	a8, a8, a10
40379548:	1389      	s32i.n	a8, a3, 4
    pxRingbuffer->xItemsWaiting++;
4037954a:	e238      	l32i.n	a3, a2, 56
    pxCurHeader = (ItemHeader_t *)pxRingbuffer->pucWrite;
4037954c:	9288      	l32i.n	a8, a2, 36
    pxRingbuffer->xItemsWaiting++;
4037954e:	331b      	addi.n	a3, a3, 1
40379550:	e239      	s32i.n	a3, a2, 56
    while (((pxCurHeader->uxItemFlags & rbITEM_WRITTEN_FLAG) || (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG)) && pxRingbuffer->pucWrite != pxRingbuffer->pucAcquire) {
40379552:	ad0c      	movi.n	a13, 10
            size_t xAlignedItemSize = rbALIGN_SIZE(pxCurHeader->xItemLen);
40379554:	ce7c      	movi.n	a14, -4
    while (((pxCurHeader->uxItemFlags & rbITEM_WRITTEN_FLAG) || (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG)) && pxRingbuffer->pucWrite != pxRingbuffer->pucAcquire) {
40379556:	1838      	l32i.n	a3, a8, 4
40379558:	0603d7        	bnone	a3, a13, 40379562 <prvSendItemDoneNoSplit+0x9a>
4037955b:	92f8      	l32i.n	a15, a2, 36
4037955d:	8248      	l32i.n	a4, a2, 32
4037955f:	019f47        	bne	a15, a4, 40379564 <prvSendItemDoneNoSplit+0x9c>
}
40379562:	f01d      	retw.n
        if (pxCurHeader->uxItemFlags & rbITEM_DUMMY_DATA_FLAG) {
40379564:	1503c7        	bnone	a3, a12, 4037957d <prvSendItemDoneNoSplit+0xb5>
            pxCurHeader->uxItemFlags |= rbITEM_WRITTEN_FLAG;   //Mark as freed (not strictly necessary but adds redundancy)
40379567:	2033a0        	or	a3, a3, a10
4037956a:	1839      	s32i.n	a3, a8, 4
            pxRingbuffer->pucWrite = pxRingbuffer->pucHead;    //Wrap around due to dummy data
4037956c:	9299      	s32i.n	a9, a2, 36
        if ((pxRingbuffer->pucTail - pxRingbuffer->pucWrite) < rbHEADER_SIZE) {
4037956e:	9238      	l32i.n	a3, a2, 36
40379570:	c03b30        	sub	a3, a11, a3
40379573:	0183f6        	bgeui	a3, 8, 40379578 <prvSendItemDoneNoSplit+0xb0>
            pxRingbuffer->pucWrite = pxRingbuffer->pucHead;
40379576:	9299      	s32i.n	a9, a2, 36
        pxCurHeader = (ItemHeader_t *)pxRingbuffer->pucWrite;      //Update header to point to item
40379578:	9288      	l32i.n	a8, a2, 36
4037957a:	fff606        	j	40379556 <prvSendItemDoneNoSplit+0x8e>
            size_t xAlignedItemSize = rbALIGN_SIZE(pxCurHeader->xItemLen);
4037957d:	0888      	l32i.n	a8, a8, 0
            configASSERT(pxRingbuffer->pucWrite <= pxRingbuffer->pucHead + pxRingbuffer->xSize);
4037957f:	0238      	l32i.n	a3, a2, 0
            size_t xAlignedItemSize = rbALIGN_SIZE(pxCurHeader->xItemLen);
40379581:	883b      	addi.n	a8, a8, 3
40379583:	1088e0        	and	a8, a8, a14
            pxRingbuffer->pucWrite += xAlignedItemSize + rbHEADER_SIZE;
40379586:	888b      	addi.n	a8, a8, 8
40379588:	8f8a      	add.n	a8, a15, a8
4037958a:	9289      	s32i.n	a8, a2, 36
            configASSERT(pxRingbuffer->pucWrite <= pxRingbuffer->pucHead + pxRingbuffer->xSize);
4037958c:	393a      	add.n	a3, a9, a3
4037958e:	dcb387        	bgeu	a3, a8, 4037956e <prvSendItemDoneNoSplit+0xa6>
40379591:	ed44d1        	l32r	a13, 40374aa4 <_iram_text_start+0x6a0>
40379594:	ed42c1        	l32r	a12, 40374a9c <_iram_text_start+0x698>
40379597:	9fa1b2        	movi	a11, 0x19f
4037959a:	ffcec6        	j	403794d9 <prvSendItemDoneNoSplit+0x11>
4037959d:	000000        	ill

403795a0 <prvCheckItemFitsDefault>:
{
403795a0:	004136        	entry	a1, 32
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucAcquire));              //pucAcquire is always aligned in no-split/allow-split ring buffers
403795a3:	082282        	l32i	a8, a2, 32
{
403795a6:	20a220        	or	a10, a2, a2
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucAcquire));              //pucAcquire is always aligned in no-split/allow-split ring buffers
403795a9:	14c080        	extui	a12, a8, 0, 2
403795ac:	00ec16        	beqz	a12, 403795be <prvCheckItemFitsDefault+0x1e>
403795af:	ed38d1        	l32r	a13, 40374a90 <_iram_text_start+0x68c>
403795b2:	ed3dc1        	l32r	a12, 40374aa8 <_iram_text_start+0x6a4>
403795b5:	2ba1b2        	movi	a11, 0x12b
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check write pointer is within bounds
403795b8:	ed22a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403795bb:	052525        	call8	4037e80c <__assert_func>
403795be:	c2f8      	l32i.n	a15, a2, 48
403795c0:	0438f7        	bltu	a8, a15, 403795c8 <prvCheckItemFitsDefault+0x28>
403795c3:	d228      	l32i.n	a2, a2, 52
403795c5:	0b3827        	bltu	a8, a2, 403795d4 <prvCheckItemFitsDefault+0x34>
403795c8:	ed21d1        	l32r	a13, 40374a4c <_iram_text_start+0x648>
403795cb:	ed37c1        	l32r	a12, 40374aa8 <_iram_text_start+0x6a4>
403795ce:	2ca1b2        	movi	a11, 0x12c
403795d1:	fff8c6        	j	403795b8 <prvCheckItemFitsDefault+0x18>
    size_t xTotalItemSize = rbALIGN_SIZE(xItemSize) + rbHEADER_SIZE;    //Rounded up aligned item size with header
403795d4:	c97c      	movi.n	a9, -4
403795d6:	333b      	addi.n	a3, a3, 3
403795d8:	103390        	and	a3, a3, a9
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
403795db:	ba98      	l32i.n	a9, a10, 44
    size_t xTotalItemSize = rbALIGN_SIZE(xItemSize) + rbHEADER_SIZE;    //Rounded up aligned item size with header
403795dd:	e38b      	addi.n	a14, a3, 8
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
403795df:	1b0c      	movi.n	a11, 1
403795e1:	0b9897        	bne	a8, a9, 403795f0 <prvCheckItemFitsDefault+0x50>
        return (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) ? pdFALSE : pdTRUE;
403795e4:	2a28      	l32i.n	a2, a10, 8
403795e6:	042220        	extui	a2, a2, 2, 1
403795e9:	3022b0        	xor	a2, a2, a11
}
403795ec:	f01d      	retw.n
403795ee:	00          	.byte 00
403795ef:	00          	.byte 00
    if (pxRingbuffer->pucFree > pxRingbuffer->pucAcquire) {
403795f0:	0cb897        	bgeu	a8, a9, 40379600 <prvCheckItemFitsDefault+0x60>
        return (xTotalItemSize <= pxRingbuffer->pucFree - pxRingbuffer->pucAcquire) ? pdTRUE : pdFALSE;
403795f3:	c09980        	sub	a9, a9, a8
403795f6:	0b2d      	mov.n	a2, a11
403795f8:	f0b9e7        	bgeu	a9, a14, 403795ec <prvCheckItemFitsDefault+0x4c>
        return (xTotalItemSize + rbHEADER_SIZE <= pxRingbuffer->xSize - (pxRingbuffer->pucAcquire - pxRingbuffer->pucFree)) ? pdTRUE : pdFALSE;
403795fb:	0c2d      	mov.n	a2, a12
403795fd:	fffac6        	j	403795ec <prvCheckItemFitsDefault+0x4c>
    if (xTotalItemSize <= pxRingbuffer->pucTail - pxRingbuffer->pucAcquire) {
40379600:	c0d280        	sub	a13, a2, a8
        return pdTRUE;      //Item fits without wrapping around
40379603:	0b2d      	mov.n	a2, a11
    if (xTotalItemSize <= pxRingbuffer->pucTail - pxRingbuffer->pucAcquire) {
40379605:	e3bde7        	bgeu	a13, a14, 403795ec <prvCheckItemFitsDefault+0x4c>
    if (pxRingbuffer->uxRingbufferFlags & rbALLOW_SPLIT_FLAG) {
40379608:	2ad8      	l32i.n	a13, a10, 8
4037960a:	04d0d0        	extui	a13, a13, 0, 1
4037960d:	3d9c      	beqz.n	a13, 40379624 <prvCheckItemFitsDefault+0x84>
        return (xTotalItemSize + rbHEADER_SIZE <= pxRingbuffer->xSize - (pxRingbuffer->pucAcquire - pxRingbuffer->pucFree)) ? pdTRUE : pdFALSE;
4037960f:	0a28      	l32i.n	a2, a10, 0
40379611:	c08890        	sub	a8, a8, a9
40379614:	c08280        	sub	a8, a2, a8
40379617:	10c332        	addi	a3, a3, 16
4037961a:	0b2d      	mov.n	a2, a11
4037961c:	ccb837        	bgeu	a8, a3, 403795ec <prvCheckItemFitsDefault+0x4c>
4037961f:	fff606        	j	403795fb <prvCheckItemFitsDefault+0x5b>
40379622:	00          	.byte 00
40379623:	00          	.byte 00
        return (xTotalItemSize <= pxRingbuffer->pucFree - pxRingbuffer->pucHead) ? pdTRUE : pdFALSE;
40379624:	c099f0        	sub	a9, a9, a15
40379627:	c1b9e7        	bgeu	a9, a14, 403795ec <prvCheckItemFitsDefault+0x4c>
4037962a:	0d2d      	mov.n	a2, a13
4037962c:	ffef06        	j	403795ec <prvCheckItemFitsDefault+0x4c>
	...

40379630 <prvInitializeNewRingbuffer>:
{
40379630:	004136        	entry	a1, 32
    pxNewRingbuffer->pucTail = pucRingbufferStorage + xBufferSize;
40379633:	808520        	add	a8, a5, a2
    pxNewRingbuffer->pucHead = pucRingbufferStorage;
40379636:	0c6452        	s32i	a5, a4, 48
    pxNewRingbuffer->pucFree = pucRingbufferStorage;
40379639:	0b6452        	s32i	a5, a4, 44
    pxNewRingbuffer->pucRead = pucRingbufferStorage;
4037963c:	a459      	s32i.n	a5, a4, 40
    pxNewRingbuffer->pucWrite = pucRingbufferStorage;
4037963e:	9459      	s32i.n	a5, a4, 36
    pxNewRingbuffer->pucAcquire = pucRingbufferStorage;
40379640:	8459      	s32i.n	a5, a4, 32
    pxNewRingbuffer->xItemsWaiting = 0;
40379642:	050c      	movi.n	a5, 0
    pxNewRingbuffer->xSize = xBufferSize;
40379644:	0429      	s32i.n	a2, a4, 0
    pxNewRingbuffer->pucTail = pucRingbufferStorage + xBufferSize;
40379646:	d489      	s32i.n	a8, a4, 52
    pxNewRingbuffer->xItemsWaiting = 0;
40379648:	e459      	s32i.n	a5, a4, 56
    if (xBufferType == RINGBUF_TYPE_NOSPLIT) {
4037964a:	469357        	bne	a3, a5, 40379694 <prvInitializeNewRingbuffer+0x64>
        pxNewRingbuffer->xMaxItemSize = rbALIGN_SIZE(pxNewRingbuffer->xSize / 2) - rbHEADER_SIZE;
4037964d:	412120        	srli	a2, a2, 1
    pxNewRingbuffer->uxRingbufferFlags = 0;
40379650:	2439      	s32i.n	a3, a4, 8
        pxNewRingbuffer->xMaxItemSize = rbALIGN_SIZE(pxNewRingbuffer->xSize / 2) - rbHEADER_SIZE;
40379652:	223b      	addi.n	a2, a2, 3
40379654:	c37c      	movi.n	a3, -4
40379656:	102230        	and	a2, a2, a3
40379659:	ed14a1        	l32r	a10, 40374aac <_iram_text_start+0x6a8>
4037965c:	ed1591        	l32r	a9, 40374ab0 <_iram_text_start+0x6ac>
4037965f:	ed1581        	l32r	a8, 40374ab4 <_iram_text_start+0x6b0>
40379662:	ed1551        	l32r	a5, 40374ab8 <_iram_text_start+0x6b4>
40379665:	ed1531        	l32r	a3, 40374abc <_iram_text_start+0x6b8>
40379668:	f8c222        	addi	a2, a2, -8
    xSemaphoreGive(rbGET_TX_SEM_HANDLE(pxNewRingbuffer));
4037966b:	0d0c      	movi.n	a13, 0
        pxNewRingbuffer->xCheckItemFits = prvCheckItemFitsDefault;
4037966d:	34a9      	s32i.n	a10, a4, 12
        pxNewRingbuffer->xMaxItemSize = rbALIGN_SIZE(pxNewRingbuffer->xSize / 2) - rbHEADER_SIZE;
4037966f:	1429      	s32i.n	a2, a4, 4
        pxNewRingbuffer->vCopyItem = prvCopyItemNoSplit;
40379671:	4499      	s32i.n	a9, a4, 16
        pxNewRingbuffer->pvGetItem = prvGetItemDefault;
40379673:	5489      	s32i.n	a8, a4, 20
        pxNewRingbuffer->vReturnItem = prvReturnItemDefault;
40379675:	6459      	s32i.n	a5, a4, 24
        pxNewRingbuffer->xGetCurMaxSize = prvGetCurMaxSizeNoSplit;
40379677:	7439      	s32i.n	a3, a4, 28
    xSemaphoreGive(rbGET_TX_SEM_HANDLE(pxNewRingbuffer));
40379679:	3cc4a2        	addi	a10, a4, 60
 */
static inline void __attribute__((always_inline)) spinlock_initialize(spinlock_t *lock)
{
    assert(lock);
#if !CONFIG_FREERTOS_UNICORE
    lock->owner = SPINLOCK_FREE;
4037967c:	e4a022        	movi	a2, 228
4037967f:	0dcd      	mov.n	a12, a13
40379681:	0dbd      	mov.n	a11, a13
40379683:	0106a5        	call8	4037a6ec <xQueueGenericSend>
40379686:	442a      	add.n	a4, a4, a2
40379688:	ed1521        	l32r	a2, 40374adc <_iram_text_start+0x6d8>
4037968b:	0429      	s32i.n	a2, a4, 0
    lock->count = 0;
4037968d:	020c      	movi.n	a2, 0
4037968f:	1429      	s32i.n	a2, a4, 4
}
40379691:	f01d      	retw.n
40379693:	00          	.byte 00
    } else if (xBufferType == RINGBUF_TYPE_ALLOWSPLIT) {
40379694:	161366        	bnei	a3, 1, 403796ae <prvInitializeNewRingbuffer+0x7e>
        pxNewRingbuffer->uxRingbufferFlags |= rbALLOW_SPLIT_FLAG;
40379697:	2439      	s32i.n	a3, a4, 8
        pxNewRingbuffer->xMaxItemSize = pxNewRingbuffer->xSize - (sizeof(ItemHeader_t) * 2);
40379699:	ed04a1        	l32r	a10, 40374aac <_iram_text_start+0x6a8>
4037969c:	ed0991        	l32r	a9, 40374ac0 <_iram_text_start+0x6bc>
4037969f:	ed0581        	l32r	a8, 40374ab4 <_iram_text_start+0x6b0>
403796a2:	ed0551        	l32r	a5, 40374ab8 <_iram_text_start+0x6b4>
403796a5:	ed0731        	l32r	a3, 40374ac4 <_iram_text_start+0x6c0>
403796a8:	f0c222        	addi	a2, a2, -16
        pxNewRingbuffer->xGetCurMaxSize = prvGetCurMaxSizeAllowSplit;
403796ab:	ffef06        	j	4037966b <prvInitializeNewRingbuffer+0x3b>
        pxNewRingbuffer->uxRingbufferFlags |= rbBYTE_BUFFER_FLAG;
403796ae:	230c      	movi.n	a3, 2
403796b0:	2439      	s32i.n	a3, a4, 8
403796b2:	ed05a1        	l32r	a10, 40374ac8 <_iram_text_start+0x6c4>
403796b5:	ed0591        	l32r	a9, 40374acc <_iram_text_start+0x6c8>
403796b8:	ed0681        	l32r	a8, 40374ad0 <_iram_text_start+0x6cc>
403796bb:	ed0651        	l32r	a5, 40374ad4 <_iram_text_start+0x6d0>
403796be:	ed0631        	l32r	a3, 40374ad8 <_iram_text_start+0x6d4>
403796c1:	ffe986        	j	4037966b <prvInitializeNewRingbuffer+0x3b>

403796c4 <prvCopyItemByteBuf>:
{
403796c4:	004136        	entry	a1, 32
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check acquire pointer is within bounds
403796c7:	82a8      	l32i.n	a10, a2, 32
403796c9:	0c2252        	l32i	a5, a2, 48
403796cc:	043a57        	bltu	a10, a5, 403796d4 <prvCopyItemByteBuf+0x10>
403796cf:	d258      	l32i.n	a5, a2, 52
403796d1:	0e3a57        	bltu	a10, a5, 403796e3 <prvCopyItemByteBuf+0x1f>
403796d4:	ecded1        	l32r	a13, 40374a4c <_iram_text_start+0x648>
403796d7:	ed02c1        	l32r	a12, 40374ae0 <_iram_text_start+0x6dc>
403796da:	ecd9a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403796dd:	eaa1b2        	movi	a11, 0x1ea
403796e0:	0512a5        	call8	4037e80c <__assert_func>
    size_t xRemLen = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;    //Length from pucAcquire until end of buffer
403796e3:	c055a0        	sub	a5, a5, a10
    if (xRemLen < xItemSize) {
403796e6:	1bb547        	bgeu	a5, a4, 40379705 <prvCopyItemByteBuf+0x41>
        memcpy(pxRingbuffer->pucAcquire, pucItem, xRemLen);
403796e9:	20c550        	or	a12, a5, a5
403796ec:	20b330        	or	a11, a3, a3
403796ef:	eb7081        	l32r	a8, 403744b0 <_iram_text_start+0xac>
403796f2:	0008e0        	callx8	a8
        pxRingbuffer->xItemsWaiting += xRemLen;
403796f5:	0e2282        	l32i	a8, a2, 56
        pucItem += xRemLen;
403796f8:	335a      	add.n	a3, a3, a5
        pxRingbuffer->xItemsWaiting += xRemLen;
403796fa:	885a      	add.n	a8, a8, a5
        xItemSize -= xRemLen;
403796fc:	c04450        	sub	a4, a4, a5
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;     //Reset acquire pointer to start of buffer
403796ff:	c258      	l32i.n	a5, a2, 48
        pxRingbuffer->xItemsWaiting += xRemLen;
40379701:	e289      	s32i.n	a8, a2, 56
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;     //Reset acquire pointer to start of buffer
40379703:	8259      	s32i.n	a5, a2, 32
    memcpy(pxRingbuffer->pucAcquire, pucItem, xItemSize);
40379705:	82a8      	l32i.n	a10, a2, 32
40379707:	04cd      	mov.n	a12, a4
40379709:	03bd      	mov.n	a11, a3
4037970b:	eb6981        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037970e:	0008e0        	callx8	a8
    pxRingbuffer->xItemsWaiting += xItemSize;
40379711:	e238      	l32i.n	a3, a2, 56
    pxRingbuffer->pucAcquire += xItemSize;
40379713:	8258      	l32i.n	a5, a2, 32
    pxRingbuffer->xItemsWaiting += xItemSize;
40379715:	334a      	add.n	a3, a3, a4
40379717:	e239      	s32i.n	a3, a2, 56
    pxRingbuffer->pucAcquire += xItemSize;
40379719:	454a      	add.n	a4, a5, a4
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucTail) {
4037971b:	d238      	l32i.n	a3, a2, 52
    pxRingbuffer->pucAcquire += xItemSize;
4037971d:	8249      	s32i.n	a4, a2, 32
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucTail) {
4037971f:	039437        	bne	a4, a3, 40379726 <prvCopyItemByteBuf+0x62>
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;
40379722:	c238      	l32i.n	a3, a2, 48
40379724:	8239      	s32i.n	a3, a2, 32
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
40379726:	8248      	l32i.n	a4, a2, 32
40379728:	b238      	l32i.n	a3, a2, 44
4037972a:	089437        	bne	a4, a3, 40379736 <prvCopyItemByteBuf+0x72>
        pxRingbuffer->uxRingbufferFlags |= rbBUFFER_FULL_FLAG;      //Mark the buffer as full to avoid confusion with an empty buffer
4037972d:	2238      	l32i.n	a3, a2, 8
4037972f:	450c      	movi.n	a5, 4
40379731:	203350        	or	a3, a3, a5
40379734:	2239      	s32i.n	a3, a2, 8
    pxRingbuffer->pucWrite = pxRingbuffer->pucAcquire;
40379736:	9249      	s32i.n	a4, a2, 36
}
40379738:	f01d      	retw.n
	...

4037973c <prvCopyItemAllowSplit>:
{
4037973c:	004136        	entry	a1, 32
    size_t xRemLen = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;    //Length from pucAcquire until end of buffer
4037973f:	082262        	l32i	a6, a2, 32
40379742:	0d2252        	l32i	a5, a2, 52
    configASSERT(rbCHECK_ALIGNED(pxRingbuffer->pucAcquire));              //pucAcquire is always aligned in split ring buffers
40379745:	148060        	extui	a8, a6, 0, 2
40379748:	00e816        	beqz	a8, 4037975a <prvCopyItemAllowSplit+0x1e>
4037974b:	ecd1d1        	l32r	a13, 40374a90 <_iram_text_start+0x68c>
4037974e:	ece5c1        	l32r	a12, 40374ae4 <_iram_text_start+0x6e0>
40379751:	b5a1b2        	movi	a11, 0x1b5
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check write pointer is within bounds
40379754:	ecbba1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379757:	050b65        	call8	4037e80c <__assert_func>
4037975a:	c278      	l32i.n	a7, a2, 48
4037975c:	143677        	bltu	a6, a7, 40379774 <prvCopyItemAllowSplit+0x38>
4037975f:	11b657        	bgeu	a6, a5, 40379774 <prvCopyItemAllowSplit+0x38>
    size_t xRemLen = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;    //Length from pucAcquire until end of buffer
40379762:	c05560        	sub	a5, a5, a6
    configASSERT(xRemLen >= rbHEADER_SIZE);                             //Remaining length must be able to at least fit an item header
40379765:	1785f6        	bgeui	a5, 8, 40379780 <prvCopyItemAllowSplit+0x44>
40379768:	ecccd1        	l32r	a13, 40374a98 <_iram_text_start+0x694>
4037976b:	ecdec1        	l32r	a12, 40374ae4 <_iram_text_start+0x6e0>
4037976e:	b7a1b2        	movi	a11, 0x1b7
40379771:	fff7c6        	j	40379754 <prvCopyItemAllowSplit+0x18>
    configASSERT(pxRingbuffer->pucAcquire >= pxRingbuffer->pucHead && pxRingbuffer->pucAcquire < pxRingbuffer->pucTail);    //Check write pointer is within bounds
40379774:	ecb6d1        	l32r	a13, 40374a4c <_iram_text_start+0x648>
40379777:	ecdbc1        	l32r	a12, 40374ae4 <_iram_text_start+0x6e0>
4037977a:	b6a1b2        	movi	a11, 0x1b6
4037977d:	fff4c6        	j	40379754 <prvCopyItemAllowSplit+0x18>
    size_t xAlignedItemSize = rbALIGN_SIZE(xItemSize);                  //Rounded up aligned item size
40379780:	c97c      	movi.n	a9, -4
40379782:	743b      	addi.n	a7, a4, 3
40379784:	107790        	and	a7, a7, a9
    if (xRemLen < xAlignedItemSize + rbHEADER_SIZE) {
40379787:	978b      	addi.n	a9, a7, 8
40379789:	2fb597        	bgeu	a5, a9, 403797bc <prvCopyItemAllowSplit+0x80>
        pxFirstHeader->xItemLen = xRemLen - rbHEADER_SIZE;  //Fill remaining length with first part
4037978c:	f8c552        	addi	a5, a5, -8
        pxFirstHeader->uxItemFlags = 0;
4037978f:	1689      	s32i.n	a8, a6, 4
        pxRingbuffer->pucAcquire += rbHEADER_SIZE;            //Advance pucAcquire past header
40379791:	a68b      	addi.n	a10, a6, 8
        pxFirstHeader->xItemLen = xRemLen - rbHEADER_SIZE;  //Fill remaining length with first part
40379793:	0659      	s32i.n	a5, a6, 0
        pxRingbuffer->pucAcquire += rbHEADER_SIZE;            //Advance pucAcquire past header
40379795:	82a9      	s32i.n	a10, a2, 32
        if (xRemLen > 0) {
40379797:	280c      	movi.n	a8, 2
40379799:	959c      	beqz.n	a5, 403797b6 <prvCopyItemAllowSplit+0x7a>
            memcpy(pxRingbuffer->pucAcquire, pucItem, xRemLen);
4037979b:	03bd      	mov.n	a11, a3
4037979d:	05cd      	mov.n	a12, a5
4037979f:	eb4481        	l32r	a8, 403744b0 <_iram_text_start+0xac>
403797a2:	0008e0        	callx8	a8
            pxRingbuffer->xItemsWaiting++;
403797a5:	e288      	l32i.n	a8, a2, 56
            pucItem += xRemLen;
403797a7:	335a      	add.n	a3, a3, a5
            pxRingbuffer->xItemsWaiting++;
403797a9:	881b      	addi.n	a8, a8, 1
403797ab:	e289      	s32i.n	a8, a2, 56
            xItemSize -= xRemLen;
403797ad:	c04450        	sub	a4, a4, a5
            xAlignedItemSize -= xRemLen;
403797b0:	c07750        	sub	a7, a7, a5
            pxFirstHeader->uxItemFlags |= rbITEM_SPLIT_FLAG;        //There must be more data
403797b3:	04a082        	movi	a8, 4
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;             //Reset acquire pointer to start of buffer
403797b6:	c258      	l32i.n	a5, a2, 48
            pxFirstHeader->uxItemFlags |= rbITEM_SPLIT_FLAG;        //There must be more data
403797b8:	1689      	s32i.n	a8, a6, 4
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;             //Reset acquire pointer to start of buffer
403797ba:	8259      	s32i.n	a5, a2, 32
    ItemHeader_t *pxSecondHeader = (ItemHeader_t *)pxRingbuffer->pucAcquire;
403797bc:	82a8      	l32i.n	a10, a2, 32
    pxSecondHeader->uxItemFlags = 0;
403797be:	050c      	movi.n	a5, 0
    pxSecondHeader->xItemLen = xItemSize;
403797c0:	0a49      	s32i.n	a4, a10, 0
    pxSecondHeader->uxItemFlags = 0;
403797c2:	1a59      	s32i.n	a5, a10, 4
    pxRingbuffer->pucAcquire += rbHEADER_SIZE;     //Advance acquire pointer past header
403797c4:	aa8b      	addi.n	a10, a10, 8
    memcpy(pxRingbuffer->pucAcquire, pucItem, xItemSize);
403797c6:	04cd      	mov.n	a12, a4
403797c8:	03bd      	mov.n	a11, a3
    pxRingbuffer->pucAcquire += rbHEADER_SIZE;     //Advance acquire pointer past header
403797ca:	82a9      	s32i.n	a10, a2, 32
    memcpy(pxRingbuffer->pucAcquire, pucItem, xItemSize);
403797cc:	eb3981        	l32r	a8, 403744b0 <_iram_text_start+0xac>
403797cf:	0008e0        	callx8	a8
    pxRingbuffer->xItemsWaiting++;
403797d2:	e238      	l32i.n	a3, a2, 56
    pxRingbuffer->pucAcquire += xAlignedItemSize;  //Advance pucAcquire past item to next aligned address
403797d4:	8248      	l32i.n	a4, a2, 32
    pxRingbuffer->xItemsWaiting++;
403797d6:	331b      	addi.n	a3, a3, 1
403797d8:	e239      	s32i.n	a3, a2, 56
    if (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire < rbHEADER_SIZE) {
403797da:	d238      	l32i.n	a3, a2, 52
    pxRingbuffer->pucAcquire += xAlignedItemSize;  //Advance pucAcquire past item to next aligned address
403797dc:	447a      	add.n	a4, a4, a7
403797de:	8249      	s32i.n	a4, a2, 32
    if (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire < rbHEADER_SIZE) {
403797e0:	c03340        	sub	a3, a3, a4
403797e3:	0383f6        	bgeui	a3, 8, 403797ea <prvCopyItemAllowSplit+0xae>
        pxRingbuffer->pucAcquire = pxRingbuffer->pucHead;   //Wrap around pucAcquire
403797e6:	c238      	l32i.n	a3, a2, 48
403797e8:	8239      	s32i.n	a3, a2, 32
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucFree) {
403797ea:	8248      	l32i.n	a4, a2, 32
403797ec:	b238      	l32i.n	a3, a2, 44
403797ee:	089437        	bne	a4, a3, 403797fa <prvCopyItemAllowSplit+0xbe>
        pxRingbuffer->uxRingbufferFlags |= rbBUFFER_FULL_FLAG;
403797f1:	2238      	l32i.n	a3, a2, 8
403797f3:	450c      	movi.n	a5, 4
403797f5:	203350        	or	a3, a3, a5
403797f8:	2239      	s32i.n	a3, a2, 8
    pxRingbuffer->pucWrite = pxRingbuffer->pucAcquire;
403797fa:	9249      	s32i.n	a4, a2, 36
}
403797fc:	f01d      	retw.n
	...

40379800 <prvCopyItemNoSplit>:
{
40379800:	004136        	entry	a1, 32
    uint8_t* item_addr = prvAcquireItemNoSplit(pxRingbuffer, xItemSize);
40379803:	20b440        	or	a11, a4, a4
40379806:	20a220        	or	a10, a2, a2
40379809:	ffc3a5        	call8	40379444 <prvAcquireItemNoSplit>
    memcpy(item_addr, pucItem, xItemSize);
4037980c:	20b330        	or	a11, a3, a3
4037980f:	04cd      	mov.n	a12, a4
40379811:	eb2781        	l32r	a8, 403744b0 <_iram_text_start+0xac>
40379814:	0008e0        	callx8	a8
    prvSendItemDoneNoSplit(pxRingbuffer, item_addr);
40379817:	0abd      	mov.n	a11, a10
40379819:	02ad      	mov.n	a10, a2
4037981b:	ffcae5        	call8	403794c8 <prvSendItemDoneNoSplit>
}
4037981e:	f01d      	retw.n

40379820 <prvReceiveGeneric>:
                                    void **pvItem2,
                                    size_t *xItemSize1,
                                    size_t *xItemSize2,
                                    size_t xMaxSize,
                                    TickType_t xTicksToWait)
{
40379820:	00a136        	entry	a1, 80
40379823:	5139      	s32i.n	a3, a1, 20
40379825:	6169      	s32i.n	a6, a1, 24
40379827:	8179      	s32i.n	a7, a1, 32
    BaseType_t xReturn = pdFALSE;
    BaseType_t xReturnSemaphore = pdFALSE;
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
40379829:	01b0a5        	call8	4037b334 <xTaskGetTickCount>
4037982c:	142132        	l32i	a3, a1, 80
    TickType_t xTicksRemaining = xTicksToWait;
    while (xTicksRemaining <= xTicksToWait) {   //xTicksToWait will underflow once xTaskGetTickCount() > ticks_end
        //Block until more free space becomes available or timeout
        if (xSemaphoreTake(rbGET_RX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
4037982f:	90a062        	movi	a6, 144
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
40379832:	aa3a      	add.n	a10, a10, a3
40379834:	4139      	s32i.n	a3, a1, 16
            xReturn = pdFALSE;     //Timed out attempting to get semaphore
            break;
        }

        //Semaphore obtained, check if item can be retrieved
        portENTER_CRITICAL(&pxRingbuffer->mux);
40379836:	e4a032        	movi	a3, 228
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
40379839:	0761a2        	s32i	a10, a1, 28
        if (xSemaphoreTake(rbGET_RX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
4037983c:	806260        	add	a6, a2, a6
        portENTER_CRITICAL(&pxRingbuffer->mux);
4037983f:	803230        	add	a3, a2, a3
        if (xSemaphoreTake(rbGET_RX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
40379842:	0421b2        	l32i	a11, a1, 16
40379845:	20a660        	or	a10, a6, a6
40379848:	012865        	call8	4037aad0 <xQueueSemaphoreTake>
4037984b:	071a26        	beqi	a10, 1, 40379856 <prvReceiveGeneric+0x36>
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
4037984e:	00a072        	movi	a7, 0

    if (xReturnSemaphore == pdTRUE) {
        xSemaphoreGive(rbGET_RX_SEM_HANDLE(pxRingbuffer));  //Give semaphore back so other tasks can retrieve
    }
    return xReturn;
}
40379851:	072d      	mov.n	a2, a7
40379853:	f01d      	retw.n
40379855:	00          	.byte 00
40379856:	ffafb2        	movi	a11, -1
40379859:	03ad      	mov.n	a10, a3
4037985b:	02d565        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if (prvCheckItemAvail(pxRingbuffer) == pdTRUE) {
4037985e:	02ad      	mov.n	a10, a2
40379860:	005425        	call8	40379da4 <prvCheckItemAvail>
40379863:	0a7d      	mov.n	a7, a10
40379865:	021a26        	beqi	a10, 1, 4037986b <prvReceiveGeneric+0x4b>
40379868:	002246        	j	403798f5 <prvReceiveGeneric+0xd5>
            if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
4037986b:	2298      	l32i.n	a9, a2, 8
            BaseType_t xIsSplit = pdFALSE;
4037986d:	0b0c      	movi.n	a11, 0
            if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
4037986f:	2c0c      	movi.n	a12, 2
            BaseType_t xIsSplit = pdFALSE;
40379871:	01b9      	s32i.n	a11, a1, 0
            if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
40379873:	10cc90        	and	a12, a12, a9
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
40379876:	5288      	l32i.n	a8, a2, 20
40379878:	05dd      	mov.n	a13, a5
            if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
4037987a:	421cb7        	beq	a12, a11, 403798c0 <prvReceiveGeneric+0xa0>
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
4037987d:	81c8      	l32i.n	a12, a1, 32
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize1);
4037987f:	02ad      	mov.n	a10, a2
40379881:	0008e0        	callx8	a8
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
40379884:	5188      	l32i.n	a8, a1, 20
            if ((pxRingbuffer->uxRingbufferFlags & rbALLOW_SPLIT_FLAG) && (pvItem2 != NULL) && (xItemSize2 != NULL)) {
40379886:	2258      	l32i.n	a5, a2, 8
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
40379888:	08a9      	s32i.n	a10, a8, 0
            if ((pxRingbuffer->uxRingbufferFlags & rbALLOW_SPLIT_FLAG) && (pvItem2 != NULL) && (xItemSize2 != NULL)) {
4037988a:	4a6507        	bbci	a5, 0, 403798d8 <prvReceiveGeneric+0xb8>
4037988d:	0c0c      	movi.n	a12, 0
4037988f:	4514c7        	beq	a4, a12, 403798d8 <prvReceiveGeneric+0xb8>
40379892:	6198      	l32i.n	a9, a1, 24
40379894:	4019c7        	beq	a9, a12, 403798d8 <prvReceiveGeneric+0xb8>
                if (xIsSplit == pdTRUE) {
40379897:	0158      	l32i.n	a5, a1, 0
40379899:	391566        	bnei	a5, 1, 403798d6 <prvReceiveGeneric+0xb6>
                    *pvItem2 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize2);
4037989c:	5258      	l32i.n	a5, a2, 20
4037989e:	09dd      	mov.n	a13, a9
403798a0:	01bd      	mov.n	a11, a1
403798a2:	20a220        	or	a10, a2, a2
403798a5:	0005e0        	callx8	a5
                    configASSERT(*pvItem2 < *pvItem1);  //Check wrap around has occurred
403798a8:	5188      	l32i.n	a8, a1, 20
                    *pvItem2 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize2);
403798aa:	04a9      	s32i.n	a10, a4, 0
                    configASSERT(*pvItem2 < *pvItem1);  //Check wrap around has occurred
403798ac:	0848      	l32i.n	a4, a8, 0
403798ae:	133a47        	bltu	a10, a4, 403798c5 <prvReceiveGeneric+0xa5>
403798b1:	ec8dd1        	l32r	a13, 40374ae8 <_iram_text_start+0x6e4>
403798b4:	ec8ec1        	l32r	a12, 40374aec <_iram_text_start+0x6e8>
403798b7:	1da3b2        	movi	a11, 0x31d
                    configASSERT(xIsSplit == pdFALSE);  //Second part should not have wrapped flag
403798ba:	ec61a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403798bd:	04f4e5        	call8	4037e80c <__assert_func>
                *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize1);
403798c0:	01bd      	mov.n	a11, a1
403798c2:	ffee46        	j	4037987f <prvReceiveGeneric+0x5f>
                    configASSERT(xIsSplit == pdFALSE);  //Second part should not have wrapped flag
403798c5:	0148      	l32i.n	a4, a1, 0
403798c7:	d48c      	beqz.n	a4, 403798d8 <prvReceiveGeneric+0xb8>
403798c9:	ec89d1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec>
403798cc:	ec88c1        	l32r	a12, 40374aec <_iram_text_start+0x6e8>
403798cf:	1ea3b2        	movi	a11, 0x31e
403798d2:	fff906        	j	403798ba <prvReceiveGeneric+0x9a>
403798d5:	00          	.byte 00
                    *pvItem2 = NULL;
403798d6:	04c9      	s32i.n	a12, a4, 0
            if (pxRingbuffer->xItemsWaiting > 0) {
403798d8:	e228      	l32i.n	a2, a2, 56
            portEXIT_CRITICAL(&pxRingbuffer->mux);
403798da:	03ad      	mov.n	a10, a3
403798dc:	02e065        	call8	4037c6e4 <vPortExitCritical>
    if (xReturnSemaphore == pdTRUE) {
403798df:	0212e6        	bgei	a2, 1, 403798e5 <prvReceiveGeneric+0xc5>
403798e2:	ffdac6        	j	40379851 <prvReceiveGeneric+0x31>
        xSemaphoreGive(rbGET_RX_SEM_HANDLE(pxRingbuffer));  //Give semaphore back so other tasks can retrieve
403798e5:	0d0c      	movi.n	a13, 0
403798e7:	0dcd      	mov.n	a12, a13
403798e9:	0dbd      	mov.n	a11, a13
403798eb:	06ad      	mov.n	a10, a6
403798ed:	00dfe5        	call8	4037a6ec <xQueueGenericSend>
    return xReturn;
403798f0:	ffd746        	j	40379851 <prvReceiveGeneric+0x31>
403798f3:	00          	.byte 00
403798f4:	00          	.byte 00
        if (xTicksToWait != portMAX_DELAY) {
403798f5:	142192        	l32i	a9, a1, 80
403798f8:	090926        	beqi	a9, -1, 40379905 <prvReceiveGeneric+0xe5>
            xTicksRemaining = xTicksEnd - xTaskGetTickCount();
403798fb:	01a3a5        	call8	4037b334 <xTaskGetTickCount>
403798fe:	7188      	l32i.n	a8, a1, 28
40379900:	c0a8a0        	sub	a10, a8, a10
40379903:	41a9      	s32i.n	a10, a1, 16
        portEXIT_CRITICAL(&pxRingbuffer->mux);
40379905:	03ad      	mov.n	a10, a3
40379907:	02dde5        	call8	4037c6e4 <vPortExitCritical>
    while (xTicksRemaining <= xTicksToWait) {   //xTicksToWait will underflow once xTaskGetTickCount() > ticks_end
4037990a:	142192        	l32i	a9, a1, 80
4037990d:	4188      	l32i.n	a8, a1, 16
4037990f:	023987        	bltu	a9, a8, 40379915 <prvReceiveGeneric+0xf5>
40379912:	ffcb06        	j	40379842 <prvReceiveGeneric+0x22>
40379915:	ffcd46        	j	4037984e <prvReceiveGeneric+0x2e>

40379918 <prvReceiveGenericFromISR>:
                                           void **pvItem1,
                                           void **pvItem2,
                                           size_t *xItemSize1,
                                           size_t *xItemSize2,
                                           size_t xMaxSize)
{
40379918:	008136        	entry	a1, 64
4037991b:	208770        	or	a8, a7, a7
    BaseType_t xReturn = pdFALSE;
    BaseType_t xReturnSemaphore = pdFALSE;

    portENTER_CRITICAL_ISR(&pxRingbuffer->mux);
4037991e:	e4a072        	movi	a7, 228
40379921:	727a      	add.n	a7, a2, a7
40379923:	fb7c      	movi.n	a11, -1
40379925:	07ad      	mov.n	a10, a7
40379927:	5189      	s32i.n	a8, a1, 20
40379929:	046152        	s32i	a5, a1, 16
4037992c:	02c825        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if(prvCheckItemAvail(pxRingbuffer) == pdTRUE) {
4037992f:	02ad      	mov.n	a10, a2
40379931:	004725        	call8	40379da4 <prvCheckItemAvail>
40379934:	5188      	l32i.n	a8, a1, 20
40379936:	41d8      	l32i.n	a13, a1, 16
40379938:	0a5d      	mov.n	a5, a10
4037993a:	0b0c      	movi.n	a11, 0
4037993c:	021a26        	beqi	a10, 1, 40379942 <prvReceiveGenericFromISR+0x2a>
4037993f:	002146        	j	403799c8 <prvReceiveGenericFromISR+0xb0>
        BaseType_t xIsSplit = pdFALSE;
        if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
40379942:	22a8      	l32i.n	a10, a2, 8
40379944:	2c0c      	movi.n	a12, 2
        BaseType_t xIsSplit = pdFALSE;
40379946:	01b9      	s32i.n	a11, a1, 0
        if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
40379948:	10cca0        	and	a12, a12, a10
            //Second argument (pxIsSplit) is unused for byte buffers
            *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
4037994b:	5298      	l32i.n	a9, a2, 20
        if (pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) {
4037994d:	3c1cb7        	beq	a12, a11, 4037998d <prvReceiveGenericFromISR+0x75>
            *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
40379950:	08cd      	mov.n	a12, a8
        } else {
            //Third argument (xMaxSize) is unused for no-split/allow-split buffers
            *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize1);
40379952:	20a220        	or	a10, a2, a2
40379955:	0009e0        	callx8	a9
        }
        //Check for item split if configured to do so
        if ((pxRingbuffer->uxRingbufferFlags & rbALLOW_SPLIT_FLAG) && pvItem2 != NULL && xItemSize2 != NULL) {
40379958:	2288      	l32i.n	a8, a2, 8
            *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, NULL, xMaxSize, xItemSize1);
4037995a:	03a9      	s32i.n	a10, a3, 0
        if ((pxRingbuffer->uxRingbufferFlags & rbALLOW_SPLIT_FLAG) && pvItem2 != NULL && xItemSize2 != NULL) {
4037995c:	446807        	bbci	a8, 0, 403799a4 <prvReceiveGenericFromISR+0x8c>
4037995f:	0c0c      	movi.n	a12, 0
40379961:	3f14c7        	beq	a4, a12, 403799a4 <prvReceiveGenericFromISR+0x8c>
40379964:	3c16c7        	beq	a6, a12, 403799a4 <prvReceiveGenericFromISR+0x8c>
            if (xIsSplit == pdTRUE) {
40379967:	0188      	l32i.n	a8, a1, 0
40379969:	351866        	bnei	a8, 1, 403799a2 <prvReceiveGenericFromISR+0x8a>
                *pvItem2 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize2);
4037996c:	5288      	l32i.n	a8, a2, 20
4037996e:	06dd      	mov.n	a13, a6
40379970:	01bd      	mov.n	a11, a1
40379972:	02ad      	mov.n	a10, a2
40379974:	0008e0        	callx8	a8
40379977:	04a9      	s32i.n	a10, a4, 0
                configASSERT(*pvItem2 < *pvItem1);  //Check wrap around has occurred
40379979:	0338      	l32i.n	a3, a3, 0
4037997b:	133a37        	bltu	a10, a3, 40379992 <prvReceiveGenericFromISR+0x7a>
4037997e:	ec5ad1        	l32r	a13, 40374ae8 <_iram_text_start+0x6e4>
40379981:	ec5cc1        	l32r	a12, 40374af4 <_iram_text_start+0x6f0>
40379984:	53a3b2        	movi	a11, 0x353
                configASSERT(xIsSplit == pdFALSE);  //Second part should not have wrapped flag
40379987:	ec2ea1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
4037998a:	04e825        	call8	4037e80c <__assert_func>
            *pvItem1 = pxRingbuffer->pvGetItem(pxRingbuffer, &xIsSplit, 0, xItemSize1);
4037998d:	01bd      	mov.n	a11, a1
4037998f:	ffefc6        	j	40379952 <prvReceiveGenericFromISR+0x3a>
                configASSERT(xIsSplit == pdFALSE);  //Second part should not have wrapped flag
40379992:	0138      	l32i.n	a3, a1, 0
40379994:	c38c      	beqz.n	a3, 403799a4 <prvReceiveGenericFromISR+0x8c>
40379996:	ec56d1        	l32r	a13, 40374af0 <_iram_text_start+0x6ec>
40379999:	ec56c1        	l32r	a12, 40374af4 <_iram_text_start+0x6f0>
4037999c:	54a3b2        	movi	a11, 0x354
4037999f:	fff906        	j	40379987 <prvReceiveGenericFromISR+0x6f>
            } else {
                *pvItem2 = NULL;
403799a2:	04c9      	s32i.n	a12, a4, 0
            }
        }
        xReturn = pdTRUE;
        if (pxRingbuffer->xItemsWaiting > 0) {
403799a4:	0e2232        	l32i	a3, a2, 56
403799a7:	31bf30        	srai	a11, a3, 31
403799aa:	c0bb30        	sub	a11, a11, a3
403799ad:	053fb0        	extui	a3, a11, 31, 1
            xReturnSemaphore = pdTRUE;
        }
    }
    portEXIT_CRITICAL_ISR(&pxRingbuffer->mux);
403799b0:	20a770        	or	a10, a7, a7
403799b3:	02d325        	call8	4037c6e4 <vPortExitCritical>

    if (xReturnSemaphore == pdTRUE) {
403799b6:	0a1366        	bnei	a3, 1, 403799c4 <prvReceiveGenericFromISR+0xac>
        xSemaphoreGiveFromISR(rbGET_RX_SEM_HANDLE(pxRingbuffer), NULL);  //Give semaphore back so other tasks can retrieve
403799b9:	90a0a2        	movi	a10, 144
403799bc:	00a0b2        	movi	a11, 0
403799bf:	a2aa      	add.n	a10, a2, a10
403799c1:	0103a5        	call8	4037a9fc <xQueueGiveFromISR>
    }
    return xReturn;
}
403799c4:	052d      	mov.n	a2, a5
403799c6:	f01d      	retw.n
    BaseType_t xReturnSemaphore = pdFALSE;
403799c8:	0b3d      	mov.n	a3, a11
    BaseType_t xReturn = pdFALSE;
403799ca:	0b5d      	mov.n	a5, a11
403799cc:	fff806        	j	403799b0 <prvReceiveGenericFromISR+0x98>
	...

403799d0 <prvReturnItemByteBuf>:
{
403799d0:	004136        	entry	a1, 32
    configASSERT((uint8_t *)pucItem >= pxRingbuffer->pucHead);
403799d3:	c288      	l32i.n	a8, a2, 48
403799d5:	0eb387        	bgeu	a3, a8, 403799e7 <prvReturnItemByteBuf+0x17>
403799d8:	ec48d1        	l32r	a13, 40374af8 <_iram_text_start+0x6f4>
403799db:	ec48c1        	l32r	a12, 40374afc <_iram_text_start+0x6f8>
403799de:	9da2b2        	movi	a11, 0x29d
    configASSERT((uint8_t *)pucItem < pxRingbuffer->pucTail);
403799e1:	ec17a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
403799e4:	04e265        	call8	4037e80c <__assert_func>
403799e7:	d288      	l32i.n	a8, a2, 52
403799e9:	0b3387        	bltu	a3, a8, 403799f8 <prvReturnItemByteBuf+0x28>
403799ec:	ec45d1        	l32r	a13, 40374b00 <_iram_text_start+0x6fc>
403799ef:	ec43c1        	l32r	a12, 40374afc <_iram_text_start+0x6f8>
403799f2:	9ea2b2        	movi	a11, 0x29e
403799f5:	fffa06        	j	403799e1 <prvReturnItemByteBuf+0x11>
    pxRingbuffer->pucFree = pxRingbuffer->pucRead;
403799f8:	a238      	l32i.n	a3, a2, 40
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
403799fa:	2288      	l32i.n	a8, a2, 8
    pxRingbuffer->pucFree = pxRingbuffer->pucRead;
403799fc:	b239      	s32i.n	a3, a2, 44
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
403799fe:	066827        	bbci	a8, 2, 40379a08 <prvReturnItemByteBuf+0x38>
        pxRingbuffer->uxRingbufferFlags &= ~rbBUFFER_FULL_FLAG;
40379a01:	b37c      	movi.n	a3, -5
40379a03:	108830        	and	a8, a8, a3
40379a06:	2289      	s32i.n	a8, a2, 8
}
40379a08:	f01d      	retw.n
	...

40379a0c <prvGetFreeSize>:
{
40379a0c:	004136        	entry	a1, 32
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379a0f:	2288      	l32i.n	a8, a2, 8
40379a11:	21e827        	bbsi	a8, 2, 40379a36 <prvGetFreeSize+0x2a>
        BaseType_t xFreeSize = pxRingbuffer->pucFree - pxRingbuffer->pucAcquire;
40379a14:	8298      	l32i.n	a9, a2, 32
40379a16:	b288      	l32i.n	a8, a2, 44
40379a18:	c08890        	sub	a8, a8, a9
            xFreeSize += pxRingbuffer->xSize;
40379a1b:	0298      	l32i.n	a9, a2, 0
        if (xFreeSize <= 0) {
40379a1d:	0118e6        	bgei	a8, 1, 40379a22 <prvGetFreeSize+0x16>
            xFreeSize += pxRingbuffer->xSize;
40379a20:	889a      	add.n	a8, a8, a9
        xReturn = xFreeSize;
40379a22:	082d      	mov.n	a2, a8
    configASSERT(xReturn <= pxRingbuffer->xSize);
40379a24:	10b987        	bgeu	a9, a8, 40379a38 <prvGetFreeSize+0x2c>
40379a27:	ec37d1        	l32r	a13, 40374b04 <_iram_text_start+0x700>
40379a2a:	ec37c1        	l32r	a12, 40374b08 <_iram_text_start+0x704>
40379a2d:	ec04a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379a30:	24a1b2        	movi	a11, 0x124
40379a33:	04dda5        	call8	4037e80c <__assert_func>
        xReturn =  0;
40379a36:	020c      	movi.n	a2, 0
}
40379a38:	f01d      	retw.n
	...

40379a3c <xRingbufferCreate>:

/* --------------------------- Public Definitions --------------------------- */

RingbufHandle_t xRingbufferCreate(size_t xBufferSize, RingbufferType_t xBufferType)
{
40379a3c:	004136        	entry	a1, 32
    configASSERT(xBufferSize > 0);
40379a3f:	00e256        	bnez	a2, 40379a51 <xRingbufferCreate+0x15>
40379a42:	ec32d1        	l32r	a13, 40374b0c <_iram_text_start+0x708>
40379a45:	ec32c1        	l32r	a12, 40374b10 <_iram_text_start+0x70c>
40379a48:	6aa3b2        	movi	a11, 0x36a
    configASSERT(xBufferType < RINGBUF_TYPE_MAX);
40379a4b:	ebfda1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379a4e:	04dbe5        	call8	4037e80c <__assert_func>
40379a51:	0c33b6        	bltui	a3, 3, 40379a61 <xRingbufferCreate+0x25>
40379a54:	ec30d1        	l32r	a13, 40374b14 <_iram_text_start+0x710>
40379a57:	ec2ec1        	l32r	a12, 40374b10 <_iram_text_start+0x70c>
40379a5a:	6ba3b2        	movi	a11, 0x36b
40379a5d:	fffa86        	j	40379a4b <xRingbufferCreate+0xf>
40379a60:	00          	.byte 00

    //Allocate memory
    if (xBufferType != RINGBUF_TYPE_BYTEBUF) {
40379a61:	082326        	beqi	a3, 2, 40379a6d <xRingbufferCreate+0x31>
        xBufferSize = rbALIGN_SIZE(xBufferSize);    //xBufferSize is rounded up for no-split/allow-split buffers
40379a64:	03c222        	addi	a2, a2, 3
40379a67:	fcaf42        	movi	a4, -4
40379a6a:	102240        	and	a2, a2, a4
    }
    Ringbuffer_t *pxNewRingbuffer = calloc(1, sizeof(Ringbuffer_t));
40379a6d:	eca0b2        	movi	a11, 236
40379a70:	1a0c      	movi.n	a10, 1
40379a72:	04f165        	call8	4037e988 <calloc>
40379a75:	0a4d      	mov.n	a4, a10
    uint8_t *pucRingbufferStorage = malloc(xBufferSize);
40379a77:	02ad      	mov.n	a10, a2
40379a79:	04e925        	call8	4037e90c <malloc>
    if (pxNewRingbuffer == NULL || pucRingbufferStorage == NULL) {
40379a7c:	160c      	movi.n	a6, 1
40379a7e:	080c      	movi.n	a8, 0
40379a80:	838640        	moveqz	a8, a6, a4
    uint8_t *pucRingbufferStorage = malloc(xBufferSize);
40379a83:	0a7d      	mov.n	a7, a10
    if (pxNewRingbuffer == NULL || pucRingbufferStorage == NULL) {
40379a85:	745080        	extui	a5, a8, 0, 8
40379a88:	38cc      	bnez.n	a8, 40379a8f <xRingbufferCreate+0x53>
40379a8a:	8356a0        	moveqz	a5, a6, a10
40379a8d:	f58c      	beqz.n	a5, 40379aa0 <xRingbufferCreate+0x64>
    prvInitializeNewRingbuffer(xBufferSize, xBufferType, pxNewRingbuffer, pucRingbufferStorage);
    return (RingbufHandle_t)pxNewRingbuffer;

err:
    //An error has occurred, Free memory and return NULL
    free(pxNewRingbuffer);
40379a8f:	04ad      	mov.n	a10, a4
40379a91:	04e9a5        	call8	4037e92c <cfree>
    free(pucRingbufferStorage);
40379a94:	07ad      	mov.n	a10, a7
40379a96:	04e965        	call8	4037e92c <cfree>
    return NULL;
40379a99:	040c      	movi.n	a4, 0
}
40379a9b:	042d      	mov.n	a2, a4
40379a9d:	f01d      	retw.n
40379a9f:	00          	.byte 00
    xSemaphoreCreateBinaryStatic(&(pxNewRingbuffer->xTransSemStatic));
40379aa0:	3cc4d2        	addi	a13, a4, 60
40379aa3:	20c550        	or	a12, a5, a5
40379aa6:	05bd      	mov.n	a11, a5
40379aa8:	3e0c      	movi.n	a14, 3
40379aaa:	06ad      	mov.n	a10, a6
40379aac:	00afe5        	call8	4037a5ac <xQueueGenericCreateStatic>
    xSemaphoreCreateBinaryStatic(&(pxNewRingbuffer->xRecvSemStatic));
40379aaf:	90a0d2        	movi	a13, 144
40379ab2:	d4da      	add.n	a13, a4, a13
40379ab4:	05cd      	mov.n	a12, a5
40379ab6:	05bd      	mov.n	a11, a5
40379ab8:	03a0e2        	movi	a14, 3
40379abb:	20a660        	or	a10, a6, a6
40379abe:	00aee5        	call8	4037a5ac <xQueueGenericCreateStatic>
    prvInitializeNewRingbuffer(xBufferSize, xBufferType, pxNewRingbuffer, pucRingbufferStorage);
40379ac1:	07dd      	mov.n	a13, a7
40379ac3:	04cd      	mov.n	a12, a4
40379ac5:	03bd      	mov.n	a11, a3
40379ac7:	02ad      	mov.n	a10, a2
40379ac9:	ffb665        	call8	40379630 <prvInitializeNewRingbuffer>
    return (RingbufHandle_t)pxNewRingbuffer;
40379acc:	fff2c6        	j	40379a9b <xRingbufferCreate+0x5f>
	...

40379ad0 <xRingbufferSend>:

BaseType_t xRingbufferSend(RingbufHandle_t xRingbuffer,
                           const void *pvItem,
                           size_t xItemSize,
                           TickType_t xTicksToWait)
{
40379ad0:	006136        	entry	a1, 48
40379ad3:	027d      	mov.n	a7, a2
    //Check arguments
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379ad5:	d2cc      	bnez.n	a2, 40379ae6 <xRingbufferSend+0x16>
40379ad7:	ec10d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379ada:	ec10c1        	l32r	a12, 40374b1c <_iram_text_start+0x718>
40379add:	03a4b2        	movi	a11, 0x403
    configASSERT(pvItem != NULL || xItemSize == 0);
40379ae0:	ebd8a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379ae3:	04d2a5        	call8	4037e80c <__assert_func>
40379ae6:	160c      	movi.n	a6, 1
40379ae8:	020c      	movi.n	a2, 0
40379aea:	936240        	movnez	a6, a2, a4
40379aed:	746060        	extui	a6, a6, 0, 8
40379af0:	0e9327        	bne	a3, a2, 40379b02 <xRingbufferSend+0x32>
40379af3:	0b9627        	bne	a6, a2, 40379b02 <xRingbufferSend+0x32>
40379af6:	ec0ad1        	l32r	a13, 40374b20 <_iram_text_start+0x71c>
40379af9:	ec08c1        	l32r	a12, 40374b1c <_iram_text_start+0x718>
40379afc:	04a4b2        	movi	a11, 0x404
40379aff:	fff746        	j	40379ae0 <xRingbufferSend+0x10>
    if (xItemSize > pxRingbuffer->xMaxItemSize) {
40379b02:	012722        	l32i	a2, a7, 4
40379b05:	02b247        	bgeu	a2, a4, 40379b0b <xRingbufferSend+0x3b>
40379b08:	002086        	j	40379b8e <xRingbufferSend+0xbe>
        return pdFALSE;     //Data will never ever fit in the queue.
    }
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && xItemSize == 0) {
40379b0b:	022722        	l32i	a2, a7, 8
40379b0e:	056217        	bbci	a2, 1, 40379b17 <xRingbufferSend+0x47>
        return pdTRUE;      //Sending 0 bytes to byte buffer has no effect
40379b11:	01a022        	movi	a2, 1
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && xItemSize == 0) {
40379b14:	078656        	bnez	a6, 40379b90 <xRingbufferSend+0xc0>
    }

    //Attempt to send an item
    BaseType_t xReturn = pdFALSE;
    BaseType_t xReturnSemaphore = pdFALSE;
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
40379b17:	0181e5        	call8	4037b334 <xTaskGetTickCount>
40379b1a:	aa5a      	add.n	a10, a10, a5
    TickType_t xTicksRemaining = xTicksToWait;
    while (xTicksRemaining <= xTicksToWait) {   //xTicksToWait will underflow once xTaskGetTickCount() > ticks_end
        //Block until more free space becomes available or timeout
        if (xSemaphoreTake(rbGET_TX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
40379b1c:	3cc722        	addi	a2, a7, 60
            xReturn = pdFALSE;
            break;
        }
        //Semaphore obtained, check if item can fit
        portENTER_CRITICAL(&pxRingbuffer->mux);
40379b1f:	e4a062        	movi	a6, 228
    TickType_t xTicksEnd = xTaskGetTickCount() + xTicksToWait;
40379b22:	21a9      	s32i.n	a10, a1, 8
40379b24:	0159      	s32i.n	a5, a1, 0
        if (xSemaphoreTake(rbGET_TX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
40379b26:	1129      	s32i.n	a2, a1, 4
        portENTER_CRITICAL(&pxRingbuffer->mux);
40379b28:	676a      	add.n	a6, a7, a6
        if (xSemaphoreTake(rbGET_TX_SEM_HANDLE(pxRingbuffer), xTicksRemaining) != pdTRUE) {
40379b2a:	01b8      	l32i.n	a11, a1, 0
40379b2c:	11a8      	l32i.n	a10, a1, 4
40379b2e:	00fa25        	call8	4037aad0 <xQueueSemaphoreTake>
40379b31:	591a66        	bnei	a10, 1, 40379b8e <xRingbufferSend+0xbe>
40379b34:	fb7c      	movi.n	a11, -1
40379b36:	06ad      	mov.n	a10, a6
40379b38:	02a765        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if(pxRingbuffer->xCheckItemFits(pxRingbuffer, xItemSize) == pdTRUE) {
40379b3b:	3798      	l32i.n	a9, a7, 12
40379b3d:	04bd      	mov.n	a11, a4
40379b3f:	07ad      	mov.n	a10, a7
40379b41:	0009e0        	callx8	a9
40379b44:	0a2d      	mov.n	a2, a10
40379b46:	291a66        	bnei	a10, 1, 40379b73 <xRingbufferSend+0xa3>
            //Item will fit, copy item
            pxRingbuffer->vCopyItem(pxRingbuffer, pvItem, xItemSize);
40379b49:	4758      	l32i.n	a5, a7, 16
40379b4b:	03bd      	mov.n	a11, a3
40379b4d:	04cd      	mov.n	a12, a4
40379b4f:	07ad      	mov.n	a10, a7
40379b51:	0005e0        	callx8	a5
            xReturn = pdTRUE;
            //Check if the free semaphore should be returned to allow other tasks to send
            if (prvGetFreeSize(pxRingbuffer) > 0) {
40379b54:	07ad      	mov.n	a10, a7
40379b56:	ffeb65        	call8	40379a0c <prvGetFreeSize>
40379b59:	0a3d      	mov.n	a3, a10
                xReturnSemaphore = pdTRUE;
            }
            portEXIT_CRITICAL(&pxRingbuffer->mux);
40379b5b:	06ad      	mov.n	a10, a6
40379b5d:	02b865        	call8	4037c6e4 <vPortExitCritical>
         * Gap between critical section and re-acquiring of the semaphore. If
         * semaphore is given now, priority inversion might occur (see docs)
         */
    }

    if (xReturnSemaphore == pdTRUE) {
40379b60:	e3ec      	bnez.n	a3, 40379b92 <xRingbufferSend+0xc2>
        xSemaphoreGive(rbGET_TX_SEM_HANDLE(pxRingbuffer));  //Give back semaphore so other tasks can send
    }
    if (xReturn == pdTRUE) {
        //Indicate item was successfully sent
        xSemaphoreGive(rbGET_RX_SEM_HANDLE(pxRingbuffer));
40379b62:	0d0c      	movi.n	a13, 0
40379b64:	90a0a2        	movi	a10, 144
40379b67:	0dcd      	mov.n	a12, a13
40379b69:	0dbd      	mov.n	a11, a13
40379b6b:	a7aa      	add.n	a10, a7, a10
40379b6d:	00b7e5        	call8	4037a6ec <xQueueGenericSend>
40379b70:	000706        	j	40379b90 <xRingbufferSend+0xc0>
        if (xTicksToWait != portMAX_DELAY) {
40379b73:	0a0526        	beqi	a5, -1, 40379b81 <xRingbufferSend+0xb1>
            xTicksRemaining = xTicksEnd - xTaskGetTickCount();
40379b76:	017be5        	call8	4037b334 <xTaskGetTickCount>
40379b79:	2128      	l32i.n	a2, a1, 8
40379b7b:	c0a2a0        	sub	a10, a2, a10
40379b7e:	0061a2        	s32i	a10, a1, 0
        portEXIT_CRITICAL(&pxRingbuffer->mux);
40379b81:	06ad      	mov.n	a10, a6
40379b83:	201110        	or	a1, a1, a1
40379b86:	02b5e5        	call8	4037c6e4 <vPortExitCritical>
    while (xTicksRemaining <= xTicksToWait) {   //xTicksToWait will underflow once xTaskGetTickCount() > ticks_end
40379b89:	0128      	l32i.n	a2, a1, 0
40379b8b:	9bb527        	bgeu	a5, a2, 40379b2a <xRingbufferSend+0x5a>
    if (xReturn == pdTRUE) {
40379b8e:	020c      	movi.n	a2, 0
    }
    return xReturn;
}
40379b90:	f01d      	retw.n
        xSemaphoreGive(rbGET_TX_SEM_HANDLE(pxRingbuffer));  //Give back semaphore so other tasks can send
40379b92:	00a0d2        	movi	a13, 0
40379b95:	0121a2        	l32i	a10, a1, 4
40379b98:	20cdd0        	or	a12, a13, a13
40379b9b:	0dbd      	mov.n	a11, a13
40379b9d:	00b4e5        	call8	4037a6ec <xQueueGenericSend>
    if (xReturn == pdTRUE) {
40379ba0:	ffef86        	j	40379b62 <xRingbufferSend+0x92>
	...

40379ba4 <xRingbufferSendFromISR>:

BaseType_t xRingbufferSendFromISR(RingbufHandle_t xRingbuffer,
                                  const void *pvItem,
                                  size_t xItemSize,
                                  BaseType_t *pxHigherPriorityTaskWoken)
{
40379ba4:	004136        	entry	a1, 32
    //Check arguments
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379ba7:	00e256        	bnez	a2, 40379bb9 <xRingbufferSendFromISR+0x15>
40379baa:	ebdbd1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379bad:	ebddc1        	l32r	a12, 40374b24 <_iram_text_start+0x720>
40379bb0:	40a4b2        	movi	a11, 0x440
    configASSERT(pvItem != NULL || xItemSize == 0);
40379bb3:	eba3a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379bb6:	04c565        	call8	4037e80c <__assert_func>
40379bb9:	180c      	movi.n	a8, 1
40379bbb:	060c      	movi.n	a6, 0
40379bbd:	938640        	movnez	a8, a6, a4
40379bc0:	748080        	extui	a8, a8, 0, 8
40379bc3:	0e9367        	bne	a3, a6, 40379bd5 <xRingbufferSendFromISR+0x31>
40379bc6:	0b9867        	bne	a8, a6, 40379bd5 <xRingbufferSendFromISR+0x31>
40379bc9:	ebd5d1        	l32r	a13, 40374b20 <_iram_text_start+0x71c>
40379bcc:	ebd6c1        	l32r	a12, 40374b24 <_iram_text_start+0x720>
40379bcf:	41a4b2        	movi	a11, 0x441
40379bd2:	fff746        	j	40379bb3 <xRingbufferSendFromISR+0xf>
    if (xItemSize > pxRingbuffer->xMaxItemSize) {
40379bd5:	1268      	l32i.n	a6, a2, 4
40379bd7:	07b647        	bgeu	a6, a4, 40379be2 <xRingbufferSendFromISR+0x3e>
        return pdFALSE;     //Data will never ever fit in the queue.
40379bda:	060c      	movi.n	a6, 0
    if (xReturn == pdTRUE) {
        //Indicate item was successfully sent
        xSemaphoreGiveFromISR(rbGET_RX_SEM_HANDLE(pxRingbuffer), pxHigherPriorityTaskWoken);
    }
    return xReturn;
}
40379bdc:	062d      	mov.n	a2, a6
40379bde:	f01d      	retw.n
40379be0:	00          	.byte 00
40379be1:	00          	.byte 00
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && xItemSize == 0) {
40379be2:	2268      	l32i.n	a6, a2, 8
40379be4:	046617        	bbci	a6, 1, 40379bec <xRingbufferSendFromISR+0x48>
        return pdTRUE;      //Sending 0 bytes to byte buffer has no effect
40379be7:	160c      	movi.n	a6, 1
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && xItemSize == 0) {
40379be9:	fef856        	bnez	a8, 40379bdc <xRingbufferSendFromISR+0x38>
    portENTER_CRITICAL_ISR(&pxRingbuffer->mux);
40379bec:	e4a072        	movi	a7, 228
40379bef:	727a      	add.n	a7, a2, a7
40379bf1:	fb7c      	movi.n	a11, -1
40379bf3:	07ad      	mov.n	a10, a7
40379bf5:	029ba5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if (pxRingbuffer->xCheckItemFits(xRingbuffer, xItemSize) == pdTRUE) {
40379bf8:	3268      	l32i.n	a6, a2, 12
40379bfa:	04bd      	mov.n	a11, a4
40379bfc:	02ad      	mov.n	a10, a2
40379bfe:	0006e0        	callx8	a6
40379c01:	0a6d      	mov.n	a6, a10
40379c03:	351a66        	bnei	a10, 1, 40379c3c <xRingbufferSendFromISR+0x98>
        pxRingbuffer->vCopyItem(xRingbuffer, pvItem, xItemSize);
40379c06:	4288      	l32i.n	a8, a2, 16
40379c08:	03bd      	mov.n	a11, a3
40379c0a:	04cd      	mov.n	a12, a4
40379c0c:	02ad      	mov.n	a10, a2
40379c0e:	0008e0        	callx8	a8
        if (prvGetFreeSize(pxRingbuffer) > 0) {
40379c11:	02ad      	mov.n	a10, a2
40379c13:	ffdfa5        	call8	40379a0c <prvGetFreeSize>
40379c16:	030c      	movi.n	a3, 0
40379c18:	9336a0        	movnez	a3, a6, a10
    portEXIT_CRITICAL_ISR(&pxRingbuffer->mux);
40379c1b:	07ad      	mov.n	a10, a7
40379c1d:	02ac65        	call8	4037c6e4 <vPortExitCritical>
    if (xReturnSemaphore == pdTRUE) {
40379c20:	071366        	bnei	a3, 1, 40379c2b <xRingbufferSendFromISR+0x87>
        xSemaphoreGiveFromISR(rbGET_TX_SEM_HANDLE(pxRingbuffer), pxHigherPriorityTaskWoken);  //Give back semaphore so other tasks can send
40379c23:	05bd      	mov.n	a11, a5
40379c25:	3cc2a2        	addi	a10, a2, 60
40379c28:	00dd25        	call8	4037a9fc <xQueueGiveFromISR>
    if (xReturn == pdTRUE) {
40379c2b:	ab1666        	bnei	a6, 1, 40379bda <xRingbufferSendFromISR+0x36>
        xSemaphoreGiveFromISR(rbGET_RX_SEM_HANDLE(pxRingbuffer), pxHigherPriorityTaskWoken);
40379c2e:	90a0a2        	movi	a10, 144
40379c31:	05bd      	mov.n	a11, a5
40379c33:	a2aa      	add.n	a10, a2, a10
40379c35:	00dc65        	call8	4037a9fc <xQueueGiveFromISR>
40379c38:	ffe806        	j	40379bdc <xRingbufferSendFromISR+0x38>
40379c3b:	00          	.byte 00
    BaseType_t xReturnSemaphore = pdFALSE;
40379c3c:	030c      	movi.n	a3, 0
        xReturn = pdFALSE;
40379c3e:	036d      	mov.n	a6, a3
40379c40:	fff5c6        	j	40379c1b <xRingbufferSendFromISR+0x77>
	...

40379c44 <xRingbufferReceive>:

void *xRingbufferReceive(RingbufHandle_t xRingbuffer, size_t *pxItemSize, TickType_t xTicksToWait)
{
40379c44:	008136        	entry	a1, 64
    //Check arguments
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379c47:	00e256        	bnez	a2, 40379c59 <xRingbufferReceive+0x15>
40379c4a:	ebb3d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379c4d:	ebb6c1        	l32r	a12, 40374b28 <_iram_text_start+0x724>
40379c50:	eb7ca1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379c53:	67a4b2        	movi	a11, 0x467
40379c56:	04bb65        	call8	4037e80c <__assert_func>

    //Attempt to retrieve an item
    void *pvTempItem;
    size_t xTempSize;
    if (prvReceiveGeneric(pxRingbuffer, &pvTempItem, NULL, &xTempSize, NULL, 0, xTicksToWait) == pdTRUE) {
40379c59:	0f0c      	movi.n	a15, 0
40379c5b:	20a220        	or	a10, a2, a2
40379c5e:	006142        	s32i	a4, a1, 0
40379c61:	0fed      	mov.n	a14, a15
40379c63:	10c1d2        	addi	a13, a1, 16
40379c66:	0fcd      	mov.n	a12, a15
40379c68:	14c1b2        	addi	a11, a1, 20
40379c6b:	ffbb65        	call8	40379820 <prvReceiveGeneric>
        if (pxItemSize != NULL) {
            *pxItemSize = xTempSize;
        }
        return pvTempItem;
    } else {
        return NULL;
40379c6e:	020c      	movi.n	a2, 0
    if (prvReceiveGeneric(pxRingbuffer, &pvTempItem, NULL, &xTempSize, NULL, 0, xTicksToWait) == pdTRUE) {
40379c70:	081a66        	bnei	a10, 1, 40379c7c <xRingbufferReceive+0x38>
        if (pxItemSize != NULL) {
40379c73:	031327        	beq	a3, a2, 40379c7a <xRingbufferReceive+0x36>
            *pxItemSize = xTempSize;
40379c76:	4128      	l32i.n	a2, a1, 16
40379c78:	0329      	s32i.n	a2, a3, 0
        return pvTempItem;
40379c7a:	5128      	l32i.n	a2, a1, 20
    }
}
40379c7c:	f01d      	retw.n
	...

40379c80 <xRingbufferReceiveFromISR>:

void *xRingbufferReceiveFromISR(RingbufHandle_t xRingbuffer, size_t *pxItemSize)
{
40379c80:	006136        	entry	a1, 48
    //Check arguments
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379c83:	00e256        	bnez	a2, 40379c95 <xRingbufferReceiveFromISR+0x15>
40379c86:	eba4d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379c89:	eba8c1        	l32r	a12, 40374b2c <_iram_text_start+0x728>
40379c8c:	eb6da1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379c8f:	7aa4b2        	movi	a11, 0x47a
40379c92:	04b7a5        	call8	4037e80c <__assert_func>

    //Attempt to retrieve an item
    void *pvTempItem;
    size_t xTempSize;
    if (prvReceiveGenericFromISR(pxRingbuffer, &pvTempItem, NULL, &xTempSize, NULL, 0) == pdTRUE) {
40379c95:	0f0c      	movi.n	a15, 0
40379c97:	20a220        	or	a10, a2, a2
40379c9a:	20eff0        	or	a14, a15, a15
40379c9d:	01dd      	mov.n	a13, a1
40379c9f:	0fcd      	mov.n	a12, a15
40379ca1:	b14b      	addi.n	a11, a1, 4
40379ca3:	ffc765        	call8	40379918 <prvReceiveGenericFromISR>
        if (pxItemSize != NULL) {
            *pxItemSize = xTempSize;
        }
        return pvTempItem;
    } else {
        return NULL;
40379ca6:	020c      	movi.n	a2, 0
    if (prvReceiveGenericFromISR(pxRingbuffer, &pvTempItem, NULL, &xTempSize, NULL, 0) == pdTRUE) {
40379ca8:	081a66        	bnei	a10, 1, 40379cb4 <xRingbufferReceiveFromISR+0x34>
        if (pxItemSize != NULL) {
40379cab:	031327        	beq	a3, a2, 40379cb2 <xRingbufferReceiveFromISR+0x32>
            *pxItemSize = xTempSize;
40379cae:	0128      	l32i.n	a2, a1, 0
40379cb0:	0329      	s32i.n	a2, a3, 0
        return pvTempItem;
40379cb2:	1128      	l32i.n	a2, a1, 4
    }
}
40379cb4:	f01d      	retw.n
	...

40379cb8 <vRingbufferReturnItem>:
        return NULL;
    }
}

void vRingbufferReturnItem(RingbufHandle_t xRingbuffer, void *pvItem)
{
40379cb8:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379cbb:	00e256        	bnez	a2, 40379ccd <vRingbufferReturnItem+0x15>
40379cbe:	eb96d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379cc1:	eb9bc1        	l32r	a12, 40374b30 <_iram_text_start+0x72c>
40379cc4:	0ba5b2        	movi	a11, 0x50b
    configASSERT(pvItem != NULL);
40379cc7:	eb5ea1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379cca:	04b425        	call8	4037e80c <__assert_func>
40379ccd:	c3cc      	bnez.n	a3, 40379cdd <vRingbufferReturnItem+0x25>
40379ccf:	eb99d1        	l32r	a13, 40374b34 <_iram_text_start+0x730>
40379cd2:	eb97c1        	l32r	a12, 40374b30 <_iram_text_start+0x72c>
40379cd5:	0ca5b2        	movi	a11, 0x50c
40379cd8:	fffac6        	j	40379cc7 <vRingbufferReturnItem+0xf>
40379cdb:	00          	.byte 00
40379cdc:	00          	.byte 00

    portENTER_CRITICAL(&pxRingbuffer->mux);
40379cdd:	e4a042        	movi	a4, 228
40379ce0:	804240        	add	a4, a2, a4
40379ce3:	fb7c      	movi.n	a11, -1
40379ce5:	04ad      	mov.n	a10, a4
40379ce7:	028ca5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    pxRingbuffer->vReturnItem(pxRingbuffer, (uint8_t *)pvItem);
40379cea:	6288      	l32i.n	a8, a2, 24
40379cec:	03bd      	mov.n	a11, a3
40379cee:	02ad      	mov.n	a10, a2
40379cf0:	0008e0        	callx8	a8
    portEXIT_CRITICAL(&pxRingbuffer->mux);
40379cf3:	04ad      	mov.n	a10, a4
40379cf5:	029ee5        	call8	4037c6e4 <vPortExitCritical>
    xSemaphoreGive(rbGET_TX_SEM_HANDLE(pxRingbuffer));
40379cf8:	0d0c      	movi.n	a13, 0
40379cfa:	0dcd      	mov.n	a12, a13
40379cfc:	0dbd      	mov.n	a11, a13
40379cfe:	3cc2a2        	addi	a10, a2, 60
40379d01:	009ea5        	call8	4037a6ec <xQueueGenericSend>
}
40379d04:	f01d      	retw.n
	...

40379d08 <vRingbufferReturnItemFromISR>:

void vRingbufferReturnItemFromISR(RingbufHandle_t xRingbuffer, void *pvItem, BaseType_t *pxHigherPriorityTaskWoken)
{
40379d08:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379d0b:	00e256        	bnez	a2, 40379d1d <vRingbufferReturnItemFromISR+0x15>
40379d0e:	eb82d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379d11:	eb89c1        	l32r	a12, 40374b38 <_iram_text_start+0x734>
40379d14:	17a5b2        	movi	a11, 0x517
    configASSERT(pvItem != NULL);
40379d17:	eb4aa1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379d1a:	04af25        	call8	4037e80c <__assert_func>
40379d1d:	c3cc      	bnez.n	a3, 40379d2d <vRingbufferReturnItemFromISR+0x25>
40379d1f:	eb85d1        	l32r	a13, 40374b34 <_iram_text_start+0x730>
40379d22:	eb85c1        	l32r	a12, 40374b38 <_iram_text_start+0x734>
40379d25:	18a5b2        	movi	a11, 0x518
40379d28:	fffac6        	j	40379d17 <vRingbufferReturnItemFromISR+0xf>
40379d2b:	00          	.byte 00
40379d2c:	00          	.byte 00

    portENTER_CRITICAL_ISR(&pxRingbuffer->mux);
40379d2d:	e4a052        	movi	a5, 228
40379d30:	805250        	add	a5, a2, a5
40379d33:	fb7c      	movi.n	a11, -1
40379d35:	05ad      	mov.n	a10, a5
40379d37:	0287a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    pxRingbuffer->vReturnItem(pxRingbuffer, (uint8_t *)pvItem);
40379d3a:	6288      	l32i.n	a8, a2, 24
40379d3c:	03bd      	mov.n	a11, a3
40379d3e:	02ad      	mov.n	a10, a2
40379d40:	0008e0        	callx8	a8
    portEXIT_CRITICAL_ISR(&pxRingbuffer->mux);
40379d43:	05ad      	mov.n	a10, a5
40379d45:	0299e5        	call8	4037c6e4 <vPortExitCritical>
    xSemaphoreGiveFromISR(rbGET_TX_SEM_HANDLE(pxRingbuffer), pxHigherPriorityTaskWoken);
40379d48:	04bd      	mov.n	a11, a4
40379d4a:	3cc2a2        	addi	a10, a2, 60
40379d4d:	00cae5        	call8	4037a9fc <xQueueGiveFromISR>
}
40379d50:	f01d      	retw.n
	...

40379d54 <vRingbufferDelete>:

void vRingbufferDelete(RingbufHandle_t xRingbuffer)
{
40379d54:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379d57:	00e256        	bnez	a2, 40379d69 <vRingbufferDelete+0x15>
40379d5a:	eb6fd1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379d5d:	eb77c1        	l32r	a12, 40374b3c <_iram_text_start+0x738>
40379d60:	eb38a1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379d63:	23a5b2        	movi	a11, 0x523
40379d66:	04aa65        	call8	4037e80c <__assert_func>

    vSemaphoreDelete(rbGET_TX_SEM_HANDLE(pxRingbuffer));
40379d69:	3cc2a2        	addi	a10, a2, 60
40379d6c:	00fd25        	call8	4037ad40 <vQueueDelete>
    vSemaphoreDelete(rbGET_RX_SEM_HANDLE(pxRingbuffer));
40379d6f:	90a0a2        	movi	a10, 144
40379d72:	a2aa      	add.n	a10, a2, a10
40379d74:	00fca5        	call8	4037ad40 <vQueueDelete>

#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_STATIC_FLAG) {
40379d77:	2288      	l32i.n	a8, a2, 8
40379d79:	09e837        	bbsi	a8, 3, 40379d86 <vRingbufferDelete+0x32>
        //Ring buffer was statically allocated, no need to free
        return;
    }
#endif
    free(pxRingbuffer->pucHead);
40379d7c:	c2a8      	l32i.n	a10, a2, 48
40379d7e:	04bae5        	call8	4037e92c <cfree>
    free(pxRingbuffer);
40379d81:	02ad      	mov.n	a10, a2
40379d83:	04baa5        	call8	4037e92c <cfree>
}
40379d86:	f01d      	retw.n

40379d88 <xRingbufferGetMaxItemSize>:

size_t xRingbufferGetMaxItemSize(RingbufHandle_t xRingbuffer)
{
40379d88:	004136        	entry	a1, 32
    Ringbuffer_t *pxRingbuffer = (Ringbuffer_t *)xRingbuffer;
    configASSERT(pxRingbuffer);
40379d8b:	00e256        	bnez	a2, 40379d9d <xRingbufferGetMaxItemSize+0x15>
40379d8e:	eb62d1        	l32r	a13, 40374b18 <_iram_text_start+0x714>
40379d91:	eb6bc1        	l32r	a12, 40374b40 <_iram_text_start+0x73c>
40379d94:	eb2ba1        	l32r	a10, 40374a40 <_iram_text_start+0x63c>
40379d97:	35a5b2        	movi	a11, 0x535
40379d9a:	04a725        	call8	4037e80c <__assert_func>
    return pxRingbuffer->xMaxItemSize;
}
40379d9d:	1228      	l32i.n	a2, a2, 4
40379d9f:	f01d      	retw.n
40379da1:	000000        	ill

40379da4 <prvCheckItemAvail>:
{
40379da4:	004136        	entry	a1, 32
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && pxRingbuffer->pucRead != pxRingbuffer->pucFree) {
40379da7:	2298      	l32i.n	a9, a2, 8
{
40379da9:	028d      	mov.n	a8, a2
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && pxRingbuffer->pucRead != pxRingbuffer->pucFree) {
40379dab:	096917        	bbci	a9, 1, 40379db8 <prvCheckItemAvail+0x14>
40379dae:	a2b8      	l32i.n	a11, a2, 40
40379db0:	b2a8      	l32i.n	a10, a2, 44
        return pdFALSE;     //No items/data available for retrieval
40379db2:	00a022        	movi	a2, 0
    if ((pxRingbuffer->uxRingbufferFlags & rbBYTE_BUFFER_FLAG) && pxRingbuffer->pucRead != pxRingbuffer->pucFree) {
40379db5:	139ba7        	bne	a11, a10, 40379dcc <prvCheckItemAvail+0x28>
    if ((pxRingbuffer->xItemsWaiting > 0) && ((pxRingbuffer->pucRead != pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG))) {
40379db8:	e8a8      	l32i.n	a10, a8, 56
        return pdFALSE;     //No items/data available for retrieval
40379dba:	020c      	movi.n	a2, 0
    if ((pxRingbuffer->xItemsWaiting > 0) && ((pxRingbuffer->pucRead != pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG))) {
40379dbc:	0c1aa6        	blti	a10, 1, 40379dcc <prvCheckItemAvail+0x28>
40379dbf:	a8a8      	l32i.n	a10, a8, 40
40379dc1:	9888      	l32i.n	a8, a8, 36
        return pdTRUE;      //Items/data available for retrieval
40379dc3:	01a022        	movi	a2, 1
    if ((pxRingbuffer->xItemsWaiting > 0) && ((pxRingbuffer->pucRead != pxRingbuffer->pucWrite) || (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG))) {
40379dc6:	029a87        	bne	a10, a8, 40379dcc <prvCheckItemAvail+0x28>
40379dc9:	042290        	extui	a2, a9, 2, 1
}
40379dcc:	f01d      	retw.n
	...

40379dd0 <prvGetCurMaxSizeNoSplit>:
{
40379dd0:	004136        	entry	a1, 32
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379dd3:	2298      	l32i.n	a9, a2, 8
        return 0;
40379dd5:	080c      	movi.n	a8, 0
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379dd7:	21e927        	bbsi	a9, 2, 40379dfc <prvGetCurMaxSizeNoSplit+0x2c>
    if (pxRingbuffer->pucAcquire < pxRingbuffer->pucFree) {
40379dda:	82a8      	l32i.n	a10, a2, 32
40379ddc:	b298      	l32i.n	a9, a2, 44
        xFreeSize = pxRingbuffer->pucFree - pxRingbuffer->pucAcquire;
40379dde:	c089a0        	sub	a8, a9, a10
    if (pxRingbuffer->pucAcquire < pxRingbuffer->pucFree) {
40379de1:	0c3a97        	bltu	a10, a9, 40379df1 <prvGetCurMaxSizeNoSplit+0x21>
        size_t xSize1 = pxRingbuffer->pucTail - pxRingbuffer->pucAcquire;
40379de4:	d288      	l32i.n	a8, a2, 52
40379de6:	c088a0        	sub	a8, a8, a10
        size_t xSize2 = pxRingbuffer->pucFree - pxRingbuffer->pucHead;
40379de9:	c2a8      	l32i.n	a10, a2, 48
40379deb:	c099a0        	sub	a9, a9, a10
        xFreeSize = (xSize1 > xSize2) ? xSize1 : xSize2;
40379dee:	738890        	maxu	a8, a8, a9
    xFreeSize -= rbHEADER_SIZE;
40379df1:	f8c882        	addi	a8, a8, -8
    if (xFreeSize < 0) {
40379df4:	008896        	bltz	a8, 40379e00 <prvGetCurMaxSizeNoSplit+0x30>
    } else if (xFreeSize > pxRingbuffer->xMaxItemSize) {
40379df7:	1228      	l32i.n	a2, a2, 4
        xFreeSize = pxRingbuffer->xMaxItemSize;
40379df9:	638820        	minu	a8, a8, a2
}
40379dfc:	082d      	mov.n	a2, a8
40379dfe:	f01d      	retw.n
        xFreeSize = 0;
40379e00:	080c      	movi.n	a8, 0
    return xFreeSize;
40379e02:	fffd86        	j	40379dfc <prvGetCurMaxSizeNoSplit+0x2c>
40379e05:	000000        	ill

40379e08 <prvGetCurMaxSizeAllowSplit>:
{
40379e08:	004136        	entry	a1, 32
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379e0b:	2298      	l32i.n	a9, a2, 8
        return 0;
40379e0d:	080c      	movi.n	a8, 0
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379e0f:	19e927        	bbsi	a9, 2, 40379e2c <prvGetCurMaxSizeAllowSplit+0x24>
    if (pxRingbuffer->pucAcquire == pxRingbuffer->pucHead && pxRingbuffer->pucFree == pxRingbuffer->pucHead) {
40379e12:	82a8      	l32i.n	a10, a2, 32
40379e14:	c2b8      	l32i.n	a11, a2, 48
40379e16:	b298      	l32i.n	a9, a2, 44
40379e18:	149ab7        	bne	a10, a11, 40379e30 <prvGetCurMaxSizeAllowSplit+0x28>
40379e1b:	119a97        	bne	a10, a9, 40379e30 <prvGetCurMaxSizeAllowSplit+0x28>
        xFreeSize = pxRingbuffer->xSize - rbHEADER_SIZE;
40379e1e:	0288      	l32i.n	a8, a2, 0
40379e20:	f8c882        	addi	a8, a8, -8
    if (xFreeSize < 0) {
40379e23:	025896        	bltz	a8, 40379e4c <prvGetCurMaxSizeAllowSplit+0x44>
    } else if (xFreeSize > pxRingbuffer->xMaxItemSize) {
40379e26:	012222        	l32i	a2, a2, 4
        xFreeSize = pxRingbuffer->xMaxItemSize;
40379e29:	638820        	minu	a8, a8, a2
}
40379e2c:	082d      	mov.n	a2, a8
40379e2e:	f01d      	retw.n
    } else if (pxRingbuffer->pucAcquire < pxRingbuffer->pucFree) {
40379e30:	08ba97        	bgeu	a10, a9, 40379e3c <prvGetCurMaxSizeAllowSplit+0x34>
        xFreeSize = (pxRingbuffer->pucFree - pxRingbuffer->pucAcquire) - rbHEADER_SIZE;
40379e33:	c099a0        	sub	a9, a9, a10
40379e36:	f8c982        	addi	a8, a9, -8
40379e39:	fff986        	j	40379e23 <prvGetCurMaxSizeAllowSplit+0x1b>
                    (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire) -
40379e3c:	d288      	l32i.n	a8, a2, 52
        xFreeSize = (pxRingbuffer->pucFree - pxRingbuffer->pucHead) +
40379e3e:	c099b0        	sub	a9, a9, a11
                    (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire) -
40379e41:	c088a0        	sub	a8, a8, a10
        xFreeSize = (pxRingbuffer->pucFree - pxRingbuffer->pucHead) +
40379e44:	889a      	add.n	a8, a8, a9
                    (pxRingbuffer->pucTail - pxRingbuffer->pucAcquire) -
40379e46:	f0c882        	addi	a8, a8, -16
40379e49:	fff586        	j	40379e23 <prvGetCurMaxSizeAllowSplit+0x1b>
        xFreeSize = 0;
40379e4c:	080c      	movi.n	a8, 0
    return xFreeSize;
40379e4e:	fff686        	j	40379e2c <prvGetCurMaxSizeAllowSplit+0x24>
40379e51:	000000        	ill

40379e54 <prvGetCurMaxSizeByteBuf>:
{
40379e54:	004136        	entry	a1, 32
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379e57:	2298      	l32i.n	a9, a2, 8
        return 0;
40379e59:	080c      	movi.n	a8, 0
    if (pxRingbuffer->uxRingbufferFlags & rbBUFFER_FULL_FLAG) {
40379e5b:	0de927        	bbsi	a9, 2, 40379e6c <prvGetCurMaxSizeByteBuf+0x18>
    xFreeSize = pxRingbuffer->pucFree - pxRingbuffer->pucAcquire;
40379e5e:	b288      	l32i.n	a8, a2, 44
40379e60:	8298      	l32i.n	a9, a2, 32
40379e62:	c08890        	sub	a8, a8, a9
    if (xFreeSize <= 0) {
40379e65:	0318e6        	bgei	a8, 1, 40379e6c <prvGetCurMaxSizeByteBuf+0x18>
        xFreeSize += pxRingbuffer->xSize;
40379e68:	0228      	l32i.n	a2, a2, 0
40379e6a:	882a      	add.n	a8, a8, a2
}
40379e6c:	082d      	mov.n	a2, a8
40379e6e:	f01d      	retw.n

40379e70 <esp_error_check_failed_print>:
        return return_address;
    }
#endif

static void esp_error_check_failed_print(const char *msg, esp_err_t rc, const char *file, int line, const char *function, const char *expression, intptr_t addr)
{
40379e70:	004136        	entry	a1, 32
    esp_rom_printf("%s failed: esp_err_t 0x%x", msg, rc);
40379e73:	eb34a1        	l32r	a10, 40374b44 <_iram_text_start+0x740>
40379e76:	03cd      	mov.n	a12, a3
40379e78:	02bd      	mov.n	a11, a2
40379e7a:	e9a981        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40379e7d:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" (%s)", esp_err_to_name(rc));
40379e80:	20a330        	or	a10, a3, a3
40379e83:	eb3481        	l32r	a8, 40374b54 <_iram_text_start+0x750>
40379e86:	0008e0        	callx8	a8
40379e89:	20baa0        	or	a11, a10, a10
40379e8c:	eb2fa1        	l32r	a10, 40374b48 <_iram_text_start+0x744>
40379e8f:	e9a481        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40379e92:	0008e0        	callx8	a8
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP
    esp_rom_printf(" at 0x%08x\n", esp_cpu_get_call_addr(addr));
40379e95:	81b8      	l32i.n	a11, a1, 32
40379e97:	eb2da1        	l32r	a10, 40374b4c <_iram_text_start+0x748>
40379e9a:	fdcbb2        	addi	a11, a11, -3
40379e9d:	e9a081        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40379ea0:	0008e0        	callx8	a8
    if (spi_flash_cache_enabled()) { // strings may be in flash cache
40379ea3:	fd88a5        	call8	4037772c <spi_flash_cache_enabled>
40379ea6:	fa8c      	beqz.n	a10, 40379eb9 <esp_error_check_failed_print+0x49>
        esp_rom_printf("file: \"%s\" line %d\nfunc: %s\nexpression: %s\n", file, line, function, expression);
40379ea8:	eb2aa1        	l32r	a10, 40374b50 <_iram_text_start+0x74c>
40379eab:	07ed      	mov.n	a14, a7
40379ead:	06dd      	mov.n	a13, a6
40379eaf:	05cd      	mov.n	a12, a5
40379eb1:	04bd      	mov.n	a11, a4
40379eb3:	e99b81        	l32r	a8, 40374520 <_iram_text_start+0x11c>
40379eb6:	0008e0        	callx8	a8
    }
}
40379eb9:	f01d      	retw.n
	...

40379ebc <_esp_error_check_failed>:
{
    esp_error_check_failed_print("ESP_ERROR_CHECK_WITHOUT_ABORT", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
}

void _esp_error_check_failed(esp_err_t rc, const char *file, int line, const char *function, const char *expression)
{
40379ebc:	006136        	entry	a1, 48
    esp_error_check_failed_print("ESP_ERROR_CHECK", rc, file, line, function, expression, (intptr_t)__builtin_return_address(0));
40379ebf:	eb2691        	l32r	a9, 40374b58 <_iram_text_start+0x754>
40379ec2:	1180e0        	slli	a8, a0, 2
40379ec5:	159e90        	extui	a9, a9, 30, 2
40379ec8:	019920        	slli	a9, a9, 30
40379ecb:	418280        	srli	a8, a8, 2
40379ece:	208890        	or	a8, a8, a9
40379ed1:	eb22a1        	l32r	a10, 40374b5c <_iram_text_start+0x758>
40379ed4:	0189      	s32i.n	a8, a1, 0
40379ed6:	06fd      	mov.n	a15, a6
40379ed8:	05ed      	mov.n	a14, a5
40379eda:	04dd      	mov.n	a13, a4
40379edc:	03cd      	mov.n	a12, a3
40379ede:	02bd      	mov.n	a11, a2
40379ee0:	fff8e5        	call8	40379e70 <esp_error_check_failed_print>
    abort();
40379ee3:	0489a5        	call8	4037e77c <abort>
	...

40379ee8 <esp_system_abort>:
{
    return IDF_VER;
}

void __attribute__((noreturn)) esp_system_abort(const char *details)
{
40379ee8:	004136        	entry	a1, 32
    panic_abort(details);
40379eeb:	02ad      	mov.n	a10, a2
40379eed:	fbc425        	call8	40375b30 <panic_abort>

40379ef0 <__ubsan_include>:
    __ubsan_default_handler(&data->loc, __func__);
}

/* Hook for the linker to include this object file */
void __ubsan_include(void)
{
40379ef0:	004136        	entry	a1, 32
}
40379ef3:	f01d      	retw.n
40379ef5:	000000        	ill

40379ef8 <_frxt_setup_switch>:
    .global     _frxt_setup_switch
    .type       _frxt_setup_switch,@function
    .align      4
_frxt_setup_switch:

    ENTRY(16)
40379ef8:	002136        	entry	a1, 16

    getcoreid a3
40379efb:	03eb30        	rsr.prid	a3
40379efe:	043d30        	extui	a3, a3, 13, 1
    movi    a2, port_switch_flag
40379f01:	eb1721        	l32r	a2, 40374b60 <_iram_text_start+0x75c>
    addx4   a2,  a3, a2
40379f04:	a02320        	addx4	a2, a3, a2
    movi    a3, 1
40379f07:	130c      	movi.n	a3, 1
    s32i    a3, a2, 0
40379f09:	0239      	s32i.n	a3, a2, 0

    RET(16)
40379f0b:	f01d      	retw.n
40379f0d:	000000        	ill

40379f10 <_frxt_int_enter>:
    .type   _frxt_int_enter,@function
    .align  4
_frxt_int_enter:

    /* Save a12-13 in the stack frame as required by _xt_context_save. */
    s32i    a12, a1, XT_STK_A12
40379f10:	f1c9      	s32i.n	a12, a1, 60
    s32i    a13, a1, XT_STK_A13
40379f12:	1061d2        	s32i	a13, a1, 64

    /* Save return address in a safe place (free a0). */
    mov     a12, a0
40379f15:	00cd      	mov.n	a12, a0

    /* Save the rest of the interrupted context (preserves A12-13). */
    call0   _xt_context_save
40379f17:	001785        	call0	4037a090 <_xt_context_save>
    /*
    Save interrupted task's SP in TCB only if not nesting.
    Manage nesting directly rather than call the generic IntEnter()
    (in windowed ABI we can't call a C function here anyway because PS.EXCM is still set).
    */
    getcoreid a4
40379f1a:	03eb40        	rsr.prid	a4
40379f1d:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
40379f20:	eb1121        	l32r	a2, 40374b64 <_iram_text_start+0x760>
    addx4   a2,  a4, a2
40379f23:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
40379f26:	e9fa31        	l32r	a3, 40374710 <_iram_text_start+0x30c>
    addx4   a3,  a4, a3
40379f29:	a03430        	addx4	a3, a4, a3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
40379f2c:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* scheduler not running, no tasks */
40379f2e:	e29c      	beqz.n	a2, 40379f50 <_frxt_int_enter+0x40>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
40379f30:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, 1                  /* increment nesting count         */
40379f32:	221b      	addi.n	a2, a2, 1
    s32i    a2,  a3, 0                  /* save nesting count              */
40379f34:	0329      	s32i.n	a2, a3, 0
    bnei    a2,  1, .Lnested            /* !=0 before incr, so nested      */
40379f36:	161266        	bnei	a2, 1, 40379f50 <_frxt_int_enter+0x40>

    movi    a2,  pxCurrentTCB
40379f39:	e9fa21        	l32r	a2, 40374724 <_iram_text_start+0x320>
    addx4   a2,  a4, a2
40379f3c:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
40379f3f:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f
40379f41:	b28c      	beqz.n	a2, 40379f50 <_frxt_int_enter+0x40>
    s32i    a1,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCB->pxTopOfStack = SP */
40379f43:	0219      	s32i.n	a1, a2, 0
    movi    a1,  port_IntStack+configISR_STACK_SIZE   /* a1 = top of intr stack for CPU 0  */
40379f45:	eb0811        	l32r	a1, 40374b68 <_iram_text_start+0x764>
    movi    a2,  configISR_STACK_SIZE   /* add configISR_STACK_SIZE * cpu_num to arrive at top of stack for cpu_num */
40379f48:	00a622        	movi	a2, 0x600
    mull    a2,  a4, a2
40379f4b:	822420        	mull	a2, a4, a2
    add     a1,  a1, a2                 /* for current proc */
40379f4e:	112a      	add.n	a1, a1, a2
    wsr     a3,  CPENABLE
    rsync
    #endif
    #endif

    mov     a0,  a12                    /* restore return addr and return  */
40379f50:	0c0d      	mov.n	a0, a12
    ret
40379f52:	f00d      	ret.n

40379f54 <_frxt_int_exit>:
    .globl  _frxt_int_exit
    .type   _frxt_int_exit,@function
    .align  4
_frxt_int_exit:

    getcoreid a4
40379f54:	03eb40        	rsr.prid	a4
40379f57:	044d40        	extui	a4, a4, 13, 1
    movi    a2,  port_xSchedulerRunning
40379f5a:	eb0221        	l32r	a2, 40374b64 <_iram_text_start+0x760>
    addx4   a2,  a4, a2
40379f5d:	a02420        	addx4	a2, a4, a2
    movi    a3,  port_interruptNesting
40379f60:	e9ec31        	l32r	a3, 40374710 <_iram_text_start+0x30c>
    addx4   a3,  a4, a3
40379f63:	a03430        	addx4	a3, a4, a3
    rsil    a0,  XCHAL_EXCM_LEVEL       /* lock out interrupts             */
40379f66:	006300        	rsil	a0, 3
    l32i    a2,  a2, 0                  /* a2 = port_xSchedulerRunning     */
40379f69:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  .Lnoswitch             /* scheduler not running, no tasks */
40379f6b:	e2ac      	beqz.n	a2, 40379f9d <_frxt_int_exit+0x49>
    l32i    a2,  a3, 0                  /* a2 = port_interruptNesting      */
40379f6d:	0328      	l32i.n	a2, a3, 0
    addi    a2,  a2, -1                 /* decrement nesting count         */
40379f6f:	220b      	addi.n	a2, a2, -1
    s32i    a2,  a3, 0                  /* save nesting count              */
40379f71:	0329      	s32i.n	a2, a3, 0
    bnez    a2,  .Lnesting              /* !=0 after decr so still nested  */
40379f73:	62ec      	bnez.n	a2, 40379f9d <_frxt_int_exit+0x49>
    wsr     a3, CPENABLE
    rsync                               /* ensure CPENABLE was modified */
    #endif
    #endif

    movi    a2,  pxCurrentTCB
40379f75:	e9eb21        	l32r	a2, 40374724 <_iram_text_start+0x320>
    addx4   a2,  a4, a2
40379f78:	a02420        	addx4	a2, a4, a2
    l32i    a2,  a2, 0                  /* a2 = current TCB                */
40379f7b:	0228      	l32i.n	a2, a2, 0
    beqz    a2,  1f                     /* no task ? go to dispatcher      */
40379f7d:	029c      	beqz.n	a2, 40379f91 <_frxt_int_exit+0x3d>
    l32i    a1,  a2, TOPOFSTACK_OFFS    /* SP = pxCurrentTCB->pxTopOfStack */
40379f7f:	0218      	l32i.n	a1, a2, 0

    movi    a2,  port_switch_flag       /* address of switch flag          */
40379f81:	eaf721        	l32r	a2, 40374b60 <_iram_text_start+0x75c>
    addx4   a2,  a4, a2                 /* point to flag for this cpu      */
40379f84:	a02420        	addx4	a2, a4, a2
    l32i    a3,  a2, 0                  /* a3 = port_switch_flag           */
40379f87:	0238      	l32i.n	a3, a2, 0
    beqz    a3,  .Lnoswitch             /* flag = 0 means no switch reqd   */
40379f89:	039c      	beqz.n	a3, 40379f9d <_frxt_int_exit+0x49>
    movi    a3,  0
40379f8b:	00a032        	movi	a3, 0
    s32i    a3,  a2, 0                  /* zero out the flag for next time */
40379f8e:	006232        	s32i	a3, a2, 0
    #endif

    #ifdef __XTENSA_CALL0_ABI__
    call0   vPortYieldFromInt       /* call dispatch inside the function; never returns */
    #else
    call4   vPortYieldFromInt       /* this one returns */
40379f91:	201110        	or	a1, a1, a1
40379f94:	000ad5        	call4	4037a044 <vPortYieldFromInt>
    call0   _frxt_dispatch          /* tail-call dispatcher */
40379f97:	201110        	or	a1, a1, a1
40379f9a:	000085        	call0	40379fa4 <_frxt_dispatch>
    is a nested interrupt, or the interrupted task was not preempted.
    In either case there's no need to load the SP.
    */

    /* Restore full context from interrupt stack frame */
    call0   _xt_context_restore
40379f9d:	001945        	call0	4037a134 <_xt_context_restore>
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0,  a1, XT_STK_EXIT
40379fa0:	0108      	l32i.n	a0, a1, 0
    ret
40379fa2:	f00d      	ret.n

40379fa4 <_frxt_dispatch>:
    call0   vTaskSwitchContext  // Get next TCB to resume
    movi    a2, pxCurrentTCB
    getcoreid a3
    addx4   a2,  a3, a2
    #else
    call4   vTaskSwitchContext  // Get next TCB to resume
40379fa4:	016f95        	call4	4037b6a0 <vTaskSwitchContext>
    movi    a2, pxCurrentTCB
40379fa7:	e9df21        	l32r	a2, 40374724 <_iram_text_start+0x320>
    getcoreid a3
40379faa:	03eb30        	rsr.prid	a3
40379fad:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
40379fb0:	a02320        	addx4	a2, a3, a2
    #endif
    l32i    a3,  a2, 0
40379fb3:	002232        	l32i	a3, a2, 0
    l32i    sp,  a3, TOPOFSTACK_OFFS     /* SP = next_TCB->pxTopOfStack;  */
40379fb6:	002312        	l32i	a1, a3, 0
    s32i    a3,  a2, 0
40379fb9:	006232        	s32i	a3, a2, 0

    /* Determine the type of stack frame. */
    l32i    a2,  sp, XT_STK_EXIT        /* exit dispatcher or solicited flag */
40379fbc:	0128      	l32i.n	a2, a1, 0
    bnez    a2,  .L_frxt_dispatch_stk
40379fbe:	f2cc      	bnez.n	a2, 40379fd1 <_frxt_dispatch+0x2d>

.L_frxt_dispatch_sol:

    /* Solicited stack frame. Restore minimal context and return from vPortYield(). */
    #if XCHAL_HAVE_THREADPTR
    l32i    a2,  sp, XT_SOL_THREADPTR
40379fc0:	3128      	l32i.n	a2, a1, 12
    wur.threadptr a2
40379fc2:	f3e720        	wur.threadptr	a2
    #endif
    l32i    a3,  sp, XT_SOL_PS
40379fc5:	2138      	l32i.n	a3, a1, 8
    l32i    a12, sp, XT_SOL_A12
    l32i    a13, sp, XT_SOL_A13
    l32i    a14, sp, XT_SOL_A14
    l32i    a15, sp, XT_SOL_A15
    #endif
    l32i    a0,  sp, XT_SOL_PC
40379fc7:	1108      	l32i.n	a0, a1, 4
    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE is complete (should be, it was cleared on entry). */
    rsync
40379fc9:	002010        	rsync
    #endif
    /* As soons as PS is restored, interrupts can happen. No need to sync PS. */
    wsr     a3,  PS
40379fcc:	13e630        	wsr.ps	a3
    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, XT_SOL_FRMSZ
    ret
    #else
    retw
40379fcf:	f01d      	retw.n

.L_frxt_dispatch_stk:

    #if XCHAL_CP_NUM > 0
    /* Restore CPENABLE from task's co-processor save area. */
    movi    a3, pxCurrentTCB            /* cp_state =                       */
40379fd1:	e9d431        	l32r	a3, 40374724 <_iram_text_start+0x320>
    getcoreid a2
40379fd4:	03eb20        	rsr.prid	a2
40379fd7:	042d20        	extui	a2, a2, 13, 1
    addx4   a3,  a2, a3
40379fda:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
40379fdd:	002332        	l32i	a3, a3, 0
    l32i    a2, a3, CP_TOPOFSTACK_OFFS     /* StackType_t                       *pxStack; */
40379fe0:	012322        	l32i	a2, a3, 4
    l16ui   a3, a2, XT_CPENABLE         /* CPENABLE = cp_state->cpenable;   */
40379fe3:	001232        	l16ui	a3, a2, 0
    wsr     a3, CPENABLE
40379fe6:	13e030        	wsr.cpenable	a3
    #endif

    /* Interrupt stack frame. Restore full context and return to exit dispatcher. */
    call0   _xt_context_restore
40379fe9:	001485        	call0	4037a134 <_xt_context_restore>
    l32i    a15, sp, XT_STK_A15
    #endif

    #if XCHAL_CP_NUM > 0
    /* Ensure wsr.CPENABLE has completed. */
    rsync
40379fec:	002010        	rsync
    /*
    Must return via the exit dispatcher corresponding to the entrypoint from which
    this was called. Interruptee's A0, A1, PS, PC are restored and the interrupt
    stack frame is deallocated in the exit dispatcher.
    */
    l32i    a0, sp, XT_STK_EXIT
40379fef:	002102        	l32i	a0, a1, 0
    ret
40379ff2:	f00d      	ret.n

40379ff4 <vPortYield>:
vPortYield:

    #ifdef __XTENSA_CALL0_ABI__
    addi    sp,  sp, -XT_SOL_FRMSZ
    #else
    entry   sp,  XT_SOL_FRMSZ
40379ff4:	004136        	entry	a1, 32
    #endif

    rsr     a2,  PS
40379ff7:	03e620        	rsr.ps	a2
    s32i    a0,  sp, XT_SOL_PC
40379ffa:	1109      	s32i.n	a0, a1, 4
    s32i    a2,  sp, XT_SOL_PS
40379ffc:	2129      	s32i.n	a2, a1, 8
    #if XCHAL_HAVE_THREADPTR
    rur.threadptr a2
40379ffe:	e32e70        	rur.threadptr	a2
    s32i    a2,  sp, XT_SOL_THREADPTR
4037a001:	3129      	s32i.n	a2, a1, 12
    s32i    a15, sp, XT_SOL_A15
    #else
    /* Spill register windows. Calling xthal_window_spill() causes extra    */
    /* spills and reloads, so we will set things up to call the _nw version */
    /* instead to save cycles.                                              */
    movi    a6,  ~(PS_WOE_MASK|PS_INTLEVEL_MASK)  /* spills a4-a7 if needed */
4037a003:	eada61        	l32r	a6, 40374b6c <_iram_text_start+0x768>
    and     a2,  a2, a6                           /* clear WOE, INTLEVEL    */
4037a006:	102260        	and	a2, a2, a6
    addi    a2,  a2, XCHAL_EXCM_LEVEL             /* set INTLEVEL           */
4037a009:	03c222        	addi	a2, a2, 3
    wsr     a2,  PS
4037a00c:	13e620        	wsr.ps	a2
    rsync
4037a00f:	002010        	rsync
    call0   xthal_window_spill_nw
4037a012:	063545        	call0	40380368 <xthal_window_spill_nw>
    l32i    a2,  sp, XT_SOL_PS                    /* restore PS             */
4037a015:	2128      	l32i.n	a2, a1, 8
    wsr     a2,  PS
4037a017:	13e620        	wsr.ps	a2
    #endif

    rsil    a2,  XCHAL_EXCM_LEVEL       /* disable low/med interrupts       */
4037a01a:	006320        	rsil	a2, 3

    #if XCHAL_CP_NUM > 0
    /* Save coprocessor callee-saved state (if any). At this point CPENABLE */
    /* should still reflect which CPs were in use (enabled).                */
    call0   _xt_coproc_savecs
4037a01d:	001a05        	call0	4037a1c0 <_xt_coproc_savecs>
    #endif

    movi    a2,  pxCurrentTCB
4037a020:	e9c121        	l32r	a2, 40374724 <_iram_text_start+0x320>
    getcoreid a3
4037a023:	03eb30        	rsr.prid	a3
4037a026:	043d30        	extui	a3, a3, 13, 1
    addx4   a2,  a3, a2
4037a029:	a02320        	addx4	a2, a3, a2
    l32i    a2,  a2, 0                  /* a2 = pxCurrentTCB                */
4037a02c:	0228      	l32i.n	a2, a2, 0
    movi    a3,  0
4037a02e:	030c      	movi.n	a3, 0
    s32i    a3,  sp, XT_SOL_EXIT        /* 0 to flag as solicited frame     */
4037a030:	0139      	s32i.n	a3, a1, 0
    s32i    sp,  a2, TOPOFSTACK_OFFS    /* pxCurrentTCB->pxTopOfStack = SP  */
4037a032:	0219      	s32i.n	a1, a2, 0

    #if XCHAL_CP_NUM > 0
    /* Clear CPENABLE, also in task's co-processor state save area. */
    l32i    a2,  a2, CP_TOPOFSTACK_OFFS /* a2 = pxCurrentTCB->cp_state      */
4037a034:	1228      	l32i.n	a2, a2, 4
    movi    a3,  0
4037a036:	030c      	movi.n	a3, 0
    wsr     a3,  CPENABLE
4037a038:	13e030        	wsr.cpenable	a3
    beqz    a2,  1f
4037a03b:	002216        	beqz	a2, 4037a041 <vPortYield+0x4d>
    s16i    a3,  a2, XT_CPENABLE        /* clear saved cpenable             */
4037a03e:	005232        	s16i	a3, a2, 0
1:
    #endif

    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
4037a041:	fff605        	call0	40379fa4 <_frxt_dispatch>

4037a044 <vPortYieldFromInt>:
    .globl  vPortYieldFromInt
    .type   vPortYieldFromInt,@function
    .align  4
vPortYieldFromInt:

    ENTRY(16)
4037a044:	002136        	entry	a1, 16

    #if XCHAL_CP_NUM > 0
    /* Save CPENABLE in task's co-processor save area, and clear CPENABLE.  */
    movi    a3, pxCurrentTCB            /* cp_state =                       */
4037a047:	e9b731        	l32r	a3, 40374724 <_iram_text_start+0x320>
    getcoreid a2
4037a04a:	03eb20        	rsr.prid	a2
4037a04d:	042d20        	extui	a2, a2, 13, 1
    addx4   a3,  a2, a3
4037a050:	a03230        	addx4	a3, a2, a3
    l32i    a3, a3, 0
4037a053:	0338      	l32i.n	a3, a3, 0

    l32i    a2, a3, CP_TOPOFSTACK_OFFS
4037a055:	1328      	l32i.n	a2, a3, 4

    rsr     a3, CPENABLE
4037a057:	03e030        	rsr.cpenable	a3
    s16i    a3, a2, XT_CPENABLE         /* cp_state->cpenable = CPENABLE;   */
4037a05a:	005232        	s16i	a3, a2, 0
    movi    a3, 0
4037a05d:	030c      	movi.n	a3, 0
    wsr     a3, CPENABLE                /* disable all co-processors        */
4037a05f:	13e030        	wsr.cpenable	a3
    #ifdef __XTENSA_CALL0_ABI__
    /* Tail-call dispatcher. */
    call0   _frxt_dispatch
    /* Never reaches here. */
    #else
    RET(16)
4037a062:	f01d      	retw.n

4037a064 <_frxt_task_coproc_state>:
    .align  4
_frxt_task_coproc_state:


    /* We can use a3 as a scratchpad, the instances of code calling XT_RTOS_CP_STATE don't seem to need it saved. */
    getcoreid a3
4037a064:	03eb30        	rsr.prid	a3
4037a067:	043d30        	extui	a3, a3, 13, 1
    movi    a15, port_xSchedulerRunning /* if (port_xSchedulerRunning              */
4037a06a:	eabef1        	l32r	a15, 40374b64 <_iram_text_start+0x760>
    addx4   a15, a3,a15
4037a06d:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a070:	0ff8      	l32i.n	a15, a15, 0
    beqz    a15, 1f
4037a072:	6f9c      	beqz.n	a15, 4037a08c <_frxt_task_coproc_state+0x28>
    movi    a15, port_interruptNesting  /* && port_interruptNesting == 0           */
4037a074:	e9a7f1        	l32r	a15, 40374710 <_iram_text_start+0x30c>
    addx4   a15, a3, a15
4037a077:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0
4037a07a:	0ff8      	l32i.n	a15, a15, 0
    bnez    a15, 1f
4037a07c:	cfcc      	bnez.n	a15, 4037a08c <_frxt_task_coproc_state+0x28>

    movi    a15, pxCurrentTCB
4037a07e:	e9a9f1        	l32r	a15, 40374724 <_iram_text_start+0x320>
    addx4   a15, a3, a15
4037a081:	a0f3f0        	addx4	a15, a3, a15
    l32i    a15, a15, 0                 /* && pxCurrentTCB != 0) {                 */
4037a084:	0ff8      	l32i.n	a15, a15, 0

    beqz    a15, 2f
4037a086:	4f8c      	beqz.n	a15, 4037a08e <_frxt_task_coproc_state+0x2a>
    l32i    a15, a15, CP_TOPOFSTACK_OFFS
4037a088:	1ff8      	l32i.n	a15, a15, 4
    ret
4037a08a:	f00d      	ret.n

1:  movi    a15, 0
4037a08c:	0f0c      	movi.n	a15, 0
2:  ret
4037a08e:	f00d      	ret.n

4037a090 <_xt_context_save>:
    .literal_position
    .align  4

_xt_context_save:

    s32i    a2,  sp, XT_STK_A2
4037a090:	5129      	s32i.n	a2, a1, 20
    s32i    a3,  sp, XT_STK_A3
4037a092:	6139      	s32i.n	a3, a1, 24
    s32i    a4,  sp, XT_STK_A4
4037a094:	7149      	s32i.n	a4, a1, 28
    s32i    a5,  sp, XT_STK_A5
4037a096:	8159      	s32i.n	a5, a1, 32
    s32i    a6,  sp, XT_STK_A6
4037a098:	9169      	s32i.n	a6, a1, 36
    s32i    a7,  sp, XT_STK_A7
4037a09a:	a179      	s32i.n	a7, a1, 40
    s32i    a8,  sp, XT_STK_A8
4037a09c:	b189      	s32i.n	a8, a1, 44
    s32i    a9,  sp, XT_STK_A9
4037a09e:	c199      	s32i.n	a9, a1, 48
    s32i    a10, sp, XT_STK_A10
4037a0a0:	d1a9      	s32i.n	a10, a1, 52
    s32i    a11, sp, XT_STK_A11
4037a0a2:	e1b9      	s32i.n	a11, a1, 56
    Call0 ABI callee-saved regs a12-15 do not need to be saved here.
    a12-13 are the caller's responsibility so it can use them as scratch.
    So only need to save a14-a15 here for Windowed ABI (not Call0).
    */
    #ifndef __XTENSA_CALL0_ABI__
    s32i    a14, sp, XT_STK_A14
4037a0a4:	1161e2        	s32i	a14, a1, 68
    s32i    a15, sp, XT_STK_A15
4037a0a7:	1261f2        	s32i	a15, a1, 72
    #endif

    rsr     a3,  SAR
4037a0aa:	030330        	rsr.sar	a3
    s32i    a3,  sp, XT_STK_SAR
4037a0ad:	136132        	s32i	a3, a1, 76

    #if XCHAL_HAVE_LOOPS
    rsr     a3,  LBEG
4037a0b0:	030030        	rsr.lbeg	a3
    s32i    a3,  sp, XT_STK_LBEG
4037a0b3:	166132        	s32i	a3, a1, 88
    rsr     a3,  LEND
4037a0b6:	030130        	rsr.lend	a3
    s32i    a3,  sp, XT_STK_LEND
4037a0b9:	176132        	s32i	a3, a1, 92
    rsr     a3,  LCOUNT
4037a0bc:	030230        	rsr.lcount	a3
    s32i    a3,  sp, XT_STK_LCOUNT
4037a0bf:	186132        	s32i	a3, a1, 96
    l32i    a3,  a3, 0
    s32i    a3,  sp, XT_STK_VPRI
    #endif

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a9,  a0                     /* preserve ret addr */
4037a0c2:	009d      	mov.n	a9, a0
    #endif

    s32i    a12, sp, XT_STK_TMP0        /* temp. save stuff in stack frame */
4037a0c4:	1961c2        	s32i	a12, a1, 100
    s32i    a13, sp, XT_STK_TMP1
4037a0c7:	1a61d2        	s32i	a13, a1, 104
    s32i    a9,  sp, XT_STK_TMP2
4037a0ca:	1b6192        	s32i	a9, a1, 108

    l32i    a12, sp, XT_STK_A12         /* recover original a9,12,13 */
4037a0cd:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
4037a0cf:	1021d2        	l32i	a13, a1, 64
    l32i    a9,  sp, XT_STK_A9
4037a0d2:	c198      	l32i.n	a9, a1, 48

    #if XCHAL_EXTRA_SA_SIZE > 0
    addi    a2,  sp, XT_STK_EXTRA       /* where to save it */
4037a0d4:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_save_extra_nw         /* destroys a0,2,3 */
4037a0d7:	063f85        	call0	403804d0 <xthal_save_extra_nw>
     * may contain live windows belonging to previous frames in the call stack.
     * These frames will be spilled by SPILL_ALL_WINDOWS, and if the register was
     * used as a temporary by this code, the temporary value would get stored
     * onto the stack, instead of the real value.
     */
    rsr     a2, PS                     /* to be restored after SPILL_ALL_WINDOWS */
4037a0da:	03e620        	rsr.ps	a2
    movi    a0, PS_INTLEVEL_MASK
4037a0dd:	f00c      	movi.n	a0, 15
    and     a3, a2, a0                 /* get the current INTLEVEL */
4037a0df:	103200        	and	a3, a2, a0
    bgeui   a3, XCHAL_EXCM_LEVEL, 1f   /* calculate max(INTLEVEL, XCHAL_EXCM_LEVEL) */
4037a0e2:	0233f6        	bgeui	a3, 3, 4037a0e8 <_xt_context_save+0x58>
    movi    a3, XCHAL_EXCM_LEVEL
4037a0e5:	03a032        	movi	a3, 3
1:
    movi    a0, PS_UM | PS_WOE         /* clear EXCM, enable window overflow, set new INTLEVEL */
4037a0e8:	eaa201        	l32r	a0, 40374b70 <_iram_text_start+0x76c>
    or      a3, a3, a0
4037a0eb:	203300        	or	a3, a3, a0
    wsr     a3, ps
4037a0ee:	13e630        	wsr.ps	a3
    rsr     a0, EPC1                   /* to be restored after SPILL_ALL_WINDOWS */
4037a0f1:	03b100        	rsr.epc1	a0

    addi    sp,  sp, XT_STK_FRMSZ      /* go back to spill register region */
4037a0f4:	01d112        	addmi	a1, a1, 0x100
4037a0f7:	c0c112        	addi	a1, a1, -64
    SPILL_ALL_WINDOWS                  /* place the live register windows there */
4037a0fa:	10ccc0        	and	a12, a12, a12
4037a0fd:	408030        	rotw	3
4037a100:	10ccc0        	and	a12, a12, a12
4037a103:	408030        	rotw	3
4037a106:	10ccc0        	and	a12, a12, a12
4037a109:	408030        	rotw	3
4037a10c:	10ccc0        	and	a12, a12, a12
4037a10f:	408030        	rotw	3
4037a112:	10ccc0        	and	a12, a12, a12
4037a115:	408040        	rotw	4
    addi    sp,  sp, -XT_STK_FRMSZ     /* return the current stack pointer and proceed with context save*/
4037a118:	ffd112        	addmi	a1, a1, 0xffffff00
4037a11b:	40c112        	addi	a1, a1, 64

    wsr     a2, PS                     /* restore to the value at entry */
4037a11e:	13e620        	wsr.ps	a2
    rsync
4037a121:	002010        	rsync
    wsr     a0, EPC1                   /* likewise */
4037a124:	13b100        	wsr.epc1	a0

    #endif /* __XTENSA_CALL0_ABI__ */

    l32i    a12, sp, XT_STK_TMP0       /* restore the temp saved registers */
4037a127:	1921c2        	l32i	a12, a1, 100
    l32i    a13, sp, XT_STK_TMP1       /* our return address is there */
4037a12a:	1a21d2        	l32i	a13, a1, 104
    l32i    a9,  sp, XT_STK_TMP2
4037a12d:	1b2192        	l32i	a9, a1, 108

    #if XCHAL_EXTRA_SA_SIZE > 0 || !defined(__XTENSA_CALL0_ABI__)
    mov     a0, a9                      /* retrieve ret addr */
4037a130:	090d      	mov.n	a0, a9
    #endif

    ret
4037a132:	f00d      	ret.n

4037a134 <_xt_context_restore>:
    affected, but it is generally unlikely. If that ever happens,
    more registers need to be saved/restored around this macro invocation.
    Here we only assume a13 is preserved.
    Future Xtensa tools releases might limit the regs that can be affected.
    */
    mov     a13, a0                     /* preserve ret addr */
4037a134:	00dd      	mov.n	a13, a0
    addi    a2,  sp, XT_STK_EXTRA       /* where to find it */
4037a136:	70c122        	addi	a2, a1, 112
    # if XCHAL_EXTRA_SA_ALIGN > 16
    movi    a3, -XCHAL_EXTRA_SA_ALIGN
    and     a2, a2, a3                  /* align dynamically >16 bytes */
    # endif
    call0   xthal_restore_extra_nw      /* destroys a0,2,3,4,5 */
4037a139:	063645        	call0	403804a0 <xthal_restore_extra_nw>
    mov     a0,  a13                    /* retrieve ret addr */
4037a13c:	0d0d      	mov.n	a0, a13
    #endif

    #if XCHAL_HAVE_LOOPS
    l32i    a2,  sp, XT_STK_LBEG
4037a13e:	162122        	l32i	a2, a1, 88
    l32i    a3,  sp, XT_STK_LEND
4037a141:	172132        	l32i	a3, a1, 92
    wsr     a2,  LBEG
4037a144:	130020        	wsr.lbeg	a2
    l32i    a2,  sp, XT_STK_LCOUNT
4037a147:	182122        	l32i	a2, a1, 96
    wsr     a3,  LEND
4037a14a:	130130        	wsr.lend	a3
    wsr     a2,  LCOUNT
4037a14d:	130220        	wsr.lcount	a2
    and     a4,  a4, a5
    wsr     a4,  INTENABLE              /* update INTENABLE */
    s32i    a5,  a3, 4                  /* restore _xt_vpri_mask */
    #endif

    l32i    a3,  sp, XT_STK_SAR
4037a150:	132132        	l32i	a3, a1, 76
    l32i    a2,  sp, XT_STK_A2
4037a153:	5128      	l32i.n	a2, a1, 20
    wsr     a3,  SAR
4037a155:	130330        	wsr.sar	a3
    l32i    a3,  sp, XT_STK_A3
4037a158:	6138      	l32i.n	a3, a1, 24
    l32i    a4,  sp, XT_STK_A4
4037a15a:	7148      	l32i.n	a4, a1, 28
    l32i    a5,  sp, XT_STK_A5
4037a15c:	8158      	l32i.n	a5, a1, 32
    l32i    a6,  sp, XT_STK_A6
4037a15e:	9168      	l32i.n	a6, a1, 36
    l32i    a7,  sp, XT_STK_A7
4037a160:	a178      	l32i.n	a7, a1, 40
    l32i    a8,  sp, XT_STK_A8
4037a162:	b188      	l32i.n	a8, a1, 44
    l32i    a9,  sp, XT_STK_A9
4037a164:	c198      	l32i.n	a9, a1, 48
    l32i    a10, sp, XT_STK_A10
4037a166:	d1a8      	l32i.n	a10, a1, 52
    l32i    a11, sp, XT_STK_A11
4037a168:	e1b8      	l32i.n	a11, a1, 56
    /*
    Call0 ABI callee-saved regs a12-15 do not need to be restored here.
    However a12-13 were saved for scratch before XT_RTOS_INT_ENTER(),
    so need to be restored anyway, despite being callee-saved in Call0.
    */
    l32i    a12, sp, XT_STK_A12
4037a16a:	f1c8      	l32i.n	a12, a1, 60
    l32i    a13, sp, XT_STK_A13
4037a16c:	1021d2        	l32i	a13, a1, 64
    #ifndef __XTENSA_CALL0_ABI__
    l32i    a14, sp, XT_STK_A14
4037a16f:	1121e2        	l32i	a14, a1, 68
    l32i    a15, sp, XT_STK_A15
4037a172:	1221f2        	l32i	a15, a1, 72
    #endif

    ret
4037a175:	f00d      	ret.n
	...

4037a178 <_xt_coproc_init>:
    .type   _xt_coproc_init,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_init:
    ENTRY0
4037a178:	002136        	entry	a1, 16

    /* Initialize thread co-processor ownerships to 0 (unowned). */
    movi    a2, _xt_coproc_owner_sa         /* a2 = base of owner array */
4037a17b:	e96c21        	l32r	a2, 4037472c <_iram_text_start+0x328>
    addi    a3, a2, (XCHAL_CP_MAX*portNUM_PROCESSORS) << 2       /* a3 = top+1 of owner array */
4037a17e:	20c232        	addi	a3, a2, 32
    movi    a4, 0                           /* a4 = 0 (unowned) */
4037a181:	00a042        	movi	a4, 0
1:  s32i    a4, a2, 0
4037a184:	0249      	s32i.n	a4, a2, 0
    addi    a2, a2, 4
4037a186:	224b      	addi.n	a2, a2, 4
    bltu    a2, a3, 1b
4037a188:	f83237        	bltu	a2, a3, 4037a184 <_xt_coproc_init+0xc>

    RET0
4037a18b:	f01d      	retw.n
4037a18d:	000000        	ill

4037a190 <_xt_coproc_release>:
    .type   _xt_coproc_release,@function
    .align  4
    .literal_position
    .align  4
_xt_coproc_release:
    ENTRY0                                  /* a2 = base of save area */
4037a190:	002136        	entry	a1, 16

    getcoreid a5
4037a193:	03eb50        	rsr.prid	a5
4037a196:	045d50        	extui	a5, a5, 13, 1
    movi    a3, XCHAL_CP_MAX << 2
4037a199:	031c      	movi.n	a3, 16
    mull    a5, a5, a3
4037a19b:	825530        	mull	a5, a5, a3
    movi    a3, _xt_coproc_owner_sa         /* a3 = base of owner array */
4037a19e:	e96331        	l32r	a3, 4037472c <_iram_text_start+0x328>
    add     a3, a3, a5
4037a1a1:	803350        	add	a3, a3, a5

    addi    a4, a3, XCHAL_CP_MAX << 2       /* a4 = top+1 of owner array */
4037a1a4:	10c342        	addi	a4, a3, 16
    movi    a5, 0                           /* a5 = 0 (unowned) */
4037a1a7:	00a052        	movi	a5, 0

    rsil    a6, XCHAL_EXCM_LEVEL            /* lock interrupts */
4037a1aa:	006360        	rsil	a6, 3

1:  l32i    a7, a3, 0                       /* a7 = owner at a3 */
4037a1ad:	0378      	l32i.n	a7, a3, 0
    bne     a2, a7, 2f                      /* if (coproc_sa_base == owner) */
4037a1af:	019277        	bne	a2, a7, 4037a1b4 <_xt_coproc_release+0x24>
    s32i    a5, a3, 0                       /*   owner = unowned */
4037a1b2:	0359      	s32i.n	a5, a3, 0
2:  addi    a3, a3, 1<<2                    /* a3 = next entry in owner array */
4037a1b4:	334b      	addi.n	a3, a3, 4
    bltu    a3, a4, 1b                      /* repeat until end of array */
4037a1b6:	f33347        	bltu	a3, a4, 4037a1ad <_xt_coproc_release+0x1d>

3:  wsr     a6, PS                          /* restore interrupts */
4037a1b9:	13e660        	wsr.ps	a6

    RET0
4037a1bc:	f01d      	retw.n
	...

4037a1c0 <_xt_coproc_savecs>:
    .align      4
_xt_coproc_savecs:

    /* At entry, CPENABLE should be showing which CPs are enabled. */

    rsr     a2, CPENABLE                /* a2 = which CPs are enabled      */
4037a1c0:	03e020        	rsr.cpenable	a2
    beqz    a2, .Ldone                  /* quick exit if none              */
4037a1c3:	d29c      	beqz.n	a2, 4037a1e4 <_xt_coproc_savecs+0x24>
    mov     a14, a0                     /* save return address             */
4037a1c5:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
4037a1c7:	ffe9c5        	call0	4037a064 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
4037a1ca:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone                 /* if none then nothing to do      */
4037a1cc:	4f9c      	beqz.n	a15, 4037a1e4 <_xt_coproc_savecs+0x24>
    s16i    a2, a15, XT_CP_CS_ST        /* save mask of CPs being stored   */
4037a1ce:	025f22        	s16i	a2, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
4037a1d1:	e957d1        	l32r	a13, 40374730 <_iram_text_start+0x32c>
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
4037a1d4:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
4037a1d6:	036207        	bbci	a2, 0, 4037a1dd <_xt_coproc_savecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
4037a1d9:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
4037a1db:	3efa      	add.n	a3, a14, a15
    xchal_cp2_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
4037a1dd:	036237        	bbci	a2, 3, 4037a1e4 <_xt_coproc_savecs+0x24>
    l32i    a14, a13, 12
4037a1e0:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
4037a1e2:	3efa      	add.n	a3, a14, a15
    xchal_cp7_store a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone:
    ret
4037a1e4:	f00d      	ret.n
	...

4037a1e8 <_xt_coproc_restorecs>:
    .align  4
    .literal_position
    .align      4
_xt_coproc_restorecs:

    mov     a14, a0                     /* save return address             */
4037a1e8:	00ed      	mov.n	a14, a0
    call0   XT_RTOS_CP_STATE            /* get address of CP save area     */
4037a1ea:	ffe785        	call0	4037a064 <_frxt_task_coproc_state>
    mov     a0, a14                     /* restore return address          */
4037a1ed:	0e0d      	mov.n	a0, a14
    beqz    a15, .Ldone2                /* if none then nothing to do      */
4037a1ef:	9f9c      	beqz.n	a15, 4037a20c <_xt_coproc_restorecs+0x24>
    l16ui   a3, a15, XT_CP_CS_ST        /* a3 = which CPs have been saved  */
4037a1f1:	021f32        	l16ui	a3, a15, 4
    xor     a3, a3, a2                  /* clear the ones being restored   */
4037a1f4:	303320        	xor	a3, a3, a2
    s32i    a3, a15, XT_CP_CS_ST        /* update saved CP mask            */
4037a1f7:	1f39      	s32i.n	a3, a15, 4
    movi    a13, _xt_coproc_sa_offset   /* array of CP save offsets        */
4037a1f9:	e94dd1        	l32r	a13, 40374730 <_iram_text_start+0x32c>
    l32i    a15, a15, XT_CP_ASA         /* a15 = base of aligned save area */
4037a1fc:	2ff8      	l32i.n	a15, a15, 8

#if XCHAL_CP0_SA_SIZE
    bbci.l  a2, 0, 2f                   /* CP 0 not enabled                */
4037a1fe:	036207        	bbci	a2, 0, 4037a205 <_xt_coproc_restorecs+0x1d>
    l32i    a14, a13, 0                 /* a14 = _xt_coproc_sa_offset[0]   */
4037a201:	0de8      	l32i.n	a14, a13, 0
    add     a3, a14, a15                /* a3 = save area for CP 0         */
4037a203:	3efa      	add.n	a3, a14, a15
    xchal_cp2_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

#if XCHAL_CP3_SA_SIZE
    bbci.l  a2, 3, 2f
4037a205:	036237        	bbci	a2, 3, 4037a20c <_xt_coproc_restorecs+0x24>
    l32i    a14, a13, 12
4037a208:	3de8      	l32i.n	a14, a13, 12
    add     a3, a14, a15
4037a20a:	3efa      	add.n	a3, a14, a15
    xchal_cp7_load a3, a4, a5, a6, a7 continue=0 ofs=-1 select=XTHAL_SAS_TIE|XTHAL_SAS_NOCC|XTHAL_SAS_CALE alloc=XTHAL_SAS_ALL
2:
#endif

.Ldone2:
    ret
4037a20c:	f00d      	ret.n
	...

4037a210 <vPortSetupTimer>:
{
4037a210:	006136        	entry	a1, 48
    asm volatile (
4037a213:	03eb20        	rsr.prid	a2
4037a216:	042d20        	extui	a2, a2, 13, 1
    ESP_ERROR_CHECK(esp_intr_alloc(ETS_SYSTIMER_TARGET0_EDGE_INTR_SOURCE + cpuid, ESP_INTR_FLAG_IRAM | level, SysTickIsrHandler, &systimer_hal, NULL));
4037a219:	ea5631        	l32r	a3, 40374b74 <_iram_text_start+0x770>
4037a21c:	ea57c1        	l32r	a12, 40374b78 <_iram_text_start+0x774>
4037a21f:	0e0c      	movi.n	a14, 0
4037a221:	03dd      	mov.n	a13, a3
4037a223:	02a4b2        	movi	a11, 0x402
4037a226:	39c2a2        	addi	a10, a2, 57
4037a229:	ea5881        	l32r	a8, 40374b8c <_iram_text_start+0x788>
4037a22c:	0008e0        	callx8	a8
4037a22f:	00da16        	beqz	a10, 4037a240 <vPortSetupTimer+0x30>
4037a232:	ea52e1        	l32r	a14, 40374b7c <_iram_text_start+0x778>
4037a235:	ea52d1        	l32r	a13, 40374b80 <_iram_text_start+0x77c>
4037a238:	ea53b1        	l32r	a11, 40374b84 <_iram_text_start+0x780>
4037a23b:	2c5c      	movi.n	a12, 82
4037a23d:	ffc7e5        	call8	40379ebc <_esp_error_check_failed>
    if (cpuid == 0) {
4037a240:	0aa256        	bnez	a2, 4037a2ee <vPortSetupTimer+0xde>
        periph_module_enable(PERIPH_SYSTIMER_MODULE);
4037a243:	4a2c      	movi.n	a10, 36
4037a245:	ea5281        	l32r	a8, 40374b90 <_iram_text_start+0x78c>
4037a248:	0008e0        	callx8	a8
        systimer_hal_init(&systimer_hal);
4037a24b:	03ad      	mov.n	a10, a3
4037a24d:	036fa5        	call8	4037d948 <systimer_hal_init>
        systimer_hal_tick_rate_ops_t ops = {
4037a250:	ea4e41        	l32r	a4, 40374b88 <_iram_text_start+0x784>
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a253:	01bd      	mov.n	a11, a1
        systimer_hal_tick_rate_ops_t ops = {
4037a255:	0488      	l32i.n	a8, a4, 0
4037a257:	1448      	l32i.n	a4, a4, 4
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a259:	03ad      	mov.n	a10, a3
        systimer_hal_tick_rate_ops_t ops = {
4037a25b:	0189      	s32i.n	a8, a1, 0
4037a25d:	1149      	s32i.n	a4, a1, 4
        systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
4037a25f:	038fa5        	call8	4037db58 <systimer_hal_set_tick_rate_ops>
        systimer_ll_set_counter_value(systimer_hal.dev, SYSTIMER_LL_COUNTER_OS_TICK, 0);
4037a262:	0388      	l32i.n	a8, a3, 0
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037a264:	f97c      	movi.n	a9, -1
4037a266:	0020c0        	memw
4037a269:	5848      	l32i.n	a4, a8, 20
4037a26b:	0199c0        	slli	a9, a9, 20
4037a26e:	104490        	and	a4, a4, a9
4037a271:	0020c0        	memw
4037a274:	5849      	s32i.n	a4, a8, 20
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037a276:	0020c0        	memw
4037a279:	6829      	s32i.n	a2, a8, 24
    dev->unit_load[counter_id].val = 0x01;
4037a27b:	140c      	movi.n	a4, 1
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK, cpuid, false);
4037a27d:	02dd      	mov.n	a13, a2
4037a27f:	02cd      	mov.n	a12, a2
4037a281:	04bd      	mov.n	a11, a4
4037a283:	03ad      	mov.n	a10, a3
4037a285:	0020c0        	memw
4037a288:	186842        	s32i	a4, a8, 96
4037a28b:	039225        	call8	4037dbac <systimer_hal_counter_can_stall_by_cpu>
4037a28e:	02dd      	mov.n	a13, a2
4037a290:	04cd      	mov.n	a12, a4
4037a292:	04bd      	mov.n	a11, a4
4037a294:	03ad      	mov.n	a10, a3
4037a296:	039165        	call8	4037dbac <systimer_hal_counter_can_stall_by_cpu>
            systimer_hal_connect_alarm_counter(&systimer_hal, alarm_id, SYSTIMER_LL_COUNTER_OS_TICK);
4037a299:	04cd      	mov.n	a12, a4
4037a29b:	02bd      	mov.n	a11, a2
4037a29d:	03ad      	mov.n	a10, a3
4037a29f:	038965        	call8	4037db34 <systimer_hal_connect_alarm_counter>
            systimer_hal_set_alarm_period(&systimer_hal, alarm_id, 1000000UL / CONFIG_FREERTOS_HZ);
4037a2a2:	71a2c2        	movi	a12, 0x271
4037a2a5:	11ccc0        	slli	a12, a12, 4
4037a2a8:	02bd      	mov.n	a11, a2
4037a2aa:	03ad      	mov.n	a10, a3
4037a2ac:	0376e5        	call8	4037da1c <systimer_hal_set_alarm_period>
            systimer_hal_select_alarm_mode(&systimer_hal, alarm_id, SYSTIMER_ALARM_MODE_PERIOD);
4037a2af:	04cd      	mov.n	a12, a4
4037a2b1:	02bd      	mov.n	a11, a2
4037a2b3:	03ad      	mov.n	a10, a3
4037a2b5:	0383e5        	call8	4037daf4 <systimer_hal_select_alarm_mode>
            systimer_hal_counter_can_stall_by_cpu(&systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK, cpuid, true);
4037a2b8:	04dd      	mov.n	a13, a4
4037a2ba:	02cd      	mov.n	a12, a2
4037a2bc:	04bd      	mov.n	a11, a4
4037a2be:	03ad      	mov.n	a10, a3
4037a2c0:	038ea5        	call8	4037dbac <systimer_hal_counter_can_stall_by_cpu>
            if (cpuid == 0) {
4037a2c3:	12ec      	bnez.n	a2, 4037a2e8 <vPortSetupTimer+0xd8>
                systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a2c5:	02bd      	mov.n	a11, a2
4037a2c7:	03ad      	mov.n	a10, a3
4037a2c9:	0389e5        	call8	4037db68 <systimer_hal_enable_alarm_int>
                systimer_hal_enable_counter(&systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK);
4037a2cc:	04bd      	mov.n	a11, a4
4037a2ce:	03ad      	mov.n	a10, a3
4037a2d0:	038b65        	call8	4037db88 <systimer_hal_enable_counter>
                systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_LL_COUNTER_OS_TICK, 1000000UL / CONFIG_FREERTOS_HZ / 2);
4037a2d3:	71a2c2        	movi	a12, 0x271
4037a2d6:	11ccd0        	slli	a12, a12, 3
4037a2d9:	02dd      	mov.n	a13, a2
4037a2db:	04bd      	mov.n	a11, a4
4037a2dd:	03ad      	mov.n	a10, a3
4037a2df:	037be5        	call8	4037da9c <systimer_hal_counter_value_advance>
4037a2e2:	042d      	mov.n	a2, a4
4037a2e4:	ffec46        	j	4037a299 <vPortSetupTimer+0x89>
4037a2e7:	00          	.byte 00
        for (cpuid = 0; cpuid < portNUM_PROCESSORS; ++cpuid) {
4037a2e8:	f61266        	bnei	a2, 1, 4037a2e2 <vPortSetupTimer+0xd2>
}
4037a2eb:	f01d      	retw.n
4037a2ed:	00          	.byte 00
        systimer_hal_enable_alarm_int(&systimer_hal, alarm_id);
4037a2ee:	02bd      	mov.n	a11, a2
4037a2f0:	03ad      	mov.n	a10, a3
4037a2f2:	038765        	call8	4037db68 <systimer_hal_enable_alarm_int>
}
4037a2f5:	fffc86        	j	4037a2eb <vPortSetupTimer+0xdb>

4037a2f8 <xPortSysTickHandler>:
 *  - _frxt_timer_int for xtensa with CONFIG_FREERTOS_SYSTICK_USES_CCOUNT
 *  - SysTickIsrHandler for xtensa with CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER
 *  - SysTickIsrHandler for riscv
 */
BaseType_t xPortSysTickHandler(void)
{
4037a2f8:	004136        	entry	a1, 32
    portbenchmarkIntLatency();
#endif //configBENCHMARK
    traceISR_ENTER(SYSTICK_INTR_ID);

    // Call IDF Tick Hook
    esp_vApplicationTickHook();
4037a2fb:	fb80e5        	call8	40375b08 <esp_vApplicationTickHook>
4037a2fe:	03eb20        	rsr.prid	a2
4037a301:	042d20        	extui	a2, a2, 13, 1
    // Call FreeRTOS Increment tick function
    BaseType_t xSwitchRequired;
#if CONFIG_FREERTOS_UNICORE
    xSwitchRequired = xTaskIncrementTick();
#else
    if (xPortGetCoreID() == 0) {
4037a304:	00c256        	bnez	a2, 4037a314 <xPortSysTickHandler+0x1c>
        xSwitchRequired = xTaskIncrementTick();
4037a307:	010725        	call8	4037b378 <xTaskIncrementTick>
    } else {
        xSwitchRequired = xTaskIncrementTickOtherCores();
4037a30a:	202aa0        	or	a2, a10, a10
    }
#endif

    // Check if yield is required
    if (xSwitchRequired != pdFALSE) {
4037a30d:	1a8c      	beqz.n	a10, 4037a312 <xPortSysTickHandler+0x1a>
        portYIELD_FROM_ISR();
4037a30f:	ffbea5        	call8	40379ef8 <_frxt_setup_switch>
    } else {
        traceISR_EXIT();
    }
    return xSwitchRequired;
}
4037a312:	f01d      	retw.n
        xSwitchRequired = xTaskIncrementTickOtherCores();
4037a314:	012fe5        	call8	4037b614 <xTaskIncrementTickOtherCores>
4037a317:	fffbc6        	j	4037a30a <xPortSysTickHandler+0x12>
	...

4037a31c <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
4037a31c:	004136        	entry	a1, 32
    BaseType_t xReturn;
    taskENTER_CRITICAL();
4037a31f:	4cc232        	addi	a3, a2, 76
4037a322:	ffafb2        	movi	a11, -1
4037a325:	20a330        	or	a10, a3, a3
4037a328:	022865        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
4037a32b:	20a330        	or	a10, a3, a3
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
4037a32e:	0020c0        	memw
4037a331:	e248      	l32i.n	a4, a2, 56
4037a333:	030c      	movi.n	a3, 0
    taskEXIT_CRITICAL();
4037a335:	023ae5        	call8	4037c6e4 <vPortExitCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
4037a338:	120c      	movi.n	a2, 1
4037a33a:	932340        	movnez	a2, a3, a4

    return xReturn;
}
4037a33d:	f01d      	retw.n
	...

4037a340 <prvCopyDataToQueue>:
{
4037a340:	004136        	entry	a1, 32
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
4037a343:	1022c2        	l32i	a12, a2, 64
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
4037a346:	0020c0        	memw
4037a349:	0e2252        	l32i	a5, a2, 56
{
4037a34c:	20b330        	or	a11, a3, a3
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
4037a34f:	019c56        	bnez	a12, 4037a36c <prvCopyDataToQueue+0x2c>
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
4037a352:	0238      	l32i.n	a3, a2, 0
    BaseType_t xReturn = pdFALSE;
4037a354:	0c4d      	mov.n	a4, a12
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
4037a356:	73cc      	bnez.n	a3, 4037a361 <prvCopyDataToQueue+0x21>
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
4037a358:	22a8      	l32i.n	a10, a2, 8
4037a35a:	01b525        	call8	4037beac <xTaskPriorityDisinherit>
4037a35d:	0a4d      	mov.n	a4, a10
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
4037a35f:	2239      	s32i.n	a3, a2, 8
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
4037a361:	551b      	addi.n	a5, a5, 1
4037a363:	0020c0        	memw
4037a366:	e259      	s32i.n	a5, a2, 56
}
4037a368:	042d      	mov.n	a2, a4
4037a36a:	f01d      	retw.n
    else if( xPosition == queueSEND_TO_BACK )
4037a36c:	c4dc      	bnez.n	a4, 4037a38c <prvCopyDataToQueue+0x4c>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
4037a36e:	12a8      	l32i.n	a10, a2, 4
4037a370:	e85081        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037a373:	0008e0        	callx8	a8
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
4037a376:	1288      	l32i.n	a8, a2, 4
4037a378:	102232        	l32i	a3, a2, 64
4037a37b:	883a      	add.n	a8, a8, a3
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
4037a37d:	2238      	l32i.n	a3, a2, 8
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
4037a37f:	1289      	s32i.n	a8, a2, 4
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
4037a381:	dc3837        	bltu	a8, a3, 4037a361 <prvCopyDataToQueue+0x21>
            pxQueue->pcWriteTo = pxQueue->pcHead;
4037a384:	0238      	l32i.n	a3, a2, 0
4037a386:	1239      	s32i.n	a3, a2, 4
4037a388:	fff546        	j	4037a361 <prvCopyDataToQueue+0x21>
4037a38b:	00          	.byte 00
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
4037a38c:	32a8      	l32i.n	a10, a2, 12
4037a38e:	e84881        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037a391:	0008e0        	callx8	a8
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
4037a394:	102292        	l32i	a9, a2, 64
4037a397:	3288      	l32i.n	a8, a2, 12
4037a399:	603090        	neg	a3, a9
4037a39c:	c08890        	sub	a8, a8, a9
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
4037a39f:	0298      	l32i.n	a9, a2, 0
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
4037a3a1:	3289      	s32i.n	a8, a2, 12
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
4037a3a3:	05b897        	bgeu	a8, a9, 4037a3ac <prvCopyDataToQueue+0x6c>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
4037a3a6:	2288      	l32i.n	a8, a2, 8
4037a3a8:	883a      	add.n	a8, a8, a3
4037a3aa:	3289      	s32i.n	a8, a2, 12
        if( xPosition == queueOVERWRITE )
4037a3ac:	092466        	bnei	a4, 2, 4037a3b9 <prvCopyDataToQueue+0x79>
    BaseType_t xReturn = pdFALSE;
4037a3af:	040c      	movi.n	a4, 0
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
4037a3b1:	ac1547        	beq	a5, a4, 4037a361 <prvCopyDataToQueue+0x21>
                --uxMessagesWaiting;
4037a3b4:	550b      	addi.n	a5, a5, -1
4037a3b6:	ffe9c6        	j	4037a361 <prvCopyDataToQueue+0x21>
    BaseType_t xReturn = pdFALSE;
4037a3b9:	040c      	movi.n	a4, 0
4037a3bb:	ffe886        	j	4037a361 <prvCopyDataToQueue+0x21>
	...

4037a3c0 <prvNotifyQueueSetContainer>:

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue,
                                                  const BaseType_t xCopyPosition )
    {
4037a3c0:	006136        	entry	a1, 48
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
4037a3c3:	122242        	l32i	a4, a2, 72
    {
4037a3c6:	0129      	s32i.n	a2, a1, 0
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
4037a3c8:	04dc      	bnez.n	a4, 4037a3dc <prvNotifyQueueSetContainer+0x1c>
4037a3ca:	0ba6b2        	movi	a11, 0x60b
4037a3cd:	e9f1d1        	l32r	a13, 40374b94 <_iram_text_start+0x790>
4037a3d0:	e9f2c1        	l32r	a12, 40374b98 <_iram_text_start+0x794>
4037a3d3:	80bbb0        	add	a11, a11, a11

        //Acquire the Queue set's spinlock
        portENTER_CRITICAL(&(pxQueueSetContainer->mux));

        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
4037a3d6:	e9f1a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a3d9:	044325        	call8	4037e80c <__assert_func>
        portENTER_CRITICAL(&(pxQueueSetContainer->mux));
4037a3dc:	4cc462        	addi	a6, a4, 76
4037a3df:	ffafb2        	movi	a11, -1
4037a3e2:	20a660        	or	a10, a6, a6
4037a3e5:	021ca5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
4037a3e8:	0020c0        	memw
4037a3eb:	0e2422        	l32i	a2, a4, 56
4037a3ee:	f458      	l32i.n	a5, a4, 60
4037a3f0:	0c3257        	bltu	a2, a5, 4037a400 <prvNotifyQueueSetContainer+0x40>
4037a3f3:	e9ebd1        	l32r	a13, 40374ba0 <_iram_text_start+0x79c>
4037a3f6:	e9e8c1        	l32r	a12, 40374b98 <_iram_text_start+0x794>
4037a3f9:	e9eab1        	l32r	a11, 40374ba4 <_iram_text_start+0x7a0>
4037a3fc:	fff586        	j	4037a3d6 <prvNotifyQueueSetContainer+0x16>
4037a3ff:	00          	.byte 00

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
4037a400:	0020c0        	memw
4037a403:	0e2482        	l32i	a8, a4, 56
        BaseType_t xReturn = pdFALSE;
4037a406:	020c      	movi.n	a2, 0
        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
4037a408:	2cb857        	bgeu	a8, a5, 4037a438 <prvNotifyQueueSetContainer+0x78>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
4037a40b:	0020c0        	memw
4037a40e:	450452        	l8ui	a5, a4, 69

            traceQUEUE_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
4037a411:	03cd      	mov.n	a12, a3
4037a413:	01bd      	mov.n	a11, a1
4037a415:	20a440        	or	a10, a4, a4
4037a418:	fff265        	call8	4037a340 <prvCopyDataToQueue>
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
4037a41b:	745050        	extui	a5, a5, 0, 8

            if( cTxLock == queueUNLOCKED )
4037a41e:	238500        	sext	a8, a5, 7
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
4037a421:	0a2d      	mov.n	a2, a10
            if( cTxLock == queueUNLOCKED )
4037a423:	190866        	bnei	a8, -1, 4037a440 <prvNotifyQueueSetContainer+0x80>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
4037a426:	0020c0        	memw
4037a429:	9458      	l32i.n	a5, a4, 36
4037a42b:	958c      	beqz.n	a5, 4037a438 <prvNotifyQueueSetContainer+0x78>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
4037a42d:	24c4a2        	addi	a10, a4, 36
4037a430:	0148a5        	call8	4037b8bc <xTaskRemoveFromEventList>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
4037a433:	140c      	movi.n	a4, 1
4037a435:	9324a0        	movnez	a2, a4, a10
        {
            mtCOVERAGE_TEST_MARKER();
        }

        //Release the Queue set's spinlock
        portEXIT_CRITICAL(&(pxQueueSetContainer->mux));
4037a438:	06ad      	mov.n	a10, a6
4037a43a:	022aa5        	call8	4037c6e4 <vPortExitCritical>

        return xReturn;
    }
4037a43d:	f01d      	retw.n
4037a43f:	00          	.byte 00
                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
4037a440:	551b      	addi.n	a5, a5, 1
4037a442:	745050        	extui	a5, a5, 0, 8
4037a445:	0020c0        	memw
4037a448:	454452        	s8i	a5, a4, 69
4037a44b:	fffa46        	j	4037a438 <prvNotifyQueueSetContainer+0x78>
	...

4037a450 <prvCopyDataFromQueue>:
{
4037a450:	004136        	entry	a1, 32
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
4037a453:	1022c2        	l32i	a12, a2, 64
{
4037a456:	03ad      	mov.n	a10, a3
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
4037a458:	5c9c      	beqz.n	a12, 4037a471 <prvCopyDataFromQueue+0x21>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
4037a45a:	3288      	l32i.n	a8, a2, 12
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
4037a45c:	2298      	l32i.n	a9, a2, 8
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
4037a45e:	88ca      	add.n	a8, a8, a12
4037a460:	3289      	s32i.n	a8, a2, 12
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
4037a462:	033897        	bltu	a8, a9, 4037a469 <prvCopyDataFromQueue+0x19>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
4037a465:	0288      	l32i.n	a8, a2, 0
4037a467:	3289      	s32i.n	a8, a2, 12
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
4037a469:	32b8      	l32i.n	a11, a2, 12
4037a46b:	e81181        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037a46e:	0008e0        	callx8	a8
}
4037a471:	f01d      	retw.n
	...

4037a474 <prvUnlockQueue>:
{
4037a474:	004136        	entry	a1, 32
    taskENTER_CRITICAL();
4037a477:	4cc242        	addi	a4, a2, 76
4037a47a:	fb7c      	movi.n	a11, -1
4037a47c:	04ad      	mov.n	a10, a4
4037a47e:	201110        	or	a1, a1, a1
4037a481:	0212e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        int8_t cTxLock = pxQueue->cTxLock;
4037a484:	0020c0        	memw
4037a487:	450232        	l8ui	a3, a2, 69
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037a48a:	24c262        	addi	a6, a2, 36
        int8_t cTxLock = pxQueue->cTxLock;
4037a48d:	743030        	extui	a3, a3, 0, 8
        while( cTxLock > queueLOCKED_UNMODIFIED )
4037a490:	235300        	sext	a5, a3, 7
4037a493:	3a15e6        	bgei	a5, 1, 4037a4d1 <prvUnlockQueue+0x5d>
        pxQueue->cTxLock = queueUNLOCKED;
4037a496:	ffaf32        	movi	a3, -1
4037a499:	0020c0        	memw
4037a49c:	454232        	s8i	a3, a2, 69
    taskEXIT_CRITICAL();
4037a49f:	20a440        	or	a10, a4, a4
4037a4a2:	022425        	call8	4037c6e4 <vPortExitCritical>
4037a4a5:	fb7c      	movi.n	a11, -1
4037a4a7:	04ad      	mov.n	a10, a4
4037a4a9:	021065        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        int8_t cRxLock = pxQueue->cRxLock;
4037a4ac:	0020c0        	memw
4037a4af:	440232        	l8ui	a3, a2, 68
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037a4b2:	10c252        	addi	a5, a2, 16
        int8_t cRxLock = pxQueue->cRxLock;
4037a4b5:	743030        	extui	a3, a3, 0, 8
        while( cRxLock > queueLOCKED_UNMODIFIED )
4037a4b8:	238300        	sext	a8, a3, 7
4037a4bb:	3d18e6        	bgei	a8, 1, 4037a4fc <prvUnlockQueue+0x88>
        pxQueue->cRxLock = queueUNLOCKED;
4037a4be:	ffaf32        	movi	a3, -1
4037a4c1:	0020c0        	memw
4037a4c4:	444232        	s8i	a3, a2, 68
    taskEXIT_CRITICAL();
4037a4c7:	20a440        	or	a10, a4, a4
4037a4ca:	0221a5        	call8	4037c6e4 <vPortExitCritical>
}
4037a4cd:	000090        	retw
4037a4d0:	00          	.byte 00
                    if( pxQueue->pxQueueSetContainer != NULL )
4037a4d1:	122252        	l32i	a5, a2, 72
4037a4d4:	014516        	beqz	a5, 4037a4ec <prvUnlockQueue+0x78>
                        if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
4037a4d7:	00a0b2        	movi	a11, 0
4037a4da:	02ad      	mov.n	a10, a2
4037a4dc:	ffee25        	call8	4037a3c0 <prvNotifyQueueSetContainer>
4037a4df:	1a8c      	beqz.n	a10, 4037a4e4 <prvUnlockQueue+0x70>
                            vTaskMissedYield();
4037a4e1:	015ea5        	call8	4037bacc <vTaskMissedYield>
            --cTxLock;
4037a4e4:	330b      	addi.n	a3, a3, -1
4037a4e6:	743030        	extui	a3, a3, 0, 8
4037a4e9:	ffe8c6        	j	4037a490 <prvUnlockQueue+0x1c>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
4037a4ec:	0020c0        	memw
4037a4ef:	9258      	l32i.n	a5, a2, 36
4037a4f1:	fa1516        	beqz	a5, 4037a496 <prvUnlockQueue+0x22>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037a4f4:	06ad      	mov.n	a10, a6
4037a4f6:	013c65        	call8	4037b8bc <xTaskRemoveFromEventList>
4037a4f9:	fff886        	j	4037a4df <prvUnlockQueue+0x6b>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
4037a4fc:	0020c0        	memw
4037a4ff:	042282        	l32i	a8, a2, 16
4037a502:	fb8816        	beqz	a8, 4037a4be <prvUnlockQueue+0x4a>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037a505:	20a550        	or	a10, a5, a5
4037a508:	013b25        	call8	4037b8bc <xTaskRemoveFromEventList>
4037a50b:	1a8c      	beqz.n	a10, 4037a510 <prvUnlockQueue+0x9c>
                    vTaskMissedYield();
4037a50d:	015be5        	call8	4037bacc <vTaskMissedYield>
                --cRxLock;
4037a510:	330b      	addi.n	a3, a3, -1
4037a512:	743030        	extui	a3, a3, 0, 8
4037a515:	ffe7c6        	j	4037a4b8 <prvUnlockQueue+0x44>

4037a518 <xQueueGenericReset>:
{
4037a518:	004136        	entry	a1, 32
    configASSERT( pxQueue );
4037a51b:	00e256        	bnez	a2, 4037a52d <xQueueGenericReset+0x15>
4037a51e:	e9a2d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037a521:	e9a2c1        	l32r	a12, 40374bac <_iram_text_start+0x7a8>
4037a524:	e99ea1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a527:	26a1b2        	movi	a11, 0x126
4037a52a:	042e25        	call8	4037e80c <__assert_func>
    if( xNewQueue == pdTRUE )
4037a52d:	0a1366        	bnei	a3, 1, 4037a53b <xQueueGenericReset+0x23>
    lock->owner = SPINLOCK_FREE;
4037a530:	e96b41        	l32r	a4, 40374adc <_iram_text_start+0x6d8>
4037a533:	136242        	s32i	a4, a2, 76
    lock->count = 0;
4037a536:	040c      	movi.n	a4, 0
4037a538:	146242        	s32i	a4, a2, 80
    taskENTER_CRITICAL();
4037a53b:	4cc242        	addi	a4, a2, 76
4037a53e:	ffafb2        	movi	a11, -1
4037a541:	04ad      	mov.n	a10, a4
4037a543:	0206e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a546:	1022a2        	l32i	a10, a2, 64
4037a549:	f288      	l32i.n	a8, a2, 60
4037a54b:	0298      	l32i.n	a9, a2, 0
4037a54d:	828a80        	mull	a8, a10, a8
        pxQueue->pcWriteTo = pxQueue->pcHead;
4037a550:	1299      	s32i.n	a9, a2, 4
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a552:	b98a      	add.n	a11, a9, a8
4037a554:	22b9      	s32i.n	a11, a2, 8
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a556:	c088a0        	sub	a8, a8, a10
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
4037a559:	0b0c      	movi.n	a11, 0
4037a55b:	0020c0        	memw
4037a55e:	e2b9      	s32i.n	a11, a2, 56
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a560:	998a      	add.n	a9, a9, a8
        pxQueue->cRxLock = queueUNLOCKED;
4037a562:	f87c      	movi.n	a8, -1
4037a564:	0020c0        	memw
4037a567:	444282        	s8i	a8, a2, 68
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a56a:	3299      	s32i.n	a9, a2, 12
        pxQueue->cTxLock = queueUNLOCKED;
4037a56c:	0020c0        	memw
4037a56f:	454282        	s8i	a8, a2, 69
        if( xNewQueue == pdFALSE )
4037a572:	2693b7        	bne	a3, a11, 4037a59c <xQueueGenericReset+0x84>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
4037a575:	0020c0        	memw
4037a578:	4238      	l32i.n	a3, a2, 16
4037a57a:	1013b7        	beq	a3, a11, 4037a58e <xQueueGenericReset+0x76>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037a57d:	10c2a2        	addi	a10, a2, 16
4037a580:	0133a5        	call8	4037b8bc <xTaskRemoveFromEventList>
4037a583:	7a8c      	beqz.n	a10, 4037a58e <xQueueGenericReset+0x76>
4037a585:	03eba0        	rsr.prid	a10
4037a588:	04ada0        	extui	a10, a10, 13, 1
                    queueYIELD_IF_USING_PREEMPTION();
4037a58b:	fdab65        	call8	40378040 <esp_crosscore_int_send_yield>
    taskEXIT_CRITICAL();
4037a58e:	20a440        	or	a10, a4, a4
4037a591:	021525        	call8	4037c6e4 <vPortExitCritical>
}
4037a594:	01a022        	movi	a2, 1
4037a597:	000090        	retw
4037a59a:	00          	.byte 00
4037a59b:	00          	.byte 00
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
4037a59c:	10c2a2        	addi	a10, a2, 16
4037a59f:	01e6e5        	call8	4037c40c <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
4037a5a2:	24c2a2        	addi	a10, a2, 36
4037a5a5:	01e665        	call8	4037c40c <vListInitialise>
4037a5a8:	fff886        	j	4037a58e <xQueueGenericReset+0x76>
	...

4037a5ac <xQueueGenericCreateStatic>:
    {
4037a5ac:	006136        	entry	a1, 48
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
4037a5af:	00e256        	bnez	a2, 4037a5c1 <xQueueGenericCreateStatic+0x15>
4037a5b2:	e97fd1        	l32r	a13, 40374bb0 <_iram_text_start+0x7ac>
4037a5b5:	e97fc1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0>
4037a5b8:	68a1b2        	movi	a11, 0x168
        configASSERT( pxStaticQueue != NULL );
4037a5bb:	e978a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a5be:	0424e5        	call8	4037e80c <__assert_func>
4037a5c1:	d5cc      	bnez.n	a5, 4037a5d2 <xQueueGenericCreateStatic+0x26>
4037a5c3:	e97dd1        	l32r	a13, 40374bb8 <_iram_text_start+0x7b4>
4037a5c6:	e97bc1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0>
4037a5c9:	6ca1b2        	movi	a11, 0x16c
4037a5cc:	fffac6        	j	4037a5bb <xQueueGenericCreateStatic+0xf>
4037a5cf:	00          	.byte 00
4037a5d0:	00          	.byte 00
4037a5d1:	00          	.byte 00
        configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
4037a5d2:	180c      	movi.n	a8, 1
4037a5d4:	090c      	movi.n	a9, 0
4037a5d6:	839840        	moveqz	a9, a8, a4
4037a5d9:	74a090        	extui	a10, a9, 0, 8
4037a5dc:	19dc      	bnez.n	a9, 4037a5f1 <xQueueGenericCreateStatic+0x45>
4037a5de:	0a9d      	mov.n	a9, a10
4037a5e0:	939830        	movnez	a9, a8, a3
4037a5e3:	a9cc      	bnez.n	a9, 4037a5f1 <xQueueGenericCreateStatic+0x45>
4037a5e5:	e975d1        	l32r	a13, 40374bbc <_iram_text_start+0x7b8>
4037a5e8:	e973c1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0>
4037a5eb:	70a1b2        	movi	a11, 0x170
4037a5ee:	fff246        	j	4037a5bb <xQueueGenericCreateStatic+0xf>
        configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
4037a5f1:	090c      	movi.n	a9, 0
4037a5f3:	939840        	movnez	a9, a8, a4
4037a5f6:	74a090        	extui	a10, a9, 0, 8
4037a5f9:	f9cc      	bnez.n	a9, 4037a60c <xQueueGenericCreateStatic+0x60>
4037a5fb:	938a30        	movnez	a8, a10, a3
4037a5fe:	a8cc      	bnez.n	a8, 4037a60c <xQueueGenericCreateStatic+0x60>
4037a600:	e970d1        	l32r	a13, 40374bc0 <_iram_text_start+0x7bc>
4037a603:	e96cc1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0>
4037a606:	71a1b2        	movi	a11, 0x171
4037a609:	ffeb86        	j	4037a5bb <xQueueGenericCreateStatic+0xf>
                volatile size_t xSize = sizeof( StaticQueue_t );
4037a60c:	485c      	movi.n	a8, 84
4037a60e:	0020c0        	memw
4037a611:	0189      	s32i.n	a8, a1, 0
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
4037a613:	0020c0        	memw
4037a616:	0198      	l32i.n	a9, a1, 0
4037a618:	0c1987        	beq	a9, a8, 4037a628 <xQueueGenericCreateStatic+0x7c>
4037a61b:	e96ad1        	l32r	a13, 40374bc4 <_iram_text_start+0x7c0>
4037a61e:	e965c1        	l32r	a12, 40374bb4 <_iram_text_start+0x7b0>
4037a621:	7ba1b2        	movi	a11, 0x17b
4037a624:	ffe4c6        	j	4037a5bb <xQueueGenericCreateStatic+0xf>
4037a627:	00          	.byte 00
                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
4037a628:	0020c0        	memw
4037a62b:	002182        	l32i	a8, a1, 0
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
4037a62e:	01a082        	movi	a8, 1
    if( uxItemSize == ( UBaseType_t ) 0 )
4037a631:	834530        	moveqz	a4, a5, a3
    pxNewQueue->uxLength = uxQueueLength;
4037a634:	0f6522        	s32i	a2, a5, 60
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
4037a637:	464582        	s8i	a8, a5, 70
    if( uxItemSize == ( UBaseType_t ) 0 )
4037a63a:	0549      	s32i.n	a4, a5, 0
    pxNewQueue->uxItemSize = uxItemSize;
4037a63c:	106532        	s32i	a3, a5, 64
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
4037a63f:	1b0c      	movi.n	a11, 1
4037a641:	05ad      	mov.n	a10, a5
4037a643:	ffed65        	call8	4037a518 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
4037a646:	020c      	movi.n	a2, 0
4037a648:	126522        	s32i	a2, a5, 72
    }
4037a64b:	052d      	mov.n	a2, a5
4037a64d:	f01d      	retw.n
	...

4037a650 <xQueueGenericCreate>:
    {
4037a650:	004136        	entry	a1, 32
4037a653:	024d      	mov.n	a4, a2
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
4037a655:	02dc      	bnez.n	a2, 4037a669 <xQueueGenericCreate+0x19>
4037a657:	e956d1        	l32r	a13, 40374bb0 <_iram_text_start+0x7ac>
4037a65a:	e95bc1        	l32r	a12, 40374bc8 <_iram_text_start+0x7c4>
4037a65d:	a8a1b2        	movi	a11, 0x1a8
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
4037a660:	e94fa1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a663:	201110        	or	a1, a1, a1
4037a666:	041a65        	call8	4037e80c <__assert_func>
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037a669:	82a230        	mull	a10, a2, a3
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
4037a66c:	23ac      	beqz.n	a3, 4037a692 <xQueueGenericCreate+0x42>
4037a66e:	c22a30        	quou	a2, a10, a3
4037a671:	0b1247        	beq	a2, a4, 4037a680 <xQueueGenericCreate+0x30>
4037a674:	e956d1        	l32r	a13, 40374bcc <_iram_text_start+0x7c8>
4037a677:	e954c1        	l32r	a12, 40374bc8 <_iram_text_start+0x7c4>
4037a67a:	b8a1b2        	movi	a11, 0x1b8
4037a67d:	fff7c6        	j	4037a660 <xQueueGenericCreate+0x10>
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) > xQueueSizeInBytes );
4037a680:	abaf22        	movi	a2, -85
4037a683:	0bb2a7        	bgeu	a2, a10, 4037a692 <xQueueGenericCreate+0x42>
4037a686:	e952d1        	l32r	a13, 40374bd0 <_iram_text_start+0x7cc>
4037a689:	e94fc1        	l32r	a12, 40374bc8 <_iram_text_start+0x7c4>
4037a68c:	bba1b2        	movi	a11, 0x1bb
4037a68f:	fff346        	j	4037a660 <xQueueGenericCreate+0x10>
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
4037a692:	54caa2        	addi	a10, a10, 84
4037a695:	042765        	call8	4037e90c <malloc>
4037a698:	202aa0        	or	a2, a10, a10
        if( pxNewQueue != NULL )
4037a69b:	021a16        	beqz	a10, 4037a6c0 <xQueueGenericCreate+0x70>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
4037a69e:	00a082        	movi	a8, 0
4037a6a1:	464a82        	s8i	a8, a10, 70
    if( uxItemSize == ( UBaseType_t ) 0 )
4037a6a4:	0a8d      	mov.n	a8, a10
4037a6a6:	002316        	beqz	a3, 4037a6ac <xQueueGenericCreate+0x5c>
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
4037a6a9:	54ca82        	addi	a8, a10, 84
    pxNewQueue->uxItemSize = uxItemSize;
4037a6ac:	106232        	s32i	a3, a2, 64
4037a6af:	0289      	s32i.n	a8, a2, 0
    pxNewQueue->uxLength = uxQueueLength;
4037a6b1:	f249      	s32i.n	a4, a2, 60
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
4037a6b3:	1b0c      	movi.n	a11, 1
4037a6b5:	02ad      	mov.n	a10, a2
            pxNewQueue->pxQueueSetContainer = NULL;
4037a6b7:	00a032        	movi	a3, 0
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
4037a6ba:	ffe5e5        	call8	4037a518 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
4037a6bd:	126232        	s32i	a3, a2, 72
    }
4037a6c0:	f01d      	retw.n
	...

4037a6c4 <xQueueGetMutexHolder>:
    {
4037a6c4:	004136        	entry	a1, 32
        taskENTER_CRITICAL();
4037a6c7:	4cc242        	addi	a4, a2, 76
4037a6ca:	ffafb2        	movi	a11, -1
4037a6cd:	20a440        	or	a10, a4, a4
4037a6d0:	01ede5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
4037a6d3:	002282        	l32i	a8, a2, 0
                pxReturn = NULL;
4037a6d6:	030c      	movi.n	a3, 0
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
4037a6d8:	019837        	bne	a8, a3, 4037a6dd <xQueueGetMutexHolder+0x19>
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
4037a6db:	2238      	l32i.n	a3, a2, 8
        taskEXIT_CRITICAL();
4037a6dd:	20a440        	or	a10, a4, a4
4037a6e0:	020025        	call8	4037c6e4 <vPortExitCritical>
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
4037a6e3:	202330        	or	a2, a3, a3
4037a6e6:	000090        	retw
4037a6e9:	000000        	ill

4037a6ec <xQueueGenericSend>:
{
4037a6ec:	008136        	entry	a1, 64
4037a6ef:	4149      	s32i.n	a4, a1, 16
4037a6f1:	027d      	mov.n	a7, a2
    configASSERT( pxQueue );
4037a6f3:	00e256        	bnez	a2, 4037a705 <xQueueGenericSend+0x19>
4037a6f6:	e92cd1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037a6f9:	e936c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0>
4037a6fc:	3ba3b2        	movi	a11, 0x33b
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
4037a6ff:	e927a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a702:	0410a5        	call8	4037e80c <__assert_func>
4037a705:	f3cc      	bnez.n	a3, 4037a718 <xQueueGenericSend+0x2c>
4037a707:	102222        	l32i	a2, a2, 64
4037a70a:	a28c      	beqz.n	a2, 4037a718 <xQueueGenericSend+0x2c>
4037a70c:	e933d1        	l32r	a13, 40374bd8 <_iram_text_start+0x7d4>
4037a70f:	e931c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0>
4037a712:	3ca3b2        	movi	a11, 0x33c
4037a715:	fff986        	j	4037a6ff <xQueueGenericSend+0x13>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
4037a718:	102566        	bnei	a5, 2, 4037a72c <xQueueGenericSend+0x40>
4037a71b:	f728      	l32i.n	a2, a7, 60
4037a71d:	0b1226        	beqi	a2, 1, 4037a72c <xQueueGenericSend+0x40>
4037a720:	e92fd1        	l32r	a13, 40374bdc <_iram_text_start+0x7d8>
4037a723:	e92cc1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0>
4037a726:	3da3b2        	movi	a11, 0x33d
4037a729:	fff486        	j	4037a6ff <xQueueGenericSend+0x13>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
4037a72c:	0154a5        	call8	4037bc78 <xTaskGetSchedulerState>
4037a72f:	012a56        	bnez	a10, 4037a745 <xQueueGenericSend+0x59>
4037a732:	042122        	l32i	a2, a1, 16
4037a735:	00c216        	beqz	a2, 4037a745 <xQueueGenericSend+0x59>
4037a738:	e92ad1        	l32r	a13, 40374be0 <_iram_text_start+0x7dc>
4037a73b:	e926c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0>
4037a73e:	40a3b2        	movi	a11, 0x340
4037a741:	ffee86        	j	4037a6ff <xQueueGenericSend+0x13>
4037a744:	00          	.byte 00
    configASSERT(pxQueue->uxQueueType != queueQUEUE_IS_MUTEX
4037a745:	0728      	l32i.n	a2, a7, 0
4037a747:	065216        	beqz	a2, 4037a7b0 <xQueueGenericSend+0xc4>
{
4037a74a:	00a092        	movi	a9, 0
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
4037a74d:	fec522        	addi	a2, a5, -2
4037a750:	01a062        	movi	a6, 1
4037a753:	936920        	movnez	a6, a9, a2
        taskENTER_CRITICAL();
4037a756:	4cc742        	addi	a4, a7, 76
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
4037a759:	746060        	extui	a6, a6, 0, 8
        prvLockQueue( pxQueue );
4037a75c:	092d      	mov.n	a2, a9
4037a75e:	fb7c      	movi.n	a11, -1
4037a760:	04ad      	mov.n	a10, a4
4037a762:	056192        	s32i	a9, a1, 20
4037a765:	01e4a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
4037a768:	0020c0        	memw
4037a76b:	e7b8      	l32i.n	a11, a7, 56
4037a76d:	f7a8      	l32i.n	a10, a7, 60
4037a76f:	5198      	l32i.n	a9, a1, 20
4037a771:	023ba7        	bltu	a11, a10, 4037a777 <xQueueGenericSend+0x8b>
4037a774:	064616        	beqz	a6, 4037a7dc <xQueueGenericSend+0xf0>
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
4037a777:	03bd      	mov.n	a11, a3
4037a779:	05cd      	mov.n	a12, a5
4037a77b:	07ad      	mov.n	a10, a7
                        UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
4037a77d:	0020c0        	memw
4037a780:	e728      	l32i.n	a2, a7, 56
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
4037a782:	ffbbe5        	call8	4037a340 <prvCopyDataToQueue>
                        if( pxQueue->pxQueueSetContainer != NULL )
4037a785:	122732        	l32i	a3, a7, 72
4037a788:	03c316        	beqz	a3, 4037a7c8 <xQueueGenericSend+0xdc>
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
4037a78b:	001216        	beqz	a2, 4037a790 <xQueueGenericSend+0xa4>
4037a78e:	46dc      	bnez.n	a6, 4037a7a6 <xQueueGenericSend+0xba>
                            else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
4037a790:	05bd      	mov.n	a11, a5
4037a792:	07ad      	mov.n	a10, a7
4037a794:	201110        	or	a1, a1, a1
4037a797:	ffc2a5        	call8	4037a3c0 <prvNotifyQueueSetContainer>
                            else if( xYieldRequired != pdFALSE )
4037a79a:	008a16        	beqz	a10, 4037a7a6 <xQueueGenericSend+0xba>
4037a79d:	03eba0        	rsr.prid	a10
4037a7a0:	04ada0        	extui	a10, a10, 13, 1
                                queueYIELD_IF_USING_PREEMPTION();
4037a7a3:	fd89e5        	call8	40378040 <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL();
4037a7a6:	20a440        	or	a10, a4, a4
4037a7a9:	01f3a5        	call8	4037c6e4 <vPortExitCritical>
                return pdPASS;
4037a7ac:	120c      	movi.n	a2, 1
}
4037a7ae:	f01d      	retw.n
    configASSERT(pxQueue->uxQueueType != queueQUEUE_IS_MUTEX
4037a7b0:	2728      	l32i.n	a2, a7, 8
4037a7b2:	f94216        	beqz	a2, 4037a74a <xQueueGenericSend+0x5e>
4037a7b5:	0132e5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
4037a7b8:	8e12a7        	beq	a2, a10, 4037a74a <xQueueGenericSend+0x5e>
4037a7bb:	e90ad1        	l32r	a13, 40374be4 <_iram_text_start+0x7e0>
4037a7be:	e905c1        	l32r	a12, 40374bd4 <_iram_text_start+0x7d0>
4037a7c1:	45a3b2        	movi	a11, 0x345
4037a7c4:	ffcdc6        	j	4037a6ff <xQueueGenericSend+0x13>
4037a7c7:	00          	.byte 00
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
4037a7c8:	0020c0        	memw
4037a7cb:	9728      	l32i.n	a2, a7, 36
4037a7cd:	fc9216        	beqz	a2, 4037a79a <xQueueGenericSend+0xae>
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037a7d0:	24c7a2        	addi	a10, a7, 36
4037a7d3:	010ea5        	call8	4037b8bc <xTaskRemoveFromEventList>
4037a7d6:	fff006        	j	4037a79a <xQueueGenericSend+0xae>
4037a7d9:	00          	.byte 00
4037a7da:	00          	.byte 00
4037a7db:	00          	.byte 00
                if( xTicksToWait == ( TickType_t ) 0 )
4037a7dc:	0421a2        	l32i	a10, a1, 16
4037a7df:	00ba56        	bnez	a10, 4037a7ee <xQueueGenericSend+0x102>
            taskEXIT_CRITICAL();
4037a7e2:	20a440        	or	a10, a4, a4
4037a7e5:	01efe5        	call8	4037c6e4 <vPortExitCritical>
            return errQUEUE_FULL;
4037a7e8:	020c      	movi.n	a2, 0
4037a7ea:	fff006        	j	4037a7ae <xQueueGenericSend+0xc2>
4037a7ed:	00          	.byte 00
                else if( xEntryTimeSet == pdFALSE )
4037a7ee:	39cc      	bnez.n	a9, 4037a7f5 <xQueueGenericSend+0x109>
                    vTaskInternalSetTimeOutState( &xTimeOut );
4037a7f0:	01ad      	mov.n	a10, a1
4037a7f2:	011de5        	call8	4037b9d0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
4037a7f5:	04ad      	mov.n	a10, a4
4037a7f7:	01eee5        	call8	4037c6e4 <vPortExitCritical>
4037a7fa:	fb7c      	movi.n	a11, -1
4037a7fc:	04ad      	mov.n	a10, a4
4037a7fe:	01db25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037a801:	fb7c      	movi.n	a11, -1
4037a803:	20a440        	or	a10, a4, a4
4037a806:	01daa5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        prvLockQueue( pxQueue );
4037a809:	0020c0        	memw
4037a80c:	440792        	l8ui	a9, a7, 68
4037a80f:	239900        	sext	a9, a9, 7
4037a812:	050966        	bnei	a9, -1, 4037a81b <xQueueGenericSend+0x12f>
4037a815:	0020c0        	memw
4037a818:	444722        	s8i	a2, a7, 68
4037a81b:	0020c0        	memw
4037a81e:	450792        	l8ui	a9, a7, 69
4037a821:	239900        	sext	a9, a9, 7
4037a824:	050966        	bnei	a9, -1, 4037a82d <xQueueGenericSend+0x141>
4037a827:	0020c0        	memw
4037a82a:	454722        	s8i	a2, a7, 69
4037a82d:	04ad      	mov.n	a10, a4
4037a82f:	01eb65        	call8	4037c6e4 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
4037a832:	10c1b2        	addi	a11, a1, 16
4037a835:	01ad      	mov.n	a10, a1
4037a837:	011d65        	call8	4037ba0c <xTaskCheckForTimeOut>
4037a83a:	036a56        	bnez	a10, 4037a874 <xQueueGenericSend+0x188>
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
4037a83d:	0020c0        	memw
4037a840:	e7a8      	l32i.n	a10, a7, 56
4037a842:	f798      	l32i.n	a9, a7, 60
4037a844:	0e1a97        	beq	a10, a9, 4037a856 <xQueueGenericSend+0x16a>
                prvUnlockQueue( pxQueue );
4037a847:	07ad      	mov.n	a10, a7
4037a849:	ffc2a5        	call8	4037a474 <prvUnlockQueue>
                taskEXIT_CRITICAL();
4037a84c:	04ad      	mov.n	a10, a4
4037a84e:	01e965        	call8	4037c6e4 <vPortExitCritical>
{
4037a851:	190c      	movi.n	a9, 1
4037a853:	ffc1c6        	j	4037a75e <xQueueGenericSend+0x72>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
4037a856:	41b8      	l32i.n	a11, a1, 16
4037a858:	10c7a2        	addi	a10, a7, 16
4037a85b:	010165        	call8	4037b870 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
4037a85e:	07ad      	mov.n	a10, a7
4037a860:	ffc125        	call8	4037a474 <prvUnlockQueue>
                taskEXIT_CRITICAL();
4037a863:	04ad      	mov.n	a10, a4
4037a865:	01e7e5        	call8	4037c6e4 <vPortExitCritical>
4037a868:	03eba0        	rsr.prid	a10
4037a86b:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037a86e:	fd7d25        	call8	40378040 <esp_crosscore_int_send_yield>
4037a871:	fff706        	j	4037a851 <xQueueGenericSend+0x165>
            prvUnlockQueue( pxQueue );
4037a874:	07ad      	mov.n	a10, a7
4037a876:	ffbfe5        	call8	4037a474 <prvUnlockQueue>
4037a879:	ffd946        	j	4037a7e2 <xQueueGenericSend+0xf6>

4037a87c <xQueueCreateMutexStatic>:
    {
4037a87c:	004136        	entry	a1, 32
        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
4037a87f:	00a0c2        	movi	a12, 0
4037a882:	74e020        	extui	a14, a2, 0, 8
4037a885:	20d330        	or	a13, a3, a3
4037a888:	0cbd      	mov.n	a11, a12
4037a88a:	01a0a2        	movi	a10, 1
4037a88d:	ffd1e5        	call8	4037a5ac <xQueueGenericCreateStatic>
4037a890:	0a2d      	mov.n	a2, a10
        if( pxNewQueue != NULL )
4037a892:	6a9c      	beqz.n	a10, 4037a8ac <xQueueCreateMutexStatic+0x30>
    lock->owner = SPINLOCK_FREE;
4037a894:	e89281        	l32r	a8, 40374adc <_iram_text_start+0x6d8>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
4037a897:	0b0c      	movi.n	a11, 0
4037a899:	2ab9      	s32i.n	a11, a10, 8
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
4037a89b:	0ab9      	s32i.n	a11, a10, 0
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
4037a89d:	3ab9      	s32i.n	a11, a10, 12
4037a89f:	136a82        	s32i	a8, a10, 76
    lock->count = 0;
4037a8a2:	146ab2        	s32i	a11, a10, 80
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
4037a8a5:	0bdd      	mov.n	a13, a11
4037a8a7:	0bcd      	mov.n	a12, a11
4037a8a9:	ffe425        	call8	4037a6ec <xQueueGenericSend>
    }
4037a8ac:	f01d      	retw.n
	...

4037a8b0 <xQueueGiveMutexRecursive>:
    {
4037a8b0:	004136        	entry	a1, 32
        configASSERT( pxMutex );
4037a8b3:	00e256        	bnez	a2, 4037a8c5 <xQueueGiveMutexRecursive+0x15>
4037a8b6:	e8ccd1        	l32r	a13, 40374be8 <_iram_text_start+0x7e4>
4037a8b9:	e8ccc1        	l32r	a12, 40374bec <_iram_text_start+0x7e8>
4037a8bc:	e8b8a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a8bf:	9ca2b2        	movi	a11, 0x29c
4037a8c2:	03f4a5        	call8	4037e80c <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
4037a8c5:	2248      	l32i.n	a4, a2, 8
4037a8c7:	0121e5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
            xReturn = pdFAIL;
4037a8ca:	00a032        	movi	a3, 0
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
4037a8cd:	1394a7        	bne	a4, a10, 4037a8e4 <xQueueGiveMutexRecursive+0x34>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
4037a8d0:	32b8      	l32i.n	a11, a2, 12
            xReturn = pdPASS;
4037a8d2:	130c      	movi.n	a3, 1
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
4037a8d4:	bb0b      	addi.n	a11, a11, -1
4037a8d6:	32b9      	s32i.n	a11, a2, 12
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
4037a8d8:	8bcc      	bnez.n	a11, 4037a8e4 <xQueueGiveMutexRecursive+0x34>
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
4037a8da:	0bdd      	mov.n	a13, a11
4037a8dc:	0bcd      	mov.n	a12, a11
4037a8de:	20a220        	or	a10, a2, a2
4037a8e1:	ffe0a5        	call8	4037a6ec <xQueueGenericSend>
    }
4037a8e4:	032d      	mov.n	a2, a3
4037a8e6:	f01d      	retw.n

4037a8e8 <xQueueCreateMutex>:
    {
4037a8e8:	004136        	entry	a1, 32
        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
4037a8eb:	74c020        	extui	a12, a2, 0, 8
4037a8ee:	00a0b2        	movi	a11, 0
4037a8f1:	01a0a2        	movi	a10, 1
4037a8f4:	ffd5a5        	call8	4037a650 <xQueueGenericCreate>
4037a8f7:	202aa0        	or	a2, a10, a10
        if( pxNewQueue != NULL )
4037a8fa:	6a9c      	beqz.n	a10, 4037a914 <xQueueCreateMutex+0x2c>
    lock->owner = SPINLOCK_FREE;
4037a8fc:	e87881        	l32r	a8, 40374adc <_iram_text_start+0x6d8>
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
4037a8ff:	0b0c      	movi.n	a11, 0
4037a901:	2ab9      	s32i.n	a11, a10, 8
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
4037a903:	0ab9      	s32i.n	a11, a10, 0
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
4037a905:	3ab9      	s32i.n	a11, a10, 12
4037a907:	136a82        	s32i	a8, a10, 76
    lock->count = 0;
4037a90a:	146ab2        	s32i	a11, a10, 80
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
4037a90d:	0bdd      	mov.n	a13, a11
4037a90f:	0bcd      	mov.n	a12, a11
4037a911:	ffdda5        	call8	4037a6ec <xQueueGenericSend>
    }
4037a914:	f01d      	retw.n
	...

4037a918 <xQueueGenericSendFromISR>:
{
4037a918:	006136        	entry	a1, 48
4037a91b:	026d      	mov.n	a6, a2
    configASSERT( pxQueue );
4037a91d:	d2cc      	bnez.n	a2, 4037a92e <xQueueGenericSendFromISR+0x16>
4037a91f:	e8a2d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037a922:	e8b3c1        	l32r	a12, 40374bf0 <_iram_text_start+0x7ec>
4037a925:	26a4b2        	movi	a11, 0x426
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
4037a928:	e89da1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037a92b:	03ee25        	call8	4037e80c <__assert_func>
4037a92e:	23dc      	bnez.n	a3, 4037a944 <xQueueGenericSendFromISR+0x2c>
4037a930:	102222        	l32i	a2, a2, 64
4037a933:	d28c      	beqz.n	a2, 4037a944 <xQueueGenericSendFromISR+0x2c>
4037a935:	e8a8d1        	l32r	a13, 40374bd8 <_iram_text_start+0x7d4>
4037a938:	e8aec1        	l32r	a12, 40374bf0 <_iram_text_start+0x7ec>
4037a93b:	27a4b2        	movi	a11, 0x427
4037a93e:	fff986        	j	4037a928 <xQueueGenericSendFromISR+0x10>
4037a941:	00          	.byte 00
4037a942:	00          	.byte 00
4037a943:	00          	.byte 00
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
4037a944:	102566        	bnei	a5, 2, 4037a958 <xQueueGenericSendFromISR+0x40>
4037a947:	f628      	l32i.n	a2, a6, 60
4037a949:	0b1226        	beqi	a2, 1, 4037a958 <xQueueGenericSendFromISR+0x40>
4037a94c:	e8a4d1        	l32r	a13, 40374bdc <_iram_text_start+0x7d8>
4037a94f:	e8a8c1        	l32r	a12, 40374bf0 <_iram_text_start+0x7ec>
4037a952:	28a4b2        	movi	a11, 0x428
4037a955:	fff3c6        	j	4037a928 <xQueueGenericSendFromISR+0x10>
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a958:	006320        	rsil	a2, 3
        taskENTER_CRITICAL_ISR();
4037a95b:	4cc672        	addi	a7, a6, 76
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037a95e:	fb7c      	movi.n	a11, -1
4037a960:	07ad      	mov.n	a10, a7
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037a962:	0129      	s32i.n	a2, a1, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037a964:	01c4a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
4037a967:	0020c0        	memw
4037a96a:	e698      	l32i.n	a9, a6, 56
4037a96c:	f628      	l32i.n	a2, a6, 60
4037a96e:	0c3927        	bltu	a9, a2, 4037a97e <xQueueGenericSendFromISR+0x66>
4037a971:	020c      	movi.n	a2, 0
4037a973:	fec5a2        	addi	a10, a5, -2
4037a976:	190c      	movi.n	a9, 1
4037a978:	9392a0        	movnez	a9, a2, a10
4037a97b:	5f1927        	beq	a9, a2, 4037a9de <xQueueGenericSendFromISR+0xc6>
            const int8_t cTxLock = pxQueue->cTxLock;
4037a97e:	0020c0        	memw
4037a981:	450622        	l8ui	a2, a6, 69
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
4037a984:	05cd      	mov.n	a12, a5
4037a986:	03bd      	mov.n	a11, a3
4037a988:	06ad      	mov.n	a10, a6
            const int8_t cTxLock = pxQueue->cTxLock;
4037a98a:	742020        	extui	a2, a2, 0, 8
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
4037a98d:	ff9b25        	call8	4037a340 <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
4037a990:	238200        	sext	a8, a2, 7
4037a993:	570866        	bnei	a8, -1, 4037a9ee <xQueueGenericSendFromISR+0xd6>
                        if( pxQueue->pxQueueSetContainer != NULL )
4037a996:	122682        	l32i	a8, a6, 72
4037a999:	089c      	beqz.n	a8, 4037a9ad <xQueueGenericSendFromISR+0x95>
                            if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
4037a99b:	05bd      	mov.n	a11, a5
4037a99d:	06ad      	mov.n	a10, a6
4037a99f:	ffa225        	call8	4037a3c0 <prvNotifyQueueSetContainer>
                                if( pxHigherPriorityTaskWoken != NULL )
4037a9a2:	048c      	beqz.n	a4, 4037a9a6 <xQueueGenericSendFromISR+0x8e>
4037a9a4:	0afc      	bnez.n	a10, 4037a9d8 <xQueueGenericSendFromISR+0xc0>
            xReturn = pdPASS;
4037a9a6:	120c      	movi.n	a2, 1
4037a9a8:	000c86        	j	4037a9de <xQueueGenericSendFromISR+0xc6>
4037a9ab:	00          	.byte 00
4037a9ac:	00          	.byte 00
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
4037a9ad:	0020c0        	memw
4037a9b0:	092622        	l32i	a2, a6, 36
4037a9b3:	fef216        	beqz	a2, 4037a9a6 <xQueueGenericSendFromISR+0x8e>
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037a9b6:	24c6a2        	addi	a10, a6, 36
4037a9b9:	016182        	s32i	a8, a1, 4
4037a9bc:	00efe5        	call8	4037b8bc <xTaskRemoveFromEventList>
                                    if( pxHigherPriorityTaskWoken != NULL )
4037a9bf:	012182        	l32i	a8, a1, 4
4037a9c2:	120c      	movi.n	a2, 1
4037a9c4:	085d      	mov.n	a5, a8
4037a9c6:	935240        	movnez	a5, a2, a4
4037a9c9:	745050        	extui	a5, a5, 0, 8
4037a9cc:	fd6516        	beqz	a5, 4037a9a6 <xQueueGenericSendFromISR+0x8e>
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037a9cf:	8328a0        	moveqz	a2, a8, a10
                                    if( pxHigherPriorityTaskWoken != NULL )
4037a9d2:	742020        	extui	a2, a2, 0, 8
4037a9d5:	fcd216        	beqz	a2, 4037a9a6 <xQueueGenericSendFromISR+0x8e>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
4037a9d8:	01a022        	movi	a2, 1
4037a9db:	006422        	s32i	a2, a4, 0
        taskEXIT_CRITICAL_ISR();
4037a9de:	20a770        	or	a10, a7, a7
4037a9e1:	01d025        	call8	4037c6e4 <vPortExitCritical>
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037a9e4:	01a8      	l32i.n	a10, a1, 0
4037a9e6:	e88381        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037a9e9:	0008e0        	callx8	a8
}
4037a9ec:	f01d      	retw.n
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
4037a9ee:	221b      	addi.n	a2, a2, 1
4037a9f0:	742020        	extui	a2, a2, 0, 8
4037a9f3:	0020c0        	memw
4037a9f6:	454622        	s8i	a2, a6, 69
4037a9f9:	ffea46        	j	4037a9a6 <xQueueGenericSendFromISR+0x8e>

4037a9fc <xQueueGiveFromISR>:
{
4037a9fc:	004136        	entry	a1, 32
4037a9ff:	024d      	mov.n	a4, a2
    configASSERT( pxQueue );
4037aa01:	02dc      	bnez.n	a2, 4037aa15 <xQueueGiveFromISR+0x19>
4037aa03:	e869d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037aa06:	e87cc1        	l32r	a12, 40374bf8 <_iram_text_start+0x7f4>
4037aa09:	c8a4b2        	movi	a11, 0x4c8
    configASSERT( pxQueue->uxItemSize == 0 );
4037aa0c:	e864a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037aa0f:	201110        	or	a1, a1, a1
4037aa12:	03dfa5        	call8	4037e80c <__assert_func>
4037aa15:	102222        	l32i	a2, a2, 64
4037aa18:	a28c      	beqz.n	a2, 4037aa26 <xQueueGiveFromISR+0x2a>
4037aa1a:	e878d1        	l32r	a13, 40374bfc <_iram_text_start+0x7f8>
4037aa1d:	e876c1        	l32r	a12, 40374bf8 <_iram_text_start+0x7f4>
4037aa20:	cca4b2        	movi	a11, 0x4cc
4037aa23:	fff946        	j	4037aa0c <xQueueGiveFromISR+0x10>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
4037aa26:	0428      	l32i.n	a2, a4, 0
4037aa28:	02dc      	bnez.n	a2, 4037aa3c <xQueueGiveFromISR+0x40>
4037aa2a:	2428      	l32i.n	a2, a4, 8
4037aa2c:	c28c      	beqz.n	a2, 4037aa3c <xQueueGiveFromISR+0x40>
4037aa2e:	e874d1        	l32r	a13, 40374c00 <_iram_text_start+0x7fc>
4037aa31:	e871c1        	l32r	a12, 40374bf8 <_iram_text_start+0x7f4>
4037aa34:	d1a4b2        	movi	a11, 0x4d1
4037aa37:	fff446        	j	4037aa0c <xQueueGiveFromISR+0x10>
4037aa3a:	00          	.byte 00
4037aa3b:	00          	.byte 00
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037aa3c:	006360        	rsil	a6, 3
        taskENTER_CRITICAL_ISR();
4037aa3f:	4cc452        	addi	a5, a4, 76
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037aa42:	fb7c      	movi.n	a11, -1
4037aa44:	05ad      	mov.n	a10, a5
4037aa46:	01b6a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
4037aa49:	0020c0        	memw
4037aa4c:	e4a8      	l32i.n	a10, a4, 56
        if( uxMessagesWaiting < pxQueue->uxLength )
4037aa4e:	f478      	l32i.n	a7, a4, 60
            xReturn = errQUEUE_FULL;
4037aa50:	020c      	movi.n	a2, 0
        if( uxMessagesWaiting < pxQueue->uxLength )
4037aa52:	5cba77        	bgeu	a10, a7, 4037aab2 <xQueueGiveFromISR+0xb6>
            const int8_t cTxLock = pxQueue->cTxLock;
4037aa55:	0020c0        	memw
4037aa58:	450492        	l8ui	a9, a4, 69
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
4037aa5b:	aa1b      	addi.n	a10, a10, 1
            const int8_t cTxLock = pxQueue->cTxLock;
4037aa5d:	748090        	extui	a8, a9, 0, 8
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
4037aa60:	0020c0        	memw
4037aa63:	e4a9      	s32i.n	a10, a4, 56
            if( cTxLock == queueUNLOCKED )
4037aa65:	239900        	sext	a9, a9, 7
4037aa68:	560966        	bnei	a9, -1, 4037aac2 <xQueueGiveFromISR+0xc6>
                        if( pxQueue->pxQueueSetContainer != NULL )
4037aa6b:	122472        	l32i	a7, a4, 72
4037aa6e:	131727        	beq	a7, a2, 4037aa85 <xQueueGiveFromISR+0x89>
                            if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
4037aa71:	02bd      	mov.n	a11, a2
4037aa73:	04ad      	mov.n	a10, a4
4037aa75:	ff94a5        	call8	4037a3c0 <prvNotifyQueueSetContainer>
                                if( pxHigherPriorityTaskWoken != NULL )
4037aa78:	021327        	beq	a3, a2, 4037aa7e <xQueueGiveFromISR+0x82>
4037aa7b:	2d9a27        	bne	a10, a2, 4037aaac <xQueueGiveFromISR+0xb0>
            xReturn = pdPASS;
4037aa7e:	120c      	movi.n	a2, 1
4037aa80:	000b86        	j	4037aab2 <xQueueGiveFromISR+0xb6>
4037aa83:	00          	.byte 00
4037aa84:	00          	.byte 00
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
4037aa85:	0020c0        	memw
4037aa88:	092422        	l32i	a2, a4, 36
4037aa8b:	fef216        	beqz	a2, 4037aa7e <xQueueGiveFromISR+0x82>
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037aa8e:	24c4a2        	addi	a10, a4, 36
                                    if( pxHigherPriorityTaskWoken != NULL )
4037aa91:	01a022        	movi	a2, 1
4037aa94:	204770        	or	a4, a7, a7
4037aa97:	934230        	movnez	a4, a2, a3
4037aa9a:	744040        	extui	a4, a4, 0, 8
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037aa9d:	00e1e5        	call8	4037b8bc <xTaskRemoveFromEventList>
                                    if( pxHigherPriorityTaskWoken != NULL )
4037aaa0:	fda416        	beqz	a4, 4037aa7e <xQueueGiveFromISR+0x82>
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
4037aaa3:	8327a0        	moveqz	a2, a7, a10
                                    if( pxHigherPriorityTaskWoken != NULL )
4037aaa6:	742020        	extui	a2, a2, 0, 8
4037aaa9:	fd1216        	beqz	a2, 4037aa7e <xQueueGiveFromISR+0x82>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
4037aaac:	01a022        	movi	a2, 1
4037aaaf:	006322        	s32i	a2, a3, 0
        taskEXIT_CRITICAL_ISR();
4037aab2:	20a550        	or	a10, a5, a5
4037aab5:	01c2e5        	call8	4037c6e4 <vPortExitCritical>
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037aab8:	06ad      	mov.n	a10, a6
4037aaba:	e84e81        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037aabd:	0008e0        	callx8	a8
}
4037aac0:	f01d      	retw.n
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
4037aac2:	881b      	addi.n	a8, a8, 1
4037aac4:	748080        	extui	a8, a8, 0, 8
4037aac7:	0020c0        	memw
4037aaca:	454482        	s8i	a8, a4, 69
4037aacd:	ffeb46        	j	4037aa7e <xQueueGiveFromISR+0x82>

4037aad0 <xQueueSemaphoreTake>:
{
4037aad0:	008136        	entry	a1, 64
4037aad3:	4139      	s32i.n	a3, a1, 16
4037aad5:	024d      	mov.n	a4, a2
    configASSERT( ( pxQueue ) );
4037aad7:	00e256        	bnez	a2, 4037aae9 <xQueueSemaphoreTake+0x19>
4037aada:	e84ad1        	l32r	a13, 40374c04 <_iram_text_start+0x800>
4037aadd:	e84ac1        	l32r	a12, 40374c08 <_iram_text_start+0x804>
4037aae0:	10a6b2        	movi	a11, 0x610
    configASSERT( pxQueue->uxItemSize == 0 );
4037aae3:	e82ea1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037aae6:	03d265        	call8	4037e80c <__assert_func>
4037aae9:	102222        	l32i	a2, a2, 64
4037aaec:	d28c      	beqz.n	a2, 4037aafd <xQueueSemaphoreTake+0x2d>
4037aaee:	e843d1        	l32r	a13, 40374bfc <_iram_text_start+0x7f8>
4037aaf1:	e845c1        	l32r	a12, 40374c08 <_iram_text_start+0x804>
4037aaf4:	14a6b2        	movi	a11, 0x614
4037aaf7:	fffa06        	j	4037aae3 <xQueueSemaphoreTake+0x13>
4037aafa:	00          	.byte 00
4037aafb:	00          	.byte 00
4037aafc:	00          	.byte 00
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
4037aafd:	0117a5        	call8	4037bc78 <xTaskGetSchedulerState>
4037ab00:	205aa0        	or	a5, a10, a10
4037ab03:	013a56        	bnez	a10, 4037ab1a <xQueueSemaphoreTake+0x4a>
4037ab06:	042132        	l32i	a3, a1, 16
4037ab09:	0a2d      	mov.n	a2, a10
4037ab0b:	d38c      	beqz.n	a3, 4037ab1c <xQueueSemaphoreTake+0x4c>
4037ab0d:	e834d1        	l32r	a13, 40374be0 <_iram_text_start+0x7dc>
4037ab10:	e83ec1        	l32r	a12, 40374c08 <_iram_text_start+0x804>
4037ab13:	19a6b2        	movi	a11, 0x619
4037ab16:	fff246        	j	4037aae3 <xQueueSemaphoreTake+0x13>
4037ab19:	00          	.byte 00
4037ab1a:	025d      	mov.n	a5, a2
        taskENTER_CRITICAL();
4037ab1c:	4cc432        	addi	a3, a4, 76
4037ab1f:	002906        	j	4037abc7 <xQueueSemaphoreTake+0xf7>
                if( xTicksToWait == ( TickType_t ) 0 )
4037ab22:	042162        	l32i	a6, a1, 16
4037ab25:	00b656        	bnez	a6, 4037ab34 <xQueueSemaphoreTake+0x64>
                            taskEXIT_CRITICAL();
4037ab28:	20a330        	or	a10, a3, a3
4037ab2b:	01bba5        	call8	4037c6e4 <vPortExitCritical>
                return errQUEUE_EMPTY;
4037ab2e:	020c      	movi.n	a2, 0
4037ab30:	003546        	j	4037ac09 <xQueueSemaphoreTake+0x139>
4037ab33:	00          	.byte 00
                else if( xEntryTimeSet == pdFALSE )
4037ab34:	35cc      	bnez.n	a5, 4037ab3b <xQueueSemaphoreTake+0x6b>
                    vTaskInternalSetTimeOutState( &xTimeOut );
4037ab36:	01ad      	mov.n	a10, a1
4037ab38:	00e965        	call8	4037b9d0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
4037ab3b:	03ad      	mov.n	a10, a3
4037ab3d:	01ba65        	call8	4037c6e4 <vPortExitCritical>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037ab40:	ffafb2        	movi	a11, -1
4037ab43:	20a330        	or	a10, a3, a3
4037ab46:	01a6a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037ab49:	fb7c      	movi.n	a11, -1
4037ab4b:	20a330        	or	a10, a3, a3
4037ab4e:	01a625        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        prvLockQueue( pxQueue );
4037ab51:	0020c0        	memw
4037ab54:	440452        	l8ui	a5, a4, 68
4037ab57:	235500        	sext	a5, a5, 7
4037ab5a:	070566        	bnei	a5, -1, 4037ab65 <xQueueSemaphoreTake+0x95>
4037ab5d:	050c      	movi.n	a5, 0
4037ab5f:	0020c0        	memw
4037ab62:	444452        	s8i	a5, a4, 68
4037ab65:	0020c0        	memw
4037ab68:	450452        	l8ui	a5, a4, 69
4037ab6b:	235500        	sext	a5, a5, 7
4037ab6e:	070566        	bnei	a5, -1, 4037ab79 <xQueueSemaphoreTake+0xa9>
4037ab71:	050c      	movi.n	a5, 0
4037ab73:	0020c0        	memw
4037ab76:	454452        	s8i	a5, a4, 69
4037ab79:	03ad      	mov.n	a10, a3
4037ab7b:	01b6a5        	call8	4037c6e4 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
4037ab7e:	10c1b2        	addi	a11, a1, 16
4037ab81:	01ad      	mov.n	a10, a1
4037ab83:	00e8a5        	call8	4037ba0c <xTaskCheckForTimeOut>
4037ab86:	093a56        	bnez	a10, 4037ac1d <xQueueSemaphoreTake+0x14d>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
4037ab89:	04ad      	mov.n	a10, a4
4037ab8b:	ff7925        	call8	4037a31c <prvIsQueueEmpty>
4037ab8e:	07ca16        	beqz	a10, 4037ac0e <xQueueSemaphoreTake+0x13e>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
4037ab91:	0458      	l32i.n	a5, a4, 0
4037ab93:	25dc      	bnez.n	a5, 4037aba9 <xQueueSemaphoreTake+0xd9>
4037ab95:	fb7c      	movi.n	a11, -1
4037ab97:	03ad      	mov.n	a10, a3
4037ab99:	01a165        	call8	4037c5b0 <xPortEnterCriticalTimeout>
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
4037ab9c:	24a8      	l32i.n	a10, a4, 8
4037ab9e:	0123a5        	call8	4037bdd8 <xTaskPriorityInherit>
4037aba1:	0a2d      	mov.n	a2, a10
                            taskEXIT_CRITICAL();
4037aba3:	20a330        	or	a10, a3, a3
4037aba6:	01b3e5        	call8	4037c6e4 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
4037aba9:	41b8      	l32i.n	a11, a1, 16
4037abab:	24c4a2        	addi	a10, a4, 36
4037abae:	00cc25        	call8	4037b870 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
4037abb1:	04ad      	mov.n	a10, a4
4037abb3:	ff8c25        	call8	4037a474 <prvUnlockQueue>
                taskEXIT_CRITICAL();
4037abb6:	03ad      	mov.n	a10, a3
4037abb8:	01b2a5        	call8	4037c6e4 <vPortExitCritical>
4037abbb:	03eba0        	rsr.prid	a10
4037abbe:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037abc1:	fd47e5        	call8	40378040 <esp_crosscore_int_send_yield>
4037abc4:	01a052        	movi	a5, 1
4037abc7:	ffafb2        	movi	a11, -1
4037abca:	03ad      	mov.n	a10, a3
4037abcc:	019e25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
4037abcf:	0020c0        	memw
4037abd2:	e488      	l32i.n	a8, a4, 56
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
4037abd4:	f4a816        	beqz	a8, 4037ab22 <xQueueSemaphoreTake+0x52>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
4037abd7:	880b      	addi.n	a8, a8, -1
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
4037abd9:	0428      	l32i.n	a2, a4, 0
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
4037abdb:	0020c0        	memw
4037abde:	e489      	s32i.n	a8, a4, 56
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
4037abe0:	004256        	bnez	a2, 4037abe8 <xQueueSemaphoreTake+0x118>
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
4037abe3:	014125        	call8	4037bff4 <pvTaskIncrementMutexHeldCount>
4037abe6:	24a9      	s32i.n	a10, a4, 8
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
4037abe8:	0020c0        	memw
4037abeb:	042422        	l32i	a2, a4, 16
4037abee:	010216        	beqz	a2, 4037ac02 <xQueueSemaphoreTake+0x132>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037abf1:	10c4a2        	addi	a10, a4, 16
4037abf4:	00cc65        	call8	4037b8bc <xTaskRemoveFromEventList>
4037abf7:	7a8c      	beqz.n	a10, 4037ac02 <xQueueSemaphoreTake+0x132>
4037abf9:	03eba0        	rsr.prid	a10
4037abfc:	04ada0        	extui	a10, a10, 13, 1
                        queueYIELD_IF_USING_PREEMPTION();
4037abff:	fd4425        	call8	40378040 <esp_crosscore_int_send_yield>
                taskEXIT_CRITICAL();
4037ac02:	03ad      	mov.n	a10, a3
4037ac04:	01ade5        	call8	4037c6e4 <vPortExitCritical>
                return pdPASS;
4037ac07:	120c      	movi.n	a2, 1
}
4037ac09:	f01d      	retw.n
4037ac0b:	00          	.byte 00
4037ac0c:	00          	.byte 00
4037ac0d:	00          	.byte 00
                prvUnlockQueue( pxQueue );
4037ac0e:	20a440        	or	a10, a4, a4
4037ac11:	ff8625        	call8	4037a474 <prvUnlockQueue>
                taskEXIT_CRITICAL();
4037ac14:	20a330        	or	a10, a3, a3
4037ac17:	01ace5        	call8	4037c6e4 <vPortExitCritical>
4037ac1a:	ffe986        	j	4037abc4 <xQueueSemaphoreTake+0xf4>
            prvUnlockQueue( pxQueue );
4037ac1d:	20a440        	or	a10, a4, a4
4037ac20:	ff8525        	call8	4037a474 <prvUnlockQueue>
            taskEXIT_CRITICAL();
4037ac23:	20a330        	or	a10, a3, a3
4037ac26:	01abe5        	call8	4037c6e4 <vPortExitCritical>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
4037ac29:	20a440        	or	a10, a4, a4
4037ac2c:	ff6ee5        	call8	4037a31c <prvIsQueueEmpty>
4037ac2f:	f91a16        	beqz	a10, 4037abc4 <xQueueSemaphoreTake+0xf4>
                        if( xInheritanceOccurred != pdFALSE )
4037ac32:	fd3216        	beqz	a2, 4037ac09 <xQueueSemaphoreTake+0x139>
4037ac35:	fb7c      	movi.n	a11, -1
4037ac37:	03ad      	mov.n	a10, a3
4037ac39:	019765        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
4037ac3c:	0020c0        	memw
4037ac3f:	94b8      	l32i.n	a11, a4, 36
4037ac41:	7b8c      	beqz.n	a11, 4037ac4c <xQueueSemaphoreTake+0x17c>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
4037ac43:	c428      	l32i.n	a2, a4, 48
4037ac45:	9b1c      	movi.n	a11, 25
4037ac47:	0228      	l32i.n	a2, a2, 0
4037ac49:	c0bb20        	sub	a11, a11, a2
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
4037ac4c:	24a8      	l32i.n	a10, a4, 8
4037ac4e:	013025        	call8	4037bf50 <vTaskPriorityDisinheritAfterTimeout>
4037ac51:	ffb4c6        	j	4037ab28 <xQueueSemaphoreTake+0x58>

4037ac54 <xQueueTakeMutexRecursive>:
    {
4037ac54:	004136        	entry	a1, 32
        configASSERT( pxMutex );
4037ac57:	00e256        	bnez	a2, 4037ac69 <xQueueTakeMutexRecursive+0x15>
4037ac5a:	e7e3d1        	l32r	a13, 40374be8 <_iram_text_start+0x7e4>
4037ac5d:	e7ebc1        	l32r	a12, 40374c0c <_iram_text_start+0x808>
4037ac60:	e7cfa1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037ac63:	d4a2b2        	movi	a11, 0x2d4
4037ac66:	03ba65        	call8	4037e80c <__assert_func>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
4037ac69:	2248      	l32i.n	a4, a2, 8
4037ac6b:	00e7a5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
4037ac6e:	0c94a7        	bne	a4, a10, 4037ac7e <xQueueTakeMutexRecursive+0x2a>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
4037ac71:	3288      	l32i.n	a8, a2, 12
            xReturn = pdPASS;
4037ac73:	1a0c      	movi.n	a10, 1
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
4037ac75:	881b      	addi.n	a8, a8, 1
4037ac77:	3289      	s32i.n	a8, a2, 12
    }
4037ac79:	0a2d      	mov.n	a2, a10
4037ac7b:	f01d      	retw.n
4037ac7d:	00          	.byte 00
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
4037ac7e:	20b330        	or	a11, a3, a3
4037ac81:	20a220        	or	a10, a2, a2
4037ac84:	ffe4a5        	call8	4037aad0 <xQueueSemaphoreTake>
            if( xReturn != pdFAIL )
4037ac87:	feea16        	beqz	a10, 4037ac79 <xQueueTakeMutexRecursive+0x25>
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
4037ac8a:	032282        	l32i	a8, a2, 12
4037ac8d:	881b      	addi.n	a8, a8, 1
4037ac8f:	3289      	s32i.n	a8, a2, 12
        return xReturn;
4037ac91:	fff906        	j	4037ac79 <xQueueTakeMutexRecursive+0x25>

4037ac94 <xQueueReceiveFromISR>:
{
4037ac94:	006136        	entry	a1, 48
4037ac97:	025d      	mov.n	a5, a2
    configASSERT( pxQueue );
4037ac99:	d2cc      	bnez.n	a2, 4037acaa <xQueueReceiveFromISR+0x16>
4037ac9b:	e7c3d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037ac9e:	e7dcc1        	l32r	a12, 40374c10 <_iram_text_start+0x80c>
4037aca1:	97a7b2        	movi	a11, 0x797
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
4037aca4:	e7bea1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037aca7:	03b665        	call8	4037e80c <__assert_func>
4037acaa:	23dc      	bnez.n	a3, 4037acc0 <xQueueReceiveFromISR+0x2c>
4037acac:	102222        	l32i	a2, a2, 64
4037acaf:	d28c      	beqz.n	a2, 4037acc0 <xQueueReceiveFromISR+0x2c>
4037acb1:	e7d8d1        	l32r	a13, 40374c14 <_iram_text_start+0x810>
4037acb4:	e7d7c1        	l32r	a12, 40374c10 <_iram_text_start+0x80c>
4037acb7:	98a7b2        	movi	a11, 0x798
4037acba:	fff986        	j	4037aca4 <xQueueReceiveFromISR+0x10>
4037acbd:	00          	.byte 00
4037acbe:	00          	.byte 00
4037acbf:	00          	.byte 00
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037acc0:	006320        	rsil	a2, 3
        taskENTER_CRITICAL_ISR();
4037acc3:	4cc572        	addi	a7, a5, 76
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037acc6:	fb7c      	movi.n	a11, -1
4037acc8:	07ad      	mov.n	a10, a7
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037acca:	0129      	s32i.n	a2, a1, 0
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037accc:	018e25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
4037accf:	0020c0        	memw
4037acd2:	e588      	l32i.n	a8, a5, 56
            xReturn = pdFAIL;
4037acd4:	020c      	movi.n	a2, 0
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
4037acd6:	2b1827        	beq	a8, a2, 4037ad05 <xQueueReceiveFromISR+0x71>
            prvCopyDataFromQueue( pxQueue, pvBuffer );
4037acd9:	03bd      	mov.n	a11, a3
4037acdb:	05ad      	mov.n	a10, a5
            const int8_t cRxLock = pxQueue->cRxLock;
4037acdd:	0020c0        	memw
4037ace0:	440562        	l8ui	a6, a5, 68
            prvCopyDataFromQueue( pxQueue, pvBuffer );
4037ace3:	1189      	s32i.n	a8, a1, 4
4037ace5:	ff76a5        	call8	4037a450 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
4037ace8:	1188      	l32i.n	a8, a1, 4
            const int8_t cRxLock = pxQueue->cRxLock;
4037acea:	746060        	extui	a6, a6, 0, 8
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
4037aced:	880b      	addi.n	a8, a8, -1
4037acef:	0020c0        	memw
4037acf2:	e589      	s32i.n	a8, a5, 56
            if( cRxLock == queueUNLOCKED )
4037acf4:	238600        	sext	a8, a6, 7
4037acf7:	370866        	bnei	a8, -1, 4037ad32 <xQueueReceiveFromISR+0x9e>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
4037acfa:	0020c0        	memw
4037acfd:	4568      	l32i.n	a6, a5, 16
4037acff:	139627        	bne	a6, a2, 4037ad16 <xQueueReceiveFromISR+0x82>
            xReturn = pdPASS;
4037ad02:	01a022        	movi	a2, 1
        taskEXIT_CRITICAL_ISR();
4037ad05:	20a770        	or	a10, a7, a7
4037ad08:	019da5        	call8	4037c6e4 <vPortExitCritical>
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037ad0b:	0021a2        	l32i	a10, a1, 0
4037ad0e:	e7b981        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037ad11:	0008e0        	callx8	a8
}
4037ad14:	f01d      	retw.n
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037ad16:	10c5a2        	addi	a10, a5, 16
                        if( pxHigherPriorityTaskWoken != NULL )
4037ad19:	026d      	mov.n	a6, a2
4037ad1b:	01a052        	movi	a5, 1
4037ad1e:	936540        	movnez	a6, a5, a4
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
4037ad21:	00b9a5        	call8	4037b8bc <xTaskRemoveFromEventList>
                        if( pxHigherPriorityTaskWoken != NULL )
4037ad24:	fda616        	beqz	a6, 4037ad02 <xQueueReceiveFromISR+0x6e>
4037ad27:	9325a0        	movnez	a2, a5, a10
4037ad2a:	fd4216        	beqz	a2, 4037ad02 <xQueueReceiveFromISR+0x6e>
                            *pxHigherPriorityTaskWoken = pdTRUE;
4037ad2d:	0459      	s32i.n	a5, a4, 0
4037ad2f:	fff3c6        	j	4037ad02 <xQueueReceiveFromISR+0x6e>
                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
4037ad32:	661b      	addi.n	a6, a6, 1
4037ad34:	746060        	extui	a6, a6, 0, 8
4037ad37:	0020c0        	memw
4037ad3a:	444562        	s8i	a6, a5, 68
4037ad3d:	fff046        	j	4037ad02 <xQueueReceiveFromISR+0x6e>

4037ad40 <vQueueDelete>:
{
4037ad40:	004136        	entry	a1, 32
4037ad43:	02ad      	mov.n	a10, a2
    configASSERT( pxQueue );
4037ad45:	010256        	bnez	a2, 4037ad59 <vQueueDelete+0x19>
4037ad48:	2da4b2        	movi	a11, 0x42d
4037ad4b:	e797d1        	l32r	a13, 40374ba8 <_iram_text_start+0x7a4>
4037ad4e:	e7b2c1        	l32r	a12, 40374c18 <_iram_text_start+0x814>
4037ad51:	e792a1        	l32r	a10, 40374b9c <_iram_text_start+0x798>
4037ad54:	bbba      	add.n	a11, a11, a11
4037ad56:	03ab65        	call8	4037e80c <__assert_func>
            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
4037ad59:	460282        	l8ui	a8, a2, 70
4037ad5c:	18cc      	bnez.n	a8, 4037ad61 <vQueueDelete+0x21>
                vPortFree( pxQueue );
4037ad5e:	03bce5        	call8	4037e92c <cfree>
}
4037ad61:	f01d      	retw.n
	...

4037ad64 <prvInitialiseNewTask>:
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions,
                                  BaseType_t xCoreID )
{
4037ad64:	006136        	entry	a1, 48
4037ad67:	038d      	mov.n	a8, a3
4037ad69:	c138      	l32i.n	a3, a1, 48

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
4037ad6b:	04cd      	mov.n	a12, a4
4037ad6d:	d3a8      	l32i.n	a10, a3, 52
4037ad6f:	a5a0b2        	movi	a11, 165
4037ad72:	0189      	s32i.n	a8, a1, 0
4037ad74:	1149      	s32i.n	a4, a1, 4
4037ad76:	e5bf81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037ad79:	0008e0        	callx8	a8
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
4037ad7c:	11d8      	l32i.n	a13, a1, 4
4037ad7e:	d348      	l32i.n	a4, a3, 52
4037ad80:	9d0b      	addi.n	a9, a13, -1
4037ad82:	449a      	add.n	a4, a4, a9
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
4037ad84:	097c      	movi.n	a9, -16
4037ad86:	104490        	and	a4, a4, a9
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
4037ad89:	0188      	l32i.n	a8, a1, 0
                    pxNewTCB->pxEndOfStack = pxTopOfStack;
4037ad8b:	136342        	s32i	a4, a3, 76
    if( pcName != NULL )
4037ad8e:	092816        	beqz	a8, 4037ae24 <prvInitialiseNewTask+0xc0>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
4037ad91:	090c      	movi.n	a9, 0
4037ad93:	0a1c      	movi.n	a10, 16
4037ad95:	0d8a76        	loop	a10, 4037ada6 <prvInitialiseNewTask+0x42>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
4037ad98:	b89a      	add.n	a11, a8, a9
4037ad9a:	000bb2        	l8ui	a11, a11, 0
4037ad9d:	c39a      	add.n	a12, a3, a9
4037ad9f:	384cb2        	s8i	a11, a12, 56

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
4037ada2:	0b8c      	beqz.n	a11, 4037ada6 <prvInitialiseNewTask+0x42>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
4037ada4:	991b      	addi.n	a9, a9, 1
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
4037ada6:	080c      	movi.n	a8, 0
4037ada8:	474382        	s8i	a8, a3, 71
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
4037adab:	881c      	movi.n	a8, 24
4037adad:	638680        	minu	a8, a6, a8
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    pxNewTCB->xCoreID = xCoreID;
4037adb0:	e168      	l32i.n	a6, a1, 56
    pxNewTCB->uxPriority = uxPriority;
4037adb2:	c389      	s32i.n	a8, a3, 48
    pxNewTCB->xCoreID = xCoreID;
4037adb4:	126362        	s32i	a6, a3, 72
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
4037adb7:	060c      	movi.n	a6, 0
            pxNewTCB->uxBasePriority = uxPriority;
4037adb9:	146382        	s32i	a8, a3, 80
            pxNewTCB->uxMutexesHeld = 0;
4037adbc:	156362        	s32i	a6, a3, 84
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
4037adbf:	a38b      	addi.n	a10, a3, 8
4037adc1:	0189      	s32i.n	a8, a1, 0
4037adc3:	11d9      	s32i.n	a13, a1, 4
4037adc5:	0165e5        	call8	4037c424 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
4037adc8:	1cc3a2        	addi	a10, a3, 28
4037adcb:	0165a5        	call8	4037c424 <vListInitialiseItem>
    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037adce:	0188      	l32i.n	a8, a1, 0
4037add0:	991c      	movi.n	a9, 25
4037add2:	c08980        	sub	a8, a9, a8
        }
    #endif /* configGENERATE_RUN_TIME_STATS */

    #if ( portUSING_MPU_WRAPPERS == 1 )
        {
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
4037add5:	11d8      	l32i.n	a13, a1, 4
4037add7:	d3c8      	l32i.n	a12, a3, 52
4037add9:	d1b8      	l32i.n	a11, a1, 52
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037addb:	7389      	s32i.n	a8, a3, 28
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
4037addd:	a34b      	addi.n	a10, a3, 4
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
4037addf:	5339      	s32i.n	a3, a3, 20
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
4037ade1:	a339      	s32i.n	a3, a3, 40
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
4037ade3:	019e25        	call8	4037c7c4 <vPortStoreTaskMPUSettings>
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
4037ade6:	50a1a2        	movi	a10, 0x150
4037ade9:	4c0c      	movi.n	a12, 4
4037adeb:	06bd      	mov.n	a11, a6
                pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
4037aded:	166362        	s32i	a6, a3, 88
                pxNewTCB->pvThreadLocalStoragePointersDelCallback[ x ] = NULL;
4037adf0:	176362        	s32i	a6, a3, 92
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
4037adf3:	a3aa      	add.n	a10, a3, a10
4037adf5:	e59f81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037adf8:	0008e0        	callx8	a8
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
4037adfb:	54a182        	movi	a8, 0x154
4037adfe:	838a      	add.n	a8, a3, a8
4037ae00:	004862        	s8i	a6, a8, 0
    #endif

    #if ( configUSE_NEWLIB_REENTRANT == 1 )
        {
            /* Initialise this task's Newlib reent structure. */
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
4037ae03:	60c3a2        	addi	a10, a3, 96
4037ae06:	fc2065        	call8	4037700c <esp_reent_init>
        }
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            pxNewTCB->ucDelayAborted = pdFALSE;
4037ae09:	01d382        	addmi	a8, a3, 0x100
4037ae0c:	564862        	s8i	a6, a8, 86
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
4037ae0f:	06dd      	mov.n	a13, a6
4037ae11:	05cd      	mov.n	a12, a5
4037ae13:	02bd      	mov.n	a11, a2
4037ae15:	04ad      	mov.n	a10, a4
4037ae17:	016c65        	call8	4037c4dc <pxPortInitialiseStack>
4037ae1a:	03a9      	s32i.n	a10, a3, 0
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
4037ae1c:	011767        	beq	a7, a6, 4037ae21 <prvInitialiseNewTask+0xbd>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
4037ae1f:	0739      	s32i.n	a3, a7, 0
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
4037ae21:	f01d      	retw.n
4037ae23:	00          	.byte 00
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
4037ae24:	384382        	s8i	a8, a3, 56
4037ae27:	ffe006        	j	4037adab <prvInitialiseNewTask+0x47>
	...

4037ae2c <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const portBASE_TYPE xCoreID, const TickType_t xTicksToWait )
{
4037ae2c:	004136        	entry	a1, 32
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;

    if (configNUM_CORES > 1 && listIS_CONTAINED_WITHIN(&xTasksWaitingTermination,  &( pxCurrentTCB[xCoreID]->xStateListItem))) {
4037ae2f:	e63d81        	l32r	a8, 40374724 <_iram_text_start+0x320>
    const TickType_t xConstTickCount = xTickCount;
4037ae32:	e77a41        	l32r	a4, 40374c1c <_iram_text_start+0x818>
    if (configNUM_CORES > 1 && listIS_CONTAINED_WITHIN(&xTasksWaitingTermination,  &( pxCurrentTCB[xCoreID]->xStateListItem))) {
4037ae35:	a02280        	addx4	a2, a2, a8
    const TickType_t xConstTickCount = xTickCount;
4037ae38:	0020c0        	memw
4037ae3b:	002442        	l32i	a4, a4, 0
    if (configNUM_CORES > 1 && listIS_CONTAINED_WITHIN(&xTasksWaitingTermination,  &( pxCurrentTCB[xCoreID]->xStateListItem))) {
4037ae3e:	0020c0        	memw
4037ae41:	002292        	l32i	a9, a2, 0
4037ae44:	e77781        	l32r	a8, 40374c20 <_iram_text_start+0x81c>
4037ae47:	6998      	l32i.n	a9, a9, 24
4037ae49:	271987        	beq	a9, a8, 4037ae74 <prvAddCurrentTaskToDelayedList+0x48>
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
        pxCurrentTCB[xCoreID]->ucDelayAborted = pdFALSE;
4037ae4c:	0020c0        	memw
4037ae4f:	0288      	l32i.n	a8, a2, 0
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB[xCoreID]->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ae51:	0020c0        	memw
4037ae54:	02a8      	l32i.n	a10, a2, 0
        pxCurrentTCB[xCoreID]->ucDelayAborted = pdFALSE;
4037ae56:	01d882        	addmi	a8, a8, 0x100
4037ae59:	090c      	movi.n	a9, 0
4037ae5b:	564892        	s8i	a9, a8, 86
    if( uxListRemove( &( pxCurrentTCB[xCoreID]->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037ae5e:	08caa2        	addi	a10, a10, 8
4037ae61:	016265        	call8	4037c488 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) )
4037ae64:	100366        	bnei	a3, -1, 4037ae78 <prvAddCurrentTaskToDelayedList+0x4c>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB[xCoreID]->xStateListItem ) );
4037ae67:	0020c0        	memw
4037ae6a:	02b8      	l32i.n	a11, a2, 0
4037ae6c:	e76ea1        	l32r	a10, 40374c24 <_iram_text_start+0x820>
4037ae6f:	bb8b      	addi.n	a11, a11, 8
4037ae71:	015be5        	call8	4037c430 <vListInsertEnd>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
    #endif /* INCLUDE_vTaskSuspend */
}
4037ae74:	f01d      	retw.n
4037ae76:	00          	.byte 00
4037ae77:	00          	.byte 00
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB[xCoreID]->xStateListItem ), xTimeToWake );
4037ae78:	0020c0        	memw
4037ae7b:	002282        	l32i	a8, a2, 0
                xTimeToWake = xConstTickCount + xTicksToWait;
4037ae7e:	803430        	add	a3, a4, a3
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB[xCoreID]->xStateListItem ), xTimeToWake );
4037ae81:	026832        	s32i	a3, a8, 8
                if( xTimeToWake < xConstTickCount )
4037ae84:	14b347        	bgeu	a3, a4, 4037ae9c <prvAddCurrentTaskToDelayedList+0x70>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB[xCoreID]->xStateListItem ) );
4037ae87:	e76831        	l32r	a3, 40374c28 <_iram_text_start+0x824>
4037ae8a:	0020c0        	memw
4037ae8d:	03a8      	l32i.n	a10, a3, 0
4037ae8f:	0020c0        	memw
4037ae92:	02b8      	l32i.n	a11, a2, 0
4037ae94:	bb8b      	addi.n	a11, a11, 8
4037ae96:	015be5        	call8	4037c454 <vListInsert>
4037ae99:	fff5c6        	j	4037ae74 <prvAddCurrentTaskToDelayedList+0x48>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB[xCoreID]->xStateListItem ) );
4037ae9c:	e76441        	l32r	a4, 40374c2c <_iram_text_start+0x828>
4037ae9f:	0020c0        	memw
4037aea2:	0024a2        	l32i	a10, a4, 0
4037aea5:	0020c0        	memw
4037aea8:	0022b2        	l32i	a11, a2, 0
4037aeab:	08cbb2        	addi	a11, a11, 8
4037aeae:	015a65        	call8	4037c454 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
4037aeb1:	e75f21        	l32r	a2, 40374c30 <_iram_text_start+0x82c>
4037aeb4:	0020c0        	memw
4037aeb7:	0248      	l32i.n	a4, a2, 0
4037aeb9:	b7b347        	bgeu	a3, a4, 4037ae74 <prvAddCurrentTaskToDelayedList+0x48>
                        xNextTaskUnblockTime = xTimeToWake;
4037aebc:	0020c0        	memw
4037aebf:	0239      	s32i.n	a3, a2, 0
                        mtCOVERAGE_TEST_MARKER();
4037aec1:	ffebc6        	j	4037ae74 <prvAddCurrentTaskToDelayedList+0x48>

4037aec4 <prvResetNextTaskUnblockTime>:
{
4037aec4:	004136        	entry	a1, 32
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037aec7:	e75991        	l32r	a9, 40374c2c <_iram_text_start+0x828>
4037aeca:	0020c0        	memw
4037aecd:	0988      	l32i.n	a8, a9, 0
4037aecf:	0020c0        	memw
4037aed2:	08a8      	l32i.n	a10, a8, 0
4037aed4:	e75781        	l32r	a8, 40374c30 <_iram_text_start+0x82c>
4037aed7:	9acc      	bnez.n	a10, 4037aee4 <prvResetNextTaskUnblockTime+0x20>
        xNextTaskUnblockTime = portMAX_DELAY;
4037aed9:	f97c      	movi.n	a9, -1
        xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
4037aedb:	0020c0        	memw
4037aede:	0899      	s32i.n	a9, a8, 0
}
4037aee0:	f01d      	retw.n
4037aee2:	00          	.byte 00
4037aee3:	00          	.byte 00
        ( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037aee4:	0020c0        	memw
4037aee7:	0998      	l32i.n	a9, a9, 0
4037aee9:	3998      	l32i.n	a9, a9, 12
        xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
4037aeeb:	3998      	l32i.n	a9, a9, 12
4037aeed:	2998      	l32i.n	a9, a9, 8
4037aeef:	fffa06        	j	4037aedb <prvResetNextTaskUnblockTime+0x17>
	...

4037aef4 <prvDeleteTLS>:
    {
4037aef4:	004136        	entry	a1, 32
        configASSERT( pxTCB );
4037aef7:	02dc      	bnez.n	a2, 4037af0b <prvDeleteTLS+0x17>
4037aef9:	a9a4b2        	movi	a11, 0x4a9
4037aefc:	e74ed1        	l32r	a13, 40374c34 <_iram_text_start+0x830>
4037aeff:	e74ec1        	l32r	a12, 40374c38 <_iram_text_start+0x834>
4037af02:	e74ea1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037af05:	11bbe0        	slli	a11, a11, 2
4037af08:	039025        	call8	4037e80c <__assert_func>
            if (pxTCB->pvThreadLocalStoragePointersDelCallback[ x ] != NULL)    //If del cb is set
4037af0b:	172282        	l32i	a8, a2, 92
4037af0e:	688c      	beqz.n	a8, 4037af18 <prvDeleteTLS+0x24>
                pxTCB->pvThreadLocalStoragePointersDelCallback[ x ](x, pxTCB->pvThreadLocalStoragePointers[ x ]);   //Call del cb
4037af10:	1622b2        	l32i	a11, a2, 88
4037af13:	0a0c      	movi.n	a10, 0
4037af15:	0008e0        	callx8	a8
    }
4037af18:	f01d      	retw.n
	...

4037af1c <prvDeleteTCB>:
    {
4037af1c:	004136        	entry	a1, 32
                _reclaim_reent( &( pxTCB->xNewLib_reent ) );
4037af1f:	60c2a2        	addi	a10, a2, 96
4037af22:	e74a81        	l32r	a8, 40374c4c <_iram_text_start+0x848>
4037af25:	0008e0        	callx8	a8
            vPortReleaseTaskMPUSettings( &( pxTCB->xMPUSettings) );
4037af28:	04c2a2        	addi	a10, a2, 4
4037af2b:	0188e5        	call8	4037c7b8 <vPortReleaseTaskMPUSettings>
                if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
4037af2e:	01d282        	addmi	a8, a2, 0x100
4037af31:	550882        	l8ui	a8, a8, 85
4037af34:	00e856        	bnez	a8, 4037af46 <prvDeleteTCB+0x2a>
                    vPortFree( pxTCB->pxStack );
4037af37:	d2a8      	l32i.n	a10, a2, 52
4037af39:	039f25        	call8	4037e92c <cfree>
                    vPortFree( pxTCB );
4037af3c:	02ad      	mov.n	a10, a2
4037af3e:	039ee5        	call8	4037e92c <cfree>
    }
4037af41:	f01d      	retw.n
4037af43:	00          	.byte 00
4037af44:	00          	.byte 00
4037af45:	00          	.byte 00
                else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
4037af46:	f21826        	beqi	a8, 1, 4037af3c <prvDeleteTCB+0x20>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
4037af49:	f42826        	beqi	a8, 2, 4037af41 <prvDeleteTCB+0x25>
4037af4c:	e73dd1        	l32r	a13, 40374c40 <_iram_text_start+0x83c>
4037af4f:	e73dc1        	l32r	a12, 40374c44 <_iram_text_start+0x840>
4037af52:	e73db1        	l32r	a11, 40374c48 <_iram_text_start+0x844>
4037af55:	e739a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037af58:	038b25        	call8	4037e80c <__assert_func>
	...

4037af5c <prvIdleTask>:
{
4037af5c:	004136        	entry	a1, 32
                TCB_t *pxTCB = NULL;
4037af5f:	00a022        	movi	a2, 0
4037af62:	03eb40        	rsr.prid	a4
4037af65:	044d40        	extui	a4, a4, 13, 1
                            if( pxCurrentTCB[core] == tgt_tcb || (configNUM_CORES > 1 && pxCurrentTCB[!core] == tgt_tcb) ){
4037af68:	01a052        	movi	a5, 1
4037af6b:	206220        	or	a6, a2, a2
4037af6e:	836540        	moveqz	a6, a5, a4
4037af71:	1166e0        	slli	a6, a6, 2
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
4037af74:	e73a31        	l32r	a3, 40374c5c <_iram_text_start+0x858>
4037af77:	0020c0        	memw
4037af7a:	0378      	l32i.n	a7, a3, 0
4037af7c:	d7ac      	beqz.n	a7, 4037afad <prvIdleTask+0x51>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037af7e:	e73471        	l32r	a7, 40374c50 <_iram_text_start+0x84c>
4037af81:	fb7c      	movi.n	a11, -1
4037af83:	07ad      	mov.n	a10, a7
4037af85:	0162a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
                    xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
4037af88:	e72691        	l32r	a9, 40374c20 <_iram_text_start+0x81c>
                TCB_t *pxTCB = NULL;
4037af8b:	023d      	mov.n	a3, a2
                    xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
4037af8d:	0020c0        	memw
4037af90:	09a8      	l32i.n	a10, a9, 0
                    if( xListIsEmpty == pdFALSE )
4037af92:	0a9c      	beqz.n	a10, 4037afa6 <prvIdleTask+0x4a>
                        ListItem_t *target = listGET_HEAD_ENTRY(&xTasksWaitingTermination);
4037af94:	39a8      	l32i.n	a10, a9, 12
                            if( pxCurrentTCB[core] == tgt_tcb || (configNUM_CORES > 1 && pxCurrentTCB[!core] == tgt_tcb) ){
4037af96:	e5e391        	l32r	a9, 40374724 <_iram_text_start+0x320>
                        for( ; target != listGET_END_MARKER(&xTasksWaitingTermination); target = listGET_NEXT(target) ){    //Walk the list
4037af99:	e72fd1        	l32r	a13, 40374c58 <_iram_text_start+0x854>
                            if( pxCurrentTCB[core] == tgt_tcb || (configNUM_CORES > 1 && pxCurrentTCB[!core] == tgt_tcb) ){
4037af9c:	a0e490        	addx4	a14, a4, a9
4037af9f:	996a      	add.n	a9, a9, a6
                        for( ; target != listGET_END_MARKER(&xTasksWaitingTermination); target = listGET_NEXT(target) ){    //Walk the list
4037afa1:	149ad7        	bne	a10, a13, 4037afb9 <prvIdleTask+0x5d>
                TCB_t *pxTCB = NULL;
4037afa4:	023d      	mov.n	a3, a2
                taskEXIT_CRITICAL();    //Need to call deletion callbacks outside critical section
4037afa6:	07ad      	mov.n	a10, a7
4037afa8:	0173a5        	call8	4037c6e4 <vPortExitCritical>
                if (pxTCB != NULL) {    //Call deletion callbacks and free TCB memory
4037afab:	b3fc      	bnez.n	a3, 4037afea <prvIdleTask+0x8e>
        esp_vApplicationIdleHook();
4037afad:	e72d81        	l32r	a8, 40374c64 <_iram_text_start+0x860>
4037afb0:	0008e0        	callx8	a8
    for( ; ; )
4037afb3:	ffeac6        	j	4037af62 <prvIdleTask+0x6>
4037afb6:	00          	.byte 00
4037afb7:	00          	.byte 00
4037afb8:	00          	.byte 00
                            TCB_t *tgt_tcb = ( TCB_t * )listGET_LIST_ITEM_OWNER(target);
4037afb9:	3a38      	l32i.n	a3, a10, 12
                            if( pxCurrentTCB[core] == tgt_tcb || (configNUM_CORES > 1 && pxCurrentTCB[!core] == tgt_tcb) ){
4037afbb:	0020c0        	memw
4037afbe:	0eb8      	l32i.n	a11, a14, 0
4037afc0:	2113b7        	beq	a3, a11, 4037afe5 <prvIdleTask+0x89>
4037afc3:	0020c0        	memw
4037afc6:	09b8      	l32i.n	a11, a9, 0
4037afc8:	1913b7        	beq	a3, a11, 4037afe5 <prvIdleTask+0x89>
                            int affinity = tgt_tcb->xCoreID;
4037afcb:	1223b2        	l32i	a11, a3, 72
                            if(affinity == core || affinity == tskNO_AFFINITY){     //Find first item not pinned to other core
4037afce:	02fd      	mov.n	a15, a2
4037afd0:	c0c4b0        	sub	a12, a4, a11
4037afd3:	83f5c0        	moveqz	a15, a5, a12
4037afd6:	74c0f0        	extui	a12, a15, 0, 8
4037afd9:	cfdc      	bnez.n	a15, 4037aff9 <prvIdleTask+0x9d>
4037afdb:	e71ef1        	l32r	a15, 40374c54 <_iram_text_start+0x850>
4037afde:	bbfa      	add.n	a11, a11, a15
4037afe0:	83c5b0        	moveqz	a12, a5, a11
4037afe3:	2cdc      	bnez.n	a12, 4037aff9 <prvIdleTask+0x9d>
                        for( ; target != listGET_END_MARKER(&xTasksWaitingTermination); target = listGET_NEXT(target) ){    //Walk the list
4037afe5:	1aa8      	l32i.n	a10, a10, 4
4037afe7:	ffed86        	j	4037afa1 <prvIdleTask+0x45>
                        prvDeleteTLS( pxTCB );
4037afea:	20a330        	or	a10, a3, a3
4037afed:	fff065        	call8	4037aef4 <prvDeleteTLS>
                    prvDeleteTCB( pxTCB );
4037aff0:	20a330        	or	a10, a3, a3
4037aff3:	fff2a5        	call8	4037af1c <prvDeleteTCB>
4037aff6:	ffde86        	j	4037af74 <prvIdleTask+0x18>
                            ( void ) uxListRemove( target );    //Remove list item from list
4037aff9:	0148e5        	call8	4037c488 <uxListRemove>
                            --uxCurrentNumberOfTasks;
4037affc:	e719a1        	l32r	a10, 40374c60 <_iram_text_start+0x85c>
                            --uxDeletedTasksWaitingCleanUp;
4037afff:	e71781        	l32r	a8, 40374c5c <_iram_text_start+0x858>
                            --uxCurrentNumberOfTasks;
4037b002:	0020c0        	memw
4037b005:	002a92        	l32i	a9, a10, 0
4037b008:	ffc992        	addi	a9, a9, -1
4037b00b:	0020c0        	memw
4037b00e:	006a92        	s32i	a9, a10, 0
                            --uxDeletedTasksWaitingCleanUp;
4037b011:	0020c0        	memw
4037b014:	0898      	l32i.n	a9, a8, 0
4037b016:	990b      	addi.n	a9, a9, -1
4037b018:	0020c0        	memw
4037b01b:	0899      	s32i.n	a9, a8, 0
4037b01d:	ffe146        	j	4037afa6 <prvIdleTask+0x4a>

4037b020 <taskYIELD_OTHER_CORE>:
{
4037b020:	004136        	entry	a1, 32
    if (xCoreID != tskNO_AFFINITY) {
4037b023:	e5fa81        	l32r	a8, 4037480c <_iram_text_start+0x408>
{
4037b026:	02ad      	mov.n	a10, a2
    if (xCoreID != tskNO_AFFINITY) {
4037b028:	191287        	beq	a2, a8, 4037b045 <taskYIELD_OTHER_CORE+0x25>
        if ( pxCurrentTCB[ xCoreID ]->uxPriority < uxPriority ) {   // NOLINT(clang-analyzer-core.NullDereference) IDF-685
4037b02b:	e5be81        	l32r	a8, 40374724 <_iram_text_start+0x320>
4037b02e:	a08280        	addx4	a8, a2, a8
4037b031:	0020c0        	memw
4037b034:	002882        	l32i	a8, a8, 0
4037b037:	c888      	l32i.n	a8, a8, 48
4037b039:	37b837        	bgeu	a8, a3, 4037b074 <taskYIELD_OTHER_CORE+0x54>
                vPortYieldOtherCore( i );
4037b03c:	0172e5        	call8	4037c76c <vPortYieldOtherCore>
}
4037b03f:	000c46        	j	4037b074 <taskYIELD_OTHER_CORE+0x54>
4037b042:	00          	.byte 00
4037b043:	00          	.byte 00
4037b044:	00          	.byte 00
4037b045:	03eb80        	rsr.prid	a8
4037b048:	048d80        	extui	a8, a8, 13, 1
            if (i != xPortGetCoreID() && pxCurrentTCB[ i ]->uxPriority < uxPriority)
4037b04b:	d88c      	beqz.n	a8, 4037b05c <taskYIELD_OTHER_CORE+0x3c>
4037b04d:	e5b581        	l32r	a8, 40374724 <_iram_text_start+0x320>
4037b050:	0020c0        	memw
4037b053:	002882        	l32i	a8, a8, 0
4037b056:	0c2882        	l32i	a8, a8, 48
4037b059:	193837        	bltu	a8, a3, 4037b076 <taskYIELD_OTHER_CORE+0x56>
4037b05c:	03eb80        	rsr.prid	a8
4037b05f:	048d80        	extui	a8, a8, 13, 1
4037b062:	0e1826        	beqi	a8, 1, 4037b074 <taskYIELD_OTHER_CORE+0x54>
4037b065:	e5af81        	l32r	a8, 40374724 <_iram_text_start+0x320>
        for (i=0; i<configNUM_CORES; i++) {
4037b068:	1a0c      	movi.n	a10, 1
            if (i != xPortGetCoreID() && pxCurrentTCB[ i ]->uxPriority < uxPriority)
4037b06a:	0020c0        	memw
4037b06d:	1888      	l32i.n	a8, a8, 4
4037b06f:	c888      	l32i.n	a8, a8, 48
4037b071:	c73837        	bltu	a8, a3, 4037b03c <taskYIELD_OTHER_CORE+0x1c>
}
4037b074:	f01d      	retw.n
        for (i=0; i<configNUM_CORES; i++) {
4037b076:	0a0c      	movi.n	a10, 0
4037b078:	fff006        	j	4037b03c <taskYIELD_OTHER_CORE+0x1c>
	...

4037b07c <prvAddNewTaskToReadyList$constprop$0>:
static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB,
4037b07c:	006136        	entry	a1, 48
4037b07f:	e6f4a1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037b082:	fb7c      	movi.n	a11, -1
4037b084:	0152a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        uxCurrentNumberOfTasks++;
4037b087:	e6f6a1        	l32r	a10, 40374c60 <_iram_text_start+0x85c>
static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB,
4037b08a:	025d      	mov.n	a5, a2
        uxCurrentNumberOfTasks++;
4037b08c:	0020c0        	memw
4037b08f:	0a28      	l32i.n	a2, a10, 0
4037b091:	e5a441        	l32r	a4, 40374724 <_iram_text_start+0x320>
4037b094:	221b      	addi.n	a2, a2, 1
4037b096:	0020c0        	memw
4037b099:	0a29      	s32i.n	a2, a10, 0
        if ( xCoreID == tskNO_AFFINITY )
4037b09b:	e5dc21        	l32r	a2, 4037480c <_iram_text_start+0x408>
static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB,
4037b09e:	037d      	mov.n	a7, a3
        if ( xCoreID == tskNO_AFFINITY )
4037b0a0:	2c9327        	bne	a3, a2, 4037b0d0 <prvAddNewTaskToReadyList$constprop$0+0x54>
                tcb0 = pxCurrentTCB[0];
4037b0a3:	0020c0        	memw
4037b0a6:	0428      	l32i.n	a2, a4, 0
                    xCoreID = 0;
4037b0a8:	070c      	movi.n	a7, 0
                tcb1 = pxCurrentTCB[1];
4037b0aa:	0020c0        	memw
4037b0ad:	1438      	l32i.n	a3, a4, 4
                if ( tcb0 == NULL )
4037b0af:	1d1277        	beq	a2, a7, 4037b0d0 <prvAddNewTaskToReadyList$constprop$0+0x54>
                    xCoreID = 1;
4037b0b2:	170c      	movi.n	a7, 1
                else if ( tcb1 == NULL )
4037b0b4:	839c      	beqz.n	a3, 4037b0d0 <prvAddNewTaskToReadyList$constprop$0+0x54>
                else if ( tcb0->uxPriority < pxNewTCB->uxPriority && tcb0->uxPriority < tcb1->uxPriority )
4037b0b6:	c268      	l32i.n	a6, a2, 48
4037b0b8:	c528      	l32i.n	a2, a5, 48
4037b0ba:	c338      	l32i.n	a3, a3, 48
4037b0bc:	05b627        	bgeu	a6, a2, 4037b0c5 <prvAddNewTaskToReadyList$constprop$0+0x49>
                    xCoreID = 0;
4037b0bf:	00a072        	movi	a7, 0
                else if ( tcb0->uxPriority < pxNewTCB->uxPriority && tcb0->uxPriority < tcb1->uxPriority )
4037b0c2:	0a3637        	bltu	a6, a3, 4037b0d0 <prvAddNewTaskToReadyList$constprop$0+0x54>
                    xCoreID = 1;
4037b0c5:	170c      	movi.n	a7, 1
                else if ( tcb1->uxPriority < pxNewTCB->uxPriority )
4037b0c7:	053327        	bltu	a3, a2, 4037b0d0 <prvAddNewTaskToReadyList$constprop$0+0x54>
4037b0ca:	03eb70        	rsr.prid	a7
4037b0cd:	047d70        	extui	a7, a7, 13, 1
        if( pxCurrentTCB[xCoreID] == NULL )
4037b0d0:	a03740        	addx4	a3, a7, a4
4037b0d3:	0020c0        	memw
4037b0d6:	0328      	l32i.n	a2, a3, 0
4037b0d8:	1167e0        	slli	a6, a7, 2
4037b0db:	0c9256        	bnez	a2, 4037b1a8 <prvAddNewTaskToReadyList$constprop$0+0x12c>
            pxCurrentTCB[xCoreID] = pxNewTCB;
4037b0de:	0020c0        	memw
4037b0e1:	0359      	s32i.n	a5, a3, 0
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
4037b0e3:	0020c0        	memw
4037b0e6:	0a38      	l32i.n	a3, a10, 0
4037b0e8:	4d1366        	bnei	a3, 1, 4037b139 <prvAddNewTaskToReadyList$constprop$0+0xbd>
4037b0eb:	e6df31        	l32r	a3, 40374c68 <_iram_text_start+0x864>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037b0ee:	9b1c      	movi.n	a11, 25
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
4037b0f0:	03ad      	mov.n	a10, a3
4037b0f2:	01b9      	s32i.n	a11, a1, 0
4037b0f4:	013165        	call8	4037c40c <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
4037b0f7:	01b8      	l32i.n	a11, a1, 0
4037b0f9:	221b      	addi.n	a2, a2, 1
4037b0fb:	14c332        	addi	a3, a3, 20
4037b0fe:	ee92b7        	bne	a2, a11, 4037b0f0 <prvAddNewTaskToReadyList$constprop$0+0x74>
    vListInitialise( &xDelayedTaskList1 );
4037b101:	e6da31        	l32r	a3, 40374c6c <_iram_text_start+0x868>
4037b104:	03ad      	mov.n	a10, a3
4037b106:	013065        	call8	4037c40c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
4037b109:	e6d921        	l32r	a2, 40374c70 <_iram_text_start+0x86c>
4037b10c:	02ad      	mov.n	a10, a2
4037b10e:	012fe5        	call8	4037c40c <vListInitialise>
        vListInitialise( &xPendingReadyList[ i ] );
4037b111:	e6d8a1        	l32r	a10, 40374c74 <_iram_text_start+0x870>
4037b114:	012f65        	call8	4037c40c <vListInitialise>
4037b117:	e6d8a1        	l32r	a10, 40374c78 <_iram_text_start+0x874>
4037b11a:	012f25        	call8	4037c40c <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
4037b11d:	e6c0a1        	l32r	a10, 40374c20 <_iram_text_start+0x81c>
4037b120:	012ea5        	call8	4037c40c <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
4037b123:	e6c0a1        	l32r	a10, 40374c24 <_iram_text_start+0x820>
4037b126:	012e65        	call8	4037c40c <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
4037b129:	e6c0a1        	l32r	a10, 40374c2c <_iram_text_start+0x828>
4037b12c:	0020c0        	memw
4037b12f:	0a39      	s32i.n	a3, a10, 0
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
4037b131:	e6bd31        	l32r	a3, 40374c28 <_iram_text_start+0x824>
4037b134:	0020c0        	memw
4037b137:	0329      	s32i.n	a2, a3, 0
        uxTaskNumber++;
4037b139:	e6d131        	l32r	a3, 40374c80 <_iram_text_start+0x87c>
        prvAddTaskToReadyList( pxNewTCB );
4037b13c:	c5a8      	l32i.n	a10, a5, 48
        uxTaskNumber++;
4037b13e:	0328      	l32i.n	a2, a3, 0
4037b140:	221b      	addi.n	a2, a2, 1
4037b142:	0329      	s32i.n	a2, a3, 0
        prvAddTaskToReadyList( pxNewTCB );
4037b144:	e6d021        	l32r	a2, 40374c84 <_iram_text_start+0x880>
4037b147:	0020c0        	memw
4037b14a:	0238      	l32i.n	a3, a2, 0
4037b14c:	04b3a7        	bgeu	a3, a10, 4037b154 <prvAddNewTaskToReadyList$constprop$0+0xd8>
4037b14f:	0020c0        	memw
4037b152:	02a9      	s32i.n	a10, a2, 0
4037b154:	e6c521        	l32r	a2, 40374c68 <_iram_text_start+0x864>
4037b157:	a0aaa0        	addx4	a10, a10, a10
4037b15a:	a0aa20        	addx4	a10, a10, a2
4037b15d:	b58b      	addi.n	a11, a5, 8
4037b15f:	012d25        	call8	4037c430 <vListInsertEnd>
    taskEXIT_CRITICAL();
4037b162:	e6bba1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037b165:	0157e5        	call8	4037c6e4 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
4037b168:	e6c521        	l32r	a2, 40374c7c <_iram_text_start+0x878>
4037b16b:	0020c0        	memw
4037b16e:	0228      	l32i.n	a2, a2, 0
4037b170:	22bc      	beqz.n	a2, 4037b1a6 <prvAddNewTaskToReadyList$constprop$0+0x12a>
4037b172:	e6b7a1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037b175:	fb7c      	movi.n	a11, -1
        curTCB = pxCurrentTCB[ xCoreID ];
4037b177:	446a      	add.n	a4, a4, a6
4037b179:	014365        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037b17c:	0020c0        	memw
4037b17f:	0428      	l32i.n	a2, a4, 0
        if( curTCB == NULL || curTCB->uxPriority < pxNewTCB->uxPriority )
4037b181:	628c      	beqz.n	a2, 4037b18b <prvAddNewTaskToReadyList$constprop$0+0x10f>
4037b183:	0c2232        	l32i	a3, a2, 48
4037b186:	c528      	l32i.n	a2, a5, 48
4037b188:	11b327        	bgeu	a3, a2, 4037b19d <prvAddNewTaskToReadyList$constprop$0+0x121>
4037b18b:	03eb20        	rsr.prid	a2
4037b18e:	042d20        	extui	a2, a2, 13, 1
            if( xCoreID == xPortGetCoreID() )
4037b191:	419727        	bne	a7, a2, 4037b1d6 <prvAddNewTaskToReadyList$constprop$0+0x15a>
4037b194:	03eba0        	rsr.prid	a10
4037b197:	04ada0        	extui	a10, a10, 13, 1
                taskYIELD_IF_USING_PREEMPTION();
4037b19a:	fcea65        	call8	40378040 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL();
4037b19d:	e6aca1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037b1a0:	201110        	or	a1, a1, a1
4037b1a3:	015425        	call8	4037c6e4 <vPortExitCritical>
}
4037b1a6:	f01d      	retw.n
            if( xSchedulerRunning == pdFALSE )
4037b1a8:	e6b521        	l32r	a2, 40374c7c <_iram_text_start+0x878>
                else if ( tcb0->uxPriority < pxNewTCB->uxPriority && tcb0->uxPriority < tcb1->uxPriority )
4037b1ab:	c5a8      	l32i.n	a10, a5, 48
            if( xSchedulerRunning == pdFALSE )
4037b1ad:	0020c0        	memw
4037b1b0:	0228      	l32i.n	a2, a2, 0
4037b1b2:	f83256        	bnez	a2, 4037b139 <prvAddNewTaskToReadyList$constprop$0+0xbd>
                if( pxCurrentTCB[xCoreID] == NULL || pxCurrentTCB[xCoreID]->uxPriority <= pxNewTCB->uxPriority )
4037b1b5:	0020c0        	memw
4037b1b8:	0328      	l32i.n	a2, a3, 0
4037b1ba:	b28c      	beqz.n	a2, 4037b1c9 <prvAddNewTaskToReadyList$constprop$0+0x14d>
4037b1bc:	0020c0        	memw
4037b1bf:	0328      	l32i.n	a2, a3, 0
4037b1c1:	c228      	l32i.n	a2, a2, 48
4037b1c3:	02ba27        	bgeu	a10, a2, 4037b1c9 <prvAddNewTaskToReadyList$constprop$0+0x14d>
4037b1c6:	ffdbc6        	j	4037b139 <prvAddNewTaskToReadyList$constprop$0+0xbd>
                    pxCurrentTCB[xCoreID] = pxNewTCB;
4037b1c9:	246a      	add.n	a2, a4, a6
4037b1cb:	0020c0        	memw
4037b1ce:	0259      	s32i.n	a5, a2, 0
4037b1d0:	ffd946        	j	4037b139 <prvAddNewTaskToReadyList$constprop$0+0xbd>
4037b1d3:	00          	.byte 00
4037b1d4:	00          	.byte 00
4037b1d5:	00          	.byte 00
                taskYIELD_OTHER_CORE(xCoreID, pxNewTCB->uxPriority);
4037b1d6:	c5b8      	l32i.n	a11, a5, 48
4037b1d8:	07ad      	mov.n	a10, a7
4037b1da:	ffe465        	call8	4037b020 <taskYIELD_OTHER_CORE>
4037b1dd:	ffef06        	j	4037b19d <prvAddNewTaskToReadyList$constprop$0+0x121>

4037b1e0 <xTaskCreateStaticPinnedToCore>:
    {
4037b1e0:	00a136        	entry	a1, 80
4037b1e3:	208770        	or	a8, a7, a7
4037b1e6:	142172        	l32i	a7, a1, 80
        configASSERT( portVALID_TCB_MEM(pxTaskBuffer) );
4037b1e9:	086182        	s32i	a8, a1, 32
4037b1ec:	07ad      	mov.n	a10, a7
4037b1ee:	016425        	call8	4037c830 <xPortCheckValidTCBMem>
4037b1f1:	8188      	l32i.n	a8, a1, 32
4037b1f3:	dacc      	bnez.n	a10, 4037b204 <xTaskCreateStaticPinnedToCore+0x24>
4037b1f5:	e6a4d1        	l32r	a13, 40374c88 <_iram_text_start+0x884>
4037b1f8:	e6a5c1        	l32r	a12, 40374c8c <_iram_text_start+0x888>
4037b1fb:	aca2b2        	movi	a11, 0x2ac
        configASSERT( portVALID_STACK_MEM(pxStackBuffer) );
4037b1fe:	e68fa1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b201:	0360a5        	call8	4037e80c <__assert_func>
4037b204:	20a880        	or	a10, a8, a8
4037b207:	086182        	s32i	a8, a1, 32
4037b20a:	0166e5        	call8	4037c878 <xPortcheckValidStackMem>
4037b20d:	082182        	l32i	a8, a1, 32
4037b210:	cacc      	bnez.n	a10, 4037b220 <xTaskCreateStaticPinnedToCore+0x40>
4037b212:	e69fd1        	l32r	a13, 40374c90 <_iram_text_start+0x88c>
4037b215:	e69dc1        	l32r	a12, 40374c8c <_iram_text_start+0x888>
4037b218:	ada2b2        	movi	a11, 0x2ad
4037b21b:	fff7c6        	j	4037b1fe <xTaskCreateStaticPinnedToCore+0x1e>
4037b21e:	00          	.byte 00
4037b21f:	00          	.byte 00
        configASSERT( (xCoreID>=0 && xCoreID<configNUM_CORES) || (xCoreID==tskNO_AFFINITY) );
4037b220:	152192        	l32i	a9, a1, 84
4037b223:	1529b6        	bltui	a9, 2, 4037b23c <xTaskCreateStaticPinnedToCore+0x5c>
4037b226:	e68b91        	l32r	a9, 40374c54 <_iram_text_start+0x850>
4037b229:	1521a2        	l32i	a10, a1, 84
4037b22c:	9a9a      	add.n	a9, a10, a9
4037b22e:	a98c      	beqz.n	a9, 4037b23c <xTaskCreateStaticPinnedToCore+0x5c>
4037b230:	e699d1        	l32r	a13, 40374c94 <_iram_text_start+0x890>
4037b233:	e696c1        	l32r	a12, 40374c8c <_iram_text_start+0x888>
4037b236:	aea2b2        	movi	a11, 0x2ae
4037b239:	fff046        	j	4037b1fe <xTaskCreateStaticPinnedToCore+0x1e>
                volatile size_t xSize = sizeof( StaticTask_t );
4037b23c:	58a192        	movi	a9, 0x158
4037b23f:	0020c0        	memw
4037b242:	4199      	s32i.n	a9, a1, 16
                configASSERT( xSize == sizeof( TCB_t ) );
4037b244:	0020c0        	memw
4037b247:	41a8      	l32i.n	a10, a1, 16
4037b249:	0c1a97        	beq	a10, a9, 4037b259 <xTaskCreateStaticPinnedToCore+0x79>
4037b24c:	e693d1        	l32r	a13, 40374c98 <_iram_text_start+0x894>
4037b24f:	e68fc1        	l32r	a12, 40374c8c <_iram_text_start+0x888>
4037b252:	b6a2b2        	movi	a11, 0x2b6
4037b255:	ffe946        	j	4037b1fe <xTaskCreateStaticPinnedToCore+0x1e>
4037b258:	00          	.byte 00
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
4037b259:	0020c0        	memw
4037b25c:	042192        	l32i	a9, a1, 16
        if( ( pxTaskBuffer != NULL ) && ( pxStackBuffer != NULL ) )
4037b25f:	00a092        	movi	a9, 0
4037b262:	321797        	beq	a7, a9, 4037b298 <xTaskCreateStaticPinnedToCore+0xb8>
4037b265:	2f1897        	beq	a8, a9, 4037b298 <xTaskCreateStaticPinnedToCore+0xb8>
            pxNewTCB->pxStack = ( StackType_t * ) pxStackBuffer;
4037b268:	d789      	s32i.n	a8, a7, 52
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
4037b26a:	2a0c      	movi.n	a10, 2
4037b26c:	01d782        	addmi	a8, a7, 0x100
4037b26f:	5548a2        	s8i	a10, a8, 85
            prvInitialiseNewTask( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL, xCoreID );
4037b272:	152182        	l32i	a8, a1, 84
4037b275:	03bd      	mov.n	a11, a3
4037b277:	02ad      	mov.n	a10, a2
4037b279:	2189      	s32i.n	a8, a1, 8
4037b27b:	1199      	s32i.n	a9, a1, 4
4037b27d:	0179      	s32i.n	a7, a1, 0
4037b27f:	14c1f2        	addi	a15, a1, 20
4037b282:	06ed      	mov.n	a14, a6
4037b284:	05dd      	mov.n	a13, a5
4037b286:	20c440        	or	a12, a4, a4
4037b289:	ffada5        	call8	4037ad64 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB, pvTaskCode, xCoreID );
4037b28c:	1521b2        	l32i	a11, a1, 84
4037b28f:	07ad      	mov.n	a10, a7
4037b291:	ffdea5        	call8	4037b07c <prvAddNewTaskToReadyList$constprop$0>
    }
4037b294:	5128      	l32i.n	a2, a1, 20
4037b296:	f01d      	retw.n
            xReturn = NULL;
4037b298:	5199      	s32i.n	a9, a1, 20
4037b29a:	fffd86        	j	4037b294 <xTaskCreateStaticPinnedToCore+0xb4>
4037b29d:	000000        	ill

4037b2a0 <xTaskCreatePinnedToCore>:
    {
4037b2a0:	008136        	entry	a1, 64
            pxStack = pvPortMallocStackMem( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037b2a3:	01a282        	movi	a8, 0x201
4037b2a6:	1188e0        	slli	a8, a8, 2
4037b2a9:	08bd      	mov.n	a11, a8
4037b2ab:	04ad      	mov.n	a10, a4
    {
4037b2ad:	4129      	s32i.n	a2, a1, 16
            pxStack = pvPortMallocStackMem( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037b2af:	5189      	s32i.n	a8, a1, 20
4037b2b1:	faa865        	call8	40375d38 <heap_caps_malloc>
                if( pxStack != NULL )
4037b2b4:	5188      	l32i.n	a8, a1, 20
            pxStack = pvPortMallocStackMem( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
4037b2b6:	0a9d      	mov.n	a9, a10
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
4037b2b8:	f27c      	movi.n	a2, -1
                if( pxStack != NULL )
4037b2ba:	042a16        	beqz	a10, 4037b300 <xTaskCreatePinnedToCore+0x60>
                pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
4037b2bd:	08bd      	mov.n	a11, a8
4037b2bf:	58a1a2        	movi	a10, 0x158
4037b2c2:	056192        	s32i	a9, a1, 20
4037b2c5:	faa725        	call8	40375d38 <heap_caps_malloc>
                    if( pxNewTCB != NULL )
4037b2c8:	5198      	l32i.n	a9, a1, 20
                pxNewTCB = ( TCB_t * ) pvPortMallocTcbMem( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
4037b2ca:	0a8d      	mov.n	a8, a10
                    if( pxNewTCB != NULL )
4037b2cc:	2abc      	beqz.n	a10, 4037b302 <xTaskCreatePinnedToCore+0x62>
                        pxNewTCB->pxStack = pxStack;
4037b2ce:	da99      	s32i.n	a9, a10, 52
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
4037b2d0:	01da22        	addmi	a2, a10, 0x100
4037b2d3:	090c      	movi.n	a9, 0
4037b2d5:	554292        	s8i	a9, a2, 85
            prvInitialiseNewTask( pvTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pvCreatedTask, pxNewTCB, NULL, xCoreID );
4037b2d8:	102122        	l32i	a2, a1, 64
4037b2db:	01a9      	s32i.n	a10, a1, 0
4037b2dd:	2129      	s32i.n	a2, a1, 8
4037b2df:	41a8      	l32i.n	a10, a1, 16
4037b2e1:	020c      	movi.n	a2, 0
4037b2e3:	1129      	s32i.n	a2, a1, 4
4037b2e5:	07fd      	mov.n	a15, a7
4037b2e7:	06ed      	mov.n	a14, a6
4037b2e9:	05dd      	mov.n	a13, a5
4037b2eb:	04cd      	mov.n	a12, a4
4037b2ed:	03bd      	mov.n	a11, a3
4037b2ef:	5189      	s32i.n	a8, a1, 20
4037b2f1:	ffa725        	call8	4037ad64 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB, pvTaskCode, xCoreID);
4037b2f4:	5188      	l32i.n	a8, a1, 20
4037b2f6:	1021b2        	l32i	a11, a1, 64
4037b2f9:	08ad      	mov.n	a10, a8
4037b2fb:	ffd825        	call8	4037b07c <prvAddNewTaskToReadyList$constprop$0>
            xReturn = pdPASS;
4037b2fe:	120c      	movi.n	a2, 1
    }
4037b300:	f01d      	retw.n
                        vPortFree( pxStack );
4037b302:	09ad      	mov.n	a10, a9
4037b304:	036265        	call8	4037e92c <cfree>
        if( pxNewTCB != NULL )
4037b307:	fffd46        	j	4037b300 <xTaskCreatePinnedToCore+0x60>
	...

4037b30c <vTaskSuspendAll>:
{
4037b30c:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037b30f:	0063a0        	rsil	a10, 3
4037b312:	03eb80        	rsr.prid	a8
4037b315:	048d80        	extui	a8, a8, 13, 1
    ++uxSchedulerSuspended[ xPortGetCoreID() ];
4037b318:	e66191        	l32r	a9, 40374c9c <_iram_text_start+0x898>
4037b31b:	a08890        	addx4	a8, a8, a9
4037b31e:	0020c0        	memw
4037b321:	0898      	l32i.n	a9, a8, 0
4037b323:	991b      	addi.n	a9, a9, 1
4037b325:	0020c0        	memw
4037b328:	0899      	s32i.n	a9, a8, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037b32a:	e63281        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037b32d:	0008e0        	callx8	a8
}
4037b330:	f01d      	retw.n
	...

4037b334 <xTaskGetTickCount>:
{
4037b334:	004136        	entry	a1, 32
    xTicks = xTickCount;
4037b337:	e63921        	l32r	a2, 40374c1c <_iram_text_start+0x818>
4037b33a:	0020c0        	memw
4037b33d:	0228      	l32i.n	a2, a2, 0
}
4037b33f:	f01d      	retw.n
4037b341:	000000        	ill

4037b344 <xTaskGetIdleTaskHandleForCPU>:
    {
4037b344:	004136        	entry	a1, 32
        configASSERT( cpuid < configNUM_CORES );
4037b347:	1122b6        	bltui	a2, 2, 4037b35c <xTaskGetIdleTaskHandleForCPU+0x18>
4037b34a:	dda2b2        	movi	a11, 0x2dd
4037b34d:	e654d1        	l32r	a13, 40374ca0 <_iram_text_start+0x89c>
4037b350:	e655c1        	l32r	a12, 40374ca4 <_iram_text_start+0x8a0>
4037b353:	11bbe0        	slli	a11, a11, 2
        configASSERT( ( xIdleTaskHandle[cpuid] != NULL ) );
4037b356:	e639a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b359:	034b25        	call8	4037e80c <__assert_func>
4037b35c:	e65381        	l32r	a8, 40374ca8 <_iram_text_start+0x8a4>
4037b35f:	a02280        	addx4	a2, a2, a8
4037b362:	0228      	l32i.n	a2, a2, 0
4037b364:	d2cc      	bnez.n	a2, 4037b375 <xTaskGetIdleTaskHandleForCPU+0x31>
4037b366:	e651d1        	l32r	a13, 40374cac <_iram_text_start+0x8a8>
4037b369:	e64ec1        	l32r	a12, 40374ca4 <_iram_text_start+0x8a0>
4037b36c:	e651b1        	l32r	a11, 40374cb0 <_iram_text_start+0x8ac>
4037b36f:	fff8c6        	j	4037b356 <xTaskGetIdleTaskHandleForCPU+0x12>
4037b372:	00          	.byte 00
4037b373:	00          	.byte 00
4037b374:	00          	.byte 00
    }
4037b375:	f01d      	retw.n
	...

4037b378 <xTaskIncrementTick>:
{
4037b378:	004136        	entry	a1, 32
4037b37b:	03eb20        	rsr.prid	a2
4037b37e:	042d20        	extui	a2, a2, 13, 1
            configASSERT( xPortGetCoreID() == 0 );
4037b381:	d28c      	beqz.n	a2, 4037b392 <xTaskIncrementTick+0x1a>
4037b383:	e64cd1        	l32r	a13, 40374cb4 <_iram_text_start+0x8b0>
4037b386:	e64cc1        	l32r	a12, 40374cb8 <_iram_text_start+0x8b4>
4037b389:	e64cb1        	l32r	a11, 40374cbc <_iram_text_start+0x8b8>
            taskSWITCH_DELAYED_LISTS();
4037b38c:	e62ca1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b38f:	0347e5        	call8	4037e80c <__assert_func>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037b392:	e62f41        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037b395:	fb7c      	movi.n	a11, -1
4037b397:	04ad      	mov.n	a10, a4
4037b399:	012165        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if( uxSchedulerSuspended[ 0 ] == ( UBaseType_t ) pdFALSE )
4037b39c:	e64031        	l32r	a3, 40374c9c <_iram_text_start+0x898>
4037b39f:	0020c0        	memw
4037b3a2:	0338      	l32i.n	a3, a3, 0
4037b3a4:	135356        	bnez	a3, 4037b4dd <xTaskIncrementTick+0x165>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
4037b3a7:	e61d21        	l32r	a2, 40374c1c <_iram_text_start+0x818>
4037b3aa:	0020c0        	memw
4037b3ad:	0238      	l32i.n	a3, a2, 0
4037b3af:	331b      	addi.n	a3, a3, 1
        xTickCount = xConstTickCount;
4037b3b1:	0020c0        	memw
4037b3b4:	0239      	s32i.n	a3, a2, 0
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
4037b3b6:	046356        	bnez	a3, 4037b400 <xTaskIncrementTick+0x88>
            taskSWITCH_DELAYED_LISTS();
4037b3b9:	e61c21        	l32r	a2, 40374c2c <_iram_text_start+0x828>
4037b3bc:	0020c0        	memw
4037b3bf:	0258      	l32i.n	a5, a2, 0
4037b3c1:	0020c0        	memw
4037b3c4:	0558      	l32i.n	a5, a5, 0
4037b3c6:	a58c      	beqz.n	a5, 4037b3d4 <xTaskIncrementTick+0x5c>
4037b3c8:	e63ed1        	l32r	a13, 40374cc0 <_iram_text_start+0x8bc>
4037b3cb:	e63bc1        	l32r	a12, 40374cb8 <_iram_text_start+0x8b4>
4037b3ce:	e63db1        	l32r	a11, 40374cc4 <_iram_text_start+0x8c0>
4037b3d1:	ffedc6        	j	4037b38c <xTaskIncrementTick+0x14>
4037b3d4:	e61551        	l32r	a5, 40374c28 <_iram_text_start+0x824>
4037b3d7:	0020c0        	memw
4037b3da:	002262        	l32i	a6, a2, 0
4037b3dd:	0020c0        	memw
4037b3e0:	002572        	l32i	a7, a5, 0
4037b3e3:	0020c0        	memw
4037b3e6:	006272        	s32i	a7, a2, 0
4037b3e9:	0020c0        	memw
4037b3ec:	0569      	s32i.n	a6, a5, 0
4037b3ee:	e63651        	l32r	a5, 40374cc8 <_iram_text_start+0x8c4>
4037b3f1:	0020c0        	memw
4037b3f4:	0528      	l32i.n	a2, a5, 0
4037b3f6:	221b      	addi.n	a2, a2, 1
4037b3f8:	0020c0        	memw
4037b3fb:	0529      	s32i.n	a2, a5, 0
4037b3fd:	ffac65        	call8	4037aec4 <prvResetNextTaskUnblockTime>
        if( xConstTickCount >= xNextTaskUnblockTime )
4037b400:	e60c51        	l32r	a5, 40374c30 <_iram_text_start+0x82c>
4037b403:	0020c0        	memw
4037b406:	0528      	l32i.n	a2, a5, 0
4037b408:	36b327        	bgeu	a3, a2, 4037b442 <xTaskIncrementTick+0xca>
    BaseType_t xSwitchRequired = pdFALSE;
4037b40b:	020c      	movi.n	a2, 0
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB[ 0 ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b40d:	e4c531        	l32r	a3, 40374724 <_iram_text_start+0x320>
4037b410:	e61651        	l32r	a5, 40374c68 <_iram_text_start+0x864>
4037b413:	0020c0        	memw
4037b416:	0338      	l32i.n	a3, a3, 0
4037b418:	c338      	l32i.n	a3, a3, 48
4037b41a:	a03330        	addx4	a3, a3, a3
4037b41d:	a03350        	addx4	a3, a3, a5
4037b420:	0020c0        	memw
4037b423:	0338      	l32i.n	a3, a3, 0
4037b425:	0123b6        	bltui	a3, 2, 4037b42a <xTaskIncrementTick+0xb2>
                    xSwitchRequired = pdTRUE;
4037b428:	120c      	movi.n	a2, 1
        taskEXIT_CRITICAL_ISR();
4037b42a:	20a440        	or	a10, a4, a4
4037b42d:	012b65        	call8	4037c6e4 <vPortExitCritical>
                if( xYieldPending[ 0 ] != pdFALSE )
4037b430:	e62731        	l32r	a3, 40374ccc <_iram_text_start+0x8c8>
4037b433:	0020c0        	memw
4037b436:	002342        	l32i	a4, a3, 0
                    xSwitchRequired = pdTRUE;
4037b439:	01a032        	movi	a3, 1
4037b43c:	932340        	movnez	a2, a3, a4
}
4037b43f:	f01d      	retw.n
4037b441:	00          	.byte 00
    BaseType_t xSwitchRequired = pdFALSE;
4037b442:	020c      	movi.n	a2, 0
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
4037b444:	e5fa61        	l32r	a6, 40374c2c <_iram_text_start+0x828>
4037b447:	0020c0        	memw
4037b44a:	0688      	l32i.n	a8, a6, 0
4037b44c:	0020c0        	memw
4037b44f:	0888      	l32i.n	a8, a8, 0
4037b451:	88cc      	bnez.n	a8, 4037b45d <xTaskIncrementTick+0xe5>
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037b453:	f37c      	movi.n	a3, -1
4037b455:	0020c0        	memw
4037b458:	0539      	s32i.n	a3, a5, 0
                    break;
4037b45a:	ffebc6        	j	4037b40d <xTaskIncrementTick+0x95>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b45d:	e5f361        	l32r	a6, 40374c2c <_iram_text_start+0x828>
4037b460:	0020c0        	memw
4037b463:	0688      	l32i.n	a8, a6, 0
4037b465:	3888      	l32i.n	a8, a8, 12
4037b467:	3868      	l32i.n	a6, a8, 12
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
4037b469:	2698      	l32i.n	a9, a6, 8
                    if( xConstTickCount < xItemValue )
4037b46b:	07b397        	bgeu	a3, a9, 4037b476 <xTaskIncrementTick+0xfe>
                        xNextTaskUnblockTime = xItemValue;
4037b46e:	0020c0        	memw
4037b471:	0599      	s32i.n	a9, a5, 0
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
4037b473:	ffe586        	j	4037b40d <xTaskIncrementTick+0x95>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037b476:	08c672        	addi	a7, a6, 8
4037b479:	20a770        	or	a10, a7, a7
4037b47c:	0100a5        	call8	4037c488 <uxListRemove>
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037b47f:	b698      	l32i.n	a9, a6, 44
4037b481:	498c      	beqz.n	a9, 4037b489 <xTaskIncrementTick+0x111>
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037b483:	1cc6a2        	addi	a10, a6, 28
4037b486:	010025        	call8	4037c488 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037b489:	e5fe91        	l32r	a9, 40374c84 <_iram_text_start+0x880>
4037b48c:	c6a8      	l32i.n	a10, a6, 48
4037b48e:	0020c0        	memw
4037b491:	09c8      	l32i.n	a12, a9, 0
4037b493:	05bca7        	bgeu	a12, a10, 4037b49c <xTaskIncrementTick+0x124>
4037b496:	0020c0        	memw
4037b499:	0069a2        	s32i	a10, a9, 0
4037b49c:	e5f381        	l32r	a8, 40374c68 <_iram_text_start+0x864>
4037b49f:	a0aaa0        	addx4	a10, a10, a10
4037b4a2:	07bd      	mov.n	a11, a7
4037b4a4:	a0aa80        	addx4	a10, a10, a8
4037b4a7:	00f8a5        	call8	4037c430 <vListInsertEnd>
                            if( ( pxTCB->xCoreID == 0 || pxTCB->xCoreID == tskNO_AFFINITY ) && (pxTCB->uxPriority >= pxCurrentTCB[ 0 ]->uxPriority) )
4037b4aa:	1226a2        	l32i	a10, a6, 72
4037b4ad:	190c      	movi.n	a9, 1
4037b4af:	0b0c      	movi.n	a11, 0
4037b4b1:	83b9a0        	moveqz	a11, a9, a10
4037b4b4:	74c0b0        	extui	a12, a11, 0, 8
4037b4b7:	9bcc      	bnez.n	a11, 4037b4c4 <xTaskIncrementTick+0x14c>
4037b4b9:	e5e6b1        	l32r	a11, 40374c54 <_iram_text_start+0x850>
4037b4bc:	aaba      	add.n	a10, a10, a11
4037b4be:	939ca0        	movnez	a9, a12, a10
4037b4c1:	f7f916        	beqz	a9, 4037b444 <xTaskIncrementTick+0xcc>
4037b4c4:	e49891        	l32r	a9, 40374724 <_iram_text_start+0x320>
4037b4c7:	0020c0        	memw
4037b4ca:	09a8      	l32i.n	a10, a9, 0
4037b4cc:	c698      	l32i.n	a9, a6, 48
4037b4ce:	ca88      	l32i.n	a8, a10, 48
4037b4d0:	02b987        	bgeu	a9, a8, 4037b4d6 <xTaskIncrementTick+0x15e>
4037b4d3:	ffdb46        	j	4037b444 <xTaskIncrementTick+0xcc>
                                xSwitchRequired = pdTRUE;
4037b4d6:	120c      	movi.n	a2, 1
4037b4d8:	ffda06        	j	4037b444 <xTaskIncrementTick+0xcc>
4037b4db:	00          	.byte 00
4037b4dc:	00          	.byte 00
        ++xPendedTicks;
4037b4dd:	e5fc51        	l32r	a5, 40374cd0 <_iram_text_start+0x8cc>
        taskEXIT_CRITICAL_ISR();
4037b4e0:	20a440        	or	a10, a4, a4
        ++xPendedTicks;
4037b4e3:	0020c0        	memw
4037b4e6:	002532        	l32i	a3, a5, 0
4037b4e9:	01c332        	addi	a3, a3, 1
4037b4ec:	0020c0        	memw
4037b4ef:	0539      	s32i.n	a3, a5, 0
        taskEXIT_CRITICAL_ISR();
4037b4f1:	011f25        	call8	4037c6e4 <vPortExitCritical>
    return xSwitchRequired;
4037b4f4:	ffd1c6        	j	4037b43f <xTaskIncrementTick+0xc7>
	...

4037b4f8 <xTaskResumeAll>:
{
4037b4f8:	006136        	entry	a1, 48
4037b4fb:	03eb30        	rsr.prid	a3
4037b4fe:	043d30        	extui	a3, a3, 13, 1
    configASSERT( uxSchedulerSuspended[ xPortGetCoreID() ] );
4037b501:	e5e621        	l32r	a2, 40374c9c <_iram_text_start+0x898>
4037b504:	a03320        	addx4	a3, a3, a2
4037b507:	0020c0        	memw
4037b50a:	002332        	l32i	a3, a3, 0
4037b50d:	011356        	bnez	a3, 4037b522 <xTaskResumeAll+0x2a>
4037b510:	3ba1b2        	movi	a11, 0x13b
4037b513:	e5f0d1        	l32r	a13, 40374cd4 <_iram_text_start+0x8d0>
4037b516:	e5f0c1        	l32r	a12, 40374cd8 <_iram_text_start+0x8d4>
4037b519:	e5c8a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b51c:	11bbd0        	slli	a11, a11, 3
4037b51f:	032ee5        	call8	4037e80c <__assert_func>
4037b522:	e5cb71        	l32r	a7, 40374c50 <_iram_text_start+0x84c>
4037b525:	ffafb2        	movi	a11, -1
4037b528:	07ad      	mov.n	a10, a7
4037b52a:	010865        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037b52d:	03eb50        	rsr.prid	a5
4037b530:	045d50        	extui	a5, a5, 13, 1
        --uxSchedulerSuspended[ xCoreID ];
4037b533:	a02520        	addx4	a2, a5, a2
4037b536:	0020c0        	memw
4037b539:	0238      	l32i.n	a3, a2, 0
4037b53b:	1145e0        	slli	a4, a5, 2
4037b53e:	330b      	addi.n	a3, a3, -1
4037b540:	0020c0        	memw
4037b543:	0239      	s32i.n	a3, a2, 0
        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) pdFALSE )
4037b545:	0020c0        	memw
4037b548:	0228      	l32i.n	a2, a2, 0
4037b54a:	a28c      	beqz.n	a2, 4037b558 <xTaskResumeAll+0x60>
    BaseType_t xAlreadyYielded = pdFALSE;
4037b54c:	00a022        	movi	a2, 0
    taskEXIT_CRITICAL();
4037b54f:	20a770        	or	a10, a7, a7
4037b552:	011925        	call8	4037c6e4 <vPortExitCritical>
}
4037b555:	000090        	retw
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
4037b558:	e5c231        	l32r	a3, 40374c60 <_iram_text_start+0x85c>
4037b55b:	0020c0        	memw
4037b55e:	0338      	l32i.n	a3, a3, 0
4037b560:	fe8316        	beqz	a3, 4037b54c <xTaskResumeAll+0x54>
                while( listLIST_IS_EMPTY( &xPendingReadyList[ xCoreID ] ) == pdFALSE )
4037b563:	e5c461        	l32r	a6, 40374c74 <_iram_text_start+0x870>
4037b566:	345a      	add.n	a3, a4, a5
4037b568:	a03360        	addx4	a3, a3, a6
                    if( pxTCB->uxPriority >= pxCurrentTCB[ xCoreID ]->uxPriority )
4037b56b:	e46e61        	l32r	a6, 40374724 <_iram_text_start+0x320>
4037b56e:	664a      	add.n	a6, a6, a4
4037b570:	001346        	j	4037b5c1 <xTaskResumeAll+0xc9>
4037b573:	00          	.byte 00
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList[ xCoreID ] ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b574:	032322        	l32i	a2, a3, 12
4037b577:	032222        	l32i	a2, a2, 12
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037b57a:	1cc2a2        	addi	a10, a2, 28
4037b57d:	00f0a5        	call8	4037c488 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037b580:	b28b      	addi.n	a11, a2, 8
4037b582:	0bad      	mov.n	a10, a11
4037b584:	01b9      	s32i.n	a11, a1, 0
4037b586:	00f025        	call8	4037c488 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037b589:	e5be81        	l32r	a8, 40374c84 <_iram_text_start+0x880>
4037b58c:	c2a8      	l32i.n	a10, a2, 48
4037b58e:	0020c0        	memw
4037b591:	0898      	l32i.n	a9, a8, 0
4037b593:	01b8      	l32i.n	a11, a1, 0
4037b595:	04b9a7        	bgeu	a9, a10, 4037b59d <xTaskResumeAll+0xa5>
4037b598:	0020c0        	memw
4037b59b:	08a9      	s32i.n	a10, a8, 0
4037b59d:	e5b281        	l32r	a8, 40374c68 <_iram_text_start+0x864>
4037b5a0:	a0aaa0        	addx4	a10, a10, a10
4037b5a3:	a0aa80        	addx4	a10, a10, a8
4037b5a6:	00e8a5        	call8	4037c430 <vListInsertEnd>
                    if( pxTCB->uxPriority >= pxCurrentTCB[ xCoreID ]->uxPriority )
4037b5a9:	0020c0        	memw
4037b5ac:	0688      	l32i.n	a8, a6, 0
4037b5ae:	c298      	l32i.n	a9, a2, 48
4037b5b0:	c888      	l32i.n	a8, a8, 48
4037b5b2:	0b3987        	bltu	a9, a8, 4037b5c1 <xTaskResumeAll+0xc9>
                        xYieldPending[ xCoreID ] = pdTRUE;
4037b5b5:	e5c581        	l32r	a8, 40374ccc <_iram_text_start+0x8c8>
4037b5b8:	190c      	movi.n	a9, 1
4037b5ba:	884a      	add.n	a8, a8, a4
4037b5bc:	0020c0        	memw
4037b5bf:	0899      	s32i.n	a9, a8, 0
                while( listLIST_IS_EMPTY( &xPendingReadyList[ xCoreID ] ) == pdFALSE )
4037b5c1:	0020c0        	memw
4037b5c4:	0388      	l32i.n	a8, a3, 0
4037b5c6:	faa856        	bnez	a8, 4037b574 <xTaskResumeAll+0x7c>
                if( pxTCB != NULL )
4037b5c9:	005216        	beqz	a2, 4037b5d2 <xTaskResumeAll+0xda>
                    prvResetNextTaskUnblockTime();
4037b5cc:	201110        	or	a1, a1, a1
4037b5cf:	ff8f65        	call8	4037aec4 <prvResetNextTaskUnblockTime>
                if ( xCoreID == 0 )
4037b5d2:	25ec      	bnez.n	a5, 4037b5f8 <xTaskResumeAll+0x100>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
4037b5d4:	e5bf31        	l32r	a3, 40374cd0 <_iram_text_start+0x8cc>
4037b5d7:	0020c0        	memw
4037b5da:	0328      	l32i.n	a2, a3, 0
                    if( xPendedCounts > ( TickType_t ) 0U )
4037b5dc:	829c      	beqz.n	a2, 4037b5f8 <xTaskResumeAll+0x100>
                                xYieldPending[ xCoreID ] = pdTRUE;
4037b5de:	e5bb51        	l32r	a5, 40374ccc <_iram_text_start+0x8c8>
                            if( xTaskIncrementTick() != pdFALSE )
4037b5e1:	ffd965        	call8	4037b378 <xTaskIncrementTick>
4037b5e4:	6a8c      	beqz.n	a10, 4037b5ee <xTaskResumeAll+0xf6>
                                xYieldPending[ xCoreID ] = pdTRUE;
4037b5e6:	160c      	movi.n	a6, 1
4037b5e8:	0020c0        	memw
4037b5eb:	006562        	s32i	a6, a5, 0
                            --xPendedCounts;
4037b5ee:	220b      	addi.n	a2, a2, -1
                        } while( xPendedCounts > ( TickType_t ) 0U );
4037b5f0:	fed256        	bnez	a2, 4037b5e1 <xTaskResumeAll+0xe9>
                        xPendedTicks = 0;
4037b5f3:	0020c0        	memw
4037b5f6:	0329      	s32i.n	a2, a3, 0
                if( xYieldPending[ xCoreID ] != pdFALSE )
4037b5f8:	e5b521        	l32r	a2, 40374ccc <_iram_text_start+0x8c8>
4037b5fb:	224a      	add.n	a2, a2, a4
4037b5fd:	0020c0        	memw
4037b600:	0228      	l32i.n	a2, a2, 0
4037b602:	f46216        	beqz	a2, 4037b54c <xTaskResumeAll+0x54>
4037b605:	03eba0        	rsr.prid	a10
4037b608:	04ada0        	extui	a10, a10, 13, 1
                            xAlreadyYielded = pdTRUE;
4037b60b:	120c      	movi.n	a2, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037b60d:	fca325        	call8	40378040 <esp_crosscore_int_send_yield>
4037b610:	ffcec6        	j	4037b54f <xTaskResumeAll+0x57>
	...

4037b614 <xTaskIncrementTickOtherCores>:
    {
4037b614:	004136        	entry	a1, 32
4037b617:	03eb20        	rsr.prid	a2
4037b61a:	042d20        	extui	a2, a2, 13, 1
        configASSERT( xCoreID != 0 );
4037b61d:	014256        	bnez	a2, 4037b635 <xTaskIncrementTickOtherCores+0x21>
4037b620:	3ba3b2        	movi	a11, 0x33b
4037b623:	e5aed1        	l32r	a13, 40374cdc <_iram_text_start+0x8d8>
4037b626:	e5aec1        	l32r	a12, 40374ce0 <_iram_text_start+0x8dc>
4037b629:	e584a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b62c:	11bbe0        	slli	a11, a11, 2
4037b62f:	201110        	or	a1, a1, a1
4037b632:	031da5        	call8	4037e80c <__assert_func>
        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) pdFALSE )
4037b635:	e59941        	l32r	a4, 40374c9c <_iram_text_start+0x898>
4037b638:	1132e0        	slli	a3, a2, 2
4037b63b:	a02240        	addx4	a2, a2, a4
4037b63e:	0020c0        	memw
4037b641:	002252        	l32i	a5, a2, 0
        BaseType_t xSwitchRequired = pdFALSE;
4037b644:	00a022        	movi	a2, 0
        if( uxSchedulerSuspended[ xCoreID ] == ( UBaseType_t ) pdFALSE )
4037b647:	519527        	bne	a5, a2, 4037b69c <xTaskIncrementTickOtherCores+0x88>
4037b64a:	e58141        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037b64d:	fb7c      	movi.n	a11, -1
4037b64f:	04ad      	mov.n	a10, a4
4037b651:	00f5e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
                    if( uxTopReadyPriority > pxCurrentTCB[xCoreID]->uxPriority )
4037b654:	e43421        	l32r	a2, 40374724 <_iram_text_start+0x320>
                    if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b657:	e584a1        	l32r	a10, 40374c68 <_iram_text_start+0x864>
                    if( uxTopReadyPriority > pxCurrentTCB[xCoreID]->uxPriority )
4037b65a:	223a      	add.n	a2, a2, a3
4037b65c:	0020c0        	memw
4037b65f:	0288      	l32i.n	a8, a2, 0
4037b661:	c898      	l32i.n	a9, a8, 48
4037b663:	e58881        	l32r	a8, 40374c84 <_iram_text_start+0x880>
4037b666:	0020c0        	memw
4037b669:	0888      	l32i.n	a8, a8, 0
                    if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b66b:	0020c0        	memw
4037b66e:	0228      	l32i.n	a2, a2, 0
4037b670:	c228      	l32i.n	a2, a2, 48
4037b672:	a02220        	addx4	a2, a2, a2
4037b675:	a022a0        	addx4	a2, a2, a10
4037b678:	0020c0        	memw
4037b67b:	02a8      	l32i.n	a10, a2, 0
                        xSwitchRequired = pdTRUE;
4037b67d:	120c      	movi.n	a2, 1
                    if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB[ xCoreID ]->uxPriority ] ) ) > ( UBaseType_t ) 1 )
4037b67f:	052af6        	bgeui	a10, 2, 4037b688 <xTaskIncrementTickOtherCores+0x74>
                    if( uxTopReadyPriority > pxCurrentTCB[xCoreID]->uxPriority )
4037b682:	023987        	bltu	a9, a8, 4037b688 <xTaskIncrementTickOtherCores+0x74>
4037b685:	202550        	or	a2, a5, a5
            taskEXIT_CRITICAL_ISR();
4037b688:	04ad      	mov.n	a10, a4
4037b68a:	0105a5        	call8	4037c6e4 <vPortExitCritical>
                    if( xYieldPending[ xCoreID ] != pdFALSE )
4037b68d:	e58f81        	l32r	a8, 40374ccc <_iram_text_start+0x8c8>
4037b690:	383a      	add.n	a3, a8, a3
4037b692:	0020c0        	memw
4037b695:	0348      	l32i.n	a4, a3, 0
                        xSwitchRequired = pdTRUE;
4037b697:	130c      	movi.n	a3, 1
4037b699:	932340        	movnez	a2, a3, a4
    }
4037b69c:	f01d      	retw.n
	...

4037b6a0 <vTaskSwitchContext>:
{
4037b6a0:	006136        	entry	a1, 48
4037b6a3:	e56b41        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037b6a6:	ffafb2        	movi	a11, -1
4037b6a9:	20a440        	or	a10, a4, a4
4037b6ac:	00f025        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037b6af:	03eb20        	rsr.prid	a2
4037b6b2:	042d20        	extui	a2, a2, 13, 1
    if( uxSchedulerSuspended[ xPortGetCoreID() ] != ( UBaseType_t ) pdFALSE )
4037b6b5:	e57931        	l32r	a3, 40374c9c <_iram_text_start+0x898>
4037b6b8:	e58551        	l32r	a5, 40374ccc <_iram_text_start+0x8c8>
4037b6bb:	a02230        	addx4	a2, a2, a3
4037b6be:	0020c0        	memw
4037b6c1:	0238      	l32i.n	a3, a2, 0
4037b6c3:	539c      	beqz.n	a3, 4037b6dc <vTaskSwitchContext+0x3c>
4037b6c5:	03eb20        	rsr.prid	a2
4037b6c8:	042d20        	extui	a2, a2, 13, 1
        xYieldPending[ xPortGetCoreID() ] = pdTRUE;
4037b6cb:	130c      	movi.n	a3, 1
4037b6cd:	a02250        	addx4	a2, a2, a5
        xSwitchingContext[ xPortGetCoreID() ] = pdFALSE;
4037b6d0:	0020c0        	memw
4037b6d3:	0239      	s32i.n	a3, a2, 0
    taskEXIT_CRITICAL_ISR();
4037b6d5:	04ad      	mov.n	a10, a4
4037b6d7:	0100e5        	call8	4037c6e4 <vPortExitCritical>
}
4037b6da:	f01d      	retw.n
4037b6dc:	03eb20        	rsr.prid	a2
4037b6df:	042d20        	extui	a2, a2, 13, 1
        xYieldPending[ xPortGetCoreID() ] = pdFALSE;
4037b6e2:	a02250        	addx4	a2, a2, a5
4037b6e5:	0020c0        	memw
4037b6e8:	0239      	s32i.n	a3, a2, 0
4037b6ea:	03eb20        	rsr.prid	a2
4037b6ed:	042d20        	extui	a2, a2, 13, 1
        xSwitchingContext[ xPortGetCoreID() ] = pdTRUE;
4037b6f0:	e57d31        	l32r	a3, 40374ce4 <_iram_text_start+0x8e0>
4037b6f3:	a02230        	addx4	a2, a2, a3
4037b6f6:	130c      	movi.n	a3, 1
4037b6f8:	0020c0        	memw
4037b6fb:	0239      	s32i.n	a3, a2, 0
4037b6fd:	03eb20        	rsr.prid	a2
4037b700:	042d20        	extui	a2, a2, 13, 1
        taskFIRST_CHECK_FOR_STACK_OVERFLOW();
4037b703:	e40831        	l32r	a3, 40374724 <_iram_text_start+0x320>
4037b706:	a02230        	addx4	a2, a2, a3
4037b709:	0020c0        	memw
4037b70c:	0278      	l32i.n	a7, a2, 0
4037b70e:	03eb20        	rsr.prid	a2
4037b711:	042d20        	extui	a2, a2, 13, 1
4037b714:	a02230        	addx4	a2, a2, a3
4037b717:	0020c0        	memw
4037b71a:	0268      	l32i.n	a6, a2, 0
4037b71c:	0728      	l32i.n	a2, a7, 0
4037b71e:	d668      	l32i.n	a6, a6, 52
4037b720:	213627        	bltu	a6, a2, 4037b745 <vTaskSwitchContext+0xa5>
4037b723:	03eb20        	rsr.prid	a2
4037b726:	042d20        	extui	a2, a2, 13, 1
4037b729:	a02230        	addx4	a2, a2, a3
4037b72c:	0020c0        	memw
4037b72f:	02a8      	l32i.n	a10, a2, 0
4037b731:	03eb20        	rsr.prid	a2
4037b734:	042d20        	extui	a2, a2, 13, 1
4037b737:	a02230        	addx4	a2, a2, a3
4037b73a:	0020c0        	memw
4037b73d:	02b8      	l32i.n	a11, a2, 0
4037b73f:	38cbb2        	addi	a11, a11, 56
4037b742:	010365        	call8	4037c778 <vApplicationStackOverflowHook>
4037b745:	03eb20        	rsr.prid	a2
4037b748:	042d20        	extui	a2, a2, 13, 1
        taskSECOND_CHECK_FOR_STACK_OVERFLOW();
4037b74b:	a02230        	addx4	a2, a2, a3
4037b74e:	0020c0        	memw
4037b751:	0228      	l32i.n	a2, a2, 0
4037b753:	e565b1        	l32r	a11, 40374ce8 <_iram_text_start+0x8e4>
4037b756:	d2a8      	l32i.n	a10, a2, 52
4037b758:	4c1c      	movi.n	a12, 20
4037b75a:	e56781        	l32r	a8, 40374cf8 <_iram_text_start+0x8f4>
4037b75d:	0008e0        	callx8	a8
4037b760:	0aac      	beqz.n	a10, 4037b784 <vTaskSwitchContext+0xe4>
4037b762:	03eb20        	rsr.prid	a2
4037b765:	042d20        	extui	a2, a2, 13, 1
4037b768:	a02230        	addx4	a2, a2, a3
4037b76b:	0020c0        	memw
4037b76e:	02a8      	l32i.n	a10, a2, 0
4037b770:	03eb20        	rsr.prid	a2
4037b773:	042d20        	extui	a2, a2, 13, 1
4037b776:	a02230        	addx4	a2, a2, a3
4037b779:	0020c0        	memw
4037b77c:	02b8      	l32i.n	a11, a2, 0
4037b77e:	38cbb2        	addi	a11, a11, 56
4037b781:	00ff65        	call8	4037c778 <vApplicationStackOverflowHook>
4037b784:	03eb60        	rsr.prid	a6
4037b787:	046d60        	extui	a6, a6, 13, 1
    for ( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037b78a:	e53e81        	l32r	a8, 40374c84 <_iram_text_start+0x880>
    BaseType_t xNewTopPrioritySet = pdFALSE;
4037b78d:	0a0c      	movi.n	a10, 0
    for ( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037b78f:	0020c0        	memw
4037b792:	002872        	l32i	a7, a8, 0
4037b795:	e53481        	l32r	a8, 40374c68 <_iram_text_start+0x864>
4037b798:	a02770        	addx4	a2, a7, a7
4037b79b:	a02280        	addx4	a2, a2, a8
4037b79e:	150c      	movi.n	a5, 1
    BaseType_t xTaskScheduled = pdFALSE;
4037b7a0:	208aa0        	or	a8, a10, a10
            pxCurrentTCB[ xCoreID ] = pxTCBCur;
4037b7a3:	a0d630        	addx4	a13, a6, a3
    for ( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037b7a6:	002796        	bltz	a7, 4037b7ac <vTaskSwitchContext+0x10c>
4037b7a9:	119857        	bne	a8, a5, 4037b7be <vTaskSwitchContext+0x11e>
    assert( xTaskScheduled == pdTRUE ); /* At this point, a task MUST have been scheduled */
4037b7ac:	0ac856        	bnez	a8, 4037b85c <vTaskSwitchContext+0x1bc>
4037b7af:	e54fd1        	l32r	a13, 40374cec <_iram_text_start+0x8e8>
4037b7b2:	e54fc1        	l32r	a12, 40374cf0 <_iram_text_start+0x8ec>
4037b7b5:	e54fb1        	l32r	a11, 40374cf4 <_iram_text_start+0x8f0>
4037b7b8:	e521a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b7bb:	030525        	call8	4037e80c <__assert_func>
        if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxCurPriority ] ) ) )
4037b7be:	e52ab1        	l32r	a11, 40374c68 <_iram_text_start+0x864>
4037b7c1:	a08770        	addx4	a8, a7, a7
4037b7c4:	a088b0        	addx4	a8, a8, a11
4037b7c7:	0020c0        	memw
4037b7ca:	08b8      	l32i.n	a11, a8, 0
4037b7cc:	080c      	movi.n	a8, 0
4037b7ce:	641b87        	beq	a11, a8, 4037b836 <vTaskSwitchContext+0x196>
        if( xNewTopPrioritySet == pdFALSE )
4037b7d1:	079a87        	bne	a10, a8, 4037b7dc <vTaskSwitchContext+0x13c>
            uxTopReadyPriority = uxCurPriority;
4037b7d4:	e52c81        	l32r	a8, 40374c84 <_iram_text_start+0x880>
4037b7d7:	0020c0        	memw
4037b7da:	0879      	s32i.n	a7, a8, 0
        listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037b7dc:	32a8      	l32i.n	a10, a2, 12
4037b7de:	828b      	addi.n	a8, a2, 8
4037b7e0:	12a9      	s32i.n	a10, a2, 4
4037b7e2:	039a87        	bne	a10, a8, 4037b7e9 <vTaskSwitchContext+0x149>
4037b7e5:	18a8      	l32i.n	a10, a8, 4
4037b7e7:	12a9      	s32i.n	a10, a2, 4
4037b7e9:	12a8      	l32i.n	a10, a2, 4
            if ( ( pxTCBCur->xCoreID != xCoreID ) && ( pxTCBCur->xCoreID != tskNO_AFFINITY ) )
4037b7eb:	e51af1        	l32r	a15, 40374c54 <_iram_text_start+0x850>
        listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037b7ee:	3ae8      	l32i.n	a14, a10, 12
4037b7f0:	0ebd      	mov.n	a11, a14
                if ( ux == xCoreID )
4037b7f2:	a68c      	beqz.n	a6, 4037b800 <vTaskSwitchContext+0x160>
                else if ( pxCurrentTCB[ux] == pxTCBCur )
4037b7f4:	0020c0        	memw
4037b7f7:	0023a2        	l32i	a10, a3, 0
4037b7fa:	401ab7        	beq	a10, a11, 4037b83e <vTaskSwitchContext+0x19e>
                if ( ux == xCoreID )
4037b7fd:	081626        	beqi	a6, 1, 4037b809 <vTaskSwitchContext+0x169>
                else if ( pxCurrentTCB[ux] == pxTCBCur )
4037b800:	0020c0        	memw
4037b803:	0123a2        	l32i	a10, a3, 4
4037b806:	341ba7        	beq	a11, a10, 4037b83e <vTaskSwitchContext+0x19e>
            if ( ( pxTCBCur->xCoreID != xCoreID ) && ( pxTCBCur->xCoreID != tskNO_AFFINITY ) )
4037b809:	122ba2        	l32i	a10, a11, 72
4037b80c:	0416a7        	beq	a6, a10, 4037b814 <vTaskSwitchContext+0x174>
4037b80f:	80aaf0        	add	a10, a10, a15
4037b812:	8aec      	bnez.n	a10, 4037b83e <vTaskSwitchContext+0x19e>
            pxCurrentTCB[ xCoreID ] = pxTCBCur;
4037b814:	0020c0        	memw
4037b817:	006db2        	s32i	a11, a13, 0
            uxListRemove( &( pxTCBCur->xStateListItem ) );
4037b81a:	08cbb2        	addi	a11, a11, 8
            pxReadyTasksLists[ uxCurPriority ].pxIndex = ( ListItem_t * ) &( pxReadyTasksLists[ uxCurPriority ].xListEnd );
4037b81d:	1289      	s32i.n	a8, a2, 4
            uxListRemove( &( pxTCBCur->xStateListItem ) );
4037b81f:	0bad      	mov.n	a10, a11
4037b821:	11d9      	s32i.n	a13, a1, 4
4037b823:	0061b2        	s32i	a11, a1, 0
4037b826:	00c625        	call8	4037c488 <uxListRemove>
            vListInsertEnd( &( pxReadyTasksLists[ uxCurPriority ] ), &( pxTCBCur->xStateListItem ) );
4037b829:	01b8      	l32i.n	a11, a1, 0
4037b82b:	02ad      	mov.n	a10, a2
4037b82d:	00c025        	call8	4037c430 <vListInsertEnd>
            break;
4037b830:	11d8      	l32i.n	a13, a1, 4
4037b832:	05ad      	mov.n	a10, a5
            xTaskScheduled = pdTRUE;
4037b834:	180c      	movi.n	a8, 1
    for ( uxCurPriority = uxTopReadyPriority; uxCurPriority >= 0 && xTaskScheduled == pdFALSE; uxCurPriority-- )
4037b836:	770b      	addi.n	a7, a7, -1
4037b838:	ecc222        	addi	a2, a2, -20
4037b83b:	ffd9c6        	j	4037b7a6 <vTaskSwitchContext+0x106>
            listGET_OWNER_OF_NEXT_ENTRY( pxTCBCur, &( pxReadyTasksLists[ uxCurPriority ] ) );
4037b83e:	12a8      	l32i.n	a10, a2, 4
4037b840:	1aa8      	l32i.n	a10, a10, 4
4037b842:	12a9      	s32i.n	a10, a2, 4
4037b844:	049a87        	bne	a10, a8, 4037b84c <vTaskSwitchContext+0x1ac>
4037b847:	18a8      	l32i.n	a10, a8, 4
4037b849:	0162a2        	s32i	a10, a2, 4
4037b84c:	12a8      	l32i.n	a10, a2, 4
4037b84e:	3ab8      	l32i.n	a11, a10, 12
        } while( pxTCBCur != pxTCBFirst);  /* Check to see if we've walked the entire list */
4037b850:	9e9eb7        	bne	a14, a11, 4037b7f2 <vTaskSwitchContext+0x152>
4037b853:	05ad      	mov.n	a10, a5
4037b855:	080c      	movi.n	a8, 0
4037b857:	fff6c6        	j	4037b836 <vTaskSwitchContext+0x196>
4037b85a:	00          	.byte 00
4037b85b:	00          	.byte 00
4037b85c:	03eb20        	rsr.prid	a2
4037b85f:	042d20        	extui	a2, a2, 13, 1
        xSwitchingContext[ xPortGetCoreID() ] = pdFALSE;
4037b862:	e52031        	l32r	a3, 40374ce4 <_iram_text_start+0x8e0>
4037b865:	a02230        	addx4	a2, a2, a3
4037b868:	030c      	movi.n	a3, 0
4037b86a:	ff9886        	j	4037b6d0 <vTaskSwitchContext+0x30>
4037b86d:	000000        	ill

4037b870 <vTaskPlaceOnEventList>:
{
4037b870:	004136        	entry	a1, 32
    configASSERT( pxEventList );
4037b873:	00e256        	bnez	a2, 4037b885 <vTaskPlaceOnEventList+0x15>
4037b876:	e521d1        	l32r	a13, 40374cfc <_iram_text_start+0x8f8>
4037b879:	e521c1        	l32r	a12, 40374d00 <_iram_text_start+0x8fc>
4037b87c:	e522b1        	l32r	a11, 40374d04 <_iram_text_start+0x900>
4037b87f:	e4efa1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b882:	02f8a5        	call8	4037e80c <__assert_func>
4037b885:	e4f241        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037b888:	fb7c      	movi.n	a11, -1
4037b88a:	04ad      	mov.n	a10, a4
4037b88c:	00d225        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037b88f:	03eb80        	rsr.prid	a8
4037b892:	048d80        	extui	a8, a8, 13, 1
    vListInsert( pxEventList, &( pxCurrentTCB[xPortGetCoreID()]->xEventListItem ) );
4037b895:	e3a391        	l32r	a9, 40374724 <_iram_text_start+0x320>
4037b898:	02ad      	mov.n	a10, a2
4037b89a:	a08890        	addx4	a8, a8, a9
4037b89d:	0020c0        	memw
4037b8a0:	08b8      	l32i.n	a11, a8, 0
4037b8a2:	1ccbb2        	addi	a11, a11, 28
4037b8a5:	00bae5        	call8	4037c454 <vListInsert>
4037b8a8:	03eba0        	rsr.prid	a10
4037b8ab:	04ada0        	extui	a10, a10, 13, 1
    prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTicksToWait);
4037b8ae:	03bd      	mov.n	a11, a3
4037b8b0:	ff57a5        	call8	4037ae2c <prvAddCurrentTaskToDelayedList>
    taskEXIT_CRITICAL();
4037b8b3:	04ad      	mov.n	a10, a4
4037b8b5:	00e2e5        	call8	4037c6e4 <vPortExitCritical>
}
4037b8b8:	f01d      	retw.n
	...

4037b8bc <xTaskRemoveFromEventList>:
{
4037b8bc:	004136        	entry	a1, 32
4037b8bf:	e4e441        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037b8c2:	ffafb2        	movi	a11, -1
4037b8c5:	20a440        	or	a10, a4, a4
4037b8c8:	00ce65        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    if ( ( listLIST_IS_EMPTY( pxEventList ) ) == pdFALSE )
4037b8cb:	0020c0        	memw
4037b8ce:	0238      	l32i.n	a3, a2, 0
4037b8d0:	0c4316        	beqz	a3, 4037b998 <xTaskRemoveFromEventList+0xdc>
        pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
4037b8d3:	3228      	l32i.n	a2, a2, 12
4037b8d5:	3238      	l32i.n	a3, a2, 12
        configASSERT( pxUnblockedTCB );
4037b8d7:	00e356        	bnez	a3, 4037b8e9 <xTaskRemoveFromEventList+0x2d>
4037b8da:	e50bd1        	l32r	a13, 40374d08 <_iram_text_start+0x904>
4037b8dd:	e50bc1        	l32r	a12, 40374d0c <_iram_text_start+0x908>
4037b8e0:	e50cb1        	l32r	a11, 40374d10 <_iram_text_start+0x90c>
4037b8e3:	e4d6a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b8e6:	02f265        	call8	4037e80c <__assert_func>
        ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
4037b8e9:	1cc352        	addi	a5, a3, 28
4037b8ec:	05ad      	mov.n	a10, a5
4037b8ee:	00b9a5        	call8	4037c488 <uxListRemove>
    if ( pxUnblockedTCB->xCoreID == tskNO_AFFINITY )
4037b8f1:	1223a2        	l32i	a10, a3, 72
4037b8f4:	e3c681        	l32r	a8, 4037480c <_iram_text_start+0x408>
4037b8f7:	e4e921        	l32r	a2, 40374c9c <_iram_text_start+0x898>
4037b8fa:	021a87        	beq	a10, a8, 4037b900 <xTaskRemoveFromEventList+0x44>
4037b8fd:	0028c6        	j	4037b9a4 <xTaskRemoveFromEventList+0xe8>
4037b900:	03eba0        	rsr.prid	a10
4037b903:	04ada0        	extui	a10, a10, 13, 1
            if ( uxSchedulerSuspended[ i ] == ( UBaseType_t ) pdFALSE )
4037b906:	0020c0        	memw
4037b909:	0288      	l32i.n	a8, a2, 0
4037b90b:	007816        	beqz	a8, 4037b916 <xTaskRemoveFromEventList+0x5a>
4037b90e:	0020c0        	memw
4037b911:	1228      	l32i.n	a2, a2, 4
    if( xTaskCanBeReady )
4037b913:	099256        	bnez	a2, 4037b9b0 <xTaskRemoveFromEventList+0xf4>
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
4037b916:	08c322        	addi	a2, a3, 8
4037b919:	20a220        	or	a10, a2, a2
4037b91c:	00b6a5        	call8	4037c488 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
4037b91f:	e4d951        	l32r	a5, 40374c84 <_iram_text_start+0x880>
4037b922:	0c23a2        	l32i	a10, a3, 48
4037b925:	0020c0        	memw
4037b928:	0588      	l32i.n	a8, a5, 0
4037b92a:	04b8a7        	bgeu	a8, a10, 4037b932 <xTaskRemoveFromEventList+0x76>
4037b92d:	0020c0        	memw
4037b930:	05a9      	s32i.n	a10, a5, 0
4037b932:	02bd      	mov.n	a11, a2
4037b934:	e4cd21        	l32r	a2, 40374c68 <_iram_text_start+0x864>
4037b937:	a0aaa0        	addx4	a10, a10, a10
        vListInsertEnd( &( xPendingReadyList[ uxTargetCPU ] ), &( pxUnblockedTCB->xEventListItem ) );
4037b93a:	a0aa20        	addx4	a10, a10, a2
4037b93d:	00af25        	call8	4037c430 <vListInsertEnd>
    if ( tskCAN_RUN_HERE(pxUnblockedTCB->xCoreID) && pxUnblockedTCB->uxPriority >= pxCurrentTCB[ xPortGetCoreID() ]->uxPriority )
4037b940:	1223a2        	l32i	a10, a3, 72
4037b943:	03eb90        	rsr.prid	a9
4037b946:	049d90        	extui	a9, a9, 13, 1
4037b949:	120c      	movi.n	a2, 1
4037b94b:	c099a0        	sub	a9, a9, a10
4037b94e:	080c      	movi.n	a8, 0
4037b950:	838290        	moveqz	a8, a2, a9
4037b953:	745080        	extui	a5, a8, 0, 8
4037b956:	00a856        	bnez	a8, 4037b964 <xTaskRemoveFromEventList+0xa8>
4037b959:	e4be81        	l32r	a8, 40374c54 <_iram_text_start+0x850>
4037b95c:	8a8a      	add.n	a8, a10, a8
4037b95e:	932580        	movnez	a2, a5, a8
4037b961:	058216        	beqz	a2, 4037b9bd <xTaskRemoveFromEventList+0x101>
4037b964:	03eb20        	rsr.prid	a2
4037b967:	042d20        	extui	a2, a2, 13, 1
4037b96a:	e36e51        	l32r	a5, 40374724 <_iram_text_start+0x320>
4037b96d:	a02250        	addx4	a2, a2, a5
4037b970:	0020c0        	memw
4037b973:	0228      	l32i.n	a2, a2, 0
4037b975:	c358      	l32i.n	a5, a3, 48
4037b977:	c228      	l32i.n	a2, a2, 48
4037b979:	403527        	bltu	a5, a2, 4037b9bd <xTaskRemoveFromEventList+0x101>
4037b97c:	03eb30        	rsr.prid	a3
4037b97f:	043d30        	extui	a3, a3, 13, 1
        xYieldPending[ xPortGetCoreID() ] = pdTRUE;
4037b982:	e4d221        	l32r	a2, 40374ccc <_iram_text_start+0x8c8>
4037b985:	a03320        	addx4	a3, a3, a2
4037b988:	120c      	movi.n	a2, 1
4037b98a:	0020c0        	memw
4037b98d:	006322        	s32i	a2, a3, 0
    taskEXIT_CRITICAL_ISR();
4037b990:	04ad      	mov.n	a10, a4
4037b992:	00d525        	call8	4037c6e4 <vPortExitCritical>
    return xReturn;
4037b995:	000206        	j	4037b9a1 <xTaskRemoveFromEventList+0xe5>
        taskEXIT_CRITICAL_ISR();
4037b998:	20a440        	or	a10, a4, a4
4037b99b:	00d4a5        	call8	4037c6e4 <vPortExitCritical>
        return pdFALSE;
4037b99e:	202330        	or	a2, a3, a3
}
4037b9a1:	000090        	retw
        xTaskCanBeReady = uxSchedulerSuspended[ uxTargetCPU ] == ( UBaseType_t ) pdFALSE;
4037b9a4:	a02a20        	addx4	a2, a10, a2
4037b9a7:	0020c0        	memw
4037b9aa:	0228      	l32i.n	a2, a2, 0
4037b9ac:	ffd8c6        	j	4037b913 <xTaskRemoveFromEventList+0x57>
4037b9af:	00          	.byte 00
        vListInsertEnd( &( xPendingReadyList[ uxTargetCPU ] ), &( pxUnblockedTCB->xEventListItem ) );
4037b9b0:	e4b121        	l32r	a2, 40374c74 <_iram_text_start+0x870>
4037b9b3:	a0aaa0        	addx4	a10, a10, a10
4037b9b6:	05bd      	mov.n	a11, a5
4037b9b8:	ffdf86        	j	4037b93a <xTaskRemoveFromEventList+0x7e>
4037b9bb:	00          	.byte 00
4037b9bc:	00          	.byte 00
4037b9bd:	03eb50        	rsr.prid	a5
4037b9c0:	045d50        	extui	a5, a5, 13, 1
        xReturn = pdFALSE;
4037b9c3:	020c      	movi.n	a2, 0
    else if ( pxUnblockedTCB->xCoreID != xPortGetCoreID() )
4037b9c5:	c71a57        	beq	a10, a5, 4037b990 <xTaskRemoveFromEventList+0xd4>
        taskYIELD_OTHER_CORE( pxUnblockedTCB->xCoreID, pxUnblockedTCB->uxPriority );
4037b9c8:	c3b8      	l32i.n	a11, a3, 48
4037b9ca:	ff6565        	call8	4037b020 <taskYIELD_OTHER_CORE>
        xReturn = pdFALSE;
4037b9cd:	ffefc6        	j	4037b990 <xTaskRemoveFromEventList+0xd4>

4037b9d0 <vTaskInternalSetTimeOutState>:
{
4037b9d0:	004136        	entry	a1, 32
        configASSERT( pxTimeOut );
4037b9d3:	00e256        	bnez	a2, 4037b9e5 <vTaskInternalSetTimeOutState+0x15>
4037b9d6:	e4cfd1        	l32r	a13, 40374d14 <_iram_text_start+0x910>
4037b9d9:	e4cfc1        	l32r	a12, 40374d18 <_iram_text_start+0x914>
4037b9dc:	e4d0b1        	l32r	a11, 40374d1c <_iram_text_start+0x918>
4037b9df:	e497a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037b9e2:	02e2a5        	call8	4037e80c <__assert_func>
4037b9e5:	e49a31        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037b9e8:	ffafb2        	movi	a11, -1
4037b9eb:	03ad      	mov.n	a10, a3
4037b9ed:	00bc25        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        pxTimeOut->xOverflowCount = xNumOfOverflows;
4037b9f0:	e4b681        	l32r	a8, 40374cc8 <_iram_text_start+0x8c4>
        taskEXIT_CRITICAL();
4037b9f3:	03ad      	mov.n	a10, a3
        pxTimeOut->xOverflowCount = xNumOfOverflows;
4037b9f5:	0020c0        	memw
4037b9f8:	0888      	l32i.n	a8, a8, 0
4037b9fa:	0289      	s32i.n	a8, a2, 0
        pxTimeOut->xTimeOnEntering = xTickCount;
4037b9fc:	e48881        	l32r	a8, 40374c1c <_iram_text_start+0x818>
4037b9ff:	0020c0        	memw
4037ba02:	0888      	l32i.n	a8, a8, 0
4037ba04:	1289      	s32i.n	a8, a2, 4
        taskEXIT_CRITICAL();
4037ba06:	00cde5        	call8	4037c6e4 <vPortExitCritical>
}
4037ba09:	f01d      	retw.n
	...

4037ba0c <xTaskCheckForTimeOut>:
{
4037ba0c:	004136        	entry	a1, 32
4037ba0f:	025d      	mov.n	a5, a2
    configASSERT( pxTimeOut );
4037ba11:	02dc      	bnez.n	a2, 4037ba25 <xTaskCheckForTimeOut+0x19>
4037ba13:	f1a1b2        	movi	a11, 0x1f1
4037ba16:	e4bfd1        	l32r	a13, 40374d14 <_iram_text_start+0x910>
4037ba19:	e4c1c1        	l32r	a12, 40374d20 <_iram_text_start+0x91c>
4037ba1c:	11bbd0        	slli	a11, a11, 3
    configASSERT( pxTicksToWait );
4037ba1f:	e487a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037ba22:	02dea5        	call8	4037e80c <__assert_func>
4037ba25:	b3cc      	bnez.n	a3, 4037ba34 <xTaskCheckForTimeOut+0x28>
4037ba27:	e4bfd1        	l32r	a13, 40374d24 <_iram_text_start+0x920>
4037ba2a:	e4bdc1        	l32r	a12, 40374d20 <_iram_text_start+0x91c>
4037ba2d:	e4beb1        	l32r	a11, 40374d28 <_iram_text_start+0x924>
4037ba30:	fffac6        	j	4037ba1f <xTaskCheckForTimeOut+0x13>
4037ba33:	00          	.byte 00
4037ba34:	e48741        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037ba37:	ffafb2        	movi	a11, -1
4037ba3a:	20a440        	or	a10, a4, a4
4037ba3d:	00b725        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        const TickType_t xConstTickCount = xTickCount;
4037ba40:	e47721        	l32r	a2, 40374c1c <_iram_text_start+0x818>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
4037ba43:	0125a2        	l32i	a10, a5, 4
        const TickType_t xConstTickCount = xTickCount;
4037ba46:	0020c0        	memw
4037ba49:	02b8      	l32i.n	a11, a2, 0
4037ba4b:	03eb20        	rsr.prid	a2
4037ba4e:	042d20        	extui	a2, a2, 13, 1
            if( pxCurrentTCB[xPortGetCoreID()]->ucDelayAborted != ( uint8_t ) pdFALSE )
4037ba51:	e33491        	l32r	a9, 40374724 <_iram_text_start+0x320>
4037ba54:	a02290        	addx4	a2, a2, a9
4037ba57:	0020c0        	memw
4037ba5a:	0228      	l32i.n	a2, a2, 0
4037ba5c:	01d222        	addmi	a2, a2, 0x100
4037ba5f:	560282        	l8ui	a8, a2, 86
4037ba62:	c89c      	beqz.n	a8, 4037ba82 <xTaskCheckForTimeOut+0x76>
4037ba64:	03eb20        	rsr.prid	a2
4037ba67:	042d20        	extui	a2, a2, 13, 1
                pxCurrentTCB[xPortGetCoreID()]->ucDelayAborted = pdFALSE;
4037ba6a:	a02290        	addx4	a2, a2, a9
4037ba6d:	0020c0        	memw
4037ba70:	0228      	l32i.n	a2, a2, 0
4037ba72:	030c      	movi.n	a3, 0
4037ba74:	01d222        	addmi	a2, a2, 0x100
4037ba77:	564232        	s8i	a3, a2, 86
            xReturn = pdTRUE;
4037ba7a:	120c      	movi.n	a2, 1
4037ba7c:	000ec6        	j	4037babb <xTaskCheckForTimeOut+0xaf>
4037ba7f:	00          	.byte 00
4037ba80:	00          	.byte 00
4037ba81:	00          	.byte 00
            if( *pxTicksToWait == portMAX_DELAY )
4037ba82:	0398      	l32i.n	a9, a3, 0
                xReturn = pdFALSE;
4037ba84:	082d      	mov.n	a2, a8
            if( *pxTicksToWait == portMAX_DELAY )
4037ba86:	310926        	beqi	a9, -1, 4037babb <xTaskCheckForTimeOut+0xaf>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
4037ba89:	e48f81        	l32r	a8, 40374cc8 <_iram_text_start+0x8c4>
4037ba8c:	05c8      	l32i.n	a12, a5, 0
4037ba8e:	0020c0        	memw
4037ba91:	0888      	l32i.n	a8, a8, 0
4037ba93:	1d0c      	movi.n	a13, 1
4037ba95:	c0cc80        	sub	a12, a12, a8
4037ba98:	028d      	mov.n	a8, a2
4037ba9a:	938dc0        	movnez	a8, a13, a12
4037ba9d:	488c      	beqz.n	a8, 4037baa5 <xTaskCheckForTimeOut+0x99>
            xReturn = pdTRUE;
4037ba9f:	202dd0        	or	a2, a13, a13
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
4037baa2:	15bba7        	bgeu	a11, a10, 4037babb <xTaskCheckForTimeOut+0xaf>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
4037baa5:	c02ba0        	sub	a2, a11, a10
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
4037baa8:	16b297        	bgeu	a2, a9, 4037bac2 <xTaskCheckForTimeOut+0xb6>
            *pxTicksToWait -= xElapsedTime;
4037baab:	c099b0        	sub	a9, a9, a11
4037baae:	8099a0        	add	a9, a9, a10
4037bab1:	006392        	s32i	a9, a3, 0
            vTaskInternalSetTimeOutState( pxTimeOut );
4037bab4:	05ad      	mov.n	a10, a5
4037bab6:	fff1a5        	call8	4037b9d0 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
4037bab9:	020c      	movi.n	a2, 0
    taskEXIT_CRITICAL();
4037babb:	04ad      	mov.n	a10, a4
4037babd:	00c265        	call8	4037c6e4 <vPortExitCritical>
}
4037bac0:	f01d      	retw.n
            *pxTicksToWait = 0;
4037bac2:	020c      	movi.n	a2, 0
4037bac4:	0329      	s32i.n	a2, a3, 0
4037bac6:	ffec06        	j	4037ba7a <xTaskCheckForTimeOut+0x6e>
4037bac9:	000000        	ill

4037bacc <vTaskMissedYield>:
{
4037bacc:	004136        	entry	a1, 32
4037bacf:	03eb80        	rsr.prid	a8
4037bad2:	048d80        	extui	a8, a8, 13, 1
    xYieldPending[xPortGetCoreID()] = pdTRUE;
4037bad5:	e47d91        	l32r	a9, 40374ccc <_iram_text_start+0x8c8>
4037bad8:	a08890        	addx4	a8, a8, a9
4037badb:	190c      	movi.n	a9, 1
4037badd:	0020c0        	memw
4037bae0:	0899      	s32i.n	a9, a8, 0
}
4037bae2:	f01d      	retw.n

4037bae4 <xTaskGetCurrentTaskHandle>:
    {
4037bae4:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037bae7:	0063a0        	rsil	a10, 3
4037baea:	03eb80        	rsr.prid	a8
4037baed:	048d80        	extui	a8, a8, 13, 1
        xReturn = pxCurrentTCB[ xPortGetCoreID() ];
4037baf0:	e30d21        	l32r	a2, 40374724 <_iram_text_start+0x320>
4037baf3:	a08820        	addx4	a8, a8, a2
4037baf6:	0020c0        	memw
4037baf9:	0828      	l32i.n	a2, a8, 0
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037bafb:	e43e81        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037bafe:	0008e0        	callx8	a8
    }
4037bb01:	f01d      	retw.n
	...

4037bb04 <uxTaskPriorityGet>:
    {
4037bb04:	004136        	entry	a1, 32
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037bb07:	e45231        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037bb0a:	ffafb2        	movi	a11, -1
4037bb0d:	20a330        	or	a10, a3, a3
4037bb10:	00a9e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            pxTCB = prvGetTCBFromHandle( xTask );
4037bb13:	32cc      	bnez.n	a2, 4037bb1a <uxTaskPriorityGet+0x16>
4037bb15:	fffce5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
4037bb18:	0a2d      	mov.n	a2, a10
        taskEXIT_CRITICAL();
4037bb1a:	20a330        	or	a10, a3, a3
            uxReturn = pxTCB->uxPriority;
4037bb1d:	0c2222        	l32i	a2, a2, 48
        taskEXIT_CRITICAL();
4037bb20:	00bc25        	call8	4037c6e4 <vPortExitCritical>
    }
4037bb23:	000090        	retw
	...

4037bb28 <vTaskPrioritySet>:
    {
4037bb28:	004136        	entry	a1, 32
        configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
4037bb2b:	841c      	movi.n	a4, 24
4037bb2d:	0eb437        	bgeu	a4, a3, 4037bb3f <vTaskPrioritySet+0x17>
4037bb30:	e47fd1        	l32r	a13, 40374d2c <_iram_text_start+0x928>
4037bb33:	e47fc1        	l32r	a12, 40374d30 <_iram_text_start+0x92c>
4037bb36:	e441a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037bb39:	f6a6b2        	movi	a11, 0x6f6
4037bb3c:	02cce5        	call8	4037e80c <__assert_func>
4037bb3f:	e44451        	l32r	a5, 40374c50 <_iram_text_start+0x84c>
4037bb42:	ffafb2        	movi	a11, -1
4037bb45:	05ad      	mov.n	a10, a5
4037bb47:	00a6a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            pxTCB = prvGetTCBFromHandle( xTask );
4037bb4a:	32cc      	bnez.n	a2, 4037bb51 <vTaskPrioritySet+0x29>
4037bb4c:	fff965        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
4037bb4f:	0a2d      	mov.n	a2, a10
                    uxCurrentBasePriority = pxTCB->uxBasePriority;
4037bb51:	142242        	l32i	a4, a2, 80
            if( uxCurrentBasePriority != uxNewPriority )
4037bb54:	029347        	bne	a3, a4, 4037bb5a <vTaskPrioritySet+0x32>
4037bb57:	002e86        	j	4037bc15 <vTaskPrioritySet+0xed>
                if( uxNewPriority > uxCurrentBasePriority )
4037bb5a:	e2f281        	l32r	a8, 40374724 <_iram_text_start+0x320>
4037bb5d:	023437        	bltu	a4, a3, 4037bb63 <vTaskPrioritySet+0x3b>
4037bb60:	002e06        	j	4037bc1c <vTaskPrioritySet+0xf4>
4037bb63:	03eb40        	rsr.prid	a4
4037bb66:	044d40        	extui	a4, a4, 13, 1
                    if( pxTCB != pxCurrentTCB[xPortGetCoreID()] )
4037bb69:	a04480        	addx4	a4, a4, a8
4037bb6c:	0020c0        	memw
4037bb6f:	0468      	l32i.n	a6, a4, 0
        BaseType_t xYieldRequired = pdFALSE;
4037bb71:	040c      	movi.n	a4, 0
                    if( pxTCB != pxCurrentTCB[xPortGetCoreID()] )
4037bb73:	451627        	beq	a6, a2, 4037bbbc <vTaskPrioritySet+0x94>
                        if ( tskCAN_RUN_HERE(pxTCB->xCoreID) && uxNewPriority >= pxCurrentTCB[ xPortGetCoreID() ]->uxPriority )
4037bb76:	1222a2        	l32i	a10, a2, 72
4037bb79:	03ebb0        	rsr.prid	a11
4037bb7c:	04bdb0        	extui	a11, a11, 13, 1
4037bb7f:	190c      	movi.n	a9, 1
4037bb81:	c0bba0        	sub	a11, a11, a10
4037bb84:	8349b0        	moveqz	a4, a9, a11
4037bb87:	746040        	extui	a6, a4, 0, 8
4037bb8a:	94cc      	bnez.n	a4, 4037bb97 <vTaskPrioritySet+0x6f>
4037bb8c:	e43241        	l32r	a4, 40374c54 <_iram_text_start+0x850>
4037bb8f:	804a40        	add	a4, a10, a4
4037bb92:	939640        	movnez	a9, a6, a4
4037bb95:	399c      	beqz.n	a9, 4037bbac <vTaskPrioritySet+0x84>
4037bb97:	03eb40        	rsr.prid	a4
4037bb9a:	044d40        	extui	a4, a4, 13, 1
4037bb9d:	a04480        	addx4	a4, a4, a8
4037bba0:	0020c0        	memw
4037bba3:	0448      	l32i.n	a4, a4, 0
4037bba5:	c468      	l32i.n	a6, a4, 48
                            xYieldRequired = pdTRUE;
4037bba7:	140c      	movi.n	a4, 1
                        if ( tskCAN_RUN_HERE(pxTCB->xCoreID) && uxNewPriority >= pxCurrentTCB[ xPortGetCoreID() ]->uxPriority )
4037bba9:	0fb367        	bgeu	a3, a6, 4037bbbc <vTaskPrioritySet+0x94>
4037bbac:	03eb60        	rsr.prid	a6
4037bbaf:	046d60        	extui	a6, a6, 13, 1
        BaseType_t xYieldRequired = pdFALSE;
4037bbb2:	040c      	movi.n	a4, 0
                    else if ( pxTCB->xCoreID != xPortGetCoreID() )      //Need to check if not currently running on other core
4037bbb4:	041a67        	beq	a10, a6, 4037bbbc <vTaskPrioritySet+0x94>
                        taskYIELD_OTHER_CORE( pxTCB->xCoreID, uxNewPriority );
4037bbb7:	03bd      	mov.n	a11, a3
4037bbb9:	ff4665        	call8	4037b020 <taskYIELD_OTHER_CORE>
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
4037bbbc:	c288      	l32i.n	a8, a2, 48
                        if( pxTCB->uxBasePriority == pxTCB->uxPriority )
4037bbbe:	142262        	l32i	a6, a2, 80
4037bbc1:	019687        	bne	a6, a8, 4037bbc6 <vTaskPrioritySet+0x9e>
                            pxTCB->uxPriority = uxNewPriority;
4037bbc4:	c239      	s32i.n	a3, a2, 48
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bbc6:	7268      	l32i.n	a6, a2, 28
                        pxTCB->uxBasePriority = uxNewPriority;
4037bbc8:	146232        	s32i	a3, a2, 80
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bbcb:	006696        	bltz	a6, 4037bbd5 <vTaskPrioritySet+0xad>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bbce:	991c      	movi.n	a9, 25
4037bbd0:	c09930        	sub	a9, a9, a3
4037bbd3:	7299      	s32i.n	a9, a2, 28
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037bbd5:	e42431        	l32r	a3, 40374c68 <_iram_text_start+0x864>
4037bbd8:	a08880        	addx4	a8, a8, a8
4037bbdb:	6268      	l32i.n	a6, a2, 24
4037bbdd:	a08830        	addx4	a8, a8, a3
4037bbe0:	269687        	bne	a6, a8, 4037bc0a <vTaskPrioritySet+0xe2>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bbe3:	628b      	addi.n	a6, a2, 8
4037bbe5:	06ad      	mov.n	a10, a6
4037bbe7:	008a25        	call8	4037c488 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037bbea:	c2a8      	l32i.n	a10, a2, 48
4037bbec:	e42621        	l32r	a2, 40374c84 <_iram_text_start+0x880>
4037bbef:	0020c0        	memw
4037bbf2:	0288      	l32i.n	a8, a2, 0
4037bbf4:	04b8a7        	bgeu	a8, a10, 4037bbfc <vTaskPrioritySet+0xd4>
4037bbf7:	0020c0        	memw
4037bbfa:	02a9      	s32i.n	a10, a2, 0
4037bbfc:	a0aaa0        	addx4	a10, a10, a10
4037bbff:	06bd      	mov.n	a11, a6
4037bc01:	a0aa30        	addx4	a10, a10, a3
4037bc04:	201110        	or	a1, a1, a1
4037bc07:	0082a5        	call8	4037c430 <vListInsertEnd>
                if( xYieldRequired != pdFALSE )
4037bc0a:	748c      	beqz.n	a4, 4037bc15 <vTaskPrioritySet+0xed>
4037bc0c:	03eba0        	rsr.prid	a10
4037bc0f:	04ada0        	extui	a10, a10, 13, 1
                    taskYIELD_IF_USING_PREEMPTION();
4037bc12:	fc42e5        	call8	40378040 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL();
4037bc15:	05ad      	mov.n	a10, a5
4037bc17:	00ace5        	call8	4037c6e4 <vPortExitCritical>
    }
4037bc1a:	f01d      	retw.n
4037bc1c:	03eb40        	rsr.prid	a4
4037bc1f:	044d40        	extui	a4, a4, 13, 1
                else if( pxTCB == pxCurrentTCB[xPortGetCoreID()] )
4037bc22:	a04480        	addx4	a4, a4, a8
4037bc25:	0020c0        	memw
4037bc28:	0468      	l32i.n	a6, a4, 0
                            xYieldRequired = pdTRUE;
4037bc2a:	140c      	movi.n	a4, 1
                else if( pxTCB == pxCurrentTCB[xPortGetCoreID()] )
4037bc2c:	8c1627        	beq	a6, a2, 4037bbbc <vTaskPrioritySet+0x94>
4037bc2f:	03eb40        	rsr.prid	a4
4037bc32:	044d40        	extui	a4, a4, 13, 1
                else if( pxTCB != pxCurrentTCB[xPortGetCoreID()] )
4037bc35:	a04480        	addx4	a4, a4, a8
4037bc38:	0020c0        	memw
4037bc3b:	0468      	l32i.n	a6, a4, 0
        BaseType_t xYieldRequired = pdFALSE;
4037bc3d:	040c      	movi.n	a4, 0
                else if( pxTCB != pxCurrentTCB[xPortGetCoreID()] )
4037bc3f:	029627        	bne	a6, a2, 4037bc45 <vTaskPrioritySet+0x11d>
4037bc42:	ffdd86        	j	4037bbbc <vTaskPrioritySet+0x94>
4037bc45:	03eb40        	rsr.prid	a4
4037bc48:	044d40        	extui	a4, a4, 13, 1
                    if( uxNewPriority >= pxCurrentTCB[xPortGetCoreID()]->uxPriority )
4037bc4b:	a04480        	addx4	a4, a4, a8
4037bc4e:	0020c0        	memw
4037bc51:	0448      	l32i.n	a4, a4, 0
4037bc53:	c468      	l32i.n	a6, a4, 48
                            xYieldRequired = pdTRUE;
4037bc55:	140c      	movi.n	a4, 1
                    if( uxNewPriority >= pxCurrentTCB[xPortGetCoreID()]->uxPriority )
4037bc57:	023367        	bltu	a3, a6, 4037bc5d <vTaskPrioritySet+0x135>
4037bc5a:	ffd786        	j	4037bbbc <vTaskPrioritySet+0x94>
                    else if ( pxTCB->xCoreID != xPortGetCoreID() )      //Need to check if not currently running on other core
4037bc5d:	1222a2        	l32i	a10, a2, 72
4037bc60:	ffd206        	j	4037bbac <vTaskPrioritySet+0x84>
	...

4037bc64 <xTaskGetAffinity>:
{
4037bc64:	004136        	entry	a1, 32
4037bc67:	02ad      	mov.n	a10, a2
    pxTCB = prvGetTCBFromHandle( xTask );
4037bc69:	42cc      	bnez.n	a2, 4037bc71 <xTaskGetAffinity+0xd>
4037bc6b:	201110        	or	a1, a1, a1
4037bc6e:	ffe765        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
}
4037bc71:	122a22        	l32i	a2, a10, 72
4037bc74:	f01d      	retw.n
	...

4037bc78 <xTaskGetSchedulerState>:
    {
4037bc78:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037bc7b:	0063a0        	rsil	a10, 3
        if( xSchedulerRunning == pdFALSE )
4037bc7e:	e3ff21        	l32r	a2, 40374c7c <_iram_text_start+0x878>
4037bc81:	0020c0        	memw
4037bc84:	0288      	l32i.n	a8, a2, 0
            xReturn = taskSCHEDULER_NOT_STARTED;
4037bc86:	120c      	movi.n	a2, 1
        if( xSchedulerRunning == pdFALSE )
4037bc88:	889c      	beqz.n	a8, 4037bca4 <xTaskGetSchedulerState+0x2c>
4037bc8a:	03eb80        	rsr.prid	a8
4037bc8d:	048d80        	extui	a8, a8, 13, 1
            if( uxSchedulerSuspended[xPortGetCoreID()] == ( UBaseType_t ) pdFALSE )
4037bc90:	e40391        	l32r	a9, 40374c9c <_iram_text_start+0x898>
4037bc93:	a08890        	addx4	a8, a8, a9
4037bc96:	0020c0        	memw
4037bc99:	0898      	l32i.n	a9, a8, 0
4037bc9b:	00a082        	movi	a8, 0
4037bc9e:	932890        	movnez	a2, a8, a9
4037bca1:	802220        	add	a2, a2, a2
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037bca4:	e3d481        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037bca7:	0008e0        	callx8	a8
    }
4037bcaa:	f01d      	retw.n

4037bcac <vTaskDelete>:
    {
4037bcac:	006136        	entry	a1, 48
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037bcaf:	e3e8a1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037bcb2:	ffafb2        	movi	a11, -1
4037bcb5:	008fa5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037bcb8:	03eb70        	rsr.prid	a7
4037bcbb:	047d70        	extui	a7, a7, 13, 1
            curTCB = pxCurrentTCB[core];
4037bcbe:	e29941        	l32r	a4, 40374724 <_iram_text_start+0x320>
4037bcc1:	a03740        	addx4	a3, a7, a4
4037bcc4:	0020c0        	memw
4037bcc7:	002352        	l32i	a5, a3, 0
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
4037bcca:	004256        	bnez	a2, 4037bcd2 <vTaskDelete+0x26>
4037bccd:	ffe165        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
4037bcd0:	0a2d      	mov.n	a2, a10
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bcd2:	08c262        	addi	a6, a2, 8
4037bcd5:	20a660        	or	a10, a6, a6
4037bcd8:	007ae5        	call8	4037c488 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
4037bcdb:	b238      	l32i.n	a3, a2, 44
4037bcdd:	438c      	beqz.n	a3, 4037bce5 <vTaskDelete+0x39>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
4037bcdf:	1cc2a2        	addi	a10, a2, 28
4037bce2:	007a65        	call8	4037c488 <uxListRemove>
            uxTaskNumber++;
4037bce5:	e3e681        	l32r	a8, 40374c80 <_iram_text_start+0x87c>
4037bce8:	0838      	l32i.n	a3, a8, 0
4037bcea:	331b      	addi.n	a3, a3, 1
4037bcec:	0839      	s32i.n	a3, a8, 0
                (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ]) ||
4037bcee:	130c      	movi.n	a3, 1
4037bcf0:	080c      	movi.n	a8, 0
4037bcf2:	838370        	moveqz	a8, a3, a7
4037bcf5:	1178e0        	slli	a7, a8, 2
            if( pxTCB == curTCB ||
4037bcf8:	101257        	beq	a2, a5, 4037bd0c <vTaskDelete+0x60>
                (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ]) ||
4037bcfb:	809470        	add	a9, a4, a7
4037bcfe:	0020c0        	memw
4037bd01:	0998      	l32i.n	a9, a9, 0
            if( pxTCB == curTCB ||
4037bd03:	051927        	beq	a9, a2, 4037bd0c <vTaskDelete+0x60>
                (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ]) ||
4037bd06:	122292        	l32i	a9, a2, 72
4037bd09:	639987        	bne	a9, a8, 4037bd70 <vTaskDelete+0xc4>
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
4037bd0c:	e3c5a1        	l32r	a10, 40374c20 <_iram_text_start+0x81c>
4037bd0f:	06bd      	mov.n	a11, a6
4037bd11:	0189      	s32i.n	a8, a1, 0
4037bd13:	0071e5        	call8	4037c430 <vListInsertEnd>
                ++uxDeletedTasksWaitingCleanUp;
4037bd16:	e3d191        	l32r	a9, 40374c5c <_iram_text_start+0x858>
                if (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ])
4037bd19:	447a      	add.n	a4, a4, a7
                ++uxDeletedTasksWaitingCleanUp;
4037bd1b:	0020c0        	memw
4037bd1e:	0938      	l32i.n	a3, a9, 0
                if (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ])
4037bd20:	0188      	l32i.n	a8, a1, 0
                ++uxDeletedTasksWaitingCleanUp;
4037bd22:	331b      	addi.n	a3, a3, 1
4037bd24:	0020c0        	memw
4037bd27:	0939      	s32i.n	a3, a9, 0
                if (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ])
4037bd29:	0020c0        	memw
4037bd2c:	0448      	l32i.n	a4, a4, 0
        BaseType_t xFreeNow = 0;
4037bd2e:	030c      	movi.n	a3, 0
                if (configNUM_CORES > 1 && pxTCB == pxCurrentTCB[ !core ])
4037bd30:	049427        	bne	a4, a2, 4037bd38 <vTaskDelete+0x8c>
                    vPortYieldOtherCore( !core );
4037bd33:	08ad      	mov.n	a10, a8
4037bd35:	00a365        	call8	4037c76c <vPortYieldOtherCore>
        taskEXIT_CRITICAL();
4037bd38:	e3c6a1        	l32r	a10, 40374c50 <_iram_text_start+0x84c>
4037bd3b:	009aa5        	call8	4037c6e4 <vPortExitCritical>
        if(xFreeNow == pdTRUE) {
4037bd3e:	0b1366        	bnei	a3, 1, 4037bd4d <vTaskDelete+0xa1>
                prvDeleteTLS( pxTCB );
4037bd41:	20a220        	or	a10, a2, a2
4037bd44:	ff1ae5        	call8	4037aef4 <prvDeleteTLS>
            prvDeleteTCB( pxTCB );
4037bd47:	20a220        	or	a10, a2, a2
4037bd4a:	ff1d25        	call8	4037af1c <prvDeleteTCB>
        if( xSchedulerRunning != pdFALSE )
4037bd4d:	e3cb31        	l32r	a3, 40374c7c <_iram_text_start+0x878>
4037bd50:	0020c0        	memw
4037bd53:	002332        	l32i	a3, a3, 0
            if( pxTCB == curTCB )
4037bd56:	379257        	bne	a2, a5, 4037bd91 <vTaskDelete+0xe5>
4037bd59:	034316        	beqz	a3, 4037bd91 <vTaskDelete+0xe5>
                configASSERT( xTaskGetSchedulerState() != taskSCHEDULER_SUSPENDED );
4037bd5c:	fff1a5        	call8	4037bc78 <xTaskGetSchedulerState>
4037bd5f:	5aec      	bnez.n	a10, 4037bd88 <vTaskDelete+0xdc>
4037bd61:	e3f4d1        	l32r	a13, 40374d34 <_iram_text_start+0x930>
4037bd64:	e3f5c1        	l32r	a12, 40374d38 <_iram_text_start+0x934>
4037bd67:	e3b5a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037bd6a:	a2a5b2        	movi	a11, 0x5a2
4037bd6d:	02a9e5        	call8	4037e80c <__assert_func>
                --uxCurrentNumberOfTasks;
4037bd70:	e3bc71        	l32r	a7, 40374c60 <_iram_text_start+0x85c>
4037bd73:	0020c0        	memw
4037bd76:	002742        	l32i	a4, a7, 0
4037bd79:	ffc442        	addi	a4, a4, -1
4037bd7c:	0020c0        	memw
4037bd7f:	006742        	s32i	a4, a7, 0
                prvResetNextTaskUnblockTime();
4037bd82:	ff1425        	call8	4037aec4 <prvResetNextTaskUnblockTime>
4037bd85:	ffebc6        	j	4037bd38 <vTaskDelete+0x8c>
4037bd88:	03eba0        	rsr.prid	a10
4037bd8b:	04ada0        	extui	a10, a10, 13, 1
                portYIELD_WITHIN_API();
4037bd8e:	fc2b25        	call8	40378040 <esp_crosscore_int_send_yield>
    }
4037bd91:	f01d      	retw.n
	...

4037bd94 <vTaskDelay>:
    {
4037bd94:	004136        	entry	a1, 32
        if( xTicksToDelay > ( TickType_t ) 0U )
4037bd97:	030216        	beqz	a2, 4037bdcb <vTaskDelay+0x37>
            configASSERT( xTaskGetSchedulerState() != taskSCHEDULER_SUSPENDED );
4037bd9a:	ffede5        	call8	4037bc78 <xTaskGetSchedulerState>
4037bd9d:	00ea56        	bnez	a10, 4037bdaf <vTaskDelay+0x1b>
4037bda0:	e3e5d1        	l32r	a13, 40374d34 <_iram_text_start+0x930>
4037bda3:	e3e6c1        	l32r	a12, 40374d3c <_iram_text_start+0x938>
4037bda6:	e3a5a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037bda9:	25a6b2        	movi	a11, 0x625
4037bdac:	02a5e5        	call8	4037e80c <__assert_func>
4037bdaf:	e3a831        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037bdb2:	ffafb2        	movi	a11, -1
4037bdb5:	03ad      	mov.n	a10, a3
4037bdb7:	007fa5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037bdba:	03eba0        	rsr.prid	a10
4037bdbd:	04ada0        	extui	a10, a10, 13, 1
                prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTicksToDelay );
4037bdc0:	20b220        	or	a11, a2, a2
4037bdc3:	ff06a5        	call8	4037ae2c <prvAddCurrentTaskToDelayedList>
            taskEXIT_CRITICAL();
4037bdc6:	03ad      	mov.n	a10, a3
4037bdc8:	0091a5        	call8	4037c6e4 <vPortExitCritical>
4037bdcb:	03eba0        	rsr.prid	a10
4037bdce:	04ada0        	extui	a10, a10, 13, 1
        portYIELD_WITHIN_API();
4037bdd1:	fc26e5        	call8	40378040 <esp_crosscore_int_send_yield>
    }
4037bdd4:	f01d      	retw.n
	...

4037bdd8 <xTaskPriorityInherit>:
    {
4037bdd8:	004136        	entry	a1, 32
4037bddb:	e39d31        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037bdde:	fb7c      	movi.n	a11, -1
4037bde0:	20a330        	or	a10, a3, a3
        BaseType_t xReturn = pdFALSE;
4037bde3:	040c      	movi.n	a4, 0
4037bde5:	007ca5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if( pxMutexHolder != NULL )
4037bde8:	029247        	bne	a2, a4, 4037bdee <xTaskPriorityInherit+0x16>
4037bdeb:	001f06        	j	4037be6b <xTaskPriorityInherit+0x93>
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB[xPortGetCoreID()]->uxPriority )
4037bdee:	c288      	l32i.n	a8, a2, 48
4037bdf0:	03eb90        	rsr.prid	a9
4037bdf3:	049d90        	extui	a9, a9, 13, 1
4037bdf6:	e24b51        	l32r	a5, 40374724 <_iram_text_start+0x320>
4037bdf9:	a09950        	addx4	a9, a9, a5
4037bdfc:	0020c0        	memw
4037bdff:	0968      	l32i.n	a6, a9, 0
4037be01:	c668      	l32i.n	a6, a6, 48
4037be03:	023867        	bltu	a8, a6, 4037be09 <xTaskPriorityInherit+0x31>
4037be06:	001fc6        	j	4037be89 <xTaskPriorityInherit+0xb1>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037be09:	7248      	l32i.n	a4, a2, 28
4037be0b:	016496        	bltz	a4, 4037be25 <xTaskPriorityInherit+0x4d>
4037be0e:	03eb40        	rsr.prid	a4
4037be11:	044d40        	extui	a4, a4, 13, 1
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB[xPortGetCoreID()]->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037be14:	a04450        	addx4	a4, a4, a5
4037be17:	0020c0        	memw
4037be1a:	0448      	l32i.n	a4, a4, 0
4037be1c:	c468      	l32i.n	a6, a4, 48
4037be1e:	941c      	movi.n	a4, 25
4037be20:	c04460        	sub	a4, a4, a6
4037be23:	7249      	s32i.n	a4, a2, 28
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
4037be25:	e39041        	l32r	a4, 40374c68 <_iram_text_start+0x864>
4037be28:	a08880        	addx4	a8, a8, a8
4037be2b:	6268      	l32i.n	a6, a2, 24
4037be2d:	a08840        	addx4	a8, a8, a4
4037be30:	409687        	bne	a6, a8, 4037be74 <xTaskPriorityInherit+0x9c>
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037be33:	628b      	addi.n	a6, a2, 8
4037be35:	06ad      	mov.n	a10, a6
4037be37:	006525        	call8	4037c488 <uxListRemove>
4037be3a:	03eb80        	rsr.prid	a8
4037be3d:	048d80        	extui	a8, a8, 13, 1
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB[xPortGetCoreID()]->uxPriority;
4037be40:	a05850        	addx4	a5, a8, a5
4037be43:	0020c0        	memw
4037be46:	0558      	l32i.n	a5, a5, 0
4037be48:	c5a8      	l32i.n	a10, a5, 48
4037be4a:	c2a9      	s32i.n	a10, a2, 48
                    prvAddTaskToReadyList( pxMutexHolderTCB );
4037be4c:	e38e21        	l32r	a2, 40374c84 <_iram_text_start+0x880>
4037be4f:	0020c0        	memw
4037be52:	0258      	l32i.n	a5, a2, 0
4037be54:	04b5a7        	bgeu	a5, a10, 4037be5c <xTaskPriorityInherit+0x84>
4037be57:	0020c0        	memw
4037be5a:	02a9      	s32i.n	a10, a2, 0
4037be5c:	a0aaa0        	addx4	a10, a10, a10
4037be5f:	20b660        	or	a11, a6, a6
4037be62:	a0aa40        	addx4	a10, a10, a4
4037be65:	005ca5        	call8	4037c430 <vListInsertEnd>
                xReturn = pdTRUE;
4037be68:	01a042        	movi	a4, 1
        taskEXIT_CRITICAL();
4037be6b:	03ad      	mov.n	a10, a3
4037be6d:	008765        	call8	4037c6e4 <vPortExitCritical>
    }
4037be70:	042d      	mov.n	a2, a4
4037be72:	f01d      	retw.n
4037be74:	03eb40        	rsr.prid	a4
4037be77:	044d40        	extui	a4, a4, 13, 1
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB[xPortGetCoreID()]->uxPriority;
4037be7a:	a04450        	addx4	a4, a4, a5
4037be7d:	0020c0        	memw
4037be80:	0448      	l32i.n	a4, a4, 0
4037be82:	c448      	l32i.n	a4, a4, 48
4037be84:	c249      	s32i.n	a4, a2, 48
4037be86:	fff786        	j	4037be68 <xTaskPriorityInherit+0x90>
4037be89:	03eb80        	rsr.prid	a8
4037be8c:	048d80        	extui	a8, a8, 13, 1
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB[xPortGetCoreID()]->uxPriority )
4037be8f:	a05850        	addx4	a5, a8, a5
4037be92:	0020c0        	memw
4037be95:	0588      	l32i.n	a8, a5, 0
4037be97:	142262        	l32i	a6, a2, 80
4037be9a:	c828      	l32i.n	a2, a8, 48
4037be9c:	150c      	movi.n	a5, 1
4037be9e:	023627        	bltu	a6, a2, 4037bea4 <xTaskPriorityInherit+0xcc>
4037bea1:	205440        	or	a5, a4, a4
        BaseType_t xReturn = pdFALSE;
4037bea4:	054d      	mov.n	a4, a5
4037bea6:	fff046        	j	4037be6b <xTaskPriorityInherit+0x93>
4037bea9:	000000        	ill

4037beac <xTaskPriorityDisinherit>:
    {
4037beac:	004136        	entry	a1, 32
4037beaf:	e36841        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037beb2:	ffafb2        	movi	a11, -1
4037beb5:	20a440        	or	a10, a4, a4
4037beb8:	006f65        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if( pxMutexHolder != NULL )
4037bebb:	00d256        	bnez	a2, 4037becc <xTaskPriorityDisinherit+0x20>
        BaseType_t xReturn = pdFALSE;
4037bebe:	00a022        	movi	a2, 0
        taskEXIT_CRITICAL();
4037bec1:	20a440        	or	a10, a4, a4
4037bec4:	0081e5        	call8	4037c6e4 <vPortExitCritical>
    }
4037bec7:	000090        	retw
4037beca:	00          	.byte 00
4037becb:	00          	.byte 00
4037becc:	03eb30        	rsr.prid	a3
4037becf:	043d30        	extui	a3, a3, 13, 1
            configASSERT( pxTCB == pxCurrentTCB[xPortGetCoreID()] );
4037bed2:	e21481        	l32r	a8, 40374724 <_iram_text_start+0x320>
4037bed5:	a03380        	addx4	a3, a3, a8
4037bed8:	0020c0        	memw
4037bedb:	0338      	l32i.n	a3, a3, 0
4037bedd:	141327        	beq	a3, a2, 4037bef5 <xTaskPriorityDisinherit+0x49>
4037bee0:	37a1b2        	movi	a11, 0x137
4037bee3:	e397d1        	l32r	a13, 40374d40 <_iram_text_start+0x93c>
4037bee6:	e397c1        	l32r	a12, 40374d44 <_iram_text_start+0x940>
4037bee9:	11bbc0        	slli	a11, a11, 4
            configASSERT( pxTCB->uxMutexesHeld );
4037beec:	e354a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037beef:	201110        	or	a1, a1, a1
4037bef2:	0291a5        	call8	4037e80c <__assert_func>
4037bef5:	152382        	l32i	a8, a3, 84
4037bef8:	a8cc      	bnez.n	a8, 4037bf06 <xTaskPriorityDisinherit+0x5a>
4037befa:	e393d1        	l32r	a13, 40374d48 <_iram_text_start+0x944>
4037befd:	e391c1        	l32r	a12, 40374d44 <_iram_text_start+0x940>
4037bf00:	e393b1        	l32r	a11, 40374d4c <_iram_text_start+0x948>
4037bf03:	fff946        	j	4037beec <xTaskPriorityDisinherit+0x40>
            ( pxTCB->uxMutexesHeld )--;
4037bf06:	ffc882        	addi	a8, a8, -1
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4037bf09:	0c2392        	l32i	a9, a3, 48
4037bf0c:	142322        	l32i	a2, a3, 80
            ( pxTCB->uxMutexesHeld )--;
4037bf0f:	156382        	s32i	a8, a3, 84
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4037bf12:	a81927        	beq	a9, a2, 4037bebe <xTaskPriorityDisinherit+0x12>
4037bf15:	fa5856        	bnez	a8, 4037bebe <xTaskPriorityDisinherit+0x12>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bf18:	08c322        	addi	a2, a3, 8
4037bf1b:	02ad      	mov.n	a10, a2
4037bf1d:	0056a5        	call8	4037c488 <uxListRemove>
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
4037bf20:	1423a2        	l32i	a10, a3, 80
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bf23:	981c      	movi.n	a8, 25
4037bf25:	c088a0        	sub	a8, a8, a10
4037bf28:	7389      	s32i.n	a8, a3, 28
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
4037bf2a:	c3a9      	s32i.n	a10, a3, 48
                    prvAddTaskToReadyList( pxTCB );
4037bf2c:	e35631        	l32r	a3, 40374c84 <_iram_text_start+0x880>
4037bf2f:	0020c0        	memw
4037bf32:	0388      	l32i.n	a8, a3, 0
4037bf34:	04b8a7        	bgeu	a8, a10, 4037bf3c <xTaskPriorityDisinherit+0x90>
4037bf37:	0020c0        	memw
4037bf3a:	03a9      	s32i.n	a10, a3, 0
4037bf3c:	02bd      	mov.n	a11, a2
4037bf3e:	e34a21        	l32r	a2, 40374c68 <_iram_text_start+0x864>
4037bf41:	a0aaa0        	addx4	a10, a10, a10
4037bf44:	a0aa20        	addx4	a10, a10, a2
4037bf47:	004ea5        	call8	4037c430 <vListInsertEnd>
                    xReturn = pdTRUE;
4037bf4a:	120c      	movi.n	a2, 1
4037bf4c:	ffdc46        	j	4037bec1 <xTaskPriorityDisinherit+0x15>
	...

4037bf50 <vTaskPriorityDisinheritAfterTimeout>:
    {
4037bf50:	004136        	entry	a1, 32
4037bf53:	e33f41        	l32r	a4, 40374c50 <_iram_text_start+0x84c>
4037bf56:	ffafb2        	movi	a11, -1
4037bf59:	20a440        	or	a10, a4, a4
4037bf5c:	006525        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        if( pxMutexHolder != NULL )
4037bf5f:	087216        	beqz	a2, 4037bfea <vTaskPriorityDisinheritAfterTimeout+0x9a>
            configASSERT( pxTCB->uxMutexesHeld );
4037bf62:	152252        	l32i	a5, a2, 84
4037bf65:	d5cc      	bnez.n	a5, 4037bf76 <vTaskPriorityDisinheritAfterTimeout+0x26>
4037bf67:	e378d1        	l32r	a13, 40374d48 <_iram_text_start+0x944>
4037bf6a:	e379c1        	l32r	a12, 40374d50 <_iram_text_start+0x94c>
4037bf6d:	e379b1        	l32r	a11, 40374d54 <_iram_text_start+0x950>
                    configASSERT( pxTCB != pxCurrentTCB[xPortGetCoreID()] );
4037bf70:	e333a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037bf73:	0289a5        	call8	4037e80c <__assert_func>
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4037bf76:	142282        	l32i	a8, a2, 80
4037bf79:	733380        	maxu	a3, a3, a8
            if( pxTCB->uxPriority != uxPriorityToUse )
4037bf7c:	c288      	l32i.n	a8, a2, 48
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4037bf7e:	681566        	bnei	a5, 1, 4037bfea <vTaskPriorityDisinheritAfterTimeout+0x9a>
4037bf81:	651837        	beq	a8, a3, 4037bfea <vTaskPriorityDisinheritAfterTimeout+0x9a>
4037bf84:	03eb90        	rsr.prid	a9
4037bf87:	049d90        	extui	a9, a9, 13, 1
                    configASSERT( pxTCB != pxCurrentTCB[xPortGetCoreID()] );
4037bf8a:	e1e651        	l32r	a5, 40374724 <_iram_text_start+0x320>
4037bf8d:	a09950        	addx4	a9, a9, a5
4037bf90:	0020c0        	memw
4037bf93:	0958      	l32i.n	a5, a9, 0
4037bf95:	0d9527        	bne	a5, a2, 4037bfa6 <vTaskPriorityDisinheritAfterTimeout+0x56>
4037bf98:	e370d1        	l32r	a13, 40374d58 <_iram_text_start+0x954>
4037bf9b:	e36dc1        	l32r	a12, 40374d50 <_iram_text_start+0x94c>
4037bf9e:	e36fb1        	l32r	a11, 40374d5c <_iram_text_start+0x958>
4037bfa1:	fff2c6        	j	4037bf70 <vTaskPriorityDisinheritAfterTimeout+0x20>
4037bfa4:	00          	.byte 00
4037bfa5:	00          	.byte 00
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bfa6:	7258      	l32i.n	a5, a2, 28
                    pxTCB->uxPriority = uxPriorityToUse;
4037bfa8:	c239      	s32i.n	a3, a2, 48
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037bfaa:	006596        	bltz	a5, 4037bfb4 <vTaskPriorityDisinheritAfterTimeout+0x64>
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037bfad:	991c      	movi.n	a9, 25
4037bfaf:	c03930        	sub	a3, a9, a3
4037bfb2:	7239      	s32i.n	a3, a2, 28
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037bfb4:	e32d31        	l32r	a3, 40374c68 <_iram_text_start+0x864>
4037bfb7:	a08880        	addx4	a8, a8, a8
4037bfba:	6258      	l32i.n	a5, a2, 24
4037bfbc:	a08830        	addx4	a8, a8, a3
4037bfbf:	279587        	bne	a5, a8, 4037bfea <vTaskPriorityDisinheritAfterTimeout+0x9a>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037bfc2:	528b      	addi.n	a5, a2, 8
4037bfc4:	20a550        	or	a10, a5, a5
4037bfc7:	004c25        	call8	4037c488 <uxListRemove>
                        prvAddTaskToReadyList( pxTCB );
4037bfca:	c2a8      	l32i.n	a10, a2, 48
4037bfcc:	e32e21        	l32r	a2, 40374c84 <_iram_text_start+0x880>
4037bfcf:	0020c0        	memw
4037bfd2:	0288      	l32i.n	a8, a2, 0
4037bfd4:	04b8a7        	bgeu	a8, a10, 4037bfdc <vTaskPriorityDisinheritAfterTimeout+0x8c>
4037bfd7:	0020c0        	memw
4037bfda:	02a9      	s32i.n	a10, a2, 0
4037bfdc:	a0aaa0        	addx4	a10, a10, a10
4037bfdf:	05bd      	mov.n	a11, a5
4037bfe1:	a0aa30        	addx4	a10, a10, a3
4037bfe4:	201110        	or	a1, a1, a1
4037bfe7:	0044a5        	call8	4037c430 <vListInsertEnd>
        taskEXIT_CRITICAL();
4037bfea:	04ad      	mov.n	a10, a4
4037bfec:	006f65        	call8	4037c6e4 <vPortExitCritical>
    }
4037bfef:	f01d      	retw.n
4037bff1:	000000        	ill

4037bff4 <pvTaskIncrementMutexHeldCount>:
    {
4037bff4:	004136        	entry	a1, 32
4037bff7:	e31631        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037bffa:	ffafb2        	movi	a11, -1
4037bffd:	20a330        	or	a10, a3, a3
4037c000:	005ae5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037c003:	03eb80        	rsr.prid	a8
4037c006:	048d80        	extui	a8, a8, 13, 1
        if( pxCurrentTCB[ xPortGetCoreID() ] != NULL )
4037c009:	e1c691        	l32r	a9, 40374724 <_iram_text_start+0x320>
4037c00c:	a08890        	addx4	a8, a8, a9
4037c00f:	0020c0        	memw
4037c012:	0828      	l32i.n	a2, a8, 0
4037c014:	429c      	beqz.n	a2, 4037c02c <pvTaskIncrementMutexHeldCount+0x38>
4037c016:	03eb80        	rsr.prid	a8
4037c019:	048d80        	extui	a8, a8, 13, 1
            ( pxCurrentTCB[ xPortGetCoreID() ]->uxMutexesHeld )++;
4037c01c:	a08890        	addx4	a8, a8, a9
4037c01f:	0020c0        	memw
4037c022:	08a8      	l32i.n	a10, a8, 0
4037c024:	152a82        	l32i	a8, a10, 84
4037c027:	881b      	addi.n	a8, a8, 1
4037c029:	156a82        	s32i	a8, a10, 84
4037c02c:	03eb80        	rsr.prid	a8
4037c02f:	048d80        	extui	a8, a8, 13, 1
        curTCB = pxCurrentTCB[ xPortGetCoreID() ];
4037c032:	a08890        	addx4	a8, a8, a9
        taskEXIT_CRITICAL();
4037c035:	03ad      	mov.n	a10, a3
        curTCB = pxCurrentTCB[ xPortGetCoreID() ];
4037c037:	0020c0        	memw
4037c03a:	002822        	l32i	a2, a8, 0
        taskEXIT_CRITICAL();
4037c03d:	006a65        	call8	4037c6e4 <vPortExitCritical>
    }
4037c040:	f01d      	retw.n
	...

4037c044 <ulTaskGenericNotifyTake>:
    {
4037c044:	004136        	entry	a1, 32
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c047:	00e216        	beqz	a2, 4037c059 <ulTaskGenericNotifyTake+0x15>
4037c04a:	e345d1        	l32r	a13, 40374d60 <_iram_text_start+0x95c>
4037c04d:	e345c1        	l32r	a12, 40374d64 <_iram_text_start+0x960>
4037c050:	e346b1        	l32r	a11, 40374d68 <_iram_text_start+0x964>
4037c053:	e2faa1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037c056:	027b65        	call8	4037e80c <__assert_func>
4037c059:	e2fd61        	l32r	a6, 40374c50 <_iram_text_start+0x84c>
4037c05c:	fb7c      	movi.n	a11, -1
4037c05e:	06ad      	mov.n	a10, a6
4037c060:	0054e5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037c063:	03eb20        	rsr.prid	a2
4037c066:	042d20        	extui	a2, a2, 13, 1
            if( pxCurrentTCB[xPortGetCoreID()]->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4037c069:	e1ae51        	l32r	a5, 40374724 <_iram_text_start+0x320>
4037c06c:	a02250        	addx4	a2, a2, a5
4037c06f:	0020c0        	memw
4037c072:	0228      	l32i.n	a2, a2, 0
4037c074:	0020c0        	memw
4037c077:	542222        	l32i	a2, a2, 0x150
4037c07a:	e2ec      	bnez.n	a2, 4037c0ac <ulTaskGenericNotifyTake+0x68>
4037c07c:	03eb20        	rsr.prid	a2
4037c07f:	042d20        	extui	a2, a2, 13, 1
                pxCurrentTCB[xPortGetCoreID()]->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4037c082:	a02250        	addx4	a2, a2, a5
4037c085:	0020c0        	memw
4037c088:	0228      	l32i.n	a2, a2, 0
4037c08a:	180c      	movi.n	a8, 1
4037c08c:	01d222        	addmi	a2, a2, 0x100
4037c08f:	0020c0        	memw
4037c092:	544282        	s8i	a8, a2, 84
                if( xTicksToWait > ( TickType_t ) 0 )
4037c095:	349c      	beqz.n	a4, 4037c0ac <ulTaskGenericNotifyTake+0x68>
4037c097:	03eba0        	rsr.prid	a10
4037c09a:	04ada0        	extui	a10, a10, 13, 1
                    prvAddCurrentTaskToDelayedList( xPortGetCoreID(), xTicksToWait );
4037c09d:	20b440        	or	a11, a4, a4
4037c0a0:	fed8a5        	call8	4037ae2c <prvAddCurrentTaskToDelayedList>
4037c0a3:	03eba0        	rsr.prid	a10
4037c0a6:	04ada0        	extui	a10, a10, 13, 1
                    portYIELD_WITHIN_API();
4037c0a9:	fbf965        	call8	40378040 <esp_crosscore_int_send_yield>
        taskEXIT_CRITICAL();
4037c0ac:	06ad      	mov.n	a10, a6
4037c0ae:	006365        	call8	4037c6e4 <vPortExitCritical>
4037c0b1:	fb7c      	movi.n	a11, -1
4037c0b3:	06ad      	mov.n	a10, a6
4037c0b5:	004fa5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
4037c0b8:	03eb20        	rsr.prid	a2
4037c0bb:	042d20        	extui	a2, a2, 13, 1
            ulReturn = pxCurrentTCB[xPortGetCoreID()]->ulNotifiedValue[ uxIndexToWait ];
4037c0be:	a02250        	addx4	a2, a2, a5
4037c0c1:	0020c0        	memw
4037c0c4:	0228      	l32i.n	a2, a2, 0
4037c0c6:	0020c0        	memw
4037c0c9:	542222        	l32i	a2, a2, 0x150
            if( ulReturn != 0UL )
4037c0cc:	017216        	beqz	a2, 4037c0e7 <ulTaskGenericNotifyTake+0xa3>
                if( xClearCountOnExit != pdFALSE )
4037c0cf:	53bc      	beqz.n	a3, 4037c108 <ulTaskGenericNotifyTake+0xc4>
4037c0d1:	03eb80        	rsr.prid	a8
4037c0d4:	048d80        	extui	a8, a8, 13, 1
                    pxCurrentTCB[xPortGetCoreID()]->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4037c0d7:	a08850        	addx4	a8, a8, a5
4037c0da:	0020c0        	memw
4037c0dd:	0838      	l32i.n	a3, a8, 0
4037c0df:	040c      	movi.n	a4, 0
                    pxCurrentTCB[xPortGetCoreID()]->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4037c0e1:	0020c0        	memw
4037c0e4:	546342        	s32i	a4, a3, 0x150
4037c0e7:	03eb80        	rsr.prid	a8
4037c0ea:	048d80        	extui	a8, a8, 13, 1
            pxCurrentTCB[xPortGetCoreID()]->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4037c0ed:	a05850        	addx4	a5, a8, a5
4037c0f0:	0020c0        	memw
4037c0f3:	0558      	l32i.n	a5, a5, 0
4037c0f5:	030c      	movi.n	a3, 0
4037c0f7:	01d552        	addmi	a5, a5, 0x100
4037c0fa:	0020c0        	memw
4037c0fd:	544532        	s8i	a3, a5, 84
        taskEXIT_CRITICAL();
4037c100:	06ad      	mov.n	a10, a6
4037c102:	005e25        	call8	4037c6e4 <vPortExitCritical>
    }
4037c105:	f01d      	retw.n
4037c107:	00          	.byte 00
4037c108:	03eb80        	rsr.prid	a8
4037c10b:	048d80        	extui	a8, a8, 13, 1
                    pxCurrentTCB[xPortGetCoreID()]->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4037c10e:	a08850        	addx4	a8, a8, a5
4037c111:	0020c0        	memw
4037c114:	0838      	l32i.n	a3, a8, 0
4037c116:	420b      	addi.n	a4, a2, -1
4037c118:	fff146        	j	4037c0e1 <ulTaskGenericNotifyTake+0x9d>
	...

4037c11c <vTaskGenericNotifyGiveFromISR>:
    {
4037c11c:	004136        	entry	a1, 32
        configASSERT( xTaskToNotify );
4037c11f:	00e256        	bnez	a2, 4037c131 <vTaskGenericNotifyGiveFromISR+0x15>
4037c122:	e312d1        	l32r	a13, 40374d6c <_iram_text_start+0x968>
4037c125:	e312c1        	l32r	a12, 40374d70 <_iram_text_start+0x96c>
4037c128:	e313b1        	l32r	a11, 40374d74 <_iram_text_start+0x970>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4037c12b:	e2c4a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037c12e:	026de5        	call8	4037e80c <__assert_func>
4037c131:	b38c      	beqz.n	a3, 4037c140 <vTaskGenericNotifyGiveFromISR+0x24>
4037c133:	e311d1        	l32r	a13, 40374d78 <_iram_text_start+0x974>
4037c136:	e30ec1        	l32r	a12, 40374d70 <_iram_text_start+0x96c>
4037c139:	e310b1        	l32r	a11, 40374d7c <_iram_text_start+0x978>
4037c13c:	fffac6        	j	4037c12b <vTaskGenericNotifyGiveFromISR+0xf>
4037c13f:	00          	.byte 00
4037c140:	e2c431        	l32r	a3, 40374c50 <_iram_text_start+0x84c>
4037c143:	ffafb2        	movi	a11, -1
4037c146:	20a330        	or	a10, a3, a3
4037c149:	004665        	call8	4037c5b0 <xPortEnterCriticalTimeout>
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c14c:	01d252        	addmi	a5, a2, 0x100
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c14f:	02a092        	movi	a9, 2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c152:	0020c0        	memw
4037c155:	540582        	l8ui	a8, a5, 84
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4037c158:	0020c0        	memw
4037c15b:	544592        	s8i	a9, a5, 84
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c15e:	0020c0        	memw
4037c161:	542292        	l32i	a9, a2, 0x150
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4037c164:	748080        	extui	a8, a8, 0, 8
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4037c167:	991b      	addi.n	a9, a9, 1
4037c169:	0020c0        	memw
4037c16c:	546292        	s32i	a9, a2, 0x150
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4037c16f:	021826        	beqi	a8, 1, 4037c175 <vTaskGenericNotifyGiveFromISR+0x59>
4037c172:	002386        	j	4037c204 <vTaskGenericNotifyGiveFromISR+0xe8>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4037c175:	b258      	l32i.n	a5, a2, 44
4037c177:	d58c      	beqz.n	a5, 4037c188 <vTaskGenericNotifyGiveFromISR+0x6c>
4037c179:	efa2b2        	movi	a11, 0x2ef
4037c17c:	e301d1        	l32r	a13, 40374d80 <_iram_text_start+0x97c>
4037c17f:	e2fcc1        	l32r	a12, 40374d70 <_iram_text_start+0x96c>
4037c182:	11bbd0        	slli	a11, a11, 3
4037c185:	ffe886        	j	4037c12b <vTaskGenericNotifyGiveFromISR+0xf>
4037c188:	03eb80        	rsr.prid	a8
4037c18b:	048d80        	extui	a8, a8, 13, 1
                if( uxSchedulerSuspended[ xPortGetCoreID() ] == ( UBaseType_t ) pdFALSE )
4037c18e:	e2c351        	l32r	a5, 40374c9c <_iram_text_start+0x898>
4037c191:	a08850        	addx4	a8, a8, a5
4037c194:	0020c0        	memw
4037c197:	0858      	l32i.n	a5, a8, 0
4037c199:	06f556        	bnez	a5, 4037c20c <vTaskGenericNotifyGiveFromISR+0xf0>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4037c19c:	528b      	addi.n	a5, a2, 8
4037c19e:	20a550        	or	a10, a5, a5
4037c1a1:	002e65        	call8	4037c488 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
4037c1a4:	e2b881        	l32r	a8, 40374c84 <_iram_text_start+0x880>
4037c1a7:	c2a8      	l32i.n	a10, a2, 48
4037c1a9:	0020c0        	memw
4037c1ac:	0898      	l32i.n	a9, a8, 0
4037c1ae:	04b9a7        	bgeu	a9, a10, 4037c1b6 <vTaskGenericNotifyGiveFromISR+0x9a>
4037c1b1:	0020c0        	memw
4037c1b4:	08a9      	s32i.n	a10, a8, 0
4037c1b6:	05bd      	mov.n	a11, a5
4037c1b8:	e2ac51        	l32r	a5, 40374c68 <_iram_text_start+0x864>
4037c1bb:	a0aaa0        	addx4	a10, a10, a10
                    vListInsertEnd( &( xPendingReadyList[xPortGetCoreID()] ), &( pxTCB->xEventListItem ) );
4037c1be:	a0aa50        	addx4	a10, a10, a5
4037c1c1:	0026e5        	call8	4037c430 <vListInsertEnd>
                if( tskCAN_RUN_HERE(pxTCB->xCoreID) && pxTCB->uxPriority > pxCurrentTCB[ xPortGetCoreID() ]->uxPriority )
4037c1c4:	1222a2        	l32i	a10, a2, 72
4037c1c7:	03ebb0        	rsr.prid	a11
4037c1ca:	04bdb0        	extui	a11, a11, 13, 1
4037c1cd:	e2a1c1        	l32r	a12, 40374c54 <_iram_text_start+0x850>
4037c1d0:	180c      	movi.n	a8, 1
4037c1d2:	caca      	add.n	a12, a10, a12
4037c1d4:	090c      	movi.n	a9, 0
4037c1d6:	8398c0        	moveqz	a9, a8, a12
4037c1d9:	745090        	extui	a5, a9, 0, 8
4037c1dc:	69cc      	bnez.n	a9, 4037c1e6 <vTaskGenericNotifyGiveFromISR+0xca>
4037c1de:	c09ba0        	sub	a9, a11, a10
4037c1e1:	938590        	movnez	a8, a5, a9
4037c1e4:	88bc      	beqz.n	a8, 4037c220 <vTaskGenericNotifyGiveFromISR+0x104>
4037c1e6:	03eb80        	rsr.prid	a8
4037c1e9:	048d80        	extui	a8, a8, 13, 1
4037c1ec:	e14e51        	l32r	a5, 40374724 <_iram_text_start+0x320>
4037c1ef:	a08850        	addx4	a8, a8, a5
4037c1f2:	0020c0        	memw
4037c1f5:	0888      	l32i.n	a8, a8, 0
4037c1f7:	c258      	l32i.n	a5, a2, 48
4037c1f9:	c888      	l32i.n	a8, a8, 48
4037c1fb:	21b857        	bgeu	a8, a5, 4037c220 <vTaskGenericNotifyGiveFromISR+0x104>
                    if( pxHigherPriorityTaskWoken != NULL )
4037c1fe:	248c      	beqz.n	a4, 4037c204 <vTaskGenericNotifyGiveFromISR+0xe8>
                        *pxHigherPriorityTaskWoken = pdTRUE;
4037c200:	120c      	movi.n	a2, 1
4037c202:	0429      	s32i.n	a2, a4, 0
        taskEXIT_CRITICAL_ISR();
4037c204:	03ad      	mov.n	a10, a3
4037c206:	004de5        	call8	4037c6e4 <vPortExitCritical>
    }
4037c209:	f01d      	retw.n
4037c20b:	00          	.byte 00
4037c20c:	03eba0        	rsr.prid	a10
4037c20f:	04ada0        	extui	a10, a10, 13, 1
                    vListInsertEnd( &( xPendingReadyList[xPortGetCoreID()] ), &( pxTCB->xEventListItem ) );
4037c212:	e29851        	l32r	a5, 40374c74 <_iram_text_start+0x870>
4037c215:	a0aaa0        	addx4	a10, a10, a10
4037c218:	1cc2b2        	addi	a11, a2, 28
4037c21b:	ffe7c6        	j	4037c1be <vTaskGenericNotifyGiveFromISR+0xa2>
4037c21e:	00          	.byte 00
4037c21f:	00          	.byte 00
4037c220:	03eb40        	rsr.prid	a4
4037c223:	044d40        	extui	a4, a4, 13, 1
                else if ( pxTCB->xCoreID != xPortGetCoreID() )
4037c226:	da1a47        	beq	a10, a4, 4037c204 <vTaskGenericNotifyGiveFromISR+0xe8>
                    taskYIELD_OTHER_CORE( pxTCB->xCoreID, pxTCB->uxPriority );
4037c229:	c2b8      	l32i.n	a11, a2, 48
4037c22b:	fedf65        	call8	4037b020 <taskYIELD_OTHER_CORE>
4037c22e:	fff486        	j	4037c204 <vTaskGenericNotifyGiveFromISR+0xe8>
4037c231:	000000        	ill

4037c234 <__getreent>:
 * - If FreeRTOS is not running, it will return the global reent struct
 *
 * @return Pointer to a the (current taks's)/(globa) reent struct
 */
struct _reent *__getreent(void)
{
4037c234:	004136        	entry	a1, 32
    // No lock needed because if this changes, we won't be running anymore.
    TCB_t *pxCurTask = xTaskGetCurrentTaskHandle();
4037c237:	ff8ae5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
    if (pxCurTask == NULL) {
        // No task running. Return global struct.
        ret = _GLOBAL_REENT;
    } else {
        // We have a task; return its reentrant struct.
        ret = &pxCurTask->xNewLib_reent;
4037c23a:	60ca22        	addi	a2, a10, 96
    if (pxCurTask == NULL) {
4037c23d:	3acc      	bnez.n	a10, 4037c244 <__getreent+0x10>
        ret = _GLOBAL_REENT;
4037c23f:	e15621        	l32r	a2, 40374798 <_iram_text_start+0x394>
4037c242:	0228      	l32i.n	a2, a2, 0
    }
    return ret;
}
4037c244:	f01d      	retw.n
	...

4037c248 <vTaskGetSnapshot>:

    return pxNextTCB;
}

BaseType_t vTaskGetSnapshot( TaskHandle_t pxTask, TaskSnapshot_t *pxTaskSnapshot )
{
4037c248:	004136        	entry	a1, 32
    if (portVALID_TCB_MEM(pxTask) == false || pxTaskSnapshot == NULL) {
4037c24b:	02ad      	mov.n	a10, a2
4037c24d:	005e25        	call8	4037c830 <xPortCheckValidTCBMem>
4037c250:	180c      	movi.n	a8, 1
4037c252:	30aa80        	xor	a10, a10, a8
4037c255:	74a0a0        	extui	a10, a10, 0, 8
4037c258:	4adc      	bnez.n	a10, 4037c270 <vTaskGetSnapshot+0x28>
4037c25a:	180c      	movi.n	a8, 1
4037c25c:	83a830        	moveqz	a10, a8, a3
4037c25f:	dacc      	bnez.n	a10, 4037c270 <vTaskGetSnapshot+0x28>
        return pdFALSE;
    }

    TCB_t *pxTCB = (TCB_t *)pxTask;
    pxTaskSnapshot->pxTCB = pxTCB;
    pxTaskSnapshot->pxTopOfStack = (StackType_t *)pxTCB->pxTopOfStack;
4037c261:	0298      	l32i.n	a9, a2, 0
    pxTaskSnapshot->pxTCB = pxTCB;
4037c263:	0329      	s32i.n	a2, a3, 0
    pxTaskSnapshot->pxEndOfStack = (StackType_t *)pxTCB->pxEndOfStack;
4037c265:	132222        	l32i	a2, a2, 76
    pxTaskSnapshot->pxTopOfStack = (StackType_t *)pxTCB->pxTopOfStack;
4037c268:	1399      	s32i.n	a9, a3, 4
    pxTaskSnapshot->pxEndOfStack = (StackType_t *)pxTCB->pxEndOfStack;
4037c26a:	2329      	s32i.n	a2, a3, 8
4037c26c:	082d      	mov.n	a2, a8
    return pdTRUE;
}
4037c26e:	f01d      	retw.n
        return pdFALSE;
4037c270:	020c      	movi.n	a2, 0
4037c272:	fffe06        	j	4037c26e <vTaskGetSnapshot+0x26>
4037c275:	000000        	ill

4037c278 <prvTaskPriorityRaise>:
#endif // CONFIG_FREERTOS_SMP

#if ( INCLUDE_vTaskPrioritySet == 1 )

void prvTaskPriorityRaise( prvTaskSavedPriority_t * pxSavedPriority, UBaseType_t uxNewPriority )
{
4037c278:	004136        	entry	a1, 32
    TCB_t * pxTCB;
    UBaseType_t uxPriorityUsedOnEntry;

    configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
4037c27b:	18a042        	movi	a4, 24
4037c27e:	0eb437        	bgeu	a4, a3, 4037c290 <prvTaskPriorityRaise+0x18>
4037c281:	e2aad1        	l32r	a13, 40374d2c <_iram_text_start+0x928>
4037c284:	e2c0c1        	l32r	a12, 40374d84 <_iram_text_start+0x980>
4037c287:	e2c0a1        	l32r	a10, 40374d88 <_iram_text_start+0x984>
4037c28a:	95a1b2        	movi	a11, 0x195
4037c28d:	0257e5        	call8	4037e80c <__assert_func>
4037c290:	e27051        	l32r	a5, 40374c50 <_iram_text_start+0x84c>
4037c293:	ffafb2        	movi	a11, -1
4037c296:	05ad      	mov.n	a10, a5
4037c298:	003165        	call8	4037c5b0 <xPortEnterCriticalTimeout>
        uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    }

    taskENTER_CRITICAL();
    {
        pxTCB = prvGetTCBFromHandle( NULL );
4037c29b:	ff84a5        	call8	4037bae4 <xTaskGetCurrentTaskHandle>

        #if ( configUSE_MUTEXES == 1 )
        {
            pxSavedPriority->uxPriority = pxTCB->uxPriority;
4037c29e:	ca88      	l32i.n	a8, a10, 48
            pxSavedPriority->uxBasePriority = pxTCB->uxBasePriority;
4037c2a0:	142a92        	l32i	a9, a10, 80
            pxSavedPriority->uxPriority = pxTCB->uxPriority;
4037c2a3:	0289      	s32i.n	a8, a2, 0
            pxSavedPriority->uxBasePriority = pxTCB->uxBasePriority;
4037c2a5:	1299      	s32i.n	a9, a2, 4
        pxTCB = prvGetTCBFromHandle( NULL );
4037c2a7:	0a4d      	mov.n	a4, a10

            /* If uxNewPriority < uxBasePriority, then there is nothing else to
             * do, as uxBasePriority is always <= uxPriority. */
            if( uxNewPriority > pxTCB->uxBasePriority )
4037c2a9:	49b937        	bgeu	a9, a3, 4037c2f6 <prvTaskPriorityRaise+0x7e>
            {
                pxTCB->uxBasePriority = uxNewPriority;
4037c2ac:	146a32        	s32i	a3, a10, 80
                 * change it. If the task's current priority is changed, it must
                 * be done so before moving the task between task lists) in order
                 * for the taskRESET_READY_PRIORITY() macro to function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;

                if( uxNewPriority > pxTCB->uxPriority )
4037c2af:	43b837        	bgeu	a8, a3, 4037c2f6 <prvTaskPriorityRaise+0x7e>
                {
                    pxTCB->uxPriority = uxNewPriority;

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037c2b2:	7a28      	l32i.n	a2, a10, 28
                    pxTCB->uxPriority = uxNewPriority;
4037c2b4:	ca39      	s32i.n	a3, a10, 48
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037c2b6:	006296        	bltz	a2, 4037c2c0 <prvTaskPriorityRaise+0x48>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037c2b9:	921c      	movi.n	a2, 25
4037c2bb:	c02230        	sub	a2, a2, a3
4037c2be:	7a29      	s32i.n	a2, a10, 28

                    /* If the task is in the blocked or suspended list we need do
                     * nothing more than change its priority variable. However, if
                     * the task is in a ready list it needs to be removed and placed
                     * in the list appropriate to its new priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037c2c0:	e26a21        	l32r	a2, 40374c68 <_iram_text_start+0x864>
4037c2c3:	a08880        	addx4	a8, a8, a8
4037c2c6:	6438      	l32i.n	a3, a4, 24
4037c2c8:	a08820        	addx4	a8, a8, a2
4037c2cb:	279387        	bne	a3, a8, 4037c2f6 <prvTaskPriorityRaise+0x7e>
                    {
                        /* The task is currently in its ready list - remove before
                         * adding it to its new ready list.  As we are in a critical
                         * section we can do this even if the scheduler is suspended. */
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037c2ce:	348b      	addi.n	a3, a4, 8
4037c2d0:	20a330        	or	a10, a3, a3
4037c2d3:	001b65        	call8	4037c488 <uxListRemove>
                            /* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
                        }
                        prvAddTaskToReadyList( pxTCB );
4037c2d6:	c4a8      	l32i.n	a10, a4, 48
4037c2d8:	e26b41        	l32r	a4, 40374c84 <_iram_text_start+0x880>
4037c2db:	0020c0        	memw
4037c2de:	0488      	l32i.n	a8, a4, 0
4037c2e0:	04b8a7        	bgeu	a8, a10, 4037c2e8 <prvTaskPriorityRaise+0x70>
4037c2e3:	0020c0        	memw
4037c2e6:	04a9      	s32i.n	a10, a4, 0
4037c2e8:	a0aaa0        	addx4	a10, a10, a10
4037c2eb:	03bd      	mov.n	a11, a3
4037c2ed:	a0aa20        	addx4	a10, a10, a2
4037c2f0:	201110        	or	a1, a1, a1
4037c2f3:	0013e5        	call8	4037c430 <vListInsertEnd>
                vTaskPrioritySet( NULL, uxNewPriority );
            }
        }
        #endif
    }
    taskEXIT_CRITICAL();
4037c2f6:	05ad      	mov.n	a10, a5
4037c2f8:	003ea5        	call8	4037c6e4 <vPortExitCritical>
}
4037c2fb:	f01d      	retw.n
4037c2fd:	000000        	ill

4037c300 <prvTaskPriorityRestore>:

void prvTaskPriorityRestore( prvTaskSavedPriority_t * pxSavedPriority )
{
4037c300:	004136        	entry	a1, 32
4037c303:	e25351        	l32r	a5, 40374c50 <_iram_text_start+0x84c>
4037c306:	fb7c      	movi.n	a11, -1
4037c308:	05ad      	mov.n	a10, a5
4037c30a:	002a65        	call8	4037c5b0 <xPortEnterCriticalTimeout>
    UBaseType_t uxBasePriorityUsedOnEntry;
    BaseType_t xYieldRequired = pdFALSE;

    taskENTER_CRITICAL();
    {
        pxTCB = prvGetTCBFromHandle( NULL );
4037c30d:	ff7d65        	call8	4037bae4 <xTaskGetCurrentTaskHandle>
        #if ( configUSE_MUTEXES == 1 )
        {
            /* If the saved uxBasePriority == the task's uxBasePriority, it means
             * that prvTaskPriorityRaise() never raised the task's uxBasePriority.
             * In that case, there is nothing else to do. */
            if( pxSavedPriority->uxBasePriority != pxTCB->uxBasePriority )
4037c310:	142a72        	l32i	a7, a10, 80
4037c313:	1248      	l32i.n	a4, a2, 4
        pxTCB = prvGetTCBFromHandle( NULL );
4037c315:	0a3d      	mov.n	a3, a10
            if( pxSavedPriority->uxBasePriority != pxTCB->uxBasePriority )
4037c317:	5f1477        	beq	a4, a7, 4037c37a <prvTaskPriorityRestore+0x7a>

                /* Remember the task's current priority before attempting to
                 * change it. If the task's current priority is changed, it must
                 * be done so before moving the task between task lists in order
                 * for the taskRESET_READY_PRIORITY() macro to function correctly. */
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
4037c31a:	ca68      	l32i.n	a6, a10, 48
                pxTCB->uxBasePriority = pxSavedPriority->uxBasePriority;
4037c31c:	146a42        	s32i	a4, a10, 80

                /* Check if the task inherited a priority after prvTaskPriorityRaise().
                 * If this is the case, there is nothing else to do. The priority
                 * will be restored when the task disinherits its priority. */
                if( pxTCB->uxPriority == uxBasePriorityUsedOnEntry )
4037c31f:	579767        	bne	a7, a6, 4037c37a <prvTaskPriorityRestore+0x7a>
                {
                    if( pxTCB->uxMutexesHeld == 0 )
4037c322:	152a72        	l32i	a7, a10, 84
4037c325:	001716        	beqz	a7, 4037c32a <prvTaskPriorityRestore+0x2a>
                    {
                        /* The task may have inherited a priority before prvTaskPriorityRaise()
                         * was called. Thus, we need to restore uxPriority to the
                         * "saved uxPriority" so that the task still retains that
                         * inherited priority. */
                        pxTCB->uxPriority = pxSavedPriority->uxPriority;
4037c328:	0248      	l32i.n	a4, a2, 0
                        xYieldRequired = pdTRUE;
                    }

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
4037c32a:	7328      	l32i.n	a2, a3, 28
4037c32c:	c349      	s32i.n	a4, a3, 48
4037c32e:	007296        	bltz	a2, 4037c339 <prvTaskPriorityRestore+0x39>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
4037c331:	921c      	movi.n	a2, 25
4037c333:	c02240        	sub	a2, a2, a4
4037c336:	076322        	s32i	a2, a3, 28

                    /* If the task is in the blocked or suspended list we need do
                     * nothing more than change its priority variable. However, if
                     * the task is in a ready list it needs to be removed and placed
                     * in the list appropriate to its new priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
4037c339:	e24b21        	l32r	a2, 40374c68 <_iram_text_start+0x864>
4037c33c:	a08660        	addx4	a8, a6, a6
4037c33f:	6378      	l32i.n	a7, a3, 24
4037c341:	a08820        	addx4	a8, a8, a2
4037c344:	239787        	bne	a7, a8, 4037c36b <prvTaskPriorityRestore+0x6b>
                    {
                        /* The task is currently in its ready list - remove before
                         * adding it to its new ready list.  As we are in a critical
                         * section we can do this even if the scheduler is suspended. */
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4037c347:	738b      	addi.n	a7, a3, 8
4037c349:	07ad      	mov.n	a10, a7
4037c34b:	0013e5        	call8	4037c488 <uxListRemove>
                            /* It is known that the task is in its ready list so
                             * there is no need to check again and the port level
                             * reset macro can be called directly. */
                            portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
                        }
                        prvAddTaskToReadyList( pxTCB );
4037c34e:	c3a8      	l32i.n	a10, a3, 48
4037c350:	e24d31        	l32r	a3, 40374c84 <_iram_text_start+0x880>
4037c353:	0020c0        	memw
4037c356:	0388      	l32i.n	a8, a3, 0
4037c358:	04b8a7        	bgeu	a8, a10, 4037c360 <prvTaskPriorityRestore+0x60>
4037c35b:	0020c0        	memw
4037c35e:	03a9      	s32i.n	a10, a3, 0
4037c360:	a0aaa0        	addx4	a10, a10, a10
4037c363:	07bd      	mov.n	a11, a7
4037c365:	a0aa20        	addx4	a10, a10, a2
4037c368:	000c65        	call8	4037c430 <vListInsertEnd>
                    }

                    if( xYieldRequired != pdFALSE )
4037c36b:	0bb467        	bgeu	a4, a6, 4037c37a <prvTaskPriorityRestore+0x7a>
4037c36e:	03eba0        	rsr.prid	a10
4037c371:	04ada0        	extui	a10, a10, 13, 1
                    {
                        taskYIELD_IF_USING_PREEMPTION();
4037c374:	201110        	or	a1, a1, a1
4037c377:	fbcca5        	call8	40378040 <esp_crosscore_int_send_yield>
        {
            vTaskPrioritySet( NULL, pxSavedPriority->uxPriority );
        }
        #endif
    }
    taskEXIT_CRITICAL();
4037c37a:	05ad      	mov.n	a10, a5
4037c37c:	003665        	call8	4037c6e4 <vPortExitCritical>
}
4037c37f:	f01d      	retw.n
4037c381:	000000        	ill

4037c384 <vTaskStartScheduler>:
{
4037c384:	008136        	entry	a1, 64
    for(BaseType_t xCoreID = 0; xCoreID < configNUM_CORES; xCoreID++)
4037c387:	020c      	movi.n	a2, 0
4037c389:	e24741        	l32r	a4, 40374ca8 <_iram_text_start+0x8a4>
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
4037c38c:	023d      	mov.n	a3, a2
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
4037c38e:	10c1c2        	addi	a12, a1, 16
4037c391:	14c1b2        	addi	a11, a1, 20
4037c394:	18c1a2        	addi	a10, a1, 24
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
4037c397:	6139      	s32i.n	a3, a1, 24
            StackType_t * pxIdleTaskStackBuffer = NULL;
4037c399:	056132        	s32i	a3, a1, 20
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
4037c39c:	004e65        	call8	4037c884 <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle[ xCoreID ] = xTaskCreateStaticPinnedToCore( prvIdleTask,
4037c39f:	6188      	l32i.n	a8, a1, 24
4037c3a1:	0e0c      	movi.n	a14, 0
4037c3a3:	51f8      	l32i.n	a15, a1, 20
4037c3a5:	41c8      	l32i.n	a12, a1, 16
4037c3a7:	e279b1        	l32r	a11, 40374d8c <_iram_text_start+0x988>
4037c3aa:	e279a1        	l32r	a10, 40374d90 <_iram_text_start+0x98c>
4037c3ad:	1129      	s32i.n	a2, a1, 4
4037c3af:	0189      	s32i.n	a8, a1, 0
4037c3b1:	20dee0        	or	a13, a14, a14
4037c3b4:	fee2a5        	call8	4037b1e0 <xTaskCreateStaticPinnedToCore>
4037c3b7:	04a9      	s32i.n	a10, a4, 0
    for(BaseType_t xCoreID = 0; xCoreID < configNUM_CORES; xCoreID++)
4037c3b9:	444b      	addi.n	a4, a4, 4
4037c3bb:	291266        	bnei	a2, 1, 4037c3e8 <vTaskStartScheduler+0x64>
            if( xReturn == pdPASS )
4037c3be:	4aac      	beqz.n	a10, 4037c3e6 <vTaskStartScheduler+0x62>
                xReturn = xTimerCreateTimerTask();
4037c3c0:	000425        	call8	4037c404 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
4037c3c3:	261a66        	bnei	a10, 1, 4037c3ed <vTaskStartScheduler+0x69>
        portDISABLE_INTERRUPTS();
4037c3c6:	006340        	rsil	a4, 3
        xNextTaskUnblockTime = portMAX_DELAY;
4037c3c9:	e21941        	l32r	a4, 40374c30 <_iram_text_start+0x82c>
4037c3cc:	f87c      	movi.n	a8, -1
4037c3ce:	0020c0        	memw
4037c3d1:	0489      	s32i.n	a8, a4, 0
        xSchedulerRunning = pdTRUE;
4037c3d3:	e22a41        	l32r	a4, 40374c7c <_iram_text_start+0x878>
4037c3d6:	0020c0        	memw
4037c3d9:	0429      	s32i.n	a2, a4, 0
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
4037c3db:	e21021        	l32r	a2, 40374c1c <_iram_text_start+0x818>
4037c3de:	0020c0        	memw
4037c3e1:	0239      	s32i.n	a3, a2, 0
        if( xPortStartScheduler() != pdFALSE )
4037c3e3:	000d25        	call8	4037c4b4 <xPortStartScheduler>
}
4037c3e6:	f01d      	retw.n
4037c3e8:	120c      	movi.n	a2, 1
4037c3ea:	ffe806        	j	4037c38e <vTaskStartScheduler+0xa>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
4037c3ed:	f50a66        	bnei	a10, -1, 4037c3e6 <vTaskStartScheduler+0x62>
4037c3f0:	bb4c      	movi.n	a11, 75
4037c3f2:	e268d1        	l32r	a13, 40374d94 <_iram_text_start+0x990>
4037c3f5:	e268c1        	l32r	a12, 40374d98 <_iram_text_start+0x994>
4037c3f8:	e211a1        	l32r	a10, 40374c3c <_iram_text_start+0x838>
4037c3fb:	11bbb0        	slli	a11, a11, 5
4037c3fe:	0240e5        	call8	4037e80c <__assert_func>
4037c401:	000000        	ill

4037c404 <xTimerCreateTimerTask>:

#endif /* if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 ) */

/* If timers.c is not referenced anywhere, don't create the timer task to save RAM */
BaseType_t  __attribute__((weak)) xTimerCreateTimerTask( void )
{
4037c404:	004136        	entry	a1, 32
    return pdPASS;
}
4037c407:	120c      	movi.n	a2, 1
4037c409:	f01d      	retw.n
	...

4037c40c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
4037c40c:	004136        	entry	a1, 32
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037c40f:	828b      	addi.n	a8, a2, 8
4037c411:	1289      	s32i.n	a8, a2, 4

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
4037c413:	f97c      	movi.n	a9, -1

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037c415:	3289      	s32i.n	a8, a2, 12
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
4037c417:	4289      	s32i.n	a8, a2, 16

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
4037c419:	080c      	movi.n	a8, 0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
4037c41b:	2299      	s32i.n	a9, a2, 8
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
4037c41d:	0020c0        	memw
4037c420:	0289      	s32i.n	a8, a2, 0

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
4037c422:	f01d      	retw.n

4037c424 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
4037c424:	004136        	entry	a1, 32
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
4037c427:	080c      	movi.n	a8, 0
4037c429:	4289      	s32i.n	a8, a2, 16

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
4037c42b:	f01d      	retw.n
4037c42d:	000000        	ill

4037c430 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
4037c430:	004136        	entry	a1, 32
    ListItem_t * const pxIndex = pxList->pxIndex;
4037c433:	1288      	l32i.n	a8, a2, 4

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
4037c435:	2898      	l32i.n	a9, a8, 8
    pxNewListItem->pxNext = pxIndex;
4037c437:	1389      	s32i.n	a8, a3, 4
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
4037c439:	2399      	s32i.n	a9, a3, 8

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
4037c43b:	2898      	l32i.n	a9, a8, 8
4037c43d:	1939      	s32i.n	a3, a9, 4
    pxIndex->pxPrevious = pxNewListItem;
4037c43f:	2839      	s32i.n	a3, a8, 8

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
4037c441:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037c443:	0020c0        	memw
4037c446:	0238      	l32i.n	a3, a2, 0
4037c448:	331b      	addi.n	a3, a3, 1
4037c44a:	0020c0        	memw
4037c44d:	0239      	s32i.n	a3, a2, 0
}
4037c44f:	f01d      	retw.n
4037c451:	000000        	ill

4037c454 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
4037c454:	004136        	entry	a1, 32
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
4037c457:	03a8      	l32i.n	a10, a3, 0
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
4037c459:	928b      	addi.n	a9, a2, 8
    if( xValueOfInsertion == portMAX_DELAY )
4037c45b:	1b0a66        	bnei	a10, -1, 4037c47a <vListInsert+0x26>
        pxIterator = pxList->xListEnd.pxPrevious;
4037c45e:	4288      	l32i.n	a8, a2, 16
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
4037c460:	1898      	l32i.n	a9, a8, 4
4037c462:	1399      	s32i.n	a9, a3, 4
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
4037c464:	2939      	s32i.n	a3, a9, 8
    pxNewListItem->pxPrevious = pxIterator;
4037c466:	2389      	s32i.n	a8, a3, 8
    pxIterator->pxNext = pxNewListItem;
4037c468:	1839      	s32i.n	a3, a8, 4

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
4037c46a:	4329      	s32i.n	a2, a3, 16

    ( pxList->uxNumberOfItems )++;
4037c46c:	0020c0        	memw
4037c46f:	0238      	l32i.n	a3, a2, 0
4037c471:	331b      	addi.n	a3, a3, 1
4037c473:	0020c0        	memw
4037c476:	0239      	s32i.n	a3, a2, 0
}
4037c478:	f01d      	retw.n
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
4037c47a:	098d      	mov.n	a8, a9
4037c47c:	1998      	l32i.n	a9, a9, 4
4037c47e:	09b8      	l32i.n	a11, a9, 0
4037c480:	f6bab7        	bgeu	a10, a11, 4037c47a <vListInsert+0x26>
4037c483:	fff646        	j	4037c460 <vListInsert+0xc>
	...

4037c488 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
4037c488:	004136        	entry	a1, 32
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
4037c48b:	12a8      	l32i.n	a10, a2, 4
4037c48d:	2298      	l32i.n	a9, a2, 8
    List_t * const pxList = pxItemToRemove->pxContainer;
4037c48f:	4288      	l32i.n	a8, a2, 16
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
4037c491:	2a99      	s32i.n	a9, a10, 8
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
4037c493:	19a9      	s32i.n	a10, a9, 4

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
4037c495:	18a8      	l32i.n	a10, a8, 4
4037c497:	019a27        	bne	a10, a2, 4037c49c <uxListRemove+0x14>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
4037c49a:	1899      	s32i.n	a9, a8, 4
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
4037c49c:	090c      	movi.n	a9, 0
4037c49e:	4299      	s32i.n	a9, a2, 16
    ( pxList->uxNumberOfItems )--;
4037c4a0:	0020c0        	memw
4037c4a3:	0828      	l32i.n	a2, a8, 0
4037c4a5:	220b      	addi.n	a2, a2, -1
4037c4a7:	0020c0        	memw
4037c4aa:	0829      	s32i.n	a2, a8, 0

    return pxList->uxNumberOfItems;
4037c4ac:	0020c0        	memw
4037c4af:	0828      	l32i.n	a2, a8, 0
}
4037c4b1:	f01d      	retw.n
	...

4037c4b4 <xPortStartScheduler>:
{
4037c4b4:	004136        	entry	a1, 32
    portDISABLE_INTERRUPTS();
4037c4b7:	006320        	rsil	a2, 3
    _xt_coproc_init();
4037c4ba:	fdcbe5        	call8	4037a178 <_xt_coproc_init>
    vPortSetupTimer();
4037c4bd:	fdd525        	call8	4037a210 <vPortSetupTimer>
4037c4c0:	03eb80        	rsr.prid	a8
4037c4c3:	048d80        	extui	a8, a8, 13, 1
    port_xSchedulerRunning[xPortGetCoreID()] = 1;
4037c4c6:	e1a721        	l32r	a2, 40374b64 <_iram_text_start+0x760>
4037c4c9:	a08820        	addx4	a8, a8, a2
4037c4cc:	01a022        	movi	a2, 1
4037c4cf:	0020c0        	memw
4037c4d2:	006822        	s32i	a2, a8, 0
    __asm__ volatile ("call0    _frxt_dispatch\n");
4037c4d5:	fdacc5        	call0	40379fa4 <_frxt_dispatch>
}
4037c4d8:	f01d      	retw.n
	...

4037c4dc <pxPortInitialiseStack>:
{
4037c4dc:	006136        	entry	a1, 48
    uint32_t thread_local_sz = (uint8_t *)&_thread_local_end - (uint8_t *)&_thread_local_start;
4037c4df:	e22f61        	l32r	a6, 40374d9c <_iram_text_start+0x998>
{
4037c4e2:	037d      	mov.n	a7, a3
    uint32_t thread_local_sz = (uint8_t *)&_thread_local_end - (uint8_t *)&_thread_local_start;
4037c4e4:	e22f31        	l32r	a3, 40374da0 <_iram_text_start+0x99c>
    thread_local_sz = ALIGNUP(0x10, thread_local_sz);
4037c4e7:	087c      	movi.n	a8, -16
    uint32_t thread_local_sz = (uint8_t *)&_thread_local_end - (uint8_t *)&_thread_local_start;
4037c4e9:	c06630        	sub	a6, a6, a3
    thread_local_sz = ALIGNUP(0x10, thread_local_sz);
4037c4ec:	66fb      	addi.n	a6, a6, 15
4037c4ee:	106680        	and	a6, a6, a8
    sp = (StackType_t *) (((UBaseType_t)pxTopOfStack - XT_CP_SIZE - thread_local_sz - XT_STK_FRMSZ) & ~0xf);
4037c4f1:	c03260        	sub	a3, a2, a6
4037c4f4:	04ae52        	movi	a5, 0xfffffe04
4037c4f7:	535a      	add.n	a5, a3, a5
4037c4f9:	105580        	and	a5, a5, a8
        *tp = 0;
4037c4fc:	821b      	addi.n	a8, a2, 1
4037c4fe:	0c0c      	movi.n	a12, 0
4037c500:	023857        	bltu	a8, a5, 4037c506 <pxPortInitialiseStack+0x2a>
4037c503:	c0c850        	sub	a12, a8, a5
4037c506:	0b0c      	movi.n	a11, 0
4037c508:	05ad      	mov.n	a10, a5
4037c50a:	dfda81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037c50d:	0008e0        	callx8	a8
    frame->a1    = (UBaseType_t) sp + XT_STK_FRMSZ;    /* physical top of stack frame        */
4037c510:	c0a082        	movi	a8, 192
4037c513:	858a      	add.n	a8, a5, a8
4037c515:	4589      	s32i.n	a8, a5, 16
    frame->exit = (UBaseType_t) _xt_user_exit;        /* user exception exit dispatcher    */
4037c517:	e08281        	l32r	a8, 40374720 <_iram_text_start+0x31c>
    frame->pc   = (UBaseType_t) pxCode;                /* task entrypoint                    */
4037c51a:	1579      	s32i.n	a7, a5, 4
    frame->exit = (UBaseType_t) _xt_user_exit;        /* user exception exit dispatcher    */
4037c51c:	0589      	s32i.n	a8, a5, 0
    frame->ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1);
4037c51e:	e22181        	l32r	a8, 40374da4 <_iram_text_start+0x9a0>
    memcpy(task_thread_local_start, &_thread_local_start, thread_local_sz);
4037c521:	e21fb1        	l32r	a11, 40374da0 <_iram_text_start+0x99c>
    frame->ps = PS_UM | PS_EXCM | PS_WOE | PS_CALLINC(1);
4037c524:	2589      	s32i.n	a8, a5, 8
    task_thread_local_start = (void *)(((uint32_t)pxTopOfStack - XT_CP_SIZE - thread_local_sz) & ~0xf);
4037c526:	c4ae82        	movi	a8, 0xfffffec4
4037c529:	938a      	add.n	a9, a3, a8
4037c52b:	037c      	movi.n	a3, -16
4037c52d:	109930        	and	a9, a9, a3
    frame->a0    = 0;                                /* to terminate GDB backtrace        */
4037c530:	070c      	movi.n	a7, 0
    frame->a6 = (UBaseType_t) pvParameters;
4037c532:	9549      	s32i.n	a4, a5, 36
    frame->a0    = 0;                                /* to terminate GDB backtrace        */
4037c534:	3579      	s32i.n	a7, a5, 12
    memcpy(task_thread_local_start, &_thread_local_start, thread_local_sz);
4037c536:	06cd      	mov.n	a12, a6
4037c538:	09ad      	mov.n	a10, a9
4037c53a:	0189      	s32i.n	a8, a1, 0
4037c53c:	dfdd81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037c53f:	0008e0        	callx8	a8
4037c542:	0a9d      	mov.n	a9, a10
    const uint32_t tls_section_alignment = (uint32_t) &_flash_rodata_align;  /* ALIGN value of .flash.rodata section */
4037c544:	e21961        	l32r	a6, 40374da8 <_iram_text_start+0x9a4>
    *threadptr = (uint32_t)task_thread_local_start - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037c547:	e21641        	l32r	a4, 40374da0 <_iram_text_start+0x99c>
4037c54a:	e218a1        	l32r	a10, 40374dac <_iram_text_start+0x9a8>
    p = (uint32_t *)(((uint32_t) pxTopOfStack - XT_CP_SIZE) & ~0xf);
4037c54d:	0188      	l32i.n	a8, a1, 0
    *threadptr = (uint32_t)task_thread_local_start - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037c54f:	c0aa40        	sub	a10, a10, a4
    const uint32_t base = (tcb_size + tls_section_alignment - 1) & (~(tls_section_alignment - 1));
4037c552:	467b      	addi.n	a4, a6, 7
4037c554:	606060        	neg	a6, a6
4037c557:	104460        	and	a4, a4, a6
    *threadptr = (uint32_t)task_thread_local_start - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037c55a:	c0aa40        	sub	a10, a10, a4
4037c55d:	aa9a      	add.n	a10, a10, a9
    p = (uint32_t *)(((uint32_t) pxTopOfStack - XT_CP_SIZE) & ~0xf);
4037c55f:	228a      	add.n	a2, a2, a8
    configASSERT( ( uint32_t ) p >= frame->a1 );
4037c561:	042542        	l32i	a4, a5, 16
    *threadptr = (uint32_t)task_thread_local_start - ((uint32_t)&_thread_local_start - (uint32_t)&_flash_rodata_start) - base;
4037c564:	1c65a2        	s32i	a10, a5, 112
    p = (uint32_t *)(((uint32_t) pxTopOfStack - XT_CP_SIZE) & ~0xf);
4037c567:	102230        	and	a2, a2, a3
    configASSERT( ( uint32_t ) p >= frame->a1 );
4037c56a:	0eb247        	bgeu	a2, a4, 4037c57c <pxPortInitialiseStack+0xa0>
4037c56d:	e210d1        	l32r	a13, 40374db0 <_iram_text_start+0x9ac>
4037c570:	e211c1        	l32r	a12, 40374db4 <_iram_text_start+0x9b0>
4037c573:	e211a1        	l32r	a10, 40374db8 <_iram_text_start+0x9b4>
4037c576:	05a1b2        	movi	a11, 0x105
4037c579:	022925        	call8	4037e80c <__assert_func>
    p[2] = (((uint32_t) p) + 12 + XCHAL_TOTAL_SA_ALIGN - 1) & -XCHAL_TOTAL_SA_ALIGN;
4037c57c:	1bc242        	addi	a4, a2, 27
4037c57f:	103430        	and	a3, a4, a3
    p[0] = 0;
4037c582:	0279      	s32i.n	a7, a2, 0
    p[1] = 0;
4037c584:	1279      	s32i.n	a7, a2, 4
    p[2] = (((uint32_t) p) + 12 + XCHAL_TOTAL_SA_ALIGN - 1) & -XCHAL_TOTAL_SA_ALIGN;
4037c586:	2239      	s32i.n	a3, a2, 8
}
4037c588:	052d      	mov.n	a2, a5
4037c58a:	f01d      	retw.n

4037c58c <xPortInIsrContext>:
{
4037c58c:	004136        	entry	a1, 32
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037c58f:	0063a0        	rsil	a10, 3
4037c592:	03eb20        	rsr.prid	a2
4037c595:	042d20        	extui	a2, a2, 13, 1
    ret = (port_interruptNesting[xPortGetCoreID()] != 0);
4037c598:	e05e81        	l32r	a8, 40374710 <_iram_text_start+0x30c>
4037c59b:	a02280        	addx4	a2, a2, a8
4037c59e:	0298      	l32i.n	a9, a2, 0
4037c5a0:	080c      	movi.n	a8, 0
4037c5a2:	120c      	movi.n	a2, 1
4037c5a4:	832890        	moveqz	a2, a8, a9
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037c5a7:	e19381        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037c5aa:	0008e0        	callx8	a8
}
4037c5ad:	f01d      	retw.n
	...

4037c5b0 <xPortEnterCriticalTimeout>:

// ------------------ Critical Sections --------------------

BaseType_t __attribute__((optimize("-O3"))) xPortEnterCriticalTimeout(portMUX_TYPE *mux, BaseType_t timeout)
{
4037c5b0:	006136        	entry	a1, 48
    UBaseType_t prev_int_level = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037c5b3:	006340        	rsil	a4, 3
4037c5b6:	0149      	s32i.n	a4, a1, 0
    uint32_t irq_status;
    uint32_t core_id, other_core_id;
    bool lock_set;
    esp_cpu_cycle_count_t start_count;

    assert(lock);
4037c5b8:	d2cc      	bnez.n	a2, 4037c5c9 <xPortEnterCriticalTimeout+0x19>
4037c5ba:	e200d1        	l32r	a13, 40374dbc <_iram_text_start+0x9b8>
4037c5bd:	e200c1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c5c0:	e201a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c5c3:	ab4c      	movi.n	a11, 74
4037c5c5:	000946        	j	4037c5ee <xPortEnterCriticalTimeout+0x3e>
4037c5c8:	00          	.byte 00
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037c5c9:	006350        	rsil	a5, 3
    asm volatile (
4037c5cc:	03eb70        	rsr.prid	a7
     *  - If "our" core_id, we can drop through immediately.
     *  - If "other_core_id", we spin here.
     */

    // The caller is already the owner of the lock. Simply increment the nesting count
    if (lock->owner == core_id) {
4037c5cf:	0248      	l32i.n	a4, a2, 0
4037c5d1:	1c9747        	bne	a7, a4, 4037c5f1 <xPortEnterCriticalTimeout+0x41>
        assert(lock->count > 0 && lock->count < 0xFF);    // Bad count value implies memory corruption
4037c5d4:	1238      	l32i.n	a3, a2, 4
4037c5d6:	fda062        	movi	a6, 253
4037c5d9:	430b      	addi.n	a4, a3, -1
        lock->count++;
4037c5db:	331b      	addi.n	a3, a3, 1
        assert(lock->count > 0 && lock->count < 0xFF);    // Bad count value implies memory corruption
4037c5dd:	023647        	bltu	a6, a4, 4037c5e3 <xPortEnterCriticalTimeout+0x33>
4037c5e0:	002046        	j	4037c665 <xPortEnterCriticalTimeout+0xb5>
4037c5e3:	e1f9d1        	l32r	a13, 40374dc8 <_iram_text_start+0x9c4>
4037c5e6:	e1f6c1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c5e9:	e1f6a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c5ec:	ab5c      	movi.n	a11, 90
4037c5ee:	0221e5        	call8	4037e80c <__assert_func>
     * Note: We do a first attempt separately (instead of putting this into a loop) in order to avoid call to
     * esp_cpu_get_cycle_count(). This doing a first attempt separately makes acquiring a free lock quicker, which
     * is the case for the majority of spinlock_acquire() calls (as spinlocks are free most of the time since they
     * aren't meant to be held for long).
     */
    lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_id);
4037c5f1:	e13a41        	l32r	a4, 40374adc <_iram_text_start+0x6d8>
4037c5f4:	20c770        	or	a12, a7, a7
4037c5f7:	20b440        	or	a11, a4, a4
4037c5fa:	20a220        	or	a10, a2, a2
4037c5fd:	fbc565        	call8	40378254 <esp_cpu_compare_and_set>
    if (lock_set || timeout == SPINLOCK_NO_WAIT) {
4037c600:	83bc      	beqz.n	a3, 4037c63c <xPortEnterCriticalTimeout+0x8c>
4037c602:	eaec      	bnez.n	a10, 4037c634 <xPortEnterCriticalTimeout+0x84>
    RSR(CCOUNT, ccount);
4037c604:	03ea60        	rsr.ccount	a6
    return ccount;
4037c607:	1a0326        	beqi	a3, -1, 4037c625 <xPortEnterCriticalTimeout+0x75>
    }

    // First attempt to take the lock has failed. Retry until the lock is taken, or until we timeout.
    start_count = esp_cpu_get_cycle_count();
    do {
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_id);
4037c60a:	20c770        	or	a12, a7, a7
4037c60d:	20b440        	or	a11, a4, a4
4037c610:	20a220        	or	a10, a2, a2
4037c613:	fbc425        	call8	40378254 <esp_cpu_compare_and_set>
        if (lock_set) {
4037c616:	aadc      	bnez.n	a10, 4037c634 <xPortEnterCriticalTimeout+0x84>
    RSR(CCOUNT, ccount);
4037c618:	03ea90        	rsr.ccount	a9
            break;
        }
        // Keep looping if we are waiting forever, or check if we have timed out
    } while ((timeout == SPINLOCK_WAIT_FOREVER) || (esp_cpu_get_cycle_count() - start_count) <= timeout);
4037c61b:	c09960        	sub	a9, a9, a6
4037c61e:	e8b397        	bgeu	a3, a9, 4037c60a <xPortEnterCriticalTimeout+0x5a>
4037c621:	0012c6        	j	4037c670 <xPortEnterCriticalTimeout+0xc0>
4037c624:	00          	.byte 00
        lock_set = esp_cpu_compare_and_set(&lock->owner, SPINLOCK_FREE, core_id);
4037c625:	20c770        	or	a12, a7, a7
4037c628:	20b440        	or	a11, a4, a4
4037c62b:	20a220        	or	a10, a2, a2
4037c62e:	fbc265        	call8	40378254 <esp_cpu_compare_and_set>
        if (lock_set) {
4037c631:	ff0a16        	beqz	a10, 4037c625 <xPortEnterCriticalTimeout+0x75>

exit:
    if (lock_set) {
        assert(lock->owner == core_id);
4037c634:	0238      	l32i.n	a3, a2, 0
4037c636:	161737        	beq	a7, a3, 4037c650 <xPortEnterCriticalTimeout+0xa0>
4037c639:	000106        	j	4037c641 <xPortEnterCriticalTimeout+0x91>
    if (lock_set) {
4037c63c:	0abc      	beqz.n	a10, 4037c670 <xPortEnterCriticalTimeout+0xc0>
4037c63e:	fffc86        	j	4037c634 <xPortEnterCriticalTimeout+0x84>
        assert(lock->owner == core_id);
4037c641:	e1e2d1        	l32r	a13, 40374dcc <_iram_text_start+0x9c8>
4037c644:	e1dfc1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c647:	e1dfa1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c64a:	79a0b2        	movi	a11, 121
4037c64d:	ffe746        	j	4037c5ee <xPortEnterCriticalTimeout+0x3e>
        assert(lock->count == 0);   // This is the first time the lock is set, so count should still be 0
4037c650:	1238      	l32i.n	a3, a2, 4
4037c652:	d38c      	beqz.n	a3, 4037c663 <xPortEnterCriticalTimeout+0xb3>
4037c654:	e1dfd1        	l32r	a13, 40374dd0 <_iram_text_start+0x9cc>
4037c657:	e1dac1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c65a:	e1daa1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c65d:	7aa0b2        	movi	a11, 122
4037c660:	ffe286        	j	4037c5ee <xPortEnterCriticalTimeout+0x3e>
        lock->count++;  // Finally, we increment the lock count
4037c663:	130c      	movi.n	a3, 1
4037c665:	1239      	s32i.n	a3, a2, 4
    } else {    // We timed out waiting for lock
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_id);
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
    }

    XTOS_RESTORE_INTLEVEL(irq_status);
4037c667:	13e650        	wsr.ps	a5
4037c66a:	002010        	rsync
    return lock_set;
4037c66d:	001286        	j	4037c6bb <xPortEnterCriticalTimeout+0x10b>
    other_core_id = CORE_ID_REGVAL_XOR_SWAP ^ core_id;
4037c670:	e1d941        	l32r	a4, 40374dd4 <_iram_text_start+0x9d0>
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_id);
4037c673:	0238      	l32i.n	a3, a2, 0
    other_core_id = CORE_ID_REGVAL_XOR_SWAP ^ core_id;
4037c675:	308740        	xor	a8, a7, a4
        assert(lock->owner == SPINLOCK_FREE || lock->owner == other_core_id);
4037c678:	151837        	beq	a8, a3, 4037c691 <xPortEnterCriticalTimeout+0xe1>
4037c67b:	e1d741        	l32r	a4, 40374dd8 <_iram_text_start+0x9d4>
4037c67e:	334a      	add.n	a3, a3, a4
4037c680:	d38c      	beqz.n	a3, 4037c691 <xPortEnterCriticalTimeout+0xe1>
4037c682:	e1d6d1        	l32r	a13, 40374ddc <_iram_text_start+0x9d8>
4037c685:	e1cec1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c688:	e1cfa1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c68b:	7da0b2        	movi	a11, 125
4037c68e:	ffd706        	j	4037c5ee <xPortEnterCriticalTimeout+0x3e>
        assert(lock->count < 0xFF); // Bad count value implies memory corruption
4037c691:	1228      	l32i.n	a2, a2, 4
4037c693:	fea032        	movi	a3, 254
4037c696:	0eb327        	bgeu	a3, a2, 4037c6a8 <xPortEnterCriticalTimeout+0xf8>
4037c699:	e1d1d1        	l32r	a13, 40374de0 <_iram_text_start+0x9dc>
4037c69c:	e1c9c1        	l32r	a12, 40374dc0 <_iram_text_start+0x9bc>
4037c69f:	e1c9a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c6a2:	7ea0b2        	movi	a11, 126
4037c6a5:	ffd146        	j	4037c5ee <xPortEnterCriticalTimeout+0x3e>
    XTOS_RESTORE_INTLEVEL(irq_status);
4037c6a8:	13e650        	wsr.ps	a5
4037c6ab:	002010        	rsync
    XTOS_RESTORE_JUST_INTLEVEL((int) prev_level);
4037c6ae:	01a8      	l32i.n	a10, a1, 0
     */
    BaseType_t xOldInterruptLevel = portSET_INTERRUPT_MASK_FROM_ISR();
    if (!spinlock_acquire(mux, timeout)) {
        //Timed out attempting to get spinlock. Restore previous interrupt level and return
        portCLEAR_INTERRUPT_MASK_FROM_ISR(xOldInterruptLevel);
        return pdFAIL;
4037c6b0:	020c      	movi.n	a2, 0
4037c6b2:	e15081        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037c6b5:	0008e0        	callx8	a8
4037c6b8:	000986        	j	4037c6e2 <xPortEnterCriticalTimeout+0x132>
    asm volatile (
4037c6bb:	03eb30        	rsr.prid	a3
4037c6be:	043d30        	extui	a3, a3, 13, 1
    }
    //Spinlock acquired. Increment the critical nesting count.
    BaseType_t coreID = xPortGetCoreID();
    BaseType_t newNesting = port_uxCriticalNesting[coreID] + 1;
4037c6c1:	e1c821        	l32r	a2, 40374de4 <_iram_text_start+0x9e0>
4037c6c4:	1143e0        	slli	a4, a3, 2
4037c6c7:	a03320        	addx4	a3, a3, a2
4037c6ca:	0328      	l32i.n	a2, a3, 0
4037c6cc:	221b      	addi.n	a2, a2, 1
    port_uxCriticalNesting[coreID] = newNesting;
4037c6ce:	0329      	s32i.n	a2, a3, 0
    //If this is the first entry to a critical section. Save the old interrupt level.
    if ( newNesting == 1 ) {
4037c6d0:	0c1266        	bnei	a2, 1, 4037c6e0 <xPortEnterCriticalTimeout+0x130>
        port_uxOldInterruptState[coreID] = xOldInterruptLevel;
4037c6d3:	e1c531        	l32r	a3, 40374de8 <_iram_text_start+0x9e4>
4037c6d6:	334a      	add.n	a3, a3, a4
4037c6d8:	0148      	l32i.n	a4, a1, 0
4037c6da:	0349      	s32i.n	a4, a3, 0
4037c6dc:	000086        	j	4037c6e2 <xPortEnterCriticalTimeout+0x132>
4037c6df:	00          	.byte 00
    }
    return pdPASS;
4037c6e0:	120c      	movi.n	a2, 1
}
4037c6e2:	f01d      	retw.n

4037c6e4 <vPortExitCritical>:

void __attribute__((optimize("-O3"))) vPortExitCritical(portMUX_TYPE *mux)
{
4037c6e4:	004136        	entry	a1, 32
{
#if !CONFIG_FREERTOS_UNICORE && !BOOTLOADER_BUILD
    uint32_t irq_status;
    uint32_t core_id;

    assert(lock);
4037c6e7:	d2cc      	bnez.n	a2, 4037c6f8 <vPortExitCritical+0x14>
4037c6e9:	e1b4d1        	l32r	a13, 40374dbc <_iram_text_start+0x9b8>
4037c6ec:	e1c0c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8>
4037c6ef:	e1b5a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c6f2:	9ca0b2        	movi	a11, 156
4037c6f5:	000586        	j	4037c70f <vPortExitCritical+0x2b>
    irq_status = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);
4037c6f8:	0063a0        	rsil	a10, 3
    asm volatile (
4037c6fb:	03eb90        	rsr.prid	a9

    core_id = xt_utils_get_raw_core_id();
    assert(core_id == lock->owner); // This is a lock that we didn't acquire, or the lock is corrupt
4037c6fe:	0288      	l32i.n	a8, a2, 0
4037c700:	0e1987        	beq	a9, a8, 4037c712 <vPortExitCritical+0x2e>
4037c703:	e1bbd1        	l32r	a13, 40374df0 <_iram_text_start+0x9ec>
4037c706:	e1b9c1        	l32r	a12, 40374dec <_iram_text_start+0x9e8>
4037c709:	e1aea1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c70c:	a0a0b2        	movi	a11, 160
4037c70f:	020fe5        	call8	4037e80c <__assert_func>
    lock->count--;
4037c712:	1288      	l32i.n	a8, a2, 4
4037c714:	880b      	addi.n	a8, a8, -1
4037c716:	1289      	s32i.n	a8, a2, 4

    if (!lock->count) { // If this is the last recursive release of the lock, mark the lock as free
4037c718:	98cc      	bnez.n	a8, 4037c725 <vPortExitCritical+0x41>
        lock->owner = SPINLOCK_FREE;
4037c71a:	e0f081        	l32r	a8, 40374adc <_iram_text_start+0x6d8>
4037c71d:	0289      	s32i.n	a8, a2, 0
4037c71f:	000646        	j	4037c73c <vPortExitCritical+0x58>
4037c722:	00          	.byte 00
4037c723:	00          	.byte 00
4037c724:	00          	.byte 00
    } else {
        assert(lock->count < 0x100); // Indicates memory corruption
4037c725:	ffa022        	movi	a2, 255
4037c728:	10b287        	bgeu	a2, a8, 4037c73c <vPortExitCritical+0x58>
4037c72b:	e1b2d1        	l32r	a13, 40374df4 <_iram_text_start+0x9f0>
4037c72e:	e1afc1        	l32r	a12, 40374dec <_iram_text_start+0x9e8>
4037c731:	e1a4a1        	l32r	a10, 40374dc4 <_iram_text_start+0x9c0>
4037c734:	a6a0b2        	movi	a11, 166
4037c737:	fff506        	j	4037c70f <vPortExitCritical+0x2b>
4037c73a:	00          	.byte 00
4037c73b:	00          	.byte 00
    }

    XTOS_RESTORE_INTLEVEL(irq_status);
4037c73c:	13e6a0        	wsr.ps	a10
4037c73f:	002010        	rsync
    asm volatile (
4037c742:	03eb20        	rsr.prid	a2
4037c745:	042d20        	extui	a2, a2, 13, 1
     * to reenable interrupts if this is the last call to exit the critical. We
     * can use the nesting count to determine whether this is the last exit call.
     */
    spinlock_release(mux);
    BaseType_t coreID = xPortGetCoreID();
    BaseType_t nesting = port_uxCriticalNesting[coreID];
4037c748:	e1a781        	l32r	a8, 40374de4 <_iram_text_start+0x9e0>
4037c74b:	1192e0        	slli	a9, a2, 2
4037c74e:	a02280        	addx4	a2, a2, a8
4037c751:	0288      	l32i.n	a8, a2, 0

    if (nesting > 0) {
4037c753:	1218a6        	blti	a8, 1, 4037c769 <vPortExitCritical+0x85>
        nesting--;
4037c756:	880b      	addi.n	a8, a8, -1
        port_uxCriticalNesting[coreID] = nesting;
4037c758:	0289      	s32i.n	a8, a2, 0
        //This is the last exit call, restore the saved interrupt level
        if ( nesting == 0 ) {
4037c75a:	b8cc      	bnez.n	a8, 4037c769 <vPortExitCritical+0x85>
            portCLEAR_INTERRUPT_MASK_FROM_ISR(port_uxOldInterruptState[coreID]);
4037c75c:	e1a321        	l32r	a2, 40374de8 <_iram_text_start+0x9e4>
4037c75f:	229a      	add.n	a2, a2, a9
4037c761:	02a8      	l32i.n	a10, a2, 0
4037c763:	e12481        	l32r	a8, 40374bf4 <_iram_text_start+0x7f0>
4037c766:	0008e0        	callx8	a8
        }
    }
}
4037c769:	f01d      	retw.n
	...

4037c76c <vPortYieldOtherCore>:
}

// ---------------------- Yielding -------------------------

void vPortYieldOtherCore( BaseType_t coreid )
{
4037c76c:	004136        	entry	a1, 32
    esp_crosscore_int_send_yield( coreid );
4037c76f:	02ad      	mov.n	a10, a2
4037c771:	fb8ce5        	call8	40378040 <esp_crosscore_int_send_yield>
}
4037c774:	f01d      	retw.n
	...

4037c778 <vApplicationStackOverflowHook>:

// ------------------- Hook Functions ----------------------

void  __attribute__((weak)) vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName )
{
4037c778:	010136        	entry	a1, 128
#define ERR_STR1 "***ERROR*** A stack overflow in task "
#define ERR_STR2 " has been detected."
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037c77b:	e19f21        	l32r	a2, 40374df8 <_iram_text_start+0x9f4>

    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037c77e:	0b0c      	movi.n	a11, 0
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037c780:	136122        	s32i	a2, a1, 76
4037c783:	e19e21        	l32r	a2, 40374dfc <_iram_text_start+0x9f8>
    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037c786:	7c4c      	movi.n	a12, 71
4037c788:	a14b      	addi.n	a10, a1, 4
    const char *str[] = {ERR_STR1, pcTaskName, ERR_STR2};
4037c78a:	146132        	s32i	a3, a1, 80
4037c78d:	156122        	s32i	a2, a1, 84
    char buf[sizeof(ERR_STR1) + CONFIG_FREERTOS_MAX_TASK_NAME_LEN + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037c790:	01b9      	s32i.n	a11, a1, 0
4037c792:	df3881        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037c795:	0008e0        	callx8	a8

    char *dest = buf;
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037c798:	4cc122        	addi	a2, a1, 76
4037c79b:	58c132        	addi	a3, a1, 88
    char *dest = buf;
4037c79e:	01ad      	mov.n	a10, a1
        dest = strcat(dest, str[i]);
4037c7a0:	0022b2        	l32i	a11, a2, 0
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037c7a3:	04c222        	addi	a2, a2, 4
        dest = strcat(dest, str[i]);
4037c7a6:	e19681        	l32r	a8, 40374e00 <_iram_text_start+0x9fc>
4037c7a9:	0008e0        	callx8	a8
    for (size_t i = 0 ; i < sizeof(str) / sizeof(str[0]); i++) {
4037c7ac:	f09237        	bne	a2, a3, 4037c7a0 <vApplicationStackOverflowHook+0x28>
    }
    esp_system_abort(buf);
4037c7af:	20a110        	or	a10, a1, a1
4037c7b2:	fd7365        	call8	40379ee8 <esp_system_abort>
4037c7b5:	000000        	ill

4037c7b8 <vPortReleaseTaskMPUSettings>:
     */
#endif
}

void vPortReleaseTaskMPUSettings( xMPU_SETTINGS *xMPUSettings )
{
4037c7b8:	004136        	entry	a1, 32
    /* If task has live floating point registers somewhere, release them */
    _xt_coproc_release( xMPUSettings->coproc_area );
4037c7bb:	02a8      	l32i.n	a10, a2, 0
4037c7bd:	fd9d25        	call8	4037a190 <_xt_coproc_release>
}
4037c7c0:	f01d      	retw.n
	...

4037c7c4 <vPortStoreTaskMPUSettings>:
{
4037c7c4:	004136        	entry	a1, 32
    xMPUSettings->coproc_area = ( StackType_t * ) ( ( uint32_t ) ( pxBottomOfStack + usStackDepth - 1 ));
4037c7c7:	550b      	addi.n	a5, a5, -1
    xMPUSettings->coproc_area = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) xMPUSettings->coproc_area ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
4037c7c9:	087c      	movi.n	a8, -16
    xMPUSettings->coproc_area = ( StackType_t * ) ( ( uint32_t ) ( pxBottomOfStack + usStackDepth - 1 ));
4037c7cb:	545a      	add.n	a5, a4, a5
    xMPUSettings->coproc_area = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) xMPUSettings->coproc_area ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
4037c7cd:	105580        	and	a5, a5, a8
    xMPUSettings->coproc_area = ( StackType_t * ) ( ( ( uint32_t ) xMPUSettings->coproc_area - XT_CP_SIZE ) & ~0xf );
4037c7d0:	c4ae92        	movi	a9, 0xfffffec4
4037c7d3:	559a      	add.n	a5, a5, a9
4037c7d5:	105580        	and	a5, a5, a8
4037c7d8:	0259      	s32i.n	a5, a2, 0
}
4037c7da:	f01d      	retw.n

4037c7dc <other_cpu_startup_idle_hook_cb>:
}

#if !CONFIG_FREERTOS_UNICORE
static volatile bool s_other_cpu_startup_done = false;
static bool other_cpu_startup_idle_hook_cb(void)
{
4037c7dc:	004136        	entry	a1, 32
    s_other_cpu_startup_done = true;
4037c7df:	e18981        	l32r	a8, 40374e04 <_iram_text_start+0xa00>
4037c7e2:	190c      	movi.n	a9, 1
4037c7e4:	0020c0        	memw
4037c7e7:	004892        	s8i	a9, a8, 0
    return true;
}
4037c7ea:	120c      	movi.n	a2, 1
4037c7ec:	f01d      	retw.n
	...

4037c7f0 <esp_startup_start_app_common>:
{
4037c7f0:	006136        	entry	a1, 48
    esp_int_wdt_init();
4037c7f3:	e18a81        	l32r	a8, 40374e1c <_iram_text_start+0xa18>
4037c7f6:	0008e0        	callx8	a8
    esp_int_wdt_cpu_init();
4037c7f9:	e18981        	l32r	a8, 40374e20 <_iram_text_start+0xa1c>
4037c7fc:	0008e0        	callx8	a8
    esp_crosscore_int_init();
4037c7ff:	e18981        	l32r	a8, 40374e24 <_iram_text_start+0xa20>
4037c802:	0008e0        	callx8	a8
    portBASE_TYPE res = xTaskCreatePinnedToCore(&main_task, "main",
4037c805:	00a0d2        	movi	a13, 0
4037c808:	01a0e2        	movi	a14, 1
4037c80b:	e17fb1        	l32r	a11, 40374e08 <_iram_text_start+0xa04>
4037c80e:	e17fa1        	l32r	a10, 40374e0c <_iram_text_start+0xa08>
4037c811:	01d9      	s32i.n	a13, a1, 0
4037c813:	0dfd      	mov.n	a15, a13
4037c815:	11ce40        	slli	a12, a14, 12
4037c818:	fea865        	call8	4037b2a0 <xTaskCreatePinnedToCore>
    assert(res == pdTRUE);
4037c81b:	0d1a26        	beqi	a10, 1, 4037c82c <esp_startup_start_app_common+0x3c>
4037c81e:	e17cd1        	l32r	a13, 40374e10 <_iram_text_start+0xa0c>
4037c821:	e17cc1        	l32r	a12, 40374e14 <_iram_text_start+0xa10>
4037c824:	e17da1        	l32r	a10, 40374e18 <_iram_text_start+0xa14>
4037c827:	bb4c      	movi.n	a11, 75
4037c829:	01fe25        	call8	4037e80c <__assert_func>
}
4037c82c:	f01d      	retw.n
	...

4037c830 <xPortCheckValidTCBMem>:
}

// -------------------- Heap Related -----------------------

bool xPortCheckValidTCBMem(const void *ptr)
{
4037c830:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037c833:	df7991        	l32r	a9, 40374618 <_iram_text_start+0x214>
4037c836:	e018b1        	l32r	a11, 40374898 <_iram_text_start+0x494>
4037c839:	929a      	add.n	a9, a2, a9
4037c83b:	02ad      	mov.n	a10, a2
4037c83d:	180c      	movi.n	a8, 1
4037c83f:	01bb97        	bgeu	a11, a9, 4037c844 <xPortCheckValidTCBMem+0x14>
4037c842:	080c      	movi.n	a8, 0
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037c844:	b97c      	movi.n	a9, -5
4037c846:	019940        	slli	a9, a9, 28
4037c849:	df57c1        	l32r	a12, 403745a8 <_iram_text_start+0x1a4>
4037c84c:	9a9a      	add.n	a9, a10, a9
4037c84e:	1b0c      	movi.n	a11, 1
4037c850:	01bc97        	bgeu	a12, a9, 4037c855 <xPortCheckValidTCBMem+0x25>
4037c853:	0b0c      	movi.n	a11, 0
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037c855:	2088b0        	or	a8, a8, a11
4037c858:	748080        	extui	a8, a8, 0, 8
4037c85b:	18dc      	bnez.n	a8, 4037c870 <xPortCheckValidTCBMem+0x40>
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037c85d:	df5191        	l32r	a9, 403745a4 <_iram_text_start+0x1a0>
4037c860:	df52b1        	l32r	a11, 403745a8 <_iram_text_start+0x1a4>
4037c863:	9a9a      	add.n	a9, a10, a9
4037c865:	07bb97        	bgeu	a11, a9, 4037c870 <xPortCheckValidTCBMem+0x40>
4037c868:	08ad      	mov.n	a10, a8
}
4037c86a:	0420a0        	extui	a2, a10, 0, 1
4037c86d:	f01d      	retw.n
4037c86f:	00          	.byte 00
    return esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr);
4037c870:	fbb125        	call8	40378384 <esp_ptr_byte_accessible>
4037c873:	fffcc6        	j	4037c86a <xPortCheckValidTCBMem+0x3a>
	...

4037c878 <xPortcheckValidStackMem>:
4037c878:	004136        	entry	a1, 32
4037c87b:	02ad      	mov.n	a10, a2
4037c87d:	fffb25        	call8	4037c830 <xPortCheckValidTCBMem>
4037c880:	0a2d      	mov.n	a2, a10
4037c882:	f01d      	retw.n

4037c884 <vApplicationGetIdleTaskMemory>:
memory MUST be placed in internal RAM.
*/
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize )
{
4037c884:	004136        	entry	a1, 32
        pxStackBufferTemp = pvPortMallocStackMem(configIDLE_TASK_STACK_SIZE);
    }
    #else /* portSTACK_GROWTH */
    {
        //Allocate TCB and stack buffer in internal memory
        pxStackBufferTemp = pvPortMallocStackMem(configIDLE_TASK_STACK_SIZE);
4037c887:	01a252        	movi	a5, 0x201
4037c88a:	1155e0        	slli	a5, a5, 2
4037c88d:	20b550        	or	a11, a5, a5
4037c890:	00a6a2        	movi	a10, 0x600
4037c893:	f94a65        	call8	40375d38 <heap_caps_malloc>
4037c896:	0a6d      	mov.n	a6, a10
        pxTCBBufferTemp = pvPortMallocTcbMem(sizeof(StaticTask_t));
4037c898:	05bd      	mov.n	a11, a5
4037c89a:	58a1a2        	movi	a10, 0x158
4037c89d:	f949a5        	call8	40375d38 <heap_caps_malloc>
    }
    #endif /* portSTACK_GROWTH */

    assert(pxTCBBufferTemp != NULL);
4037c8a0:	dacc      	bnez.n	a10, 4037c8b1 <vApplicationGetIdleTaskMemory+0x2d>
4037c8a2:	e161d1        	l32r	a13, 40374e28 <_iram_text_start+0xa24>
4037c8a5:	e161c1        	l32r	a12, 40374e2c <_iram_text_start+0xa28>
4037c8a8:	b8a0b2        	movi	a11, 184
    assert(pxStackBufferTemp != NULL);
4037c8ab:	e15ba1        	l32r	a10, 40374e18 <_iram_text_start+0xa14>
4037c8ae:	01f5e5        	call8	4037e80c <__assert_func>
4037c8b1:	b6cc      	bnez.n	a6, 4037c8c0 <vApplicationGetIdleTaskMemory+0x3c>
4037c8b3:	e15fd1        	l32r	a13, 40374e30 <_iram_text_start+0xa2c>
4037c8b6:	e15dc1        	l32r	a12, 40374e2c <_iram_text_start+0xa28>
4037c8b9:	b9a0b2        	movi	a11, 185
4037c8bc:	fffac6        	j	4037c8ab <vApplicationGetIdleTaskMemory+0x27>
4037c8bf:	00          	.byte 00
    //Write back pointers
    *ppxIdleTaskTCBBuffer = pxTCBBufferTemp;
4037c8c0:	02a9      	s32i.n	a10, a2, 0
    *ppxIdleTaskStackBuffer = pxStackBufferTemp;
4037c8c2:	0369      	s32i.n	a6, a3, 0
    *pulIdleTaskStackSize = configIDLE_TASK_STACK_SIZE;
4037c8c4:	00a652        	movi	a5, 0x600
4037c8c7:	0459      	s32i.n	a5, a4, 0
}
4037c8c9:	f01d      	retw.n
	...

4037c8cc <spi_flash_encryption_hal_enable>:
// This part is put in iram.

#include "hal/spi_flash_encrypted_ll.h"

void spi_flash_encryption_hal_enable(void)
{
4037c8cc:	004136        	entry	a1, 32
/**
 * Enable the flash encryption function under spi boot mode and download boot mode.
 */
static inline void spi_flash_encrypt_ll_enable(void)
{
    REG_SET_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037c8cf:	e15991        	l32r	a9, 40374e34 <_iram_text_start+0xa30>
4037c8d2:	9a0c      	movi.n	a10, 9
4037c8d4:	0020c0        	memw
4037c8d7:	0988      	l32i.n	a8, a9, 0
4037c8d9:	2088a0        	or	a8, a8, a10
4037c8dc:	0020c0        	memw
4037c8df:	0989      	s32i.n	a8, a9, 0
 */
static inline void spi_flash_encrypt_ll_type(flash_encrypt_ll_type_t type)
{
    // Our hardware only support flash encryption
    HAL_ASSERT(type == FLASH_ENCRYPTION_MANU);
    REG_WRITE(AES_XTS_DESTINATION_REG, type);
4037c8e1:	e15581        	l32r	a8, 40374e38 <_iram_text_start+0xa34>
4037c8e4:	090c      	movi.n	a9, 0
4037c8e6:	0020c0        	memw
4037c8e9:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_aes_accelerator_enable();
#endif //CONFIG_IDF_TARGET_ESP32S2
#if !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_type(FLASH_ENCRYPTION_MANU);
#endif // !CONFIG_IDF_TARGET_ESP32
}
4037c8eb:	f01d      	retw.n
4037c8ed:	000000        	ill

4037c8f0 <spi_flash_encryption_hal_disable>:

void spi_flash_encryption_hal_disable(void)
{
4037c8f0:	004136        	entry	a1, 32
    REG_CLR_BIT(SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG,
4037c8f3:	e15091        	l32r	a9, 40374e34 <_iram_text_start+0xa30>
4037c8f6:	ea7c      	movi.n	a10, -2
4037c8f8:	0020c0        	memw
4037c8fb:	0988      	l32i.n	a8, a9, 0
4037c8fd:	1088a0        	and	a8, a8, a10
4037c900:	0020c0        	memw
4037c903:	0989      	s32i.n	a8, a9, 0
    spi_flash_encrypt_ll_disable();
}
4037c905:	f01d      	retw.n
	...

4037c908 <spi_flash_encryption_hal_prepare>:

void spi_flash_encryption_hal_prepare(uint32_t address, const uint32_t* buffer, uint32_t size)
{
4037c908:	004136        	entry	a1, 32
 * @param block_size Size of the desired block.
 */
static inline void spi_flash_encrypt_ll_buffer_length(uint32_t size)
{
    // Desired block should not be larger than the block size.
    REG_WRITE(AES_XTS_SIZE_REG, size >> 5);
4037c90b:	e14c81        	l32r	a8, 40374e3c <_iram_text_start+0xa38>
4037c90e:	419540        	srli	a9, a4, 5
4037c911:	0020c0        	memw
4037c914:	0899      	s32i.n	a9, a8, 0
 *
 * @param flash_addr flash address to write.
 */
static inline void spi_flash_encrypt_ll_address_save(uint32_t flash_addr)
{
    REG_WRITE(AES_XTS_PHYSICAL_ADDR_REG, flash_addr);
4037c916:	e14a81        	l32r	a8, 40374e40 <_iram_text_start+0xa3c>
    memcpy((void *)(AES_XTS_PLAIN_BASE + plaintext_offs), buffer, size);
4037c919:	e14aa1        	l32r	a10, 40374e44 <_iram_text_start+0xa40>
    REG_WRITE(AES_XTS_PHYSICAL_ADDR_REG, flash_addr);
4037c91c:	0020c0        	memw
4037c91f:	0829      	s32i.n	a2, a8, 0
    uint32_t plaintext_offs = (address % 64);
4037c921:	542020        	extui	a2, a2, 0, 6
    memcpy((void *)(AES_XTS_PLAIN_BASE + plaintext_offs), buffer, size);
4037c924:	a2aa      	add.n	a10, a2, a10
4037c926:	04cd      	mov.n	a12, a4
4037c928:	03bd      	mov.n	a11, a3
4037c92a:	dee181        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037c92d:	0008e0        	callx8	a8
/**
 * Start flash encryption
 */
static inline void spi_flash_encrypt_ll_calculate_start(void)
{
    REG_WRITE(AES_XTS_TRIGGER_REG, 1);
4037c930:	e14621        	l32r	a2, 40374e48 <_iram_text_start+0xa44>
4037c933:	180c      	movi.n	a8, 1
4037c935:	0020c0        	memw
4037c938:	0289      	s32i.n	a8, a2, 0
    spi_flash_encrypt_ll_buffer_length(size);
#endif // !CONFIG_IDF_TARGET_ESP32
    spi_flash_encrypt_ll_address_save(address);
    spi_flash_encrypt_ll_plaintext_save(address, buffer, size);
    spi_flash_encrypt_ll_calculate_start();
}
4037c93a:	f01d      	retw.n

4037c93c <spi_flash_encryption_hal_done>:

void spi_flash_encryption_hal_done(void)
{
4037c93c:	004136        	entry	a1, 32
/**
 * Wait for flash encryption termination
 */
static inline void spi_flash_encrypt_ll_calculate_wait_idle(void)
{
    while(REG_READ(AES_XTS_STATE_REG) == 0x1) {
4037c93f:	e14381        	l32r	a8, 40374e4c <_iram_text_start+0xa48>
4037c942:	0020c0        	memw
4037c945:	0898      	l32i.n	a9, a8, 0
4037c947:	f71926        	beqi	a9, 1, 4037c942 <spi_flash_encryption_hal_done+0x6>
/**
 * Finish the flash encryption and make encrypted result accessible to SPI.
 */
static inline void spi_flash_encrypt_ll_done(void)
{
    REG_WRITE(AES_XTS_RELEASE_REG, 1);
4037c94a:	e14191        	l32r	a9, 40374e50 <_iram_text_start+0xa4c>
4037c94d:	1a0c      	movi.n	a10, 1
4037c94f:	0020c0        	memw
4037c952:	09a9      	s32i.n	a10, a9, 0
    while(REG_READ(AES_XTS_STATE_REG) != 0x3) {
4037c954:	0020c0        	memw
4037c957:	0898      	l32i.n	a9, a8, 0
4037c959:	f73966        	bnei	a9, 3, 4037c954 <spi_flash_encryption_hal_done+0x18>
    spi_flash_encrypt_ll_calculate_wait_idle();
    spi_flash_encrypt_ll_done();
}
4037c95c:	f01d      	retw.n
	...

4037c960 <spi_flash_encryption_hal_destroy>:

void spi_flash_encryption_hal_destroy(void)
{
4037c960:	004136        	entry	a1, 32
/**
 * Set to destroy encrypted result
 */
static inline void spi_flash_encrypt_ll_destroy(void)
{
    REG_WRITE(AES_XTS_DESTROY_REG, 1);
4037c963:	e13c81        	l32r	a8, 40374e54 <_iram_text_start+0xa50>
4037c966:	190c      	movi.n	a9, 1
4037c968:	0020c0        	memw
4037c96b:	0899      	s32i.n	a9, a8, 0
    spi_flash_encrypt_ll_destroy();
}
4037c96d:	f01d      	retw.n
	...

4037c970 <spi_flash_encryption_hal_check>:

bool spi_flash_encryption_hal_check(uint32_t address, uint32_t length)
{
4037c970:	004136        	entry	a1, 32
 * @param address the address of written flash partition.
 * @param length Buffer size.
 */
static inline bool spi_flash_encrypt_ll_check(uint32_t address, uint32_t length)
{
    return ((address % length) == 0) ? true : false;
4037c973:	e23230        	remu	a3, a2, a3
4037c976:	080c      	movi.n	a8, 0
4037c978:	120c      	movi.n	a2, 1
4037c97a:	932830        	movnez	a2, a8, a3
    return spi_flash_encrypt_ll_check(address, length);
}
4037c97d:	f01d      	retw.n
	...

4037c980 <gpspi_flash_ll_get_buffer_data>:
 * @param dev Beginning address of the peripheral registers.
 * @param buffer Buffer to hold the output data
 * @param read_len Length to get out of the buffer
 */
static inline void gpspi_flash_ll_get_buffer_data(spi_dev_t *dev, void *buffer, uint32_t read_len)
{
4037c980:	008136        	entry	a1, 64
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037c983:	205340        	or	a5, a3, a4
4037c986:	145050        	extui	a5, a5, 0, 2
4037c989:	f5cc      	bnez.n	a5, 4037c99c <gpspi_flash_ll_get_buffer_data+0x1c>
        // If everything is word-aligned, do a faster memcpy
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037c98b:	98a0b2        	movi	a11, 152
4037c98e:	04cd      	mov.n	a12, a4
4037c990:	b2ba      	add.n	a11, a2, a11
4037c992:	03ad      	mov.n	a10, a3
4037c994:	dec781        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037c997:	0008e0        	callx8	a8
            memcpy(buffer, &word, word_len);
            buffer = (void *)((intptr_t)buffer + word_len);
            copy_len -= word_len;
        }
    }
}
4037c99a:	f01d      	retw.n
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037c99c:	643b      	addi.n	a6, a4, 3
4037c99e:	416260        	srli	a6, a6, 2
4037c9a1:	050c      	movi.n	a5, 0
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037c9a3:	490c      	movi.n	a9, 4
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037c9a5:	f11657        	beq	a6, a5, 4037c99a <gpspi_flash_ll_get_buffer_data+0x1a>
            uint32_t word = dev->data_buf[i];
4037c9a8:	24c582        	addi	a8, a5, 36
4037c9ab:	a08820        	addx4	a8, a8, a2
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037c9ae:	637490        	minu	a7, a4, a9
            uint32_t word = dev->data_buf[i];
4037c9b1:	0020c0        	memw
4037c9b4:	2888      	l32i.n	a8, a8, 8
            memcpy(buffer, &word, word_len);
4037c9b6:	03ad      	mov.n	a10, a3
4037c9b8:	07cd      	mov.n	a12, a7
4037c9ba:	01bd      	mov.n	a11, a1
4037c9bc:	4199      	s32i.n	a9, a1, 16
            uint32_t word = dev->data_buf[i];
4037c9be:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037c9c0:	debc81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037c9c3:	0008e0        	callx8	a8
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037c9c6:	4198      	l32i.n	a9, a1, 16
            buffer = (void *)((intptr_t)buffer + word_len);
4037c9c8:	337a      	add.n	a3, a3, a7
            copy_len -= word_len;
4037c9ca:	c04470        	sub	a4, a4, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037c9cd:	551b      	addi.n	a5, a5, 1
4037c9cf:	fff486        	j	4037c9a5 <gpspi_flash_ll_get_buffer_data+0x25>
	...

4037c9d4 <spi_flash_hal_gpspi_device_config>:
        //nop
    }
}

esp_err_t spi_flash_hal_device_config(spi_flash_host_inst_t *host)
{
4037c9d4:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037c9d7:	1288      	l32i.n	a8, a2, 4
    dev->user.val = 0;
4037c9d9:	0a0c      	movi.n	a10, 0
4037c9db:	0020c0        	memw
4037c9de:	48a9      	s32i.n	a10, a8, 16
    dev->ctrl.val = 0;
4037c9e0:	0020c0        	memw
4037c9e3:	28a9      	s32i.n	a10, a8, 8
    dev->clk_gate.clk_en = 1;
4037c9e5:	0020c0        	memw
4037c9e8:	3a28b2        	l32i	a11, a8, 232
4037c9eb:	190c      	movi.n	a9, 1
4037c9ed:	20bb90        	or	a11, a11, a9
4037c9f0:	0020c0        	memw
4037c9f3:	3a68b2        	s32i	a11, a8, 232
    dev->clk_gate.mst_clk_active = 1;
4037c9f6:	0020c0        	memw
4037c9f9:	3a28b2        	l32i	a11, a8, 232
4037c9fc:	2c0c      	movi.n	a12, 2
4037c9fe:	20bbc0        	or	a11, a11, a12
4037ca01:	0020c0        	memw
4037ca04:	3a68b2        	s32i	a11, a8, 232
    dev->clk_gate.mst_clk_sel = 1;
4037ca07:	0020c0        	memw
4037ca0a:	3a28b2        	l32i	a11, a8, 232
4037ca0d:	4c0c      	movi.n	a12, 4
4037ca0f:	20bbc0        	or	a11, a11, a12
4037ca12:	0020c0        	memw
4037ca15:	3a68b2        	s32i	a11, a8, 232
    dev->dma_conf.val = 0;
4037ca18:	0020c0        	memw
4037ca1b:	c8a9      	s32i.n	a10, a8, 48
    dev->dma_conf.tx_seg_trans_clr_en = 1;
4037ca1d:	0020c0        	memw
4037ca20:	c8b8      	l32i.n	a11, a8, 48
4037ca22:	01c9c0        	slli	a12, a9, 20
4037ca25:	20bbc0        	or	a11, a11, a12
4037ca28:	0020c0        	memw
4037ca2b:	c8b9      	s32i.n	a11, a8, 48
    dev->dma_conf.rx_seg_trans_clr_en = 1;
4037ca2d:	0020c0        	memw
4037ca30:	c8b8      	l32i.n	a11, a8, 48
4037ca32:	01d9d0        	slli	a13, a9, 19
4037ca35:	20bbd0        	or	a11, a11, a13
4037ca38:	0020c0        	memw
4037ca3b:	c8b9      	s32i.n	a11, a8, 48
    dev->dma_conf.dma_seg_trans_en = 0;
4037ca3d:	0020c0        	memw
4037ca40:	c8b8      	l32i.n	a11, a8, 48
4037ca42:	e105d1        	l32r	a13, 40374e58 <_iram_text_start+0xa54>
 * @param dev Beginning address of the peripheral registers.
 * @param pin Pin ID to use, 0-2. Set to other values to disable all the CS pins.
 */
static inline void gpspi_flash_ll_set_cs_pin(spi_dev_t *dev, int pin)
{
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037ca45:	0aed      	mov.n	a14, a10
    dev->dma_conf.dma_seg_trans_en = 0;
4037ca47:	10bbd0        	and	a11, a11, a13
4037ca4a:	0020c0        	memw
4037ca4d:	c8b9      	s32i.n	a11, a8, 48
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037ca4f:	0020c0        	memw
4037ca52:	88b8      	l32i.n	a11, a8, 32
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    spi_dev_t *dev = get_spi_dev(host);

    spi_flash_ll_reset(dev);
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037ca54:	22d8      	l32i.n	a13, a2, 8
4037ca56:	ef7c      	movi.n	a15, -2
4037ca58:	93e9d0        	movnez	a14, a9, a13
4037ca5b:	10bbf0        	and	a11, a11, a15
4037ca5e:	20bbe0        	or	a11, a11, a14
4037ca61:	0020c0        	memw
4037ca64:	88b9      	s32i.n	a11, a8, 32
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037ca66:	dd0b      	addi.n	a13, a13, -1
4037ca68:	0aed      	mov.n	a14, a10
4037ca6a:	0020c0        	memw
4037ca6d:	88b8      	l32i.n	a11, a8, 32
4037ca6f:	93e9d0        	movnez	a14, a9, a13
4037ca72:	deea      	add.n	a13, a14, a14
4037ca74:	de7c      	movi.n	a14, -3
4037ca76:	10bbe0        	and	a11, a11, a14
4037ca79:	20bbd0        	or	a11, a11, a13
4037ca7c:	0020c0        	memw
4037ca7f:	88b9      	s32i.n	a11, a8, 32
 * @param dev Beginning address of the peripheral registers.
 * @param clock_val pointer to the clock value to set
 */
static inline void gpspi_flash_ll_set_clock(spi_dev_t *dev, gpspi_flash_ll_clock_reg_t *clock_val)
{
    dev->clock.val = *clock_val;
4037ca81:	0020c0        	memw
4037ca84:	42b8      	l32i.n	a11, a2, 16
 * @param dev Beginning address of the peripheral registers.
 * @param hold_n Cycles of clocks before CS is inactive
 */
static inline void gpspi_flash_ll_set_hold(spi_dev_t *dev, uint32_t hold_n)
{
    dev->user1.cs_hold_time = hold_n - 1;
4037ca86:	e0f5f1        	l32r	a15, 40374e5c <_iram_text_start+0xa58>
    dev->clock.val = *clock_val;
4037ca89:	0020c0        	memw
4037ca8c:	38b9      	s32i.n	a11, a8, 12
    spi_flash_ll_set_clock(dev, &ctx->clock_conf);
    int cs_hold = ctx->cs_hold;
4037ca8e:	0e02e2        	l8ui	a14, a2, 14
    dev->user1.cs_hold_time = hold_n - 1;
4037ca91:	0020c0        	memw
4037ca94:	58b8      	l32i.n	a11, a8, 20
4037ca96:	de0b      	addi.n	a13, a14, -1
4037ca98:	44d0d0        	extui	a13, a13, 0, 5
4037ca9b:	01dda0        	slli	a13, a13, 22
4037ca9e:	10bbf0        	and	a11, a11, a15
4037caa1:	20bbd0        	or	a11, a11, a13
4037caa4:	0020c0        	memw
4037caa7:	58b9      	s32i.n	a11, a8, 20
    dev->user.cs_hold = (hold_n > 0? 1: 0);
4037caa9:	0020c0        	memw
4037caac:	48b8      	l32i.n	a11, a8, 16
4037caae:	0add      	mov.n	a13, a10
4037cab0:	93d9e0        	movnez	a13, a9, a14
4037cab3:	bfafe2        	movi	a14, -65
4037cab6:	11dda0        	slli	a13, a13, 6
4037cab9:	10bbe0        	and	a11, a11, a14
4037cabc:	20bbd0        	or	a11, a11, a13
4037cabf:	0020c0        	memw
4037cac2:	48b9      	s32i.n	a11, a8, 16
    spi_flash_ll_set_hold(dev, cs_hold);
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037cac4:	0d02b2        	l8ui	a11, a2, 13
}

static inline void gpspi_flash_ll_set_cs_setup(spi_dev_t *dev, uint32_t cs_setup_time)
{
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037cac7:	0020c0        	memw
4037caca:	48d8      	l32i.n	a13, a8, 16
4037cacc:	839ab0        	moveqz	a9, a10, a11
4037cacf:	7faf22        	movi	a2, -129
4037cad2:	10dd20        	and	a13, a13, a2
4037cad5:	119990        	slli	a9, a9, 7
4037cad8:	209d90        	or	a9, a13, a9
4037cadb:	0020c0        	memw
4037cade:	4899      	s32i.n	a9, a8, 16
    dev->user1.cs_setup_time = cs_setup_time - 1;
4037cae0:	bb0b      	addi.n	a11, a11, -1
4037cae2:	0020c0        	memw
4037cae5:	5898      	l32i.n	a9, a8, 20
4037cae7:	e0de21        	l32r	a2, 40374e60 <_iram_text_start+0xa5c>
4037caea:	44b0b0        	extui	a11, a11, 0, 5
4037caed:	01bbf0        	slli	a11, a11, 17
4037caf0:	109920        	and	a9, a9, a2
4037caf3:	2099b0        	or	a9, a9, a11
4037caf6:	0020c0        	memw
4037caf9:	5899      	s32i.n	a9, a8, 20
    dev->ctrl.hold_pol = pol_val;
4037cafb:	0020c0        	memw
4037cafe:	2828      	l32i.n	a2, a8, 8
4037cb00:	2022c0        	or	a2, a2, a12
4037cb03:	0020c0        	memw
4037cb06:	2829      	s32i.n	a2, a8, 8
#else
    gpspi_flash_ll_set_hold_pol(dev, 1);
#endif //GPSPI_BUILD

    return ESP_OK;
}
4037cb08:	0a2d      	mov.n	a2, a10
4037cb0a:	f01d      	retw.n

4037cb0c <spi_flash_hal_gpspi_configure_host_io_mode>:
    spi_flash_host_inst_t *host,
    uint32_t command,
    uint32_t addr_bitlen,
    int dummy_cyclelen_base,
    esp_flash_io_mode_t io_mode)
{
4037cb0c:	008136        	entry	a1, 64
    return ((spi_flash_hal_context_t*)host)->spi;
4037cb0f:	1288      	l32i.n	a8, a2, 4
    spi_dev_t *dev = get_spi_dev(host);
    int host_id = spi_flash_ll_hw_get_id(dev);

    uint32_t extra_bits = io_mode & 0xFFFF0000;
4037cb11:	fa7c      	movi.n	a10, -1
4037cb13:	11aa00        	slli	a10, a10, 16
    dev->ctrl.dummy_out = out_en;
4037cb16:	0020c0        	memw
4037cb19:	2898      	l32i.n	a9, a8, 8
4037cb1b:	10c6a0        	and	a12, a6, a10
4037cb1e:	05cfc0        	extui	a12, a12, 31, 1
4037cb21:	7d7c      	movi.n	a13, -9
4037cb23:	11ccd0        	slli	a12, a12, 3
4037cb26:	1099d0        	and	a9, a9, a13
4037cb29:	2099c0        	or	a9, a9, a12
4037cb2c:	0020c0        	memw
4037cb2f:	2899      	s32i.n	a9, a8, 8
    dev->ctrl.q_pol = out_lev;
4037cb31:	0020c0        	memw
4037cb34:	2898      	l32i.n	a9, a8, 8
4037cb36:	1c0c      	movi.n	a12, 1
4037cb38:	01cce0        	slli	a12, a12, 18
4037cb3b:	2099c0        	or	a9, a9, a12
4037cb3e:	0020c0        	memw
4037cb41:	2899      	s32i.n	a9, a8, 8
    dev->ctrl.d_pol = out_lev;
4037cb43:	0020c0        	memw
4037cb46:	2898      	l32i.n	a9, a8, 8
4037cb48:	1c0c      	movi.n	a12, 1
4037cb4a:	01ccd0        	slli	a12, a12, 19
4037cb4d:	2099c0        	or	a9, a9, a12
4037cb50:	0020c0        	memw
4037cb53:	2899      	s32i.n	a9, a8, 8
        dummy_cyclelen_base -= 4 / line_width;
        addr_bitlen += 4;   //extra 4 bits indicate the conf bits is included
    }
#endif

    if (command >= 0x100) {
4037cb55:	ffa0c2        	movi	a12, 255
4037cb58:	f97c      	movi.n	a9, -1
    io_mode = io_mode & 0xFFFF;
4037cb5a:	f4b060        	extui	a11, a6, 0, 16
    if (command >= 0x100) {
4037cb5d:	019910        	slli	a9, a9, 31
4037cb60:	023c37        	bltu	a12, a3, 4037cb66 <spi_flash_hal_gpspi_configure_host_io_mode+0x5a>
4037cb63:	004d46        	j	4037cc9c <spi_flash_hal_gpspi_configure_host_io_mode+0x190>
    dev->user.usr_command = 1;
4037cb66:	0020c0        	memw
4037cb69:	48c8      	l32i.n	a12, a8, 16
    typeof(dev->user2) user2 = {
4037cb6b:	743030        	extui	a3, a3, 0, 8
    dev->user.usr_command = 1;
4037cb6e:	209c90        	or	a9, a12, a9
4037cb71:	0020c0        	memw
4037cb74:	4899      	s32i.n	a9, a8, 16
    typeof(dev->user2) user2 = {
4037cb76:	090c      	movi.n	a9, 0
4037cb78:	0020c0        	memw
4037cb7b:	4199      	s32i.n	a9, a1, 16
4037cb7d:	0020c0        	memw
4037cb80:	4198      	l32i.n	a9, a1, 16
4037cb82:	1099a0        	and	a9, a9, a10
4037cb85:	209930        	or	a9, a9, a3
4037cb88:	0020c0        	memw
4037cb8b:	4199      	s32i.n	a9, a1, 16
4037cb8d:	0020c0        	memw
4037cb90:	4138      	l32i.n	a3, a1, 16
4037cb92:	f97c      	movi.n	a9, -1
4037cb94:	019940        	slli	a9, a9, 28
4037cb97:	203390        	or	a3, a3, a9
4037cb9a:	0020c0        	memw
4037cb9d:	4139      	s32i.n	a3, a1, 16
    dev->user2 = user2;
4037cb9f:	0020c0        	memw
4037cba2:	4138      	l32i.n	a3, a1, 16
4037cba4:	0020c0        	memw
4037cba7:	6839      	s32i.n	a3, a8, 24
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037cba9:	0020c0        	memw
4037cbac:	5838      	l32i.n	a3, a8, 20
4037cbae:	e0ada1        	l32r	a10, 40374e64 <_iram_text_start+0xa60>
4037cbb1:	940b      	addi.n	a9, a4, -1
4037cbb3:	019950        	slli	a9, a9, 27
4037cbb6:	1033a0        	and	a3, a3, a10
4037cbb9:	203390        	or	a3, a3, a9
4037cbbc:	0020c0        	memw
4037cbbf:	5839      	s32i.n	a3, a8, 20
    dev->user.usr_addr = bitlen ? 1 : 0;
4037cbc1:	030c      	movi.n	a3, 0
4037cbc3:	190c      	movi.n	a9, 1
4037cbc5:	03cd      	mov.n	a12, a3
4037cbc7:	0020c0        	memw
4037cbca:	48a8      	l32i.n	a10, a8, 16
4037cbcc:	93c940        	movnez	a12, a9, a4
4037cbcf:	df0841        	l32r	a4, 403747f0 <_iram_text_start+0x3ec>
4037cbd2:	01cc20        	slli	a12, a12, 30
4037cbd5:	10aa40        	and	a10, a10, a4
4037cbd8:	20aac0        	or	a10, a10, a12
4037cbdb:	0020c0        	memw
4037cbde:	48a9      	s32i.n	a10, a8, 16
    } else {
        spi_flash_ll_set_command(dev, command, 8);
    }
    spi_flash_ll_set_addr_bitlen(dev, addr_bitlen);
    // Add dummy cycles to compensate for latency of GPIO matrix and external delay, if necessary...
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037cbe0:	0c02a2        	l8ui	a10, a2, 12
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037cbe3:	df0521        	l32r	a2, 403747f8 <_iram_text_start+0x3f4>
4037cbe6:	5a5a      	add.n	a5, a10, a5
4037cbe8:	0020c0        	memw
4037cbeb:	48a8      	l32i.n	a10, a8, 16
4037cbed:	933950        	movnez	a3, a9, a5
4037cbf0:	10aa20        	and	a10, a10, a2
4037cbf3:	013330        	slli	a3, a3, 29
4037cbf6:	203a30        	or	a3, a10, a3
4037cbf9:	0020c0        	memw
4037cbfc:	4839      	s32i.n	a3, a8, 16
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037cbfe:	0020c0        	memw
4037cc01:	5828      	l32i.n	a2, a8, 20
4037cc03:	550b      	addi.n	a5, a5, -1
4037cc05:	0020c0        	memw
4037cc08:	0129      	s32i.n	a2, a1, 0
4037cc0a:	0020c0        	memw
4037cc0d:	0138      	l32i.n	a3, a1, 0
4037cc0f:	00af22        	movi	a2, 0xffffff00
4037cc12:	103320        	and	a3, a3, a2
4037cc15:	745050        	extui	a5, a5, 0, 8
4037cc18:	203350        	or	a3, a3, a5
4037cc1b:	0020c0        	memw
4037cc1e:	0139      	s32i.n	a3, a1, 0
4037cc20:	0020c0        	memw
4037cc23:	0128      	l32i.n	a2, a1, 0
    dev->user.usr_miso = bitlen > 0;
4037cc25:	def631        	l32r	a3, 40374800 <_iram_text_start+0x3fc>
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037cc28:	0020c0        	memw
4037cc2b:	5829      	s32i.n	a2, a8, 20
    dev->user.usr_miso = bitlen > 0;
4037cc2d:	0020c0        	memw
4037cc30:	4828      	l32i.n	a2, a8, 16
4037cc32:	102230        	and	a2, a2, a3
4037cc35:	0020c0        	memw
4037cc38:	4829      	s32i.n	a2, a8, 16
    dev->user.usr_mosi = bitlen > 0;
4037cc3a:	0020c0        	memw
4037cc3d:	4828      	l32i.n	a2, a8, 16
4037cc3f:	deef31        	l32r	a3, 403747fc <_iram_text_start+0x3f8>
4037cc42:	102230        	and	a2, a2, a3
4037cc45:	0020c0        	memw
4037cc48:	4829      	s32i.n	a2, a8, 16
    typeof (dev->ctrl) ctrl = dev->ctrl;
4037cc4a:	0020c0        	memw
4037cc4d:	2828      	l32i.n	a2, a8, 8
    ctrl.val &= ~(SPI_FCMD_QUAD_M | SPI_FADDR_QUAD_M | SPI_FREAD_QUAD_M | SPI_FCMD_DUAL_M | SPI_FADDR_DUAL_M | SPI_FREAD_DUAL_M);
4037cc4f:	e08631        	l32r	a3, 40374e68 <_iram_text_start+0xa64>
    typeof (dev->ctrl) ctrl = dev->ctrl;
4037cc52:	0020c0        	memw
4037cc55:	2129      	s32i.n	a2, a1, 8
    typeof (dev->user) user = dev->user;
4037cc57:	0020c0        	memw
4037cc5a:	4828      	l32i.n	a2, a8, 16
4037cc5c:	0020c0        	memw
4037cc5f:	1129      	s32i.n	a2, a1, 4
    ctrl.val &= ~(SPI_FCMD_QUAD_M | SPI_FADDR_QUAD_M | SPI_FREAD_QUAD_M | SPI_FCMD_DUAL_M | SPI_FADDR_DUAL_M | SPI_FREAD_DUAL_M);
4037cc61:	0020c0        	memw
4037cc64:	2128      	l32i.n	a2, a1, 8
4037cc66:	102230        	and	a2, a2, a3
4037cc69:	0020c0        	memw
4037cc6c:	2129      	s32i.n	a2, a1, 8
    user.val &= ~(SPI_FWRITE_QUAD_M | SPI_FWRITE_DUAL_M);
4037cc6e:	0020c0        	memw
4037cc71:	1128      	l32i.n	a2, a1, 4
4037cc73:	e07e31        	l32r	a3, 40374e6c <_iram_text_start+0xa68>
4037cc76:	102230        	and	a2, a2, a3
4037cc79:	0020c0        	memw
4037cc7c:	1129      	s32i.n	a2, a1, 4
    switch (read_mode) {
4037cc7e:	023b66        	bnei	a11, 3, 4037cc84 <spi_flash_hal_gpspi_configure_host_io_mode+0x178>
4037cc81:	002e06        	j	4037cd3d <spi_flash_hal_gpspi_configure_host_io_mode+0x231>
4037cc84:	e07b21        	l32r	a2, 40374e70 <_iram_text_start+0xa6c>
4037cc87:	5d8627        	bany	a6, a2, 4037cce8 <spi_flash_hal_gpspi_configure_host_io_mode+0x1dc>
4037cc8a:	e07a21        	l32r	a2, 40374e74 <_iram_text_start+0xa70>
4037cc8d:	028627        	bany	a6, a2, 4037cc93 <spi_flash_hal_gpspi_configure_host_io_mode+0x187>
4037cc90:	002246        	j	4037cd1d <spi_flash_hal_gpspi_configure_host_io_mode+0x211>
4037cc93:	022b66        	bnei	a11, 2, 4037cc99 <spi_flash_hal_gpspi_configure_host_io_mode+0x18d>
4037cc96:	003386        	j	4037cd68 <spi_flash_hal_gpspi_configure_host_io_mode+0x25c>
        abort();
4037cc99:	01ae25        	call8	4037e77c <abort>
    dev->user.usr_command = 1;
4037cc9c:	0020c0        	memw
4037cc9f:	0428c2        	l32i	a12, a8, 16
    typeof(dev->user2) user2 = {
4037cca2:	f43030        	extui	a3, a3, 0, 16
    dev->user.usr_command = 1;
4037cca5:	209c90        	or	a9, a12, a9
4037cca8:	0020c0        	memw
4037ccab:	046892        	s32i	a9, a8, 16
    typeof(dev->user2) user2 = {
4037ccae:	00a092        	movi	a9, 0
4037ccb1:	0020c0        	memw
4037ccb4:	3199      	s32i.n	a9, a1, 12
4037ccb6:	0020c0        	memw
4037ccb9:	3198      	l32i.n	a9, a1, 12
4037ccbb:	1099a0        	and	a9, a9, a10
4037ccbe:	209930        	or	a9, a9, a3
4037ccc1:	0020c0        	memw
4037ccc4:	3199      	s32i.n	a9, a1, 12
4037ccc6:	0020c0        	memw
4037ccc9:	3138      	l32i.n	a3, a1, 12
4037cccb:	dec891        	l32r	a9, 403747ec <_iram_text_start+0x3e8>
4037ccce:	103390        	and	a3, a3, a9
4037ccd1:	790c      	movi.n	a9, 7
4037ccd3:	019940        	slli	a9, a9, 28
4037ccd6:	203390        	or	a3, a3, a9
4037ccd9:	0020c0        	memw
4037ccdc:	3139      	s32i.n	a3, a1, 12
    dev->user2 = user2;
4037ccde:	0020c0        	memw
4037cce1:	3138      	l32i.n	a3, a1, 12
4037cce3:	ffaf46        	j	4037cba4 <spi_flash_hal_gpspi_configure_host_io_mode+0x98>
4037cce6:	00          	.byte 00
4037cce7:	00          	.byte 00
4037cce8:	113910        	slli	a3, a9, 15
    switch (read_mode) {
4037cceb:	464b26        	beqi	a11, 4, 4037cd35 <spi_flash_hal_gpspi_configure_host_io_mode+0x229>
4037ccee:	a75b66        	bnei	a11, 5, 4037cc99 <spi_flash_hal_gpspi_configure_host_io_mode+0x18d>
        ctrl.fread_quad = 1;
4037ccf1:	0020c0        	memw
4037ccf4:	2128      	l32i.n	a2, a1, 8
4037ccf6:	202230        	or	a2, a2, a3
4037ccf9:	0020c0        	memw
4037ccfc:	2129      	s32i.n	a2, a1, 8
        ctrl.faddr_quad = 1;
4037ccfe:	0020c0        	memw
4037cd01:	2128      	l32i.n	a2, a1, 8
4037cd03:	034c      	movi.n	a3, 64
        ctrl.fread_quad = 1;
4037cd05:	202230        	or	a2, a2, a3
4037cd08:	0020c0        	memw
4037cd0b:	2129      	s32i.n	a2, a1, 8
        user.fwrite_quad = 1;
4037cd0d:	0020c0        	memw
4037cd10:	1128      	l32i.n	a2, a1, 4
4037cd12:	119930        	slli	a9, a9, 13
        user.fwrite_dual = 1;
4037cd15:	209290        	or	a9, a2, a9
4037cd18:	0020c0        	memw
4037cd1b:	1199      	s32i.n	a9, a1, 4
    dev->ctrl = ctrl;
4037cd1d:	0020c0        	memw
4037cd20:	2128      	l32i.n	a2, a1, 8
4037cd22:	0020c0        	memw
4037cd25:	2829      	s32i.n	a2, a8, 8
    dev->user = user;
4037cd27:	0020c0        	memw
4037cd2a:	1128      	l32i.n	a2, a1, 4
4037cd2c:	0020c0        	memw
4037cd2f:	4829      	s32i.n	a2, a8, 16
    //disable all data phases, enable them later if needed
    spi_flash_ll_set_miso_bitlen(dev, 0);
    spi_flash_ll_set_mosi_bitlen(dev, 0);
    spi_flash_ll_set_read_mode(dev, io_mode);
    return ESP_OK;
}
4037cd31:	020c      	movi.n	a2, 0
4037cd33:	f01d      	retw.n
        ctrl.fread_quad = 1;
4037cd35:	0020c0        	memw
4037cd38:	2128      	l32i.n	a2, a1, 8
4037cd3a:	fff1c6        	j	4037cd05 <spi_flash_hal_gpspi_configure_host_io_mode+0x1f9>
        ctrl.fread_dual = 1;
4037cd3d:	0020c0        	memw
4037cd40:	2128      	l32i.n	a2, a1, 8
4037cd42:	113920        	slli	a3, a9, 14
4037cd45:	202230        	or	a2, a2, a3
4037cd48:	0020c0        	memw
4037cd4b:	2129      	s32i.n	a2, a1, 8
        ctrl.faddr_dual = 1;
4037cd4d:	0020c0        	memw
4037cd50:	2128      	l32i.n	a2, a1, 8
4037cd52:	032c      	movi.n	a3, 32
4037cd54:	202230        	or	a2, a2, a3
4037cd57:	0020c0        	memw
4037cd5a:	2129      	s32i.n	a2, a1, 8
        user.fwrite_dual = 1;
4037cd5c:	0020c0        	memw
4037cd5f:	1128      	l32i.n	a2, a1, 4
4037cd61:	119940        	slli	a9, a9, 12
4037cd64:	ffeb46        	j	4037cd15 <spi_flash_hal_gpspi_configure_host_io_mode+0x209>
4037cd67:	00          	.byte 00
        ctrl.fread_dual = 1;
4037cd68:	0020c0        	memw
4037cd6b:	2128      	l32i.n	a2, a1, 8
4037cd6d:	113920        	slli	a3, a9, 14
4037cd70:	202230        	or	a2, a2, a3
4037cd73:	0020c0        	memw
4037cd76:	2129      	s32i.n	a2, a1, 8
        user.fwrite_dual = 1;
4037cd78:	0020c0        	memw
4037cd7b:	1128      	l32i.n	a2, a1, 4
4037cd7d:	119940        	slli	a9, a9, 12
4037cd80:	202290        	or	a2, a2, a9
4037cd83:	0020c0        	memw
4037cd86:	1129      	s32i.n	a2, a1, 4
        break;
4037cd88:	ffe446        	j	4037cd1d <spi_flash_hal_gpspi_configure_host_io_mode+0x211>
	...

4037cd8c <spi_flash_hal_gpspi_common_command>:

esp_err_t spi_flash_hal_common_command(spi_flash_host_inst_t *host, spi_flash_trans_t *trans)
{
4037cd8c:	008136        	entry	a1, 64
    uint16_t command;
    uint8_t dummy_bitlen;

    command = trans->command;
    dummy_bitlen = trans->dummy_bitlen;
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037cd8f:	4368      	l32i.n	a6, a3, 16
    return ((spi_flash_hal_context_t*)host)->spi;
4037cd91:	1248      	l32i.n	a4, a2, 4
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037cd93:	0522e2        	l32i	a14, a2, 20
    command = trans->command;
4037cd96:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037cd99:	160352        	l8ui	a5, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037cd9c:	026617        	bbci	a6, 1, 4037cda2 <spi_flash_hal_gpspi_common_command+0x16>
        io_mode = trans->io_mode;
4037cd9f:	0623e2        	l32i	a14, a3, 24
    }

    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037cda2:	0268      	l32i.n	a6, a2, 0
4037cda4:	0303c2        	l8ui	a12, a3, 3
4037cda7:	f668      	l32i.n	a6, a6, 60
4037cda9:	05dd      	mov.n	a13, a5
4037cdab:	02ad      	mov.n	a10, a2
4037cdad:	0006e0        	callx8	a6

    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037cdb0:	030372        	l8ui	a7, a3, 3
4037cdb3:	012362        	l32i	a6, a3, 4
    uint32_t padding_ones = (bitlen == 32? 0 : UINT32_MAX >> bitlen);
4037cdb6:	00a082        	movi	a8, 0
4037cdb9:	07c726        	beqi	a7, 32, 4037cdc4 <spi_flash_hal_gpspi_common_command+0x38>
4037cdbc:	f87c      	movi.n	a8, -1
4037cdbe:	400700        	ssr	a7
4037cdc1:	918080        	srl	a8, a8
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037cdc4:	607070        	neg	a7, a7
4037cdc7:	401700        	ssl	a7
4037cdca:	a16600        	sll	a6, a6
4037cdcd:	206680        	or	a6, a6, a8
4037cdd0:	0020c0        	memw
4037cdd3:	1469      	s32i.n	a6, a4, 4
    //No extra dummy cycles for compensation if no input data
    if (trans->miso_len == 0) {
4037cdd5:	020362        	l8ui	a6, a3, 2
4037cdd8:	049656        	bnez	a6, 4037ce25 <spi_flash_hal_gpspi_common_command+0x99>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037cddb:	180c      	movi.n	a8, 1
4037cddd:	0020c0        	memw
4037cde0:	4478      	l32i.n	a7, a4, 16
4037cde2:	838650        	moveqz	a8, a6, a5
4037cde5:	de8491        	l32r	a9, 403747f8 <_iram_text_start+0x3f4>
4037cde8:	048080        	extui	a8, a8, 0, 1
4037cdeb:	018830        	slli	a8, a8, 29
4037cdee:	107790        	and	a7, a7, a9
4037cdf1:	207780        	or	a7, a7, a8
4037cdf4:	0020c0        	memw
4037cdf7:	4479      	s32i.n	a7, a4, 16
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->user1, usr_dummy_cyclelen, dummy_n - 1)
4037cdf9:	0020c0        	memw
4037cdfc:	5478      	l32i.n	a7, a4, 20
4037cdfe:	550b      	addi.n	a5, a5, -1
4037ce00:	0020c0        	memw
4037ce03:	1179      	s32i.n	a7, a1, 4
4037ce05:	0020c0        	memw
4037ce08:	1178      	l32i.n	a7, a1, 4
4037ce0a:	00af82        	movi	a8, 0xffffff00
4037ce0d:	745050        	extui	a5, a5, 0, 8
4037ce10:	107780        	and	a7, a7, a8
4037ce13:	205750        	or	a5, a7, a5
4037ce16:	0020c0        	memw
4037ce19:	1159      	s32i.n	a5, a1, 4
4037ce1b:	0020c0        	memw
4037ce1e:	1158      	l32i.n	a5, a1, 4
4037ce20:	0020c0        	memw
4037ce23:	5459      	s32i.n	a5, a4, 20
        spi_flash_ll_set_dummy(dev, dummy_bitlen);
    }

    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037ce25:	010392        	l8ui	a9, a3, 1
    dev->user.usr_mosi = bitlen > 0;
4037ce28:	050c      	movi.n	a5, 0
4037ce2a:	1189d0        	slli	a8, a9, 3
4037ce2d:	170c      	movi.n	a7, 1
4037ce2f:	837580        	moveqz	a7, a5, a8
4037ce32:	de72a1        	l32r	a10, 403747fc <_iram_text_start+0x3f8>
4037ce35:	0020c0        	memw
4037ce38:	4458      	l32i.n	a5, a4, 16
4037ce3a:	017750        	slli	a7, a7, 27
4037ce3d:	1055a0        	and	a5, a5, a10
4037ce40:	205570        	or	a5, a5, a7
4037ce43:	0020c0        	memw
4037ce46:	4459      	s32i.n	a5, a4, 16
    if (bitlen) {
4037ce48:	c99c      	beqz.n	a9, 4037ce68 <spi_flash_hal_gpspi_common_command+0xdc>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037ce4a:	e00b71        	l32r	a7, 40374e78 <_iram_text_start+0xa74>
4037ce4d:	880b      	addi.n	a8, a8, -1
4037ce4f:	0020c0        	memw
4037ce52:	7458      	l32i.n	a5, a4, 28
4037ce54:	108870        	and	a8, a8, a7
4037ce57:	ffaf72        	movi	a7, -1
4037ce5a:	0177e0        	slli	a7, a7, 18
4037ce5d:	105570        	and	a5, a5, a7
4037ce60:	205580        	or	a5, a5, a8
4037ce63:	0020c0        	memw
4037ce66:	7459      	s32i.n	a5, a4, 28
    int num_words = (length + 3) / 4;
4037ce68:	893b      	addi.n	a8, a9, 3
    for (int i = 0; i < num_words; i++) {
4037ce6a:	050c      	movi.n	a5, 0
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037ce6c:	23e8      	l32i.n	a14, a3, 8
    int num_words = (length + 3) / 4;
4037ce6e:	418280        	srli	a8, a8, 2
    for (int i = 0; i < num_words; i++) {
4037ce71:	05dd      	mov.n	a13, a5
4037ce73:	02a587        	bge	a5, a8, 4037ce79 <spi_flash_hal_gpspi_common_command+0xed>
4037ce76:	0021c6        	j	4037cf01 <spi_flash_hal_gpspi_common_command+0x175>
    dev->user.usr_miso = bitlen > 0;
4037ce79:	0020c0        	memw
4037ce7c:	4488      	l32i.n	a8, a4, 16
4037ce7e:	de6071        	l32r	a7, 40374800 <_iram_text_start+0x3fc>

    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037ce81:	1156d0        	slli	a5, a6, 3
4037ce84:	190c      	movi.n	a9, 1
4037ce86:	839d50        	moveqz	a9, a13, a5
4037ce89:	019940        	slli	a9, a9, 28
4037ce8c:	108870        	and	a8, a8, a7
4037ce8f:	208890        	or	a8, a8, a9
4037ce92:	0020c0        	memw
4037ce95:	4489      	s32i.n	a8, a4, 16
    if (bitlen) {
4037ce97:	d69c      	beqz.n	a6, 4037ceb8 <spi_flash_hal_gpspi_common_command+0x12c>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037ce99:	dff771        	l32r	a7, 40374e78 <_iram_text_start+0xa74>
4037ce9c:	550b      	addi.n	a5, a5, -1
4037ce9e:	0020c0        	memw
4037cea1:	7468      	l32i.n	a6, a4, 28
4037cea3:	105570        	and	a5, a5, a7
4037cea6:	ffaf72        	movi	a7, -1
4037cea9:	0177e0        	slli	a7, a7, 18
4037ceac:	106670        	and	a6, a6, a7
4037ceaf:	205650        	or	a5, a6, a5
4037ceb2:	0020c0        	memw
4037ceb5:	076452        	s32i	a5, a4, 28
    dev->cmd.update = 1;
4037ceb8:	0020c0        	memw
4037cebb:	0458      	l32i.n	a5, a4, 0
4037cebd:	01a062        	movi	a6, 1
4037cec0:	016690        	slli	a6, a6, 23
4037cec3:	205560        	or	a5, a5, a6
4037cec6:	0020c0        	memw
4037cec9:	006452        	s32i	a5, a4, 0
    while (dev->cmd.update);
4037cecc:	0020c0        	memw
4037cecf:	0458      	l32i.n	a5, a4, 0
4037ced1:	f7f577        	bbsi	a5, 23, 4037cecc <spi_flash_hal_gpspi_common_command+0x140>
    dev->cmd.usr = 1;
4037ced4:	0020c0        	memw
4037ced7:	0458      	l32i.n	a5, a4, 0
4037ced9:	160c      	movi.n	a6, 1
4037cedb:	016680        	slli	a6, a6, 24
4037cede:	205560        	or	a5, a5, a6
4037cee1:	0020c0        	memw
4037cee4:	0459      	s32i.n	a5, a4, 0
    spi_flash_ll_user_start(dev);
    host->driver->poll_cmd_done(host);
4037cee6:	0258      	l32i.n	a5, a2, 0
4037cee8:	02ad      	mov.n	a10, a2
4037ceea:	102552        	l32i	a5, a5, 64
4037ceed:	0005e0        	callx8	a5
    if (trans->miso_len > 0) {
4037cef0:	0203c2        	l8ui	a12, a3, 2
4037cef3:	5c8c      	beqz.n	a12, 4037cefc <spi_flash_hal_gpspi_common_command+0x170>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037cef5:	33b8      	l32i.n	a11, a3, 12
4037cef7:	04ad      	mov.n	a10, a4
4037cef9:	ffa865        	call8	4037c980 <gpspi_flash_ll_get_buffer_data>
    }
    return ESP_OK;
}
4037cefc:	020c      	movi.n	a2, 0
4037cefe:	f01d      	retw.n
4037cf00:	00          	.byte 00
        uint32_t word_len = MIN(length, sizeof(word));
4037cf01:	470c      	movi.n	a7, 4
4037cf03:	637970        	minu	a7, a9, a7
        memcpy(&word, buffer, word_len);
4037cf06:	0ebd      	mov.n	a11, a14
4037cf08:	07cd      	mov.n	a12, a7
4037cf0a:	01ad      	mov.n	a10, a1
        uint32_t word = 0;
4037cf0c:	01d9      	s32i.n	a13, a1, 0
        memcpy(&word, buffer, word_len);
4037cf0e:	5189      	s32i.n	a8, a1, 20
4037cf10:	4199      	s32i.n	a9, a1, 16
4037cf12:	71d9      	s32i.n	a13, a1, 28
4037cf14:	61e9      	s32i.n	a14, a1, 24
4037cf16:	dd6681        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037cf19:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037cf1c:	24c5a2        	addi	a10, a5, 36
4037cf1f:	01b8      	l32i.n	a11, a1, 0
        length -= word_len;
4037cf21:	4198      	l32i.n	a9, a1, 16
        buffer = (void *)((intptr_t)buffer + word_len);
4037cf23:	61e8      	l32i.n	a14, a1, 24
        dev->data_buf[i] = word;
4037cf25:	a0aa40        	addx4	a10, a10, a4
    for (int i = 0; i < num_words; i++) {
4037cf28:	71d8      	l32i.n	a13, a1, 28
4037cf2a:	5188      	l32i.n	a8, a1, 20
        dev->data_buf[i] = word;
4037cf2c:	0020c0        	memw
4037cf2f:	2ab9      	s32i.n	a11, a10, 8
        length -= word_len;
4037cf31:	c09970        	sub	a9, a9, a7
        buffer = (void *)((intptr_t)buffer + word_len);
4037cf34:	ee7a      	add.n	a14, a14, a7
    for (int i = 0; i < num_words; i++) {
4037cf36:	551b      	addi.n	a5, a5, 1
4037cf38:	ffcdc6        	j	4037ce73 <spi_flash_hal_gpspi_common_command+0xe7>
	...

4037cf3c <spi_flash_hal_gpspi_read>:

esp_err_t spi_flash_hal_read(spi_flash_host_inst_t *host, void *buffer, uint32_t address, uint32_t read_len)
{
4037cf3c:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037cf3f:	1268      	l32i.n	a6, a2, 4
{
4037cf41:	02ad      	mov.n	a10, a2
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037cf43:	0020c0        	memw
4037cf46:	4698      	l32i.n	a9, a6, 16
4037cf48:	00a082        	movi	a8, 0
4037cf4b:	0b79e7        	bbci	a9, 30, 4037cf5a <spi_flash_hal_gpspi_read+0x1e>
4037cf4e:	0020c0        	memw
4037cf51:	052682        	l32i	a8, a6, 20
4037cf54:	458b80        	extui	a8, a8, 27, 5
4037cf57:	01c882        	addi	a8, a8, 1
    spi_dev_t *dev = get_spi_dev(host);
    int bitlen = spi_flash_ll_get_addr_bitlen(dev);
    //Only 24-bit and 32-bit address are supported. The extra length are for M7-M0, which should be
    //filled with ones by the function below
    spi_flash_ll_set_usr_address(dev, address, bitlen & (~7));
4037cf5a:	897c      	movi.n	a9, -8
4037cf5c:	108890        	and	a8, a8, a9
    uint32_t padding_ones = (bitlen == 32? 0 : UINT32_MAX >> bitlen);
4037cf5f:	090c      	movi.n	a9, 0
4037cf61:	07c826        	beqi	a8, 32, 4037cf6c <spi_flash_hal_gpspi_read+0x30>
4037cf64:	f97c      	movi.n	a9, -1
4037cf66:	400800        	ssr	a8
4037cf69:	919090        	srl	a9, a9
    dev->addr = (addr << (32 - bitlen)) | padding_ones;
4037cf6c:	608080        	neg	a8, a8
4037cf6f:	401800        	ssl	a8
4037cf72:	a14400        	sll	a4, a4
4037cf75:	204490        	or	a4, a4, a9
4037cf78:	0020c0        	memw
4037cf7b:	1649      	s32i.n	a4, a6, 4
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037cf7d:	1185d0        	slli	a8, a5, 3
    dev->user.usr_miso = bitlen > 0;
4037cf80:	040c      	movi.n	a4, 0
4037cf82:	1b0c      	movi.n	a11, 1
4037cf84:	0020c0        	memw
4037cf87:	4698      	l32i.n	a9, a6, 16
4037cf89:	83b480        	moveqz	a11, a4, a8
4037cf8c:	de1d41        	l32r	a4, 40374800 <_iram_text_start+0x3fc>
4037cf8f:	01bb40        	slli	a11, a11, 28
4037cf92:	109940        	and	a9, a9, a4
4037cf95:	2099b0        	or	a9, a9, a11
4037cf98:	0020c0        	memw
4037cf9b:	4699      	s32i.n	a9, a6, 16
    if (bitlen) {
4037cf9d:	b89c      	beqz.n	a8, 4037cfbc <spi_flash_hal_gpspi_read+0x80>
        dev->ms_dlen.ms_data_bitlen = bitlen - 1;
4037cf9f:	dfb641        	l32r	a4, 40374e78 <_iram_text_start+0xa74>
4037cfa2:	880b      	addi.n	a8, a8, -1
4037cfa4:	0020c0        	memw
4037cfa7:	7698      	l32i.n	a9, a6, 28
4037cfa9:	108840        	and	a8, a8, a4
4037cfac:	f47c      	movi.n	a4, -1
4037cfae:	0144e0        	slli	a4, a4, 18
4037cfb1:	109940        	and	a9, a9, a4
4037cfb4:	208980        	or	a8, a9, a8
4037cfb7:	0020c0        	memw
4037cfba:	7689      	s32i.n	a8, a6, 28
    dev->cmd.update = 1;
4037cfbc:	0020c0        	memw
4037cfbf:	0648      	l32i.n	a4, a6, 0
4037cfc1:	01a082        	movi	a8, 1
4037cfc4:	018890        	slli	a8, a8, 23
4037cfc7:	204480        	or	a4, a4, a8
4037cfca:	0020c0        	memw
4037cfcd:	006642        	s32i	a4, a6, 0
    while (dev->cmd.update);
4037cfd0:	0020c0        	memw
4037cfd3:	002642        	l32i	a4, a6, 0
4037cfd6:	f6f477        	bbsi	a4, 23, 4037cfd0 <spi_flash_hal_gpspi_read+0x94>
    dev->cmd.usr = 1;
4037cfd9:	0020c0        	memw
4037cfdc:	002642        	l32i	a4, a6, 0
4037cfdf:	01a082        	movi	a8, 1
4037cfe2:	018880        	slli	a8, a8, 24
4037cfe5:	204480        	or	a4, a4, a8
4037cfe8:	0020c0        	memw
4037cfeb:	0649      	s32i.n	a4, a6, 0
    spi_flash_ll_user_start(dev);
    host->driver->poll_cmd_done(host);
4037cfed:	0a48      	l32i.n	a4, a10, 0
4037cfef:	102442        	l32i	a4, a4, 64
4037cff2:	0004e0        	callx8	a4
    if (read_len > 0) {
4037cff5:	758c      	beqz.n	a5, 4037d000 <spi_flash_hal_gpspi_read+0xc4>
        spi_flash_ll_get_buffer_data(dev, buffer, read_len);
4037cff7:	05cd      	mov.n	a12, a5
4037cff9:	03bd      	mov.n	a11, a3
4037cffb:	06ad      	mov.n	a10, a6
4037cffd:	ff9825        	call8	4037c980 <gpspi_flash_ll_get_buffer_data>
    }
    return ESP_OK;
}
4037d000:	020c      	movi.n	a2, 0
4037d002:	f01d      	retw.n

4037d004 <spi_flash_hal_gpspi_poll_cmd_done>:
{
4037d004:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d007:	1298      	l32i.n	a9, a2, 4
    return (dev->cmd.usr == 0);
4037d009:	0020c0        	memw
4037d00c:	0988      	l32i.n	a8, a9, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037d00e:	f7f887        	bbsi	a8, 24, 4037d009 <spi_flash_hal_gpspi_poll_cmd_done+0x5>
}
4037d011:	f01d      	retw.n
	...

4037d014 <spi_flash_hal_gpspi_supports_direct_write>:
#define spi_flash_hal_read                      spi_flash_hal_gpspi_read

#include "spi_flash_hal_common.inc"

bool spi_flash_hal_gpspi_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
4037d014:	004136        	entry	a1, 32
    return true;
}
4037d017:	120c      	movi.n	a2, 1
4037d019:	f01d      	retw.n
	...

4037d01c <spi_flash_hal_gpspi_supports_direct_read>:
4037d01c:	004136        	entry	a1, 32
4037d01f:	120c      	movi.n	a2, 1
4037d021:	f01d      	retw.n
	...

4037d024 <spi_flash_hal_gpspi_check_status>:
{
    return true;
}

uint32_t spi_flash_hal_gpspi_check_status(spi_flash_host_inst_t *host)
{
4037d024:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d027:	1228      	l32i.n	a2, a2, 4
    return dev->cmd.usr == 0;
4037d029:	0020c0        	memw
4037d02c:	0288      	l32i.n	a8, a2, 0
    spi_dev_t *dev = get_spi_dev(host);
    return spi_flash_ll_host_idle(dev);
}
4037d02e:	120c      	movi.n	a2, 1
4037d030:	058880        	extui	a8, a8, 24, 1
4037d033:	302820        	xor	a2, a8, a2
4037d036:	f01d      	retw.n

4037d038 <spimem_flash_ll_set_buffer_data>:
 * @param dev Beginning address of the peripheral registers.
 * @param buffer Buffer holding the data
 * @param length Length of data in bytes.
 */
static inline void spimem_flash_ll_set_buffer_data(spi_mem_dev_t *dev, const void *buffer, uint32_t length)
{
4037d038:	008136        	entry	a1, 64
    // Load data registers, word at a time
    int num_words = (length + 3) / 4;
4037d03b:	743b      	addi.n	a7, a4, 3
    for (int i = 0; i < num_words; i++) {
4037d03d:	050c      	movi.n	a5, 0
    int num_words = (length + 3) / 4;
4037d03f:	417270        	srli	a7, a7, 2
        uint32_t word = 0;
4037d042:	059d      	mov.n	a9, a5
    for (int i = 0; i < num_words; i++) {
4037d044:	012577        	blt	a5, a7, 4037d049 <spimem_flash_ll_set_buffer_data+0x11>
        memcpy(&word, buffer, word_len);
        dev->data_buf[i] = word;
        length -= word_len;
        buffer = (void *)((intptr_t)buffer + word_len);
    }
}
4037d047:	f01d      	retw.n
        uint32_t word_len = MIN(length, sizeof(word));
4037d049:	460c      	movi.n	a6, 4
4037d04b:	636460        	minu	a6, a4, a6
        memcpy(&word, buffer, word_len);
4037d04e:	03bd      	mov.n	a11, a3
4037d050:	06cd      	mov.n	a12, a6
4037d052:	01ad      	mov.n	a10, a1
        uint32_t word = 0;
4037d054:	006192        	s32i	a9, a1, 0
        memcpy(&word, buffer, word_len);
4037d057:	046192        	s32i	a9, a1, 16
4037d05a:	dd1581        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037d05d:	0008e0        	callx8	a8
        dev->data_buf[i] = word;
4037d060:	14c582        	addi	a8, a5, 20
4037d063:	01a8      	l32i.n	a10, a1, 0
4037d065:	a08820        	addx4	a8, a8, a2
    for (int i = 0; i < num_words; i++) {
4037d068:	4198      	l32i.n	a9, a1, 16
        dev->data_buf[i] = word;
4037d06a:	0020c0        	memw
4037d06d:	28a9      	s32i.n	a10, a8, 8
        length -= word_len;
4037d06f:	c04460        	sub	a4, a4, a6
        buffer = (void *)((intptr_t)buffer + word_len);
4037d072:	336a      	add.n	a3, a3, a6
    for (int i = 0; i < num_words; i++) {
4037d074:	551b      	addi.n	a5, a5, 1
4037d076:	fff286        	j	4037d044 <spimem_flash_ll_set_buffer_data+0xc>
4037d079:	000000        	ill

4037d07c <spimem_flash_ll_get_buffer_data>:
{
4037d07c:	008136        	entry	a1, 64
    if (((intptr_t)buffer % 4 == 0) && (read_len % 4 == 0)) {
4037d07f:	205340        	or	a5, a3, a4
4037d082:	145050        	extui	a5, a5, 0, 2
4037d085:	d5cc      	bnez.n	a5, 4037d096 <spimem_flash_ll_get_buffer_data+0x1a>
        memcpy(buffer, (void *)dev->data_buf, read_len);
4037d087:	04cd      	mov.n	a12, a4
4037d089:	58c2b2        	addi	a11, a2, 88
4037d08c:	03ad      	mov.n	a10, a3
4037d08e:	dd0881        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037d091:	0008e0        	callx8	a8
}
4037d094:	f01d      	retw.n
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d096:	643b      	addi.n	a6, a4, 3
4037d098:	416260        	srli	a6, a6, 2
4037d09b:	050c      	movi.n	a5, 0
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037d09d:	490c      	movi.n	a9, 4
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d09f:	f11657        	beq	a6, a5, 4037d094 <spimem_flash_ll_get_buffer_data+0x18>
            uint32_t word = dev->data_buf[i];
4037d0a2:	14c582        	addi	a8, a5, 20
4037d0a5:	a08820        	addx4	a8, a8, a2
            int word_len = MIN(sizeof(uint32_t), copy_len);
4037d0a8:	637490        	minu	a7, a4, a9
            uint32_t word = dev->data_buf[i];
4037d0ab:	0020c0        	memw
4037d0ae:	2888      	l32i.n	a8, a8, 8
            memcpy(buffer, &word, word_len);
4037d0b0:	03ad      	mov.n	a10, a3
4037d0b2:	07cd      	mov.n	a12, a7
4037d0b4:	01bd      	mov.n	a11, a1
4037d0b6:	4199      	s32i.n	a9, a1, 16
            uint32_t word = dev->data_buf[i];
4037d0b8:	0189      	s32i.n	a8, a1, 0
            memcpy(buffer, &word, word_len);
4037d0ba:	dcfd81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037d0bd:	0008e0        	callx8	a8
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d0c0:	4198      	l32i.n	a9, a1, 16
            buffer = (void *)((intptr_t)buffer + word_len);
4037d0c2:	337a      	add.n	a3, a3, a7
            copy_len -= word_len;
4037d0c4:	c04470        	sub	a4, a4, a7
        for (uint32_t i = 0; i < (read_len + 3) / 4; i++) {
4037d0c7:	551b      	addi.n	a5, a5, 1
4037d0c9:	fff486        	j	4037d09f <spimem_flash_ll_get_buffer_data+0x23>

4037d0cc <spi_flash_hal_configure_host_io_mode>:
{
4037d0cc:	006136        	entry	a1, 48
    return ((spi_flash_hal_context_t*)host)->spi;
4037d0cf:	1288      	l32i.n	a8, a2, 4
    uint32_t extra_bits = io_mode & 0xFFFF0000;
4037d0d1:	f97c      	movi.n	a9, -1
4037d0d3:	119900        	slli	a9, a9, 16
 * @param out_en whether to enable IO output for dummy phase
 * @param out_level dummy output level
 */
static inline void spimem_flash_ll_set_dummy_out(spi_mem_dev_t *dev, uint32_t out_en, uint32_t out_lev)
{
    dev->ctrl.fdummy_out = out_en;
4037d0d6:	0020c0        	memw
4037d0d9:	28b8      	l32i.n	a11, a8, 8
    io_mode = io_mode & 0xFFFF;
4037d0db:	f4a060        	extui	a10, a6, 0, 16
    uint32_t extra_bits = io_mode & 0xFFFF0000;
4037d0de:	106690        	and	a6, a6, a9
4037d0e1:	7c7c      	movi.n	a12, -9
4037d0e3:	056f60        	extui	a6, a6, 31, 1
4037d0e6:	10bbc0        	and	a11, a11, a12
4037d0e9:	1166d0        	slli	a6, a6, 3
4037d0ec:	206b60        	or	a6, a11, a6
4037d0ef:	0020c0        	memw
4037d0f2:	2869      	s32i.n	a6, a8, 8
    dev->ctrl.q_pol = out_lev;
4037d0f4:	0020c0        	memw
4037d0f7:	2868      	l32i.n	a6, a8, 8
4037d0f9:	1b0c      	movi.n	a11, 1
4037d0fb:	01bbe0        	slli	a11, a11, 18
4037d0fe:	2066b0        	or	a6, a6, a11
4037d101:	0020c0        	memw
4037d104:	2869      	s32i.n	a6, a8, 8
    dev->ctrl.d_pol = out_lev;
4037d106:	0020c0        	memw
4037d109:	2868      	l32i.n	a6, a8, 8
4037d10b:	1b0c      	movi.n	a11, 1
4037d10d:	01bbd0        	slli	a11, a11, 19
4037d110:	2066b0        	or	a6, a6, a11
4037d113:	0020c0        	memw
4037d116:	2869      	s32i.n	a6, a8, 8
    if (command >= 0x100) {
4037d118:	ffa0c2        	movi	a12, 255
4037d11b:	f67c      	movi.n	a6, -1
4037d11d:	016610        	slli	a6, a6, 31
4037d120:	f4b030        	extui	a11, a3, 0, 16
4037d123:	023c37        	bltu	a12, a3, 4037d129 <spi_flash_hal_configure_host_io_mode+0x5d>
4037d126:	005746        	j	4037d287 <spi_flash_hal_configure_host_io_mode+0x1bb>
    dev->user.usr_command = 1;
4037d129:	0020c0        	memw
4037d12c:	6838      	l32i.n	a3, a8, 24
4037d12e:	203360        	or	a3, a3, a6
4037d131:	0020c0        	memw
4037d134:	6839      	s32i.n	a3, a8, 24
    typeof(dev->user2) user2 = {
4037d136:	030c      	movi.n	a3, 0
4037d138:	0020c0        	memw
4037d13b:	2139      	s32i.n	a3, a1, 8
4037d13d:	0020c0        	memw
4037d140:	2168      	l32i.n	a6, a1, 8
4037d142:	106690        	and	a6, a6, a9
4037d145:	2066b0        	or	a6, a6, a11
4037d148:	0020c0        	memw
4037d14b:	2169      	s32i.n	a6, a1, 8
4037d14d:	0020c0        	memw
4037d150:	2138      	l32i.n	a3, a1, 8
4037d152:	f67c      	movi.n	a6, -1
4037d154:	016640        	slli	a6, a6, 28
4037d157:	203360        	or	a3, a3, a6
4037d15a:	0020c0        	memw
4037d15d:	2139      	s32i.n	a3, a1, 8
    dev->user2 = user2;
4037d15f:	0020c0        	memw
4037d162:	2138      	l32i.n	a3, a1, 8
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d164:	060c      	movi.n	a6, 0
    dev->user2 = user2;
4037d166:	0020c0        	memw
4037d169:	8839      	s32i.n	a3, a8, 32
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d16b:	190c      	movi.n	a9, 1
4037d16d:	e0c4b2        	addi	a11, a4, -32
4037d170:	063d      	mov.n	a3, a6
4037d172:	8339b0        	moveqz	a3, a9, a11
4037d175:	0020c0        	memw
4037d178:	f8b8      	l32i.n	a11, a8, 60
4037d17a:	dc7c      	movi.n	a12, -3
4037d17c:	333a      	add.n	a3, a3, a3
4037d17e:	10bbc0        	and	a11, a11, a12
4037d181:	20bb30        	or	a11, a11, a3
4037d184:	0020c0        	memw
4037d187:	f8b9      	s32i.n	a11, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d189:	0020c0        	memw
4037d18c:	78b8      	l32i.n	a11, a8, 28
4037d18e:	dd72c1        	l32r	a12, 40374758 <_iram_text_start+0x354>
4037d191:	340b      	addi.n	a3, a4, -1
4037d193:	013360        	slli	a3, a3, 26
4037d196:	10bbc0        	and	a11, a11, a12
4037d199:	20bb30        	or	a11, a11, a3
4037d19c:	0020c0        	memw
4037d19f:	78b9      	s32i.n	a11, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d1a1:	063d      	mov.n	a3, a6
4037d1a3:	0020c0        	memw
4037d1a6:	68b8      	l32i.n	a11, a8, 24
4037d1a8:	933940        	movnez	a3, a9, a4
4037d1ab:	dd9141        	l32r	a4, 403747f0 <_iram_text_start+0x3ec>
4037d1ae:	013320        	slli	a3, a3, 30
4037d1b1:	10bb40        	and	a11, a11, a4
4037d1b4:	20bb30        	or	a11, a11, a3
4037d1b7:	0020c0        	memw
4037d1ba:	68b9      	s32i.n	a11, a8, 24
    spi_flash_ll_set_dummy(dev, COMPUTE_DUMMY_CYCLELEN(host, dummy_cyclelen_base));
4037d1bc:	0c02b2        	l8ui	a11, a2, 12
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d1bf:	dd8e21        	l32r	a2, 403747f8 <_iram_text_start+0x3f4>
4037d1c2:	5b5a      	add.n	a5, a11, a5
4037d1c4:	0020c0        	memw
4037d1c7:	68b8      	l32i.n	a11, a8, 24
4037d1c9:	936950        	movnez	a6, a9, a5
4037d1cc:	10bb20        	and	a11, a11, a2
4037d1cf:	016630        	slli	a6, a6, 29
4037d1d2:	206b60        	or	a6, a11, a6
4037d1d5:	0020c0        	memw
4037d1d8:	6869      	s32i.n	a6, a8, 24
    dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037d1da:	0020c0        	memw
4037d1dd:	7868      	l32i.n	a6, a8, 28
4037d1df:	c0af22        	movi	a2, -64
4037d1e2:	550b      	addi.n	a5, a5, -1
4037d1e4:	106620        	and	a6, a6, a2
4037d1e7:	545050        	extui	a5, a5, 0, 6
4037d1ea:	205650        	or	a5, a6, a5
4037d1ed:	0020c0        	memw
4037d1f0:	7859      	s32i.n	a5, a8, 28
    dev->user.usr_miso = bitlen > 0;
4037d1f2:	0020c0        	memw
4037d1f5:	6828      	l32i.n	a2, a8, 24
4037d1f7:	dd8231        	l32r	a3, 40374800 <_iram_text_start+0x3fc>
    dev->user.usr_mosi = bitlen > 0;
4037d1fa:	dd8041        	l32r	a4, 403747fc <_iram_text_start+0x3f8>
    dev->user.usr_miso = bitlen > 0;
4037d1fd:	102230        	and	a2, a2, a3
4037d200:	0020c0        	memw
4037d203:	6829      	s32i.n	a2, a8, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037d205:	0020c0        	memw
4037d208:	a828      	l32i.n	a2, a8, 40
4037d20a:	00ac32        	movi	a3, 0xfffffc00
4037d20d:	102230        	and	a2, a2, a3
4037d210:	0020c0        	memw
4037d213:	a829      	s32i.n	a2, a8, 40
    dev->user.usr_mosi = bitlen > 0;
4037d215:	0020c0        	memw
4037d218:	6828      	l32i.n	a2, a8, 24
4037d21a:	102240        	and	a2, a2, a4
4037d21d:	0020c0        	memw
4037d220:	6829      	s32i.n	a2, a8, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037d222:	0020c0        	memw
4037d225:	9828      	l32i.n	a2, a8, 36
4037d227:	102230        	and	a2, a2, a3
4037d22a:	0020c0        	memw
4037d22d:	9829      	s32i.n	a2, a8, 36
    typeof (dev->ctrl) ctrl = dev->ctrl;
4037d22f:	0020c0        	memw
4037d232:	2828      	l32i.n	a2, a8, 8
    ctrl.val &= ~(SPI_MEM_FREAD_QIO_M | SPI_MEM_FREAD_QUAD_M | SPI_MEM_FREAD_DIO_M | SPI_MEM_FREAD_DUAL_M | SPI_MEM_FCMD_OCT | SPI_MEM_FADDR_OCT | SPI_MEM_FDIN_OCT | SPI_MEM_FDOUT_OCT);
4037d234:	df1231        	l32r	a3, 40374e7c <_iram_text_start+0xa78>
    typeof (dev->ctrl) ctrl = dev->ctrl;
4037d237:	0020c0        	memw
4037d23a:	0129      	s32i.n	a2, a1, 0
    ctrl.val &= ~(SPI_MEM_FREAD_QIO_M | SPI_MEM_FREAD_QUAD_M | SPI_MEM_FREAD_DIO_M | SPI_MEM_FREAD_DUAL_M | SPI_MEM_FCMD_OCT | SPI_MEM_FADDR_OCT | SPI_MEM_FDIN_OCT | SPI_MEM_FDOUT_OCT);
4037d23c:	0020c0        	memw
4037d23f:	0128      	l32i.n	a2, a1, 0
4037d241:	102230        	and	a2, a2, a3
4037d244:	0020c0        	memw
4037d247:	0129      	s32i.n	a2, a1, 0
    dev->ddr.fmem_ddr_en = 0;
4037d249:	0020c0        	memw
4037d24c:	382822        	l32i	a2, a8, 224
4037d24f:	e37c      	movi.n	a3, -2
4037d251:	102230        	and	a2, a2, a3
4037d254:	0020c0        	memw
4037d257:	386822        	s32i	a2, a8, 224
    ctrl.val |= SPI_MEM_FASTRD_MODE_M;
4037d25a:	0020c0        	memw
4037d25d:	002122        	l32i	a2, a1, 0
4037d260:	113930        	slli	a3, a9, 13
4037d263:	202230        	or	a2, a2, a3
4037d266:	0020c0        	memw
4037d269:	006122        	s32i	a2, a1, 0
    switch (read_mode) {
4037d26c:	024a66        	bnei	a10, 4, 4037d272 <spi_flash_hal_configure_host_io_mode+0x1a6>
4037d26f:	002746        	j	4037d310 <spi_flash_hal_configure_host_io_mode+0x244>
4037d272:	6a5af6        	bgeui	a10, 5, 4037d2e0 <spi_flash_hal_configure_host_io_mode+0x214>
4037d275:	022a66        	bnei	a10, 2, 4037d27b <spi_flash_hal_configure_host_io_mode+0x1af>
4037d278:	002806        	j	4037d31c <spi_flash_hal_configure_host_io_mode+0x250>
4037d27b:	513af6        	bgeui	a10, 3, 4037d2d0 <spi_flash_hal_configure_host_io_mode+0x204>
4037d27e:	0a6a16        	beqz	a10, 4037d328 <spi_flash_hal_configure_host_io_mode+0x25c>
4037d281:	7b1a97        	beq	a10, a9, 4037d300 <spi_flash_hal_configure_host_io_mode+0x234>
        abort();
4037d284:	014f65        	call8	4037e77c <abort>
    dev->user.usr_command = 1;
4037d287:	0020c0        	memw
4037d28a:	062832        	l32i	a3, a8, 24
4037d28d:	203360        	or	a3, a3, a6
4037d290:	0020c0        	memw
4037d293:	066832        	s32i	a3, a8, 24
    typeof(dev->user2) user2 = {
4037d296:	00a032        	movi	a3, 0
4037d299:	0020c0        	memw
4037d29c:	1139      	s32i.n	a3, a1, 4
4037d29e:	0020c0        	memw
4037d2a1:	1168      	l32i.n	a6, a1, 4
4037d2a3:	dd5231        	l32r	a3, 403747ec <_iram_text_start+0x3e8>
4037d2a6:	106690        	and	a6, a6, a9
4037d2a9:	2066b0        	or	a6, a6, a11
4037d2ac:	0020c0        	memw
4037d2af:	1169      	s32i.n	a6, a1, 4
4037d2b1:	0020c0        	memw
4037d2b4:	1168      	l32i.n	a6, a1, 4
4037d2b6:	106630        	and	a6, a6, a3
4037d2b9:	730c      	movi.n	a3, 7
4037d2bb:	013340        	slli	a3, a3, 28
4037d2be:	206630        	or	a6, a6, a3
4037d2c1:	0020c0        	memw
4037d2c4:	1169      	s32i.n	a6, a1, 4
    dev->user2 = user2;
4037d2c6:	0020c0        	memw
4037d2c9:	1138      	l32i.n	a3, a1, 4
4037d2cb:	ffa546        	j	4037d164 <spi_flash_hal_configure_host_io_mode+0x98>
4037d2ce:	00          	.byte 00
4037d2cf:	00          	.byte 00
    switch (read_mode) {
4037d2d0:	b03a66        	bnei	a10, 3, 4037d284 <spi_flash_hal_configure_host_io_mode+0x1b8>
        ctrl.fread_dio = 1;
4037d2d3:	0020c0        	memw
4037d2d6:	0128      	l32i.n	a2, a1, 0
4037d2d8:	019990        	slli	a9, a9, 23
4037d2db:	000606        	j	4037d2f7 <spi_flash_hal_configure_host_io_mode+0x22b>
4037d2de:	00          	.byte 00
4037d2df:	00          	.byte 00
    switch (read_mode) {
4037d2e0:	57ba26        	beqi	a10, 16, 4037d33b <spi_flash_hal_configure_host_io_mode+0x26f>
4037d2e3:	121c      	movi.n	a2, 17
4037d2e5:	029a27        	bne	a10, a2, 4037d2eb <spi_flash_hal_configure_host_io_mode+0x21f>
4037d2e8:	002206        	j	4037d374 <spi_flash_hal_configure_host_io_mode+0x2a8>
4037d2eb:	955a66        	bnei	a10, 5, 4037d284 <spi_flash_hal_configure_host_io_mode+0x1b8>
        ctrl.fread_qio = 1;
4037d2ee:	0020c0        	memw
4037d2f1:	002122        	l32i	a2, a1, 0
4037d2f4:	019980        	slli	a9, a9, 24
        ctrl.fread_quad = 1;
4037d2f7:	209290        	or	a9, a2, a9
4037d2fa:	0020c0        	memw
4037d2fd:	006192        	s32i	a9, a1, 0
    dev->ctrl = ctrl;
4037d300:	0020c0        	memw
4037d303:	0128      	l32i.n	a2, a1, 0
4037d305:	0020c0        	memw
4037d308:	2829      	s32i.n	a2, a8, 8
}
4037d30a:	020c      	movi.n	a2, 0
4037d30c:	f01d      	retw.n
4037d30e:	00          	.byte 00
4037d30f:	00          	.byte 00
        ctrl.fread_quad = 1;
4037d310:	0020c0        	memw
4037d313:	0128      	l32i.n	a2, a1, 0
4037d315:	0199c0        	slli	a9, a9, 20
4037d318:	fff6c6        	j	4037d2f7 <spi_flash_hal_configure_host_io_mode+0x22b>
4037d31b:	00          	.byte 00
        ctrl.fread_dual = 1;
4037d31c:	0020c0        	memw
4037d31f:	0128      	l32i.n	a2, a1, 0
4037d321:	119920        	slli	a9, a9, 14
4037d324:	fff3c6        	j	4037d2f7 <spi_flash_hal_configure_host_io_mode+0x22b>
4037d327:	00          	.byte 00
        ctrl.fastrd_mode = 0;
4037d328:	0020c0        	memw
4037d32b:	0128      	l32i.n	a2, a1, 0
4037d32d:	ded431        	l32r	a3, 40374e80 <_iram_text_start+0xa7c>
4037d330:	102230        	and	a2, a2, a3
        ctrl.fdout_oct = 1;
4037d333:	0020c0        	memw
4037d336:	0129      	s32i.n	a2, a1, 0
        break;
4037d338:	fff106        	j	4037d300 <spi_flash_hal_configure_host_io_mode+0x234>
        ctrl.faddr_oct = 1;
4037d33b:	0020c0        	memw
4037d33e:	0128      	l32i.n	a2, a1, 0
4037d340:	034c      	movi.n	a3, 64
4037d342:	202230        	or	a2, a2, a3
4037d345:	0020c0        	memw
4037d348:	0129      	s32i.n	a2, a1, 0
        ctrl.fcmd_oct = 1;
4037d34a:	0020c0        	memw
4037d34d:	0128      	l32i.n	a2, a1, 0
4037d34f:	00a232        	movi	a3, 0x200
4037d352:	202230        	or	a2, a2, a3
4037d355:	0020c0        	memw
4037d358:	0129      	s32i.n	a2, a1, 0
        ctrl.fdin_oct = 1;
4037d35a:	0020c0        	memw
4037d35d:	0128      	l32i.n	a2, a1, 0
4037d35f:	032c      	movi.n	a3, 32
4037d361:	202230        	or	a2, a2, a3
4037d364:	0020c0        	memw
4037d367:	0129      	s32i.n	a2, a1, 0
        ctrl.fdout_oct = 1;
4037d369:	0020c0        	memw
4037d36c:	0128      	l32i.n	a2, a1, 0
4037d36e:	2022a0        	or	a2, a2, a10
4037d371:	ffef86        	j	4037d333 <spi_flash_hal_configure_host_io_mode+0x267>
        ctrl.faddr_oct = 1;
4037d374:	0020c0        	memw
4037d377:	0128      	l32i.n	a2, a1, 0
4037d379:	034c      	movi.n	a3, 64
4037d37b:	202230        	or	a2, a2, a3
4037d37e:	0020c0        	memw
4037d381:	0129      	s32i.n	a2, a1, 0
        ctrl.fcmd_oct = 1;
4037d383:	0020c0        	memw
4037d386:	0128      	l32i.n	a2, a1, 0
4037d388:	00a232        	movi	a3, 0x200
4037d38b:	202230        	or	a2, a2, a3
4037d38e:	0020c0        	memw
4037d391:	0129      	s32i.n	a2, a1, 0
        ctrl.fdin_oct = 1;
4037d393:	0020c0        	memw
4037d396:	0128      	l32i.n	a2, a1, 0
4037d398:	032c      	movi.n	a3, 32
4037d39a:	202230        	or	a2, a2, a3
4037d39d:	0020c0        	memw
4037d3a0:	0129      	s32i.n	a2, a1, 0
        ctrl.fdout_oct = 1;
4037d3a2:	0020c0        	memw
4037d3a5:	0128      	l32i.n	a2, a1, 0
4037d3a7:	031c      	movi.n	a3, 16
4037d3a9:	202230        	or	a2, a2, a3
4037d3ac:	0020c0        	memw
4037d3af:	0129      	s32i.n	a2, a1, 0
        dev->ddr.fmem_ddr_en = 1;
4037d3b1:	0020c0        	memw
4037d3b4:	382822        	l32i	a2, a8, 224
4037d3b7:	202290        	or	a2, a2, a9
4037d3ba:	0020c0        	memw
4037d3bd:	386822        	s32i	a2, a8, 224
        break;
4037d3c0:	ffcf06        	j	4037d300 <spi_flash_hal_configure_host_io_mode+0x234>
	...

4037d3c4 <spi_flash_hal_common_command>:
{
4037d3c4:	004136        	entry	a1, 32
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037d3c7:	4358      	l32i.n	a5, a3, 16
    return ((spi_flash_hal_context_t*)host)->spi;
4037d3c9:	1248      	l32i.n	a4, a2, 4
    esp_flash_io_mode_t io_mode = ((spi_flash_hal_context_t*)host)->base_io_mode;
4037d3cb:	52e8      	l32i.n	a14, a2, 20
    command = trans->command;
4037d3cd:	0a13b2        	l16ui	a11, a3, 20
    dummy_bitlen = trans->dummy_bitlen;
4037d3d0:	160362        	l8ui	a6, a3, 22
    if ((trans->flags & SPI_FLASH_TRANS_FLAG_IGNORE_BASEIO) != 0) {
4037d3d3:	016517        	bbci	a5, 1, 4037d3d8 <spi_flash_hal_common_command+0x14>
        io_mode = trans->io_mode;
4037d3d6:	63e8      	l32i.n	a14, a3, 24
    host->driver->configure_host_io_mode(host, command, trans->address_bitlen, dummy_bitlen, io_mode);
4037d3d8:	0258      	l32i.n	a5, a2, 0
4037d3da:	0303c2        	l8ui	a12, a3, 3
4037d3dd:	f558      	l32i.n	a5, a5, 60
4037d3df:	06dd      	mov.n	a13, a6
4037d3e1:	02ad      	mov.n	a10, a2
4037d3e3:	0005e0        	callx8	a5
    spi_flash_ll_set_usr_address(dev, trans->address, trans->address_bitlen);
4037d3e6:	1358      	l32i.n	a5, a3, 4
    dev->addr = addr;
4037d3e8:	0020c0        	memw
4037d3eb:	1459      	s32i.n	a5, a4, 4
    if (trans->miso_len == 0) {
4037d3ed:	020352        	l8ui	a5, a3, 2
4037d3f0:	55fc      	bnez.n	a5, 4037d429 <spi_flash_hal_common_command+0x65>
    dev->user.usr_dummy = dummy_n ? 1 : 0;
4037d3f2:	180c      	movi.n	a8, 1
4037d3f4:	0020c0        	memw
4037d3f7:	6498      	l32i.n	a9, a4, 24
4037d3f9:	838560        	moveqz	a8, a5, a6
4037d3fc:	dcffa1        	l32r	a10, 403747f8 <_iram_text_start+0x3f4>
4037d3ff:	048080        	extui	a8, a8, 0, 1
4037d402:	1099a0        	and	a9, a9, a10
4037d405:	018830        	slli	a8, a8, 29
4037d408:	208980        	or	a8, a9, a8
4037d40b:	0020c0        	memw
4037d40e:	6489      	s32i.n	a8, a4, 24
    dev->user1.usr_dummy_cyclelen = dummy_n - 1;
4037d410:	0020c0        	memw
4037d413:	7488      	l32i.n	a8, a4, 28
4037d415:	660b      	addi.n	a6, a6, -1
4037d417:	c0af92        	movi	a9, -64
4037d41a:	546060        	extui	a6, a6, 0, 6
4037d41d:	108890        	and	a8, a8, a9
4037d420:	206860        	or	a6, a8, a6
4037d423:	0020c0        	memw
4037d426:	076462        	s32i	a6, a4, 28
    spi_flash_ll_set_mosi_bitlen(dev, trans->mosi_len * 8);
4037d429:	0103c2        	l8ui	a12, a3, 1
    dev->user.usr_mosi = bitlen > 0;
4037d42c:	0020c0        	memw
4037d42f:	6468      	l32i.n	a6, a4, 24
4037d431:	dcf2a1        	l32r	a10, 403747fc <_iram_text_start+0x3f8>
4037d434:	080c      	movi.n	a8, 0
4037d436:	190c      	movi.n	a9, 1
4037d438:	8398c0        	moveqz	a9, a8, a12
4037d43b:	019950        	slli	a9, a9, 27
4037d43e:	1066a0        	and	a6, a6, a10
4037d441:	206690        	or	a6, a6, a9
4037d444:	0020c0        	memw
4037d447:	6469      	s32i.n	a6, a4, 24
    dev->mosi_dlen.usr_mosi_bit_len = bitlen ? (bitlen - 1) : 0;
4037d449:	071c87        	beq	a12, a8, 4037d454 <spi_flash_hal_common_command+0x90>
4037d44c:	118cd0        	slli	a8, a12, 3
4037d44f:	880b      	addi.n	a8, a8, -1
4037d451:	948080        	extui	a8, a8, 0, 10
4037d454:	0020c0        	memw
4037d457:	092462        	l32i	a6, a4, 36
4037d45a:	00ac92        	movi	a9, 0xfffffc00
4037d45d:	106690        	and	a6, a6, a9
4037d460:	206680        	or	a6, a6, a8
4037d463:	0020c0        	memw
4037d466:	096462        	s32i	a6, a4, 36
    spi_flash_ll_set_buffer_data(dev, trans->mosi_data, trans->mosi_len);
4037d469:	0223b2        	l32i	a11, a3, 8
4037d46c:	04ad      	mov.n	a10, a4
4037d46e:	ffbca5        	call8	4037d038 <spimem_flash_ll_set_buffer_data>
    dev->user.usr_miso = bitlen > 0;
4037d471:	0020c0        	memw
4037d474:	6488      	l32i.n	a8, a4, 24
4037d476:	dce2a1        	l32r	a10, 40374800 <_iram_text_start+0x3fc>
4037d479:	060c      	movi.n	a6, 0
4037d47b:	190c      	movi.n	a9, 1
4037d47d:	839650        	moveqz	a9, a6, a5
4037d480:	019940        	slli	a9, a9, 28
4037d483:	1088a0        	and	a8, a8, a10
4037d486:	208890        	or	a8, a8, a9
4037d489:	0020c0        	memw
4037d48c:	6489      	s32i.n	a8, a4, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037d48e:	071567        	beq	a5, a6, 4037d499 <spi_flash_hal_common_command+0xd5>
    spi_flash_ll_set_miso_bitlen(dev, trans->miso_len * 8);
4037d491:	1155d0        	slli	a5, a5, 3
4037d494:	550b      	addi.n	a5, a5, -1
4037d496:	946050        	extui	a6, a5, 0, 10
4037d499:	0020c0        	memw
4037d49c:	a458      	l32i.n	a5, a4, 40
4037d49e:	00ac82        	movi	a8, 0xfffffc00
4037d4a1:	105580        	and	a5, a5, a8
4037d4a4:	205560        	or	a5, a5, a6
4037d4a7:	0020c0        	memw
4037d4aa:	a459      	s32i.n	a5, a4, 40
    dev->cmd.usr = 1;
4037d4ac:	0020c0        	memw
4037d4af:	0458      	l32i.n	a5, a4, 0
4037d4b1:	160c      	movi.n	a6, 1
4037d4b3:	0166e0        	slli	a6, a6, 18
4037d4b6:	205560        	or	a5, a5, a6
4037d4b9:	0020c0        	memw
4037d4bc:	0459      	s32i.n	a5, a4, 0
    host->driver->poll_cmd_done(host);
4037d4be:	0258      	l32i.n	a5, a2, 0
4037d4c0:	02ad      	mov.n	a10, a2
4037d4c2:	102552        	l32i	a5, a5, 64
4037d4c5:	0005e0        	callx8	a5
    if (trans->miso_len > 0) {
4037d4c8:	0203c2        	l8ui	a12, a3, 2
4037d4cb:	5c8c      	beqz.n	a12, 4037d4d4 <spi_flash_hal_common_command+0x110>
        spi_flash_ll_get_buffer_data(dev, trans->miso_data, trans->miso_len);
4037d4cd:	33b8      	l32i.n	a11, a3, 12
4037d4cf:	04ad      	mov.n	a10, a4
4037d4d1:	ffbaa5        	call8	4037d07c <spimem_flash_ll_get_buffer_data>
}
4037d4d4:	020c      	movi.n	a2, 0
4037d4d6:	f01d      	retw.n

4037d4d8 <spi_flash_hal_read>:
{
4037d4d8:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d4db:	1268      	l32i.n	a6, a2, 4
{
4037d4dd:	02ad      	mov.n	a10, a2
    return dev->user.usr_addr ? dev->user1.usr_addr_bitlen + 1 : 0;
4037d4df:	0020c0        	memw
4037d4e2:	6688      	l32i.n	a8, a6, 24
4037d4e4:	0478e7        	bbci	a8, 30, 4037d4ec <spi_flash_hal_read+0x14>
4037d4e7:	0020c0        	memw
4037d4ea:	7688      	l32i.n	a8, a6, 28
    dev->addr = addr;
4037d4ec:	0020c0        	memw
4037d4ef:	1649      	s32i.n	a4, a6, 4
    dev->user.usr_miso = bitlen > 0;
4037d4f1:	0020c0        	memw
4037d4f4:	66d8      	l32i.n	a13, a6, 24
4037d4f6:	dcc2c1        	l32r	a12, 40374800 <_iram_text_start+0x3fc>
    spi_flash_ll_set_miso_bitlen(dev, read_len * 8);
4037d4f9:	1185d0        	slli	a8, a5, 3
4037d4fc:	090c      	movi.n	a9, 0
4037d4fe:	1b0c      	movi.n	a11, 1
4037d500:	83b980        	moveqz	a11, a9, a8
4037d503:	01bb40        	slli	a11, a11, 28
4037d506:	10ddc0        	and	a13, a13, a12
4037d509:	20ddb0        	or	a13, a13, a11
4037d50c:	0020c0        	memw
4037d50f:	66d9      	s32i.n	a13, a6, 24
    dev->miso_dlen.usr_miso_bit_len = bitlen ? (bitlen - 1) : 0;
4037d511:	041897        	beq	a8, a9, 4037d519 <spi_flash_hal_read+0x41>
4037d514:	880b      	addi.n	a8, a8, -1
4037d516:	949080        	extui	a9, a8, 0, 10
4037d519:	0020c0        	memw
4037d51c:	0a2682        	l32i	a8, a6, 40
4037d51f:	00acb2        	movi	a11, 0xfffffc00
4037d522:	1088b0        	and	a8, a8, a11
4037d525:	208890        	or	a8, a8, a9
4037d528:	0020c0        	memw
4037d52b:	0a6682        	s32i	a8, a6, 40
    dev->cmd.usr = 1;
4037d52e:	0020c0        	memw
4037d531:	002682        	l32i	a8, a6, 0
4037d534:	190c      	movi.n	a9, 1
4037d536:	0199e0        	slli	a9, a9, 18
4037d539:	208890        	or	a8, a8, a9
4037d53c:	0020c0        	memw
4037d53f:	0689      	s32i.n	a8, a6, 0
    host->driver->poll_cmd_done(host);
4037d541:	0a88      	l32i.n	a8, a10, 0
4037d543:	102882        	l32i	a8, a8, 64
4037d546:	0008e0        	callx8	a8
    if (read_len > 0) {
4037d549:	758c      	beqz.n	a5, 4037d554 <spi_flash_hal_read+0x7c>
        spi_flash_ll_get_buffer_data(dev, buffer, read_len);
4037d54b:	05cd      	mov.n	a12, a5
4037d54d:	03bd      	mov.n	a11, a3
4037d54f:	06ad      	mov.n	a10, a6
4037d551:	ffb2a5        	call8	4037d07c <spimem_flash_ll_get_buffer_data>
}
4037d554:	020c      	movi.n	a2, 0
4037d556:	f01d      	retw.n

4037d558 <spi_flash_hal_erase_sector>:
#endif
}

// Only support 24bit address
void spi_flash_hal_erase_sector(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037d558:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d55b:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d55d:	db7c      	movi.n	a11, -3
4037d55f:	0020c0        	memw
4037d562:	f898      	l32i.n	a9, a8, 60
4037d564:	02ad      	mov.n	a10, a2
4037d566:	1099b0        	and	a9, a9, a11
4037d569:	0020c0        	memw
4037d56c:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d56e:	0020c0        	memw
4037d571:	7898      	l32i.n	a9, a8, 28
4037d573:	dc79b1        	l32r	a11, 40374758 <_iram_text_start+0x354>
4037d576:	1099b0        	and	a9, a9, a11
4037d579:	7b1c      	movi.n	a11, 23
4037d57b:	01bb60        	slli	a11, a11, 26
4037d57e:	2099b0        	or	a9, a9, a11
4037d581:	0020c0        	memw
4037d584:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d586:	0020c0        	memw
4037d589:	6898      	l32i.n	a9, a8, 24
4037d58b:	1b0c      	movi.n	a11, 1
4037d58d:	01bb20        	slli	a11, a11, 30
4037d590:	2099b0        	or	a9, a9, a11
4037d593:	0020c0        	memw
4037d596:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037d598:	dccb91        	l32r	a9, 403748c4 <_iram_text_start+0x4c0>
    dev->cmd.flash_se = 1;
4037d59b:	1b0c      	movi.n	a11, 1
4037d59d:	103390        	and	a3, a3, a9
    dev->addr = addr;
4037d5a0:	0020c0        	memw
4037d5a3:	1839      	s32i.n	a3, a8, 4
    dev->ctrl.val = 0;
4037d5a5:	030c      	movi.n	a3, 0
4037d5a7:	0020c0        	memw
4037d5aa:	2839      	s32i.n	a3, a8, 8
    dev->cmd.flash_se = 1;
4037d5ac:	0020c0        	memw
4037d5af:	0898      	l32i.n	a9, a8, 0
4037d5b1:	01bb80        	slli	a11, a11, 24
4037d5b4:	2099b0        	or	a9, a9, a11
4037d5b7:	0020c0        	memw
4037d5ba:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_sector(dev);

#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037d5bc:	6238      	l32i.n	a3, a2, 24
4037d5be:	07e307        	bbsi	a3, 0, 4037d5c9 <spi_flash_hal_erase_sector+0x71>
        host->driver->poll_cmd_done(host);
4037d5c1:	0238      	l32i.n	a3, a2, 0
4037d5c3:	102332        	l32i	a3, a3, 64
4037d5c6:	0003e0        	callx8	a3
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037d5c9:	f01d      	retw.n
	...

4037d5cc <spi_flash_hal_erase_block>:

// Only support 24bit address
void spi_flash_hal_erase_block(spi_flash_host_inst_t *host, uint32_t start_address)
{
4037d5cc:	004136        	entry	a1, 32
4037d5cf:	1288      	l32i.n	a8, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d5d1:	db7c      	movi.n	a11, -3
4037d5d3:	0020c0        	memw
4037d5d6:	f898      	l32i.n	a9, a8, 60
4037d5d8:	02ad      	mov.n	a10, a2
4037d5da:	1099b0        	and	a9, a9, a11
4037d5dd:	0020c0        	memw
4037d5e0:	f899      	s32i.n	a9, a8, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d5e2:	0020c0        	memw
4037d5e5:	7898      	l32i.n	a9, a8, 28
4037d5e7:	dc5cb1        	l32r	a11, 40374758 <_iram_text_start+0x354>
4037d5ea:	1099b0        	and	a9, a9, a11
4037d5ed:	7b1c      	movi.n	a11, 23
4037d5ef:	01bb60        	slli	a11, a11, 26
4037d5f2:	2099b0        	or	a9, a9, a11
4037d5f5:	0020c0        	memw
4037d5f8:	7899      	s32i.n	a9, a8, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d5fa:	0020c0        	memw
4037d5fd:	6898      	l32i.n	a9, a8, 24
4037d5ff:	1b0c      	movi.n	a11, 1
4037d601:	01bb20        	slli	a11, a11, 30
4037d604:	2099b0        	or	a9, a9, a11
4037d607:	0020c0        	memw
4037d60a:	6899      	s32i.n	a9, a8, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, start_address & ADDRESS_MASK_24BIT);
4037d60c:	dcae91        	l32r	a9, 403748c4 <_iram_text_start+0x4c0>
    dev->cmd.flash_be = 1;
4037d60f:	1b0c      	movi.n	a11, 1
4037d611:	103390        	and	a3, a3, a9
    dev->addr = addr;
4037d614:	0020c0        	memw
4037d617:	1839      	s32i.n	a3, a8, 4
    dev->cmd.flash_be = 1;
4037d619:	0020c0        	memw
4037d61c:	0898      	l32i.n	a9, a8, 0
4037d61e:	01bb90        	slli	a11, a11, 23
4037d621:	2099b0        	or	a9, a9, a11
4037d624:	0020c0        	memw
4037d627:	0899      	s32i.n	a9, a8, 0
    spi_flash_ll_erase_block(dev);
#if SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037d629:	6238      	l32i.n	a3, a2, 24
4037d62b:	07e307        	bbsi	a3, 0, 4037d636 <spi_flash_hal_erase_block+0x6a>
        host->driver->poll_cmd_done(host);
4037d62e:	0238      	l32i.n	a3, a2, 0
4037d630:	102332        	l32i	a3, a3, 64
4037d633:	0003e0        	callx8	a3
    }
#else
    host->driver->poll_cmd_done(host);
#endif
}
4037d636:	f01d      	retw.n

4037d638 <spi_flash_hal_program_page>:

// Only support 24bit address
void spi_flash_hal_program_page(spi_flash_host_inst_t *host, const void *buffer, uint32_t address, uint32_t length)
{
4037d638:	004136        	entry	a1, 32
4037d63b:	1268      	l32i.n	a6, a2, 4
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d63d:	d97c      	movi.n	a9, -3
4037d63f:	0020c0        	memw
4037d642:	f688      	l32i.n	a8, a6, 60
    spimem_flash_ll_set_buffer_data(dev, buffer, length);
4037d644:	06ad      	mov.n	a10, a6
    dev->cache_fctrl.usr_cmd_4byte = (bitlen == 32) ? 1 : 0 ;
4037d646:	108890        	and	a8, a8, a9
4037d649:	0020c0        	memw
4037d64c:	f689      	s32i.n	a8, a6, 60
    dev->user1.usr_addr_bitlen = (bitlen - 1);
4037d64e:	0020c0        	memw
4037d651:	7688      	l32i.n	a8, a6, 28
4037d653:	dc4191        	l32r	a9, 40374758 <_iram_text_start+0x354>
4037d656:	05cd      	mov.n	a12, a5
4037d658:	108890        	and	a8, a8, a9
4037d65b:	791c      	movi.n	a9, 23
4037d65d:	019960        	slli	a9, a9, 26
4037d660:	208890        	or	a8, a8, a9
4037d663:	0020c0        	memw
4037d666:	7689      	s32i.n	a8, a6, 28
    dev->user.usr_addr = bitlen ? 1 : 0;
4037d668:	0020c0        	memw
4037d66b:	6688      	l32i.n	a8, a6, 24
4037d66d:	190c      	movi.n	a9, 1
4037d66f:	019920        	slli	a9, a9, 30
4037d672:	208890        	or	a8, a8, a9
4037d675:	0020c0        	memw
4037d678:	6689      	s32i.n	a8, a6, 24
    spi_dev_t *dev = get_spi_dev(host);
    spi_flash_ll_set_addr_bitlen(dev, 24);
    spi_flash_ll_set_address(dev, (address & ADDRESS_MASK_24BIT) | (length << 24));
4037d67a:	dc9281        	l32r	a8, 403748c4 <_iram_text_start+0x4c0>
    spimem_flash_ll_set_buffer_data(dev, buffer, length);
4037d67d:	03bd      	mov.n	a11, a3
4037d67f:	104480        	and	a4, a4, a8
4037d682:	018580        	slli	a8, a5, 24
4037d685:	204480        	or	a4, a4, a8
    dev->addr = addr;
4037d688:	0020c0        	memw
4037d68b:	1649      	s32i.n	a4, a6, 4
    dev->user.usr_dummy = 0;
4037d68d:	0020c0        	memw
4037d690:	6648      	l32i.n	a4, a6, 24
4037d692:	dc5981        	l32r	a8, 403747f8 <_iram_text_start+0x3f4>
4037d695:	104480        	and	a4, a4, a8
4037d698:	0020c0        	memw
4037d69b:	6649      	s32i.n	a4, a6, 24
    spimem_flash_ll_set_buffer_data(dev, buffer, length);
4037d69d:	ff99a5        	call8	4037d038 <spimem_flash_ll_set_buffer_data>
    dev->cmd.flash_pp = 1;
4037d6a0:	180c      	movi.n	a8, 1
4037d6a2:	0020c0        	memw
4037d6a5:	0648      	l32i.n	a4, a6, 0
4037d6a7:	018870        	slli	a8, a8, 25
4037d6aa:	204480        	or	a4, a4, a8
4037d6ad:	0020c0        	memw
4037d6b0:	0649      	s32i.n	a4, a6, 0
    spi_flash_ll_program_page(dev, buffer, length);
    host->driver->poll_cmd_done(host);
4037d6b2:	0248      	l32i.n	a4, a2, 0
4037d6b4:	02ad      	mov.n	a10, a2
4037d6b6:	102442        	l32i	a4, a4, 64
4037d6b9:	0004e0        	callx8	a4
}
4037d6bc:	f01d      	retw.n
	...

4037d6c0 <spi_flash_hal_setup_read_suspend>:
    //status and sus_status should be mutual exclusion
    return (status | sus_status);
}

esp_err_t spi_flash_hal_setup_read_suspend(spi_flash_host_inst_t *host, const spi_flash_sus_cmd_conf *sus_conf)
{
4037d6c0:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
    spi_mem_dev_t *dev = (spi_mem_dev_t *)spi_flash_ll_get_hw(SPI1_HOST);
    spi_flash_hal_context_t* ctx = (spi_flash_hal_context_t*)host;
    memcpy(&(ctx->sus_cfg), sus_conf, sizeof(spi_flash_sus_cmd_conf));
4037d6c3:	8c0c      	movi.n	a12, 8
4037d6c5:	03bd      	mov.n	a11, a3
4037d6c7:	1cc2a2        	addi	a10, a2, 28
4037d6ca:	db7981        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037d6cd:	0008e0        	callx8	a8
    abort();// Not supported on esp32s3
4037d6d0:	010aa5        	call8	4037e77c <abort>
	...

4037d6d4 <spi_flash_hal_setup_auto_suspend_mode>:
    return ESP_OK;
}

#if SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND
void spi_flash_hal_setup_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037d6d4:	006136        	entry	a1, 48
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05); // Set the command to send, to fetch flash status reg value.
4037d6d7:	dc4381        	l32r	a8, 403747e4 <_iram_text_start+0x3e0>
4037d6da:	03aca2        	movi	a10, 0xfffffc03
4037d6dd:	0020c0        	memw
4037d6e0:	262892        	l32i	a9, a8, 152
4037d6e3:	0020c0        	memw
4037d6e6:	0199      	s32i.n	a9, a1, 0
4037d6e8:	0020c0        	memw
4037d6eb:	0198      	l32i.n	a9, a1, 0
4037d6ed:	1099a0        	and	a9, a9, a10
4037d6f0:	4a1c      	movi.n	a10, 20
4037d6f2:	2099a0        	or	a9, a9, a10
4037d6f5:	0020c0        	memw
4037d6f8:	0199      	s32i.n	a9, a1, 0
4037d6fa:	0020c0        	memw
4037d6fd:	0198      	l32i.n	a9, a1, 0
    dev->flash_waiti_ctrl.waiti_en = auto_waiti;  // enable auto wait-idle function.
4037d6ff:	1a0c      	movi.n	a10, 1
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05); // Set the command to send, to fetch flash status reg value.
4037d701:	0020c0        	memw
4037d704:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = auto_waiti;  // enable auto wait-idle function.
4037d707:	0020c0        	memw
4037d70a:	262892        	l32i	a9, a8, 152
4037d70d:	2099a0        	or	a9, a9, a10
4037d710:	0020c0        	memw
4037d713:	266892        	s32i	a9, a8, 152
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037d716:	0020c0        	memw
4037d719:	282892        	l32i	a9, a8, 160
4037d71c:	2099a0        	or	a9, a9, a10
4037d71f:	0020c0        	memw
4037d722:	286892        	s32i	a9, a8, 160
    spimem_flash_ll_auto_wait_idle_init(dev, true);
    spimem_flash_ll_auto_suspend_init(dev, true);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, true);
#endif
}
4037d725:	f01d      	retw.n
	...

4037d728 <spi_flash_hal_disable_auto_suspend_mode>:
    spimem_flash_ll_res_check_sus_setup(dev, true);
#endif
}

void spi_flash_hal_disable_auto_suspend_mode(spi_flash_host_inst_t *host)
{
4037d728:	006136        	entry	a1, 48
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05); // Set the command to send, to fetch flash status reg value.
4037d72b:	dc2e81        	l32r	a8, 403747e4 <_iram_text_start+0x3e0>
4037d72e:	03aca2        	movi	a10, 0xfffffc03
4037d731:	0020c0        	memw
4037d734:	262892        	l32i	a9, a8, 152
4037d737:	0020c0        	memw
4037d73a:	0199      	s32i.n	a9, a1, 0
4037d73c:	0020c0        	memw
4037d73f:	0198      	l32i.n	a9, a1, 0
4037d741:	1099a0        	and	a9, a9, a10
4037d744:	4a1c      	movi.n	a10, 20
4037d746:	2099a0        	or	a9, a9, a10
4037d749:	0020c0        	memw
4037d74c:	0199      	s32i.n	a9, a1, 0
4037d74e:	0020c0        	memw
4037d751:	0198      	l32i.n	a9, a1, 0
    dev->flash_waiti_ctrl.waiti_en = auto_waiti;  // enable auto wait-idle function.
4037d753:	ea7c      	movi.n	a10, -2
    HAL_FORCE_MODIFY_U32_REG_FIELD(dev->flash_waiti_ctrl, waiti_cmd, 0x05); // Set the command to send, to fetch flash status reg value.
4037d755:	0020c0        	memw
4037d758:	266892        	s32i	a9, a8, 152
    dev->flash_waiti_ctrl.waiti_en = auto_waiti;  // enable auto wait-idle function.
4037d75b:	0020c0        	memw
4037d75e:	262892        	l32i	a9, a8, 152
4037d761:	1099a0        	and	a9, a9, a10
4037d764:	0020c0        	memw
4037d767:	266892        	s32i	a9, a8, 152
    dev->flash_sus_ctrl.flash_pes_en = auto_sus; // enable Flash Auto-Suspend.
4037d76a:	0020c0        	memw
4037d76d:	282892        	l32i	a9, a8, 160
4037d770:	1099a0        	and	a9, a9, a10
4037d773:	0020c0        	memw
4037d776:	286892        	s32i	a9, a8, 160
    spimem_flash_ll_auto_wait_idle_init(dev, false);
    spimem_flash_ll_auto_suspend_init(dev, false);
#if SOC_SPI_MEM_SUPPORT_CHECK_SUS
    spimem_flash_ll_sus_check_sus_setup(dev, false);
#endif
}
4037d779:	f01d      	retw.n
	...

4037d77c <spi_flash_hal_device_config>:
{
4037d77c:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d77f:	1238      	l32i.n	a3, a2, 4
    dev->user.val = 0;
4037d781:	0b0c      	movi.n	a11, 0
4037d783:	0020c0        	memw
4037d786:	63b9      	s32i.n	a11, a3, 24
    dev->ctrl.val = 0;
4037d788:	0020c0        	memw
4037d78b:	23b9      	s32i.n	a11, a3, 8
    dev->misc.cs0_dis = (pin == 0) ? 0 : 1;
4037d78d:	0020c0        	memw
4037d790:	d398      	l32i.n	a9, a3, 52
    spi_flash_ll_set_cs_pin(dev, ctx->cs_num);
4037d792:	22c8      	l32i.n	a12, a2, 8
{
4037d794:	02ad      	mov.n	a10, a2
4037d796:	180c      	movi.n	a8, 1
4037d798:	0b2d      	mov.n	a2, a11
4037d79a:	ed7c      	movi.n	a13, -2
4037d79c:	9328c0        	movnez	a2, a8, a12
4037d79f:	1099d0        	and	a9, a9, a13
4037d7a2:	209920        	or	a9, a9, a2
4037d7a5:	0020c0        	memw
4037d7a8:	d399      	s32i.n	a9, a3, 52
    dev->misc.cs1_dis = (pin == 1) ? 0 : 1;
4037d7aa:	0020c0        	memw
4037d7ad:	d398      	l32i.n	a9, a3, 52
4037d7af:	cc0b      	addi.n	a12, a12, -1
4037d7b1:	0bdd      	mov.n	a13, a11
4037d7b3:	93d8c0        	movnez	a13, a8, a12
4037d7b6:	d27c      	movi.n	a2, -3
4037d7b8:	cdda      	add.n	a12, a13, a13
4037d7ba:	109920        	and	a9, a9, a2
4037d7bd:	2099c0        	or	a9, a9, a12
4037d7c0:	0020c0        	memw
4037d7c3:	d399      	s32i.n	a9, a3, 52
    dev->clock.val = *clock_val;
4037d7c5:	0020c0        	memw
4037d7c8:	4a28      	l32i.n	a2, a10, 16
}

static inline void spimem_flash_ll_set_hold(spi_mem_dev_t *dev, uint32_t hold_n)
{
    dev->ctrl2.cs_hold_time = hold_n - 1;
4037d7ca:	1facd2        	movi	a13, 0xfffffc1f
    dev->clock.val = *clock_val;
4037d7cd:	0020c0        	memw
4037d7d0:	5329      	s32i.n	a2, a3, 20
    int cs_hold = ctx->cs_hold;
4037d7d2:	0e0a22        	l8ui	a2, a10, 14
    dev->ctrl2.cs_hold_time = hold_n - 1;
4037d7d5:	0020c0        	memw
4037d7d8:	4398      	l32i.n	a9, a3, 16
4037d7da:	c20b      	addi.n	a12, a2, -1
4037d7dc:	44c0c0        	extui	a12, a12, 0, 5
4037d7df:	11ccb0        	slli	a12, a12, 5
4037d7e2:	1099d0        	and	a9, a9, a13
4037d7e5:	2099c0        	or	a9, a9, a12
4037d7e8:	0020c0        	memw
4037d7eb:	4399      	s32i.n	a9, a3, 16
    dev->user.cs_hold = (hold_n > 0? 1: 0);
4037d7ed:	0020c0        	memw
4037d7f0:	6398      	l32i.n	a9, a3, 24
4037d7f2:	0bcd      	mov.n	a12, a11
4037d7f4:	93c820        	movnez	a12, a8, a2
4037d7f7:	bfaf22        	movi	a2, -65
4037d7fa:	109920        	and	a9, a9, a2
4037d7fd:	11cca0        	slli	a12, a12, 6
4037d800:	2099c0        	or	a9, a9, a12
4037d803:	0020c0        	memw
4037d806:	6399      	s32i.n	a9, a3, 24
    spi_flash_ll_set_cs_setup(dev, ctx->cs_setup);
4037d808:	0d0a92        	l8ui	a9, a10, 13
}

static inline void spimem_flash_ll_set_cs_setup(spi_mem_dev_t *dev, uint32_t cs_setup_time)
{
    dev->user.cs_setup = (cs_setup_time > 0 ? 1 : 0);
4037d80b:	7faf22        	movi	a2, -129
4037d80e:	838b90        	moveqz	a8, a11, a9
4037d811:	0020c0        	memw
4037d814:	63b8      	l32i.n	a11, a3, 24
4037d816:	118890        	slli	a8, a8, 7
4037d819:	10bb20        	and	a11, a11, a2
4037d81c:	208b80        	or	a8, a11, a8
4037d81f:	0020c0        	memw
4037d822:	6389      	s32i.n	a8, a3, 24
    dev->ctrl2.cs_setup_time = cs_setup_time - 1;
4037d824:	0020c0        	memw
4037d827:	4388      	l32i.n	a8, a3, 16
4037d829:	026c      	movi.n	a2, -32
4037d82b:	990b      	addi.n	a9, a9, -1
4037d82d:	108820        	and	a8, a8, a2
4037d830:	449090        	extui	a9, a9, 0, 5
4037d833:	208890        	or	a8, a8, a9
4037d836:	0020c0        	memw
4037d839:	4389      	s32i.n	a8, a3, 16
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) != 0) {
4037d83b:	062a22        	l32i	a2, a10, 24
4037d83e:	2f6207        	bbci	a2, 0, 4037d871 <spi_flash_hal_device_config+0xf5>
        spi_flash_hal_setup_auto_suspend_mode(host);
4037d841:	ffe925        	call8	4037d6d4 <spi_flash_hal_setup_auto_suspend_mode>
    if ((ctx->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME) != 0) {
4037d844:	dbe881        	l32r	a8, 403747e4 <_iram_text_start+0x3e0>
    dev->misc.auto_per = auto_res;
4037d847:	0020c0        	memw
4037d84a:	d898      	l32i.n	a9, a8, 52
4037d84c:	286217        	bbci	a2, 1, 4037d878 <spi_flash_hal_device_config+0xfc>
4037d84f:	1a0c      	movi.n	a10, 1
4037d851:	11aa50        	slli	a10, a10, 11
4037d854:	2099a0        	or	a9, a9, a10
4037d857:	0020c0        	memw
4037d85a:	d899      	s32i.n	a9, a8, 52
}

static inline void spimem_flash_ll_set_extra_dummy(spi_mem_dev_t *dev, uint32_t extra_dummy)
{
    dev->timing_cali.extra_dummy_cyclelen = extra_dummy;
4037d85c:	0020c0        	memw
4037d85f:	2a2382        	l32i	a8, a3, 168
4037d862:	326c      	movi.n	a2, -29
4037d864:	108820        	and	a8, a8, a2
4037d867:	0020c0        	memw
4037d86a:	2a6382        	s32i	a8, a3, 168
}
4037d86d:	020c      	movi.n	a2, 0
4037d86f:	f01d      	retw.n
        spi_flash_hal_disable_auto_suspend_mode(host);
4037d871:	ffeb65        	call8	4037d728 <spi_flash_hal_disable_auto_suspend_mode>
4037d874:	fff306        	j	4037d844 <spi_flash_hal_device_config+0xc8>
4037d877:	00          	.byte 00
    dev->misc.auto_per = auto_res;
4037d878:	dc5e21        	l32r	a2, 403749f0 <_iram_text_start+0x5ec>
4037d87b:	109920        	and	a9, a9, a2
4037d87e:	fff546        	j	4037d857 <spi_flash_hal_device_config+0xdb>
4037d881:	000000        	ill

4037d884 <spi_flash_hal_poll_cmd_done>:
{
4037d884:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d887:	1298      	l32i.n	a9, a2, 4
    return (dev->cmd.val == 0);
4037d889:	0020c0        	memw
4037d88c:	0988      	l32i.n	a8, a9, 0
    while (!spi_flash_ll_cmd_is_done(get_spi_dev(host))) {
4037d88e:	ff7856        	bnez	a8, 4037d889 <spi_flash_hal_poll_cmd_done+0x5>
}
4037d891:	f01d      	retw.n
	...

4037d894 <spi_flash_hal_erase_chip>:
{
4037d894:	004136        	entry	a1, 32
    return ((spi_flash_hal_context_t*)host)->spi;
4037d897:	12b8      	l32i.n	a11, a2, 4
    dev->cmd.flash_ce = 1;
4037d899:	190c      	movi.n	a9, 1
4037d89b:	0020c0        	memw
4037d89e:	0b88      	l32i.n	a8, a11, 0
4037d8a0:	0199a0        	slli	a9, a9, 22
4037d8a3:	208890        	or	a8, a8, a9
4037d8a6:	0020c0        	memw
4037d8a9:	0b89      	s32i.n	a8, a11, 0
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037d8ab:	6288      	l32i.n	a8, a2, 24
{
4037d8ad:	02ad      	mov.n	a10, a2
    if((((spi_flash_hal_context_t*)host)->flags & SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND) == 0) {
4037d8af:	07e807        	bbsi	a8, 0, 4037d8ba <spi_flash_hal_erase_chip+0x26>
        host->driver->poll_cmd_done(host);
4037d8b2:	0288      	l32i.n	a8, a2, 0
4037d8b4:	102882        	l32i	a8, a8, 64
4037d8b7:	0008e0        	callx8	a8
}
4037d8ba:	f01d      	retw.n

4037d8bc <spi_flash_hal_set_write_protect>:
{
4037d8bc:	004136        	entry	a1, 32
4037d8bf:	1298      	l32i.n	a9, a2, 4
4037d8c1:	743030        	extui	a3, a3, 0, 8
        dev->cmd.flash_wrdi = 1;
4037d8c4:	0020c0        	memw
4037d8c7:	09b8      	l32i.n	a11, a9, 0
4037d8c9:	02ad      	mov.n	a10, a2
4037d8cb:	180c      	movi.n	a8, 1
    if (wp) {
4037d8cd:	739c      	beqz.n	a3, 4037d8e8 <spi_flash_hal_set_write_protect+0x2c>
        dev->cmd.flash_wrdi = 1;
4037d8cf:	018830        	slli	a8, a8, 29
        dev->cmd.flash_wren = 1;
4037d8d2:	208b80        	or	a8, a11, a8
4037d8d5:	0020c0        	memw
4037d8d8:	0989      	s32i.n	a8, a9, 0
    host->driver->poll_cmd_done(host);
4037d8da:	0a88      	l32i.n	a8, a10, 0
}
4037d8dc:	020c      	movi.n	a2, 0
    host->driver->poll_cmd_done(host);
4037d8de:	102882        	l32i	a8, a8, 64
4037d8e1:	0008e0        	callx8	a8
}
4037d8e4:	f01d      	retw.n
4037d8e6:	00          	.byte 00
4037d8e7:	00          	.byte 00
4037d8e8:	018820        	slli	a8, a8, 30
4037d8eb:	fff8c6        	j	4037d8d2 <spi_flash_hal_set_write_protect+0x16>
	...

4037d8f0 <spi_flash_hal_check_status>:
{
4037d8f0:	004136        	entry	a1, 32
4037d8f3:	1228      	l32i.n	a2, a2, 4
    return dev->fsm.st == 0;
4037d8f5:	0a0c      	movi.n	a10, 0
4037d8f7:	0020c0        	memw
4037d8fa:	152292        	l32i	a9, a2, 84
    return dev->sus_status.flash_sus;
4037d8fd:	0020c0        	memw
4037d900:	292282        	l32i	a8, a2, 164
    return dev->fsm.st == 0;
4037d903:	249090        	extui	a9, a9, 0, 3
    return dev->sus_status.flash_sus;
4037d906:	048080        	extui	a8, a8, 0, 1
    return dev->fsm.st == 0;
4037d909:	120c      	movi.n	a2, 1
4037d90b:	932a90        	movnez	a2, a10, a9
    uint32_t sus_status = spimem_flash_ll_sus_status((spi_mem_dev_t*)dev) << 1;
4037d90e:	888a      	add.n	a8, a8, a8
}
4037d910:	202280        	or	a2, a2, a8
4037d913:	f01d      	retw.n
4037d915:	000000        	ill

4037d918 <spi_flash_hal_resume>:
#endif
}
#endif // SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND

void spi_flash_hal_resume(spi_flash_host_inst_t *host)
{
4037d918:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_resume((spi_mem_dev_t*)(((spi_flash_hal_context_t *)host)->spi));
4037d91b:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_per = 1;
4037d91d:	1a0c      	movi.n	a10, 1
4037d91f:	0020c0        	memw
4037d922:	272982        	l32i	a8, a9, 156
4037d925:	2088a0        	or	a8, a8, a10
4037d928:	0020c0        	memw
4037d92b:	276982        	s32i	a8, a9, 156
#else
    abort();
#endif
}
4037d92e:	f01d      	retw.n

4037d930 <spi_flash_hal_suspend>:

void spi_flash_hal_suspend(spi_flash_host_inst_t *host)
{
4037d930:	004136        	entry	a1, 32
#if SOC_SPI_MEM_SUPPORT_SW_SUSPEND
    spimem_flash_ll_suspend((spi_mem_dev_t *)(((spi_flash_hal_context_t *)host)->spi));
4037d933:	1298      	l32i.n	a9, a2, 4
    dev->flash_sus_cmd.flash_pes = 1;
4037d935:	2a0c      	movi.n	a10, 2
4037d937:	0020c0        	memw
4037d93a:	272982        	l32i	a8, a9, 156
4037d93d:	2088a0        	or	a8, a8, a10
4037d940:	0020c0        	memw
4037d943:	276982        	s32i	a8, a9, 156
#else
    abort();
#endif
}
4037d946:	f01d      	retw.n

4037d948 <systimer_hal_init>:
#include "hal/systimer_ll.h"
#include "hal/systimer_types.h"
#include "hal/assert.h"

void systimer_hal_init(systimer_hal_context_t *hal)
{
4037d948:	004136        	entry	a1, 32
    hal->dev = &SYSTIMER;
4037d94b:	dd4e81        	l32r	a8, 40374e84 <_iram_text_start+0xa80>
    dev->conf.clk_en = en;
4037d94e:	fa7c      	movi.n	a10, -1
4037d950:	0020c0        	memw
4037d953:	0898      	l32i.n	a9, a8, 0
4037d955:	01aa10        	slli	a10, a10, 31
4037d958:	0289      	s32i.n	a8, a2, 0
4037d95a:	2099a0        	or	a9, a9, a10
4037d95d:	0020c0        	memw
4037d960:	0899      	s32i.n	a9, a8, 0
    systimer_ll_enable_clock(hal->dev, true);
}
4037d962:	f01d      	retw.n

4037d964 <systimer_hal_get_counter_value>:
    hal->ticks_to_us = ops->ticks_to_us;
    hal->us_to_ticks = ops->us_to_ticks;
}

uint64_t systimer_hal_get_counter_value(systimer_hal_context_t *hal, uint32_t counter_id)
{
4037d964:	006136        	entry	a1, 48
    uint32_t lo, lo_start, hi;
    /* Set the "update" bit and wait for acknowledgment */
    systimer_ll_counter_snapshot(hal->dev, counter_id);
4037d967:	0288      	l32i.n	a8, a2, 0
    dev->unit_op[counter_id].timer_unit_update = 1;
4037d969:	01a0a2        	movi	a10, 1
4037d96c:	a02380        	addx4	a2, a3, a8
4037d96f:	0020c0        	memw
4037d972:	1298      	l32i.n	a9, a2, 4
4037d974:	01aa20        	slli	a10, a10, 30
4037d977:	2099a0        	or	a9, a9, a10
4037d97a:	0020c0        	memw
4037d97d:	016292        	s32i	a9, a2, 4
    return dev->unit_op[counter_id].timer_unit_value_valid;
4037d980:	0020c0        	memw
4037d983:	1298      	l32i.n	a9, a2, 4
    while (!systimer_ll_is_counter_value_valid(hal->dev, counter_id));
4037d985:	f779d7        	bbci	a9, 29, 4037d980 <systimer_hal_get_counter_value+0x1c>
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037d988:	b09380        	addx8	a9, a3, a8
4037d98b:	0020c0        	memw
4037d98e:	112922        	l32i	a2, a9, 68
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
4037d991:	338b      	addi.n	a3, a3, 8
4037d993:	dd3db1        	l32r	a11, 40374e88 <_iram_text_start+0xa84>
4037d996:	b08380        	addx8	a8, a3, a8
4037d999:	0020c0        	memw
4037d99c:	0838      	l32i.n	a3, a8, 0
4037d99e:	02ad      	mov.n	a10, a2
    return dev->unit_val[counter_id].lo.timer_unit_value_lo;
4037d9a0:	0020c0        	memw
4037d9a3:	112922        	l32i	a2, a9, 68
    return dev->unit_val[counter_id].hi.timer_unit_value_hi;
4037d9a6:	1033b0        	and	a3, a3, a11
    lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    do {
        lo = lo_start;
        hi = systimer_ll_get_counter_value_high(hal->dev, counter_id);
        lo_start = systimer_ll_get_counter_value_low(hal->dev, counter_id);
    } while (lo_start != lo);
4037d9a9:	ec9a27        	bne	a10, a2, 4037d999 <systimer_hal_get_counter_value+0x35>
        .lo = lo,
        .hi = hi
    };

    return result.val;
}
4037d9ac:	f01d      	retw.n
	...

4037d9b0 <systimer_hal_set_alarm_target>:
    return hal->ticks_to_us(systimer_hal_get_counter_value(hal, counter_id));
}

#if SOC_SYSTIMER_ALARM_MISS_COMPENSATE
void systimer_hal_set_alarm_target(systimer_hal_context_t *hal, uint32_t alarm_id, uint64_t target)
{
4037d9b0:	004136        	entry	a1, 32
    systimer_counter_value_t alarm = {
        .val = hal->us_to_ticks(target),
4037d9b3:	2288      	l32i.n	a8, a2, 8
4037d9b5:	04ad      	mov.n	a10, a4
4037d9b7:	05bd      	mov.n	a11, a5
4037d9b9:	0008e0        	callx8	a8
    };
    systimer_ll_enable_alarm(hal->dev, alarm_id, false);
4037d9bc:	02d8      	l32i.n	a13, a2, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
4037d9be:	881c      	movi.n	a8, 24
4037d9c0:	c08830        	sub	a8, a8, a3
4037d9c3:	1f0c      	movi.n	a15, 1
4037d9c5:	0020c0        	memw
4037d9c8:	0d28      	l32i.n	a2, a13, 0
4037d9ca:	401800        	ssl	a8
4037d9cd:	a18f00        	sll	a8, a15
4037d9d0:	fe7c      	movi.n	a14, -1
4037d9d2:	309e80        	xor	a9, a14, a8
4037d9d5:	109920        	and	a9, a9, a2
4037d9d8:	0020c0        	memw
4037d9db:	0d99      	s32i.n	a9, a13, 0
    dev->target_val[alarm_id].hi.timer_target_hi = value >> 32;
4037d9dd:	932b      	addi.n	a9, a3, 2
4037d9df:	b099d0        	addx8	a9, a9, a13
4037d9e2:	0020c0        	memw
4037d9e5:	39c8      	l32i.n	a12, a9, 12
4037d9e7:	dd2821        	l32r	a2, 40374e88 <_iram_text_start+0xa84>
4037d9ea:	01eec0        	slli	a14, a14, 20
4037d9ed:	10bb20        	and	a11, a11, a2
4037d9f0:	10cce0        	and	a12, a12, a14
4037d9f3:	20ccb0        	or	a12, a12, a11
4037d9f6:	0020c0        	memw
4037d9f9:	39c9      	s32i.n	a12, a9, 12
    dev->comp_load[alarm_id].val = 0x01;
4037d9fb:	14c332        	addi	a3, a3, 20
    dev->target_val[alarm_id].lo.timer_target_lo = value & 0xFFFFFFFF;
4037d9fe:	0020c0        	memw
4037da01:	49a9      	s32i.n	a10, a9, 16
    dev->comp_load[alarm_id].val = 0x01;
4037da03:	a033d0        	addx4	a3, a3, a13
4037da06:	0020c0        	memw
4037da09:	03f9      	s32i.n	a15, a3, 0
        dev->conf.val |= 1 << (24 - alarm_id);
4037da0b:	0020c0        	memw
4037da0e:	0d28      	l32i.n	a2, a13, 0
4037da10:	208820        	or	a8, a8, a2
4037da13:	0020c0        	memw
4037da16:	0d89      	s32i.n	a8, a13, 0
    systimer_ll_set_alarm_target(hal->dev, alarm_id, alarm.val);
    systimer_ll_apply_alarm_value(hal->dev, alarm_id);
    systimer_ll_enable_alarm(hal->dev, alarm_id, true);
}
4037da18:	f01d      	retw.n
	...

4037da1c <systimer_hal_set_alarm_period>:
    } while (1);
}
#endif // SOC_SYSTIMER_ALARM_MISS_COMPENSATE

void systimer_hal_set_alarm_period(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t period)
{
4037da1c:	006136        	entry	a1, 48
    systimer_ll_enable_alarm(hal->dev, alarm_id, false);
4037da1f:	0288      	l32i.n	a8, a2, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
4037da21:	851c      	movi.n	a5, 24
4037da23:	c05530        	sub	a5, a5, a3
4037da26:	160c      	movi.n	a6, 1
4037da28:	0020c0        	memw
4037da2b:	08a8      	l32i.n	a10, a8, 0
4037da2d:	401500        	ssl	a5
4037da30:	a15600        	sll	a5, a6
4037da33:	f77c      	movi.n	a7, -1
4037da35:	309750        	xor	a9, a7, a5
4037da38:	1099a0        	and	a9, a9, a10
4037da3b:	0020c0        	memw
4037da3e:	0899      	s32i.n	a9, a8, 0
    systimer_ll_set_alarm_period(hal->dev, alarm_id, hal->us_to_ticks(period));
4037da40:	2298      	l32i.n	a9, a2, 8
4037da42:	04ad      	mov.n	a10, a4
4037da44:	0189      	s32i.n	a8, a1, 0
4037da46:	0b0c      	movi.n	a11, 0
4037da48:	0009e0        	callx8	a9
    HAL_ASSERT(period < (1 << 26));
4037da4b:	db4391        	l32r	a9, 40374758 <_iram_text_start+0x354>
4037da4e:	0188      	l32i.n	a8, a1, 0
4037da50:	0eb9a7        	bgeu	a9, a10, 4037da62 <systimer_hal_set_alarm_period+0x46>
4037da53:	dd0ed1        	l32r	a13, 40374e8c <_iram_text_start+0xa88>
4037da56:	dd0ec1        	l32r	a12, 40374e90 <_iram_text_start+0xa8c>
4037da59:	dd0ea1        	l32r	a10, 40374e94 <_iram_text_start+0xa90>
4037da5c:	72a0b2        	movi	a11, 114
4037da5f:	00dae5        	call8	4037e80c <__assert_func>
    dev->target_conf[alarm_id].target_period = period;
4037da62:	10aa90        	and	a10, a10, a9
4037da65:	93cb      	addi.n	a9, a3, 12
4037da67:	a09980        	addx4	a9, a9, a8
4037da6a:	0020c0        	memw
4037da6d:	1988      	l32i.n	a8, a9, 4
4037da6f:	017760        	slli	a7, a7, 26
    systimer_ll_apply_alarm_value(hal->dev, alarm_id);
4037da72:	0228      	l32i.n	a2, a2, 0
4037da74:	108870        	and	a8, a8, a7
4037da77:	2088a0        	or	a8, a8, a10
    dev->comp_load[alarm_id].val = 0x01;
4037da7a:	14c332        	addi	a3, a3, 20
    dev->target_conf[alarm_id].target_period = period;
4037da7d:	0020c0        	memw
4037da80:	1989      	s32i.n	a8, a9, 4
    dev->comp_load[alarm_id].val = 0x01;
4037da82:	a03320        	addx4	a3, a3, a2
4037da85:	0020c0        	memw
4037da88:	0369      	s32i.n	a6, a3, 0
        dev->conf.val |= 1 << (24 - alarm_id);
4037da8a:	0020c0        	memw
4037da8d:	0238      	l32i.n	a3, a2, 0
4037da8f:	205530        	or	a5, a5, a3
4037da92:	0020c0        	memw
4037da95:	0259      	s32i.n	a5, a2, 0
    systimer_ll_enable_alarm(hal->dev, alarm_id, true);
}
4037da97:	f01d      	retw.n
4037da99:	000000        	ill

4037da9c <systimer_hal_counter_value_advance>:
{
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
}

void systimer_hal_counter_value_advance(systimer_hal_context_t *hal, uint32_t counter_id, int64_t time_us)
{
4037da9c:	004136        	entry	a1, 32
    systimer_counter_value_t new_count = {
        .val = systimer_hal_get_counter_value(hal, counter_id) + hal->us_to_ticks(time_us),
4037da9f:	03bd      	mov.n	a11, a3
4037daa1:	02ad      	mov.n	a10, a2
4037daa3:	ffec25        	call8	4037d964 <systimer_hal_get_counter_value>
4037daa6:	22c8      	l32i.n	a12, a2, 8
4037daa8:	0a6d      	mov.n	a6, a10
4037daaa:	0b7d      	mov.n	a7, a11
4037daac:	04ad      	mov.n	a10, a4
4037daae:	05bd      	mov.n	a11, a5
4037dab0:	000ce0        	callx8	a12
4037dab3:	a6aa      	add.n	a10, a6, a10
4037dab5:	180c      	movi.n	a8, 1
4037dab7:	013a67        	bltu	a10, a6, 4037dabc <systimer_hal_counter_value_advance+0x20>
4037daba:	080c      	movi.n	a8, 0
    };
    systimer_ll_set_counter_value(hal->dev, counter_id, new_count.val);
4037dabc:	0228      	l32i.n	a2, a2, 0
        .val = systimer_hal_get_counter_value(hal, counter_id) + hal->us_to_ticks(time_us),
4037dabe:	57ba      	add.n	a5, a7, a11
    dev->unit_load_val[counter_id].hi.timer_unit_load_hi = value >> 32;
4037dac0:	b0b320        	addx8	a11, a3, a2
4037dac3:	0020c0        	memw
4037dac6:	3b98      	l32i.n	a9, a11, 12
4037dac8:	885a      	add.n	a8, a8, a5
4037daca:	fc7c      	movi.n	a12, -1
4037dacc:	dcef51        	l32r	a5, 40374e88 <_iram_text_start+0xa84>
4037dacf:	01ccc0        	slli	a12, a12, 20
4037dad2:	108850        	and	a8, a8, a5
4037dad5:	1099c0        	and	a9, a9, a12
4037dad8:	208980        	or	a8, a9, a8
4037dadb:	0020c0        	memw
4037dade:	3b89      	s32i.n	a8, a11, 12
    dev->unit_load[counter_id].val = 0x01;
4037dae0:	14c332        	addi	a3, a3, 20
4037dae3:	a03320        	addx4	a3, a3, a2
    dev->unit_load_val[counter_id].lo.timer_unit_load_lo = value & 0xFFFFFFFF;
4037dae6:	0020c0        	memw
4037dae9:	4ba9      	s32i.n	a10, a11, 16
    dev->unit_load[counter_id].val = 0x01;
4037daeb:	120c      	movi.n	a2, 1
4037daed:	0020c0        	memw
4037daf0:	3329      	s32i.n	a2, a3, 12
    systimer_ll_apply_counter_value(hal->dev, counter_id);
}
4037daf2:	f01d      	retw.n

4037daf4 <systimer_hal_select_alarm_mode>:
{
    systimer_ll_enable_counter(hal->dev, counter_id, true);
}

void systimer_hal_select_alarm_mode(systimer_hal_context_t *hal, uint32_t alarm_id, systimer_alarm_mode_t mode)
{
4037daf4:	004136        	entry	a1, 32
    switch (mode) {
4037daf7:	348c      	beqz.n	a4, 4037dafe <systimer_hal_select_alarm_mode+0xa>
4037daf9:	1b1426        	beqi	a4, 1, 4037db18 <systimer_hal_select_alarm_mode+0x24>
        systimer_ll_enable_alarm_period(hal->dev, alarm_id);
        break;
    default:
        break;
    }
}
4037dafc:	f01d      	retw.n
        systimer_ll_enable_alarm_oneshot(hal->dev, alarm_id);
4037dafe:	0228      	l32i.n	a2, a2, 0
    dev->target_conf[alarm_id].target_period_mode = 0;
4037db00:	33cb      	addi.n	a3, a3, 12
4037db02:	a03320        	addx4	a3, a3, a2
4037db05:	0020c0        	memw
4037db08:	1348      	l32i.n	a4, a3, 4
4037db0a:	db3921        	l32r	a2, 403747f0 <_iram_text_start+0x3ec>
4037db0d:	104420        	and	a4, a4, a2
4037db10:	0020c0        	memw
4037db13:	1349      	s32i.n	a4, a3, 4
}
4037db15:	fff8c6        	j	4037dafc <systimer_hal_select_alarm_mode+0x8>
        systimer_ll_enable_alarm_period(hal->dev, alarm_id);
4037db18:	0228      	l32i.n	a2, a2, 0
    dev->target_conf[alarm_id].target_period_mode = 1;
4037db1a:	33cb      	addi.n	a3, a3, 12
4037db1c:	a03320        	addx4	a3, a3, a2
4037db1f:	0020c0        	memw
4037db22:	1388      	l32i.n	a8, a3, 4
4037db24:	014420        	slli	a4, a4, 30
4037db27:	208840        	or	a8, a8, a4
4037db2a:	0020c0        	memw
4037db2d:	1389      	s32i.n	a8, a3, 4
}
4037db2f:	fff246        	j	4037dafc <systimer_hal_select_alarm_mode+0x8>
	...

4037db34 <systimer_hal_connect_alarm_counter>:

void systimer_hal_connect_alarm_counter(systimer_hal_context_t *hal, uint32_t alarm_id, uint32_t counter_id)
{
4037db34:	004136        	entry	a1, 32
    systimer_ll_connect_alarm_counter(hal->dev, alarm_id, counter_id);
4037db37:	0288      	l32i.n	a8, a2, 0
    dev->target_conf[alarm_id].target_timer_unit_sel = counter_id;
4037db39:	33cb      	addi.n	a3, a3, 12
4037db3b:	a03380        	addx4	a3, a3, a8
4037db3e:	0020c0        	memw
4037db41:	1388      	l32i.n	a8, a3, 4
4037db43:	db3291        	l32r	a9, 4037480c <_iram_text_start+0x408>
4037db46:	014410        	slli	a4, a4, 31
4037db49:	108890        	and	a8, a8, a9
4037db4c:	208840        	or	a8, a8, a4
4037db4f:	0020c0        	memw
4037db52:	1389      	s32i.n	a8, a3, 4
}
4037db54:	f01d      	retw.n
	...

4037db58 <systimer_hal_set_tick_rate_ops>:
{
4037db58:	004136        	entry	a1, 32
    hal->ticks_to_us = ops->ticks_to_us;
4037db5b:	0388      	l32i.n	a8, a3, 0
    hal->us_to_ticks = ops->us_to_ticks;
4037db5d:	1338      	l32i.n	a3, a3, 4
    hal->ticks_to_us = ops->ticks_to_us;
4037db5f:	1289      	s32i.n	a8, a2, 4
    hal->us_to_ticks = ops->us_to_ticks;
4037db61:	2239      	s32i.n	a3, a2, 8
}
4037db63:	f01d      	retw.n
4037db65:	000000        	ill

4037db68 <systimer_hal_enable_alarm_int>:
{
4037db68:	004136        	entry	a1, 32
    systimer_ll_enable_alarm_int(hal->dev, alarm_id, true);
4037db6b:	0298      	l32i.n	a9, a2, 0
        dev->int_ena.val |= 1 << alarm_id;
4037db6d:	180c      	movi.n	a8, 1
4037db6f:	0020c0        	memw
4037db72:	1929a2        	l32i	a10, a9, 100
4037db75:	401300        	ssl	a3
4037db78:	a13800        	sll	a3, a8
4037db7b:	2033a0        	or	a3, a3, a10
4037db7e:	0020c0        	memw
4037db81:	196932        	s32i	a3, a9, 100
}
4037db84:	f01d      	retw.n
	...

4037db88 <systimer_hal_enable_counter>:
{
4037db88:	004136        	entry	a1, 32
    systimer_ll_enable_counter(hal->dev, counter_id, true);
4037db8b:	0298      	l32i.n	a9, a2, 0
        dev->conf.val |= 1 << (30 - counter_id);
4037db8d:	e81c      	movi.n	a8, 30
4037db8f:	0020c0        	memw
4037db92:	09a8      	l32i.n	a10, a9, 0
4037db94:	c03830        	sub	a3, a8, a3
4037db97:	180c      	movi.n	a8, 1
4037db99:	401300        	ssl	a3
4037db9c:	a18800        	sll	a8, a8
4037db9f:	2088a0        	or	a8, a8, a10
4037dba2:	0020c0        	memw
4037dba5:	0989      	s32i.n	a8, a9, 0
}
4037dba7:	f01d      	retw.n
4037dba9:	000000        	ill

4037dbac <systimer_hal_counter_can_stall_by_cpu>:

void systimer_hal_counter_can_stall_by_cpu(systimer_hal_context_t *hal, uint32_t counter_id, uint32_t cpu_id, bool can)
{
4037dbac:	004136        	entry	a1, 32
        dev->conf.val |= 1 << ((28 - counter_id * 2) - cpu_id);
4037dbaf:	e80c      	movi.n	a8, 14
4037dbb1:	c03830        	sub	a3, a8, a3
    systimer_ll_counter_can_stall_by_cpu(hal->dev, counter_id, cpu_id, can);
4037dbb4:	02a8      	l32i.n	a10, a2, 0
4037dbb6:	d03340        	subx2	a3, a3, a4
4037dbb9:	180c      	movi.n	a8, 1
4037dbbb:	401300        	ssl	a3
4037dbbe:	a18800        	sll	a8, a8
{
4037dbc1:	745050        	extui	a5, a5, 0, 8
4037dbc4:	0020c0        	memw
4037dbc7:	0a38      	l32i.n	a3, a10, 0
    if (can) {
4037dbc9:	858c      	beqz.n	a5, 4037dbd5 <systimer_hal_counter_can_stall_by_cpu+0x29>
        dev->conf.val |= 1 << ((28 - counter_id * 2) - cpu_id);
4037dbcb:	208830        	or	a8, a8, a3
        dev->conf.val &= ~(1 << ((28 - counter_id * 2) - cpu_id));
4037dbce:	0020c0        	memw
4037dbd1:	0a89      	s32i.n	a8, a10, 0
}
4037dbd3:	f01d      	retw.n
4037dbd5:	f97c      	movi.n	a9, -1
4037dbd7:	308980        	xor	a8, a9, a8
4037dbda:	108830        	and	a8, a8, a3
4037dbdd:	fffb46        	j	4037dbce <systimer_hal_counter_can_stall_by_cpu+0x22>

4037dbe0 <assert_valid_block>:

#else // CONFIG_HEAP_TLSF_USE_ROM_IMPL

/* Check a block is valid for this heap. Used to verify parameters. */
__attribute__((noinline)) NOCLONE_ATTR static void assert_valid_block(const heap_t *heap, const block_header_t *block)
{
4037dbe0:	004136        	entry	a1, 32
    pool_t pool = tlsf_get_pool(heap->heap_data);
4037dbe3:	42a8      	l32i.n	a10, a2, 16
4037dbe5:	0049e5        	call8	4037e084 <tlsf_get_pool>
		tlsf_cast(unsigned char*, ptr) - block_start_offset);
}

static inline __attribute__((always_inline)) void* block_to_ptr(const block_header_t* block)
{
	return tlsf_cast(void*,
4037dbe8:	c38b      	addi.n	a12, a3, 8
    void *ptr = block_to_ptr(block);

    MULTI_HEAP_ASSERT((ptr >= pool) &&
4037dbea:	063ca7        	bltu	a12, a10, 4037dbf4 <assert_valid_block+0x14>
4037dbed:	3228      	l32i.n	a2, a2, 12
4037dbef:	aa2a      	add.n	a10, a10, a2
    /* Can't use libc assert() here as it calls printf() which can cause another malloc() for a newlib lock.

       Also, it's useful to be able to print the memory address where corruption was detected.
    */
#ifndef NDEBUG
    if(!condition) {
4037dbf1:	0e3ca7        	bltu	a12, a10, 4037dc03 <assert_valid_block+0x23>
#ifndef CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        esp_rom_printf(format, line, address);
4037dbf4:	dca9a1        	l32r	a10, 40374e98 <_iram_text_start+0xa94>
4037dbf7:	72a0b2        	movi	a11, 114
4037dbfa:	da4981        	l32r	a8, 40374520 <_iram_text_start+0x11c>
4037dbfd:	0008e0        	callx8	a8
#endif  // CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
        abort();
4037dc00:	00b7a5        	call8	4037e77c <abort>
                    (ptr < pool + heap->pool_size),
                    (uintptr_t)ptr);
}
4037dc03:	f01d      	retw.n
4037dc05:	000000        	ill

4037dc08 <multi_heap_aligned_free>:

    return result;
}

void multi_heap_free_impl(multi_heap_handle_t heap, void *p)
{
4037dc08:	004136        	entry	a1, 32
    if (heap == NULL || p == NULL) {
4037dc0b:	01a082        	movi	a8, 1
4037dc0e:	00a092        	movi	a9, 0
4037dc11:	839820        	moveqz	a9, a8, a2
4037dc14:	74a090        	extui	a10, a9, 0, 8
4037dc17:	031956        	bnez	a9, 4037dc4c <multi_heap_aligned_free+0x44>
4037dc1a:	938a30        	movnez	a8, a10, a3
4037dc1d:	b8ec      	bnez.n	a8, 4037dc4c <multi_heap_aligned_free+0x44>
        return;
    }

    assert_valid_block(heap, block_from_ptr(p));
4037dc1f:	f8c3b2        	addi	a11, a3, -8
4037dc22:	02ad      	mov.n	a10, a2
4037dc24:	fffba5        	call8	4037dbe0 <assert_valid_block>

    multi_heap_internal_lock(heap);
4037dc27:	02ad      	mov.n	a10, a2
4037dc29:	000325        	call8	4037dc5c <multi_heap_internal_lock>
    heap->free_bytes += tlsf_block_size(p);
4037dc2c:	03ad      	mov.n	a10, a3
4037dc2e:	001225        	call8	4037dd50 <tlsf_block_size>
4037dc31:	1288      	l32i.n	a8, a2, 4
4037dc33:	a8aa      	add.n	a10, a8, a10
4037dc35:	12a9      	s32i.n	a10, a2, 4
    heap->free_bytes += tlsf_alloc_overhead();
4037dc37:	001125        	call8	4037dd48 <tlsf_alloc_overhead>
4037dc3a:	1288      	l32i.n	a8, a2, 4
    tlsf_free(heap->heap_data, p);
4037dc3c:	03bd      	mov.n	a11, a3
    heap->free_bytes += tlsf_alloc_overhead();
4037dc3e:	a8aa      	add.n	a10, a8, a10
4037dc40:	12a9      	s32i.n	a10, a2, 4
    tlsf_free(heap->heap_data, p);
4037dc42:	42a8      	l32i.n	a10, a2, 16
4037dc44:	001365        	call8	4037dd7c <tlsf_free>
    multi_heap_internal_unlock(heap);
4037dc47:	02ad      	mov.n	a10, a2
4037dc49:	000225        	call8	4037dc6c <multi_heap_internal_unlock>
}
4037dc4c:	f01d      	retw.n
	...

4037dc50 <multi_heap_get_allocated_size>:
{
4037dc50:	004136        	entry	a1, 32
    return tlsf_block_size(p);
4037dc53:	03ad      	mov.n	a10, a3
4037dc55:	000fa5        	call8	4037dd50 <tlsf_block_size>
}
4037dc58:	0a2d      	mov.n	a2, a10
4037dc5a:	f01d      	retw.n

4037dc5c <multi_heap_internal_lock>:
{
4037dc5c:	004136        	entry	a1, 32
    MULTI_HEAP_LOCK(heap->lock);
4037dc5f:	02a8      	l32i.n	a10, a2, 0
4037dc61:	3a8c      	beqz.n	a10, 4037dc68 <multi_heap_internal_lock+0xc>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4037dc63:	fb7c      	movi.n	a11, -1
4037dc65:	fe94a5        	call8	4037c5b0 <xPortEnterCriticalTimeout>
}
4037dc68:	f01d      	retw.n
	...

4037dc6c <multi_heap_internal_unlock>:
{
4037dc6c:	004136        	entry	a1, 32
    MULTI_HEAP_UNLOCK(heap->lock);
4037dc6f:	02a8      	l32i.n	a10, a2, 0
4037dc71:	1a8c      	beqz.n	a10, 4037dc76 <multi_heap_internal_unlock+0xa>
4037dc73:	fea725        	call8	4037c6e4 <vPortExitCritical>
}
4037dc76:	f01d      	retw.n

4037dc78 <multi_heap_malloc>:
{
4037dc78:	004136        	entry	a1, 32
    if (size == 0 || heap == NULL) {
4037dc7b:	180c      	movi.n	a8, 1
4037dc7d:	00a092        	movi	a9, 0
4037dc80:	839830        	moveqz	a9, a8, a3
4037dc83:	74a090        	extui	a10, a9, 0, 8
4037dc86:	03e956        	bnez	a9, 4037dcc8 <multi_heap_malloc+0x50>
4037dc89:	938a20        	movnez	a8, a10, a2
4037dc8c:	038856        	bnez	a8, 4037dcc8 <multi_heap_malloc+0x50>
    multi_heap_internal_lock(heap);
4037dc8f:	20a220        	or	a10, a2, a2
4037dc92:	fffca5        	call8	4037dc5c <multi_heap_internal_lock>
    void *result = tlsf_malloc(heap->heap_data, size);
4037dc95:	42a8      	l32i.n	a10, a2, 16
4037dc97:	03bd      	mov.n	a11, a3
4037dc99:	003fa5        	call8	4037e094 <tlsf_malloc>
4037dc9c:	0a3d      	mov.n	a3, a10
    if(result) {
4037dc9e:	aa9c      	beqz.n	a10, 4037dcbc <multi_heap_malloc+0x44>
        heap->free_bytes -= tlsf_block_size(result);
4037dca0:	000ae5        	call8	4037dd50 <tlsf_block_size>
4037dca3:	1288      	l32i.n	a8, a2, 4
4037dca5:	c0a8a0        	sub	a10, a8, a10
4037dca8:	0162a2        	s32i	a10, a2, 4
        heap->free_bytes -= tlsf_alloc_overhead();
4037dcab:	0009e5        	call8	4037dd48 <tlsf_alloc_overhead>
4037dcae:	1288      	l32i.n	a8, a2, 4
4037dcb0:	c0a8a0        	sub	a10, a8, a10
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037dcb3:	2288      	l32i.n	a8, a2, 8
        heap->free_bytes -= tlsf_alloc_overhead();
4037dcb5:	12a9      	s32i.n	a10, a2, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037dcb7:	01ba87        	bgeu	a10, a8, 4037dcbc <multi_heap_malloc+0x44>
            heap->minimum_free_bytes = heap->free_bytes;
4037dcba:	22a9      	s32i.n	a10, a2, 8
    multi_heap_internal_unlock(heap);
4037dcbc:	20a220        	or	a10, a2, a2
4037dcbf:	fffae5        	call8	4037dc6c <multi_heap_internal_unlock>
}
4037dcc2:	202330        	or	a2, a3, a3
4037dcc5:	000090        	retw
        return NULL;
4037dcc8:	030c      	movi.n	a3, 0
4037dcca:	fffd06        	j	4037dcc2 <multi_heap_malloc+0x4a>
4037dccd:	000000        	ill

4037dcd0 <multi_heap_realloc>:

void *multi_heap_realloc_impl(multi_heap_handle_t heap, void *p, size_t size)
{
4037dcd0:	004136        	entry	a1, 32
    assert(heap != NULL);
4037dcd3:	00e256        	bnez	a2, 4037dce5 <multi_heap_realloc+0x15>
4037dcd6:	dc71d1        	l32r	a13, 40374e9c <_iram_text_start+0xa98>
4037dcd9:	dc71c1        	l32r	a12, 40374ea0 <_iram_text_start+0xa9c>
4037dcdc:	dc72a1        	l32r	a10, 40374ea4 <_iram_text_start+0xaa0>
4037dcdf:	eda0b2        	movi	a11, 237
4037dce2:	00b2a5        	call8	4037e80c <__assert_func>

    if (p == NULL) {
4037dce5:	03dc      	bnez.n	a3, 4037dcf9 <multi_heap_realloc+0x29>
        return multi_heap_malloc_impl(heap, size);
4037dce7:	20b440        	or	a11, a4, a4
4037dcea:	20a220        	or	a10, a2, a2
4037dced:	fff8a5        	call8	4037dc78 <multi_heap_malloc>
4037dcf0:	0a3d      	mov.n	a3, a10
    }

    multi_heap_internal_unlock(heap);

    return result;
}
4037dcf2:	032d      	mov.n	a2, a3
4037dcf4:	f01d      	retw.n
4037dcf6:	00          	.byte 00
4037dcf7:	00          	.byte 00
4037dcf8:	00          	.byte 00
    assert_valid_block(heap, block_from_ptr(p));
4037dcf9:	f8c3b2        	addi	a11, a3, -8
4037dcfc:	20a220        	or	a10, a2, a2
4037dcff:	ffee25        	call8	4037dbe0 <assert_valid_block>
    multi_heap_internal_lock(heap);
4037dd02:	20a220        	or	a10, a2, a2
4037dd05:	fff565        	call8	4037dc5c <multi_heap_internal_lock>
    size_t previous_block_size =  tlsf_block_size(p);
4037dd08:	20a330        	or	a10, a3, a3
4037dd0b:	000465        	call8	4037dd50 <tlsf_block_size>
4037dd0e:	0a5d      	mov.n	a5, a10
    void *result = tlsf_realloc(heap->heap_data, p, size);
4037dd10:	42a8      	l32i.n	a10, a2, 16
4037dd12:	03bd      	mov.n	a11, a3
4037dd14:	04cd      	mov.n	a12, a4
4037dd16:	006725        	call8	4037e388 <tlsf_realloc>
4037dd19:	0a3d      	mov.n	a3, a10
    if(result) {
4037dd1b:	7a9c      	beqz.n	a10, 4037dd36 <multi_heap_realloc+0x66>
        heap->free_bytes += previous_block_size;
4037dd1d:	12a8      	l32i.n	a10, a2, 4
4037dd1f:	aa5a      	add.n	a10, a10, a5
4037dd21:	12a9      	s32i.n	a10, a2, 4
        heap->free_bytes -= tlsf_block_size(result);
4037dd23:	03ad      	mov.n	a10, a3
4037dd25:	0002a5        	call8	4037dd50 <tlsf_block_size>
4037dd28:	1288      	l32i.n	a8, a2, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037dd2a:	2248      	l32i.n	a4, a2, 8
        heap->free_bytes -= tlsf_block_size(result);
4037dd2c:	c0a8a0        	sub	a10, a8, a10
4037dd2f:	12a9      	s32i.n	a10, a2, 4
        if (heap->free_bytes < heap->minimum_free_bytes) {
4037dd31:	01ba47        	bgeu	a10, a4, 4037dd36 <multi_heap_realloc+0x66>
            heap->minimum_free_bytes = heap->free_bytes;
4037dd34:	22a9      	s32i.n	a10, a2, 8
    multi_heap_internal_unlock(heap);
4037dd36:	02ad      	mov.n	a10, a2
4037dd38:	fff325        	call8	4037dc6c <multi_heap_internal_unlock>
    return result;
4037dd3b:	ffecc6        	j	4037dcf2 <multi_heap_realloc+0x22>
	...

4037dd40 <multi_heap_set_lock>:
{
4037dd40:	004136        	entry	a1, 32
    heap->lock = lock;
4037dd43:	0239      	s32i.n	a3, a2, 0
}
4037dd45:	f01d      	retw.n
	...

4037dd48 <tlsf_alloc_overhead>:
4037dd48:	004136        	entry	a1, 32
4037dd4b:	420c      	movi.n	a2, 4
4037dd4d:	f01d      	retw.n
	...

4037dd50 <tlsf_block_size>:
		block = block_next(block);
	}
}

size_t tlsf_block_size(void* ptr)
{
4037dd50:	004136        	entry	a1, 32
4037dd53:	028d      	mov.n	a8, a2
	size_t size = 0;
4037dd55:	020c      	movi.n	a2, 0
	if (ptr)
4037dd57:	091827        	beq	a8, a2, 4037dd64 <tlsf_block_size+0x14>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037dd5a:	f8c882        	addi	a8, a8, -8
4037dd5d:	1888      	l32i.n	a8, a8, 4
4037dd5f:	c27c      	movi.n	a2, -4
4037dd61:	102280        	and	a2, a2, a8
	{
		const block_header_t* block = block_from_ptr(ptr);
		size = block_size(block);
	}
	return size;
}
4037dd64:	f01d      	retw.n
	...

4037dd68 <tlsf_block_size_max>:
{
	return block_size_min;
}

size_t tlsf_block_size_max(tlsf_t tlsf)
{
4037dd68:	004136        	entry	a1, 32
	if (tlsf == NULL)
4037dd6b:	b28c      	beqz.n	a2, 4037dd7a <tlsf_block_size_max+0x12>
	{
		return 0;
	}
	control_t* control = tlsf_cast(control_t*, tlsf);
	return tlsf_cast(size_t, 1) << control->fl_index_max;
4037dd6d:	4288      	l32i.n	a8, a2, 16
4037dd6f:	120c      	movi.n	a2, 1
4037dd71:	548880        	extui	a8, a8, 8, 6
4037dd74:	401800        	ssl	a8
4037dd77:	a12200        	sll	a2, a2
}
4037dd7a:	f01d      	retw.n

4037dd7c <tlsf_free>:
	return tlsf_memalign_offs(tlsf, align, size, 0);
}


void tlsf_free(tlsf_t tlsf, void* ptr)
{
4037dd7c:	004136        	entry	a1, 32
	/* Don't attempt to free a NULL pointer. */
	if (ptr)
4037dd7f:	2ff316        	beqz	a3, 4037e082 <tlsf_free+0x306>
	return tlsf_cast(block_header_t*,
4037dd82:	f8c3a2        	addi	a10, a3, -8
	return tlsf_cast(int, block->size & block_header_free_bit);
4037dd85:	1a48      	l32i.n	a4, a10, 4
	{
		control_t* control = tlsf_cast(control_t*, tlsf);
		block_header_t* block = block_from_ptr(ptr);
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037dd87:	0e6407        	bbci	a4, 0, 4037dd99 <tlsf_free+0x1d>
4037dd8a:	dc47d1        	l32r	a13, 40374ea8 <_iram_text_start+0xaa4>
4037dd8d:	dc47c1        	l32r	a12, 40374eac <_iram_text_start+0xaa8>
4037dd90:	5fa4b2        	movi	a11, 0x45f
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037dd93:	dc47a1        	l32r	a10, 40374eb0 <_iram_text_start+0xaac>
4037dd96:	000586        	j	4037ddb0 <tlsf_free+0x34>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037dd99:	c87c      	movi.n	a8, -4
4037dd9b:	104480        	and	a4, a4, a8
}

/* Return location of next block after block of given size. */
static inline __attribute__((always_inline)) block_header_t* offset_to_block(const void* ptr, size_t size)
{
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037dd9e:	338a      	add.n	a3, a3, a8
4037dda0:	334a      	add.n	a3, a3, a4
/* Return location of next existing block. */
static inline __attribute__((always_inline)) block_header_t* block_next(const block_header_t* block)
{
	block_header_t* next = offset_to_block(block_to_ptr(block),
		block_size(block) - block_header_overhead);
	tlsf_assert(!block_is_last(block));
4037dda2:	d4cc      	bnez.n	a4, 4037ddb3 <tlsf_free+0x37>
4037dda4:	dc44d1        	l32r	a13, 40374eb4 <_iram_text_start+0xab0>
4037dda7:	dc44c1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4>
4037ddaa:	dc44a1        	l32r	a10, 40374ebc <_iram_text_start+0xab8>
4037ddad:	5ea0b2        	movi	a11, 94
4037ddb0:	00a5a5        	call8	4037e80c <__assert_func>
	block->size |= block_header_prev_free_bit;
4037ddb3:	012342        	l32i	a4, a3, 4
4037ddb6:	02a092        	movi	a9, 2
4037ddb9:	204490        	or	a4, a4, a9
4037ddbc:	1349      	s32i.n	a4, a3, 4
	block->size |= block_header_free_bit;
4037ddbe:	1a48      	l32i.n	a4, a10, 4

/* Link a new block with its physical neighbor, return the neighbor. */
static inline __attribute__((always_inline)) block_header_t* block_link_next(block_header_t* block)
{
	block_header_t* next = block_next(block);
	next->prev_phys_block = block;
4037ddc0:	03a9      	s32i.n	a10, a3, 0
	block->size |= block_header_free_bit;
4037ddc2:	130c      	movi.n	a3, 1
4037ddc4:	203340        	or	a3, a3, a4
4037ddc7:	1a39      	s32i.n	a3, a10, 4
	if (block_is_prev_free(block))
4037ddc9:	028397        	bany	a3, a9, 4037ddcf <tlsf_free+0x53>
4037ddcc:	004a06        	j	4037def8 <tlsf_free+0x17c>
	return block->prev_phys_block;
4037ddcf:	0a38      	l32i.n	a3, a10, 0
		tlsf_assert(prev && "prev physical block can't be null");
4037ddd1:	b3cc      	bnez.n	a3, 4037dde0 <tlsf_free+0x64>
4037ddd3:	dc3bd1        	l32r	a13, 40374ec0 <_iram_text_start+0xabc>
4037ddd6:	dc3bc1        	l32r	a12, 40374ec4 <_iram_text_start+0xac0>
4037ddd9:	d4a1b2        	movi	a11, 0x1d4
4037dddc:	ffecc6        	j	4037dd93 <tlsf_free+0x17>
4037dddf:	00          	.byte 00
	return tlsf_cast(int, block->size & block_header_free_bit);
4037dde0:	1348      	l32i.n	a4, a3, 4
		tlsf_assert(block_is_free(prev) && "prev block is not free though marked as such");
4037dde2:	0be407        	bbsi	a4, 0, 4037ddf1 <tlsf_free+0x75>
4037dde5:	dc38d1        	l32r	a13, 40374ec8 <_iram_text_start+0xac4>
4037dde8:	dc37c1        	l32r	a12, 40374ec4 <_iram_text_start+0xac0>
4037ddeb:	d5a1b2        	movi	a11, 0x1d5
4037ddee:	ffe846        	j	4037dd93 <tlsf_free+0x17>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037ddf1:	104480        	and	a4, a4, a8
	if (size < control->small_block_size)
4037ddf4:	4288      	l32i.n	a8, a2, 16
4037ddf6:	759780        	extui	a9, a8, 23, 8
4037ddf9:	1cb497        	bgeu	a4, a9, 4037de19 <tlsf_free+0x9d>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037ddfc:	548e80        	extui	a8, a8, 14, 6
4037ddff:	d29980        	quos	a9, a9, a8
4037de02:	d24490        	quos	a4, a4, a9
		fl = 0;
4037de05:	090c      	movi.n	a9, 0
	block_header_t* prev = block->prev_free;
4037de07:	3388      	l32i.n	a8, a3, 12
	block_header_t* next = block->next_free;
4037de09:	23b8      	l32i.n	a11, a3, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037de0b:	b8fc      	bnez.n	a8, 4037de4a <tlsf_free+0xce>
4037de0d:	dc2fd1        	l32r	a13, 40374ecc <_iram_text_start+0xac8>
4037de10:	dc30c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037de13:	4aa1b2        	movi	a11, 0x14a
4037de16:	ffde46        	j	4037dd93 <tlsf_free+0x17>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037de19:	00a092        	movi	a9, 0
4037de1c:	081497        	beq	a4, a9, 4037de28 <tlsf_free+0xac>
4037de1f:	40f4b0        	nsau	a11, a4
4037de22:	20a092        	movi	a9, 32
4037de25:	c099b0        	sub	a9, a9, a11
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037de28:	25c480        	extui	a12, a8, 20, 3
	return bit - 1;
4037de2b:	b90b      	addi.n	a11, a9, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037de2d:	c0bbc0        	sub	a11, a11, a12
4037de30:	400b00        	ssr	a11
4037de33:	914040        	srl	a4, a4
4037de36:	1b0c      	movi.n	a11, 1
4037de38:	401c00        	ssl	a12
4037de3b:	a1bb00        	sll	a11, a11
		fl -= (control->fl_index_shift - 1);
4037de3e:	248580        	extui	a8, a8, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037de41:	3044b0        	xor	a4, a4, a11
		fl -= (control->fl_index_shift - 1);
4037de44:	c09980        	sub	a9, a9, a8
4037de47:	ffef06        	j	4037de07 <tlsf_free+0x8b>
	tlsf_assert(next && "next_free field can not be null");
4037de4a:	abcc      	bnez.n	a11, 4037de58 <tlsf_free+0xdc>
4037de4c:	dc22d1        	l32r	a13, 40374ed4 <_iram_text_start+0xad0>
4037de4f:	dc20c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037de52:	4ba1b2        	movi	a11, 0x14b
4037de55:	ffce86        	j	4037dd93 <tlsf_free+0x17>
	next->prev_free = prev;
4037de58:	3b89      	s32i.n	a8, a11, 12
	prev->next_free = next;
4037de5a:	28b9      	s32i.n	a11, a8, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037de5c:	4288      	l32i.n	a8, a2, 16
4037de5e:	82c8      	l32i.n	a12, a2, 32
4037de60:	548e80        	extui	a8, a8, 14, 6
4037de63:	828890        	mull	a8, a8, a9
4037de66:	884a      	add.n	a8, a8, a4
4037de68:	a088c0        	addx4	a8, a8, a12
4037de6b:	08c8      	l32i.n	a12, a8, 0
4037de6d:	3093c7        	bne	a3, a12, 4037dea1 <tlsf_free+0x125>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037de70:	08b9      	s32i.n	a11, a8, 0
		if (next == &control->block_null)
4037de72:	2b9b27        	bne	a11, a2, 4037dea1 <tlsf_free+0x125>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037de75:	72c8      	l32i.n	a12, a2, 28
4037de77:	1b0c      	movi.n	a11, 1
4037de79:	a0c9c0        	addx4	a12, a9, a12
4037de7c:	0cd8      	l32i.n	a13, a12, 0
4037de7e:	401400        	ssl	a4
4037de81:	a14b00        	sll	a4, a11
4037de84:	f87c      	movi.n	a8, -1
4037de86:	304840        	xor	a4, a8, a4
4037de89:	1044d0        	and	a4, a4, a13
4037de8c:	0c49      	s32i.n	a4, a12, 0
			if (!control->sl_bitmap[fl])
4037de8e:	f4cc      	bnez.n	a4, 4037dea1 <tlsf_free+0x125>
				control->fl_bitmap &= ~(1U << fl);
4037de90:	6248      	l32i.n	a4, a2, 24
4037de92:	401900        	ssl	a9
4037de95:	a1bb00        	sll	a11, a11
4037de98:	3088b0        	xor	a8, a8, a11
4037de9b:	104480        	and	a4, a4, a8
4037de9e:	066242        	s32i	a4, a2, 24
4037dea1:	1398      	l32i.n	a9, a3, 4
4037dea3:	c47c      	movi.n	a4, -4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037dea5:	0b8947        	bany	a9, a4, 4037deb4 <tlsf_free+0x138>
4037dea8:	dc0cd1        	l32r	a13, 40374ed8 <_iram_text_start+0xad4>
4037deab:	dc0cc1        	l32r	a12, 40374edc <_iram_text_start+0xad8>
4037deae:	c1a1b2        	movi	a11, 0x1c1
4037deb1:	ffb786        	j	4037dd93 <tlsf_free+0x17>
4037deb4:	1a88      	l32i.n	a8, a10, 4
4037deb6:	108480        	and	a8, a4, a8
	prev->size += block_size(block) + block_header_overhead;
4037deb9:	889a      	add.n	a8, a8, a9
4037debb:	884b      	addi.n	a8, a8, 4
4037debd:	1389      	s32i.n	a8, a3, 4
4037debf:	108840        	and	a8, a8, a4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037dec2:	434b      	addi.n	a4, a3, 4
4037dec4:	448a      	add.n	a4, a4, a8
	tlsf_assert(!block_is_last(block));
4037dec6:	eda816        	beqz	a8, 4037dda4 <tlsf_free+0x28>
	next->prev_phys_block = block;
4037dec9:	0439      	s32i.n	a3, a4, 0
	if (block_absorb_post_hook != NULL)
4037decb:	dc0541        	l32r	a4, 40374ee0 <_iram_text_start+0xadc>
4037dece:	848c      	beqz.n	a4, 4037deda <tlsf_free+0x15e>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037ded0:	1c0c      	movi.n	a12, 1
4037ded2:	0b1c      	movi.n	a11, 16
4037ded4:	dc0381        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
4037ded7:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037deda:	1388      	l32i.n	a8, a3, 4
4037dedc:	cc7c      	movi.n	a12, -4
	return tlsf_cast(void*,
4037dede:	438b      	addi.n	a4, a3, 8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037dee0:	108c80        	and	a8, a12, a8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037dee3:	a84a      	add.n	a10, a8, a4
4037dee5:	aaca      	add.n	a10, a10, a12
	tlsf_assert(!block_is_last(block));
4037dee7:	eb9816        	beqz	a8, 4037dda4 <tlsf_free+0x28>
	tlsf_assert(next && "next physical block can't be null");
4037deea:	facc      	bnez.n	a10, 4037defd <tlsf_free+0x181>
4037deec:	dbfed1        	l32r	a13, 40374ee4 <_iram_text_start+0xae0>
4037deef:	dbfec1        	l32r	a12, 40374ee8 <_iram_text_start+0xae4>
4037def2:	e1a1b2        	movi	a11, 0x1e1
4037def5:	ffa686        	j	4037dd93 <tlsf_free+0x17>
4037def8:	0a3d      	mov.n	a3, a10
4037defa:	fff706        	j	4037deda <tlsf_free+0x15e>
	if (size < control->small_block_size)
4037defd:	4298      	l32i.n	a9, a2, 16
	return tlsf_cast(int, block->size & block_header_free_bit);
4037deff:	1a88      	l32i.n	a8, a10, 4
4037df01:	75b790        	extui	a11, a9, 23, 8
	if (block_is_free(next))
4037df04:	02e807        	bbsi	a8, 0, 4037df0a <tlsf_free+0x18e>
4037df07:	002546        	j	4037dfa0 <tlsf_free+0x224>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037df0a:	1088c0        	and	a8, a8, a12
	if (size < control->small_block_size)
4037df0d:	0238b7        	bltu	a8, a11, 4037df13 <tlsf_free+0x197>
4037df10:	003046        	j	4037dfd5 <tlsf_free+0x259>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037df13:	549e90        	extui	a9, a9, 14, 6
4037df16:	d2bb90        	quos	a11, a11, a9
4037df19:	d288b0        	quos	a8, a8, a11
		fl = 0;
4037df1c:	0b0c      	movi.n	a11, 0
	block_header_t* prev = block->prev_free;
4037df1e:	3a98      	l32i.n	a9, a10, 12
	block_header_t* next = block->next_free;
4037df20:	2ac8      	l32i.n	a12, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037df22:	ee7916        	beqz	a9, 4037de0d <tlsf_free+0x91>
	tlsf_assert(next && "next_free field can not be null");
4037df25:	f23c16        	beqz	a12, 4037de4c <tlsf_free+0xd0>
	next->prev_free = prev;
4037df28:	3c99      	s32i.n	a9, a12, 12
	prev->next_free = next;
4037df2a:	29c9      	s32i.n	a12, a9, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037df2c:	4298      	l32i.n	a9, a2, 16
4037df2e:	82d8      	l32i.n	a13, a2, 32
4037df30:	549e90        	extui	a9, a9, 14, 6
4037df33:	8299b0        	mull	a9, a9, a11
4037df36:	998a      	add.n	a9, a9, a8
4037df38:	a099d0        	addx4	a9, a9, a13
4037df3b:	09d8      	l32i.n	a13, a9, 0
4037df3d:	2f9ad7        	bne	a10, a13, 4037df70 <tlsf_free+0x1f4>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037df40:	09c9      	s32i.n	a12, a9, 0
		if (next == &control->block_null)
4037df42:	2a9c27        	bne	a12, a2, 4037df70 <tlsf_free+0x1f4>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037df45:	72d8      	l32i.n	a13, a2, 28
4037df47:	1c0c      	movi.n	a12, 1
4037df49:	a0dbd0        	addx4	a13, a11, a13
4037df4c:	0de8      	l32i.n	a14, a13, 0
4037df4e:	401800        	ssl	a8
4037df51:	a18c00        	sll	a8, a12
4037df54:	f97c      	movi.n	a9, -1
4037df56:	308980        	xor	a8, a9, a8
4037df59:	1088e0        	and	a8, a8, a14
4037df5c:	0d89      	s32i.n	a8, a13, 0
			if (!control->sl_bitmap[fl])
4037df5e:	e8cc      	bnez.n	a8, 4037df70 <tlsf_free+0x1f4>
				control->fl_bitmap &= ~(1U << fl);
4037df60:	6288      	l32i.n	a8, a2, 24
4037df62:	401b00        	ssl	a11
4037df65:	a1cc00        	sll	a12, a12
4037df68:	3099c0        	xor	a9, a9, a12
4037df6b:	108890        	and	a8, a8, a9
4037df6e:	6289      	s32i.n	a8, a2, 24
4037df70:	1398      	l32i.n	a9, a3, 4
4037df72:	cb7c      	movi.n	a11, -4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037df74:	0289b7        	bany	a9, a11, 4037df7a <tlsf_free+0x1fe>
4037df77:	ffcb46        	j	4037dea8 <tlsf_free+0x12c>
4037df7a:	1a88      	l32i.n	a8, a10, 4
	prev->size += block_size(block) + block_header_overhead;
4037df7c:	994b      	addi.n	a9, a9, 4
4037df7e:	108b80        	and	a8, a11, a8
4037df81:	889a      	add.n	a8, a8, a9
4037df83:	1389      	s32i.n	a8, a3, 4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037df85:	94ba      	add.n	a9, a4, a11
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037df87:	1088b0        	and	a8, a8, a11
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037df8a:	998a      	add.n	a9, a9, a8
	tlsf_assert(!block_is_last(block));
4037df8c:	e14816        	beqz	a8, 4037dda4 <tlsf_free+0x28>
	if (block_absorb_post_hook != NULL)
4037df8f:	dbd481        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
	next->prev_phys_block = block;
4037df92:	0939      	s32i.n	a3, a9, 0
4037df94:	888c      	beqz.n	a8, 4037dfa0 <tlsf_free+0x224>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037df96:	1c0c      	movi.n	a12, 1
4037df98:	0b1c      	movi.n	a11, 16
4037df9a:	dbd181        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
4037df9d:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037dfa0:	1398      	l32i.n	a9, a3, 4
	if (size < control->small_block_size)
4037dfa2:	42b8      	l32i.n	a11, a2, 16
4037dfa4:	c87c      	movi.n	a8, -4
4037dfa6:	108890        	and	a8, a8, a9
4037dfa9:	75a7b0        	extui	a10, a11, 23, 8
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037dfac:	549eb0        	extui	a9, a11, 14, 6
	if (size < control->small_block_size)
4037dfaf:	53b8a7        	bgeu	a8, a10, 4037e006 <tlsf_free+0x28a>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037dfb2:	d2aa90        	quos	a10, a10, a9
4037dfb5:	d288a0        	quos	a8, a8, a10
		fl = 0;
4037dfb8:	0a0c      	movi.n	a10, 0
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037dfba:	829a90        	mull	a9, a10, a9
4037dfbd:	82b8      	l32i.n	a11, a2, 32
4037dfbf:	998a      	add.n	a9, a9, a8
4037dfc1:	a099b0        	addx4	a9, a9, a11
4037dfc4:	0998      	l32i.n	a9, a9, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037dfc6:	06c956        	bnez	a9, 4037e036 <tlsf_free+0x2ba>
4037dfc9:	dbc8d1        	l32r	a13, 40374eec <_iram_text_start+0xae8>
4037dfcc:	dbc9c1        	l32r	a12, 40374ef0 <_iram_text_start+0xaec>
4037dfcf:	66a1b2        	movi	a11, 0x166
4037dfd2:	ff6f46        	j	4037dd93 <tlsf_free+0x17>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037dfd5:	00a0b2        	movi	a11, 0
4037dfd8:	0818b7        	beq	a8, a11, 4037dfe4 <tlsf_free+0x268>
4037dfdb:	40f8c0        	nsau	a12, a8
4037dfde:	20a0b2        	movi	a11, 32
4037dfe1:	c0bbc0        	sub	a11, a11, a12
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037dfe4:	25d490        	extui	a13, a9, 20, 3
	return bit - 1;
4037dfe7:	cb0b      	addi.n	a12, a11, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037dfe9:	c0ccd0        	sub	a12, a12, a13
4037dfec:	400c00        	ssr	a12
4037dfef:	918080        	srl	a8, a8
4037dff2:	1c0c      	movi.n	a12, 1
4037dff4:	401d00        	ssl	a13
4037dff7:	a1cc00        	sll	a12, a12
		fl -= (control->fl_index_shift - 1);
4037dffa:	249590        	extui	a9, a9, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037dffd:	3088c0        	xor	a8, a8, a12
		fl -= (control->fl_index_shift - 1);
4037e000:	c0bb90        	sub	a11, a11, a9
4037e003:	ffc5c6        	j	4037df1e <tlsf_free+0x1a2>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e006:	0a0c      	movi.n	a10, 0
4037e008:	0818a7        	beq	a8, a10, 4037e014 <tlsf_free+0x298>
4037e00b:	40f8c0        	nsau	a12, a8
4037e00e:	20a0a2        	movi	a10, 32
4037e011:	c0aac0        	sub	a10, a10, a12
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e014:	25d4b0        	extui	a13, a11, 20, 3
	return bit - 1;
4037e017:	ca0b      	addi.n	a12, a10, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e019:	c0ccd0        	sub	a12, a12, a13
4037e01c:	400c00        	ssr	a12
4037e01f:	918080        	srl	a8, a8
4037e022:	1c0c      	movi.n	a12, 1
4037e024:	401d00        	ssl	a13
4037e027:	a1cc00        	sll	a12, a12
		fl -= (control->fl_index_shift - 1);
4037e02a:	24b5b0        	extui	a11, a11, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e02d:	3088c0        	xor	a8, a8, a12
		fl -= (control->fl_index_shift - 1);
4037e030:	c0aab0        	sub	a10, a10, a11
4037e033:	ffe0c6        	j	4037dfba <tlsf_free+0x23e>
	block->next_free = current;
4037e036:	2399      	s32i.n	a9, a3, 8
	block->prev_free = &control->block_null;
4037e038:	3329      	s32i.n	a2, a3, 12
	current->prev_free = block;
4037e03a:	3939      	s32i.n	a3, a9, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037e03c:	cc7c      	movi.n	a12, -4
4037e03e:	943b      	addi.n	a9, a4, 3
4037e040:	1099c0        	and	a9, a9, a12
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
4037e043:	0b1497        	beq	a4, a9, 4037e052 <tlsf_free+0x2d6>
4037e046:	dbabd1        	l32r	a13, 40374ef4 <_iram_text_start+0xaf0>
4037e049:	dba9c1        	l32r	a12, 40374ef0 <_iram_text_start+0xaec>
4037e04c:	6ca1b2        	movi	a11, 0x16c
4037e04f:	ff5006        	j	4037dd93 <tlsf_free+0x17>
	control->blocks[fl * control->sl_index_count + sl] = block;
4037e052:	4248      	l32i.n	a4, a2, 16
4037e054:	544e40        	extui	a4, a4, 14, 6
4037e057:	8244a0        	mull	a4, a4, a10
4037e05a:	448a      	add.n	a4, a4, a8
4037e05c:	a044b0        	addx4	a4, a4, a11
4037e05f:	0439      	s32i.n	a3, a4, 0
	control->fl_bitmap |= (1U << fl);
4037e061:	6248      	l32i.n	a4, a2, 24
4037e063:	130c      	movi.n	a3, 1
4037e065:	401a00        	ssl	a10
4037e068:	a19300        	sll	a9, a3
4037e06b:	204490        	or	a4, a4, a9
4037e06e:	6249      	s32i.n	a4, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037e070:	7228      	l32i.n	a2, a2, 28
4037e072:	401800        	ssl	a8
4037e075:	a13300        	sll	a3, a3
4037e078:	a02a20        	addx4	a2, a10, a2
4037e07b:	0248      	l32i.n	a4, a2, 0
4037e07d:	203430        	or	a3, a4, a3
4037e080:	0239      	s32i.n	a3, a2, 0
		block_mark_as_free(block);
		block = block_merge_prev(control, block);
		block = block_merge_next(control, block);
		block_insert(control, block);
	}
}
4037e082:	f01d      	retw.n

4037e084 <tlsf_get_pool>:
{
4037e084:	004136        	entry	a1, 32
		return 0;
4037e087:	028d      	mov.n	a8, a2
	if (tlsf == NULL)
4037e089:	028c      	beqz.n	a2, 4037e08d <tlsf_get_pool+0x9>
	return control->size;
4037e08b:	5288      	l32i.n	a8, a2, 20
}
4037e08d:	228a      	add.n	a2, a2, a8
4037e08f:	f01d      	retw.n
4037e091:	000000        	ill

4037e094 <tlsf_malloc>:
{
4037e094:	004136        	entry	a1, 32
	if (size)
4037e097:	2e2316        	beqz	a3, 4037e37d <tlsf_malloc+0x2e9>
	return (x + (align - 1)) & ~(align - 1);
4037e09a:	03c332        	addi	a3, a3, 3
4037e09d:	fcaf42        	movi	a4, -4
		if (aligned < tlsf_block_size_max(tlsf)) 
4037e0a0:	02ad      	mov.n	a10, a2
	return (x + (align - 1)) & ~(align - 1);
4037e0a2:	103340        	and	a3, a3, a4
		if (aligned < tlsf_block_size_max(tlsf)) 
4037e0a5:	ffcc25        	call8	4037dd68 <tlsf_block_size_max>
4037e0a8:	0233a7        	bltu	a3, a10, 4037e0ae <tlsf_malloc+0x1a>
4037e0ab:	00b486        	j	4037e381 <tlsf_malloc+0x2ed>
	if (size >= control->small_block_size)
4037e0ae:	42c8      	l32i.n	a12, a2, 16
			adjust = tlsf_max(aligned, block_size_min);
4037e0b0:	cb0c      	movi.n	a11, 12
4037e0b2:	73b3b0        	maxu	a11, a3, a11
	if (size >= control->small_block_size)
4037e0b5:	7547c0        	extui	a4, a12, 23, 8
4037e0b8:	7c3b47        	bltu	a11, a4, 4037e138 <tlsf_malloc+0xa4>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e0bb:	40fb30        	nsau	a3, a11
	return bit - 1;
4037e0be:	f81c      	movi.n	a8, 31
4037e0c0:	c08830        	sub	a8, a8, a3
		const size_t round = (1 << (tlsf_fls_sizet(size) - control->sl_index_count_log2)) - 1;
4037e0c3:	2594c0        	extui	a9, a12, 20, 3
4037e0c6:	c08890        	sub	a8, a8, a9
4037e0c9:	130c      	movi.n	a3, 1
4037e0cb:	401800        	ssl	a8
4037e0ce:	a13300        	sll	a3, a3
4037e0d1:	330b      	addi.n	a3, a3, -1
		size += round;
4037e0d3:	33ba      	add.n	a3, a3, a11
	if (size < control->small_block_size)
4037e0d5:	64b347        	bgeu	a3, a4, 4037e13d <tlsf_malloc+0xa9>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e0d8:	545ec0        	extui	a5, a12, 14, 6
4037e0db:	d24450        	quos	a4, a4, a5
4037e0de:	d23340        	quos	a3, a3, a4
		fl = 0;
4037e0e1:	080c      	movi.n	a8, 0
		if (fl < control->fl_index_count)
4037e0e3:	4440c0        	extui	a4, a12, 0, 5
4037e0e6:	022847        	blt	a8, a4, 4037e0ec <tlsf_malloc+0x58>
4037e0e9:	00a506        	j	4037e381 <tlsf_malloc+0x2ed>
	unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
4037e0ec:	72d8      	l32i.n	a13, a2, 28
4037e0ee:	f97c      	movi.n	a9, -1
4037e0f0:	a048d0        	addx4	a4, a8, a13
4037e0f3:	0448      	l32i.n	a4, a4, 0
4037e0f5:	401300        	ssl	a3
4037e0f8:	a13900        	sll	a3, a9
4037e0fb:	103340        	and	a3, a3, a4
	if (!sl_map)
4037e0fe:	067356        	bnez	a3, 4037e169 <tlsf_malloc+0xd5>
		const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
4037e101:	6248      	l32i.n	a4, a2, 24
4037e103:	881b      	addi.n	a8, a8, 1
4037e105:	401800        	ssl	a8
4037e108:	a13900        	sll	a3, a9
4037e10b:	103340        	and	a3, a3, a4
		if (!fl_map)
4037e10e:	26b316        	beqz	a3, 4037e37d <tlsf_malloc+0x2e9>
	return __builtin_ffs(word) - 1;
4037e111:	608030        	neg	a8, a3
4037e114:	108830        	and	a8, a8, a3
4037e117:	40f880        	nsau	a8, a8
4037e11a:	608080        	neg	a8, a8
4037e11d:	1fc882        	addi	a8, a8, 31
		sl_map = control->sl_bitmap[fl];
4037e120:	a038d0        	addx4	a3, a8, a13
4037e123:	002332        	l32i	a3, a3, 0
	tlsf_assert(sl_map && "internal error - second level bitmap is null");
4037e126:	03f356        	bnez	a3, 4037e169 <tlsf_malloc+0xd5>
4037e129:	db73d1        	l32r	a13, 40374ef8 <_iram_text_start+0xaf4>
4037e12c:	db74c1        	l32r	a12, 40374efc <_iram_text_start+0xaf8>
4037e12f:	3da1b2        	movi	a11, 0x13d
		tlsf_assert(block_size(block) >= size);
4037e132:	db5fa1        	l32r	a10, 40374eb0 <_iram_text_start+0xaac>
4037e135:	006d65        	call8	4037e80c <__assert_func>
4037e138:	0b3d      	mov.n	a3, a11
4037e13a:	ffe686        	j	4037e0d8 <tlsf_malloc+0x44>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e13d:	080c      	movi.n	a8, 0
4037e13f:	071387        	beq	a3, a8, 4037e14a <tlsf_malloc+0xb6>
4037e142:	40f340        	nsau	a4, a3
4037e145:	082c      	movi.n	a8, 32
4037e147:	c08840        	sub	a8, a8, a4
	return bit - 1;
4037e14a:	480b      	addi.n	a4, a8, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e14c:	c04490        	sub	a4, a4, a9
4037e14f:	400400        	ssr	a4
4037e152:	913030        	srl	a3, a3
4037e155:	140c      	movi.n	a4, 1
4037e157:	401900        	ssl	a9
4037e15a:	a14400        	sll	a4, a4
4037e15d:	303340        	xor	a3, a3, a4
		fl -= (control->fl_index_shift - 1);
4037e160:	2445c0        	extui	a4, a12, 5, 3
4037e163:	c08840        	sub	a8, a8, a4
4037e166:	ffde46        	j	4037e0e3 <tlsf_malloc+0x4f>
	return __builtin_ffs(word) - 1;
4037e169:	609030        	neg	a9, a3
4037e16c:	109930        	and	a9, a9, a3
4037e16f:	40f990        	nsau	a9, a9
	return control->blocks[fl * control->sl_index_count + sl];
4037e172:	54cec0        	extui	a12, a12, 14, 6
4037e175:	82cc80        	mull	a12, a12, a8
	return __builtin_ffs(word) - 1;
4037e178:	609090        	neg	a9, a9
	return control->blocks[fl * control->sl_index_count + sl];
4037e17b:	82e8      	l32i.n	a14, a2, 32
	return __builtin_ffs(word) - 1;
4037e17d:	1fc992        	addi	a9, a9, 31
	return control->blocks[fl * control->sl_index_count + sl];
4037e180:	cc9a      	add.n	a12, a12, a9
4037e182:	a0cce0        	addx4	a12, a12, a14
4037e185:	0c38      	l32i.n	a3, a12, 0
	if (block)
4037e187:	1f2316        	beqz	a3, 4037e37d <tlsf_malloc+0x2e9>
4037e18a:	1358      	l32i.n	a5, a3, 4
4037e18c:	c47c      	movi.n	a4, -4
4037e18e:	104450        	and	a4, a4, a5
		tlsf_assert(block_size(block) >= size);
4037e191:	0bb4b7        	bgeu	a4, a11, 4037e1a0 <tlsf_malloc+0x10c>
4037e194:	db5bd1        	l32r	a13, 40374f00 <_iram_text_start+0xafc>
4037e197:	db5bc1        	l32r	a12, 40374f04 <_iram_text_start+0xb00>
4037e19a:	36a2b2        	movi	a11, 0x236
4037e19d:	ffe446        	j	4037e132 <tlsf_malloc+0x9e>
	block_header_t* prev = block->prev_free;
4037e1a0:	3358      	l32i.n	a5, a3, 12
	block_header_t* next = block->next_free;
4037e1a2:	2348      	l32i.n	a4, a3, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e1a4:	a5cc      	bnez.n	a5, 4037e1b2 <tlsf_malloc+0x11e>
4037e1a6:	db49d1        	l32r	a13, 40374ecc <_iram_text_start+0xac8>
4037e1a9:	db49c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037e1ac:	4aa1b2        	movi	a11, 0x14a
4037e1af:	ffdfc6        	j	4037e132 <tlsf_malloc+0x9e>
	tlsf_assert(next && "next_free field can not be null");
4037e1b2:	a4cc      	bnez.n	a4, 4037e1c0 <tlsf_malloc+0x12c>
4037e1b4:	db48d1        	l32r	a13, 40374ed4 <_iram_text_start+0xad0>
4037e1b7:	db46c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037e1ba:	4ba1b2        	movi	a11, 0x14b
4037e1bd:	ffdc46        	j	4037e132 <tlsf_malloc+0x9e>
	next->prev_free = prev;
4037e1c0:	3459      	s32i.n	a5, a4, 12
	prev->next_free = next;
4037e1c2:	2549      	s32i.n	a4, a5, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e1c4:	42a8      	l32i.n	a10, a2, 16
4037e1c6:	54aea0        	extui	a10, a10, 14, 6
4037e1c9:	82aa80        	mull	a10, a10, a8
4037e1cc:	aa9a      	add.n	a10, a10, a9
4037e1ce:	a0aae0        	addx4	a10, a10, a14
4037e1d1:	0a58      	l32i.n	a5, a10, 0
4037e1d3:	2d9357        	bne	a3, a5, 4037e204 <tlsf_malloc+0x170>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e1d6:	0a49      	s32i.n	a4, a10, 0
		if (next == &control->block_null)
4037e1d8:	289427        	bne	a4, a2, 4037e204 <tlsf_malloc+0x170>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e1db:	a0a8d0        	addx4	a10, a8, a13
4037e1de:	150c      	movi.n	a5, 1
4037e1e0:	0ac8      	l32i.n	a12, a10, 0
4037e1e2:	401900        	ssl	a9
4037e1e5:	a19500        	sll	a9, a5
4037e1e8:	f47c      	movi.n	a4, -1
4037e1ea:	309490        	xor	a9, a4, a9
4037e1ed:	1099c0        	and	a9, a9, a12
4037e1f0:	0a99      	s32i.n	a9, a10, 0
			if (!control->sl_bitmap[fl])
4037e1f2:	e9cc      	bnez.n	a9, 4037e204 <tlsf_malloc+0x170>
				control->fl_bitmap &= ~(1U << fl);
4037e1f4:	401800        	ssl	a8
4037e1f7:	a15500        	sll	a5, a5
4037e1fa:	304450        	xor	a4, a4, a5
4037e1fd:	6258      	l32i.n	a5, a2, 24
4037e1ff:	104540        	and	a4, a5, a4
4037e202:	6249      	s32i.n	a4, a2, 24
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e204:	1388      	l32i.n	a8, a3, 4
	tlsf_assert(block_is_free(block) && "block must be free");
4037e206:	0be807        	bbsi	a8, 0, 4037e215 <tlsf_malloc+0x181>
4037e209:	db3fd1        	l32r	a13, 40374f08 <_iram_text_start+0xb04>
4037e20c:	db40c1        	l32r	a12, 40374f0c <_iram_text_start+0xb08>
4037e20f:	f0a1b2        	movi	a11, 0x1f0
4037e212:	ffc706        	j	4037e132 <tlsf_malloc+0x9e>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e215:	c47c      	movi.n	a4, -4
4037e217:	108840        	and	a8, a8, a4
	return block_size(block) >= sizeof(block_header_t) + size;
4037e21a:	10cb52        	addi	a5, a11, 16
	return tlsf_cast(void*,
4037e21d:	c38b      	addi.n	a12, a3, 8
	if (block_can_split(block, size))
4037e21f:	02b857        	bgeu	a8, a5, 4037e225 <tlsf_malloc+0x191>
4037e222:	004d06        	j	4037e35a <tlsf_malloc+0x2c6>
		offset_to_block(block_to_ptr(block), size - block_header_overhead);
4037e225:	9b4a      	add.n	a9, a11, a4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e227:	99ca      	add.n	a9, a9, a12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037e229:	f9bb      	addi.n	a15, a9, 11
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037e22b:	c054b0        	sub	a5, a4, a11
	return tlsf_cast(void*,
4037e22e:	a98b      	addi.n	a10, a9, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037e230:	10ff40        	and	a15, a15, a4
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037e233:	558a      	add.n	a5, a5, a8
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037e235:	0b1af7        	beq	a10, a15, 4037e244 <tlsf_malloc+0x1b0>
4037e238:	db36d1        	l32r	a13, 40374f10 <_iram_text_start+0xb0c>
4037e23b:	db36c1        	l32r	a12, 40374f14 <_iram_text_start+0xb10>
4037e23e:	9aa1b2        	movi	a11, 0x19a
4037e241:	ffbb46        	j	4037e132 <tlsf_malloc+0x9e>
	tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
4037e244:	fb4b      	addi.n	a15, a11, 4
4037e246:	ff5a      	add.n	a15, a15, a5
4037e248:	0c18f7        	beq	a8, a15, 4037e258 <tlsf_malloc+0x1c4>
4037e24b:	db33d1        	l32r	a13, 40374f18 <_iram_text_start+0xb14>
4037e24e:	db31c1        	l32r	a12, 40374f14 <_iram_text_start+0xb10>
4037e251:	9da1b2        	movi	a11, 0x19d
4037e254:	ffb686        	j	4037e132 <tlsf_malloc+0x9e>
4037e257:	00          	.byte 00
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037e258:	19f8      	l32i.n	a15, a9, 4
4037e25a:	14f0f0        	extui	a15, a15, 0, 2
4037e25d:	20ff50        	or	a15, a15, a5
4037e260:	19f9      	s32i.n	a15, a9, 4
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037e262:	b50c      	movi.n	a5, 11
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e264:	10ff40        	and	a15, a15, a4
4037e267:	0b35f7        	bltu	a5, a15, 4037e276 <tlsf_malloc+0x1e2>
4037e26a:	db2cd1        	l32r	a13, 40374f1c <_iram_text_start+0xb18>
4037e26d:	db29c1        	l32r	a12, 40374f14 <_iram_text_start+0xb10>
4037e270:	9fa1b2        	movi	a11, 0x19f
4037e273:	ffaec6        	j	4037e132 <tlsf_malloc+0x9e>
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037e276:	1388      	l32i.n	a8, a3, 4
4037e278:	148080        	extui	a8, a8, 0, 2
4037e27b:	2088b0        	or	a8, a8, a11
4037e27e:	1389      	s32i.n	a8, a3, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e280:	1988      	l32i.n	a8, a9, 4
4037e282:	108480        	and	a8, a4, a8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e285:	aa8a      	add.n	a10, a10, a8
4037e287:	fccaa2        	addi	a10, a10, -4
	tlsf_assert(!block_is_last(block));
4037e28a:	c8cc      	bnez.n	a8, 4037e29a <tlsf_malloc+0x206>
4037e28c:	db0ad1        	l32r	a13, 40374eb4 <_iram_text_start+0xab0>
4037e28f:	db0ac1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4>
4037e292:	db0aa1        	l32r	a10, 40374ebc <_iram_text_start+0xab8>
4037e295:	eb5c      	movi.n	a11, 94
4037e297:	ffa686        	j	4037e135 <tlsf_malloc+0xa1>
	block->size |= block_header_prev_free_bit;
4037e29a:	1a58      	l32i.n	a5, a10, 4
4037e29c:	280c      	movi.n	a8, 2
4037e29e:	205580        	or	a5, a5, a8
4037e2a1:	1a59      	s32i.n	a5, a10, 4
	block->size |= block_header_free_bit;
4037e2a3:	1988      	l32i.n	a8, a9, 4
4037e2a5:	150c      	movi.n	a5, 1
	next->prev_phys_block = block;
4037e2a7:	0a99      	s32i.n	a9, a10, 0
	block->size |= block_header_free_bit;
4037e2a9:	205850        	or	a5, a8, a5
4037e2ac:	1959      	s32i.n	a5, a9, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e2ae:	13a8      	l32i.n	a10, a3, 4
4037e2b0:	10a4a0        	and	a10, a4, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e2b3:	5caa      	add.n	a5, a12, a10
4037e2b5:	fcc552        	addi	a5, a5, -4
	tlsf_assert(!block_is_last(block));
4037e2b8:	fd0a16        	beqz	a10, 4037e28c <tlsf_malloc+0x1f8>
	next->prev_phys_block = block;
4037e2bb:	0539      	s32i.n	a3, a5, 0
	block->size |= block_header_prev_free_bit;
4037e2bd:	350c      	movi.n	a5, 3
4037e2bf:	205850        	or	a5, a8, a5
4037e2c2:	1959      	s32i.n	a5, a9, 4
	if (size < control->small_block_size)
4037e2c4:	42b8      	l32i.n	a11, a2, 16
4037e2c6:	108840        	and	a8, a8, a4
4037e2c9:	7547b0        	extui	a4, a11, 23, 8
4037e2cc:	25b847        	bgeu	a8, a4, 4037e2f5 <tlsf_malloc+0x261>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e2cf:	545eb0        	extui	a5, a11, 14, 6
4037e2d2:	d24450        	quos	a4, a4, a5
4037e2d5:	d28840        	quos	a8, a8, a4
		fl = 0;
4037e2d8:	0a0c      	movi.n	a10, 0
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037e2da:	54beb0        	extui	a11, a11, 14, 6
4037e2dd:	82bba0        	mull	a11, a11, a10
4037e2e0:	bb8a      	add.n	a11, a11, a8
4037e2e2:	a0bbe0        	addx4	a11, a11, a14
4037e2e5:	0b48      	l32i.n	a4, a11, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037e2e7:	b4fc      	bnez.n	a4, 4037e326 <tlsf_malloc+0x292>
4037e2e9:	db00d1        	l32r	a13, 40374eec <_iram_text_start+0xae8>
4037e2ec:	db01c1        	l32r	a12, 40374ef0 <_iram_text_start+0xaec>
4037e2ef:	66a1b2        	movi	a11, 0x166
4037e2f2:	ff8f06        	j	4037e132 <tlsf_malloc+0x9e>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e2f5:	00a0a2        	movi	a10, 0
4037e2f8:	0818a7        	beq	a8, a10, 4037e304 <tlsf_malloc+0x270>
4037e2fb:	40f840        	nsau	a4, a8
4037e2fe:	20a0a2        	movi	a10, 32
4037e301:	c0aa40        	sub	a10, a10, a4
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e304:	2554b0        	extui	a5, a11, 20, 3
	return bit - 1;
4037e307:	4a0b      	addi.n	a4, a10, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e309:	c04450        	sub	a4, a4, a5
4037e30c:	400400        	ssr	a4
4037e30f:	918080        	srl	a8, a8
4037e312:	140c      	movi.n	a4, 1
4037e314:	401500        	ssl	a5
4037e317:	a14400        	sll	a4, a4
4037e31a:	308840        	xor	a8, a8, a4
		fl -= (control->fl_index_shift - 1);
4037e31d:	2445b0        	extui	a4, a11, 5, 3
4037e320:	c0aa40        	sub	a10, a10, a4
4037e323:	ffecc6        	j	4037e2da <tlsf_malloc+0x246>
	block->next_free = current;
4037e326:	2949      	s32i.n	a4, a9, 8
	block->prev_free = &control->block_null;
4037e328:	3929      	s32i.n	a2, a9, 12
	current->prev_free = block;
4037e32a:	3499      	s32i.n	a9, a4, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037e32c:	42b8      	l32i.n	a11, a2, 16
	control->fl_bitmap |= (1U << fl);
4037e32e:	6258      	l32i.n	a5, a2, 24
	control->blocks[fl * control->sl_index_count + sl] = block;
4037e330:	54beb0        	extui	a11, a11, 14, 6
4037e333:	82bba0        	mull	a11, a11, a10
	control->fl_bitmap |= (1U << fl);
4037e336:	140c      	movi.n	a4, 1
	control->blocks[fl * control->sl_index_count + sl] = block;
4037e338:	bb8a      	add.n	a11, a11, a8
4037e33a:	a0bbe0        	addx4	a11, a11, a14
4037e33d:	0b99      	s32i.n	a9, a11, 0
	control->fl_bitmap |= (1U << fl);
4037e33f:	401a00        	ssl	a10
4037e342:	a19400        	sll	a9, a4
4037e345:	205590        	or	a5, a5, a9
4037e348:	6259      	s32i.n	a5, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037e34a:	a0aad0        	addx4	a10, a10, a13
4037e34d:	0a28      	l32i.n	a2, a10, 0
4037e34f:	401800        	ssl	a8
4037e352:	a14400        	sll	a4, a4
4037e355:	202240        	or	a2, a2, a4
4037e358:	0a29      	s32i.n	a2, a10, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e35a:	1328      	l32i.n	a2, a3, 4
4037e35c:	c47c      	movi.n	a4, -4
4037e35e:	104420        	and	a4, a4, a2
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e361:	2c4a      	add.n	a2, a12, a4
4037e363:	fcc222        	addi	a2, a2, -4
	tlsf_assert(!block_is_last(block));
4037e366:	f22416        	beqz	a4, 4037e28c <tlsf_malloc+0x1f8>
	block->size &= ~block_header_prev_free_bit;
4037e369:	1248      	l32i.n	a4, a2, 4
4037e36b:	d57c      	movi.n	a5, -3
4037e36d:	104450        	and	a4, a4, a5
4037e370:	1249      	s32i.n	a4, a2, 4
	block->size &= ~block_header_free_bit;
4037e372:	1328      	l32i.n	a2, a3, 4
4037e374:	e47c      	movi.n	a4, -2
4037e376:	102240        	and	a2, a2, a4
4037e379:	1329      	s32i.n	a2, a3, 4
		p = block_to_ptr(block);
4037e37b:	0c3d      	mov.n	a3, a12
}
4037e37d:	032d      	mov.n	a2, a3
4037e37f:	f01d      	retw.n
	void* p = 0;
4037e381:	030c      	movi.n	a3, 0
4037e383:	fffd86        	j	4037e37d <tlsf_malloc+0x2e9>
	...

4037e388 <tlsf_realloc>:
**   untouched
** - an extended buffer size will leave the newly-allocated area with
**   contents undefined
*/
void* tlsf_realloc(tlsf_t tlsf, void* ptr, size_t size)
{
4037e388:	008136        	entry	a1, 64
4037e38b:	049d      	mov.n	a9, a4
	control_t* control = tlsf_cast(control_t*, tlsf);
	void* p = 0;

	/* Zero-size requests are treated as free. */
	if (ptr && size == 0)
4037e38d:	f38c      	beqz.n	a3, 4037e3a0 <tlsf_realloc+0x18>
4037e38f:	b4cc      	bnez.n	a4, 4037e39e <tlsf_realloc+0x16>
	{
		tlsf_free(tlsf, ptr);
4037e391:	03bd      	mov.n	a11, a3
4037e393:	02ad      	mov.n	a10, a2
4037e395:	ff9e65        	call8	4037dd7c <tlsf_free>
		const size_t adjust = adjust_request_size(tlsf, size, ALIGN_SIZE);

		// if adjust if equal to 0, the size is too big
		if (adjust == 0)
		{
			return p;
4037e398:	050c      	movi.n	a5, 0
4037e39a:	000386        	j	4037e3ac <tlsf_realloc+0x24>
4037e39d:	00          	.byte 00
	else if (!ptr)
4037e39e:	e3cc      	bnez.n	a3, 4037e3b0 <tlsf_realloc+0x28>
		p = tlsf_malloc(tlsf, size);
4037e3a0:	20b990        	or	a11, a9, a9
4037e3a3:	20a220        	or	a10, a2, a2
4037e3a6:	ffcee5        	call8	4037e094 <tlsf_malloc>
4037e3a9:	205aa0        	or	a5, a10, a10
			p = ptr;
		}
	}

	return p;
}
4037e3ac:	052d      	mov.n	a2, a5
4037e3ae:	f01d      	retw.n
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e3b0:	f8c362        	addi	a6, a3, -8
4037e3b3:	16d8      	l32i.n	a13, a6, 4
4037e3b5:	c87c      	movi.n	a8, -4
4037e3b7:	10cd80        	and	a12, a13, a8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e3ba:	438a      	add.n	a4, a3, a8
4037e3bc:	7c4a      	add.n	a7, a12, a4
	tlsf_assert(!block_is_last(block));
4037e3be:	dccc      	bnez.n	a12, 4037e3cf <tlsf_realloc+0x47>
4037e3c0:	dabdd1        	l32r	a13, 40374eb4 <_iram_text_start+0xab0>
4037e3c3:	dabdc1        	l32r	a12, 40374eb8 <_iram_text_start+0xab4>
4037e3c6:	dabda1        	l32r	a10, 40374ebc <_iram_text_start+0xab8>
4037e3c9:	5ea0b2        	movi	a11, 94
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037e3cc:	0043e5        	call8	4037e80c <__assert_func>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e3cf:	0127b2        	l32i	a11, a7, 4
	if (size)
4037e3d2:	fc2916        	beqz	a9, 4037e398 <tlsf_realloc+0x10>
	return (x + (align - 1)) & ~(align - 1);
4037e3d5:	593b      	addi.n	a5, a9, 3
		if (aligned < tlsf_block_size_max(tlsf)) 
4037e3d7:	02ad      	mov.n	a10, a2
	return (x + (align - 1)) & ~(align - 1);
4037e3d9:	105580        	and	a5, a5, a8
		if (aligned < tlsf_block_size_max(tlsf)) 
4037e3dc:	2189      	s32i.n	a8, a1, 8
4037e3de:	4199      	s32i.n	a9, a1, 16
4037e3e0:	01b9      	s32i.n	a11, a1, 0
4037e3e2:	31c9      	s32i.n	a12, a1, 12
4037e3e4:	11d9      	s32i.n	a13, a1, 4
4037e3e6:	ff9825        	call8	4037dd68 <tlsf_block_size_max>
4037e3e9:	2188      	l32i.n	a8, a1, 8
4037e3eb:	4198      	l32i.n	a9, a1, 16
4037e3ed:	01b8      	l32i.n	a11, a1, 0
4037e3ef:	31c8      	l32i.n	a12, a1, 12
4037e3f1:	11d8      	l32i.n	a13, a1, 4
4037e3f3:	a1b5a7        	bgeu	a5, a10, 4037e398 <tlsf_realloc+0x10>
			adjust = tlsf_max(aligned, block_size_min);
4037e3f6:	ca0c      	movi.n	a10, 12
4037e3f8:	7355a0        	maxu	a5, a5, a10
		tlsf_assert(!block_is_free(block) && "block already marked as free");
4037e3fb:	0e6d07        	bbci	a13, 0, 4037e40d <tlsf_realloc+0x85>
4037e3fe:	daaad1        	l32r	a13, 40374ea8 <_iram_text_start+0xaa4>
4037e401:	dac7c1        	l32r	a12, 40374f20 <_iram_text_start+0xb1c>
4037e404:	92a4b2        	movi	a11, 0x492
4037e407:	daaaa1        	l32r	a10, 40374eb0 <_iram_text_start+0xaac>
4037e40a:	ffef86        	j	4037e3cc <tlsf_realloc+0x44>
		if (adjust > cursize && (!block_is_free(next) || adjust > combined))
4037e40d:	023c57        	bltu	a12, a5, 4037e413 <tlsf_realloc+0x8b>
4037e410:	005306        	j	4037e560 <tlsf_realloc+0x1d8>
4037e413:	108b80        	and	a8, a11, a8
		const size_t combined = cursize + block_size(next) + block_header_overhead;
4037e416:	ac4b      	addi.n	a10, a12, 4
4037e418:	aa8a      	add.n	a10, a10, a8
		if (adjust > cursize && (!block_is_free(next) || adjust > combined))
4037e41a:	023a57        	bltu	a10, a5, 4037e420 <tlsf_realloc+0x98>
4037e41d:	2deb07        	bbsi	a11, 0, 4037e44e <tlsf_realloc+0xc6>
			p = tlsf_malloc(tlsf, size);
4037e420:	20b990        	or	a11, a9, a9
4037e423:	20a220        	or	a10, a2, a2
4037e426:	4199      	s32i.n	a9, a1, 16
4037e428:	31c9      	s32i.n	a12, a1, 12
4037e42a:	ffc6a5        	call8	4037e094 <tlsf_malloc>
			if (p)
4037e42d:	4198      	l32i.n	a9, a1, 16
4037e42f:	31c8      	l32i.n	a12, a1, 12
			p = tlsf_malloc(tlsf, size);
4037e431:	0a5d      	mov.n	a5, a10
			if (p)
4037e433:	f75a16        	beqz	a10, 4037e3ac <tlsf_realloc+0x24>
				memcpy(p, ptr, minsize);
4037e436:	03bd      	mov.n	a11, a3
4037e438:	63c9c0        	minu	a12, a9, a12
4037e43b:	d81d81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037e43e:	0008e0        	callx8	a8
				tlsf_free(tlsf, ptr);
4037e441:	03bd      	mov.n	a11, a3
4037e443:	02ad      	mov.n	a10, a2
4037e445:	ff9365        	call8	4037dd7c <tlsf_free>
4037e448:	ffd806        	j	4037e3ac <tlsf_realloc+0x24>
4037e44b:	00          	.byte 00
4037e44c:	00          	.byte 00
4037e44d:	00          	.byte 00
	tlsf_assert(next && "next physical block can't be null");
4037e44e:	a7cc      	bnez.n	a7, 4037e45c <tlsf_realloc+0xd4>
4037e450:	daa5d1        	l32r	a13, 40374ee4 <_iram_text_start+0xae0>
4037e453:	daa5c1        	l32r	a12, 40374ee8 <_iram_text_start+0xae4>
4037e456:	e1a1b2        	movi	a11, 0x1e1
4037e459:	ffea86        	j	4037e407 <tlsf_realloc+0x7f>
	if (size < control->small_block_size)
4037e45c:	42a8      	l32i.n	a10, a2, 16
4037e45e:	7597a0        	extui	a9, a10, 23, 8
4037e461:	1cb897        	bgeu	a8, a9, 4037e481 <tlsf_realloc+0xf9>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e464:	54aea0        	extui	a10, a10, 14, 6
4037e467:	d299a0        	quos	a9, a9, a10
4037e46a:	d28890        	quos	a8, a8, a9
		fl = 0;
4037e46d:	090c      	movi.n	a9, 0
	block_header_t* prev = block->prev_free;
4037e46f:	37a8      	l32i.n	a10, a7, 12
	block_header_t* next = block->next_free;
4037e471:	27b8      	l32i.n	a11, a7, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e473:	bafc      	bnez.n	a10, 4037e4b2 <tlsf_realloc+0x12a>
4037e475:	da95d1        	l32r	a13, 40374ecc <_iram_text_start+0xac8>
4037e478:	da96c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037e47b:	4aa1b2        	movi	a11, 0x14a
4037e47e:	ffe146        	j	4037e407 <tlsf_realloc+0x7f>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e481:	00a092        	movi	a9, 0
4037e484:	081897        	beq	a8, a9, 4037e490 <tlsf_realloc+0x108>
4037e487:	40f8b0        	nsau	a11, a8
4037e48a:	20a092        	movi	a9, 32
4037e48d:	c099b0        	sub	a9, a9, a11
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e490:	25c4a0        	extui	a12, a10, 20, 3
	return bit - 1;
4037e493:	b90b      	addi.n	a11, a9, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e495:	c0bbc0        	sub	a11, a11, a12
4037e498:	400b00        	ssr	a11
4037e49b:	918080        	srl	a8, a8
4037e49e:	1b0c      	movi.n	a11, 1
4037e4a0:	401c00        	ssl	a12
4037e4a3:	a1bb00        	sll	a11, a11
		fl -= (control->fl_index_shift - 1);
4037e4a6:	24a5a0        	extui	a10, a10, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e4a9:	3088b0        	xor	a8, a8, a11
		fl -= (control->fl_index_shift - 1);
4037e4ac:	c099a0        	sub	a9, a9, a10
4037e4af:	ffef06        	j	4037e46f <tlsf_realloc+0xe7>
	tlsf_assert(next && "next_free field can not be null");
4037e4b2:	abcc      	bnez.n	a11, 4037e4c0 <tlsf_realloc+0x138>
4037e4b4:	da88d1        	l32r	a13, 40374ed4 <_iram_text_start+0xad0>
4037e4b7:	da86c1        	l32r	a12, 40374ed0 <_iram_text_start+0xacc>
4037e4ba:	4ba1b2        	movi	a11, 0x14b
4037e4bd:	ffd186        	j	4037e407 <tlsf_realloc+0x7f>
	next->prev_free = prev;
4037e4c0:	3ba9      	s32i.n	a10, a11, 12
	prev->next_free = next;
4037e4c2:	2ab9      	s32i.n	a11, a10, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e4c4:	42a8      	l32i.n	a10, a2, 16
4037e4c6:	82c8      	l32i.n	a12, a2, 32
4037e4c8:	54aea0        	extui	a10, a10, 14, 6
4037e4cb:	82aa90        	mull	a10, a10, a9
4037e4ce:	aa8a      	add.n	a10, a10, a8
4037e4d0:	a0aac0        	addx4	a10, a10, a12
4037e4d3:	0ac8      	l32i.n	a12, a10, 0
4037e4d5:	309c77        	bne	a12, a7, 4037e509 <tlsf_realloc+0x181>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e4d8:	0ab9      	s32i.n	a11, a10, 0
		if (next == &control->block_null)
4037e4da:	2b9b27        	bne	a11, a2, 4037e509 <tlsf_realloc+0x181>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e4dd:	72c8      	l32i.n	a12, a2, 28
4037e4df:	1b0c      	movi.n	a11, 1
4037e4e1:	a0c9c0        	addx4	a12, a9, a12
4037e4e4:	0cd8      	l32i.n	a13, a12, 0
4037e4e6:	401800        	ssl	a8
4037e4e9:	a18b00        	sll	a8, a11
4037e4ec:	fa7c      	movi.n	a10, -1
4037e4ee:	308a80        	xor	a8, a10, a8
4037e4f1:	1088d0        	and	a8, a8, a13
4037e4f4:	0c89      	s32i.n	a8, a12, 0
			if (!control->sl_bitmap[fl])
4037e4f6:	f8cc      	bnez.n	a8, 4037e509 <tlsf_realloc+0x181>
				control->fl_bitmap &= ~(1U << fl);
4037e4f8:	6288      	l32i.n	a8, a2, 24
4037e4fa:	401900        	ssl	a9
4037e4fd:	a1bb00        	sll	a11, a11
4037e500:	30aab0        	xor	a10, a10, a11
4037e503:	1088a0        	and	a8, a8, a10
4037e506:	066282        	s32i	a8, a2, 24
4037e509:	1698      	l32i.n	a9, a6, 4
4037e50b:	ca7c      	movi.n	a10, -4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037e50d:	0b89a7        	bany	a9, a10, 4037e51c <tlsf_realloc+0x194>
4037e510:	da72d1        	l32r	a13, 40374ed8 <_iram_text_start+0xad4>
4037e513:	da72c1        	l32r	a12, 40374edc <_iram_text_start+0xad8>
4037e516:	c1a1b2        	movi	a11, 0x1c1
4037e519:	ffba86        	j	4037e407 <tlsf_realloc+0x7f>
4037e51c:	1788      	l32i.n	a8, a7, 4
	prev->size += block_size(block) + block_header_overhead;
4037e51e:	994b      	addi.n	a9, a9, 4
4037e520:	108a80        	and	a8, a10, a8
4037e523:	889a      	add.n	a8, a8, a9
4037e525:	1689      	s32i.n	a8, a6, 4
4037e527:	1088a0        	and	a8, a8, a10
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e52a:	948a      	add.n	a9, a4, a8
	tlsf_assert(!block_is_last(block));
4037e52c:	e90816        	beqz	a8, 4037e3c0 <tlsf_realloc+0x38>
	if (block_absorb_post_hook != NULL)
4037e52f:	da6c81        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
	next->prev_phys_block = block;
4037e532:	0969      	s32i.n	a6, a9, 0
4037e534:	a88c      	beqz.n	a8, 4037e542 <tlsf_realloc+0x1ba>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037e536:	1c0c      	movi.n	a12, 1
4037e538:	0b1c      	movi.n	a11, 16
4037e53a:	07ad      	mov.n	a10, a7
4037e53c:	da6981        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
4037e53f:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e542:	1688      	l32i.n	a8, a6, 4
4037e544:	c77c      	movi.n	a7, -4
4037e546:	107780        	and	a7, a7, a8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e549:	874a      	add.n	a8, a7, a4
	tlsf_assert(!block_is_last(block));
4037e54b:	e71716        	beqz	a7, 4037e3c0 <tlsf_realloc+0x38>
	block->size &= ~block_header_prev_free_bit;
4037e54e:	1878      	l32i.n	a7, a8, 4
4037e550:	d97c      	movi.n	a9, -3
4037e552:	107790        	and	a7, a7, a9
4037e555:	1879      	s32i.n	a7, a8, 4
	block->size &= ~block_header_free_bit;
4037e557:	1678      	l32i.n	a7, a6, 4
4037e559:	e87c      	movi.n	a8, -2
4037e55b:	107780        	and	a7, a7, a8
4037e55e:	1679      	s32i.n	a7, a6, 4
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e560:	1678      	l32i.n	a7, a6, 4
	tlsf_assert(!block_is_free(block) && "block must be used");
4037e562:	0b6707        	bbci	a7, 0, 4037e571 <tlsf_realloc+0x1e9>
4037e565:	da6fd1        	l32r	a13, 40374f24 <_iram_text_start+0xb20>
4037e568:	da70c1        	l32r	a12, 40374f28 <_iram_text_start+0xb24>
4037e56b:	fda1b2        	movi	a11, 0x1fd
4037e56e:	ffa546        	j	4037e407 <tlsf_realloc+0x7f>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e571:	c97c      	movi.n	a9, -4
4037e573:	107790        	and	a7, a7, a9
	return block_size(block) >= sizeof(block_header_t) + size;
4037e576:	10c582        	addi	a8, a5, 16
	if (block_can_split(block, size))
4037e579:	02b787        	bgeu	a7, a8, 4037e57f <tlsf_realloc+0x1f7>
4037e57c:	007a06        	j	4037e768 <tlsf_realloc+0x3e0>
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e57f:	454a      	add.n	a4, a5, a4
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037e581:	84bb      	addi.n	a8, a4, 11
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037e583:	779a      	add.n	a7, a7, a9
	return tlsf_cast(void*,
4037e585:	b48b      	addi.n	a11, a4, 8
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
4037e587:	108890        	and	a8, a8, a9
	const size_t remain_size = block_size(block) - (size + block_header_overhead);
4037e58a:	c07750        	sub	a7, a7, a5
	tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
4037e58d:	0b1b87        	beq	a11, a8, 4037e59c <tlsf_realloc+0x214>
4037e590:	da60d1        	l32r	a13, 40374f10 <_iram_text_start+0xb0c>
4037e593:	da60c1        	l32r	a12, 40374f14 <_iram_text_start+0xb10>
4037e596:	9aa1b2        	movi	a11, 0x19a
4037e599:	ff9a86        	j	4037e407 <tlsf_realloc+0x7f>
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037e59c:	1488      	l32i.n	a8, a4, 4
4037e59e:	148080        	extui	a8, a8, 0, 2
4037e5a1:	207870        	or	a7, a8, a7
4037e5a4:	1479      	s32i.n	a7, a4, 4
	tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
4037e5a6:	b80c      	movi.n	a8, 11
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e5a8:	107790        	and	a7, a7, a9
4037e5ab:	0b3877        	bltu	a8, a7, 4037e5ba <tlsf_realloc+0x232>
4037e5ae:	da5bd1        	l32r	a13, 40374f1c <_iram_text_start+0xb18>
4037e5b1:	da58c1        	l32r	a12, 40374f14 <_iram_text_start+0xb10>
4037e5b4:	9fa1b2        	movi	a11, 0x19f
4037e5b7:	ff9306        	j	4037e407 <tlsf_realloc+0x7f>
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
4037e5ba:	1678      	l32i.n	a7, a6, 4
4037e5bc:	147070        	extui	a7, a7, 0, 2
4037e5bf:	205750        	or	a5, a7, a5
4037e5c2:	1659      	s32i.n	a5, a6, 4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e5c4:	1468      	l32i.n	a6, a4, 4
4037e5c6:	106960        	and	a6, a9, a6
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e5c9:	5b6a      	add.n	a5, a11, a6
4037e5cb:	fcc552        	addi	a5, a5, -4
	tlsf_assert(!block_is_last(block));
4037e5ce:	dee616        	beqz	a6, 4037e3c0 <tlsf_realloc+0x38>
	block->size |= block_header_prev_free_bit;
4037e5d1:	1568      	l32i.n	a6, a5, 4
4037e5d3:	270c      	movi.n	a7, 2
4037e5d5:	206670        	or	a6, a6, a7
4037e5d8:	1569      	s32i.n	a6, a5, 4
	next->prev_phys_block = block;
4037e5da:	0549      	s32i.n	a4, a5, 0
	block->size |= block_header_free_bit;
4037e5dc:	1458      	l32i.n	a5, a4, 4
	block->size &= ~block_header_prev_free_bit;
4037e5de:	d67c      	movi.n	a6, -3
4037e5e0:	106560        	and	a6, a5, a6
4037e5e3:	170c      	movi.n	a7, 1
4037e5e5:	206670        	or	a6, a6, a7
4037e5e8:	105590        	and	a5, a5, a9
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e5eb:	a5ba      	add.n	a10, a5, a11
	block->size &= ~block_header_prev_free_bit;
4037e5ed:	1469      	s32i.n	a6, a4, 4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e5ef:	fccaa2        	addi	a10, a10, -4
	tlsf_assert(!block_is_last(block));
4037e5f2:	dca516        	beqz	a5, 4037e3c0 <tlsf_realloc+0x38>
	tlsf_assert(next && "next physical block can't be null");
4037e5f5:	e57a16        	beqz	a10, 4037e450 <tlsf_realloc+0xc8>
	if (size < control->small_block_size)
4037e5f8:	4258      	l32i.n	a5, a2, 16
	return tlsf_cast(int, block->size & block_header_free_bit);
4037e5fa:	1a88      	l32i.n	a8, a10, 4
4037e5fc:	756750        	extui	a6, a5, 23, 8
	if (block_is_free(next))
4037e5ff:	02e807        	bbsi	a8, 0, 4037e605 <tlsf_realloc+0x27d>
4037e602:	002586        	j	4037e69c <tlsf_realloc+0x314>
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e605:	108890        	and	a8, a8, a9
	if (size < control->small_block_size)
4037e608:	023867        	bltu	a8, a6, 4037e60e <tlsf_realloc+0x286>
4037e60b:	003086        	j	4037e6d1 <tlsf_realloc+0x349>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e60e:	545e50        	extui	a5, a5, 14, 6
4037e611:	d26650        	quos	a6, a6, a5
4037e614:	d28860        	quos	a8, a8, a6
		fl = 0;
4037e617:	0c0c      	movi.n	a12, 0
	block_header_t* prev = block->prev_free;
4037e619:	3a58      	l32i.n	a5, a10, 12
	block_header_t* next = block->next_free;
4037e61b:	2a68      	l32i.n	a6, a10, 8
	tlsf_assert(prev && "prev_free field can not be null");
4037e61d:	e54516        	beqz	a5, 4037e475 <tlsf_realloc+0xed>
	tlsf_assert(next && "next_free field can not be null");
4037e620:	e90616        	beqz	a6, 4037e4b4 <tlsf_realloc+0x12c>
	next->prev_free = prev;
4037e623:	3659      	s32i.n	a5, a6, 12
	prev->next_free = next;
4037e625:	2569      	s32i.n	a6, a5, 8
	if (control->blocks[fl * control->sl_index_count + sl] == block)
4037e627:	4298      	l32i.n	a9, a2, 16
4037e629:	8258      	l32i.n	a5, a2, 32
4037e62b:	549e90        	extui	a9, a9, 14, 6
4037e62e:	8299c0        	mull	a9, a9, a12
4037e631:	998a      	add.n	a9, a9, a8
4037e633:	a09950        	addx4	a9, a9, a5
4037e636:	0958      	l32i.n	a5, a9, 0
4037e638:	309a57        	bne	a10, a5, 4037e66c <tlsf_realloc+0x2e4>
		control->blocks[fl * control->sl_index_count + sl] = next;
4037e63b:	0969      	s32i.n	a6, a9, 0
		if (next == &control->block_null)
4037e63d:	2b9627        	bne	a6, a2, 4037e66c <tlsf_realloc+0x2e4>
			control->sl_bitmap[fl] &= ~(1U << sl);
4037e640:	7278      	l32i.n	a7, a2, 28
4037e642:	160c      	movi.n	a6, 1
4037e644:	a07c70        	addx4	a7, a12, a7
4037e647:	0798      	l32i.n	a9, a7, 0
4037e649:	401800        	ssl	a8
4037e64c:	a18600        	sll	a8, a6
4037e64f:	f57c      	movi.n	a5, -1
4037e651:	308580        	xor	a8, a5, a8
4037e654:	108890        	and	a8, a8, a9
4037e657:	0789      	s32i.n	a8, a7, 0
			if (!control->sl_bitmap[fl])
4037e659:	f8cc      	bnez.n	a8, 4037e66c <tlsf_realloc+0x2e4>
				control->fl_bitmap &= ~(1U << fl);
4037e65b:	401c00        	ssl	a12
4037e65e:	a16600        	sll	a6, a6
4037e661:	305560        	xor	a5, a5, a6
4037e664:	6268      	l32i.n	a6, a2, 24
4037e666:	105650        	and	a5, a6, a5
4037e669:	066252        	s32i	a5, a2, 24
4037e66c:	1468      	l32i.n	a6, a4, 4
4037e66e:	c77c      	movi.n	a7, -4
	tlsf_assert(!block_is_last(prev) && "previous block can't be last");
4037e670:	028677        	bany	a6, a7, 4037e676 <tlsf_realloc+0x2ee>
4037e673:	ffa646        	j	4037e510 <tlsf_realloc+0x188>
4037e676:	1a58      	l32i.n	a5, a10, 4
	prev->size += block_size(block) + block_header_overhead;
4037e678:	664b      	addi.n	a6, a6, 4
4037e67a:	105750        	and	a5, a7, a5
4037e67d:	556a      	add.n	a5, a5, a6
4037e67f:	1459      	s32i.n	a5, a4, 4
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e681:	bb7a      	add.n	a11, a11, a7
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e683:	105570        	and	a5, a5, a7
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
4037e686:	bb5a      	add.n	a11, a11, a5
	tlsf_assert(!block_is_last(block));
4037e688:	d34516        	beqz	a5, 4037e3c0 <tlsf_realloc+0x38>
	if (block_absorb_post_hook != NULL)
4037e68b:	da1551        	l32r	a5, 40374ee0 <_iram_text_start+0xadc>
	next->prev_phys_block = block;
4037e68e:	0b49      	s32i.n	a4, a11, 0
4037e690:	858c      	beqz.n	a5, 4037e69c <tlsf_realloc+0x314>
		block_absorb_post_hook(block, sizeof(block_header_t), POISONING_AFTER_FREE);
4037e692:	1c0c      	movi.n	a12, 1
4037e694:	0b1c      	movi.n	a11, 16
4037e696:	da1281        	l32r	a8, 40374ee0 <_iram_text_start+0xadc>
4037e699:	0008e0        	callx8	a8
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
4037e69c:	1468      	l32i.n	a6, a4, 4
	if (size < control->small_block_size)
4037e69e:	4298      	l32i.n	a9, a2, 16
4037e6a0:	c57c      	movi.n	a5, -4
4037e6a2:	105560        	and	a5, a5, a6
4037e6a5:	757790        	extui	a7, a9, 23, 8
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e6a8:	546e90        	extui	a6, a9, 14, 6
	if (size < control->small_block_size)
4037e6ab:	53b577        	bgeu	a5, a7, 4037e702 <tlsf_realloc+0x37a>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
4037e6ae:	d27760        	quos	a7, a7, a6
4037e6b1:	d27570        	quos	a7, a5, a7
		fl = 0;
4037e6b4:	080c      	movi.n	a8, 0
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
4037e6b6:	826860        	mull	a6, a8, a6
4037e6b9:	8298      	l32i.n	a9, a2, 32
4037e6bb:	667a      	add.n	a6, a6, a7
4037e6bd:	a06690        	addx4	a6, a6, a9
4037e6c0:	0658      	l32i.n	a5, a6, 0
	tlsf_assert(current && "free list cannot have a null entry");
4037e6c2:	06c556        	bnez	a5, 4037e732 <tlsf_realloc+0x3aa>
4037e6c5:	da09d1        	l32r	a13, 40374eec <_iram_text_start+0xae8>
4037e6c8:	da0ac1        	l32r	a12, 40374ef0 <_iram_text_start+0xaec>
4037e6cb:	66a1b2        	movi	a11, 0x166
4037e6ce:	ff4d46        	j	4037e407 <tlsf_realloc+0x7f>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e6d1:	00a0c2        	movi	a12, 0
4037e6d4:	0818c7        	beq	a8, a12, 4037e6e0 <tlsf_realloc+0x358>
4037e6d7:	40f860        	nsau	a6, a8
4037e6da:	20a0c2        	movi	a12, 32
4037e6dd:	c0cc60        	sub	a12, a12, a6
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e6e0:	257450        	extui	a7, a5, 20, 3
	return bit - 1;
4037e6e3:	6c0b      	addi.n	a6, a12, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e6e5:	c06670        	sub	a6, a6, a7
4037e6e8:	400600        	ssr	a6
4037e6eb:	918080        	srl	a8, a8
4037e6ee:	160c      	movi.n	a6, 1
4037e6f0:	401700        	ssl	a7
4037e6f3:	a16600        	sll	a6, a6
		fl -= (control->fl_index_shift - 1);
4037e6f6:	245550        	extui	a5, a5, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e6f9:	308860        	xor	a8, a8, a6
		fl -= (control->fl_index_shift - 1);
4037e6fc:	c0cc50        	sub	a12, a12, a5
4037e6ff:	ffc586        	j	4037e619 <tlsf_realloc+0x291>
	const int bit = word ? 32 - __builtin_clz(word) : 0;
4037e702:	080c      	movi.n	a8, 0
4037e704:	081587        	beq	a5, a8, 4037e710 <tlsf_realloc+0x388>
4037e707:	40f570        	nsau	a7, a5
4037e70a:	20a082        	movi	a8, 32
4037e70d:	c08870        	sub	a8, a8, a7
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e710:	25a490        	extui	a10, a9, 20, 3
	return bit - 1;
4037e713:	780b      	addi.n	a7, a8, -1
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e715:	c077a0        	sub	a7, a7, a10
4037e718:	400700        	ssr	a7
4037e71b:	915050        	srl	a5, a5
4037e71e:	170c      	movi.n	a7, 1
4037e720:	401a00        	ssl	a10
4037e723:	a17700        	sll	a7, a7
		fl -= (control->fl_index_shift - 1);
4037e726:	249590        	extui	a9, a9, 5, 3
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
4037e729:	307570        	xor	a7, a5, a7
		fl -= (control->fl_index_shift - 1);
4037e72c:	c08890        	sub	a8, a8, a9
4037e72f:	ffe0c6        	j	4037e6b6 <tlsf_realloc+0x32e>
	block->prev_free = &control->block_null;
4037e732:	3429      	s32i.n	a2, a4, 12
	block->next_free = current;
4037e734:	2459      	s32i.n	a5, a4, 8
	current->prev_free = block;
4037e736:	3549      	s32i.n	a4, a5, 12
	control->blocks[fl * control->sl_index_count + sl] = block;
4037e738:	4258      	l32i.n	a5, a2, 16
4037e73a:	545e50        	extui	a5, a5, 14, 6
4037e73d:	825580        	mull	a5, a5, a8
4037e740:	557a      	add.n	a5, a5, a7
4037e742:	a05590        	addx4	a5, a5, a9
4037e745:	0549      	s32i.n	a4, a5, 0
	control->fl_bitmap |= (1U << fl);
4037e747:	6258      	l32i.n	a5, a2, 24
4037e749:	140c      	movi.n	a4, 1
4037e74b:	401800        	ssl	a8
4037e74e:	a16400        	sll	a6, a4
4037e751:	205560        	or	a5, a5, a6
4037e754:	6259      	s32i.n	a5, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
4037e756:	7228      	l32i.n	a2, a2, 28
4037e758:	401700        	ssl	a7
4037e75b:	a14400        	sll	a4, a4
4037e75e:	a08820        	addx4	a8, a8, a2
4037e761:	0828      	l32i.n	a2, a8, 0
4037e763:	202240        	or	a2, a2, a4
4037e766:	0829      	s32i.n	a2, a8, 0
4037e768:	035d      	mov.n	a5, a3
4037e76a:	ff0f86        	j	4037e3ac <tlsf_realloc+0x24>
4037e76d:	000000        	ill

4037e770 <tlsf_size>:
{
4037e770:	004136        	entry	a1, 32
	if (tlsf == NULL)
4037e773:	128c      	beqz.n	a2, 4037e778 <tlsf_size+0x8>
	return control->size;
4037e775:	052222        	l32i	a2, a2, 20
}
4037e778:	f01d      	retw.n
	...

4037e77c <abort>:
#include "esp_cpu.h"

#include "soc/soc_caps.h"

void __attribute__((noreturn)) abort(void)
{
4037e77c:	00e136        	entry	a1, 112

    _Static_assert(UINTPTR_MAX == 0xffffffff, "abort() assumes 32-bit addresses");
    _Static_assert(SOC_CPU_CORES_NUM < 10, "abort() assumes number of cores is 1 to 9");

    char addr_buf[9] = { 0 };
    char core_buf[2] = { 0 };
4037e77f:	d9eb41        	l32r	a4, 40374f2c <_iram_text_start+0xb28>
    char addr_buf[9] = { 0 };
4037e782:	020c      	movi.n	a2, 0
    char core_buf[2] = { 0 };
4037e784:	000482        	l8ui	a8, a4, 0
4037e787:	010442        	l8ui	a4, a4, 1

    char buf[sizeof(ERR_STR1) + sizeof(addr_buf) + sizeof(core_buf) + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037e78a:	02bd      	mov.n	a11, a2
4037e78c:	ec2c      	movi.n	a12, 46
4037e78e:	a14b      	addi.n	a10, a1, 4
    char core_buf[2] = { 0 };
4037e790:	4d4182        	s8i	a8, a1, 77
4037e793:	4e4142        	s8i	a4, a1, 78
    char addr_buf[9] = { 0 };
4037e796:	116122        	s32i	a2, a1, 68
4037e799:	126122        	s32i	a2, a1, 72
4037e79c:	4c4122        	s8i	a2, a1, 76
    char buf[sizeof(ERR_STR1) + sizeof(addr_buf) + sizeof(core_buf) + sizeof(ERR_STR2) + 1 /* null char */] = { 0 };
4037e79f:	006122        	s32i	a2, a1, 0
4037e7a2:	d73481        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037e7a5:	0008e0        	callx8	a8

    itoa((uint32_t)(__builtin_return_address(0) - 3), addr_buf, 16);
4037e7a8:	d9e281        	l32r	a8, 40374f30 <_iram_text_start+0xb2c>
4037e7ab:	11a0e0        	slli	a10, a0, 2
4037e7ae:	158e80        	extui	a8, a8, 30, 2
4037e7b1:	018820        	slli	a8, a8, 30
4037e7b4:	41a2a0        	srli	a10, a10, 2
4037e7b7:	20aa80        	or	a10, a10, a8
4037e7ba:	44c142        	addi	a4, a1, 68
4037e7bd:	0c1c      	movi.n	a12, 16
4037e7bf:	04bd      	mov.n	a11, a4
4037e7c1:	fdcaa2        	addi	a10, a10, -3
    char core_buf[2] = { 0 };
4037e7c4:	4dc132        	addi	a3, a1, 77
    itoa((uint32_t)(__builtin_return_address(0) - 3), addr_buf, 16);
4037e7c7:	d9dd81        	l32r	a8, 40374f3c <_iram_text_start+0xb38>
4037e7ca:	0008e0        	callx8	a8
4037e7cd:	03eba0        	rsr.prid	a10
4037e7d0:	04ada0        	extui	a10, a10, 13, 1
    itoa(esp_cpu_get_core_id(), core_buf, 10);
4037e7d3:	ac0c      	movi.n	a12, 10
4037e7d5:	03bd      	mov.n	a11, a3
4037e7d7:	d9d981        	l32r	a8, 40374f3c <_iram_text_start+0xb38>
4037e7da:	0008e0        	callx8	a8

    const char *str[] = { ERR_STR1, addr_buf, ERR_STR2, core_buf };
4037e7dd:	d9d581        	l32r	a8, 40374f34 <_iram_text_start+0xb30>
4037e7e0:	e149      	s32i.n	a4, a1, 56
4037e7e2:	d9d541        	l32r	a4, 40374f38 <_iram_text_start+0xb34>
4037e7e5:	106132        	s32i	a3, a1, 64
4037e7e8:	d189      	s32i.n	a8, a1, 52
4037e7ea:	0f6142        	s32i	a4, a1, 60
4037e7ed:	34c132        	addi	a3, a1, 52

    char *dest = buf;

    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
        strcat(dest, str[i]);
4037e7f0:	0023b2        	l32i	a11, a3, 0
4037e7f3:	20a110        	or	a10, a1, a1
    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037e7f6:	01c222        	addi	a2, a2, 1
        strcat(dest, str[i]);
4037e7f9:	d98181        	l32r	a8, 40374e00 <_iram_text_start+0x9fc>
4037e7fc:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037e7ff:	334b      	addi.n	a3, a3, 4
4037e801:	eb4266        	bnei	a2, 4, 4037e7f0 <abort+0x74>
    }

    esp_system_abort(buf);
4037e804:	01ad      	mov.n	a10, a1
4037e806:	fb6e25        	call8	40379ee8 <esp_system_abort>
4037e809:	000000        	ill

4037e80c <__assert_func>:

/* Overriding assert function so that whenever assert is called from critical section,
 * it does not lead to a crash of its own.
 */
void __attribute__((noreturn)) __assert_func(const char *file, int line, const char *func, const char *expr)
{
4037e80c:	024136        	entry	a1, 0x120

    ra_to_str(&buff[sizeof(ASSERT_STR) - 1]);

    esp_system_abort(buff);
#else
    char addr[11] = { 0 };
4037e80f:	eca062        	movi	a6, 236
4037e812:	661a      	add.n	a6, a6, a1
4037e814:	0b0c      	movi.n	a11, 0
4037e816:	7c0c      	movi.n	a12, 7
4037e818:	04c6a2        	addi	a10, a6, 4
4037e81b:	3b61b2        	s32i	a11, a1, 236
4037e81e:	d71581        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037e821:	0008e0        	callx8	a8
    char buff[200];
    char lbuf[5];
    uint32_t rem_len = sizeof(buff) - 1;
    uint32_t off = 0;

    itoa(line, lbuf, 10);
4037e824:	f7a0b2        	movi	a11, 247
4037e827:	ac0c      	movi.n	a12, 10
4037e829:	b1ba      	add.n	a11, a1, a11
4037e82b:	03ad      	mov.n	a10, a3
4037e82d:	d9c381        	l32r	a8, 40374f3c <_iram_text_start+0xb38>
4037e830:	0008e0        	callx8	a8

    if (!spi_flash_cache_enabled()) {
4037e833:	f8efa5        	call8	4037772c <spi_flash_cache_enabled>
4037e836:	057a56        	bnez	a10, 4037e891 <__assert_func+0x85>
    return ((intptr_t)p >= SOC_DROM_LOW && (intptr_t)p < SOC_DROM_HIGH);
4037e839:	187c      	movi.n	a8, -15
4037e83b:	018860        	slli	a8, a8, 26
       if (esp_ptr_in_drom(file)) {
4037e83e:	d82131        	l32r	a3, 403748c4 <_iram_text_start+0x4c0>
4037e841:	628a      	add.n	a6, a2, a8
4037e843:	023367        	bltu	a3, a6, 4037e849 <__assert_func+0x3d>
           file = CACHE_DISABLED_STR;
4037e846:	d9be21        	l32r	a2, 40374f40 <_iram_text_start+0xb3c>
4037e849:	848a      	add.n	a8, a4, a8
       }

       if (esp_ptr_in_drom(func)) {
4037e84b:	323387        	bltu	a3, a8, 4037e881 <__assert_func+0x75>
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037e84e:	d9be41        	l32r	a4, 40374f48 <_iram_text_start+0xb44>
    addr[0] = '0';
4037e851:	033c      	movi.n	a3, 48
4037e853:	ec4132        	s8i	a3, a1, 236
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037e856:	11a0e0        	slli	a10, a0, 2
    addr[1] = 'x';
4037e859:	78a032        	movi	a3, 120
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037e85c:	154e40        	extui	a4, a4, 30, 2
    addr[1] = 'x';
4037e85f:	ed4132        	s8i	a3, a1, 237
    itoa((uint32_t)(__builtin_return_address(0) - INST_LEN), addr + 2, 16);
4037e862:	014420        	slli	a4, a4, 30
4037e865:	41a2a0        	srli	a10, a10, 2
4037e868:	eca032        	movi	a3, 236
4037e86b:	20aa40        	or	a10, a10, a4
4037e86e:	331a      	add.n	a3, a3, a1
4037e870:	0c1c      	movi.n	a12, 16
4037e872:	02c3b2        	addi	a11, a3, 2
4037e875:	fdcaa2        	addi	a10, a10, -3
4037e878:	d9b181        	l32r	a8, 40374f3c <_iram_text_start+0xb38>
4037e87b:	0008e0        	callx8	a8
           ra_to_str(addr);
           func = addr;
4037e87e:	204330        	or	a4, a3, a3
4037e881:	187c      	movi.n	a8, -15
4037e883:	018860        	slli	a8, a8, 26
       }

       if (esp_ptr_in_drom(expr)) {
4037e886:	d80f31        	l32r	a3, 403748c4 <_iram_text_start+0x4c0>
4037e889:	858a      	add.n	a8, a5, a8
4037e88b:	023387        	bltu	a3, a8, 4037e891 <__assert_func+0x85>
           expr = CACHE_DISABLED_STR;
4037e88e:	d9ac51        	l32r	a5, 40374f40 <_iram_text_start+0xb3c>
       }
    }

    const char *str[] = {ASSERT_STR, func ? func : "\b", " ", file, ":", lbuf, " (", expr, ")"};
4037e891:	d9ae31        	l32r	a3, 40374f4c <_iram_text_start+0xb48>
4037e894:	326132        	s32i	a3, a1, 200
4037e897:	14cc      	bnez.n	a4, 4037e89c <__assert_func+0x90>
4037e899:	d9aa41        	l32r	a4, 40374f44 <_iram_text_start+0xb40>
4037e89c:	356122        	s32i	a2, a1, 212
4037e89f:	d9ad21        	l32r	a2, 40374f54 <_iram_text_start+0xb50>
4037e8a2:	d9ab31        	l32r	a3, 40374f50 <_iram_text_start+0xb4c>
4037e8a5:	366122        	s32i	a2, a1, 216
4037e8a8:	f7a022        	movi	a2, 247
4037e8ab:	212a      	add.n	a2, a1, a2
4037e8ad:	376122        	s32i	a2, a1, 220
4037e8b0:	d9aa21        	l32r	a2, 40374f58 <_iram_text_start+0xb54>
4037e8b3:	336142        	s32i	a4, a1, 204
4037e8b6:	386122        	s32i	a2, a1, 224
4037e8b9:	d9a821        	l32r	a2, 40374f5c <_iram_text_start+0xb58>
4037e8bc:	346132        	s32i	a3, a1, 208
4037e8bf:	3a6122        	s32i	a2, a1, 232

    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037e8c2:	c8a022        	movi	a2, 200
4037e8c5:	221a      	add.n	a2, a2, a1
    const char *str[] = {ASSERT_STR, func ? func : "\b", " ", file, ":", lbuf, " (", expr, ")"};
4037e8c7:	396152        	s32i	a5, a1, 228
4037e8ca:	24c272        	addi	a7, a2, 36
    uint32_t off = 0;
4037e8cd:	040c      	movi.n	a4, 0
    uint32_t rem_len = sizeof(buff) - 1;
4037e8cf:	c7a032        	movi	a3, 199
        uint32_t len = strlen(str[i]);
4037e8d2:	0268      	l32i.n	a6, a2, 0
4037e8d4:	06ad      	mov.n	a10, a6
4037e8d6:	d9a281        	l32r	a8, 40374f60 <_iram_text_start+0xb5c>
4037e8d9:	0008e0        	callx8	a8
        uint32_t cpy_len = MIN(len, rem_len);
4037e8dc:	6353a0        	minu	a5, a3, a10
        memcpy(buff + off, str[i], cpy_len);
4037e8df:	05cd      	mov.n	a12, a5
4037e8e1:	a14a      	add.n	a10, a1, a4
4037e8e3:	06bd      	mov.n	a11, a6
        rem_len -= cpy_len;
4037e8e5:	c03350        	sub	a3, a3, a5
        memcpy(buff + off, str[i], cpy_len);
4037e8e8:	d6f281        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037e8eb:	0008e0        	callx8	a8
        off += cpy_len;
4037e8ee:	445a      	add.n	a4, a4, a5
        if (rem_len == 0) {
4037e8f0:	004316        	beqz	a3, 4037e8f8 <__assert_func+0xec>
    for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
4037e8f3:	224b      	addi.n	a2, a2, 4
4037e8f5:	d99277        	bne	a2, a7, 4037e8d2 <__assert_func+0xc6>
            break;
        }
    }
    buff[off] = '\0';
4037e8f8:	414a      	add.n	a4, a1, a4
4037e8fa:	020c      	movi.n	a2, 0
4037e8fc:	004422        	s8i	a2, a4, 0
    esp_system_abort(buff);
4037e8ff:	01ad      	mov.n	a10, a1
4037e901:	fb5e65        	call8	40379ee8 <esp_system_abort>

4037e904 <newlib_include_assert_impl>:
    __assert_func(file, line, NULL, failedexpr);
}

/* No-op function, used to force linker to include these changes */
void newlib_include_assert_impl(void)
{
4037e904:	004136        	entry	a1, 32
}
4037e907:	f01d      	retw.n
4037e909:	000000        	ill

4037e90c <malloc>:
*/
extern void *heap_caps_malloc_default( size_t size );
extern void *heap_caps_realloc_default( void *ptr, size_t size );

void* malloc(size_t size)
{
4037e90c:	004136        	entry	a1, 32
    return heap_caps_malloc_default(size);
4037e90f:	02ad      	mov.n	a10, a2
4037e911:	f74465        	call8	40375d58 <heap_caps_malloc_default>
}
4037e914:	0a2d      	mov.n	a2, a10
4037e916:	f01d      	retw.n

4037e918 <realloc>:
{
    return _calloc_r(_REENT, n, size);
}

void* realloc(void* ptr, size_t size)
{
4037e918:	004136        	entry	a1, 32
    return heap_caps_realloc_default(ptr, size);
4037e91b:	20b330        	or	a11, a3, a3
4037e91e:	20a220        	or	a10, a2, a2
4037e921:	f75d25        	call8	40375ef4 <heap_caps_realloc_default>
}
4037e924:	202aa0        	or	a2, a10, a10
4037e927:	f01d      	retw.n
4037e929:	000000        	ill

4037e92c <cfree>:

void free(void *ptr)
{
4037e92c:	004136        	entry	a1, 32
    heap_caps_free(ptr);
4037e92f:	02ad      	mov.n	a10, a2
4037e931:	f747e5        	call8	40375db0 <heap_caps_free>
}
4037e934:	f01d      	retw.n
	...

4037e938 <_malloc_r>:

void* _malloc_r(struct _reent *r, size_t size)
{
4037e938:	004136        	entry	a1, 32
    return heap_caps_malloc_default(size);
4037e93b:	03ad      	mov.n	a10, a3
4037e93d:	f741a5        	call8	40375d58 <heap_caps_malloc_default>
}
4037e940:	0a2d      	mov.n	a2, a10
4037e942:	f01d      	retw.n

4037e944 <_free_r>:

void _free_r(struct _reent *r, void* ptr)
{
4037e944:	004136        	entry	a1, 32
    heap_caps_free(ptr);
4037e947:	03ad      	mov.n	a10, a3
4037e949:	f74665        	call8	40375db0 <heap_caps_free>
}
4037e94c:	f01d      	retw.n
	...

4037e950 <_realloc_r>:

void* _realloc_r(struct _reent *r, void* ptr, size_t size)
{
4037e950:	004136        	entry	a1, 32
    return heap_caps_realloc_default( ptr, size );
4037e953:	20b440        	or	a11, a4, a4
4037e956:	20a330        	or	a10, a3, a3
4037e959:	f759a5        	call8	40375ef4 <heap_caps_realloc_default>
}
4037e95c:	202aa0        	or	a2, a10, a10
4037e95f:	f01d      	retw.n
4037e961:	000000        	ill

4037e964 <_calloc_r>:

void* _calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
4037e964:	004136        	entry	a1, 32
    void *result;
    size_t size_bytes;
    if (__builtin_mul_overflow(nmemb, size, &size_bytes)) {
4037e967:	825340        	mull	a5, a3, a4
4037e96a:	a23340        	muluh	a3, a3, a4
        return NULL;
4037e96d:	00a022        	movi	a2, 0
    if (__builtin_mul_overflow(nmemb, size, &size_bytes)) {
4037e970:	011356        	bnez	a3, 4037e985 <_calloc_r+0x21>
    }

    result = heap_caps_malloc_default(size_bytes);
4037e973:	20a550        	or	a10, a5, a5
4037e976:	f73e25        	call8	40375d58 <heap_caps_malloc_default>
4037e979:	0a2d      	mov.n	a2, a10
    if (result != NULL) {
4037e97b:	6a8c      	beqz.n	a10, 4037e985 <_calloc_r+0x21>
        bzero(result, size_bytes);
4037e97d:	05bd      	mov.n	a11, a5
4037e97f:	d97981        	l32r	a8, 40374f64 <_iram_text_start+0xb60>
4037e982:	0008e0        	callx8	a8
    }
    return result;
}
4037e985:	f01d      	retw.n
	...

4037e988 <calloc>:
{
4037e988:	004136        	entry	a1, 32
    return _calloc_r(_REENT, n, size);
4037e98b:	fd8aa5        	call8	4037c234 <__getreent>
4037e98e:	20b220        	or	a11, a2, a2
4037e991:	20c330        	or	a12, a3, a3
4037e994:	fffce5        	call8	4037e964 <_calloc_r>
}
4037e997:	202aa0        	or	a2, a10, a10
4037e99a:	f01d      	retw.n

4037e99c <newlib_include_heap_impl>:
4037e99c:	004136        	entry	a1, 32
4037e99f:	f01d      	retw.n
4037e9a1:	000000        	ill

4037e9a4 <spi_flash_needs_reset_check>:
static bool flash_brownout_needs_reset = false;
static bool flash_erasing = false;

// This function could be called in startup
void spi_flash_needs_reset_check(void)
{
4037e9a4:	004136        	entry	a1, 32
    // Currently only XMC is suggested to reset when brownout
#if CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC
    if ((g_rom_flashchip.device_id >> 16) == 0x20) {
4037e9a7:	d79381        	l32r	a8, 403747f4 <_iram_text_start+0x3f0>
4037e9aa:	0888      	l32i.n	a8, a8, 0
4037e9ac:	011882        	l16ui	a8, a8, 2
4037e9af:	07c866        	bnei	a8, 32, 4037e9ba <spi_flash_needs_reset_check+0x16>
        flash_brownout_needs_reset = true;
4037e9b2:	d96d81        	l32r	a8, 40374f68 <_iram_text_start+0xb64>
4037e9b5:	190c      	movi.n	a9, 1
4037e9b7:	004892        	s8i	a9, a8, 0
    }
#endif
}
4037e9ba:	f01d      	retw.n

4037e9bc <spi_flash_set_erasing_flag>:

void spi_flash_set_erasing_flag(bool status)
{
4037e9bc:	004136        	entry	a1, 32
    flash_erasing = status;
4037e9bf:	d96b81        	l32r	a8, 40374f6c <_iram_text_start+0xb68>
4037e9c2:	004822        	s8i	a2, a8, 0
}
4037e9c5:	f01d      	retw.n
	...

4037e9c8 <spi_flash_brownout_need_reset>:

bool spi_flash_brownout_need_reset(void)
{
4037e9c8:	004136        	entry	a1, 32
    return (flash_brownout_needs_reset && flash_erasing);
4037e9cb:	d96721        	l32r	a2, 40374f68 <_iram_text_start+0xb64>
4037e9ce:	000282        	l8ui	a8, a2, 0
4037e9d1:	020c      	movi.n	a2, 0
4037e9d3:	051827        	beq	a8, a2, 4037e9dc <spi_flash_brownout_need_reset+0x14>
4037e9d6:	d96521        	l32r	a2, 40374f6c <_iram_text_start+0xb68>
4037e9d9:	000222        	l8ui	a2, a2, 0
}
4037e9dc:	042020        	extui	a2, a2, 0, 1
4037e9df:	f01d      	retw.n
4037e9e1:	000000        	ill

4037e9e4 <memspi_host_read_id_hs>:
#ifndef CONFIG_SPI_FLASH_ROM_IMPL

static const char TAG[] = "memspi";

esp_err_t memspi_host_read_id_hs(spi_flash_host_inst_t *host, uint32_t *id)
{
4037e9e4:	008136        	entry	a1, 64
    uint32_t id_buf = 0;
4037e9e7:	040c      	movi.n	a4, 0
    spi_flash_trans_t t = {
4037e9e9:	04bd      	mov.n	a11, a4
4037e9eb:	cc1c      	movi.n	a12, 28
4037e9ed:	01ad      	mov.n	a10, a1
    uint32_t id_buf = 0;
4037e9ef:	076142        	s32i	a4, a1, 28
    spi_flash_trans_t t = {
4037e9f2:	d6a081        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037e9f5:	0008e0        	callx8	a8
4037e9f8:	380c      	movi.n	a8, 3
4037e9fa:	024182        	s8i	a8, a1, 2
4037e9fd:	1cc182        	addi	a8, a1, 28
4037ea00:	3189      	s32i.n	a8, a1, 12
4037ea02:	9fa082        	movi	a8, 159
4037ea05:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RDID,
        .miso_len = 3,
        .miso_data = ((uint8_t*) &id_buf),
    };
    host->driver->common_command(host, &t);
4037ea08:	0288      	l32i.n	a8, a2, 0
4037ea0a:	02ad      	mov.n	a10, a2
4037ea0c:	1888      	l32i.n	a8, a8, 4
4037ea0e:	20b110        	or	a11, a1, a1
4037ea11:	0008e0        	callx8	a8

    uint32_t raw_flash_id = id_buf;
4037ea14:	7188      	l32i.n	a8, a1, 28
    ESP_EARLY_LOGV(TAG, "raw_chip_id: %X\n", raw_flash_id);
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
4037ea16:	d95691        	l32r	a9, 40374f70 <_iram_text_start+0xb6c>
4037ea19:	120c      	movi.n	a2, 1
4037ea1b:	989a      	add.n	a9, a8, a9
4037ea1d:	834290        	moveqz	a4, a2, a9
4037ea20:	749040        	extui	a9, a4, 0, 8
4037ea23:	54ec      	bnez.n	a4, 4037ea4c <memspi_host_read_id_hs+0x68>
4037ea25:	932980        	movnez	a2, a9, a8
4037ea28:	02ec      	bnez.n	a2, 4037ea4c <memspi_host_read_id_hs+0x68>
        ESP_EARLY_LOGE(TAG, "no response\n");
        return ESP_ERR_FLASH_NO_RESPONSE;
    }
    // Byte swap the flash id as it's usually written the other way around
    uint8_t mfg_id = raw_flash_id & 0xFF;
    uint16_t flash_id = (raw_flash_id >> 16) | (raw_flash_id & 0xFF00);
4037ea2a:	00af42        	movi	a4, 0xffffff00
4037ea2d:	104840        	and	a4, a8, a4
4037ea30:	f59080        	extui	a9, a8, 16, 16
4037ea33:	209940        	or	a9, a9, a4
    *id = ((uint32_t)mfg_id << 16) | flash_id;
4037ea36:	ffa042        	movi	a4, 255
4037ea39:	118800        	slli	a8, a8, 16
4037ea3c:	114400        	slli	a4, a4, 16
4037ea3f:	f49090        	extui	a9, a9, 0, 16
4037ea42:	108840        	and	a8, a8, a4
4037ea45:	208980        	or	a8, a9, a8
4037ea48:	0389      	s32i.n	a8, a3, 0
    ESP_EARLY_LOGV(TAG, "chip_id: %X\n", *id);
    return ESP_OK;
}
4037ea4a:	f01d      	retw.n
        return ESP_ERR_FLASH_NO_RESPONSE;
4037ea4c:	08a122        	movi	a2, 0x108
4037ea4f:	fffdc6        	j	4037ea4a <memspi_host_read_id_hs+0x66>
	...

4037ea54 <memspi_host_read_status_hs>:

esp_err_t memspi_host_read_status_hs(spi_flash_host_inst_t *host, uint8_t *out_sr)
{
4037ea54:	008136        	entry	a1, 64
    //NOTE: we do have a read id function, however it doesn't work in high freq
    uint32_t stat_buf = 0;
4037ea57:	0b0c      	movi.n	a11, 0
    spi_flash_trans_t t = {
4037ea59:	cc1c      	movi.n	a12, 28
4037ea5b:	01ad      	mov.n	a10, a1
    uint32_t stat_buf = 0;
4037ea5d:	0761b2        	s32i	a11, a1, 28
    spi_flash_trans_t t = {
4037ea60:	d68581        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037ea63:	0008e0        	callx8	a8
4037ea66:	180c      	movi.n	a8, 1
4037ea68:	024182        	s8i	a8, a1, 2
4037ea6b:	1cc182        	addi	a8, a1, 28
4037ea6e:	3189      	s32i.n	a8, a1, 12
4037ea70:	580c      	movi.n	a8, 5
4037ea72:	0a5182        	s16i	a8, a1, 20
        .command = CMD_RDSR,
        .miso_data = ((uint8_t*) &stat_buf),
        .miso_len = 1
    };
    esp_err_t err = host->driver->common_command(host, &t);
4037ea75:	0288      	l32i.n	a8, a2, 0
4037ea77:	01bd      	mov.n	a11, a1
4037ea79:	1888      	l32i.n	a8, a8, 4
4037ea7b:	20a220        	or	a10, a2, a2
4037ea7e:	0008e0        	callx8	a8
    if (err != ESP_OK) {
4037ea81:	3acc      	bnez.n	a10, 4037ea88 <memspi_host_read_status_hs+0x34>
        return err;
    }
    *out_sr = stat_buf;
4037ea83:	7128      	l32i.n	a2, a1, 28
4037ea85:	004322        	s8i	a2, a3, 0
    return ESP_OK;
}
4037ea88:	0a2d      	mov.n	a2, a10
4037ea8a:	f01d      	retw.n

4037ea8c <memspi_host_erase_chip>:
    }
    return ESP_OK;
}

void memspi_host_erase_chip(spi_flash_host_inst_t *host)
{
4037ea8c:	008136        	entry	a1, 64
    spi_flash_trans_t t = { 0 };
4037ea8f:	cc1c      	movi.n	a12, 28
4037ea91:	0b0c      	movi.n	a11, 0
4037ea93:	20a110        	or	a10, a1, a1
4037ea96:	d67781        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037ea99:	0008e0        	callx8	a8
    t.command = CMD_CHIP_ERASE;
4037ea9c:	c7a082        	movi	a8, 199
4037ea9f:	0a5182        	s16i	a8, a1, 20
    host->driver->common_command(host, &t);
4037eaa2:	0288      	l32i.n	a8, a2, 0
4037eaa4:	01bd      	mov.n	a11, a1
4037eaa6:	1888      	l32i.n	a8, a8, 4
4037eaa8:	02ad      	mov.n	a10, a2
4037eaaa:	0008e0        	callx8	a8
}
4037eaad:	f01d      	retw.n
	...

4037eab0 <memspi_host_set_write_protect>:
    host->driver->common_command(host, &t);
    return ESP_OK;
}

esp_err_t memspi_host_set_write_protect(spi_flash_host_inst_t *host, bool wp)
{
4037eab0:	008136        	entry	a1, 64
    spi_flash_trans_t t = {
4037eab3:	cc1c      	movi.n	a12, 28
4037eab5:	0b0c      	movi.n	a11, 0
4037eab7:	20a110        	or	a10, a1, a1
4037eaba:	d66e81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037eabd:	0008e0        	callx8	a8
4037eac0:	690c      	movi.n	a9, 6
{
4037eac2:	743030        	extui	a3, a3, 0, 8
    spi_flash_trans_t t = {
4037eac5:	480c      	movi.n	a8, 4
4037eac7:	838930        	moveqz	a8, a9, a3
4037eaca:	0a5182        	s16i	a8, a1, 20
        .command = wp ? CMD_WRDI : CMD_WREN
    };
    host->driver->common_command(host, &t);
4037eacd:	0288      	l32i.n	a8, a2, 0
4037eacf:	01bd      	mov.n	a11, a1
4037ead1:	1888      	l32i.n	a8, a8, 4
4037ead3:	02ad      	mov.n	a10, a2
4037ead5:	0008e0        	callx8	a8
    return ESP_OK;
}
4037ead8:	020c      	movi.n	a2, 0
4037eada:	f01d      	retw.n

4037eadc <memspi_host_flush_cache>:
{
4037eadc:	004136        	entry	a1, 32
    if ((void*)((memspi_host_inst_t*)host)->spi == (void*) spi_flash_ll_get_hw(SPI1_HOST)) {
4037eadf:	d74181        	l32r	a8, 403747e4 <_iram_text_start+0x3e0>
4037eae2:	012292        	l32i	a9, a2, 4
{
4037eae5:	20a330        	or	a10, a3, a3
4037eae8:	20b440        	or	a11, a4, a4
    if ((void*)((memspi_host_inst_t*)host)->spi == (void*) spi_flash_ll_get_hw(SPI1_HOST)) {
4037eaeb:	029987        	bne	a9, a8, 4037eaf1 <memspi_host_flush_cache+0x15>
        spi_flash_check_and_flush_cache(addr, size);
4037eaee:	f90965        	call8	40377b84 <spi_flash_check_and_flush_cache>
}
4037eaf1:	020c      	movi.n	a2, 0
4037eaf3:	f01d      	retw.n
4037eaf5:	000000        	ill

4037eaf8 <memspi_host_erase_sector>:
{
4037eaf8:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
4037eafb:	d77281        	l32r	a8, 403748c4 <_iram_text_start+0x4c0>
4037eafe:	0eb837        	bgeu	a8, a3, 4037eb10 <memspi_host_erase_sector+0x18>
4037eb01:	d91cd1        	l32r	a13, 40374f74 <_iram_text_start+0xb70>
4037eb04:	d91dc1        	l32r	a12, 40374f78 <_iram_text_start+0xb74>
4037eb07:	d91da1        	l32r	a10, 40374f7c <_iram_text_start+0xb78>
4037eb0a:	92a0b2        	movi	a11, 146
4037eb0d:	ffcfe5        	call8	4037e80c <__assert_func>
    spi_flash_trans_t t = {
4037eb10:	cc1c      	movi.n	a12, 28
4037eb12:	0b0c      	movi.n	a11, 0
4037eb14:	01ad      	mov.n	a10, a1
4037eb16:	d65781        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037eb19:	0008e0        	callx8	a8
4037eb1c:	1139      	s32i.n	a3, a1, 4
4037eb1e:	032c      	movi.n	a3, 32
4037eb20:	0a5132        	s16i	a3, a1, 20
    host->driver->common_command(host, &t);
4037eb23:	0238      	l32i.n	a3, a2, 0
    spi_flash_trans_t t = {
4037eb25:	881c      	movi.n	a8, 24
    host->driver->common_command(host, &t);
4037eb27:	1338      	l32i.n	a3, a3, 4
    spi_flash_trans_t t = {
4037eb29:	034182        	s8i	a8, a1, 3
    host->driver->common_command(host, &t);
4037eb2c:	01bd      	mov.n	a11, a1
4037eb2e:	20a220        	or	a10, a2, a2
4037eb31:	0003e0        	callx8	a3
}
4037eb34:	f01d      	retw.n
	...

4037eb38 <memspi_host_erase_block>:
{
4037eb38:	008136        	entry	a1, 64
    assert(start_address < 0x1000000);
4037eb3b:	d76281        	l32r	a8, 403748c4 <_iram_text_start+0x4c0>
4037eb3e:	0eb837        	bgeu	a8, a3, 4037eb50 <memspi_host_erase_block+0x18>
4037eb41:	d90cd1        	l32r	a13, 40374f74 <_iram_text_start+0xb70>
4037eb44:	d90fc1        	l32r	a12, 40374f80 <_iram_text_start+0xb7c>
4037eb47:	d90da1        	l32r	a10, 40374f7c <_iram_text_start+0xb78>
4037eb4a:	9ea0b2        	movi	a11, 158
4037eb4d:	ffcbe5        	call8	4037e80c <__assert_func>
    spi_flash_trans_t t = {
4037eb50:	cc1c      	movi.n	a12, 28
4037eb52:	0b0c      	movi.n	a11, 0
4037eb54:	01ad      	mov.n	a10, a1
4037eb56:	d64781        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037eb59:	0008e0        	callx8	a8
4037eb5c:	1139      	s32i.n	a3, a1, 4
4037eb5e:	d8a032        	movi	a3, 216
4037eb61:	0a5132        	s16i	a3, a1, 20
    host->driver->common_command(host, &t);
4037eb64:	0238      	l32i.n	a3, a2, 0
    spi_flash_trans_t t = {
4037eb66:	881c      	movi.n	a8, 24
    host->driver->common_command(host, &t);
4037eb68:	1338      	l32i.n	a3, a3, 4
    spi_flash_trans_t t = {
4037eb6a:	034182        	s8i	a8, a1, 3
    host->driver->common_command(host, &t);
4037eb6d:	01bd      	mov.n	a11, a1
4037eb6f:	02ad      	mov.n	a10, a2
4037eb71:	0003e0        	callx8	a3
}
4037eb74:	f01d      	retw.n
	...

4037eb78 <memspi_host_program_page>:
{
4037eb78:	008136        	entry	a1, 64
    assert(address + length <= 0x1000000);
4037eb7b:	180c      	movi.n	a8, 1
4037eb7d:	945a      	add.n	a9, a4, a5
4037eb7f:	018880        	slli	a8, a8, 24
4037eb82:	0eb897        	bgeu	a8, a9, 4037eb94 <memspi_host_program_page+0x1c>
4037eb85:	d8ffd1        	l32r	a13, 40374f84 <_iram_text_start+0xb80>
4037eb88:	d900c1        	l32r	a12, 40374f88 <_iram_text_start+0xb84>
4037eb8b:	d8fca1        	l32r	a10, 40374f7c <_iram_text_start+0xb78>
4037eb8e:	aaa0b2        	movi	a11, 170
4037eb91:	ffc7a5        	call8	4037e80c <__assert_func>
    spi_flash_trans_t t = {
4037eb94:	cc1c      	movi.n	a12, 28
4037eb96:	0b0c      	movi.n	a11, 0
4037eb98:	01ad      	mov.n	a10, a1
4037eb9a:	d63681        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037eb9d:	0008e0        	callx8	a8
4037eba0:	1149      	s32i.n	a4, a1, 4
4037eba2:	240c      	movi.n	a4, 2
4037eba4:	0a5142        	s16i	a4, a1, 20
    host->driver->common_command(host, &t);
4037eba7:	0248      	l32i.n	a4, a2, 0
    spi_flash_trans_t t = {
4037eba9:	014152        	s8i	a5, a1, 1
    host->driver->common_command(host, &t);
4037ebac:	1448      	l32i.n	a4, a4, 4
    spi_flash_trans_t t = {
4037ebae:	851c      	movi.n	a5, 24
4037ebb0:	034152        	s8i	a5, a1, 3
4037ebb3:	2139      	s32i.n	a3, a1, 8
    host->driver->common_command(host, &t);
4037ebb5:	01bd      	mov.n	a11, a1
4037ebb7:	02ad      	mov.n	a10, a2
4037ebb9:	0004e0        	callx8	a4
}
4037ebbc:	f01d      	retw.n
	...

4037ebc0 <memspi_host_init_pointers>:
{
4037ebc0:	004136        	entry	a1, 32
    r = ((intptr_t)p >= SOC_MEM_INTERNAL_LOW && (intptr_t)p < SOC_MEM_INTERNAL_HIGH);
4037ebc3:	d69591        	l32r	a9, 40374618 <_iram_text_start+0x214>
4037ebc6:	d734d1        	l32r	a13, 40374898 <_iram_text_start+0x494>
4037ebc9:	929a      	add.n	a9, a2, a9
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
4037ebcb:	73c8      	l32i.n	a12, a3, 28
{
4037ebcd:	03bd      	mov.n	a11, a3
4037ebcf:	1a0c      	movi.n	a10, 1
4037ebd1:	01bd97        	bgeu	a13, a9, 4037ebd6 <memspi_host_init_pointers+0x16>
4037ebd4:	0a0c      	movi.n	a10, 0
    r |= ((intptr_t)p >= SOC_RTC_DATA_LOW && (intptr_t)p < SOC_RTC_DATA_HIGH);
4037ebd6:	b97c      	movi.n	a9, -5
4037ebd8:	019940        	slli	a9, a9, 28
4037ebdb:	d673e1        	l32r	a14, 403745a8 <_iram_text_start+0x1a4>
4037ebde:	929a      	add.n	a9, a2, a9
4037ebe0:	1d0c      	movi.n	a13, 1
4037ebe2:	02be97        	bgeu	a14, a9, 4037ebe8 <memspi_host_init_pointers+0x28>
4037ebe5:	00a0d2        	movi	a13, 0
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
4037ebe8:	20aad0        	or	a10, a10, a13
4037ebeb:	16ea07        	bbsi	a10, 0, 4037ec05 <memspi_host_init_pointers+0x45>
    r |= ((intptr_t)p >= SOC_RTC_DRAM_LOW && (intptr_t)p < SOC_RTC_DRAM_HIGH);
4037ebee:	d66d91        	l32r	a9, 403745a4 <_iram_text_start+0x1a0>
4037ebf1:	d66da1        	l32r	a10, 403745a8 <_iram_text_start+0x1a4>
4037ebf4:	929a      	add.n	a9, a2, a9
4037ebf6:	0bba97        	bgeu	a10, a9, 4037ec05 <memspi_host_init_pointers+0x45>
        host->inst.driver = &esp_flash_gpspi_host;
4037ebf9:	d8e591        	l32r	a9, 40374f90 <_iram_text_start+0xb8c>
        return ESP_ERR_INVALID_ARG;
4037ebfc:	02a1a2        	movi	a10, 0x102
    if (!esp_ptr_internal(host) && cfg->host_id == SPI1_HOST) {
4037ebff:	bccc      	bnez.n	a12, 4037ec0e <memspi_host_init_pointers+0x4e>
}
4037ec01:	0a2d      	mov.n	a2, a10
4037ec03:	f01d      	retw.n
        host->inst.driver = &esp_flash_gpspi_host;
4037ec05:	d8e291        	l32r	a9, 40374f90 <_iram_text_start+0xb8c>
    if (cfg->host_id == SPI1_HOST)
4037ec08:	002c56        	bnez	a12, 4037ec0e <memspi_host_init_pointers+0x4e>
        host->inst.driver = &esp_flash_default_host;
4037ec0b:	d8e091        	l32r	a9, 40374f8c <_iram_text_start+0xb88>
4037ec0e:	0299      	s32i.n	a9, a2, 0
    esp_err_t err = spi_flash_hal_init(host, cfg);
4037ec10:	02ad      	mov.n	a10, a2
4037ec12:	d8e081        	l32r	a8, 40374f94 <_iram_text_start+0xb90>
4037ec15:	0008e0        	callx8	a8
    return err;
4037ec18:	fff946        	j	4037ec01 <memspi_host_init_pointers+0x41>
	...

4037ec1c <memspi_host_write_data_slicer>:

// When encryption is enabled, etc. the data slicer may be complicated
// This is the simple case where the hardware has no other requirements than the size and page boundary
int memspi_host_write_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
4037ec1c:	004136        	entry	a1, 32
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
4037ec1f:	9228      	l32i.n	a2, a2, 36
4037ec21:	136207        	bbci	a2, 0, 4037ec38 <memspi_host_write_data_slicer+0x1c>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4037ec24:	042040        	extui	a2, a4, 0, 1
4037ec27:	256307        	bbci	a3, 0, 4037ec50 <memspi_host_write_data_slicer+0x34>
            align_addr -= 1;
4037ec2a:	330b      	addi.n	a3, a3, -1
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4037ec2c:	628c      	beqz.n	a2, 4037ec36 <memspi_host_write_data_slicer+0x1a>
            len += 1;
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
            len += 2;
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
            len += 1;
4037ec2e:	441b      	addi.n	a4, a4, 1
4037ec30:	000106        	j	4037ec38 <memspi_host_write_data_slicer+0x1c>
4037ec33:	00          	.byte 00
4037ec34:	00          	.byte 00
4037ec35:	00          	.byte 00
            len += 2;
4037ec36:	442b      	addi.n	a4, a4, 2
        }
    }

    uint32_t end_bound = (align_addr/page_size + 1) * page_size;
4037ec38:	c22360        	quou	a2, a3, a6
4037ec3b:	221b      	addi.n	a2, a2, 1
4037ec3d:	822260        	mull	a2, a2, a6
    // Shouldn't program cross the page, or longer than SPI_FLASH_HAL_MAX_WRITE_BYTES
    uint32_t max_len = MIN(end_bound - align_addr, SPI_FLASH_HAL_MAX_WRITE_BYTES);
    *align_address = align_addr;
4037ec40:	0539      	s32i.n	a3, a5, 0
    uint32_t max_len = MIN(end_bound - align_addr, SPI_FLASH_HAL_MAX_WRITE_BYTES);
4037ec42:	c02230        	sub	a2, a2, a3
    return MIN(max_len, len);
4037ec45:	034c      	movi.n	a3, 64
4037ec47:	634430        	minu	a4, a4, a3
}
4037ec4a:	632240        	minu	a2, a2, a4
4037ec4d:	f01d      	retw.n
4037ec4f:	00          	.byte 00
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
4037ec50:	fe4216        	beqz	a2, 4037ec38 <memspi_host_write_data_slicer+0x1c>
4037ec53:	fff5c6        	j	4037ec2e <memspi_host_write_data_slicer+0x12>
	...

4037ec58 <memspi_host_read_data_slicer>:

int memspi_host_read_data_slicer(spi_flash_host_inst_t *host, uint32_t address, uint32_t len, uint32_t *align_address, uint32_t page_size)
{
4037ec58:	004136        	entry	a1, 32
    // Shouldn't read longer than SPI_FLASH_HAL_MAX_READ_BYTES
    uint32_t slicer_flag = ((spi_flash_hal_context_t*)host)->slicer_flags;
    uint32_t align_addr = address;

    if (slicer_flag & SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR) {
4037ec5b:	9228      	l32i.n	a2, a2, 36
4037ec5d:	116207        	bbci	a2, 0, 4037ec72 <memspi_host_read_data_slicer+0x1a>
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4037ec60:	048040        	extui	a8, a4, 0, 1
4037ec63:	156307        	bbci	a3, 0, 4037ec7c <memspi_host_read_data_slicer+0x24>
            align_addr -= 1;
4037ec66:	330b      	addi.n	a3, a3, -1
        if (((align_addr % 2) != 0) && ((len % 2) != 0)) {
4037ec68:	488c      	beqz.n	a8, 4037ec70 <memspi_host_read_data_slicer+0x18>
            len += 1;
        } else if (((align_addr % 2) != 0) && ((len % 2) == 0)) {
            align_addr -= 1;
            len += 2;
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
            len += 1;
4037ec6a:	441b      	addi.n	a4, a4, 1
4037ec6c:	000086        	j	4037ec72 <memspi_host_read_data_slicer+0x1a>
4037ec6f:	00          	.byte 00
            len += 2;
4037ec70:	442b      	addi.n	a4, a4, 2
        }
    }
    uint32_t max_len = SPI_FLASH_HAL_MAX_READ_BYTES;
    *align_address = align_addr;
    return MIN(max_len, len);
}
4037ec72:	024c      	movi.n	a2, 64
    *align_address = align_addr;
4037ec74:	0539      	s32i.n	a3, a5, 0
}
4037ec76:	632420        	minu	a2, a4, a2
4037ec79:	f01d      	retw.n
4037ec7b:	00          	.byte 00
        } else if (((align_addr % 2) == 0) && ((len % 2) != 0)) {
4037ec7c:	ff2816        	beqz	a8, 4037ec72 <memspi_host_read_data_slicer+0x1a>
4037ec7f:	fff9c6        	j	4037ec6a <memspi_host_read_data_slicer+0x12>
	...

4037ec84 <spi_flash_chip_boya_probe>:
#include "spi_flash_chip_generic.h"
#include "spi_flash_chip_gd.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_boya_probe(esp_flash_t *chip, uint32_t flash_id)
{
4037ec84:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0x68;
    if (flash_id >> 16 != MFG_ID) {
4037ec87:	f59030        	extui	a9, a3, 16, 16
4037ec8a:	68a082        	movi	a8, 104
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x4000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
        return ESP_ERR_NOT_FOUND;
4037ec8d:	05a122        	movi	a2, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037ec90:	109987        	bne	a9, a8, 4037eca4 <spi_flash_chip_boya_probe+0x20>
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
4037ec93:	ffa082        	movi	a8, 255
4037ec96:	118880        	slli	a8, a8, 8
4037ec99:	103380        	and	a3, a3, a8
    }

    return ESP_OK;
4037ec9c:	c0d332        	addmi	a3, a3, 0xffffc000
4037ec9f:	080c      	movi.n	a8, 0
4037eca1:	832830        	moveqz	a2, a8, a3
}
4037eca4:	f01d      	retw.n
	...

4037eca8 <spi_flash_chip_boya_get_caps>:

spi_flash_caps_t spi_flash_chip_boya_get_caps(esp_flash_t *chip)
{
4037eca8:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4037ecab:	420c      	movi.n	a2, 4
4037ecad:	f01d      	retw.n
	...

4037ecb0 <spi_flash_chip_gd_detect_size>:
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}

esp_err_t spi_flash_chip_gd_detect_size(esp_flash_t *chip, uint32_t *size)
{
4037ecb0:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
4037ecb3:	62b8      	l32i.n	a11, a2, 24
    *size = 0;

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
4037ecb5:	180c      	movi.n	a8, 1
4037ecb7:	f490b0        	extui	a9, a11, 0, 16
4037ecba:	0a0c      	movi.n	a10, 0
4037ecbc:	83a890        	moveqz	a10, a8, a9
4037ecbf:	7420a0        	extui	a2, a10, 0, 8
4037ecc2:	8acc      	bnez.n	a10, 4037ecce <spi_flash_chip_gd_detect_size+0x1e>
4037ecc4:	d8b5a1        	l32r	a10, 40374f98 <_iram_text_start+0xb94>
4037ecc7:	99aa      	add.n	a9, a9, a10
4037ecc9:	832890        	moveqz	a2, a8, a9
4037eccc:	828c      	beqz.n	a2, 4037ecd8 <spi_flash_chip_gd_detect_size+0x28>
    *size = 0;
4037ecce:	020c      	movi.n	a2, 0
4037ecd0:	0329      	s32i.n	a2, a3, 0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4037ecd2:	d70221        	l32r	a2, 403748dc <_iram_text_start+0x4d8>
    }

    *size = 1 << (id & 0xFF);
    return ESP_OK;
}
4037ecd5:	f01d      	retw.n
4037ecd7:	00          	.byte 00
    *size = 1 << (id & 0xFF);
4037ecd8:	401b00        	ssl	a11
4037ecdb:	a18800        	sll	a8, a8
4037ecde:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
4037ece0:	fffc46        	j	4037ecd5 <spi_flash_chip_gd_detect_size+0x25>
	...

4037ece4 <spi_flash_chip_gd_get_io_mode>:
                                            qe);
    }
}

esp_err_t spi_flash_chip_gd_get_io_mode(esp_flash_t *chip, esp_flash_io_mode_t* out_io_mode)
{
4037ece4:	006136        	entry	a1, 48
    /* GD uses bit 1 of SR2 as Quad Enable */
    const uint8_t BIT_QE = 1 << 1;
    uint32_t sr;
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
4037ece7:	20b110        	or	a11, a1, a1
4037ecea:	20a220        	or	a10, a2, a2
4037eced:	005c25        	call8	4037f2b0 <spi_flash_common_read_status_8b_rdsr2>
    if (ret == ESP_OK) {
4037ecf0:	00aa56        	bnez	a10, 4037ecfe <spi_flash_chip_gd_get_io_mode+0x1a>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
4037ecf3:	0188      	l32i.n	a8, a1, 0
4037ecf5:	490c      	movi.n	a9, 4
4037ecf7:	888a      	add.n	a8, a8, a8
4037ecf9:	108890        	and	a8, a8, a9
4037ecfc:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
4037ecfe:	0a2d      	mov.n	a2, a10
4037ed00:	f01d      	retw.n
	...

4037ed04 <spi_flash_chip_gd_set_io_mode>:
{
4037ed04:	004136        	entry	a1, 32
    if (WRSR_16B_REQUIRED(chip->chip_id)) {
4037ed07:	6298      	l32i.n	a9, a2, 24
4037ed09:	ffa082        	movi	a8, 255
4037ed0c:	118880        	slli	a8, a8, 8
4037ed0f:	3b0c      	movi.n	a11, 3
4037ed11:	108980        	and	a8, a9, a8
4037ed14:	11bb30        	slli	a11, a11, 13
{
4037ed17:	02ad      	mov.n	a10, a2
    if (WRSR_16B_REQUIRED(chip->chip_id)) {
4037ed19:	0718b7        	beq	a8, a11, 4037ed24 <spi_flash_chip_gd_set_io_mode+0x20>
4037ed1c:	749090        	extui	a9, a9, 0, 8
4037ed1f:	581c      	movi.n	a8, 21
4037ed21:	0f3897        	bltu	a8, a9, 4037ed34 <spi_flash_chip_gd_set_io_mode+0x30>
        return spi_flash_common_set_io_mode(chip,
4037ed24:	d89ec1        	l32r	a12, 40374f9c <_iram_text_start+0xb98>
4037ed27:	d89eb1        	l32r	a11, 40374fa0 <_iram_text_start+0xb9c>
4037ed2a:	00a2d2        	movi	a13, 0x200
        return spi_flash_common_set_io_mode(chip,
4037ed2d:	0092a5        	call8	4037f658 <spi_flash_common_set_io_mode>
}
4037ed30:	0a2d      	mov.n	a2, a10
4037ed32:	f01d      	retw.n
        return spi_flash_common_set_io_mode(chip,
4037ed34:	d89cc1        	l32r	a12, 40374fa4 <_iram_text_start+0xba0>
4037ed37:	d89cb1        	l32r	a11, 40374fa8 <_iram_text_start+0xba4>
4037ed3a:	2d0c      	movi.n	a13, 2
4037ed3c:	fffb46        	j	4037ed2d <spi_flash_chip_gd_set_io_mode+0x29>
	...

4037ed40 <spi_flash_chip_gd_get_caps>:
{
4037ed40:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4037ed43:	180282        	l8ui	a8, a2, 24
4037ed46:	891c      	movi.n	a9, 24
4037ed48:	120c      	movi.n	a2, 1
4037ed4a:	023987        	bltu	a9, a8, 4037ed50 <spi_flash_chip_gd_get_caps+0x10>
4037ed4d:	00a022        	movi	a2, 0
}
4037ed50:	480c      	movi.n	a8, 4
    if ((chip->chip_id & 0xFF) >= 0x19) {
4037ed52:	222a      	add.n	a2, a2, a2
}
4037ed54:	202280        	or	a2, a2, a8
4037ed57:	f01d      	retw.n
4037ed59:	000000        	ill

4037ed5c <spi_flash_chip_gd_probe>:
{
4037ed5c:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
4037ed5f:	f59030        	extui	a9, a3, 16, 16
4037ed62:	c8a082        	movi	a8, 200
        return ESP_ERR_NOT_FOUND;
4037ed65:	05a122        	movi	a2, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037ed68:	109987        	bne	a9, a8, 4037ed7c <spi_flash_chip_gd_probe+0x20>
    if (product_id != GD25Q_PRODUCT_ID && product_id != GD25LQ_PRODUCT_ID) {
4037ed6b:	dfa082        	movi	a8, 223
4037ed6e:	118880        	slli	a8, a8, 8
4037ed71:	103380        	and	a3, a3, a8
    return ESP_OK;
4037ed74:	c0d332        	addmi	a3, a3, 0xffffc000
4037ed77:	080c      	movi.n	a8, 0
4037ed79:	832830        	moveqz	a2, a8, a3
}
4037ed7c:	f01d      	retw.n
	...

4037ed80 <spi_flash_chip_generic_detect_size>:
} while(0)

static const char TAG[] = "chip_generic";

esp_err_t spi_flash_chip_generic_detect_size(esp_flash_t *chip, uint32_t *size)
{
4037ed80:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
4037ed83:	6288      	l32i.n	a8, a2, 24
    *size = 0;

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
4037ed85:	190c      	movi.n	a9, 1
4037ed87:	f4a080        	extui	a10, a8, 0, 16
4037ed8a:	0b0c      	movi.n	a11, 0
4037ed8c:	83b9a0        	moveqz	a11, a9, a10
4037ed8f:	7420b0        	extui	a2, a11, 0, 8
4037ed92:	8bcc      	bnez.n	a11, 4037ed9e <spi_flash_chip_generic_detect_size+0x1e>
4037ed94:	d881b1        	l32r	a11, 40374f98 <_iram_text_start+0xb94>
4037ed97:	aaba      	add.n	a10, a10, a11
4037ed99:	9392a0        	movnez	a9, a2, a10
4037ed9c:	998c      	beqz.n	a9, 4037eda9 <spi_flash_chip_generic_detect_size+0x29>
    *size = 0;
4037ed9e:	020c      	movi.n	a2, 0
4037eda0:	0329      	s32i.n	a2, a3, 0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4037eda2:	d6ce21        	l32r	a2, 403748dc <_iram_text_start+0x4d8>
        mem_density -= SPI_FLASH_HEX_A_F_RANGE;
    }

    *size = 1 << mem_density;
    return ESP_OK;
}
4037eda5:	f01d      	retw.n
4037eda7:	00          	.byte 00
4037eda8:	00          	.byte 00
    uint32_t mem_density = (id & 0xFF);
4037eda9:	748080        	extui	a8, a8, 0, 8
    if (mem_density > SPI_FLASH_LINEAR_DENSITY_LAST_VALUE) {
4037edac:	921c      	movi.n	a2, 25
4037edae:	02b287        	bgeu	a2, a8, 4037edb4 <spi_flash_chip_generic_detect_size+0x34>
        mem_density -= SPI_FLASH_HEX_A_F_RANGE;
4037edb1:	fac882        	addi	a8, a8, -6
    *size = 1 << mem_density;
4037edb4:	190c      	movi.n	a9, 1
4037edb6:	401800        	ssl	a8
4037edb9:	a18900        	sll	a8, a9
4037edbc:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
4037edbe:	020c      	movi.n	a2, 0
4037edc0:	fff846        	j	4037eda5 <spi_flash_chip_generic_detect_size+0x25>
	...

4037edc4 <spi_flash_chip_generic_reset>:
    // else has claimed it yet.
    return ESP_OK;
}

esp_err_t spi_flash_chip_generic_reset(esp_flash_t *chip)
{
4037edc4:	008136        	entry	a1, 64
    //this is written following the winbond spec..
    spi_flash_trans_t t;
    t = (spi_flash_trans_t) {
4037edc7:	0b0c      	movi.n	a11, 0
4037edc9:	cc1c      	movi.n	a12, 28
4037edcb:	20a110        	or	a10, a1, a1
4037edce:	d5a981        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037edd1:	0008e0        	callx8	a8
        .command = CMD_RST_EN,
    };
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037edd4:	02a8      	l32i.n	a10, a2, 0
    t = (spi_flash_trans_t) {
4037edd6:	66a082        	movi	a8, 102
4037edd9:	0a5182        	s16i	a8, a1, 20
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037eddc:	0a88      	l32i.n	a8, a10, 0
4037edde:	01bd      	mov.n	a11, a1
4037ede0:	012882        	l32i	a8, a8, 4
4037ede3:	0008e0        	callx8	a8
    if (err != ESP_OK) {
4037ede6:	baec      	bnez.n	a10, 4037ee15 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    t = (spi_flash_trans_t) {
4037ede8:	0abd      	mov.n	a11, a10
4037edea:	cc1c      	movi.n	a12, 28
4037edec:	01ad      	mov.n	a10, a1
4037edee:	d5a181        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037edf1:	0008e0        	callx8	a8
        .command = CMD_RST_DEV,
    };
    err = chip->host->driver->common_command(chip->host, &t);
4037edf4:	02a8      	l32i.n	a10, a2, 0
    t = (spi_flash_trans_t) {
4037edf6:	99a082        	movi	a8, 153
4037edf9:	0a5182        	s16i	a8, a1, 20
    err = chip->host->driver->common_command(chip->host, &t);
4037edfc:	0a88      	l32i.n	a8, a10, 0
4037edfe:	01bd      	mov.n	a11, a1
4037ee00:	1888      	l32i.n	a8, a8, 4
4037ee02:	0008e0        	callx8	a8
    if (err != ESP_OK) {
4037ee05:	cacc      	bnez.n	a10, 4037ee15 <spi_flash_chip_generic_reset+0x51>
        return err;
    }

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037ee07:	1288      	l32i.n	a8, a2, 4
4037ee09:	02ad      	mov.n	a10, a2
4037ee0b:	1898      	l32i.n	a9, a8, 4
4037ee0d:	152882        	l32i	a8, a8, 84
4037ee10:	09b8      	l32i.n	a11, a9, 0
4037ee12:	0008e0        	callx8	a8
    return err;
}
4037ee15:	0a2d      	mov.n	a2, a10
4037ee17:	f01d      	retw.n
4037ee19:	000000        	ill

4037ee1c <spi_flash_chip_generic_config_host_io_mode>:
    }
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
}

esp_err_t spi_flash_chip_generic_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4037ee1c:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    bool conf_required = false;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4037ee1f:	42e8      	l32i.n	a14, a2, 16
    bool addr_32bit = (flags & SPI_FLASH_CONFIG_IO_MODE_32B_ADDR);
4037ee21:	043030        	extui	a3, a3, 0, 1

    switch (read_mode & 0xFFFF) {
4037ee24:	f490e0        	extui	a9, a14, 0, 16
4037ee27:	023966        	bnei	a9, 3, 4037ee2d <spi_flash_chip_generic_config_host_io_mode+0x11>
4037ee2a:	002606        	j	4037eec6 <spi_flash_chip_generic_config_host_io_mode+0xaa>
4037ee2d:	d810a1        	l32r	a10, 40374e70 <_iram_text_start+0xa6c>
4037ee30:	298ea7        	bany	a14, a10, 4037ee5d <spi_flash_chip_generic_config_host_io_mode+0x41>
4037ee33:	021966        	bnei	a9, 1, 4037ee39 <spi_flash_chip_generic_config_host_io_mode+0x1d>
4037ee36:	003106        	j	4037eefe <spi_flash_chip_generic_config_host_io_mode+0xe2>
4037ee39:	022966        	bnei	a9, 2, 4037ee3f <spi_flash_chip_generic_config_host_io_mode+0x23>
4037ee3c:	002886        	j	4037eee2 <spi_flash_chip_generic_config_host_io_mode+0xc6>
4037ee3f:	d6a6a1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4>
4037ee42:	04e956        	bnez	a9, 4037ee94 <spi_flash_chip_generic_config_host_io_mode+0x78>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
        break;
    case SPI_FLASH_SLOWRD:
        addr_bitlen = SPI_FLASH_SLOWRD_ADDR_BITLEN;
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
4037ee45:	7298      	l32i.n	a9, a2, 28
4037ee47:	02e917        	bbsi	a9, 1, 4037ee4d <spi_flash_chip_generic_config_host_io_mode+0x31>
4037ee4a:	003386        	j	4037ef1c <spi_flash_chip_generic_config_host_io_mode+0x100>
4037ee4d:	d85791        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037ee50:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4037ee52:	3b0c      	movi.n	a11, 3
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
4037ee54:	0509d2        	l8ui	a13, a9, 5
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4037ee57:	391c      	movi.n	a9, 19
4037ee59:	001506        	j	4037eeb1 <spi_flash_chip_generic_config_host_io_mode+0x95>
4037ee5c:	00          	.byte 00
    switch (read_mode & 0xFFFF) {
4037ee5d:	3d4926        	beqi	a9, 4, 4037ee9e <spi_flash_chip_generic_config_host_io_mode+0x82>
4037ee60:	d69ea1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4>
4037ee63:	2d5966        	bnei	a9, 5, 4037ee94 <spi_flash_chip_generic_config_host_io_mode+0x78>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
4037ee66:	7298      	l32i.n	a9, a2, 28
4037ee68:	2c6917        	bbci	a9, 1, 4037ee98 <spi_flash_chip_generic_config_host_io_mode+0x7c>
4037ee6b:	d85091        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037ee6e:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
4037ee70:	eba0b2        	movi	a11, 235
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
4037ee73:	0109d2        	l8ui	a13, a9, 1
        read_command = (addr_32bit? CMD_FASTRD_QIO_4B: CMD_FASTRD_QIO);
4037ee76:	eca092        	movi	a9, 236
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
4037ee79:	93b930        	movnez	a11, a9, a3
4037ee7c:	8c1c      	movi.n	a12, 24
4037ee7e:	092c      	movi.n	a9, 32
4037ee80:	93c930        	movnez	a12, a9, a3
    if (addr_32bit) {
        addr_bitlen += 8;
    }

    if (conf_required) {
        read_mode |= SPI_FLASH_CONFIG_CONF_BITS;
4037ee83:	f37c      	movi.n	a3, -1
4037ee85:	013310        	slli	a3, a3, 31
4037ee88:	20ee30        	or	a14, a14, a3
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
4037ee8b:	02a8      	l32i.n	a10, a2, 0
4037ee8d:	0a38      	l32i.n	a3, a10, 0
4037ee8f:	f338      	l32i.n	a3, a3, 60
4037ee91:	0003e0        	callx8	a3
}
4037ee94:	0a2d      	mov.n	a2, a10
4037ee96:	f01d      	retw.n
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qio_dummy_bitlen : rom_flash_chip_dummy->qio_dummy_bitlen);
4037ee98:	d84691        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037ee9b:	fff3c6        	j	4037ee6e <spi_flash_chip_generic_config_host_io_mode+0x52>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
4037ee9e:	7298      	l32i.n	a9, a2, 28
4037eea0:	1c6917        	bbci	a9, 1, 4037eec0 <spi_flash_chip_generic_config_host_io_mode+0xa4>
4037eea3:	d84291        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037eea6:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4037eea8:	6ba0b2        	movi	a11, 107
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
4037eeab:	0209d2        	l8ui	a13, a9, 2
        read_command = (addr_32bit? CMD_FASTRD_QUAD_4B: CMD_FASTRD_QUAD);
4037eeae:	6ca092        	movi	a9, 108
        read_command = (addr_32bit? CMD_READ_4B: CMD_READ);
4037eeb1:	93b930        	movnez	a11, a9, a3
4037eeb4:	8c1c      	movi.n	a12, 24
4037eeb6:	092c      	movi.n	a9, 32
4037eeb8:	93c930        	movnez	a12, a9, a3
4037eebb:	fff306        	j	4037ee8b <spi_flash_chip_generic_config_host_io_mode+0x6f>
4037eebe:	00          	.byte 00
4037eebf:	00          	.byte 00
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->qout_dummy_bitlen : rom_flash_chip_dummy->qout_dummy_bitlen);
4037eec0:	d83c91        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037eec3:	fff7c6        	j	4037eea6 <spi_flash_chip_generic_config_host_io_mode+0x8a>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
4037eec6:	7298      	l32i.n	a9, a2, 28
4037eec8:	106917        	bbci	a9, 1, 4037eedc <spi_flash_chip_generic_config_host_io_mode+0xc0>
4037eecb:	d83891        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037eece:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
4037eed0:	bba0b2        	movi	a11, 187
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
4037eed3:	0009d2        	l8ui	a13, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_DIO_4B: CMD_FASTRD_DIO);
4037eed6:	bca092        	movi	a9, 188
4037eed9:	ffe706        	j	4037ee79 <spi_flash_chip_generic_config_host_io_mode+0x5d>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dio_dummy_bitlen : rom_flash_chip_dummy->dio_dummy_bitlen);
4037eedc:	d83591        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037eedf:	fffac6        	j	4037eece <spi_flash_chip_generic_config_host_io_mode+0xb2>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
4037eee2:	72a8      	l32i.n	a10, a2, 28
4037eee4:	1009a7        	bnone	a9, a10, 4037eef8 <spi_flash_chip_generic_config_host_io_mode+0xdc>
4037eee7:	d83191        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037eeea:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
4037eeec:	bb3c      	movi.n	a11, 59
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
4037eeee:	0309d2        	l8ui	a13, a9, 3
        read_command = (addr_32bit? CMD_FASTRD_DUAL_4B: CMD_FASTRD_DUAL);
4037eef1:	c93c      	movi.n	a9, 60
4037eef3:	ffee86        	j	4037eeb1 <spi_flash_chip_generic_config_host_io_mode+0x95>
4037eef6:	00          	.byte 00
4037eef7:	00          	.byte 00
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->dout_dummy_bitlen : rom_flash_chip_dummy->dout_dummy_bitlen);
4037eef8:	d82e91        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037eefb:	fffac6        	j	4037eeea <spi_flash_chip_generic_config_host_io_mode+0xce>
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
4037eefe:	7298      	l32i.n	a9, a2, 28
4037ef00:	106917        	bbci	a9, 1, 4037ef14 <spi_flash_chip_generic_config_host_io_mode+0xf8>
4037ef03:	d82a91        	l32r	a9, 40374fac <_iram_text_start+0xba8>
4037ef06:	0998      	l32i.n	a9, a9, 0
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
4037ef08:	bb0c      	movi.n	a11, 11
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
4037ef0a:	0409d2        	l8ui	a13, a9, 4
        read_command = (addr_32bit? CMD_FASTRD_4B: CMD_FASTRD);
4037ef0d:	c90c      	movi.n	a9, 12
4037ef0f:	ffe786        	j	4037eeb1 <spi_flash_chip_generic_config_host_io_mode+0x95>
4037ef12:	00          	.byte 00
4037ef13:	00          	.byte 00
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->fastrd_dummy_bitlen : rom_flash_chip_dummy->fastrd_dummy_bitlen);
4037ef14:	d82791        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037ef17:	fffac6        	j	4037ef06 <spi_flash_chip_generic_config_host_io_mode+0xea>
4037ef1a:	00          	.byte 00
4037ef1b:	00          	.byte 00
        dummy_cyclelen_base = (chip->hpm_dummy_ena ? rom_flash_chip_dummy_hpm->slowrd_dummy_bitlen : rom_flash_chip_dummy->slowrd_dummy_bitlen);
4037ef1c:	d82591        	l32r	a9, 40374fb0 <_iram_text_start+0xbac>
4037ef1f:	ffcb46        	j	4037ee50 <spi_flash_chip_generic_config_host_io_mode+0x34>
	...

4037ef24 <spi_flash_chip_generic_read>:
{
4037ef24:	010136        	entry	a1, 128
    const uint32_t page_size = chip->chip_drv->page_size;
4037ef27:	1268      	l32i.n	a6, a2, 4
{
4037ef29:	027d      	mov.n	a7, a2
    const uint32_t page_size = chip->chip_drv->page_size;
4037ef2b:	132622        	l32i	a2, a6, 76
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4037ef2e:	1e2662        	l32i	a6, a6, 120
4037ef31:	0b0c      	movi.n	a11, 0
4037ef33:	20a770        	or	a10, a7, a7
    const uint32_t page_size = chip->chip_drv->page_size;
4037ef36:	156122        	s32i	a2, a1, 84
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4037ef39:	0006e0        	callx8	a6
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037ef3c:	06a162        	movi	a6, 0x106
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4037ef3f:	0a2d      	mov.n	a2, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037ef41:	679a67        	bne	a10, a6, 4037efac <spi_flash_chip_generic_read+0x88>
}
4037ef44:	f01d      	retw.n
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4037ef46:	0c4c      	movi.n	a12, 64
4037ef48:	ffa0b2        	movi	a11, 255
4037ef4b:	20a110        	or	a10, a1, a1
4037ef4e:	d54981        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037ef51:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
4037ef54:	07a8      	l32i.n	a10, a7, 0
4037ef56:	1521e2        	l32i	a14, a1, 84
4037ef59:	0a68      	l32i.n	a6, a10, 0
4037ef5b:	05cd      	mov.n	a12, a5
4037ef5d:	0d2662        	l32i	a6, a6, 52
4037ef60:	20b440        	or	a11, a4, a4
4037ef63:	40c1d2        	addi	a13, a1, 64
4037ef66:	0006e0        	callx8	a6
        uint32_t left_off = address - align_address;
4037ef69:	1021c2        	l32i	a12, a1, 64
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
4037ef6c:	0add      	mov.n	a13, a10
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037ef6e:	2caa      	add.n	a2, a12, a10
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef70:	07a8      	l32i.n	a10, a7, 0
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037ef72:	654a      	add.n	a6, a5, a4
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef74:	0a98      	l32i.n	a9, a10, 0
        uint32_t left_off = address - align_address;
4037ef76:	c0e4c0        	sub	a14, a4, a12
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037ef79:	636620        	minu	a6, a6, a2
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef7c:	b998      	l32i.n	a9, a9, 44
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037ef7e:	c08640        	sub	a8, a6, a4
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef81:	01bd      	mov.n	a11, a1
4037ef83:	1661e2        	s32i	a14, a1, 88
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037ef86:	146182        	s32i	a8, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef89:	0009e0        	callx8	a9
        memcpy(buffer, temp_buffer + left_off, data_len);
4037ef8c:	1621e2        	l32i	a14, a1, 88
4037ef8f:	1421c2        	l32i	a12, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037ef92:	0a2d      	mov.n	a2, a10
        memcpy(buffer, temp_buffer + left_off, data_len);
4037ef94:	80b1e0        	add	a11, a1, a14
4037ef97:	20a330        	or	a10, a3, a3
4037ef9a:	d54581        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037ef9d:	0008e0        	callx8	a8
        buffer = (void *)((intptr_t)buffer + data_len);
4037efa0:	142182        	l32i	a8, a1, 80
        length = length - data_len;
4037efa3:	c04460        	sub	a4, a4, a6
4037efa6:	554a      	add.n	a5, a5, a4
        buffer = (void *)((intptr_t)buffer + data_len);
4037efa8:	338a      	add.n	a3, a3, a8
        address += data_len;
4037efaa:	064d      	mov.n	a4, a6
    while (err == ESP_OK && length > 0) {
4037efac:	f94256        	bnez	a2, 4037ef44 <spi_flash_chip_generic_read+0x20>
4037efaf:	f93556        	bnez	a5, 4037ef46 <spi_flash_chip_generic_read+0x22>
4037efb2:	ffe386        	j	4037ef44 <spi_flash_chip_generic_read+0x20>
4037efb5:	000000        	ill

4037efb8 <spi_flash_chip_generic_write>:
{
4037efb8:	010136        	entry	a1, 128
4037efbb:	027d      	mov.n	a7, a2
    const uint32_t page_size = chip->chip_drv->page_size;
4037efbd:	1228      	l32i.n	a2, a2, 4
    esp_err_t err = ESP_OK;
4037efbf:	0a0c      	movi.n	a10, 0
    const uint32_t page_size = chip->chip_drv->page_size;
4037efc1:	132222        	l32i	a2, a2, 76
4037efc4:	146122        	s32i	a2, a1, 80
    while (err == ESP_OK && length > 0) {
4037efc7:	090c      	movi.n	a9, 0
4037efc9:	01a022        	movi	a2, 1
4037efcc:	832950        	moveqz	a2, a9, a5
4037efcf:	742020        	extui	a2, a2, 0, 8
4037efd2:	029a97        	bne	a10, a9, 4037efd8 <spi_flash_chip_generic_write+0x20>
4037efd5:	049297        	bne	a2, a9, 4037efdd <spi_flash_chip_generic_write+0x25>
}
4037efd8:	0a2d      	mov.n	a2, a10
4037efda:	f01d      	retw.n
4037efdc:	00          	.byte 00
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4037efdd:	0c4c      	movi.n	a12, 64
4037efdf:	ffa0b2        	movi	a11, 255
4037efe2:	01ad      	mov.n	a10, a1
4037efe4:	166192        	s32i	a9, a1, 88
4037efe7:	d52381        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037efea:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
4037efed:	07a8      	l32i.n	a10, a7, 0
4037efef:	1421e2        	l32i	a14, a1, 80
4037eff2:	0a28      	l32i.n	a2, a10, 0
4037eff4:	40c1d2        	addi	a13, a1, 64
4037eff7:	a228      	l32i.n	a2, a2, 40
4037eff9:	05cd      	mov.n	a12, a5
4037effb:	20b440        	or	a11, a4, a4
4037effe:	0002e0        	callx8	a2
4037f001:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
4037f003:	1021a2        	l32i	a10, a1, 64
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
4037f006:	245a      	add.n	a2, a4, a5
4037f008:	6ada      	add.n	a6, a10, a13
4037f00a:	632260        	minu	a2, a2, a6
4037f00d:	c06240        	sub	a6, a2, a4
        uint32_t left_off = address - align_address;
4037f010:	c0a4a0        	sub	a10, a4, a10
        memcpy(temp_buffer + left_off, buffer, write_len);
4037f013:	06cd      	mov.n	a12, a6
4037f015:	03bd      	mov.n	a11, a3
4037f017:	a1aa      	add.n	a10, a1, a10
4037f019:	1561d2        	s32i	a13, a1, 84
4037f01c:	d52581        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037f01f:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f022:	17a8      	l32i.n	a10, a7, 4
4037f024:	162192        	l32i	a9, a1, 88
4037f027:	bac8      	l32i.n	a12, a10, 44
4037f029:	09bd      	mov.n	a11, a9
4037f02b:	07ad      	mov.n	a10, a7
4037f02d:	000ce0        	callx8	a12
        if (err == ESP_OK && length > 0) {
4037f030:	1521d2        	l32i	a13, a1, 84
4037f033:	fa1a56        	bnez	a10, 4037efd8 <spi_flash_chip_generic_write+0x20>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037f036:	1798      	l32i.n	a9, a7, 4
4037f038:	1021c2        	l32i	a12, a1, 64
4037f03b:	122992        	l32i	a9, a9, 72
            length -= write_len;
4037f03e:	c04420        	sub	a4, a4, a2
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037f041:	01bd      	mov.n	a11, a1
4037f043:	07ad      	mov.n	a10, a7
            length -= write_len;
4037f045:	554a      	add.n	a5, a5, a4
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037f047:	0009e0        	callx8	a9
            buffer = (void *)((intptr_t)buffer + write_len);
4037f04a:	336a      	add.n	a3, a3, a6
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
4037f04c:	024d      	mov.n	a4, a2
4037f04e:	ffdd46        	j	4037efc7 <spi_flash_chip_generic_write+0xf>
4037f051:	000000        	ill

4037f054 <spi_flash_chip_generic_yield>:
{
4037f054:	006136        	entry	a1, 48
    if (chip->os_func->check_yield) {
4037f057:	2248      	l32i.n	a4, a2, 8
4037f059:	6488      	l32i.n	a8, a4, 24
4037f05b:	040c      	movi.n	a4, 0
4037f05d:	341847        	beq	a8, a4, 4037f095 <spi_flash_chip_generic_yield+0x41>
    uint32_t flags = wip? 1: 0; //check_yield() and yield() impls should not issue suspend/resume if this flag is zero
4037f060:	1b0c      	movi.n	a11, 1
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
4037f062:	32a8      	l32i.n	a10, a2, 12
    uint32_t flags = wip? 1: 0; //check_yield() and yield() impls should not issue suspend/resume if this flag is zero
4037f064:	83b430        	moveqz	a11, a4, a3
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
4037f067:	04c1c2        	addi	a12, a1, 4
4037f06a:	0008e0        	callx8	a8
        if (err == ESP_OK) {
4037f06d:	139a47        	bne	a10, a4, 4037f084 <spi_flash_chip_generic_yield+0x30>
            if (err == ESP_OK && (request & SPI_FLASH_YIELD_REQ_YIELD) != 0) {
4037f070:	1148      	l32i.n	a4, a1, 4
4037f072:	0a6407        	bbci	a4, 0, 4037f080 <spi_flash_chip_generic_yield+0x2c>
                err = chip->os_func->yield(chip->os_func_data, &status);
4037f075:	2248      	l32i.n	a4, a2, 8
4037f077:	32a8      	l32i.n	a10, a2, 12
4037f079:	7448      	l32i.n	a4, a4, 28
4037f07b:	01bd      	mov.n	a11, a1
4037f07d:	0004e0        	callx8	a4
}
4037f080:	0a2d      	mov.n	a2, a10
4037f082:	f01d      	retw.n
        } else if (err == ESP_ERR_TIMEOUT) {
4037f084:	07a122        	movi	a2, 0x107
4037f087:	021a27        	beq	a10, a2, 4037f08d <spi_flash_chip_generic_yield+0x39>
            abort();
4037f08a:	ff6f25        	call8	4037e77c <abort>
        err = chip->os_func->check_yield(chip->os_func_data, flags, &request);
4037f08d:	04ad      	mov.n	a10, a4
4037f08f:	fffb46        	j	4037f080 <spi_flash_chip_generic_yield+0x2c>
4037f092:	00          	.byte 00
4037f093:	00          	.byte 00
4037f094:	00          	.byte 00
    esp_err_t err = ESP_OK;
4037f095:	08ad      	mov.n	a10, a8
    return err;
4037f097:	fff946        	j	4037f080 <spi_flash_chip_generic_yield+0x2c>
	...

4037f09c <spi_flash_chip_generic_read_unique_id>:
                                        BIT_QE);
}
#endif // CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_generic_read_unique_id(esp_flash_t *chip, uint64_t* flash_unique_id)
{
4037f09c:	00a136        	entry	a1, 80
    uint64_t unique_id_buf = 0;
4037f09f:	080c      	movi.n	a8, 0
    spi_flash_trans_t transfer = {
4037f0a1:	08bd      	mov.n	a11, a8
4037f0a3:	cc1c      	movi.n	a12, 28
4037f0a5:	01ad      	mov.n	a10, a1
    uint64_t unique_id_buf = 0;
4037f0a7:	8189      	s32i.n	a8, a1, 32
4037f0a9:	096182        	s32i	a8, a1, 36
    spi_flash_trans_t transfer = {
4037f0ac:	d4f281        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f0af:	0008e0        	callx8	a8
4037f0b2:	880c      	movi.n	a8, 8
4037f0b4:	024182        	s8i	a8, a1, 2
4037f0b7:	20c182        	addi	a8, a1, 32
4037f0ba:	3189      	s32i.n	a8, a1, 12
4037f0bc:	b84c      	movi.n	a8, 75
        .command = CMD_RDUID,
        .miso_len = 8,
        .miso_data = ((uint8_t *)&unique_id_buf),
        .dummy_bitlen = 32, //RDUID command followed by 4 bytes (32 bits) of dummy clocks.
    };
    esp_err_t err = chip->host->driver->common_command(chip->host, &transfer);
4037f0be:	02a8      	l32i.n	a10, a2, 0
    spi_flash_trans_t transfer = {
4037f0c0:	0a5182        	s16i	a8, a1, 20
4037f0c3:	082c      	movi.n	a8, 32
4037f0c5:	164182        	s8i	a8, a1, 22
    esp_err_t err = chip->host->driver->common_command(chip->host, &transfer);
4037f0c8:	0a28      	l32i.n	a2, a10, 0
4037f0ca:	01bd      	mov.n	a11, a1
4037f0cc:	1228      	l32i.n	a2, a2, 4
4037f0ce:	0002e0        	callx8	a2
4037f0d1:	0a2d      	mov.n	a2, a10

    if (unique_id_buf == 0 || unique_id_buf == UINT64_MAX) {
4037f0d3:	81a8      	l32i.n	a10, a1, 32
4037f0d5:	91b8      	l32i.n	a11, a1, 36
4037f0d7:	8a0b      	addi.n	a8, a10, -1
4037f0d9:	190c      	movi.n	a9, 1
4037f0db:	0238a7        	bltu	a8, a10, 4037f0e1 <spi_flash_chip_generic_read_unique_id+0x45>
4037f0de:	00a092        	movi	a9, 0
4037f0e1:	60c0b0        	neg	a12, a11
4037f0e4:	049c97        	bne	a12, a9, 4037f0ec <spi_flash_chip_generic_read_unique_id+0x50>
4037f0e7:	d97c      	movi.n	a9, -3
4037f0e9:	0b3987        	bltu	a9, a8, 4037f0f8 <spi_flash_chip_generic_read_unique_id+0x5c>
        ESP_EARLY_LOGE(TAG, "No response from device when trying to retrieve Unique ID\n");
        *flash_unique_id = unique_id_buf;
        return ESP_ERR_NOT_SUPPORTED;
    }

    *flash_unique_id = __builtin_bswap64(unique_id_buf);
4037f0ec:	d7b281        	l32r	a8, 40374fb4 <_iram_text_start+0xbb0>
4037f0ef:	0008e0        	callx8	a8
    return err;
4037f0f2:	03a9      	s32i.n	a10, a3, 0
4037f0f4:	13b9      	s32i.n	a11, a3, 4
}
4037f0f6:	f01d      	retw.n
        return ESP_ERR_NOT_SUPPORTED;
4037f0f8:	06a122        	movi	a2, 0x106
4037f0fb:	fffcc6        	j	4037f0f2 <spi_flash_chip_generic_read_unique_id+0x56>
	...

4037f100 <spi_flash_chip_generic_write_encrypted>:
{
4037f100:	004136        	entry	a1, 32
    if (chip != esp_flash_default_chip) {
4037f103:	d7ad61        	l32r	a6, 40374fb8 <_iram_text_start+0xbb4>
4037f106:	002662        	l32i	a6, a6, 0
4037f109:	081627        	beq	a6, a2, 4037f115 <spi_flash_chip_generic_write_encrypted+0x15>
        return ESP_ERR_NOT_SUPPORTED;
4037f10c:	06a1a2        	movi	a10, 0x106
}
4037f10f:	0a2d      	mov.n	a2, a10
4037f111:	f01d      	retw.n
4037f113:	00          	.byte 00
4037f114:	00          	.byte 00
    if (esp_flash_encryption->flash_encryption_check(address, length) != true) {
4037f115:	d7a961        	l32r	a6, 40374fbc <_iram_text_start+0xbb8>
4037f118:	05bd      	mov.n	a11, a5
4037f11a:	5678      	l32i.n	a7, a6, 20
4037f11c:	04ad      	mov.n	a10, a4
4037f11e:	0007e0        	callx8	a7
4037f121:	fe7a16        	beqz	a10, 4037f10c <spi_flash_chip_generic_write_encrypted+0xc>
    esp_flash_encryption->flash_encryption_enable();
4037f124:	0678      	l32i.n	a7, a6, 0
4037f126:	0007e0        	callx8	a7
    while (length > 0) {
4037f129:	85cc      	bnez.n	a5, 4037f135 <spi_flash_chip_generic_write_encrypted+0x35>
    esp_flash_encryption->flash_encryption_disable();
4037f12b:	1628      	l32i.n	a2, a6, 4
4037f12d:	0002e0        	callx8	a2
    return err;
4037f130:	05ad      	mov.n	a10, a5
4037f132:	fff646        	j	4037f10f <spi_flash_chip_generic_write_encrypted+0xf>
        if (address % 64 == 0 && length >= 64) {
4037f135:	547040        	extui	a7, a4, 0, 6
4037f138:	57cc      	bnez.n	a7, 4037f141 <spi_flash_chip_generic_write_encrypted+0x41>
4037f13a:	f83c      	movi.n	a8, 63
            block_size = 64;
4037f13c:	074c      	movi.n	a7, 64
        if (address % 64 == 0 && length >= 64) {
4037f13e:	0e3857        	bltu	a8, a5, 4037f150 <spi_flash_chip_generic_write_encrypted+0x50>
        } else if (address % 32 == 0 && length >= 32) {
4037f141:	447040        	extui	a7, a4, 0, 5
4037f144:	67cc      	bnez.n	a7, 4037f14e <spi_flash_chip_generic_write_encrypted+0x4e>
4037f146:	f81c      	movi.n	a8, 31
            block_size = 32;
4037f148:	20a072        	movi	a7, 32
        } else if (address % 32 == 0 && length >= 32) {
4037f14b:	013857        	bltu	a8, a5, 4037f150 <spi_flash_chip_generic_write_encrypted+0x50>
            block_size = 16;
4037f14e:	071c      	movi.n	a7, 16
        esp_flash_encryption->flash_encryption_data_prepare(address, (uint32_t *)data_bytes, block_size);
4037f150:	2688      	l32i.n	a8, a6, 8
4037f152:	03bd      	mov.n	a11, a3
4037f154:	04ad      	mov.n	a10, a4
4037f156:	20c770        	or	a12, a7, a7
4037f159:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f15c:	1288      	l32i.n	a8, a2, 4
4037f15e:	0b0c      	movi.n	a11, 0
4037f160:	b888      	l32i.n	a8, a8, 44
4037f162:	20a220        	or	a10, a2, a2
4037f165:	0008e0        	callx8	a8
        if (err != ESP_OK) {
4037f168:	fa3a56        	bnez	a10, 4037f10f <spi_flash_chip_generic_write_encrypted+0xf>
        esp_flash_encryption->flash_encryption_done();
4037f16b:	3688      	l32i.n	a8, a6, 12
4037f16d:	0008e0        	callx8	a8
        err = chip->chip_drv->write(chip, (uint32_t *)data_bytes, address, length);
4037f170:	1288      	l32i.n	a8, a2, 4
4037f172:	05dd      	mov.n	a13, a5
4037f174:	112882        	l32i	a8, a8, 68
4037f177:	04cd      	mov.n	a12, a4
4037f179:	03bd      	mov.n	a11, a3
4037f17b:	02ad      	mov.n	a10, a2
4037f17d:	0008e0        	callx8	a8
        if (err != ESP_OK) {
4037f180:	f8ba56        	bnez	a10, 4037f10f <spi_flash_chip_generic_write_encrypted+0xf>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
4037f183:	1288      	l32i.n	a8, a2, 4
4037f185:	02ad      	mov.n	a10, a2
4037f187:	1898      	l32i.n	a9, a8, 4
4037f189:	152882        	l32i	a8, a8, 84
4037f18c:	49b8      	l32i.n	a11, a9, 16
4037f18e:	0008e0        	callx8	a8
        if (err != ESP_OK) {
4037f191:	f7aa56        	bnez	a10, 4037f10f <spi_flash_chip_generic_write_encrypted+0xf>
        esp_flash_encryption->flash_encryption_destroy();
4037f194:	4688      	l32i.n	a8, a6, 16
        length -= block_size;
4037f196:	c05570        	sub	a5, a5, a7
        esp_flash_encryption->flash_encryption_destroy();
4037f199:	0008e0        	callx8	a8
        data_bytes += block_size;
4037f19c:	337a      	add.n	a3, a3, a7
        address += block_size;
4037f19e:	447a      	add.n	a4, a4, a7
4037f1a0:	ffe146        	j	4037f129 <spi_flash_chip_generic_write_encrypted+0x29>
	...

4037f1a4 <spi_flash_chip_generic_get_write_protect>:
{
4037f1a4:	006136        	entry	a1, 48
4037f1a7:	20a220        	or	a10, a2, a2
    assert(out_write_protect!=NULL);
4037f1aa:	00e356        	bnez	a3, 4037f1bc <spi_flash_chip_generic_get_write_protect+0x18>
4037f1ad:	d784d1        	l32r	a13, 40374fc0 <_iram_text_start+0xbbc>
4037f1b0:	d785c1        	l32r	a12, 40374fc4 <_iram_text_start+0xbc0>
4037f1b3:	d785a1        	l32r	a10, 40374fc8 <_iram_text_start+0xbc4>
4037f1b6:	88a1b2        	movi	a11, 0x188
4037f1b9:	ff6525        	call8	4037e80c <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
4037f1bc:	012282        	l32i	a8, a2, 4
4037f1bf:	01cd      	mov.n	a12, a1
4037f1c1:	192882        	l32i	a8, a8, 100
4037f1c4:	1b0c      	movi.n	a11, 1
4037f1c6:	0008e0        	callx8	a8
    if (err != ESP_OK) {
4037f1c9:	bacc      	bnez.n	a10, 4037f1d8 <spi_flash_chip_generic_get_write_protect+0x34>
    *out_write_protect = ((status & SR_WREN) == 0);
4037f1cb:	0188      	l32i.n	a8, a1, 0
4037f1cd:	190c      	movi.n	a9, 1
4037f1cf:	048180        	extui	a8, a8, 1, 1
4037f1d2:	308890        	xor	a8, a8, a9
4037f1d5:	004382        	s8i	a8, a3, 0
}
4037f1d8:	0a2d      	mov.n	a2, a10
4037f1da:	f01d      	retw.n

4037f1dc <spi_flash_common_read_qe_sr$constprop$0$isra$0>:
#ifndef CONFIG_SPI_FLASH_ROM_IMPL
/*******************************************************************************
 * Utility functions
 ******************************************************************************/

static esp_err_t spi_flash_common_read_qe_sr(esp_flash_t *chip, uint8_t qe_rdsr_command, uint8_t qe_sr_bitwidth, uint32_t *sr)
4037f1dc:	008136        	entry	a1, 64
{
    uint32_t sr_buf = 0;
4037f1df:	0b0c      	movi.n	a11, 0
    spi_flash_trans_t t = {
4037f1e1:	cc1c      	movi.n	a12, 28
4037f1e3:	01ad      	mov.n	a10, a1
    uint32_t sr_buf = 0;
4037f1e5:	71b9      	s32i.n	a11, a1, 28
    spi_flash_trans_t t = {
4037f1e7:	d4a381        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f1ea:	0008e0        	callx8	a8
4037f1ed:	180c      	movi.n	a8, 1
4037f1ef:	024182        	s8i	a8, a1, 2
4037f1f2:	1cc182        	addi	a8, a1, 28
4037f1f5:	3189      	s32i.n	a8, a1, 12
        .command = qe_rdsr_command,
        .miso_data = (uint8_t*) &sr_buf,
        .miso_len = qe_sr_bitwidth / 8,
    };
    esp_err_t ret = chip->host->driver->common_command(chip->host, &t);
4037f1f7:	0288      	l32i.n	a8, a2, 0
    spi_flash_trans_t t = {
4037f1f9:	0a5132        	s16i	a3, a1, 20
    esp_err_t ret = chip->host->driver->common_command(chip->host, &t);
4037f1fc:	1888      	l32i.n	a8, a8, 4
4037f1fe:	01bd      	mov.n	a11, a1
4037f200:	02ad      	mov.n	a10, a2
4037f202:	0008e0        	callx8	a8
    *sr = sr_buf;
4037f205:	7128      	l32i.n	a2, a1, 28
4037f207:	0429      	s32i.n	a2, a4, 0
    return ret;
}
4037f209:	0a2d      	mov.n	a2, a10
4037f20b:	f01d      	retw.n
4037f20d:	000000        	ill

4037f210 <spi_flash_common_read_status_16b_rdsr_rdsr2>:
    };
    return chip->host->driver->common_command(chip->host, &t);
}

esp_err_t spi_flash_common_read_status_16b_rdsr_rdsr2(esp_flash_t* chip, uint32_t* out_sr)
{
4037f210:	006136        	entry	a1, 48
    uint32_t sr, sr2;
    esp_err_t ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, &sr2);
4037f213:	0022a2        	l32i	a10, a2, 0
4037f216:	20c110        	or	a12, a1, a1
4037f219:	35a0b2        	movi	a11, 53
4037f21c:	fffbe5        	call8	4037f1dc <spi_flash_common_read_qe_sr$constprop$0$isra$0>
    if (ret == ESP_OK) {
4037f21f:	9adc      	bnez.n	a10, 4037f23c <spi_flash_common_read_status_16b_rdsr_rdsr2+0x2c>
        ret = spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, &sr);
4037f221:	02a8      	l32i.n	a10, a2, 0
4037f223:	c14b      	addi.n	a12, a1, 4
4037f225:	5b0c      	movi.n	a11, 5
4037f227:	fffb65        	call8	4037f1dc <spi_flash_common_read_qe_sr$constprop$0$isra$0>
    }
    if (ret == ESP_OK) {
4037f22a:	eacc      	bnez.n	a10, 4037f23c <spi_flash_common_read_status_16b_rdsr_rdsr2+0x2c>
        *out_sr = (sr & 0xff) | ((sr2 & 0xff) << 8);
4037f22c:	0188      	l32i.n	a8, a1, 0
4037f22e:	040122        	l8ui	a2, a1, 4
4037f231:	118880        	slli	a8, a8, 8
4037f234:	f48080        	extui	a8, a8, 0, 16
4037f237:	208820        	or	a8, a8, a2
4037f23a:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
4037f23c:	0a2d      	mov.n	a2, a10
4037f23e:	f01d      	retw.n

4037f240 <spi_flash_chip_generic_suspend_cmd_conf>:
}

#endif // !CONFIG_SPI_FLASH_ROM_IMPL

esp_err_t spi_flash_chip_generic_suspend_cmd_conf(esp_flash_t *chip)
{
4037f240:	006136        	entry	a1, 48
    // Only XMC support auto-suspend
    if (chip->chip_id >> 16 != 0x20) {
4037f243:	0d1282        	l16ui	a8, a2, 26
        ESP_EARLY_LOGE(TAG, "The flash you use doesn't support auto suspend, only \'XMC\' is supported");
        return ESP_ERR_NOT_SUPPORTED;
4037f246:	06a1a2        	movi	a10, 0x106
    if (chip->chip_id >> 16 != 0x20) {
4037f249:	15c866        	bnei	a8, 32, 4037f262 <spi_flash_chip_generic_suspend_cmd_conf+0x22>
4037f24c:	02a8      	l32i.n	a10, a2, 0
    }
    spi_flash_sus_cmd_conf sus_conf = {
4037f24e:	80a022        	movi	a2, 128
4037f251:	0129      	s32i.n	a2, a1, 0
4037f253:	d75e21        	l32r	a2, 40374fcc <_iram_text_start+0xbc8>
        .cmd_rdsr = CMD_RDSR2,
        .sus_cmd = CMD_SUSPEND,
        .res_cmd = CMD_RESUME,
    };

    return chip->host->driver->sus_setup(chip->host, &sus_conf);
4037f256:	01bd      	mov.n	a11, a1
    spi_flash_sus_cmd_conf sus_conf = {
4037f258:	1129      	s32i.n	a2, a1, 4
    return chip->host->driver->sus_setup(chip->host, &sus_conf);
4037f25a:	0a28      	l32i.n	a2, a10, 0
4037f25c:	152222        	l32i	a2, a2, 84
4037f25f:	0002e0        	callx8	a2
}
4037f262:	0a2d      	mov.n	a2, a10
4037f264:	f01d      	retw.n
	...

4037f268 <spi_flash_common_write_qe_sr$isra$0>:
static esp_err_t spi_flash_common_write_qe_sr(esp_flash_t *chip, uint8_t qe_wrsr_command, uint8_t qe_sr_bitwidth, uint32_t qe)
4037f268:	00a136        	entry	a1, 80
    spi_flash_trans_t t = {
4037f26b:	cc1c      	movi.n	a12, 28
4037f26d:	0b0c      	movi.n	a11, 0
4037f26f:	01ad      	mov.n	a10, a1
4037f271:	414340        	srli	a4, a4, 3
static esp_err_t spi_flash_common_write_qe_sr(esp_flash_t *chip, uint8_t qe_wrsr_command, uint8_t qe_sr_bitwidth, uint32_t qe)
4037f274:	8159      	s32i.n	a5, a1, 32
    spi_flash_trans_t t = {
4037f276:	d47f81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f279:	0008e0        	callx8	a8
4037f27c:	014142        	s8i	a4, a1, 1
4037f27f:	20c142        	addi	a4, a1, 32
4037f282:	2149      	s32i.n	a4, a1, 8
    return chip->host->driver->common_command(chip->host, &t);
4037f284:	0248      	l32i.n	a4, a2, 0
    spi_flash_trans_t t = {
4037f286:	0a5132        	s16i	a3, a1, 20
    return chip->host->driver->common_command(chip->host, &t);
4037f289:	1448      	l32i.n	a4, a4, 4
4037f28b:	01bd      	mov.n	a11, a1
4037f28d:	02ad      	mov.n	a10, a2
4037f28f:	0004e0        	callx8	a4
}
4037f292:	0a2d      	mov.n	a2, a10
4037f294:	f01d      	retw.n
	...

4037f298 <spi_flash_common_write_status_16b_wrsr>:
{
4037f298:	004136        	entry	a1, 32
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 16, sr);
4037f29b:	0022a2        	l32i	a10, a2, 0
4037f29e:	20d330        	or	a13, a3, a3
4037f2a1:	10a0c2        	movi	a12, 16
4037f2a4:	1b0c      	movi.n	a11, 1
4037f2a6:	fffc25        	call8	4037f268 <spi_flash_common_write_qe_sr$isra$0>
}
4037f2a9:	0a2d      	mov.n	a2, a10
4037f2ab:	f01d      	retw.n
4037f2ad:	000000        	ill

4037f2b0 <spi_flash_common_read_status_8b_rdsr2>:
{
4037f2b0:	004136        	entry	a1, 32
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR2, 8, out_sr);
4037f2b3:	02a8      	l32i.n	a10, a2, 0
4037f2b5:	03cd      	mov.n	a12, a3
4037f2b7:	5b3c      	movi.n	a11, 53
4037f2b9:	fff225        	call8	4037f1dc <spi_flash_common_read_qe_sr$constprop$0$isra$0>
}
4037f2bc:	0a2d      	mov.n	a2, a10
4037f2be:	f01d      	retw.n

4037f2c0 <spi_flash_chip_generic_get_io_mode>:
{
4037f2c0:	006136        	entry	a1, 48
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr2(chip, &sr);
4037f2c3:	20b110        	or	a11, a1, a1
4037f2c6:	20a220        	or	a10, a2, a2
4037f2c9:	fffe65        	call8	4037f2b0 <spi_flash_common_read_status_8b_rdsr2>
    if (ret == ESP_OK) {
4037f2cc:	00aa56        	bnez	a10, 4037f2da <spi_flash_chip_generic_get_io_mode+0x1a>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
4037f2cf:	0188      	l32i.n	a8, a1, 0
4037f2d1:	490c      	movi.n	a9, 4
4037f2d3:	888a      	add.n	a8, a8, a8
4037f2d5:	108890        	and	a8, a8, a9
4037f2d8:	0389      	s32i.n	a8, a3, 0
}
4037f2da:	0a2d      	mov.n	a2, a10
4037f2dc:	f01d      	retw.n
	...

4037f2e0 <spi_flash_common_read_status_8b_rdsr>:
{
4037f2e0:	004136        	entry	a1, 32
    return spi_flash_common_read_qe_sr(chip, CMD_RDSR, 8, out_sr);
4037f2e3:	02a8      	l32i.n	a10, a2, 0
4037f2e5:	03cd      	mov.n	a12, a3
4037f2e7:	5b0c      	movi.n	a11, 5
4037f2e9:	ffef25        	call8	4037f1dc <spi_flash_common_read_qe_sr$constprop$0$isra$0>
}
4037f2ec:	0a2d      	mov.n	a2, a10
4037f2ee:	f01d      	retw.n

4037f2f0 <spi_flash_common_write_status_8b_wrsr>:
{
4037f2f0:	004136        	entry	a1, 32
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR, 8, sr);
4037f2f3:	0022a2        	l32i	a10, a2, 0
4037f2f6:	20d330        	or	a13, a3, a3
4037f2f9:	08a0c2        	movi	a12, 8
4037f2fc:	1b0c      	movi.n	a11, 1
4037f2fe:	fff6a5        	call8	4037f268 <spi_flash_common_write_qe_sr$isra$0>
}
4037f301:	0a2d      	mov.n	a2, a10
4037f303:	f01d      	retw.n
4037f305:	000000        	ill

4037f308 <spi_flash_common_write_status_8b_wrsr2>:
{
4037f308:	004136        	entry	a1, 32
    return spi_flash_common_write_qe_sr(chip, CMD_WRSR2, 8, sr);
4037f30b:	0022a2        	l32i	a10, a2, 0
4037f30e:	20d330        	or	a13, a3, a3
4037f311:	08a0c2        	movi	a12, 8
4037f314:	1b3c      	movi.n	a11, 49
4037f316:	fff525        	call8	4037f268 <spi_flash_common_write_qe_sr$isra$0>
}
4037f319:	0a2d      	mov.n	a2, a10
4037f31b:	f01d      	retw.n
4037f31d:	000000        	ill

4037f320 <spi_flash_chip_generic_set_io_mode>:
{
4037f320:	004136        	entry	a1, 32
    return spi_flash_common_set_io_mode(chip,
4037f323:	d71ec1        	l32r	a12, 40374f9c <_iram_text_start+0xb98>
4037f326:	d71eb1        	l32r	a11, 40374fa0 <_iram_text_start+0xb9c>
4037f329:	00a2d2        	movi	a13, 0x200
4037f32c:	20a220        	or	a10, a2, a2
4037f32f:	0032a5        	call8	4037f658 <spi_flash_common_set_io_mode>
}
4037f332:	202aa0        	or	a2, a10, a10
4037f335:	000090        	retw

4037f338 <spi_flash_chip_generic_probe>:
{
4037f338:	004136        	entry	a1, 32
}
4037f33b:	020c      	movi.n	a2, 0
4037f33d:	f01d      	retw.n
	...

4037f340 <spi_flash_chip_generic_erase_chip>:
{
4037f340:	004136        	entry	a1, 32
    err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f343:	1238      	l32i.n	a3, a2, 4
4037f345:	0b0c      	movi.n	a11, 0
4037f347:	b338      	l32i.n	a3, a3, 44
4037f349:	02ad      	mov.n	a10, a2
4037f34b:	0003e0        	callx8	a3
4037f34e:	0a3d      	mov.n	a3, a10
    if (err == ESP_OK) {
4037f350:	eacc      	bnez.n	a10, 4037f362 <spi_flash_chip_generic_erase_chip+0x22>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f352:	1238      	l32i.n	a3, a2, 4
4037f354:	02ad      	mov.n	a10, a2
4037f356:	1388      	l32i.n	a8, a3, 4
4037f358:	152332        	l32i	a3, a3, 84
4037f35b:	08b8      	l32i.n	a11, a8, 0
4037f35d:	0003e0        	callx8	a3
4037f360:	0a3d      	mov.n	a3, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f362:	180c      	movi.n	a8, 1
4037f364:	090c      	movi.n	a9, 0
4037f366:	839830        	moveqz	a9, a8, a3
4037f369:	74a090        	extui	a10, a9, 0, 8
4037f36c:	99cc      	bnez.n	a9, 4037f379 <spi_flash_chip_generic_erase_chip+0x39>
4037f36e:	faae92        	movi	a9, 0xfffffefa
4037f371:	939a      	add.n	a9, a3, a9
4037f373:	938a90        	movnez	a8, a10, a9
4037f376:	04a816        	beqz	a8, 4037f3c4 <spi_flash_chip_generic_erase_chip+0x84>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
4037f379:	2238      	l32i.n	a3, a2, 8
4037f37b:	9338      	l32i.n	a3, a3, 36
4037f37d:	338c      	beqz.n	a3, 4037f384 <spi_flash_chip_generic_erase_chip+0x44>
4037f37f:	1a0c      	movi.n	a10, 1
4037f381:	0003e0        	callx8	a3
        chip->host->driver->erase_chip(chip->host);
4037f384:	02a8      	l32i.n	a10, a2, 0
4037f386:	0a38      	l32i.n	a3, a10, 0
4037f388:	3338      	l32i.n	a3, a3, 12
4037f38a:	0003e0        	callx8	a3
        chip->busy = 1;
4037f38d:	7238      	l32i.n	a3, a2, 28
4037f38f:	180c      	movi.n	a8, 1
4037f391:	203380        	or	a3, a3, a8
4037f394:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
4037f396:	1238      	l32i.n	a3, a2, 4
4037f398:	02ad      	mov.n	a10, a2
4037f39a:	1388      	l32i.n	a8, a3, 4
4037f39c:	152332        	l32i	a3, a3, 84
4037f39f:	18b8      	l32i.n	a11, a8, 4
4037f3a1:	0003e0        	callx8	a3
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f3a4:	2288      	l32i.n	a8, a2, 8
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
4037f3a6:	0a3d      	mov.n	a3, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f3a8:	9888      	l32i.n	a8, a8, 36
4037f3aa:	388c      	beqz.n	a8, 4037f3b1 <spi_flash_chip_generic_erase_chip+0x71>
4037f3ac:	0a0c      	movi.n	a10, 0
4037f3ae:	0008e0        	callx8	a8
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f3b1:	06a182        	movi	a8, 0x106
4037f3b4:	0c9387        	bne	a3, a8, 4037f3c4 <spi_flash_chip_generic_erase_chip+0x84>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f3b7:	1238      	l32i.n	a3, a2, 4
4037f3b9:	1b0c      	movi.n	a11, 1
4037f3bb:	b338      	l32i.n	a3, a3, 44
4037f3bd:	02ad      	mov.n	a10, a2
4037f3bf:	0003e0        	callx8	a3
4037f3c2:	0a3d      	mov.n	a3, a10
}
4037f3c4:	032d      	mov.n	a2, a3
4037f3c6:	f01d      	retw.n

4037f3c8 <spi_flash_chip_generic_erase_sector>:
{
4037f3c8:	004136        	entry	a1, 32
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f3cb:	1248      	l32i.n	a4, a2, 4
4037f3cd:	0b0c      	movi.n	a11, 0
4037f3cf:	b448      	l32i.n	a4, a4, 44
4037f3d1:	02ad      	mov.n	a10, a2
4037f3d3:	0004e0        	callx8	a4
4037f3d6:	0a4d      	mov.n	a4, a10
    if (err == ESP_OK) {
4037f3d8:	eacc      	bnez.n	a10, 4037f3ea <spi_flash_chip_generic_erase_sector+0x22>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f3da:	1248      	l32i.n	a4, a2, 4
4037f3dc:	02ad      	mov.n	a10, a2
4037f3de:	1488      	l32i.n	a8, a4, 4
4037f3e0:	152442        	l32i	a4, a4, 84
4037f3e3:	08b8      	l32i.n	a11, a8, 0
4037f3e5:	0004e0        	callx8	a4
4037f3e8:	0a4d      	mov.n	a4, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f3ea:	180c      	movi.n	a8, 1
4037f3ec:	090c      	movi.n	a9, 0
4037f3ee:	839840        	moveqz	a9, a8, a4
4037f3f1:	74a090        	extui	a10, a9, 0, 8
4037f3f4:	a9cc      	bnez.n	a9, 4037f402 <spi_flash_chip_generic_erase_sector+0x3a>
4037f3f6:	faae92        	movi	a9, 0xfffffefa
4037f3f9:	809490        	add	a9, a4, a9
4037f3fc:	938a90        	movnez	a8, a10, a9
4037f3ff:	051816        	beqz	a8, 4037f454 <spi_flash_chip_generic_erase_sector+0x8c>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
4037f402:	2248      	l32i.n	a4, a2, 8
4037f404:	9448      	l32i.n	a4, a4, 36
4037f406:	448c      	beqz.n	a4, 4037f40e <spi_flash_chip_generic_erase_sector+0x46>
4037f408:	01a0a2        	movi	a10, 1
4037f40b:	0004e0        	callx8	a4
        chip->host->driver->erase_sector(chip->host, start_address);
4037f40e:	02a8      	l32i.n	a10, a2, 0
4037f410:	03bd      	mov.n	a11, a3
4037f412:	0a48      	l32i.n	a4, a10, 0
4037f414:	042442        	l32i	a4, a4, 16
4037f417:	0004e0        	callx8	a4
        chip->busy = 1;
4037f41a:	7238      	l32i.n	a3, a2, 28
4037f41c:	140c      	movi.n	a4, 1
4037f41e:	203340        	or	a3, a3, a4
4037f421:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4037f423:	1238      	l32i.n	a3, a2, 4
4037f425:	02ad      	mov.n	a10, a2
4037f427:	1348      	l32i.n	a4, a3, 4
4037f429:	152332        	l32i	a3, a3, 84
4037f42c:	0324b2        	l32i	a11, a4, 12
4037f42f:	0003e0        	callx8	a3
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f432:	2238      	l32i.n	a3, a2, 8
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4037f434:	0a4d      	mov.n	a4, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f436:	9338      	l32i.n	a3, a3, 36
4037f438:	005316        	beqz	a3, 4037f441 <spi_flash_chip_generic_erase_sector+0x79>
4037f43b:	00a0a2        	movi	a10, 0
4037f43e:	0003e0        	callx8	a3
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f441:	06a132        	movi	a3, 0x106
4037f444:	0c9437        	bne	a4, a3, 4037f454 <spi_flash_chip_generic_erase_sector+0x8c>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f447:	1238      	l32i.n	a3, a2, 4
4037f449:	1b0c      	movi.n	a11, 1
4037f44b:	b338      	l32i.n	a3, a3, 44
4037f44d:	02ad      	mov.n	a10, a2
4037f44f:	0003e0        	callx8	a3
4037f452:	0a4d      	mov.n	a4, a10
}
4037f454:	042d      	mov.n	a2, a4
4037f456:	f01d      	retw.n

4037f458 <spi_flash_chip_generic_erase_block>:
{
4037f458:	004136        	entry	a1, 32
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f45b:	1248      	l32i.n	a4, a2, 4
4037f45d:	0b0c      	movi.n	a11, 0
4037f45f:	b448      	l32i.n	a4, a4, 44
4037f461:	02ad      	mov.n	a10, a2
4037f463:	0004e0        	callx8	a4
4037f466:	0a4d      	mov.n	a4, a10
    if (err == ESP_OK) {
4037f468:	eacc      	bnez.n	a10, 4037f47a <spi_flash_chip_generic_erase_block+0x22>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f46a:	1248      	l32i.n	a4, a2, 4
4037f46c:	02ad      	mov.n	a10, a2
4037f46e:	1488      	l32i.n	a8, a4, 4
4037f470:	152442        	l32i	a4, a4, 84
4037f473:	08b8      	l32i.n	a11, a8, 0
4037f475:	0004e0        	callx8	a4
4037f478:	0a4d      	mov.n	a4, a10
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f47a:	180c      	movi.n	a8, 1
4037f47c:	090c      	movi.n	a9, 0
4037f47e:	839840        	moveqz	a9, a8, a4
4037f481:	74a090        	extui	a10, a9, 0, 8
4037f484:	a9cc      	bnez.n	a9, 4037f492 <spi_flash_chip_generic_erase_block+0x3a>
4037f486:	faae92        	movi	a9, 0xfffffefa
4037f489:	809490        	add	a9, a4, a9
4037f48c:	938a90        	movnez	a8, a10, a9
4037f48f:	051816        	beqz	a8, 4037f4e4 <spi_flash_chip_generic_erase_block+0x8c>
        SET_FLASH_ERASE_STATUS(chip, SPI_FLASH_OS_IS_ERASING_STATUS_FLAG);
4037f492:	2248      	l32i.n	a4, a2, 8
4037f494:	9448      	l32i.n	a4, a4, 36
4037f496:	448c      	beqz.n	a4, 4037f49e <spi_flash_chip_generic_erase_block+0x46>
4037f498:	01a0a2        	movi	a10, 1
4037f49b:	0004e0        	callx8	a4
        chip->host->driver->erase_block(chip->host, start_address);
4037f49e:	02a8      	l32i.n	a10, a2, 0
4037f4a0:	03bd      	mov.n	a11, a3
4037f4a2:	0a48      	l32i.n	a4, a10, 0
4037f4a4:	052442        	l32i	a4, a4, 20
4037f4a7:	0004e0        	callx8	a4
        chip->busy = 1;
4037f4aa:	7238      	l32i.n	a3, a2, 28
4037f4ac:	140c      	movi.n	a4, 1
4037f4ae:	203340        	or	a3, a3, a4
4037f4b1:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4037f4b3:	1238      	l32i.n	a3, a2, 4
4037f4b5:	02ad      	mov.n	a10, a2
4037f4b7:	1348      	l32i.n	a4, a3, 4
4037f4b9:	152332        	l32i	a3, a3, 84
4037f4bc:	0224b2        	l32i	a11, a4, 8
4037f4bf:	0003e0        	callx8	a3
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f4c2:	2238      	l32i.n	a3, a2, 8
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4037f4c4:	0a4d      	mov.n	a4, a10
        SET_FLASH_ERASE_STATUS(chip, 0);
4037f4c6:	9338      	l32i.n	a3, a3, 36
4037f4c8:	005316        	beqz	a3, 4037f4d1 <spi_flash_chip_generic_erase_block+0x79>
4037f4cb:	00a0a2        	movi	a10, 0
4037f4ce:	0003e0        	callx8	a3
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f4d1:	06a132        	movi	a3, 0x106
4037f4d4:	0c9437        	bne	a4, a3, 4037f4e4 <spi_flash_chip_generic_erase_block+0x8c>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f4d7:	1238      	l32i.n	a3, a2, 4
4037f4d9:	1b0c      	movi.n	a11, 1
4037f4db:	b338      	l32i.n	a3, a3, 44
4037f4dd:	02ad      	mov.n	a10, a2
4037f4df:	0003e0        	callx8	a3
4037f4e2:	0a4d      	mov.n	a4, a10
}
4037f4e4:	042d      	mov.n	a2, a4
4037f4e6:	f01d      	retw.n

4037f4e8 <spi_flash_chip_generic_page_program>:
{
4037f4e8:	004136        	entry	a1, 32
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f4eb:	1288      	l32i.n	a8, a2, 4
4037f4ed:	02ad      	mov.n	a10, a2
4037f4ef:	1898      	l32i.n	a9, a8, 4
4037f4f1:	152882        	l32i	a8, a8, 84
4037f4f4:	0029b2        	l32i	a11, a9, 0
4037f4f7:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f4fa:	180c      	movi.n	a8, 1
4037f4fc:	090c      	movi.n	a9, 0
4037f4fe:	8398a0        	moveqz	a9, a8, a10
4037f501:	74b090        	extui	a11, a9, 0, 8
4037f504:	99cc      	bnez.n	a9, 4037f511 <spi_flash_chip_generic_page_program+0x29>
4037f506:	faae92        	movi	a9, 0xfffffefa
4037f509:	809a90        	add	a9, a10, a9
4037f50c:	938b90        	movnez	a8, a11, a9
4037f50f:	68bc      	beqz.n	a8, 4037f549 <spi_flash_chip_generic_page_program+0x61>
        chip->host->driver->program_page(chip->host, buffer, address, length);
4037f511:	02a8      	l32i.n	a10, a2, 0
4037f513:	05dd      	mov.n	a13, a5
4037f515:	0a88      	l32i.n	a8, a10, 0
4037f517:	04cd      	mov.n	a12, a4
4037f519:	8888      	l32i.n	a8, a8, 32
4037f51b:	20b330        	or	a11, a3, a3
4037f51e:	0008e0        	callx8	a8
        chip->busy = 1;
4037f521:	7288      	l32i.n	a8, a2, 28
4037f523:	130c      	movi.n	a3, 1
4037f525:	208830        	or	a8, a8, a3
4037f528:	7289      	s32i.n	a8, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
4037f52a:	1288      	l32i.n	a8, a2, 4
4037f52c:	02ad      	mov.n	a10, a2
4037f52e:	1858      	l32i.n	a5, a8, 4
4037f530:	152842        	l32i	a4, a8, 84
4037f533:	45b8      	l32i.n	a11, a5, 16
4037f535:	0004e0        	callx8	a4
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f538:	06a142        	movi	a4, 0x106
4037f53b:	0a9a47        	bne	a10, a4, 4037f549 <spi_flash_chip_generic_page_program+0x61>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f53e:	1248      	l32i.n	a4, a2, 4
4037f540:	03bd      	mov.n	a11, a3
4037f542:	b448      	l32i.n	a4, a4, 44
4037f544:	02ad      	mov.n	a10, a2
4037f546:	0004e0        	callx8	a4
}
4037f549:	0a2d      	mov.n	a2, a10
4037f54b:	f01d      	retw.n
4037f54d:	000000        	ill

4037f550 <spi_flash_chip_generic_set_write_protect>:
{
4037f550:	006136        	entry	a1, 48
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f553:	1288      	l32i.n	a8, a2, 4
4037f555:	02ad      	mov.n	a10, a2
4037f557:	1898      	l32i.n	a9, a8, 4
4037f559:	152882        	l32i	a8, a8, 84
4037f55c:	09b8      	l32i.n	a11, a9, 0
{
4037f55e:	743030        	extui	a3, a3, 0, 8
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f561:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f564:	180c      	movi.n	a8, 1
4037f566:	090c      	movi.n	a9, 0
4037f568:	8398a0        	moveqz	a9, a8, a10
4037f56b:	74b090        	extui	a11, a9, 0, 8
4037f56e:	89cc      	bnez.n	a9, 4037f57a <spi_flash_chip_generic_set_write_protect+0x2a>
4037f570:	faae92        	movi	a9, 0xfffffefa
4037f573:	aa9a      	add.n	a10, a10, a9
4037f575:	938ba0        	movnez	a8, a11, a10
4037f578:	988c      	beqz.n	a8, 4037f585 <spi_flash_chip_generic_set_write_protect+0x35>
        chip->host->driver->set_write_protect(chip->host, write_protect);
4037f57a:	02a8      	l32i.n	a10, a2, 0
4037f57c:	03bd      	mov.n	a11, a3
4037f57e:	0a88      	l32i.n	a8, a10, 0
4037f580:	7888      	l32i.n	a8, a8, 28
4037f582:	0008e0        	callx8	a8
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
4037f585:	1288      	l32i.n	a8, a2, 4
4037f587:	02ad      	mov.n	a10, a2
4037f589:	a888      	l32i.n	a8, a8, 40
4037f58b:	01bd      	mov.n	a11, a1
4037f58d:	0008e0        	callx8	a8
4037f590:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
4037f592:	aacc      	bnez.n	a10, 4037f5a0 <spi_flash_chip_generic_set_write_protect+0x50>
4037f594:	000182        	l8ui	a8, a1, 0
        err = ESP_ERR_NOT_FOUND;
4037f597:	c08830        	sub	a8, a8, a3
4037f59a:	05a132        	movi	a3, 0x105
4037f59d:	932380        	movnez	a2, a3, a8
}
4037f5a0:	f01d      	retw.n
	...

4037f5a4 <spi_flash_chip_generic_read_reg>:
{
4037f5a4:	004136        	entry	a1, 32
    return chip->host->driver->read_status(chip->host, (uint8_t*)out_reg);
4037f5a7:	02a8      	l32i.n	a10, a2, 0
4037f5a9:	04bd      	mov.n	a11, a4
4037f5ab:	0a88      	l32i.n	a8, a10, 0
4037f5ad:	6888      	l32i.n	a8, a8, 24
4037f5af:	0008e0        	callx8	a8
}
4037f5b2:	0a2d      	mov.n	a2, a10
4037f5b4:	f01d      	retw.n
	...

4037f5b8 <spi_flash_chip_generic_wait_idle>:
{
4037f5b8:	006136        	entry	a1, 48
        timeout_us = 0;// In order to go into while
4037f5bb:	531b      	addi.n	a5, a3, 1
4037f5bd:	040c      	movi.n	a4, 0
4037f5bf:	934350        	movnez	a4, a3, a5
    timeout_us++; // allow at least one pass before timeout, last one has no sleep cycle
4037f5c2:	441b      	addi.n	a4, a4, 1
                chip->os_func->delay_us(chip->os_func_data, delay);
4037f5c4:	150c      	movi.n	a5, 1
        while (!chip->host->driver->host_status(chip->host) && timeout_us > 0) {
4037f5c6:	02a8      	l32i.n	a10, a2, 0
4037f5c8:	0a68      	l32i.n	a6, a10, 0
4037f5ca:	0e2662        	l32i	a6, a6, 56
4037f5cd:	0006e0        	callx8	a6
4037f5d0:	1abc      	beqz.n	a10, 4037f605 <spi_flash_chip_generic_wait_idle+0x4d>
        esp_err_t err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &read);
4037f5d2:	1268      	l32i.n	a6, a2, 4
4037f5d4:	01cd      	mov.n	a12, a1
4037f5d6:	192662        	l32i	a6, a6, 100
4037f5d9:	05bd      	mov.n	a11, a5
4037f5db:	02ad      	mov.n	a10, a2
4037f5dd:	0006e0        	callx8	a6
        if (err != ESP_OK) {
4037f5e0:	dadc      	bnez.n	a10, 4037f601 <spi_flash_chip_generic_wait_idle+0x49>
        if ((status & SR_WIP) == 0) { // Verify write in progress is complete
4037f5e2:	01a8      	l32i.n	a10, a1, 0
4037f5e4:	7460a0        	extui	a6, a10, 0, 8
4037f5e7:	04a0a0        	extui	a10, a10, 0, 1
4037f5ea:	baec      	bnez.n	a10, 4037f619 <spi_flash_chip_generic_wait_idle+0x61>
            if (chip->busy == 1) {
4037f5ec:	7238      	l32i.n	a3, a2, 28
4037f5ee:	0f6307        	bbci	a3, 0, 4037f601 <spi_flash_chip_generic_wait_idle+0x49>
                chip->busy = 0;
4037f5f1:	e47c      	movi.n	a4, -2
4037f5f3:	103340        	and	a3, a3, a4
4037f5f6:	7239      	s32i.n	a3, a2, 28
                if ((status & SR_WREN) != 0) { // The previous command is not accepted, leaving the WEL still set.
4037f5f8:	046160        	extui	a6, a6, 1, 1
                    return ESP_ERR_NOT_SUPPORTED;
4037f5fb:	06a122        	movi	a2, 0x106
4037f5fe:	93a260        	movnez	a10, a2, a6
}
4037f601:	0a2d      	mov.n	a2, a10
4037f603:	f01d      	retw.n
            if (timeout_us > 1) {
4037f605:	bd1426        	beqi	a4, 1, 4037f5c6 <spi_flash_chip_generic_wait_idle+0xe>
                chip->os_func->delay_us(chip->os_func_data, delay);
4037f608:	2268      	l32i.n	a6, a2, 8
4037f60a:	32a8      	l32i.n	a10, a2, 12
4037f60c:	3668      	l32i.n	a6, a6, 12
4037f60e:	20b550        	or	a11, a5, a5
4037f611:	0006e0        	callx8	a6
                timeout_us -= delay;
4037f614:	440b      	addi.n	a4, a4, -1
4037f616:	ffeb06        	j	4037f5c6 <spi_flash_chip_generic_wait_idle+0xe>
            chip->os_func->delay_us(chip->os_func_data, delay);
4037f619:	2288      	l32i.n	a8, a2, 8
            int delay = MIN(interval, timeout_us);
4037f61b:	461c      	movi.n	a6, 20
4037f61d:	636460        	minu	a6, a4, a6
            chip->os_func->delay_us(chip->os_func_data, delay);
4037f620:	3888      	l32i.n	a8, a8, 12
4037f622:	32a8      	l32i.n	a10, a2, 12
4037f624:	06bd      	mov.n	a11, a6
4037f626:	0008e0        	callx8	a8
            if (timeout_en) {
4037f629:	990326        	beqi	a3, -1, 4037f5c6 <spi_flash_chip_generic_wait_idle+0xe>
                timeout_us -= delay;
4037f62c:	c04460        	sub	a4, a4, a6
    while (timeout_us > 0) {
4037f62f:	f93456        	bnez	a4, 4037f5c6 <spi_flash_chip_generic_wait_idle+0xe>
    return (timeout_us > 0) ?  ESP_OK : ESP_ERR_TIMEOUT;
4037f632:	07a1a2        	movi	a10, 0x107
4037f635:	fff206        	j	4037f601 <spi_flash_chip_generic_wait_idle+0x49>

4037f638 <spi_flash_chip_generic_get_caps>:
{
4037f638:	004136        	entry	a1, 32
    if (chip->chip_id >> 16 == 0x20) {
4037f63b:	0d1292        	l16ui	a9, a2, 26
4037f63e:	180c      	movi.n	a8, 1
4037f640:	e0c992        	addi	a9, a9, -32
4037f643:	020c      	movi.n	a2, 0
4037f645:	938290        	movnez	a8, a2, a9
}
4037f648:	420c      	movi.n	a2, 4
4037f64a:	202820        	or	a2, a8, a2
4037f64d:	f01d      	retw.n
	...

4037f650 <spi_flash_chip_generic_read_unique_id_none>:
{
4037f650:	004136        	entry	a1, 32
}
4037f653:	06a122        	movi	a2, 0x106
4037f656:	f01d      	retw.n

4037f658 <spi_flash_common_set_io_mode>:
{
4037f658:	006136        	entry	a1, 48
4037f65b:	4288      	l32i.n	a8, a2, 16
4037f65d:	026d      	mov.n	a6, a2
4037f65f:	fcc882        	addi	a8, a8, -4
    if (need_check) {
4037f662:	020c      	movi.n	a2, 0
4037f664:	3428f6        	bgeui	a8, 2, 4037f69c <spi_flash_common_set_io_mode+0x44>
        ret = (*rdsr_func)(chip, &sr);
4037f667:	01bd      	mov.n	a11, a1
4037f669:	06ad      	mov.n	a10, a6
4037f66b:	0004e0        	callx8	a4
4037f66e:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
4037f670:	8aec      	bnez.n	a10, 4037f69c <spi_flash_common_set_io_mode+0x44>
            sr_update = sr | qe_sr_bit;
4037f672:	0188      	l32i.n	a8, a1, 0
4037f674:	205850        	or	a5, a8, a5
        if (sr != sr_update) {
4037f677:	211857        	beq	a8, a5, 4037f69c <spi_flash_common_set_io_mode+0x44>
        chip->chip_drv->set_chip_write_protect(chip, false);
4037f67a:	1688      	l32i.n	a8, a6, 4
4037f67c:	0abd      	mov.n	a11, a10
4037f67e:	b888      	l32i.n	a8, a8, 44
4037f680:	20a660        	or	a10, a6, a6
4037f683:	0008e0        	callx8	a8
        ret = (*wrsr_func)(chip, sr_update);
4037f686:	05bd      	mov.n	a11, a5
4037f688:	06ad      	mov.n	a10, a6
4037f68a:	0003e0        	callx8	a3
4037f68d:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
4037f68f:	1638      	l32i.n	a3, a6, 4
4037f691:	9a8c      	beqz.n	a10, 4037f69e <spi_flash_common_set_io_mode+0x46>
            chip->chip_drv->set_chip_write_protect(chip, true);
4037f693:	b338      	l32i.n	a3, a3, 44
4037f695:	1b0c      	movi.n	a11, 1
4037f697:	06ad      	mov.n	a10, a6
4037f699:	0003e0        	callx8	a3
}
4037f69c:	f01d      	retw.n
        ret = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f69e:	1388      	l32i.n	a8, a3, 4
4037f6a0:	152322        	l32i	a2, a3, 84
4037f6a3:	0028b2        	l32i	a11, a8, 0
4037f6a6:	20a660        	or	a10, a6, a6
4037f6a9:	0002e0        	callx8	a2
        if (ret == ESP_ERR_NOT_SUPPORTED) {
4037f6ac:	06a132        	movi	a3, 0x106
        ret = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f6af:	0a2d      	mov.n	a2, a10
        if (ret == ESP_ERR_NOT_SUPPORTED) {
4037f6b1:	279a37        	bne	a10, a3, 4037f6dc <spi_flash_common_set_io_mode+0x84>
            chip->chip_drv->set_chip_write_protect(chip, true);
4037f6b4:	1628      	l32i.n	a2, a6, 4
4037f6b6:	1b0c      	movi.n	a11, 1
4037f6b8:	0b2222        	l32i	a2, a2, 44
4037f6bb:	20a660        	or	a10, a6, a6
4037f6be:	0002e0        	callx8	a2
        ret = (*rdsr_func)(chip, &sr);
4037f6c1:	01bd      	mov.n	a11, a1
4037f6c3:	06ad      	mov.n	a10, a6
4037f6c5:	0004e0        	callx8	a4
4037f6c8:	0a2d      	mov.n	a2, a10
        if (ret != ESP_OK) {
4037f6ca:	fcea56        	bnez	a10, 4037f69c <spi_flash_common_set_io_mode+0x44>
            ret = ESP_ERR_FLASH_NO_RESPONSE;
4037f6cd:	0168      	l32i.n	a6, a1, 0
4037f6cf:	08a132        	movi	a3, 0x108
4037f6d2:	c05650        	sub	a5, a6, a5
4037f6d5:	932350        	movnez	a2, a3, a5
4037f6d8:	fff006        	j	4037f69c <spi_flash_common_set_io_mode+0x44>
4037f6db:	00          	.byte 00
        if (ret != ESP_OK && ret != ESP_ERR_NOT_SUPPORTED) {
4037f6dc:	fbca56        	bnez	a10, 4037f69c <spi_flash_common_set_io_mode+0x44>
4037f6df:	fff786        	j	4037f6c1 <spi_flash_common_set_io_mode+0x69>
	...

4037f6e4 <spi_flash_chip_issi_set_io_mode>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_issi_set_io_mode(esp_flash_t *chip)
{
4037f6e4:	004136        	entry	a1, 32
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    return spi_flash_common_set_io_mode(chip,
4037f6e7:	d63ac1        	l32r	a12, 40374fd0 <_iram_text_start+0xbcc>
4037f6ea:	d63ab1        	l32r	a11, 40374fd4 <_iram_text_start+0xbd0>
4037f6ed:	0d4c      	movi.n	a13, 64
4037f6ef:	02ad      	mov.n	a10, a2
4037f6f1:	fff665        	call8	4037f658 <spi_flash_common_set_io_mode>
                                        spi_flash_common_write_status_8b_wrsr,
                                        spi_flash_common_read_status_8b_rdsr,
                                        BIT_QE);
}
4037f6f4:	0a2d      	mov.n	a2, a10
4037f6f6:	f01d      	retw.n

4037f6f8 <spi_flash_chip_issi_get_io_mode>:

esp_err_t spi_flash_chip_issi_get_io_mode(esp_flash_t *chip, esp_flash_io_mode_t* out_io_mode)
{
4037f6f8:	006136        	entry	a1, 48
    /* ISSI uses bit 6 of "basic" SR as Quad Enable */
    const uint8_t BIT_QE = 1 << 6;
    uint32_t sr;
    esp_err_t ret = spi_flash_common_read_status_8b_rdsr(chip, &sr);
4037f6fb:	01bd      	mov.n	a11, a1
4037f6fd:	02ad      	mov.n	a10, a2
4037f6ff:	ffbe25        	call8	4037f2e0 <spi_flash_common_read_status_8b_rdsr>
    if (ret == ESP_OK) {
4037f702:	aacc      	bnez.n	a10, 4037f710 <spi_flash_chip_issi_get_io_mode+0x18>
        *out_io_mode = ((sr & BIT_QE)? SPI_FLASH_QOUT: 0);
4037f704:	0188      	l32i.n	a8, a1, 0
4037f706:	490c      	movi.n	a9, 4
4037f708:	418480        	srli	a8, a8, 4
4037f70b:	108890        	and	a8, a8, a9
4037f70e:	0389      	s32i.n	a8, a3, 0
    }
    return ret;
}
4037f710:	0a2d      	mov.n	a2, a10
4037f712:	f01d      	retw.n

4037f714 <spi_flash_chip_issi_probe>:
{
4037f714:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
4037f717:	f59030        	extui	a9, a3, 16, 16
4037f71a:	9da082        	movi	a8, 157
        return ESP_ERR_NOT_FOUND;
4037f71d:	05a122        	movi	a2, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037f720:	109987        	bne	a9, a8, 4037f734 <spi_flash_chip_issi_probe+0x20>
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
4037f723:	cfa082        	movi	a8, 207
4037f726:	118880        	slli	a8, a8, 8
4037f729:	103380        	and	a3, a3, a8
    return ESP_OK;
4037f72c:	c0d332        	addmi	a3, a3, 0xffffc000
4037f72f:	080c      	movi.n	a8, 0
4037f731:	832830        	moveqz	a2, a8, a3
}
4037f734:	f01d      	retw.n
	...

4037f738 <spi_flash_chip_issi_get_caps>:

spi_flash_caps_t spi_flash_chip_issi_get_caps(esp_flash_t *chip)
{
4037f738:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4037f73b:	420c      	movi.n	a2, 4
4037f73d:	f01d      	retw.n
	...

4037f740 <spi_flash_chip_mxic_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_detect_size(esp_flash_t *chip, uint32_t *size)
{
4037f740:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
4037f743:	6288      	l32i.n	a8, a2, 24
    *size = 0;

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
4037f745:	190c      	movi.n	a9, 1
4037f747:	f4a080        	extui	a10, a8, 0, 16
4037f74a:	0b0c      	movi.n	a11, 0
4037f74c:	83b9a0        	moveqz	a11, a9, a10
4037f74f:	7420b0        	extui	a2, a11, 0, 8
4037f752:	8bcc      	bnez.n	a11, 4037f75e <spi_flash_chip_mxic_detect_size+0x1e>
4037f754:	d611b1        	l32r	a11, 40374f98 <_iram_text_start+0xb94>
4037f757:	aaba      	add.n	a10, a10, a11
4037f759:	9392a0        	movnez	a9, a2, a10
4037f75c:	998c      	beqz.n	a9, 4037f769 <spi_flash_chip_mxic_detect_size+0x29>
    *size = 0;
4037f75e:	020c      	movi.n	a2, 0
4037f760:	0329      	s32i.n	a2, a3, 0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4037f762:	d45e21        	l32r	a2, 403748dc <_iram_text_start+0x4d8>
        mem_density -= 0x20;
    }

    *size = 1 << mem_density;
    return ESP_OK;
}
4037f765:	f01d      	retw.n
4037f767:	00          	.byte 00
4037f768:	00          	.byte 00
    uint32_t mem_density = (id & 0xFF);
4037f769:	748080        	extui	a8, a8, 0, 8
    if (mem_density > 0x30) { // For OPI chips
4037f76c:	023c      	movi.n	a2, 48
4037f76e:	02b287        	bgeu	a2, a8, 4037f774 <spi_flash_chip_mxic_detect_size+0x34>
        mem_density -= 0x20;
4037f771:	e0c882        	addi	a8, a8, -32
    *size = 1 << mem_density;
4037f774:	190c      	movi.n	a9, 1
4037f776:	401800        	ssl	a8
4037f779:	a18900        	sll	a8, a9
4037f77c:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
4037f77e:	020c      	movi.n	a2, 0
4037f780:	fff846        	j	4037f765 <spi_flash_chip_mxic_detect_size+0x25>
	...

4037f784 <spi_flash_chip_mxic_probe>:
{
4037f784:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
4037f787:	f53030        	extui	a3, a3, 16, 16
4037f78a:	c2a092        	movi	a9, 194
        return ESP_ERR_NOT_FOUND;
4037f78d:	05a182        	movi	a8, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037f790:	089397        	bne	a3, a9, 4037f79c <spi_flash_chip_mxic_probe+0x18>
    if (chip->read_mode >= SPI_FLASH_OPI_FLAG) {
4037f793:	4298      	l32i.n	a9, a2, 16
4037f795:	fa0c      	movi.n	a10, 15
4037f797:	013a97        	bltu	a10, a9, 4037f79c <spi_flash_chip_mxic_probe+0x18>
    return ESP_OK;
4037f79a:	080c      	movi.n	a8, 0
}
4037f79c:	082d      	mov.n	a2, a8
4037f79e:	f01d      	retw.n

4037f7a0 <spi_flash_chip_mxic_get_caps>:
#define spi_flash_chip_mxic_read_reg        spi_flash_chip_generic_read_reg

static const char chip_name[] = "mxic";

spi_flash_caps_t spi_flash_chip_mxic_get_caps(esp_flash_t *chip)
{
4037f7a0:	004136        	entry	a1, 32
    spi_flash_caps_t caps_flags = 0;
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // reading unique id is not supported.
    return caps_flags;
}
4037f7a3:	020c      	movi.n	a2, 0
4037f7a5:	f01d      	retw.n
	...

4037f7a8 <spi_flash_chip_mxic_opi_detect_size>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_mxic_opi_detect_size(esp_flash_t *chip, uint32_t *size)
{
4037f7a8:	004136        	entry	a1, 32
    uint32_t id = chip->chip_id;
4037f7ab:	62b8      	l32i.n	a11, a2, 24
    *size = 0;

    /* Can't detect size unless the high byte of the product ID matches the same convention, which is usually 0x40 or
     * 0xC0 or similar. */
    if (((id & 0xFFFF) == 0x0000) || ((id & 0xFFFF) == 0xFFFF)) {
4037f7ad:	180c      	movi.n	a8, 1
4037f7af:	f490b0        	extui	a9, a11, 0, 16
4037f7b2:	0a0c      	movi.n	a10, 0
4037f7b4:	83a890        	moveqz	a10, a8, a9
4037f7b7:	7420a0        	extui	a2, a10, 0, 8
4037f7ba:	8acc      	bnez.n	a10, 4037f7c6 <spi_flash_chip_mxic_opi_detect_size+0x1e>
4037f7bc:	d5f7a1        	l32r	a10, 40374f98 <_iram_text_start+0xb94>
4037f7bf:	99aa      	add.n	a9, a9, a10
4037f7c1:	832890        	moveqz	a2, a8, a9
4037f7c4:	828c      	beqz.n	a2, 4037f7d0 <spi_flash_chip_mxic_opi_detect_size+0x28>
    *size = 0;
4037f7c6:	020c      	movi.n	a2, 0
4037f7c8:	0329      	s32i.n	a2, a3, 0
        return ESP_ERR_FLASH_UNSUPPORTED_CHIP;
4037f7ca:	d44421        	l32r	a2, 403748dc <_iram_text_start+0x4d8>
    }

    *size = 1 << ((id & 0xFF) - 0x20);
    return ESP_OK;
}
4037f7cd:	f01d      	retw.n
4037f7cf:	00          	.byte 00
    *size = 1 << ((id & 0xFF) - 0x20);
4037f7d0:	401b00        	ssl	a11
4037f7d3:	a18800        	sll	a8, a8
4037f7d6:	0389      	s32i.n	a8, a3, 0
    return ESP_OK;
4037f7d8:	fffc46        	j	4037f7cd <spi_flash_chip_mxic_opi_detect_size+0x25>
	...

4037f7dc <spi_flash_chip_mxic_opi_set_write_protect>:
    // reading unique id is not supported.
    return caps_flags;
}

esp_err_t spi_flash_chip_mxic_opi_set_write_protect(esp_flash_t *chip, bool write_protect)
{
4037f7dc:	008136        	entry	a1, 64
    esp_err_t err = ESP_OK;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f7df:	1248      	l32i.n	a4, a2, 4
4037f7e1:	02ad      	mov.n	a10, a2
4037f7e3:	1488      	l32i.n	a8, a4, 4
4037f7e5:	152442        	l32i	a4, a4, 84
4037f7e8:	08b8      	l32i.n	a11, a8, 0
{
4037f7ea:	743030        	extui	a3, a3, 0, 8
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f7ed:	0004e0        	callx8	a4
4037f7f0:	0a4d      	mov.n	a4, a10
    spi_flash_trans_t t = {};
4037f7f2:	cc1c      	movi.n	a12, 28
4037f7f4:	0b0c      	movi.n	a11, 0
4037f7f6:	01ad      	mov.n	a10, a1
4037f7f8:	d31f81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f7fb:	0008e0        	callx8	a8
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f7fe:	180c      	movi.n	a8, 1
4037f800:	090c      	movi.n	a9, 0
4037f802:	839840        	moveqz	a9, a8, a4
4037f805:	74a090        	extui	a10, a9, 0, 8
4037f808:	89cc      	bnez.n	a9, 4037f814 <spi_flash_chip_mxic_opi_set_write_protect+0x38>
4037f80a:	faae92        	movi	a9, 0xfffffefa
4037f80d:	449a      	add.n	a4, a4, a9
4037f80f:	938a40        	movnez	a8, a10, a4
4037f812:	489c      	beqz.n	a8, 4037f82a <spi_flash_chip_mxic_opi_set_write_protect+0x4e>
        if(write_protect) {
            t.command = CMD_OPI_FLASH_MXIC(CMD_WRDI);
        } else {
            t.command = CMD_OPI_FLASH_MXIC(CMD_WREN);
4037f814:	d5f241        	l32r	a4, 40374fdc <_iram_text_start+0xbd8>
        if(write_protect) {
4037f817:	138c      	beqz.n	a3, 4037f81c <spi_flash_chip_mxic_opi_set_write_protect+0x40>
            t.command = CMD_OPI_FLASH_MXIC(CMD_WRDI);
4037f819:	d5ef41        	l32r	a4, 40374fd8 <_iram_text_start+0xbd4>
        }
        err = chip->host->driver->common_command(chip->host, &t);
4037f81c:	02a8      	l32i.n	a10, a2, 0
4037f81e:	0a5142        	s16i	a4, a1, 20
4037f821:	0a48      	l32i.n	a4, a10, 0
4037f823:	01bd      	mov.n	a11, a1
4037f825:	1448      	l32i.n	a4, a4, 4
4037f827:	0004e0        	callx8	a4
    }

    bool wp_read;
    err = chip->chip_drv->get_chip_write_protect(chip, &wp_read);
4037f82a:	1248      	l32i.n	a4, a2, 4
4037f82c:	02ad      	mov.n	a10, a2
4037f82e:	a448      	l32i.n	a4, a4, 40
4037f830:	1cc1b2        	addi	a11, a1, 28
4037f833:	0004e0        	callx8	a4
4037f836:	0a2d      	mov.n	a2, a10
    if (err == ESP_OK && wp_read != write_protect) {
4037f838:	aacc      	bnez.n	a10, 4037f846 <spi_flash_chip_mxic_opi_set_write_protect+0x6a>
4037f83a:	1c0142        	l8ui	a4, a1, 28
        err = ESP_ERR_NOT_FOUND;
4037f83d:	c04430        	sub	a4, a4, a3
4037f840:	05a132        	movi	a3, 0x105
4037f843:	932340        	movnez	a2, a3, a4
    }
    return err;
}
4037f846:	f01d      	retw.n

4037f848 <spi_flash_chip_mxic_opi_erase_chip>:
    *out_write_protected = ((status & SR_WREN) == 0);
    return err;
}

esp_err_t spi_flash_chip_mxic_opi_erase_chip(esp_flash_t *chip)
{
4037f848:	008136        	entry	a1, 64
    esp_err_t err;

    err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f84b:	1238      	l32i.n	a3, a2, 4
4037f84d:	0b0c      	movi.n	a11, 0
4037f84f:	b338      	l32i.n	a3, a3, 44
4037f851:	02ad      	mov.n	a10, a2
4037f853:	0003e0        	callx8	a3
4037f856:	0a3d      	mov.n	a3, a10
    if (err == ESP_OK) {
4037f858:	eacc      	bnez.n	a10, 4037f86a <spi_flash_chip_mxic_opi_erase_chip+0x22>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f85a:	1238      	l32i.n	a3, a2, 4
4037f85c:	02ad      	mov.n	a10, a2
4037f85e:	1348      	l32i.n	a4, a3, 4
4037f860:	152332        	l32i	a3, a3, 84
4037f863:	04b8      	l32i.n	a11, a4, 0
4037f865:	0003e0        	callx8	a3
4037f868:	0a3d      	mov.n	a3, a10
    }

    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f86a:	180c      	movi.n	a8, 1
4037f86c:	090c      	movi.n	a9, 0
4037f86e:	839830        	moveqz	a9, a8, a3
4037f871:	744090        	extui	a4, a9, 0, 8
4037f874:	99cc      	bnez.n	a9, 4037f881 <spi_flash_chip_mxic_opi_erase_chip+0x39>
4037f876:	faae92        	movi	a9, 0xfffffefa
4037f879:	939a      	add.n	a9, a3, a9
4037f87b:	938490        	movnez	a8, a4, a9
4037f87e:	046816        	beqz	a8, 4037f8c8 <spi_flash_chip_mxic_opi_erase_chip+0x80>
        // Do erase chip here.
        spi_flash_trans_t t = {
4037f881:	cc1c      	movi.n	a12, 28
4037f883:	0b0c      	movi.n	a11, 0
4037f885:	01ad      	mov.n	a10, a1
4037f887:	d2fb81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f88a:	0008e0        	callx8	a8
            .command = CMD_OPI_FLASH_MXIC_CHIP_ERASE,
        };
        err = chip->host->driver->common_command(chip->host, &t);
4037f88d:	02a8      	l32i.n	a10, a2, 0
        spi_flash_trans_t t = {
4037f88f:	d5d431        	l32r	a3, 40374fe0 <_iram_text_start+0xbdc>
        err = chip->host->driver->common_command(chip->host, &t);
4037f892:	01bd      	mov.n	a11, a1
        spi_flash_trans_t t = {
4037f894:	0a5132        	s16i	a3, a1, 20
        err = chip->host->driver->common_command(chip->host, &t);
4037f897:	0a38      	l32i.n	a3, a10, 0
        chip->busy = 1;
4037f899:	140c      	movi.n	a4, 1
        err = chip->host->driver->common_command(chip->host, &t);
4037f89b:	1338      	l32i.n	a3, a3, 4
4037f89d:	0003e0        	callx8	a3
        chip->busy = 1;
4037f8a0:	7238      	l32i.n	a3, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
4037f8a2:	02ad      	mov.n	a10, a2
        chip->busy = 1;
4037f8a4:	203340        	or	a3, a3, a4
4037f8a7:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
4037f8a9:	1238      	l32i.n	a3, a2, 4
4037f8ab:	1388      	l32i.n	a8, a3, 4
4037f8ad:	152332        	l32i	a3, a3, 84
4037f8b0:	18b8      	l32i.n	a11, a8, 4
4037f8b2:	0003e0        	callx8	a3
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f8b5:	06a182        	movi	a8, 0x106
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->chip_erase_timeout);
4037f8b8:	0a3d      	mov.n	a3, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f8ba:	0a9a87        	bne	a10, a8, 4037f8c8 <spi_flash_chip_mxic_opi_erase_chip+0x80>
        chip->chip_drv->set_chip_write_protect(chip, true);
4037f8bd:	1288      	l32i.n	a8, a2, 4
4037f8bf:	04bd      	mov.n	a11, a4
4037f8c1:	b888      	l32i.n	a8, a8, 44
4037f8c3:	02ad      	mov.n	a10, a2
4037f8c5:	0008e0        	callx8	a8
    }

    return err;

}
4037f8c8:	032d      	mov.n	a2, a3
4037f8ca:	f01d      	retw.n

4037f8cc <spi_flash_chip_mxic_opi_erase_sector>:

esp_err_t spi_flash_chip_mxic_opi_erase_sector(esp_flash_t *chip, uint32_t start_address)
{
4037f8cc:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f8cf:	1248      	l32i.n	a4, a2, 4
4037f8d1:	0b0c      	movi.n	a11, 0
4037f8d3:	b448      	l32i.n	a4, a4, 44
4037f8d5:	02ad      	mov.n	a10, a2
4037f8d7:	0004e0        	callx8	a4
    if (err == ESP_OK) {
4037f8da:	cacc      	bnez.n	a10, 4037f8ea <spi_flash_chip_mxic_opi_erase_sector+0x1e>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f8dc:	1248      	l32i.n	a4, a2, 4
4037f8de:	02ad      	mov.n	a10, a2
4037f8e0:	1488      	l32i.n	a8, a4, 4
4037f8e2:	152442        	l32i	a4, a4, 84
4037f8e5:	08b8      	l32i.n	a11, a8, 0
4037f8e7:	0004e0        	callx8	a4
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f8ea:	180c      	movi.n	a8, 1
4037f8ec:	090c      	movi.n	a9, 0
4037f8ee:	8398a0        	moveqz	a9, a8, a10
4037f8f1:	744090        	extui	a4, a9, 0, 8
4037f8f4:	a9cc      	bnez.n	a9, 4037f902 <spi_flash_chip_mxic_opi_erase_sector+0x36>
4037f8f6:	faae92        	movi	a9, 0xfffffefa
4037f8f9:	809a90        	add	a9, a10, a9
4037f8fc:	938490        	movnez	a8, a4, a9
4037f8ff:	04e816        	beqz	a8, 4037f951 <spi_flash_chip_mxic_opi_erase_sector+0x85>
        spi_flash_trans_t t = {
4037f902:	cc1c      	movi.n	a12, 28
4037f904:	0b0c      	movi.n	a11, 0
4037f906:	01ad      	mov.n	a10, a1
4037f908:	d2db81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f90b:	0008e0        	callx8	a8
            .command = CMD_OPI_FLASH_MXIC(CMD_SECTOR_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
4037f90e:	02a8      	l32i.n	a10, a2, 0
        spi_flash_trans_t t = {
4037f910:	042c      	movi.n	a4, 32
4037f912:	1139      	s32i.n	a3, a1, 4
4037f914:	d5b431        	l32r	a3, 40374fe4 <_iram_text_start+0xbe0>
4037f917:	034142        	s8i	a4, a1, 3
4037f91a:	0a5132        	s16i	a3, a1, 20
        err = chip->host->driver->common_command(chip->host, &t);
4037f91d:	0a38      	l32i.n	a3, a10, 0
4037f91f:	01bd      	mov.n	a11, a1
4037f921:	012332        	l32i	a3, a3, 4
        chip->busy = 1;
4037f924:	01a042        	movi	a4, 1
        err = chip->host->driver->common_command(chip->host, &t);
4037f927:	0003e0        	callx8	a3
        chip->busy = 1;
4037f92a:	7238      	l32i.n	a3, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4037f92c:	02ad      	mov.n	a10, a2
        chip->busy = 1;
4037f92e:	203340        	or	a3, a3, a4
4037f931:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4037f933:	1238      	l32i.n	a3, a2, 4
4037f935:	1388      	l32i.n	a8, a3, 4
4037f937:	152332        	l32i	a3, a3, 84
4037f93a:	0328b2        	l32i	a11, a8, 12
4037f93d:	0003e0        	callx8	a3
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f940:	06a132        	movi	a3, 0x106
4037f943:	0a9a37        	bne	a10, a3, 4037f951 <spi_flash_chip_mxic_opi_erase_sector+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f946:	1238      	l32i.n	a3, a2, 4
4037f948:	04bd      	mov.n	a11, a4
4037f94a:	b338      	l32i.n	a3, a3, 44
4037f94c:	02ad      	mov.n	a10, a2
4037f94e:	0003e0        	callx8	a3
    }

    return err;
}
4037f951:	0a2d      	mov.n	a2, a10
4037f953:	f01d      	retw.n
4037f955:	000000        	ill

4037f958 <spi_flash_chip_mxic_opi_erase_block>:

esp_err_t spi_flash_chip_mxic_opi_erase_block(esp_flash_t *chip, uint32_t start_address)
{
4037f958:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037f95b:	1248      	l32i.n	a4, a2, 4
4037f95d:	0b0c      	movi.n	a11, 0
4037f95f:	b448      	l32i.n	a4, a4, 44
4037f961:	02ad      	mov.n	a10, a2
4037f963:	0004e0        	callx8	a4
    if (err == ESP_OK) {
4037f966:	cacc      	bnez.n	a10, 4037f976 <spi_flash_chip_mxic_opi_erase_block+0x1e>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f968:	1248      	l32i.n	a4, a2, 4
4037f96a:	02ad      	mov.n	a10, a2
4037f96c:	1488      	l32i.n	a8, a4, 4
4037f96e:	152442        	l32i	a4, a4, 84
4037f971:	08b8      	l32i.n	a11, a8, 0
4037f973:	0004e0        	callx8	a4
    }
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f976:	180c      	movi.n	a8, 1
4037f978:	090c      	movi.n	a9, 0
4037f97a:	8398a0        	moveqz	a9, a8, a10
4037f97d:	744090        	extui	a4, a9, 0, 8
4037f980:	a9cc      	bnez.n	a9, 4037f98e <spi_flash_chip_mxic_opi_erase_block+0x36>
4037f982:	faae92        	movi	a9, 0xfffffefa
4037f985:	809a90        	add	a9, a10, a9
4037f988:	938490        	movnez	a8, a4, a9
4037f98b:	04e816        	beqz	a8, 4037f9dd <spi_flash_chip_mxic_opi_erase_block+0x85>
        spi_flash_trans_t t = {
4037f98e:	cc1c      	movi.n	a12, 28
4037f990:	0b0c      	movi.n	a11, 0
4037f992:	01ad      	mov.n	a10, a1
4037f994:	d2b881        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037f997:	0008e0        	callx8	a8
            .command = CMD_OPI_FLASH_MXIC(CMD_LARGE_BLOCK_ERASE_4B),
            .address_bitlen = 32,
            .address = start_address,
        };
        err = chip->host->driver->common_command(chip->host, &t);
4037f99a:	02a8      	l32i.n	a10, a2, 0
        spi_flash_trans_t t = {
4037f99c:	042c      	movi.n	a4, 32
4037f99e:	1139      	s32i.n	a3, a1, 4
4037f9a0:	d59231        	l32r	a3, 40374fe8 <_iram_text_start+0xbe4>
4037f9a3:	034142        	s8i	a4, a1, 3
4037f9a6:	0a5132        	s16i	a3, a1, 20
        err = chip->host->driver->common_command(chip->host, &t);
4037f9a9:	0a38      	l32i.n	a3, a10, 0
4037f9ab:	01bd      	mov.n	a11, a1
4037f9ad:	012332        	l32i	a3, a3, 4
        chip->busy = 1;
4037f9b0:	01a042        	movi	a4, 1
        err = chip->host->driver->common_command(chip->host, &t);
4037f9b3:	0003e0        	callx8	a3
        chip->busy = 1;
4037f9b6:	7238      	l32i.n	a3, a2, 28
#ifdef CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED
        err = chip->chip_drv->wait_idle(chip, ESP_FLASH_CHIP_GENERIC_NO_TIMEOUT);
#else
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4037f9b8:	02ad      	mov.n	a10, a2
        chip->busy = 1;
4037f9ba:	203340        	or	a3, a3, a4
4037f9bd:	7239      	s32i.n	a3, a2, 28
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4037f9bf:	1238      	l32i.n	a3, a2, 4
4037f9c1:	1388      	l32i.n	a8, a3, 4
4037f9c3:	152332        	l32i	a3, a3, 84
4037f9c6:	0228b2        	l32i	a11, a8, 8
4037f9c9:	0003e0        	callx8	a3
#endif
    }
    // Ensure WEL is 0, even if the erase failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037f9cc:	06a132        	movi	a3, 0x106
4037f9cf:	0a9a37        	bne	a10, a3, 4037f9dd <spi_flash_chip_mxic_opi_erase_block+0x85>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037f9d2:	1238      	l32i.n	a3, a2, 4
4037f9d4:	04bd      	mov.n	a11, a4
4037f9d6:	b338      	l32i.n	a3, a3, 44
4037f9d8:	02ad      	mov.n	a10, a2
4037f9da:	0003e0        	callx8	a3
    }

    return err;
}
4037f9dd:	0a2d      	mov.n	a2, a10
4037f9df:	f01d      	retw.n
4037f9e1:	000000        	ill

4037f9e4 <spi_flash_chip_mxic_opi_page_program>:

esp_err_t spi_flash_chip_mxic_opi_page_program(esp_flash_t *chip, const void *buffer, uint32_t address, uint32_t length)
{
4037f9e4:	008136        	entry	a1, 64
    esp_err_t err;

    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037f9e7:	1288      	l32i.n	a8, a2, 4
4037f9e9:	02ad      	mov.n	a10, a2
4037f9eb:	1898      	l32i.n	a9, a8, 4
4037f9ed:	152882        	l32i	a8, a8, 84
4037f9f0:	09b8      	l32i.n	a11, a9, 0
4037f9f2:	0008e0        	callx8	a8
    //The chip didn't accept the previous write command. Ignore this in preparationstage.
    if (err == ESP_OK || err == ESP_ERR_NOT_SUPPORTED) {
4037f9f5:	180c      	movi.n	a8, 1
4037f9f7:	090c      	movi.n	a9, 0
4037f9f9:	8398a0        	moveqz	a9, a8, a10
4037f9fc:	74b090        	extui	a11, a9, 0, 8
4037f9ff:	99cc      	bnez.n	a9, 4037fa0c <spi_flash_chip_mxic_opi_page_program+0x28>
4037fa01:	faae92        	movi	a9, 0xfffffefa
4037fa04:	9a9a      	add.n	a9, a10, a9
4037fa06:	938b90        	movnez	a8, a11, a9
4037fa09:	050816        	beqz	a8, 4037fa5d <spi_flash_chip_mxic_opi_page_program+0x79>
        // Perform the actual Page Program command
        spi_flash_trans_t t = {
4037fa0c:	cc1c      	movi.n	a12, 28
4037fa0e:	0b0c      	movi.n	a11, 0
4037fa10:	01ad      	mov.n	a10, a1
4037fa12:	d29881        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fa15:	0008e0        	callx8	a8
            .address_bitlen = 32,
            .address = address,
            .mosi_len = length,
            .mosi_data = buffer,
        };
        chip->host->driver->common_command(chip->host, &t);
4037fa18:	02a8      	l32i.n	a10, a2, 0
        spi_flash_trans_t t = {
4037fa1a:	014152        	s8i	a5, a1, 1
4037fa1d:	2139      	s32i.n	a3, a1, 8
4037fa1f:	052c      	movi.n	a5, 32
4037fa21:	d57231        	l32r	a3, 40374fec <_iram_text_start+0xbe8>
4037fa24:	034152        	s8i	a5, a1, 3
4037fa27:	0a5132        	s16i	a3, a1, 20
        chip->host->driver->common_command(chip->host, &t);
4037fa2a:	0a38      	l32i.n	a3, a10, 0
        spi_flash_trans_t t = {
4037fa2c:	1149      	s32i.n	a4, a1, 4
        chip->host->driver->common_command(chip->host, &t);
4037fa2e:	1338      	l32i.n	a3, a3, 4
4037fa30:	01bd      	mov.n	a11, a1
4037fa32:	0003e0        	callx8	a3
        chip->busy = 1;
4037fa35:	7238      	l32i.n	a3, a2, 28
4037fa37:	140c      	movi.n	a4, 1
4037fa39:	203340        	or	a3, a3, a4
4037fa3c:	7239      	s32i.n	a3, a2, 28

        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
4037fa3e:	1238      	l32i.n	a3, a2, 4
4037fa40:	02ad      	mov.n	a10, a2
4037fa42:	1358      	l32i.n	a5, a3, 4
4037fa44:	152332        	l32i	a3, a3, 84
4037fa47:	45b8      	l32i.n	a11, a5, 16
4037fa49:	0003e0        	callx8	a3
    }
    // Ensure WEL is 0, even if the page program failed.
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037fa4c:	06a132        	movi	a3, 0x106
4037fa4f:	0a9a37        	bne	a10, a3, 4037fa5d <spi_flash_chip_mxic_opi_page_program+0x79>
        err = chip->chip_drv->set_chip_write_protect(chip, true);
4037fa52:	1238      	l32i.n	a3, a2, 4
4037fa54:	04bd      	mov.n	a11, a4
4037fa56:	b338      	l32i.n	a3, a3, 44
4037fa58:	02ad      	mov.n	a10, a2
4037fa5a:	0003e0        	callx8	a3
    }
    return err;
}
4037fa5d:	0a2d      	mov.n	a2, a10
4037fa5f:	f01d      	retw.n
4037fa61:	000000        	ill

4037fa64 <spi_flash_chip_xmic_opi_config_host_io_mode>:
}

// This function should only be called after opi mode initialization. So, only configure for OPI-STR/OPI-DTR mode
// not support other mode in this file, return `ESP_ERR_FLASH_NOT_INITIALISED` directely.
esp_err_t spi_flash_chip_xmic_opi_config_host_io_mode(esp_flash_t *chip, uint32_t flags)
{
4037fa64:	004136        	entry	a1, 32
    uint32_t dummy_cyclelen_base;
    uint32_t addr_bitlen;
    uint32_t read_command;
    esp_flash_io_mode_t read_mode = chip->read_mode;
4037fa67:	42e8      	l32i.n	a14, a2, 16

    switch (read_mode & 0xFFFF) {
4037fa69:	f480e0        	extui	a8, a14, 0, 16
4037fa6c:	10b826        	beqi	a8, 16, 4037fa80 <spi_flash_chip_xmic_opi_config_host_io_mode+0x1c>
4037fa6f:	191c      	movi.n	a9, 17
4037fa71:	d399a1        	l32r	a10, 403748d8 <_iram_text_start+0x4d4>
        read_command = CMD_OPI_FLASH_MXIC_READ_STR;
        break;
    case SPI_FLASH_OPI_DTR:
        addr_bitlen = SPI_FLASH_OPIDTR_ADDR_BITLEN;
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
        read_command = CMD_OPI_FLASH_MXIC_READ_DTR;
4037fa74:	d55fb1        	l32r	a11, 40374ff0 <_iram_text_start+0xbec>
        dummy_cyclelen_base = SPI_FLASH_OPIDTR_DUMMY_BITLEN;
4037fa77:	8d2c      	movi.n	a13, 40
    switch (read_mode & 0xFFFF) {
4037fa79:	0c1897        	beq	a8, a9, 4037fa89 <spi_flash_chip_xmic_opi_config_host_io_mode+0x25>
    default:
        return ESP_ERR_FLASH_NOT_INITIALISED;
    }

    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
}
4037fa7c:	0a2d      	mov.n	a2, a10
4037fa7e:	f01d      	retw.n
    switch (read_mode & 0xFFFF) {
4037fa80:	fba4b2        	movi	a11, 0x4fb
4037fa83:	11bbe0        	slli	a11, a11, 2
4037fa86:	14a0d2        	movi	a13, 20
    return chip->host->driver->configure_host_io_mode(chip->host, read_command, addr_bitlen, dummy_cyclelen_base, read_mode);
4037fa89:	02a8      	l32i.n	a10, a2, 0
4037fa8b:	0c2c      	movi.n	a12, 32
4037fa8d:	0a28      	l32i.n	a2, a10, 0
4037fa8f:	f228      	l32i.n	a2, a2, 60
4037fa91:	0002e0        	callx8	a2
4037fa94:	fff906        	j	4037fa7c <spi_flash_chip_xmic_opi_config_host_io_mode+0x18>
	...

4037fa98 <spi_flash_chip_mxic_opi_write>:
{
4037fa98:	010136        	entry	a1, 128
4037fa9b:	027d      	mov.n	a7, a2
    const uint32_t page_size = chip->chip_drv->page_size;
4037fa9d:	1228      	l32i.n	a2, a2, 4
    esp_err_t err = ESP_OK;
4037fa9f:	0a0c      	movi.n	a10, 0
    const uint32_t page_size = chip->chip_drv->page_size;
4037faa1:	132222        	l32i	a2, a2, 76
4037faa4:	146122        	s32i	a2, a1, 80
    while (err == ESP_OK && length > 0) {
4037faa7:	090c      	movi.n	a9, 0
4037faa9:	01a022        	movi	a2, 1
4037faac:	832950        	moveqz	a2, a9, a5
4037faaf:	742020        	extui	a2, a2, 0, 8
4037fab2:	029a97        	bne	a10, a9, 4037fab8 <spi_flash_chip_mxic_opi_write+0x20>
4037fab5:	049297        	bne	a2, a9, 4037fabd <spi_flash_chip_mxic_opi_write+0x25>
}
4037fab8:	0a2d      	mov.n	a2, a10
4037faba:	f01d      	retw.n
4037fabc:	00          	.byte 00
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4037fabd:	0c4c      	movi.n	a12, 64
4037fabf:	ffa0b2        	movi	a11, 255
4037fac2:	01ad      	mov.n	a10, a1
4037fac4:	166192        	s32i	a9, a1, 88
4037fac7:	d26b81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037faca:	0008e0        	callx8	a8
        uint32_t page_len = chip->host->driver->write_data_slicer(chip->host, address, length, &align_address, page_size);
4037facd:	07a8      	l32i.n	a10, a7, 0
4037facf:	1421e2        	l32i	a14, a1, 80
4037fad2:	0a28      	l32i.n	a2, a10, 0
4037fad4:	40c1d2        	addi	a13, a1, 64
4037fad7:	a228      	l32i.n	a2, a2, 40
4037fad9:	05cd      	mov.n	a12, a5
4037fadb:	20b440        	or	a11, a4, a4
4037fade:	0002e0        	callx8	a2
4037fae1:	0add      	mov.n	a13, a10
        uint32_t left_off = address - align_address;
4037fae3:	1021a2        	l32i	a10, a1, 64
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
4037fae6:	245a      	add.n	a2, a4, a5
4037fae8:	6ada      	add.n	a6, a10, a13
4037faea:	632260        	minu	a2, a2, a6
4037faed:	c06240        	sub	a6, a2, a4
        uint32_t left_off = address - align_address;
4037faf0:	c0a4a0        	sub	a10, a4, a10
        memcpy(temp_buffer + left_off, buffer, write_len);
4037faf3:	06cd      	mov.n	a12, a6
4037faf5:	03bd      	mov.n	a11, a3
4037faf7:	a1aa      	add.n	a10, a1, a10
4037faf9:	1561d2        	s32i	a13, a1, 84
4037fafc:	d26d81        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037faff:	0008e0        	callx8	a8
        err = chip->chip_drv->set_chip_write_protect(chip, false);
4037fb02:	17a8      	l32i.n	a10, a7, 4
4037fb04:	162192        	l32i	a9, a1, 88
4037fb07:	bac8      	l32i.n	a12, a10, 44
4037fb09:	09bd      	mov.n	a11, a9
4037fb0b:	07ad      	mov.n	a10, a7
4037fb0d:	000ce0        	callx8	a12
        if (err == ESP_OK && length > 0) {
4037fb10:	1521d2        	l32i	a13, a1, 84
4037fb13:	fa1a56        	bnez	a10, 4037fab8 <spi_flash_chip_mxic_opi_write+0x20>
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037fb16:	1798      	l32i.n	a9, a7, 4
4037fb18:	1021c2        	l32i	a12, a1, 64
4037fb1b:	122992        	l32i	a9, a9, 72
            length -= write_len;
4037fb1e:	c04420        	sub	a4, a4, a2
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037fb21:	01bd      	mov.n	a11, a1
4037fb23:	07ad      	mov.n	a10, a7
            length -= write_len;
4037fb25:	554a      	add.n	a5, a5, a4
            err = chip->chip_drv->program_page(chip, temp_buffer, align_address, page_len);
4037fb27:	0009e0        	callx8	a9
            buffer = (void *)((intptr_t)buffer + write_len);
4037fb2a:	336a      	add.n	a3, a3, a6
        uint32_t write_len = MIN(align_address + page_len, address + length) - address;
4037fb2c:	024d      	mov.n	a4, a2
4037fb2e:	ffdd46        	j	4037faa7 <spi_flash_chip_mxic_opi_write+0xf>
4037fb31:	000000        	ill

4037fb34 <spi_flash_chip_mxic_opi_get_data_length_zoom>:
{
4037fb34:	004136        	entry	a1, 32
    assert((io_mode == SPI_FLASH_OPI_STR) || (io_mode == SPI_FLASH_OPI_DTR));
4037fb37:	f0c222        	addi	a2, a2, -16
4037fb3a:	0e22b6        	bltui	a2, 2, 4037fb4c <spi_flash_chip_mxic_opi_get_data_length_zoom+0x18>
4037fb3d:	d52dd1        	l32r	a13, 40374ff4 <_iram_text_start+0xbf0>
4037fb40:	d52ec1        	l32r	a12, 40374ff8 <_iram_text_start+0xbf4>
4037fb43:	d52ea1        	l32r	a10, 40374ffc <_iram_text_start+0xbf8>
4037fb46:	5da0b2        	movi	a11, 93
4037fb49:	fecc25        	call8	4037e80c <__assert_func>
    *length_zoom = (io_mode == SPI_FLASH_OPI_STR) ? 1 : 2;
4037fb4c:	01a082        	movi	a8, 1
4037fb4f:	02a092        	movi	a9, 2
4037fb52:	938920        	movnez	a8, a9, a2
4037fb55:	0389      	s32i.n	a8, a3, 0
}
4037fb57:	f01d      	retw.n
4037fb59:	000000        	ill

4037fb5c <spi_flash_chip_mxic_opi_read_id>:
{
4037fb5c:	00a136        	entry	a1, 80
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fb5f:	42a8      	l32i.n	a10, a2, 16
    uint64_t id_buf = 0;
4037fb61:	080c      	movi.n	a8, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fb63:	28c1b2        	addi	a11, a1, 40
    uint64_t id_buf = 0;
4037fb66:	8189      	s32i.n	a8, a1, 32
4037fb68:	9189      	s32i.n	a8, a1, 36
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fb6a:	fffca5        	call8	4037fb34 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
4037fb6d:	cc1c      	movi.n	a12, 28
4037fb6f:	0b0c      	movi.n	a11, 0
4037fb71:	01ad      	mov.n	a10, a1
4037fb73:	d24081        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fb76:	0008e0        	callx8	a8
4037fb79:	280182        	l8ui	a8, a1, 40
    chip->host->driver->common_command(chip->host, &t);
4037fb7c:	02a8      	l32i.n	a10, a2, 0
    spi_flash_trans_t t = {
4037fb7e:	909880        	addx2	a9, a8, a8
4037fb81:	024192        	s8i	a9, a1, 2
4037fb84:	1188e0        	slli	a8, a8, 2
4037fb87:	092c      	movi.n	a9, 32
4037fb89:	034192        	s8i	a9, a1, 3
4037fb8c:	164182        	s8i	a8, a1, 22
    chip->host->driver->common_command(chip->host, &t);
4037fb8f:	0a88      	l32i.n	a8, a10, 0
    spi_flash_trans_t t = {
4037fb91:	d51b41        	l32r	a4, 40375000 <_iram_text_start+0xbfc>
    chip->host->driver->common_command(chip->host, &t);
4037fb94:	1888      	l32i.n	a8, a8, 4
    spi_flash_trans_t t = {
4037fb96:	20c192        	addi	a9, a1, 32
4037fb99:	3199      	s32i.n	a9, a1, 12
4037fb9b:	0a5142        	s16i	a4, a1, 20
    chip->host->driver->common_command(chip->host, &t);
4037fb9e:	01bd      	mov.n	a11, a1
4037fba0:	0008e0        	callx8	a8
    if(chip->read_mode == SPI_FLASH_OPI_DTR) {
4037fba3:	4228      	l32i.n	a2, a2, 16
4037fba5:	181c      	movi.n	a8, 17
4037fba7:	339287        	bne	a2, a8, 4037fbde <spi_flash_chip_mxic_opi_read_id+0x82>
        id_buf = (id_buf & 0xff) | ((id_buf & 0xff0000) >> 8) | ((id_buf & 0xff00000000) >> 16);
4037fbaa:	8128      	l32i.n	a2, a1, 32
4037fbac:	9198      	l32i.n	a9, a1, 36
4037fbae:	418820        	srli	a8, a2, 8
4037fbb1:	01a980        	slli	a10, a9, 24
4037fbb4:	208a80        	or	a8, a10, a8
4037fbb7:	ffa0a2        	movi	a10, 255
4037fbba:	11aa80        	slli	a10, a10, 8
4037fbbd:	1088a0        	and	a8, a8, a10
4037fbc0:	11a900        	slli	a10, a9, 16
4037fbc3:	f59020        	extui	a9, a2, 16, 16
4037fbc6:	209a90        	or	a9, a10, a9
4037fbc9:	ffa0a2        	movi	a10, 255
4037fbcc:	11aa00        	slli	a10, a10, 16
4037fbcf:	1099a0        	and	a9, a9, a10
4037fbd2:	208890        	or	a8, a8, a9
4037fbd5:	742020        	extui	a2, a2, 0, 8
4037fbd8:	208820        	or	a8, a8, a2
4037fbdb:	086182        	s32i	a8, a1, 32
    uint32_t raw_flash_id = __builtin_bswap32(id_buf);
4037fbde:	81a8      	l32i.n	a10, a1, 32
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
4037fbe0:	120c      	movi.n	a2, 1
    uint32_t raw_flash_id = __builtin_bswap32(id_buf);
4037fbe2:	d50881        	l32r	a8, 40375004 <_iram_text_start+0xc00>
4037fbe5:	0008e0        	callx8	a8
    if (raw_flash_id == 0xFFFFFF || raw_flash_id == 0) {
4037fbe8:	d4e291        	l32r	a9, 40374f70 <_iram_text_start+0xb6c>
4037fbeb:	080c      	movi.n	a8, 0
4037fbed:	9a9a      	add.n	a9, a10, a9
4037fbef:	838290        	moveqz	a8, a2, a9
4037fbf2:	749080        	extui	a9, a8, 0, 8
4037fbf5:	b8cc      	bnez.n	a8, 4037fc04 <spi_flash_chip_mxic_opi_read_id+0xa8>
4037fbf7:	9329a0        	movnez	a2, a9, a10
4037fbfa:	62cc      	bnez.n	a2, 4037fc04 <spi_flash_chip_mxic_opi_read_id+0xa8>
    *out_chip_id = (raw_flash_id >> 8);
4037fbfc:	41a8a0        	srli	a10, a10, 8
4037fbff:	03a9      	s32i.n	a10, a3, 0
}
4037fc01:	f01d      	retw.n
4037fc03:	00          	.byte 00
        return ESP_ERR_FLASH_NO_RESPONSE;
4037fc04:	08a122        	movi	a2, 0x108
4037fc07:	fffd86        	j	4037fc01 <spi_flash_chip_mxic_opi_read_id+0xa5>
	...

4037fc0c <spi_flash_chip_mxic_opi_read_reg>:
{
4037fc0c:	00a136        	entry	a1, 80
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc0f:	42a8      	l32i.n	a10, a2, 16
    uint32_t stat_buf = 0;
4037fc11:	030c      	movi.n	a3, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc13:	1cc1b2        	addi	a11, a1, 28
    uint32_t stat_buf = 0;
4037fc16:	8139      	s32i.n	a3, a1, 32
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc18:	fff1a5        	call8	4037fb34 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
4037fc1b:	03bd      	mov.n	a11, a3
4037fc1d:	cc1c      	movi.n	a12, 28
4037fc1f:	20a110        	or	a10, a1, a1
4037fc22:	d21481        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fc25:	0008e0        	callx8	a8
4037fc28:	1c0182        	l8ui	a8, a1, 28
4037fc2b:	032c      	movi.n	a3, 32
4037fc2d:	024182        	s8i	a8, a1, 2
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc30:	02a8      	l32i.n	a10, a2, 0
    spi_flash_trans_t t = {
4037fc32:	1188e0        	slli	a8, a8, 2
4037fc35:	034132        	s8i	a3, a1, 3
4037fc38:	164182        	s8i	a8, a1, 22
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc3b:	0a28      	l32i.n	a2, a10, 0
    spi_flash_trans_t t = {
4037fc3d:	20c132        	addi	a3, a1, 32
4037fc40:	3139      	s32i.n	a3, a1, 12
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc42:	012222        	l32i	a2, a2, 4
    spi_flash_trans_t t = {
4037fc45:	05aa32        	movi	a3, 0xfffffa05
4037fc48:	0a5132        	s16i	a3, a1, 20
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc4b:	20b110        	or	a11, a1, a1
4037fc4e:	0002e0        	callx8	a2
    if (err != ESP_OK) {
4037fc51:	3acc      	bnez.n	a10, 4037fc58 <spi_flash_chip_mxic_opi_read_reg+0x4c>
    *out_reg = (stat_buf & 0xff);
4037fc53:	200122        	l8ui	a2, a1, 32
4037fc56:	0429      	s32i.n	a2, a4, 0
}
4037fc58:	0a2d      	mov.n	a2, a10
4037fc5a:	f01d      	retw.n

4037fc5c <spi_flash_chip_mxic_opi_get_io_mode>:
{
4037fc5c:	00a136        	entry	a1, 80
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc5f:	42a8      	l32i.n	a10, a2, 16
    uint32_t stat_buf = 0;
4037fc61:	040c      	movi.n	a4, 0
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc63:	1cc1b2        	addi	a11, a1, 28
    uint32_t stat_buf = 0;
4037fc66:	8149      	s32i.n	a4, a1, 32
    spi_flash_chip_mxic_opi_get_data_length_zoom(chip->read_mode, &length_zoom);
4037fc68:	ffeca5        	call8	4037fb34 <spi_flash_chip_mxic_opi_get_data_length_zoom>
    spi_flash_trans_t t = {
4037fc6b:	04bd      	mov.n	a11, a4
4037fc6d:	cc1c      	movi.n	a12, 28
4037fc6f:	01ad      	mov.n	a10, a1
4037fc71:	d20081        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fc74:	0008e0        	callx8	a8
4037fc77:	1c0182        	l8ui	a8, a1, 28
4037fc7a:	042c      	movi.n	a4, 32
4037fc7c:	034142        	s8i	a4, a1, 3
4037fc7f:	20c142        	addi	a4, a1, 32
4037fc82:	024182        	s8i	a8, a1, 2
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc85:	02a8      	l32i.n	a10, a2, 0
    spi_flash_trans_t t = {
4037fc87:	3149      	s32i.n	a4, a1, 12
4037fc89:	1188e0        	slli	a8, a8, 2
4037fc8c:	d4df41        	l32r	a4, 40375008 <_iram_text_start+0xc04>
4037fc8f:	164182        	s8i	a8, a1, 22
4037fc92:	0a5142        	s16i	a4, a1, 20
    esp_err_t err = chip->host->driver->common_command(chip->host, &t);
4037fc95:	0a48      	l32i.n	a4, a10, 0
4037fc97:	01bd      	mov.n	a11, a1
4037fc99:	1448      	l32i.n	a4, a4, 4
4037fc9b:	0004e0        	callx8	a4
    if (err != ESP_OK) {
4037fc9e:	aadc      	bnez.n	a10, 4037fcbc <spi_flash_chip_mxic_opi_get_io_mode+0x60>
    switch (stat_buf & 0xff)
4037fca0:	200192        	l8ui	a9, a1, 32
4037fca3:	081c      	movi.n	a8, 16
4037fca5:	081926        	beqi	a9, 1, 4037fcb1 <spi_flash_chip_mxic_opi_get_io_mode+0x55>
4037fca8:	fec992        	addi	a9, a9, -2
4037fcab:	11a082        	movi	a8, 17
4037fcae:	938a90        	movnez	a8, a10, a9
        *out_io_mode = SPI_FLASH_OPI_STR;
4037fcb1:	0389      	s32i.n	a8, a3, 0
    if (*out_io_mode != chip->read_mode) {
4037fcb3:	4228      	l32i.n	a2, a2, 16
4037fcb5:	031287        	beq	a2, a8, 4037fcbc <spi_flash_chip_mxic_opi_get_io_mode+0x60>
        *out_io_mode = 0;
4037fcb8:	020c      	movi.n	a2, 0
4037fcba:	0329      	s32i.n	a2, a3, 0
}
4037fcbc:	0a2d      	mov.n	a2, a10
4037fcbe:	f01d      	retw.n

4037fcc0 <spi_flash_chip_mxic_opi_get_write_protect>:
{
4037fcc0:	006136        	entry	a1, 48
4037fcc3:	20a220        	or	a10, a2, a2
    assert(out_write_protected!=NULL);
4037fcc6:	00e356        	bnez	a3, 4037fcd8 <spi_flash_chip_mxic_opi_get_write_protect+0x18>
4037fcc9:	d4d0d1        	l32r	a13, 4037500c <_iram_text_start+0xc08>
4037fccc:	d4d1c1        	l32r	a12, 40375010 <_iram_text_start+0xc0c>
4037fccf:	d4cba1        	l32r	a10, 40374ffc <_iram_text_start+0xbf8>
4037fcd2:	9ea0b2        	movi	a11, 158
4037fcd5:	feb365        	call8	4037e80c <__assert_func>
    err = chip->chip_drv->read_reg(chip, SPI_FLASH_REG_STATUS, &status);
4037fcd8:	012282        	l32i	a8, a2, 4
4037fcdb:	01cd      	mov.n	a12, a1
4037fcdd:	192882        	l32i	a8, a8, 100
4037fce0:	1b0c      	movi.n	a11, 1
4037fce2:	0008e0        	callx8	a8
    if (err != ESP_OK) {
4037fce5:	bacc      	bnez.n	a10, 4037fcf4 <spi_flash_chip_mxic_opi_get_write_protect+0x34>
    *out_write_protected = ((status & SR_WREN) == 0);
4037fce7:	0188      	l32i.n	a8, a1, 0
4037fce9:	190c      	movi.n	a9, 1
4037fceb:	048180        	extui	a8, a8, 1, 1
4037fcee:	308890        	xor	a8, a8, a9
4037fcf1:	004382        	s8i	a8, a3, 0
}
4037fcf4:	0a2d      	mov.n	a2, a10
4037fcf6:	f01d      	retw.n

4037fcf8 <spi_flash_chip_mxic_opi_probe>:
{
4037fcf8:	004136        	entry	a1, 32
    if (flash_id >> 16 != MFG_ID) {
4037fcfb:	f53030        	extui	a3, a3, 16, 16
4037fcfe:	c2a092        	movi	a9, 194
        return ESP_ERR_NOT_FOUND;
4037fd01:	05a182        	movi	a8, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037fd04:	089397        	bne	a3, a9, 4037fd10 <spi_flash_chip_mxic_opi_probe+0x18>
    if (chip->read_mode < SPI_FLASH_OPI_FLAG) {
4037fd07:	4298      	l32i.n	a9, a2, 16
4037fd09:	fa0c      	movi.n	a10, 15
4037fd0b:	01ba97        	bgeu	a10, a9, 4037fd10 <spi_flash_chip_mxic_opi_probe+0x18>
    return ESP_OK;
4037fd0e:	080c      	movi.n	a8, 0
}
4037fd10:	082d      	mov.n	a2, a8
4037fd12:	f01d      	retw.n

4037fd14 <spi_flash_chip_mxic_opi_get_caps>:
{
4037fd14:	004136        	entry	a1, 32
}
4037fd17:	220c      	movi.n	a2, 2
4037fd19:	f01d      	retw.n
	...

4037fd1c <spi_flash_chip_xmic_opi_set_io_mode>:
{
4037fd1c:	004136        	entry	a1, 32
}
4037fd1f:	020c      	movi.n	a2, 0
4037fd21:	f01d      	retw.n
	...

4037fd24 <spi_flash_chip_th_probe>:
#include <stdlib.h>
#include "spi_flash_chip_generic.h"
#include "spi_flash_defs.h"

esp_err_t spi_flash_chip_th_probe(esp_flash_t *chip, uint32_t flash_id)
{
4037fd24:	004136        	entry	a1, 32
    /* Check manufacturer and product IDs match our desired masks */
    const uint8_t MFG_ID = 0xcd;
    if (flash_id >> 16 != MFG_ID) {
4037fd27:	f59030        	extui	a9, a3, 16, 16
4037fd2a:	cda082        	movi	a8, 205
    }

    const uint16_t FLASH_ID_MASK = 0xFF00;
    const uint16_t FLASH_ID_VALUE = 0x6000;
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
        return ESP_ERR_NOT_FOUND;
4037fd2d:	05a122        	movi	a2, 0x105
    if (flash_id >> 16 != MFG_ID) {
4037fd30:	109987        	bne	a9, a8, 4037fd44 <spi_flash_chip_th_probe+0x20>
    if ((flash_id & FLASH_ID_MASK) != FLASH_ID_VALUE) {
4037fd33:	ffa082        	movi	a8, 255
4037fd36:	118880        	slli	a8, a8, 8
4037fd39:	103380        	and	a3, a3, a8
    }

    return ESP_OK;
4037fd3c:	a0d332        	addmi	a3, a3, 0xffffa000
4037fd3f:	080c      	movi.n	a8, 0
4037fd41:	832830        	moveqz	a2, a8, a3
}
4037fd44:	f01d      	retw.n
	...

4037fd48 <spi_flash_chip_th_get_caps>:

spi_flash_caps_t spi_flash_chip_th_get_caps(esp_flash_t *chip)
{
4037fd48:	004136        	entry	a1, 32
    // 32-bit-address flash is not supported
    // flash-suspend is not supported
    // flash read unique id.
    caps_flags |= SPI_FLASH_CHIP_CAP_UNIQUE_ID;
    return caps_flags;
}
4037fd4b:	420c      	movi.n	a2, 4
4037fd4d:	f01d      	retw.n
	...

4037fd50 <spi_flash_chip_winbond_read>:

    return ESP_OK;
}

esp_err_t spi_flash_chip_winbond_read(esp_flash_t *chip, void *buffer, uint32_t address, uint32_t length)
{
4037fd50:	010136        	entry	a1, 128
    esp_err_t err = ESP_OK;
    const uint32_t page_size = chip->chip_drv->page_size;
4037fd53:	1268      	l32i.n	a6, a2, 4
    uint32_t align_address;
    uint8_t temp_buffer[64]; //spiflash hal max length of read no longer than 64byte
    uint32_t config_io_flags = 0;

    // Configure the host, and return
    if (REGION_32BIT(address, length)) {
4037fd55:	1b0c      	movi.n	a11, 1
4037fd57:	845a      	add.n	a8, a4, a5
4037fd59:	019b80        	slli	a9, a11, 24
    const uint32_t page_size = chip->chip_drv->page_size;
4037fd5c:	132672        	l32i	a7, a6, 76
    if (REGION_32BIT(address, length)) {
4037fd5f:	013987        	bltu	a9, a8, 4037fd64 <spi_flash_chip_winbond_read+0x14>
4037fd62:	0b0c      	movi.n	a11, 0
        config_io_flags |= SPI_FLASH_CONFIG_IO_MODE_32B_ADDR;
    }
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4037fd64:	1e2662        	l32i	a6, a6, 120
4037fd67:	02ad      	mov.n	a10, a2
4037fd69:	0006e0        	callx8	a6

    if (err == ESP_ERR_NOT_SUPPORTED) {
4037fd6c:	06a162        	movi	a6, 0x106
    err = chip->chip_drv->config_host_io_mode(chip, config_io_flags);
4037fd6f:	0a9d      	mov.n	a9, a10
    if (err == ESP_ERR_NOT_SUPPORTED) {
4037fd71:	6b9a67        	bne	a10, a6, 4037fde0 <spi_flash_chip_winbond_read+0x90>
        buffer = (void *)((intptr_t)buffer + data_len);
        length = length - data_len;
    }

    return err;
}
4037fd74:	092d      	mov.n	a2, a9
4037fd76:	f01d      	retw.n
4037fd78:	00          	.byte 00
        memset(temp_buffer, 0xFF, sizeof(temp_buffer));
4037fd79:	0c4c      	movi.n	a12, 64
4037fd7b:	ffa0b2        	movi	a11, 255
4037fd7e:	01ad      	mov.n	a10, a1
4037fd80:	d1bd81        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fd83:	0008e0        	callx8	a8
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
4037fd86:	02a8      	l32i.n	a10, a2, 0
4037fd88:	05cd      	mov.n	a12, a5
4037fd8a:	0a68      	l32i.n	a6, a10, 0
4037fd8c:	04bd      	mov.n	a11, a4
4037fd8e:	d668      	l32i.n	a6, a6, 52
4037fd90:	20e770        	or	a14, a7, a7
4037fd93:	40c1d2        	addi	a13, a1, 64
4037fd96:	0006e0        	callx8	a6
        uint32_t left_off = address - align_address;
4037fd99:	1021c2        	l32i	a12, a1, 64
        uint32_t read_len = chip->host->driver->read_data_slicer(chip->host, address, length, &align_address, page_size);
4037fd9c:	0add      	mov.n	a13, a10
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037fd9e:	6caa      	add.n	a6, a12, a10
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037fda0:	02a8      	l32i.n	a10, a2, 0
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037fda2:	854a      	add.n	a8, a5, a4
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037fda4:	0a98      	l32i.n	a9, a10, 0
        uint32_t left_off = address - align_address;
4037fda6:	c0e4c0        	sub	a14, a4, a12
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037fda9:	638860        	minu	a8, a8, a6
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037fdac:	b998      	l32i.n	a9, a9, 44
4037fdae:	01bd      	mov.n	a11, a1
4037fdb0:	156182        	s32i	a8, a1, 84
4037fdb3:	1461e2        	s32i	a14, a1, 80
        uint32_t data_len = MIN(align_address + read_len, address + length) - address;
4037fdb6:	c06840        	sub	a6, a8, a4
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037fdb9:	0009e0        	callx8	a9
        memcpy(buffer, temp_buffer + left_off, data_len);
4037fdbc:	1421e2        	l32i	a14, a1, 80
        err = chip->host->driver->read(chip->host, temp_buffer, align_address, read_len);
4037fdbf:	0a9d      	mov.n	a9, a10
        memcpy(buffer, temp_buffer + left_off, data_len);
4037fdc1:	06cd      	mov.n	a12, a6
4037fdc3:	03ad      	mov.n	a10, a3
4037fdc5:	80b1e0        	add	a11, a1, a14
4037fdc8:	146192        	s32i	a9, a1, 80
4037fdcb:	d1b981        	l32r	a8, 403744b0 <_iram_text_start+0xac>
4037fdce:	0008e0        	callx8	a8
        length = length - data_len;
4037fdd1:	152182        	l32i	a8, a1, 84
        address += data_len;
4037fdd4:	142192        	l32i	a9, a1, 80
        length = length - data_len;
4037fdd7:	c04480        	sub	a4, a4, a8
4037fdda:	554a      	add.n	a5, a5, a4
        buffer = (void *)((intptr_t)buffer + data_len);
4037fddc:	336a      	add.n	a3, a3, a6
        address += data_len;
4037fdde:	084d      	mov.n	a4, a8
    while (err == ESP_OK && length > 0) {
4037fde0:	f90956        	bnez	a9, 4037fd74 <spi_flash_chip_winbond_read+0x24>
4037fde3:	f92556        	bnez	a5, 4037fd79 <spi_flash_chip_winbond_read+0x29>
4037fde6:	ffe286        	j	4037fd74 <spi_flash_chip_winbond_read+0x24>
4037fde9:	000000        	ill

4037fdec <spi_flash_chip_winbond_erase_block>:
    }
    return err;
}

esp_err_t spi_flash_chip_winbond_erase_block(esp_flash_t *chip, uint32_t start_address)
{
4037fdec:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037fdef:	1248      	l32i.n	a4, a2, 4
4037fdf1:	00a0b2        	movi	a11, 0
4037fdf4:	0b2442        	l32i	a4, a4, 44
4037fdf7:	02ad      	mov.n	a10, a2
4037fdf9:	0004e0        	callx8	a4
    if (err == ESP_OK) {
4037fdfc:	064a56        	bnez	a10, 4037fe64 <spi_flash_chip_winbond_erase_block+0x78>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037fdff:	1248      	l32i.n	a4, a2, 4
4037fe01:	02ad      	mov.n	a10, a2
4037fe03:	1488      	l32i.n	a8, a4, 4
4037fe05:	152442        	l32i	a4, a4, 84
4037fe08:	08b8      	l32i.n	a11, a8, 0
4037fe0a:	0004e0        	callx8	a4
    }

    if (err == ESP_OK) {
4037fe0d:	053a56        	bnez	a10, 4037fe64 <spi_flash_chip_winbond_erase_block+0x78>
}

esp_err_t spi_flash_command_erase_block_4B(esp_flash_t *chip, uint32_t start_address)
{
    bool addr_4b = ADDR_32BIT(start_address);
    spi_flash_trans_t t = {
4037fe10:	0abd      	mov.n	a11, a10
4037fe12:	cc1c      	movi.n	a12, 28
4037fe14:	20a110        	or	a10, a1, a1
4037fe17:	002242        	l32i	a4, a2, 0
4037fe1a:	d19681        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fe1d:	0008e0        	callx8	a8
4037fe20:	d2a991        	l32r	a9, 403748c4 <_iram_text_start+0x4c0>
4037fe23:	20a082        	movi	a8, 32
4037fe26:	023937        	bltu	a9, a3, 4037fe2c <spi_flash_chip_winbond_erase_block+0x40>
4037fe29:	18a082        	movi	a8, 24
4037fe2c:	034182        	s8i	a8, a1, 3
4037fe2f:	1139      	s32i.n	a3, a1, 4
4037fe31:	dca082        	movi	a8, 220
4037fe34:	023937        	bltu	a9, a3, 4037fe3a <spi_flash_chip_winbond_erase_block+0x4e>
4037fe37:	d8a082        	movi	a8, 216
4037fe3a:	0a5182        	s16i	a8, a1, 20
        .command = (addr_4b? CMD_LARGE_BLOCK_ERASE_4B: CMD_LARGE_BLOCK_ERASE),
        .address_bitlen = (addr_4b? 32: 24),
        .address = start_address,
    };
    return chip->host->driver->common_command(chip->host, &t);
4037fe3d:	0488      	l32i.n	a8, a4, 0
4037fe3f:	01bd      	mov.n	a11, a1
4037fe41:	1888      	l32i.n	a8, a8, 4
4037fe43:	04ad      	mov.n	a10, a4
4037fe45:	0008e0        	callx8	a8
        if (err != ESP_OK) {
4037fe48:	8adc      	bnez.n	a10, 4037fe64 <spi_flash_chip_winbond_erase_block+0x78>
        if (chip->host->driver->flush_cache) {
4037fe4a:	02a8      	l32i.n	a10, a2, 0
4037fe4c:	0a48      	l32i.n	a4, a10, 0
4037fe4e:	112482        	l32i	a8, a4, 68
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->block_erase_size);
4037fe51:	1248      	l32i.n	a4, a2, 4
        if (chip->host->driver->flush_cache) {
4037fe53:	012856        	bnez	a8, 4037fe69 <spi_flash_chip_winbond_erase_block+0x7d>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->block_erase_timeout);
4037fe56:	1238      	l32i.n	a3, a2, 4
4037fe58:	02ad      	mov.n	a10, a2
4037fe5a:	1348      	l32i.n	a4, a3, 4
4037fe5c:	152332        	l32i	a3, a3, 84
4037fe5f:	24b8      	l32i.n	a11, a4, 8
4037fe61:	0003e0        	callx8	a3
}
4037fe64:	0a2d      	mov.n	a2, a10
4037fe66:	f01d      	retw.n
4037fe68:	00          	.byte 00
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->block_erase_size);
4037fe69:	94c8      	l32i.n	a12, a4, 36
4037fe6b:	03bd      	mov.n	a11, a3
4037fe6d:	0008e0        	callx8	a8
            if (err != ESP_OK) {
4037fe70:	fe2a16        	beqz	a10, 4037fe56 <spi_flash_chip_winbond_erase_block+0x6a>
4037fe73:	fffb46        	j	4037fe64 <spi_flash_chip_winbond_erase_block+0x78>
	...

4037fe78 <spi_flash_chip_winbond_erase_sector>:
{
4037fe78:	008136        	entry	a1, 64
    esp_err_t err = chip->chip_drv->set_chip_write_protect(chip, false);
4037fe7b:	1248      	l32i.n	a4, a2, 4
4037fe7d:	00a0b2        	movi	a11, 0
4037fe80:	0b2442        	l32i	a4, a4, 44
4037fe83:	02ad      	mov.n	a10, a2
4037fe85:	0004e0        	callx8	a4
    if (err == ESP_OK) {
4037fe88:	062a56        	bnez	a10, 4037feee <spi_flash_chip_winbond_erase_sector+0x76>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037fe8b:	1248      	l32i.n	a4, a2, 4
4037fe8d:	02ad      	mov.n	a10, a2
4037fe8f:	1488      	l32i.n	a8, a4, 4
4037fe91:	152442        	l32i	a4, a4, 84
4037fe94:	08b8      	l32i.n	a11, a8, 0
4037fe96:	0004e0        	callx8	a4
    if (err == ESP_OK) {
4037fe99:	051a56        	bnez	a10, 4037feee <spi_flash_chip_winbond_erase_sector+0x76>
    spi_flash_trans_t t = {
4037fe9c:	0abd      	mov.n	a11, a10
4037fe9e:	cc1c      	movi.n	a12, 28
4037fea0:	20a110        	or	a10, a1, a1
4037fea3:	002242        	l32i	a4, a2, 0
4037fea6:	d17381        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037fea9:	0008e0        	callx8	a8
4037feac:	d28691        	l32r	a9, 403748c4 <_iram_text_start+0x4c0>
4037feaf:	20a082        	movi	a8, 32
4037feb2:	023937        	bltu	a9, a3, 4037feb8 <spi_flash_chip_winbond_erase_sector+0x40>
4037feb5:	18a082        	movi	a8, 24
4037feb8:	034182        	s8i	a8, a1, 3
4037febb:	1139      	s32i.n	a3, a1, 4
4037febd:	182c      	movi.n	a8, 33
4037febf:	013937        	bltu	a9, a3, 4037fec4 <spi_flash_chip_winbond_erase_sector+0x4c>
4037fec2:	082c      	movi.n	a8, 32
4037fec4:	0a5182        	s16i	a8, a1, 20
    return chip->host->driver->common_command(chip->host, &t);
4037fec7:	0488      	l32i.n	a8, a4, 0
4037fec9:	01bd      	mov.n	a11, a1
4037fecb:	1888      	l32i.n	a8, a8, 4
4037fecd:	04ad      	mov.n	a10, a4
4037fecf:	0008e0        	callx8	a8
        if (err != ESP_OK) {
4037fed2:	8adc      	bnez.n	a10, 4037feee <spi_flash_chip_winbond_erase_sector+0x76>
        if (chip->host->driver->flush_cache) {
4037fed4:	02a8      	l32i.n	a10, a2, 0
4037fed6:	0a48      	l32i.n	a4, a10, 0
4037fed8:	112482        	l32i	a8, a4, 68
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->sector_size);
4037fedb:	012242        	l32i	a4, a2, 4
        if (chip->host->driver->flush_cache) {
4037fede:	08dc      	bnez.n	a8, 4037fef2 <spi_flash_chip_winbond_erase_sector+0x7a>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->sector_erase_timeout);
4037fee0:	1238      	l32i.n	a3, a2, 4
4037fee2:	02ad      	mov.n	a10, a2
4037fee4:	1348      	l32i.n	a4, a3, 4
4037fee6:	152332        	l32i	a3, a3, 84
4037fee9:	34b8      	l32i.n	a11, a4, 12
4037feeb:	0003e0        	callx8	a3
}
4037feee:	0a2d      	mov.n	a2, a10
4037fef0:	f01d      	retw.n
            err = chip->host->driver->flush_cache(chip->host, start_address, chip->chip_drv->sector_size);
4037fef2:	84c8      	l32i.n	a12, a4, 32
4037fef4:	03bd      	mov.n	a11, a3
4037fef6:	0008e0        	callx8	a8
            if (err != ESP_OK) {
4037fef9:	fe3a16        	beqz	a10, 4037fee0 <spi_flash_chip_winbond_erase_sector+0x68>
4037fefc:	fffb86        	j	4037feee <spi_flash_chip_winbond_erase_sector+0x76>
	...

4037ff00 <spi_flash_chip_winbond_page_program>:
{
4037ff00:	008136        	entry	a1, 64
    err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->idle_timeout);
4037ff03:	1268      	l32i.n	a6, a2, 4
4037ff05:	02ad      	mov.n	a10, a2
4037ff07:	1688      	l32i.n	a8, a6, 4
4037ff09:	152662        	l32i	a6, a6, 84
4037ff0c:	08b8      	l32i.n	a11, a8, 0
4037ff0e:	0006e0        	callx8	a6
    if (err == ESP_OK) {
4037ff11:	049a56        	bnez	a10, 4037ff5e <spi_flash_chip_winbond_page_program+0x5e>
    spi_flash_trans_t t = {
4037ff14:	0abd      	mov.n	a11, a10
4037ff16:	1ca0c2        	movi	a12, 28
4037ff19:	20a110        	or	a10, a1, a1
4037ff1c:	002262        	l32i	a6, a2, 0
4037ff1f:	d15581        	l32r	a8, 40374474 <_iram_text_start+0x70>
4037ff22:	0008e0        	callx8	a8
4037ff25:	d26781        	l32r	a8, 403748c4 <_iram_text_start+0x4c0>
4037ff28:	014152        	s8i	a5, a1, 1
4037ff2b:	092c      	movi.n	a9, 32
4037ff2d:	013847        	bltu	a8, a4, 4037ff32 <spi_flash_chip_winbond_page_program+0x32>
4037ff30:	891c      	movi.n	a9, 24
4037ff32:	2139      	s32i.n	a3, a1, 8
4037ff34:	034192        	s8i	a9, a1, 3
4037ff37:	1149      	s32i.n	a4, a1, 4
4037ff39:	231c      	movi.n	a3, 18
4037ff3b:	013847        	bltu	a8, a4, 4037ff40 <spi_flash_chip_winbond_page_program+0x40>
4037ff3e:	230c      	movi.n	a3, 2
4037ff40:	0a5132        	s16i	a3, a1, 20
    return chip->host->driver->common_command(chip->host, &t);
4037ff43:	0638      	l32i.n	a3, a6, 0
4037ff45:	01bd      	mov.n	a11, a1
4037ff47:	1338      	l32i.n	a3, a3, 4
4037ff49:	06ad      	mov.n	a10, a6
4037ff4b:	0003e0        	callx8	a3
        if (err != ESP_OK) {
4037ff4e:	cacc      	bnez.n	a10, 4037ff5e <spi_flash_chip_winbond_page_program+0x5e>
        err = chip->chip_drv->wait_idle(chip, chip->chip_drv->timeout->page_program_timeout);
4037ff50:	1248      	l32i.n	a4, a2, 4
4037ff52:	02ad      	mov.n	a10, a2
4037ff54:	1458      	l32i.n	a5, a4, 4
4037ff56:	152432        	l32i	a3, a4, 84
4037ff59:	45b8      	l32i.n	a11, a5, 16
4037ff5b:	0003e0        	callx8	a3
}
4037ff5e:	0a2d      	mov.n	a2, a10
4037ff60:	f01d      	retw.n
	...

4037ff64 <spi_flash_chip_winbond_probe>:
{
4037ff64:	004136        	entry	a1, 32
        return ESP_ERR_NOT_FOUND;
4037ff67:	efa022        	movi	a2, 239
    if (flash_id >> 16 != MFG_ID) {
4037ff6a:	f53030        	extui	a3, a3, 16, 16
        return ESP_ERR_NOT_FOUND;
4037ff6d:	c03320        	sub	a3, a3, a2
4037ff70:	05a182        	movi	a8, 0x105
4037ff73:	020c      	movi.n	a2, 0
4037ff75:	932830        	movnez	a2, a8, a3
}
4037ff78:	f01d      	retw.n
	...

4037ff7c <spi_flash_chip_winbond_get_caps>:
{
4037ff7c:	004136        	entry	a1, 32
    if ((chip->chip_id & 0xFF) >= 0x19) {
4037ff7f:	180282        	l8ui	a8, a2, 24
4037ff82:	891c      	movi.n	a9, 24
4037ff84:	120c      	movi.n	a2, 1
4037ff86:	023987        	bltu	a9, a8, 4037ff8c <spi_flash_chip_winbond_get_caps+0x10>
4037ff89:	00a022        	movi	a2, 0
}
4037ff8c:	480c      	movi.n	a8, 4
    if ((chip->chip_id & 0xFF) >= 0x19) {
4037ff8e:	222a      	add.n	a2, a2, a2
}
4037ff90:	202280        	or	a2, a2, a8
4037ff93:	f01d      	retw.n
4037ff95:	000000        	ill

4037ff98 <spi_flash_hpm_probe_chip_with_write_hpf_bit_5>:
 * @brief Probe the chip whether to write status register to enable HPM mode. Take ZB as an example:
 *        Write status register bits to enable HPM mode of the flash. If ZB works under 80MHz, the register value
 *        would be 0, but when works under 120MHz, the register value would be 1.
 */
static esp_err_t spi_flash_hpm_probe_chip_with_write_hpf_bit_5(uint32_t flash_id)
{
4037ff98:	004136        	entry	a1, 32
    /* The flash listed here should enter the HPM by adjusting dummy cycles */
    // ZB chips.
    case 0x5E4016:
        break;
    default:
        ret = ESP_ERR_NOT_FOUND;
4037ff9b:	d41e81        	l32r	a8, 40375014 <_iram_text_start+0xc10>
4037ff9e:	05a192        	movi	a9, 0x105
4037ffa1:	c08280        	sub	a8, a2, a8
4037ffa4:	020c      	movi.n	a2, 0
4037ffa6:	932980        	movnez	a2, a9, a8
        break;
    }
    return ret;
}
4037ffa9:	f01d      	retw.n
	...

4037ffac <spi_flash_high_performance_check_dummy_sr>:
{
4037ffac:	004136        	entry	a1, 32
    if((bootloader_read_status_8b_rdsr3() & 0x03) == 0) {
4037ffaf:	f822e5        	call8	403781dc <bootloader_read_status_8b_rdsr3>
4037ffb2:	14a0a0        	extui	a10, a10, 0, 2
4037ffb5:	00a082        	movi	a8, 0
4037ffb8:	01a022        	movi	a2, 1
4037ffbb:	9328a0        	movnez	a2, a8, a10
}
4037ffbe:	602020        	neg	a2, a2
4037ffc1:	000090        	retw

4037ffc4 <spi_flash_high_performance_check_hpf_bit_5>:
{
4037ffc4:	004136        	entry	a1, 32
    if((bootloader_read_status_8b_rdsr3() & (1 << 4)) == 0) {
4037ffc7:	f82165        	call8	403781dc <bootloader_read_status_8b_rdsr3>
4037ffca:	04a4a0        	extui	a10, a10, 4, 1
}
4037ffcd:	2a0b      	addi.n	a2, a10, -1
4037ffcf:	f01d      	retw.n
4037ffd1:	000000        	ill

4037ffd4 <spi_flash_turn_high_performance_write_hpf_bit_5>:

/**
 * @brief Write bit 5 in status 3
 */
static void spi_flash_turn_high_performance_write_hpf_bit_5(void)
{
4037ffd4:	004136        	entry	a1, 32
    uint8_t old_status_3 = bootloader_read_status_8b_rdsr3();
4037ffd7:	f82065        	call8	403781dc <bootloader_read_status_8b_rdsr3>
    uint8_t new_status = (old_status_3 | 0x10);
    bootloader_execute_flash_command(CMD_WRENVSR, 0, 0, 0);
4037ffda:	00a0d2        	movi	a13, 0
    uint8_t old_status_3 = bootloader_read_status_8b_rdsr3();
4037ffdd:	0a2d      	mov.n	a2, a10
    bootloader_execute_flash_command(CMD_WRENVSR, 0, 0, 0);
4037ffdf:	0dcd      	mov.n	a12, a13
4037ffe1:	0dbd      	mov.n	a11, a13
4037ffe3:	50a0a2        	movi	a10, 80
4037ffe6:	f74165        	call8	403773fc <bootloader_execute_flash_command>
    uint8_t new_status = (old_status_3 | 0x10);
4037ffe9:	10a082        	movi	a8, 16
4037ffec:	20a280        	or	a10, a2, a8
    bootloader_write_status_8b_wrsr3(new_status);
4037ffef:	74a0a0        	extui	a10, a10, 0, 8
4037fff2:	f82025        	call8	403781f4 <bootloader_write_status_8b_wrsr3>
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
4037fff5:	d1ff21        	l32r	a2, 403747f4 <_iram_text_start+0x3f0>
4037fff8:	02a8      	l32i.n	a10, a2, 0
4037fffa:	d40781        	l32r	a8, 40375018 <_iram_text_start+0xc14>
4037fffd:	0008e0        	callx8	a8
}
40380000:	f01d      	retw.n
	...

40380004 <spi_flash_turn_high_performance_reconfig_dummy>:
{
40380004:	004136        	entry	a1, 32
    uint8_t old_status_3 = bootloader_read_status_8b_rdsr3();
40380007:	f81d65        	call8	403781dc <bootloader_read_status_8b_rdsr3>
    bootloader_execute_flash_command(CMD_WRENVSR, 0, 0, 0);
4038000a:	00a0d2        	movi	a13, 0
    uint8_t old_status_3 = bootloader_read_status_8b_rdsr3();
4038000d:	0a2d      	mov.n	a2, a10
    bootloader_execute_flash_command(CMD_WRENVSR, 0, 0, 0);
4038000f:	0dcd      	mov.n	a12, a13
40380011:	0dbd      	mov.n	a11, a13
40380013:	50a0a2        	movi	a10, 80
40380016:	f73e65        	call8	403773fc <bootloader_execute_flash_command>
    uint8_t new_status = (old_status_3 | 0x03);
40380019:	03a082        	movi	a8, 3
4038001c:	20a280        	or	a10, a2, a8
    bootloader_write_status_8b_wrsr3(new_status);
4038001f:	74a0a0        	extui	a10, a10, 0, 8
40380022:	f81d25        	call8	403781f4 <bootloader_write_status_8b_wrsr3>
    esp_rom_spiflash_wait_idle(&g_rom_flashchip);
40380025:	d1f321        	l32r	a2, 403747f4 <_iram_text_start+0x3f0>
40380028:	02a8      	l32i.n	a10, a2, 0
4038002a:	d3fb81        	l32r	a8, 40375018 <_iram_text_start+0xc14>
4038002d:	0008e0        	callx8	a8
}
40380030:	f01d      	retw.n
	...

40380034 <spi_flash_enable_high_performance_send_cmd>:
{
40380034:	006136        	entry	a1, 48
    bootloader_flash_execute_command_common(CMD_HPMEN, 0, 0, dummy, 0, 0, 0);
40380037:	00a0b2        	movi	a11, 0
4038003a:	0061b2        	s32i	a11, a1, 0
4038003d:	20fbb0        	or	a15, a11, a11
40380040:	0bed      	mov.n	a14, a11
40380042:	8d1c      	movi.n	a13, 24
40380044:	0bcd      	mov.n	a12, a11
40380046:	a3a0a2        	movi	a10, 163
40380049:	f71ee5        	call8	40377238 <bootloader_flash_execute_command_common>
    esp_rom_delay_us(20);
4038004c:	4a1c      	movi.n	a10, 20
4038004e:	d0fc81        	l32r	a8, 40374440 <_iram_text_start+0x3c>
40380051:	0008e0        	callx8	a8
}
40380054:	f01d      	retw.n
	...

40380058 <spi_flash_hpm_probe_chip_with_cmd>:
{
40380058:	004136        	entry	a1, 32
    switch (flash_id) {
4038005b:	d3f081        	l32r	a8, 4037501c <_iram_text_start+0xc18>
4038005e:	802280        	add	a2, a2, a8
40380061:	0d22f6        	bgeui	a2, 2, 40380072 <spi_flash_hpm_probe_chip_with_cmd+0x1a>
        uint32_t gd_sfdp = bootloader_flash_read_sfdp(0x4, 1);
40380064:	01a0b2        	movi	a11, 1
40380067:	04a0a2        	movi	a10, 4
4038006a:	f73b25        	call8	4037741c <bootloader_flash_read_sfdp>
    esp_err_t ret = ESP_OK;
4038006d:	020c      	movi.n	a2, 0
        if (gd_sfdp == 0x0) {
4038006f:	021a27        	beq	a10, a2, 40380075 <spi_flash_hpm_probe_chip_with_cmd+0x1d>
            ret = ESP_ERR_NOT_FOUND;
40380072:	05a122        	movi	a2, 0x105
}
40380075:	f01d      	retw.n
	...

40380078 <spi_flash_hpm_probe_chip_with_dummy>:
{
40380078:	004136        	entry	a1, 32
    switch (flash_id) {
4038007b:	d3e931        	l32r	a3, 40375020 <_iram_text_start+0xc1c>
4038007e:	0e3327        	bltu	a3, a2, 40380090 <spi_flash_hpm_probe_chip_with_dummy+0x18>
40380081:	d3e881        	l32r	a8, 40375024 <_iram_text_start+0xc20>
40380084:	05a132        	movi	a3, 0x105
40380087:	01b827        	bgeu	a8, a2, 4038008c <spi_flash_hpm_probe_chip_with_dummy+0x14>
    esp_err_t ret = ESP_OK;
4038008a:	030c      	movi.n	a3, 0
}
4038008c:	032d      	mov.n	a2, a3
4038008e:	f01d      	retw.n
    switch (flash_id) {
40380090:	d3e631        	l32r	a3, 40375028 <_iram_text_start+0xc24>
40380093:	802230        	add	a2, a2, a3
40380096:	05a132        	movi	a3, 0x105
40380099:	ef22f6        	bgeui	a2, 2, 4038008c <spi_flash_hpm_probe_chip_with_dummy+0x14>
        uint32_t gd_sfdp = bootloader_flash_read_sfdp(0x4, 1);
4038009c:	01a0b2        	movi	a11, 1
4038009f:	04a0a2        	movi	a10, 4
403800a2:	f737a5        	call8	4037741c <bootloader_flash_read_sfdp>
            ret = ESP_ERR_NOT_FOUND;
403800a5:	facaa2        	addi	a10, a10, -6
403800a8:	020c      	movi.n	a2, 0
403800aa:	8332a0        	moveqz	a3, a2, a10
403800ad:	fff6c6        	j	4038008c <spi_flash_hpm_probe_chip_with_dummy+0x14>

403800b0 <spi_flash_enable_high_performance_mode>:
static const spi_flash_hpm_info_t *chip_hpm = NULL;
static spi_flash_hpm_dummy_conf_t dummy_conf;
static bool hpm_dummy_changed = false;

esp_err_t spi_flash_enable_high_performance_mode(void)
{
403800b0:	004136        	entry	a1, 32
    uint32_t flash_chip_id = g_rom_flashchip.device_id;
403800b3:	d1d021        	l32r	a2, 403747f4 <_iram_text_start+0x3f0>
    spi_flash_requirement_t hpm_requirement_check;
    // voltage and temperature has not been implemented, just leave an interface here. Complete in the future.
    int voltage = 0;
    int temperature = 0;

    const spi_flash_hpm_info_t *chip = spi_flash_hpm_enable_list;
403800b6:	d3dd31        	l32r	a3, 4037502c <_iram_text_start+0xc28>
    uint32_t flash_chip_id = g_rom_flashchip.device_id;
403800b9:	0228      	l32i.n	a2, a2, 0
403800bb:	0258      	l32i.n	a5, a2, 0
    esp_err_t ret = ESP_OK;
403800bd:	020c      	movi.n	a2, 0
    while (chip->probe) {
403800bf:	050382        	l8ui	a8, a3, 5
403800c2:	040342        	l8ui	a4, a3, 4
403800c5:	118880        	slli	a8, a8, 8
403800c8:	208840        	or	a8, a8, a4
403800cb:	060342        	l8ui	a4, a3, 6
403800ce:	114400        	slli	a4, a4, 16
403800d1:	204480        	or	a4, a4, a8
403800d4:	070382        	l8ui	a8, a3, 7
403800d7:	018880        	slli	a8, a8, 24
403800da:	208840        	or	a8, a8, a4
403800dd:	08f856        	bnez	a8, 40380170 <spi_flash_enable_high_performance_mode+0xc0>
        if (ret == ESP_OK) {
            break;
        }
        chip++;
    }
    chip_hpm = chip;
403800e0:	d3d441        	l32r	a4, 40375030 <_iram_text_start+0xc2c>
403800e3:	0439      	s32i.n	a3, a4, 0

    if (ret != ESP_OK) {
403800e5:	084256        	bnez	a2, 4038016d <spi_flash_enable_high_performance_mode+0xbd>
            ESP_EARLY_LOGW(HPM_TAG, "Flash high performance mode hasn't been supported");
#endif
        return ret;
    }

    hpm_requirement_check = chip_hpm->chip_hpm_requirement_check(flash_chip_id, flash_freq, voltage, temperature);
403800e8:	090392        	l8ui	a9, a3, 9
403800eb:	080382        	l8ui	a8, a3, 8
403800ee:	119980        	slli	a9, a9, 8
403800f1:	209980        	or	a9, a9, a8
403800f4:	0a0382        	l8ui	a8, a3, 10
403800f7:	0b0332        	l8ui	a3, a3, 11
403800fa:	118800        	slli	a8, a8, 16
403800fd:	208890        	or	a8, a8, a9
40380100:	013380        	slli	a3, a3, 24
40380103:	203380        	or	a3, a3, a8
40380106:	02dd      	mov.n	a13, a2
40380108:	02cd      	mov.n	a12, a2
4038010a:	0b5c      	movi.n	a11, 80
4038010c:	05ad      	mov.n	a10, a5
4038010e:	0003e0        	callx8	a3
40380111:	0a3d      	mov.n	a3, a10
    if ((hpm_requirement_check == SPI_FLASH_HPM_CMD_NEEDED) || (hpm_requirement_check == SPI_FLASH_HPM_DUMMY_NEEDED) || (hpm_requirement_check == SPI_FLASH_HPM_WRITE_SR_NEEDED)) {
40380113:	693af6        	bgeui	a10, 3, 40380180 <spi_flash_enable_high_performance_mode+0xd0>
        ESP_EARLY_LOGI(HPM_TAG, "Enabling flash high speed mode by %s", chip_hpm->method);
        chip_hpm->flash_hpm_enable();
40380116:	0458      	l32i.n	a5, a4, 0
40380118:	0d0522        	l8ui	a2, a5, 13
4038011b:	0c0582        	l8ui	a8, a5, 12
4038011e:	112280        	slli	a2, a2, 8
40380121:	202280        	or	a2, a2, a8
40380124:	0e0582        	l8ui	a8, a5, 14
40380127:	118800        	slli	a8, a8, 16
4038012a:	208820        	or	a8, a8, a2
4038012d:	0f0522        	l8ui	a2, a5, 15
40380130:	012280        	slli	a2, a2, 24
40380133:	202280        	or	a2, a2, a8
40380136:	0002e0        	callx8	a2
        ESP_EARLY_LOGD(HPM_TAG, "Checking whether HPM has been executed");

        if (chip_hpm->flash_hpf_check() != ESP_OK) {
40380139:	0448      	l32i.n	a4, a4, 0
4038013b:	110482        	l8ui	a8, a4, 17
4038013e:	100422        	l8ui	a2, a4, 16
40380141:	118880        	slli	a8, a8, 8
40380144:	208820        	or	a8, a8, a2
40380147:	120422        	l8ui	a2, a4, 18
4038014a:	1304a2        	l8ui	a10, a4, 19
4038014d:	112200        	slli	a2, a2, 16
40380150:	202280        	or	a2, a2, a8
40380153:	01aa80        	slli	a10, a10, 24
40380156:	20aa20        	or	a10, a10, a2
40380159:	000ae0        	callx8	a10
4038015c:	0a2d      	mov.n	a2, a10
4038015e:	caec      	bnez.n	a10, 4038018e <spi_flash_enable_high_performance_mode+0xde>
            ESP_EARLY_LOGE(HPM_TAG, "Flash high performance mode hasn't been executed successfully");
            return ESP_FAIL;
        }
        hpm_dummy_changed = (hpm_requirement_check == SPI_FLASH_HPM_DUMMY_NEEDED) ? true : false;
40380160:	330b      	addi.n	a3, a3, -1
40380162:	140c      	movi.n	a4, 1
40380164:	934a30        	movnez	a4, a10, a3
40380167:	d3b331        	l32r	a3, 40375034 <_iram_text_start+0xc30>
4038016a:	004342        	s8i	a4, a3, 0
    } else if (hpm_requirement_check == SPI_FLASH_HPM_BEYOND_LIMIT) {
        ESP_EARLY_LOGE(HPM_TAG, "Flash does not have the ability to raise to that frequency");
        return ESP_FAIL;
    }
    return ESP_OK;
}
4038016d:	f01d      	retw.n
4038016f:	00          	.byte 00
        ret = chip->probe(flash_chip_id);
40380170:	05ad      	mov.n	a10, a5
40380172:	0008e0        	callx8	a8
40380175:	0a2d      	mov.n	a2, a10
        if (ret == ESP_OK) {
40380177:	f65a16        	beqz	a10, 403800e0 <spi_flash_enable_high_performance_mode+0x30>
        chip++;
4038017a:	18c332        	addi	a3, a3, 24
4038017d:	ffcf86        	j	403800bf <spi_flash_enable_high_performance_mode+0xf>
    } else if (hpm_requirement_check == SPI_FLASH_HPM_BEYOND_LIMIT) {
40380180:	fcca32        	addi	a3, a10, -4
40380183:	140c      	movi.n	a4, 1
40380185:	934230        	movnez	a4, a2, a3
40380188:	602040        	neg	a2, a4
4038018b:	fff786        	j	4038016d <spi_flash_enable_high_performance_mode+0xbd>
            return ESP_FAIL;
4038018e:	f27c      	movi.n	a2, -1
40380190:	fff646        	j	4038016d <spi_flash_enable_high_performance_mode+0xbd>
	...

40380194 <spi_flash_hpm_chip_hpm_requirement_check_with_cmd>:
{
40380194:	004136        	entry	a1, 32
    if (freq_mhz > 80) {
40380197:	085c      	movi.n	a8, 80
    spi_flash_requirement_t chip_cap = SPI_FLASH_HPM_UNNEEDED;
40380199:	320c      	movi.n	a2, 3
    if (freq_mhz > 80) {
4038019b:	01b837        	bgeu	a8, a3, 403801a0 <spi_flash_hpm_chip_hpm_requirement_check_with_cmd+0xc>
        chip_cap = SPI_FLASH_HPM_CMD_NEEDED;
4038019e:	020c      	movi.n	a2, 0
}
403801a0:	f01d      	retw.n
	...

403801a4 <spi_flash_hpm_chip_hpm_requirement_check_with_dummy>:
{
403801a4:	004136        	entry	a1, 32
    if (freq_mhz >= 104) {
403801a7:	67a082        	movi	a8, 103
    spi_flash_requirement_t chip_cap = SPI_FLASH_HPM_UNNEEDED;
403801aa:	320c      	movi.n	a2, 3
    if (freq_mhz >= 104) {
403801ac:	01b837        	bgeu	a8, a3, 403801b1 <spi_flash_hpm_chip_hpm_requirement_check_with_dummy+0xd>
        chip_cap = SPI_FLASH_HPM_DUMMY_NEEDED;
403801af:	120c      	movi.n	a2, 1
}
403801b1:	f01d      	retw.n
	...

403801b4 <spi_flash_hpm_get_dummy_xmc>:
{
403801b4:	004136        	entry	a1, 32
    dummy_conf->dio_dummy = SPI_FLASH_DIO_HPM_DUMMY_BITLEN;
403801b7:	880c      	movi.n	a8, 8
    dummy_conf->qio_dummy = SPI_FLASH_QIO_HPM_DUMMY_BITLEN;
403801b9:	a90c      	movi.n	a9, 10
    dummy_conf->dio_dummy = SPI_FLASH_DIO_HPM_DUMMY_BITLEN;
403801bb:	004282        	s8i	a8, a2, 0
    dummy_conf->dout_dummy = SPI_FLASH_DOUT_DUMMY_BITLEN;
403801be:	014282        	s8i	a8, a2, 1
    dummy_conf->qio_dummy = SPI_FLASH_QIO_HPM_DUMMY_BITLEN;
403801c1:	024292        	s8i	a9, a2, 2
    dummy_conf->qout_dummy = SPI_FLASH_QOUT_DUMMY_BITLEN;
403801c4:	034282        	s8i	a8, a2, 3
    dummy_conf->fastrd_dummy = SPI_FLASH_FASTRD_DUMMY_BITLEN;
403801c7:	044282        	s8i	a8, a2, 4
}
403801ca:	f01d      	retw.n

403801cc <spi_flash_hpm_chip_require_check_hpf_bit_5>:
{
403801cc:	004136        	entry	a1, 32
    if (freq_mhz >= 104) {
403801cf:	67a082        	movi	a8, 103
    spi_flash_requirement_t chip_cap = SPI_FLASH_HPM_UNNEEDED;
403801d2:	320c      	movi.n	a2, 3
    if (freq_mhz >= 104) {
403801d4:	01b837        	bgeu	a8, a3, 403801d9 <spi_flash_hpm_chip_require_check_hpf_bit_5+0xd>
        chip_cap = SPI_FLASH_HPM_WRITE_SR_NEEDED;
403801d7:	220c      	movi.n	a2, 2
}
403801d9:	f01d      	retw.n
	...

403801dc <spi_flash_hpm_get_dummy_generic>:
{
403801dc:	004136        	entry	a1, 32
    dummy_conf->dio_dummy = SPI_FLASH_DIO_DUMMY_BITLEN;
403801df:	480c      	movi.n	a8, 4
403801e1:	004282        	s8i	a8, a2, 0
    dummy_conf->qio_dummy = SPI_FLASH_QIO_DUMMY_BITLEN;
403801e4:	690c      	movi.n	a9, 6
    dummy_conf->dout_dummy = SPI_FLASH_DOUT_DUMMY_BITLEN;
403801e6:	880c      	movi.n	a8, 8
403801e8:	014282        	s8i	a8, a2, 1
    dummy_conf->qio_dummy = SPI_FLASH_QIO_DUMMY_BITLEN;
403801eb:	024292        	s8i	a9, a2, 2
    dummy_conf->qout_dummy = SPI_FLASH_QOUT_DUMMY_BITLEN;
403801ee:	034282        	s8i	a8, a2, 3
    dummy_conf->fastrd_dummy = SPI_FLASH_FASTRD_DUMMY_BITLEN;
403801f1:	044282        	s8i	a8, a2, 4
}
403801f4:	f01d      	retw.n
	...

403801f8 <spi_timing_enter_mspi_low_speed_mode>:
    spi_timing_config_psram_set_extra_dummy(0, 0);
}
#endif  //#if SPI_TIMING_FLASH_NEEDS_TUNING || SPI_TIMING_PSRAM_NEEDS_TUNING

void spi_timing_enter_mspi_low_speed_mode(bool control_spi1)
{
403801f8:	004136        	entry	a1, 32
     *
     * Therefore, here we need to slow both the SPI0 and SPI1 and related timing tuning regs to 20Mhz configuration.
     */

    //Switch SPI1 and SPI0 clock as 20MHz, set its SPIMEM core clock as 80M and set clock division as 4
    spi_timing_config_set_core_clock(0, SPI_TIMING_CONFIG_CORE_CLOCK_80M);  //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
403801fb:	00a0b2        	movi	a11, 0
403801fe:	0bad      	mov.n	a10, a11
40380200:	000a25        	call8	403802a4 <spi_timing_config_set_core_clock>
{
40380203:	742020        	extui	a2, a2, 0, 8
    spi_timing_config_set_flash_clock(0, 4);
40380206:	4b0c      	movi.n	a11, 4
40380208:	0a0c      	movi.n	a10, 0
4038020a:	000da5        	call8	403802e4 <spi_timing_config_set_flash_clock>
    if (control_spi1) {
4038020d:	528c      	beqz.n	a2, 40380216 <spi_timing_enter_mspi_low_speed_mode+0x1e>
        //After tuning, won't touch SPI1 again
        spi_timing_config_set_flash_clock(1, 4);
4038020f:	4b0c      	movi.n	a11, 4
40380211:	1a0c      	movi.n	a10, 1
40380213:	000d25        	call8	403802e4 <spi_timing_config_set_flash_clock>
    }

    //Set PSRAM module clock
    spi_timing_config_set_psram_clock(0, 4);
40380216:	04a0b2        	movi	a11, 4
40380219:	00a0a2        	movi	a10, 0
4038021c:	0010e5        	call8	4038032c <spi_timing_config_set_psram_clock>

#if SPI_TIMING_FLASH_NEEDS_TUNING || SPI_TIMING_PSRAM_NEEDS_TUNING
    clear_timing_tuning_regs(control_spi1);
#endif
}
4038021f:	000090        	retw
	...

40380224 <spi_timing_enter_mspi_high_speed_mode>:
 * iF control_spi1 == 1, will also update SPI1 timing registers. Should only be set to 1 when do tuning.
 *
 * This function should always be called after `spi_timing_flash_tuning` or `calculate_best_flash_tuning_config`
 */
void spi_timing_enter_mspi_high_speed_mode(bool control_spi1)
{
40380224:	004136        	entry	a1, 32
    return spi_timing_config_get_core_clock();
40380227:	0013a5        	call8	40380360 <spi_timing_config_get_core_clock>
    spi_timing_config_core_clock_t core_clock = get_mspi_core_clock();
    uint32_t flash_div = get_flash_clock_divider();
    uint32_t psram_div = get_psram_clock_divider();

    //Set SPI01 core clock
    spi_timing_config_set_core_clock(0, core_clock); //SPI0 and SPI1 share the register for core clock. So we only set SPI0 here.
4038022a:	20baa0        	or	a11, a10, a10
4038022d:	00a0a2        	movi	a10, 0
40380230:	000725        	call8	403802a4 <spi_timing_config_set_core_clock>
{
40380233:	742020        	extui	a2, a2, 0, 8
    //Set FLASH module clock
    spi_timing_config_set_flash_clock(0, flash_div);
40380236:	1b0c      	movi.n	a11, 1
40380238:	0a0c      	movi.n	a10, 0
4038023a:	000aa5        	call8	403802e4 <spi_timing_config_set_flash_clock>
    if (control_spi1) {
4038023d:	528c      	beqz.n	a2, 40380246 <spi_timing_enter_mspi_high_speed_mode+0x22>
        spi_timing_config_set_flash_clock(1, flash_div);
4038023f:	1b0c      	movi.n	a11, 1
40380241:	0bad      	mov.n	a10, a11
40380243:	000a25        	call8	403802e4 <spi_timing_config_set_flash_clock>
    }
    //Set PSRAM module clock
    spi_timing_config_set_psram_clock(0, psram_div);
40380246:	00a0b2        	movi	a11, 0
40380249:	20abb0        	or	a10, a11, a11
4038024c:	000de5        	call8	4038032c <spi_timing_config_set_psram_clock>

#if SPI_TIMING_FLASH_NEEDS_TUNING || SPI_TIMING_PSRAM_NEEDS_TUNING
    set_timing_tuning_regs_as_required(true);
#endif
}
4038024f:	000090        	retw
	...

40380254 <spi_timing_change_speed_mode_cache_safe>:

void spi_timing_change_speed_mode_cache_safe(bool switch_down)
{
40380254:	004136        	entry	a1, 32
    Cache_Freeze_ICache_Enable(1);
40380257:	1a0c      	movi.n	a10, 1
40380259:	d37781        	l32r	a8, 40375038 <_iram_text_start+0xc34>
4038025c:	0008e0        	callx8	a8
{
4038025f:	742020        	extui	a2, a2, 0, 8
    Cache_Freeze_DCache_Enable(1);
40380262:	01a0a2        	movi	a10, 1
40380265:	d37581        	l32r	a8, 4037503c <_iram_text_start+0xc38>
40380268:	0008e0        	callx8	a8
    if (switch_down) {
4038026b:	013216        	beqz	a2, 40380282 <spi_timing_change_speed_mode_cache_safe+0x2e>
        //enter MSPI low speed mode, extra delays should be removed
        spi_timing_enter_mspi_low_speed_mode(false);
4038026e:	00a0a2        	movi	a10, 0
40380271:	fff865        	call8	403801f8 <spi_timing_enter_mspi_low_speed_mode>
    } else {
        //enter MSPI high speed mode, extra delays should be considered
        spi_timing_enter_mspi_high_speed_mode(false);
    }
    Cache_Freeze_DCache_Disable();
40380274:	d37381        	l32r	a8, 40375040 <_iram_text_start+0xc3c>
40380277:	0008e0        	callx8	a8
    Cache_Freeze_ICache_Disable();
4038027a:	d37281        	l32r	a8, 40375044 <_iram_text_start+0xc40>
4038027d:	0008e0        	callx8	a8
}
40380280:	f01d      	retw.n
        spi_timing_enter_mspi_high_speed_mode(false);
40380282:	02ad      	mov.n	a10, a2
40380284:	fff9e5        	call8	40380224 <spi_timing_enter_mspi_high_speed_mode>
40380287:	fffa46        	j	40380274 <spi_timing_change_speed_mode_cache_safe+0x20>
	...

4038028c <spi_timing_get_flash_timing_param>:
    // Get CS setup/hold value here.
    spi_timing_config_get_cs_timing(&out_timing_config->cs_setup, &out_timing_config->cs_hold);
}
#else
void spi_timing_get_flash_timing_param(spi_flash_hal_timing_config_t *out_timing_config)
{
4038028c:	004136        	entry	a1, 32
    // This function shouldn't be called if timing tuning is not used.
    abort();
4038028f:	fe4ee5        	call8	4037e77c <abort>
	...

40380294 <spi_timing_flash_tuning>:
{
40380294:	004136        	entry	a1, 32
}
40380297:	f01d      	retw.n
40380299:	000000        	ill

4038029c <spi_timing_is_tuned>:
{
4038029c:	004136        	entry	a1, 32
}
4038029f:	020c      	movi.n	a2, 0
403802a1:	f01d      	retw.n
	...

403802a4 <spi_timing_config_set_core_clock>:
            abort();
    }
}

void spi_timing_config_set_core_clock(uint8_t spi_num, spi_timing_config_core_clock_t core_clock)
{
403802a4:	004136        	entry	a1, 32
403802a7:	742020        	extui	a2, a2, 0, 8
    uint32_t reg_val = 0;

    switch (core_clock) {
403802aa:	0b2326        	beqi	a3, 2, 403802b9 <spi_timing_config_set_core_clock+0x15>
403802ad:	2b33f6        	bgeui	a3, 3, 403802dc <spi_timing_config_set_core_clock+0x38>
403802b0:	190c      	movi.n	a9, 1
403802b2:	080c      	movi.n	a8, 0
403802b4:	938930        	movnez	a8, a9, a3
403802b7:	083d      	mov.n	a3, a8
            break;
        default:
            abort();
    }

    REG_SET_FIELD(SPI_MEM_CORE_CLK_SEL_REG(spi_num), SPI_MEM_CORE_CLK_SEL, reg_val);
403802b9:	d36381        	l32r	a8, 40375048 <_iram_text_start+0xc44>
403802bc:	eca092        	movi	a9, 236
403802bf:	c08820        	sub	a8, a8, a2
403802c2:	118840        	slli	a8, a8, 12
403802c5:	889a      	add.n	a8, a8, a9
403802c7:	0020c0        	memw
403802ca:	0898      	l32i.n	a9, a8, 0
403802cc:	ca7c      	movi.n	a10, -4
403802ce:	1099a0        	and	a9, a9, a10
403802d1:	209930        	or	a9, a9, a3
403802d4:	0020c0        	memw
403802d7:	0899      	s32i.n	a9, a8, 0
}
403802d9:	f01d      	retw.n
403802db:	00          	.byte 00
    switch (core_clock) {
403802dc:	d93326        	beqi	a3, 3, 403802b9 <spi_timing_config_set_core_clock+0x15>
            abort();
403802df:	fe49e5        	call8	4037e77c <abort>
	...

403802e4 <spi_timing_config_set_flash_clock>:

void spi_timing_config_set_flash_clock(uint8_t spi_num, uint32_t freqdiv)
{
403802e4:	004136        	entry	a1, 32
403802e7:	742020        	extui	a2, a2, 0, 8
    assert(freqdiv > 0);
403802ea:	f3cc      	bnez.n	a3, 403802fd <spi_timing_config_set_flash_clock+0x19>
403802ec:	d358d1        	l32r	a13, 4037504c <_iram_text_start+0xc48>
403802ef:	d358c1        	l32r	a12, 40375050 <_iram_text_start+0xc4c>
403802f2:	d358a1        	l32r	a10, 40375054 <_iram_text_start+0xc50>
403802f5:	1b5c      	movi.n	a11, 81
403802f7:	201110        	or	a1, a1, a1
403802fa:	fe5125        	call8	4037e80c <__assert_func>
    if (freqdiv == 1) {
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
403802fd:	d35281        	l32r	a8, 40375048 <_iram_text_start+0xc44>
40380300:	c08820        	sub	a8, a8, a2
40380303:	118840        	slli	a8, a8, 12
    if (freqdiv == 1) {
40380306:	0a1366        	bnei	a3, 1, 40380314 <spi_timing_config_set_flash_clock+0x30>
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), SPI_MEM_CLK_EQU_SYSCLK);
40380309:	d35331        	l32r	a3, 40375058 <_iram_text_start+0xc54>
    } else {
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
        WRITE_PERI_REG(SPI_MEM_CLOCK_REG(spi_num), freqbits);
4038030c:	0020c0        	memw
4038030f:	5839      	s32i.n	a3, a8, 20
    }
}
40380311:	f01d      	retw.n
40380313:	00          	.byte 00
        uint32_t freqbits = (((freqdiv - 1) << SPI_MEM_CLKCNT_N_S)) | (((freqdiv / 2 - 1) << SPI_MEM_CLKCNT_H_S)) | ((freqdiv - 1) << SPI_MEM_CLKCNT_L_S);
40380314:	a30b      	addi.n	a10, a3, -1
40380316:	413130        	srli	a3, a3, 1
40380319:	330b      	addi.n	a3, a3, -1
4038031b:	119a00        	slli	a9, a10, 16
4038031e:	113380        	slli	a3, a3, 8
40380321:	2099a0        	or	a9, a9, a10
40380324:	203390        	or	a3, a3, a9
40380327:	fff846        	j	4038030c <spi_timing_config_set_flash_clock+0x28>
	...

4038032c <spi_timing_config_set_psram_clock>:

void spi_timing_config_set_psram_clock(uint8_t spi_num, uint32_t freqdiv)
{
4038032c:	004136        	entry	a1, 32
    if (freqdiv == 1) {
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
4038032f:	d34681        	l32r	a8, 40375048 <_iram_text_start+0xc44>
{
40380332:	742020        	extui	a2, a2, 0, 8
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
40380335:	c08820        	sub	a8, a8, a2
40380338:	118840        	slli	a8, a8, 12
    if (freqdiv == 1) {
4038033b:	0a1366        	bnei	a3, 1, 40380349 <spi_timing_config_set_psram_clock+0x1d>
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), SPI_MEM_SCLK_EQU_SYSCLK);
4038033e:	d34631        	l32r	a3, 40375058 <_iram_text_start+0xc54>
    } else {
        uint32_t freqbits = (((freqdiv-1)<<SPI_MEM_SCLKCNT_N_S)) | (((freqdiv/2-1)<<SPI_MEM_SCLKCNT_H_S)) | ((freqdiv-1)<<SPI_MEM_SCLKCNT_L_S);
        WRITE_PERI_REG(SPI_MEM_SRAM_CLK_REG(spi_num), freqbits);
40380341:	0020c0        	memw
40380344:	146832        	s32i	a3, a8, 80
    }
}
40380347:	f01d      	retw.n
        uint32_t freqbits = (((freqdiv-1)<<SPI_MEM_SCLKCNT_N_S)) | (((freqdiv/2-1)<<SPI_MEM_SCLKCNT_H_S)) | ((freqdiv-1)<<SPI_MEM_SCLKCNT_L_S);
40380349:	a30b      	addi.n	a10, a3, -1
4038034b:	413130        	srli	a3, a3, 1
4038034e:	330b      	addi.n	a3, a3, -1
40380350:	119a00        	slli	a9, a10, 16
40380353:	113380        	slli	a3, a3, 8
40380356:	2099a0        	or	a9, a9, a10
40380359:	203390        	or	a3, a3, a9
4038035c:	fff846        	j	40380341 <spi_timing_config_set_psram_clock+0x15>
	...

40380360 <spi_timing_config_get_core_clock>:
{
40380360:	004136        	entry	a1, 32
}
40380363:	020c      	movi.n	a2, 0
40380365:	f01d      	retw.n
	...

40380368 <xthal_window_spill_nw>:
40380368:	034820        	rsr.windowbase	a2
4038036b:	221b      	addi.n	a2, a2, 1
4038036d:	400200        	ssr	a2
40380370:	034930        	rsr.windowstart	a3
40380373:	912030        	srl	a2, a3
40380376:	a13300        	sll	a3, a3
40380379:	0bf3d6        	bgez	a3, 4038043c <xthal_window_spill_nw+0xd4>
4038037c:	f53030        	extui	a3, a3, 16, 16
4038037f:	202230        	or	a2, a2, a3
40380382:	603020        	neg	a3, a2
40380385:	103320        	and	a3, a3, a2
40380388:	40f330        	nsau	a3, a3
4038038b:	401300        	ssl	a3
4038038e:	912020        	srl	a2, a2
40380391:	134920        	wsr.windowstart	a2
40380394:	034820        	rsr.windowbase	a2
40380397:	1fc222        	addi	a2, a2, 31
4038039a:	c03230        	sub	a3, a2, a3
4038039d:	134830        	wsr.windowbase	a3
403803a0:	002010        	rsync
403803a3:	034920        	rsr.windowstart	a2
403803a6:	07a216        	beqz	a2, 40380424 <xthal_window_spill_nw+0xbc>
403803a9:	08e207        	bbsi	a2, 0, 403803b5 <xthal_window_spill_nw+0x4d>
403803ac:	19e217        	bbsi	a2, 1, 403803c9 <xthal_window_spill_nw+0x61>
403803af:	3ae227        	bbsi	a2, 2, 403803ed <xthal_window_spill_nw+0x85>
403803b2:	002306        	j	40380442 <xthal_window_spill_nw+0xda>
403803b5:	f0c932        	addi	a3, a9, -16
403803b8:	0349      	s32i.n	a4, a3, 0
403803ba:	1359      	s32i.n	a5, a3, 4
403803bc:	2369      	s32i.n	a6, a3, 8
403803be:	3379      	s32i.n	a7, a3, 12
403803c0:	416120        	srli	a6, a2, 1
403803c3:	408010        	rotw	1
403803c6:	fff706        	j	403803a6 <xthal_window_spill_nw+0x3e>
403803c9:	f0cd32        	addi	a3, a13, -16
403803cc:	0349      	s32i.n	a4, a3, 0
403803ce:	1359      	s32i.n	a5, a3, 4
403803d0:	2369      	s32i.n	a6, a3, 8
403803d2:	3379      	s32i.n	a7, a3, 12
403803d4:	f4c532        	addi	a3, a5, -12
403803d7:	0338      	l32i.n	a3, a3, 0
403803d9:	e0c332        	addi	a3, a3, -32
403803dc:	0389      	s32i.n	a8, a3, 0
403803de:	1399      	s32i.n	a9, a3, 4
403803e0:	23a9      	s32i.n	a10, a3, 8
403803e2:	33b9      	s32i.n	a11, a3, 12
403803e4:	41a220        	srli	a10, a2, 2
403803e7:	408020        	rotw	2
403803ea:	ffee06        	j	403803a6 <xthal_window_spill_nw+0x3e>
403803ed:	408010        	rotw	1
403803f0:	f0cdd2        	addi	a13, a13, -16
403803f3:	0d09      	s32i.n	a0, a13, 0
403803f5:	1d19      	s32i.n	a1, a13, 4
403803f7:	2d29      	s32i.n	a2, a13, 8
403803f9:	3d39      	s32i.n	a3, a13, 12
403803fb:	f4c132        	addi	a3, a1, -12
403803fe:	0338      	l32i.n	a3, a3, 0
40380400:	10cdd2        	addi	a13, a13, 16
40380403:	d0c332        	addi	a3, a3, -48
40380406:	0349      	s32i.n	a4, a3, 0
40380408:	1359      	s32i.n	a5, a3, 4
4038040a:	2369      	s32i.n	a6, a3, 8
4038040c:	3379      	s32i.n	a7, a3, 12
4038040e:	4389      	s32i.n	a8, a3, 16
40380410:	5399      	s32i.n	a9, a3, 20
40380412:	63a9      	s32i.n	a10, a3, 24
40380414:	73b9      	s32i.n	a11, a3, 28
40380416:	4080f0        	rotw	-1
40380419:	41e320        	srli	a14, a2, 3
4038041c:	408030        	rotw	3
4038041f:	ffe0c6        	j	403803a6 <xthal_window_spill_nw+0x3e>
40380422:	00          	.byte 00
40380423:	00          	.byte 00
40380424:	408010        	rotw	1
40380427:	034820        	rsr.windowbase	a2
4038042a:	401200        	ssl	a2
4038042d:	120c      	movi.n	a2, 1
4038042f:	a12200        	sll	a2, a2
40380432:	134920        	wsr.windowstart	a2
40380435:	002010        	rsync
40380438:	020c      	movi.n	a2, 0
4038043a:	f00d      	ret.n
4038043c:	120c      	movi.n	a2, 1
4038043e:	f00d      	ret.n
40380440:	00          	.byte 00
40380441:	00          	.byte 00
40380442:	1122f0        	slli	a2, a2, 1
40380445:	221b      	addi.n	a2, a2, 1
40380447:	034830        	rsr.windowbase	a3
4038044a:	0ae2f7        	bbsi	a2, 15, 40380458 <xthal_window_spill_nw+0xf0>
4038044d:	330b      	addi.n	a3, a3, -1
4038044f:	1122f0        	slli	a2, a2, 1
40380452:	f762f7        	bbci	a2, 15, 4038044d <xthal_window_spill_nw+0xe5>
40380455:	343030        	extui	a3, a3, 0, 4
40380458:	401300        	ssl	a3
4038045b:	113200        	slli	a3, a2, 16
4038045e:	812230        	src	a2, a2, a3
40380461:	f42020        	extui	a2, a2, 0, 16
40380464:	134920        	wsr.windowstart	a2
40380467:	030330        	rsr.sar	a3
4038046a:	022c      	movi.n	a2, 32
4038046c:	c03230        	sub	a3, a2, a3
4038046f:	134830        	wsr.windowbase	a3
40380472:	002010        	rsync
40380475:	220c      	movi.n	a2, 2
40380477:	f00d      	ret.n
40380479:	000000        	ill

4038047c <xthal_window_spill>:
4038047c:	002136        	entry	a1, 16
4038047f:	d1bb61        	l32r	a6, 40374b6c <_iram_text_start+0x768>
40380482:	03e650        	rsr.ps	a5
40380485:	004d      	mov.n	a4, a0
40380487:	102560        	and	a2, a5, a6
4038048a:	223b      	addi.n	a2, a2, 3
4038048c:	13e620        	wsr.ps	a2
4038048f:	002010        	rsync
40380492:	ffed45        	call0	40380368 <xthal_window_spill_nw>
40380495:	040d      	mov.n	a0, a4
40380497:	13e650        	wsr.ps	a5
4038049a:	002010        	rsync
4038049d:	f01d      	retw.n
	...

403804a0 <xthal_restore_extra_nw>:
403804a0:	0238      	l32i.n	a3, a2, 0
403804a2:	f3e730        	wur.threadptr	a3
403804a5:	1238      	l32i.n	a3, a2, 4
403804a7:	131030        	wsr.acclo	a3
403804aa:	2238      	l32i.n	a3, a2, 8
403804ac:	131130        	wsr.acchi	a3
403804af:	3238      	l32i.n	a3, a2, 12
403804b1:	130430        	wsr.br	a3
403804b4:	4238      	l32i.n	a3, a2, 16
403804b6:	130c30        	wsr.scompare1	a3
403804b9:	5238      	l32i.n	a3, a2, 20
403804bb:	132030        	wsr.m0	a3
403804be:	6238      	l32i.n	a3, a2, 24
403804c0:	132130        	wsr.m1	a3
403804c3:	7238      	l32i.n	a3, a2, 28
403804c5:	132230        	wsr.m2	a3
403804c8:	8238      	l32i.n	a3, a2, 32
403804ca:	132330        	wsr.m3	a3
403804cd:	f00d      	ret.n
	...

403804d0 <xthal_save_extra_nw>:
403804d0:	e33e70        	rur.threadptr	a3
403804d3:	0239      	s32i.n	a3, a2, 0
403804d5:	031030        	rsr.acclo	a3
403804d8:	1239      	s32i.n	a3, a2, 4
403804da:	031130        	rsr.acchi	a3
403804dd:	2239      	s32i.n	a3, a2, 8
403804df:	030430        	rsr.br	a3
403804e2:	3239      	s32i.n	a3, a2, 12
403804e4:	030c30        	rsr.scompare1	a3
403804e7:	4239      	s32i.n	a3, a2, 16
403804e9:	032030        	rsr.m0	a3
403804ec:	5239      	s32i.n	a3, a2, 20
403804ee:	032130        	rsr.m1	a3
403804f1:	6239      	s32i.n	a3, a2, 24
403804f3:	032230        	rsr.m2	a3
403804f6:	7239      	s32i.n	a3, a2, 28
403804f8:	032330        	rsr.m3	a3
403804fb:	8239      	s32i.n	a3, a2, 32
403804fd:	f00d      	ret.n
	...

40380500 <xt_ints_on>:
    .global xt_ints_on
    .type   xt_ints_on,@function

xt_ints_on:

    ENTRY0
40380500:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable |= mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts       */
    mov     a2, a3               /* Previous mask             */
#else
    movi    a3, 0
40380503:	030c      	movi.n	a3, 0
    xsr     a3, INTENABLE        /* Disables all interrupts   */
40380505:	61e430        	xsr.intenable	a3
    rsync
40380508:	002010        	rsync
    or      a2, a3, a2           /* set bits in mask */
4038050b:	202320        	or	a2, a3, a2
    wsr     a2, INTENABLE        /* Re-enable ints */
4038050e:	13e420        	wsr.intenable	a2
    rsync
40380511:	002010        	rsync
    mov     a2, a3               /* return prev mask */
40380514:	032d      	mov.n	a2, a3
#endif
#else
    movi    a2, 0                /* Return zero */
#endif
    RET0
40380516:	f01d      	retw.n

40380518 <xt_ints_off>:
    .global xt_ints_off
    .type   xt_ints_off,@function

xt_ints_off:

    ENTRY0
40380518:	002136        	entry	a1, 16
    s32i    a5, a4, 0            /* _xt_intenable &= ~mask     */
    and     a5, a5, a6           /* a5 = _xt_intenable & _xt_vpri_mask */
    wsr     a5, INTENABLE        /* Reenable interrupts        */
    mov     a2, a3               /* Previous mask              */
#else
    movi    a4, 0
4038051b:	040c      	movi.n	a4, 0
    xsr     a4, INTENABLE        /* Disables all interrupts   */
4038051d:	61e440        	xsr.intenable	a4
    rsync
40380520:	002010        	rsync
    or      a3, a4, a2           /* set bits in mask */
40380523:	203420        	or	a3, a4, a2
    xor     a3, a3, a2           /* invert bits in mask set in mask, essentially clearing them */
40380526:	303320        	xor	a3, a3, a2
    wsr     a3, INTENABLE        /* Re-enable ints */
40380529:	13e430        	wsr.intenable	a3
    rsync
4038052c:	002010        	rsync
    mov     a2, a4               /* return prev mask */
4038052f:	042d      	mov.n	a2, a4
#endif
#else
    movi    a2, 0                /* return zero */
#endif
    RET0
40380531:	f01d      	retw.n

Disassembly of section .flash.text:

42000020 <_stext>:
42000020:	5c 50 37 40 	
42000024:	2c e9 37 40 	
42000028:	c8 0e 00 42 	
4200002c:	58 26 c9 3f 	
42000030:	5c 26 c9 3f 	
42000034:	e8 a8 37 40 	
42000038:	04 06 c9 3f 	
4200003c:	60 26 c9 3f 	
42000040:	b0 c5 37 40 	
42000044:	e4 c6 37 40 	
42000048:	0c e9 37 40 	
4200004c:	54 1b 00 40 	
42000050:	64 26 c9 3f 	
42000054:	4c 85 37 40 	
42000058:	40 90 37 40 	
4200005c:	24 86 37 40 	
42000060:	9c 01 02 3c 	
42000064:	ff ff ff bf 	
42000068:	38 01 02 3c 	
4200006c:	a0 01 02 3c 	
42000070:	92 01 02 3c 	
42000074:	00 80 00 60 	
42000078:	98 01 02 3c 	
4200007c:	7c 05 00 40 	
42000080:	04 87 37 40 	
42000084:	0c e8 37 40 	
42000088:	0c 86 37 40 	
4200008c:	84 85 37 40 	
42000090:	c4 86 37 40 	
42000094:	a8 86 37 40 	
42000098:	e0 0d 00 40 	
4200009c:	1c 0e 00 40 	
420000a0:	44 25 00 40 	
420000a4:	d4 0d 00 40 	
420000a8:	ec 0d 00 40 	
420000ac:	7c 87 37 40 	
420000b0:	28 87 37 40 	
420000b4:	9c 06 00 40 	
420000b8:	14 8a 37 40 	
420000bc:	f8 8f fb 8e 	
420000c0:	18 00 0c 60 	
420000c4:	1c 00 0c 60 	
420000c8:	14 60 02 60 	
420000cc:	f0 13 e5 88 	
420000d0:	20 00 0c 60 	
420000d4:	24 00 0c 60 	
420000d8:	cf 9f fb 00 	
420000dc:	28 00 0c 60 	
420000e0:	2c 00 0c 60 	
420000e4:	ff ff ff fd 	
420000e8:	e0 40 0c 60 	
420000ec:	dc 40 0c 60 	
420000f0:	ec 40 0c 60 	
420000f4:	e8 40 0c 60 	
420000f8:	f8 40 0c 60 	
420000fc:	f4 40 0c 60 	
42000100:	6c 26 c9 3f 	
42000104:	bc 0d 00 40 	
42000108:	f8 0d 00 40 	
4200010c:	08 55 37 40 	
42000110:	50 ee 02 3c 	
42000114:	60 ee 02 3c 	
42000118:	89 26 c9 3f 	
4200011c:	7c e7 37 40 	
42000120:	ad 01 02 3c 	
42000124:	5f 02 02 3c 	
42000128:	ff 01 02 3c 	
4200012c:	d0 ff ce 3f 	
42000130:	24 da 02 3c 	
42000134:	09 02 02 3c 	
42000138:	17 02 02 3c 	
4200013c:	19 02 02 3c 	
42000140:	4b 02 02 3c 	
42000144:	28 ee 02 3c 	
42000148:	1c ee 02 3c 	
4200014c:	88 26 c9 3f 	
42000150:	90 5f 37 40 	
42000154:	0c 70 37 40 	
42000158:	a4 e9 37 40 	
4200015c:	04 0e 00 40 	
42000160:	00 06 00 40 	
42000164:	98 26 c9 3f 	
42000168:	0c 20 10 00 	
4200016c:	ff ff ff 3f 	
42000170:	ff ff ff 01 	
42000174:	00 00 c9 bf 	
42000178:	ff ff 06 00 	
4200017c:	ff a0 01 00 	
42000180:	00 20 f0 9f 	
42000184:	ff 1f 00 00 	
42000188:	00 44 37 40 	
4200018c:	1c 06 c9 3f 	
42000190:	74 02 02 3c 	
42000194:	40 17 00 42 	
42000198:	e8 11 00 40 	
4200019c:	80 54 37 40 	
420001a0:	9c 82 37 40 	
420001a4:	f8 5a 37 40 	
420001a8:	10 0e 00 40 	
420001ac:	3c 27 c9 3f 	
420001b0:	9f 02 02 3c 	
420001b4:	e8 65 37 40 	
420001b8:	6c 64 37 40 	
420001bc:	f4 56 37 40 	
420001c0:	74 55 37 40 	
420001c4:	a2 02 02 3c 	
420001c8:	6c 56 37 40 	
420001cc:	f4 11 00 40 	
420001d0:	f8 5b 37 40 	
420001d4:	a0 26 c9 3f 	
420001d8:	c8 80 00 60 	
420001dc:	d8 56 37 40 	
420001e0:	90 58 37 40 	
420001e4:	a0 58 37 40 	
420001e8:	30 06 00 40 	
420001ec:	30 03 02 3c 	
420001f0:	49 03 02 3c 	
420001f4:	55 03 02 3c 	
420001f8:	63 03 02 3c 	
420001fc:	7b 03 02 3c 	
42000200:	93 03 02 3c 	
42000204:	a0 03 02 3c 	
42000208:	ae 03 02 3c 	
4200020c:	fc ff ff bf 	
42000210:	ff ff ff 03 	
42000214:	b9 03 02 3c 	
42000218:	67 0b 02 3c 	
4200021c:	24 06 02 3c 	
42000220:	e4 40 0c 60 	
42000224:	cb 03 02 3c 	
42000228:	17 04 02 3c 	
4200022c:	1b 04 02 3c 	
42000230:	98 40 0c 60 	
42000234:	9c 40 0c 60 	
42000238:	1f 04 02 3c 	
4200023c:	6e 04 02 3c 	
42000240:	44 40 0c 60 	
42000244:	48 40 0c 60 	
42000248:	ba 04 02 3c 	
4200024c:	09 05 02 3c 	
42000250:	24 41 0c 60 	
42000254:	4f 05 02 3c 	
42000258:	20 41 0c 60 	
4200025c:	8d 05 02 3c 	
42000260:	9f 02 02 3c 	
42000264:	e4 06 02 3c 	
42000268:	13 0b 02 3c 	
4200026c:	a2 05 02 3c 	
42000270:	d9 05 02 3c 	
42000274:	23 06 02 3c 	
42000278:	b2 05 02 3c 	
4200027c:	d1 05 02 3c 	
42000280:	de 05 02 3c 	
42000284:	ed 05 02 3c 	
42000288:	fc 05 02 3c 	
4200028c:	d0 66 37 40 	
42000290:	74 02 02 3c 	
42000294:	0c 0a 02 3c 	
42000298:	44 07 02 3c 	
4200029c:	e4 18 00 42 	
420002a0:	5d 07 02 3c 	
420002a4:	ec 09 02 3c 	
420002a8:	94 18 00 42 	
420002ac:	38 19 00 42 	
420002b0:	94 59 37 40 	
420002b4:	a4 26 c9 3f 	
420002b8:	f4 26 c9 3f 	
420002bc:	7c 83 37 40 	
420002c0:	30 06 c9 3f 	
420002c4:	b4 26 c9 3f 	
420002c8:	38 06 c9 3f 	
420002cc:	34 27 c9 3f 	
420002d0:	00 80 03 60 	
420002d4:	38 27 c9 3f 	
420002d8:	67 66 66 66 	
420002dc:	ec 0a 02 3c 	
420002e0:	f4 0a 02 3c 	
420002e4:	60 1d 00 42 	
420002e8:	fc 0a 02 3c 	
420002ec:	19 0b 02 3c 	
420002f0:	25 0b 02 3c 	
420002f4:	9f 02 02 3c 	
420002f8:	29 0b 02 3c 	
420002fc:	42 0b 02 3c 	
42000300:	3c 06 c9 3f 	
42000304:	56 0b 02 3c 	
42000308:	6a 0b 02 3c 	
4200030c:	34 0e 00 40 	
42000310:	a0 56 37 40 	
42000314:	ff ff fb ff 	
42000318:	ff ff fd ff 	
4200031c:	0f c0 ff ff 	
42000320:	ff bf ff ff 	
42000324:	ff 7f ff ff 	
42000328:	ff ff ff fb 	
4200032c:	0c 63 37 40 	
42000330:	44 27 c9 3f 	
42000334:	31 0d 02 3c 	
42000338:	e1 0d 02 3c 	
4200033c:	62 0d 02 3c 	
42000340:	40 dd 37 40 	
42000344:	73 0d 02 3c 	
42000348:	d2 0d 02 3c 	
4200034c:	bc 16 02 3c 	
42000350:	ff ff 3f b3 	
42000354:	89 0d 02 3c 	
42000358:	9f 0d 02 3c 	
4200035c:	be 0d 02 3c 	
42000360:	78 dc 37 40 	
42000364:	50 ee 02 3c 	
42000368:	30 ee 02 3c 	
4200036c:	cc 15 02 3c 	
42000370:	d0 15 02 3c 	
42000374:	fc ff f1 3f 	
42000378:	00 00 cf 3f 	
4200037c:	28 7d 01 42 	
42000380:	31 15 02 3c 	
42000384:	b1 15 02 3c 	
42000388:	71 15 02 3c 	
4200038c:	87 15 02 3c 	
42000390:	88 14 00 40 	
42000394:	48 06 c9 3f 	
42000398:	54 80 00 60 	
4200039c:	08 00 00 50 	
420003a0:	00 00 00 50 	
420003a4:	8c c5 37 40 	
420003a8:	14 91 37 40 	
420003ac:	5c 27 c9 3f 	
420003b0:	08 1a 02 3c 	
420003b4:	3b 1b 02 3c 	
420003b8:	71 1a 02 3c 	
420003bc:	ff ff c1 ff 	
420003c0:	ff ff fe ff 	
420003c4:	38 5d 37 40 	
420003c8:	00 05 38 40 	
420003cc:	18 05 38 40 	
420003d0:	ff ff ff 7f 	
420003d4:	50 06 c9 3f 	
420003d8:	7e 1a 02 3c 	
420003dc:	4f 1b 02 3c 	
420003e0:	8a 1a 02 3c 	
420003e4:	22 1b 02 3c 	
420003e8:	df 1a 02 3c 	
420003ec:	d8 5f 37 40 	
420003f0:	0c 1b 02 3c 	
420003f4:	ff ff 3f c0 	
420003f8:	54 27 c9 3f 	
420003fc:	40 61 37 40 	
42000400:	e4 1b 00 40 	
42000404:	b8 2c 00 42 	
42000408:	e9 1a 02 3c 	
4200040c:	fe 1a 02 3c 	
42000410:	8f 07 78 00 	
42000414:	08 00 0c 60 	
42000418:	01 40 c0 17 	
4200041c:	0c 00 0c 60 	
42000420:	18 60 02 60 	
42000424:	64 1b 02 3c 	
42000428:	d7 1b 02 3c 	
4200042c:	9f 1b 02 3c 	
42000430:	58 06 c9 3f 	
42000434:	60 27 c9 3f 	
42000438:	c1 1b 02 3c 	
4200043c:	ad 1b 02 3c 	
42000440:	d8 0d c9 3f 	
42000444:	8c 27 c9 3f 	
42000448:	40 80 00 60 	
4200044c:	4c 80 00 60 	
42000450:	f4 61 37 40 	
42000454:	e4 0d c9 3f 	
42000458:	ec 0d c9 3f 	
4200045c:	e0 0d c9 3f 	
42000460:	e0 80 00 60 	
42000464:	ff ff 3f 00 	
42000468:	84 d2 02 3c 	
4200046c:	d8 80 00 60 	
42000470:	b4 cd 02 3c 	
42000474:	4c 81 37 40 	
42000478:	48 1c 02 3c 	
4200047c:	04 24 02 3c 	
42000480:	00 80 c8 bf 	
42000484:	ff 7f 06 00 	
42000488:	00 80 37 c0 	
4200048c:	08 d0 00 00 	
42000490:	78 06 c9 3f 	
42000494:	24 11 0c 60 	
42000498:	d0 11 0c 60 	
4200049c:	48 11 0c 60 	
420004a0:	f4 11 0c 60 	
420004a4:	02 d0 00 00 	
420004a8:	01 d0 00 00 	
420004ac:	c4 10 0c 60 	
420004b0:	c8 10 0c 60 	
420004b4:	cc 10 0c 60 	
420004b8:	d0 10 0c 60 	
420004bc:	d4 10 0c 60 	
420004c0:	d8 10 0c 60 	
420004c4:	fc 10 0c 60 	
420004c8:	4c 11 0c 60 	
420004cc:	f8 11 0c 60 	
420004d0:	e0 10 0c 60 	
420004d4:	ff f1 ff ff 	
420004d8:	00 11 0c 60 	
420004dc:	ff 8f ff ff 	
420004e0:	ff 7f fc ff 	
420004e4:	e4 10 0c 60 	
420004e8:	f0 10 0c 60 	
420004ec:	04 11 0c 60 	
420004f0:	14 11 0c 60 	
420004f4:	9c 11 0c 60 	
420004f8:	48 12 0c 60 	
420004fc:	e8 10 0c 60 	
42000500:	f4 10 0c 60 	
42000504:	08 11 0c 60 	
42000508:	18 11 0c 60 	
4200050c:	a0 11 0c 60 	
42000510:	4c 12 0c 60 	
42000514:	00 06 38 40 	
42000518:	00 80 00 60 	
4200051c:	00 00 00 80 	
42000520:	10 e0 0f 60 	
42000524:	c0 10 0c 60 	
42000528:	64 1c 02 3c 	
4200052c:	bf 1c 02 3c 	
42000530:	1b 1d 02 3c 	
42000534:	77 1d 02 3c 	
42000538:	d3 1d 02 3c 	
4200053c:	2f 1e 02 3c 	
42000540:	87 1e 02 3c 	
42000544:	df 1e 02 3c 	
42000548:	37 1f 02 3c 	
4200054c:	8f 1f 02 3c 	
42000550:	e7 1f 02 3c 	
42000554:	3f 20 02 3c 	
42000558:	97 20 02 3c 	
4200055c:	ef 20 02 3c 	
42000560:	4a 21 02 3c 	
42000564:	a5 21 02 3c 	
42000568:	09 22 02 3c 	
4200056c:	6a 22 02 3c 	
42000570:	d3 22 02 3c 	
42000574:	37 23 02 3c 	
42000578:	98 23 02 3c 	
4200057c:	50 63 37 40 	
42000580:	d0 05 00 40 	
42000584:	03 d0 00 00 	
42000588:	04 d0 00 00 	
4200058c:	05 d0 00 00 	
42000590:	06 d0 00 00 	
42000594:	07 d0 00 00 	
42000598:	ec 2a c9 3f 	
4200059c:	4b 34 02 3c 	
420005a0:	b1 34 02 3c 	
420005a4:	05 34 02 3c 	
420005a8:	98 2a c9 3f 	
420005ac:	79 34 02 3c 	
420005b0:	33 c4 10 bb 	
420005b4:	7c a8 37 40 	
420005b8:	dc 11 00 40 	
420005bc:	d4 ff ce 3f 	
420005c0:	c0 06 c9 3f 	
420005c4:	40 2b c9 3f 	
420005c8:	e8 34 c9 3f 	
420005cc:	40 2c c9 3f 	
420005d0:	38 2c c9 3f 	
420005d4:	30 2c c9 3f 	
420005d8:	40 42 0f 00 	
420005dc:	a4 6e 37 40 	
420005e0:	e4 6e 37 40 	
420005e4:	50 2c c9 3f 	
420005e8:	74 71 37 40 	
420005ec:	48 2c c9 3f 	
420005f0:	58 80 00 60 	
420005f4:	5c 80 00 60 	
420005f8:	10 35 02 3c 	
420005fc:	cc 4a 02 3c 	
42000600:	5c 2c c9 3f 	
42000604:	1e 1e de f0 	
42000608:	ff ff ff 00 	
4200060c:	44 c0 37 40 	
42000610:	bc 70 37 40 	
42000614:	bc 71 37 40 	
42000618:	d0 70 37 40 	
4200061c:	40 71 37 40 	
42000620:	d4 71 37 40 	
42000624:	58 2c c9 3f 	
42000628:	4c 51 02 3c 	
4200062c:	44 47 00 42 	
42000630:	54 71 37 40 	
42000634:	a0 b2 37 40 	
42000638:	ac bc 37 40 	
4200063c:	90 26 c9 3f 	
42000640:	60 2c c9 3f 	
42000644:	b0 46 00 42 	
42000648:	58 51 02 3c 	
4200064c:	68 2c c9 3f 	
42000650:	48 d9 37 40 	
42000654:	58 db 37 40 	
42000658:	88 db 37 40 	
4200065c:	f4 da 37 40 	
42000660:	34 db 37 40 	
42000664:	74 2c c9 3f 	
42000668:	78 2c c9 3f 	
4200066c:	94 71 37 40 	
42000670:	ff ff bf ff 	
42000674:	68 db 37 40 	
42000678:	b8 60 37 40 	
4200067c:	80 07 c9 3f 	
42000680:	15 02 02 3c 	
42000684:	60 51 02 3c 	
42000688:	ba 51 02 3c 	
4200068c:	b4 51 02 3c 	
42000690:	3c 12 00 40 	
42000694:	48 12 00 40 	
42000698:	80 2c c9 3f 	
4200069c:	84 2c c9 3f 	
420006a0:	18 12 00 40 	
420006a4:	0c 12 00 40 	
420006a8:	7c 2c c9 3f 	
420006ac:	ec a6 37 40 	
420006b0:	fc a9 37 40 	
420006b4:	c9 51 02 3c 	
420006b8:	d3 51 02 3c 	
420006bc:	a4 2c c9 3f 	
420006c0:	d6 51 02 3c 	
420006c4:	15 02 02 3c 	
420006c8:	ac 2c c9 3f 	
420006cc:	b0 2c c9 3f 	
420006d0:	f4 51 02 3c 	
420006d4:	e5 51 02 3c 	
420006d8:	40 08 c9 3f 	
420006dc:	00 20 00 00 	
420006e0:	48 08 c9 3f 	
420006e4:	4f c3 00 00 	
420006e8:	b4 6e 37 40 	
420006ec:	f4 6e 37 40 	
420006f0:	02 40 00 00 	
420006f4:	98 52 02 3c 	
420006f8:	db 52 02 3c 	
420006fc:	c5 52 02 3c 	
42000700:	44 08 c9 3f 	
42000704:	f8 52 02 3c 	
42000708:	f8 54 02 3c 	
4200070c:	68 08 c9 3f 	
42000710:	b4 2c c9 3f 	
42000714:	b8 2c c9 3f 	
42000718:	18 e9 37 40 	
4200071c:	ec 57 00 42 	
42000720:	20 a1 07 00 	
42000724:	a0 25 26 00 	
42000728:	60 e3 16 00 	
4200072c:	80 84 1e 00 	
42000730:	e0 67 35 00 	
42000734:	00 09 3d 00 	
42000738:	c0 c6 2d 00 	
4200073c:	d3 51 02 3c 	
42000740:	9c 53 02 3c 	
42000744:	9f 53 02 3c 	
42000748:	30 12 00 40 	
4200074c:	a2 53 02 3c 	
42000750:	3e 54 02 3c 	
42000754:	c8 53 02 3c 	
42000758:	33 54 02 3c 	
4200075c:	28 54 02 3c 	
42000760:	d3 53 02 3c 	
42000764:	0d 54 02 3c 	
42000768:	f0 53 02 3c 	
4200076c:	49 54 02 3c 	
42000770:	1e 54 02 3c 	
42000774:	02 54 02 3c 	
42000778:	54 54 02 3c 	
4200077c:	70 c4 02 3c 	
42000780:	6c c4 02 3c 	
42000784:	68 c4 02 3c 	
42000788:	64 c4 02 3c 	
4200078c:	60 c4 02 3c 	
42000790:	d4 2c c9 3f 	
42000794:	74 c4 02 3c 	
42000798:	5c 61 02 3c 	
4200079c:	58 61 02 3c 	
420007a0:	54 61 02 3c 	
420007a4:	50 61 02 3c 	
420007a8:	bc 2c c9 3f 	
420007ac:	dc 08 c9 3f 	
420007b0:	04 55 02 3c 	
420007b4:	02 56 02 3c 	
420007b8:	2e 55 02 3c 	
420007bc:	3c 55 02 3c 	
420007c0:	a3 55 02 3c 	
420007c4:	bc 9e 37 40 	
420007c8:	2c 2f c9 3f 	
420007cc:	ec 2c c9 3f 	
420007d0:	5e 61 02 3c 	
420007d4:	ac 2d c9 3f 	
420007d8:	0e 56 02 3c 	
420007dc:	e1 55 02 3c 	
420007e0:	e8 55 02 3c 	
420007e4:	ef 55 02 3c 	
420007e8:	a0 86 01 00 	
420007ec:	34 30 c9 3f 	
420007f0:	00 00 00 00 	
420007f4:	74 22 00 40 	
420007f8:	a4 22 00 40 	
420007fc:	34 23 00 40 	
42000800:	84 21 00 40 	
42000804:	d4 22 00 40 	
42000808:	ff 7f 00 00 	
4200080c:	01 00 07 00 	
42000810:	f8 08 c9 3f 	
42000814:	20 72 37 40 	
42000818:	74 dd 02 3c 	
4200081c:	dc 66 00 42 	
42000820:	06 16 00 00 	
42000824:	94 bd 37 40 	
42000828:	44 32 c9 3f 	
4200082c:	94 67 00 42 	
42000830:	6b c5 02 3c 	
42000834:	9f c5 02 3c 	
42000838:	f3 c4 02 3c 	
4200083c:	b8 c4 02 3c 	
42000840:	84 c5 02 3c 	
42000844:	bc c5 02 3c 	
42000848:	07 c5 02 3c 	
4200084c:	07 00 00 80 	
42000850:	b4 21 00 40 	
42000854:	d0 23 00 40 	
42000858:	d8 24 00 40 	
4200085c:	ff ff 3f fc 	
42000860:	ff ff 01 00 	
42000864:	30 0d c9 3f 	
42000868:	a0 1a 00 40 	
4200086c:	55 11 00 18 	
42000870:	f0 cc 02 3c 	
42000874:	01 24 00 18 	
42000878:	34 0d c9 3f 	
4200087c:	18 80 03 60 	
42000880:	c0 21 00 40 	
42000884:	ff f7 ff ff 	
42000888:	50 90 00 60 	
4200088c:	48 d3 02 3c 	
42000890:	60 0d c9 3f 	
42000894:	ff ff 7f ff 	
42000898:	4c 32 c9 3f 	
4200089c:	00 40 00 00 	
420008a0:	40 ad 37 40 	
420008a4:	54 9d 37 40 	
420008a8:	d0 9a 37 40 	
420008ac:	00 10 00 00 	
420008b0:	01 01 04 00 	
420008b4:	48 32 c9 3f 	
420008b8:	00 00 04 00 	
420008bc:	58 0d c9 3f 	
420008c0:	ff ef ff ff 	
420008c4:	ff df ff ff 	
420008c8:	80 9c 37 40 	
420008cc:	08 9d 37 40 	
420008d0:	a4 9b 37 40 	
420008d4:	18 a9 37 40 	
420008d8:	f8 9e 37 40 	
420008dc:	00 2d 31 01 	
420008e0:	a4 5f 37 40 	
420008e4:	c8 5f 37 40 	
420008e8:	d0 aa 37 40 	
420008ec:	88 9d 37 40 	
420008f0:	94 1a 00 40 	
420008f4:	ff ff 07 00 	
420008f8:	14 c6 02 3c 	
420008fc:	a8 c6 02 3c 	
42000900:	98 c6 02 3c 	
42000904:	34 b3 37 40 	
42000908:	44 9c 37 40 	
4200090c:	b8 9c 37 40 	
42000910:	a0 c6 02 3c 	
42000914:	e0 6f 00 42 	
42000918:	54 5f 37 40 	
4200091c:	3c 9a 37 40 	
42000920:	50 a6 37 40 	
42000924:	e4 ff ce 3f 	
42000928:	50 74 37 40 	
4200092c:	5c 32 c9 3f 	
42000930:	7a c7 02 3c 	
42000934:	30 c9 02 3c 	
42000938:	ae c7 02 3c 	
4200093c:	54 ac 37 40 	
42000940:	b0 a8 37 40 	
42000944:	ff ff ff 41 	
42000948:	44 c9 02 3c 	
4200094c:	91 ca 02 3c 	
42000950:	5d c9 02 3c 	
42000954:	00 14 03 18 	
42000958:	5c 19 00 40 	
4200095c:	68 19 00 40 	
42000960:	48 77 37 40 	
42000964:	03 60 00 00 	
42000968:	74 34 c9 3f 	
4200096c:	98 7c 37 40 	
42000970:	00 30 00 60 	
42000974:	38 1a c9 3f 	
42000978:	18 1a c9 3f 	
4200097c:	74 1f 00 40 	
42000980:	9c 02 38 40 	
42000984:	8c 02 38 40 	
42000988:	c0 eb 37 40 	
4200098c:	50 7d 37 40 	
42000990:	fc 19 c9 3f 	
42000994:	dc 7b 37 40 	
42000998:	94 dc 02 3c 	
4200099c:	88 1a c9 3f 	
420009a0:	60 1a c9 3f 	
420009a4:	bc 0d c9 3f 	
420009a8:	80 34 c9 3f 	
420009ac:	94 7f 37 40 	
420009b0:	84 34 c9 3f 	
420009b4:	67 cb 02 3c 	
420009b8:	82 cb 02 3c 	
420009bc:	3c cb 02 3c 	
420009c0:	b8 34 c9 3f 	
420009c4:	b0 34 c9 3f 	
420009c8:	98 34 c9 3f 	
420009cc:	90 34 c9 3f 	
420009d0:	88 34 c9 3f 	
420009d4:	a8 34 c9 3f 	
420009d8:	a0 34 c9 3f 	
420009dc:	78 bc 37 40 	
420009e0:	e4 ba 37 40 	
420009e4:	04 bb 37 40 	
420009e8:	28 bb 37 40 	
420009ec:	d9 cb 02 3c 	
420009f0:	a8 1c c9 3f 	
420009f4:	58 1b c9 3f 	
420009f8:	00 1c c9 3f 	
420009fc:	70 80 37 40 	
42000a00:	65 26 02 3c 	
42000a04:	e8 cb 02 3c 	
42000a08:	cf cb 02 3c 	
42000a0c:	ac a5 37 40 	
42000a10:	c0 34 c9 3f 	
42000a14:	c4 0d c9 3f 	
42000a18:	88 e9 37 40 	
42000a1c:	f5 cb 02 3c 	
42000a20:	d2 cc 02 3c 	
42000a24:	28 cc 02 3c 	
42000a28:	c4 34 c9 3f 	
42000a2c:	48 c2 37 40 	
42000a30:	58 56 37 40 	
42000a34:	00 00 00 00 	
42000a38:	33 cc 02 3c 	
42000a3c:	c5 cc 02 3c 	
42000a40:	64 bc 37 40 	
42000a44:	b0 5a 37 40 	
42000a48:	60 80 37 40 	
42000a4c:	50 80 37 40 	
42000a50:	42 cc 02 3c 	
42000a54:	b6 cc 02 3c 	
42000a58:	53 cc 02 3c 	
42000a5c:	04 cc 02 3c 	
42000a60:	b4 8d 00 42 	
42000a64:	76 cc 02 3c 	
42000a68:	44 b3 37 40 	
42000a6c:	7c 8b 00 42 	
42000a70:	d0 34 c9 3f 	
42000a74:	c8 34 c9 3f 	
42000a78:	ff ff cf ff 	
42000a7c:	ff ff 0f ff 	
42000a80:	ff 0f f0 ff 	
42000a84:	7f 00 fe ff 	
42000a88:	ff 03 f0 ff 	
42000a8c:	ff ff 01 f8 	
42000a90:	50 22 00 40 	
42000a94:	00 20 00 60 	
42000a98:	00 40 02 60 	
42000a9c:	00 50 02 60 	
42000aa0:	00 b4 c4 04 	
42000aa4:	d3 4d 62 10 	
42000aa8:	cc 0d c9 3f 	
42000aac:	d8 34 c9 3f 	
42000ab0:	d4 34 c9 3f 	
42000ab4:	48 8c 37 40 	
42000ab8:	40 91 37 40 	
42000abc:	90 d3 02 3c 	
42000ac0:	d6 d3 02 3c 	
42000ac4:	c8 d3 02 3c 	
42000ac8:	68 8c 37 40 	
42000acc:	dc 34 c9 3f 	
42000ad0:	ec 93 00 42 	
42000ad4:	98 dc 02 3c 	
42000ad8:	f4 dc 02 3c 	
42000adc:	db dc 02 3c 	
42000ae0:	e9 dc 02 3c 	
42000ae4:	e0 34 c9 3f 	
42000ae8:	e4 34 c9 3f 	
42000aec:	eb eb ff ff 	
42000af0:	aa 50 00 00 	
42000af4:	5c 1c 00 40 	
42000af8:	7c 7a 37 40 	
42000afc:	68 1c 00 40 	
42000b00:	18 75 37 40 	
42000b04:	24 12 00 40 	
42000b08:	74 1c 00 40 	
42000b0c:	e8 7a 37 40 	
42000b10:	2e 09 02 3c 	
42000b14:	60 dd 02 3c 	
42000b18:	31 dd 02 3c 	
42000b1c:	3d dd 02 3c 	
42000b20:	4e dd 02 3c 	
42000b24:	9c 75 00 88 	
42000b28:	3c e4 37 7e 	
42000b2c:	ff ff 0f 00 	
42000b30:	a0 23 00 40 	
42000b34:	34 c2 37 40 	
42000b38:	f4 a6 00 42 	
42000b3c:	30 a7 00 42 	
42000b40:	68 a7 00 42 	
42000b44:	a0 a7 00 42 	
42000b48:	b0 22 01 42 	
42000b4c:	70 6f 37 40 	
42000b50:	f8 6f 37 40 	
42000b54:	38 e9 37 40 	
42000b58:	e8 98 00 42 	
42000b5c:	01 00 ff ff 	
42000b60:	18 6f 37 40 	
42000b64:	f8 98 00 42 	
42000b68:	14 99 00 42 	
42000b6c:	3c 6f 37 40 	
42000b70:	d4 dd 02 3c 	
42000b74:	b4 dd 02 3c 	
42000b78:	94 dd 02 3c 	
42000b7c:	df f7 ff ff 	
42000b80:	44 e9 37 40 	
42000b84:	80 ff ff 7f 	
42000b88:	fe ff ff 7f 	
42000b8c:	50 e9 37 40 	
42000b90:	00 12 00 40 	
42000b94:	44 13 00 40 	
42000b98:	d4 a4 00 42 	
42000b9c:	c4 e7 02 3c 	
42000ba0:	58 e7 02 3c 	
42000ba4:	ec e6 02 3c 	
42000ba8:	f4 dd 02 3c 	
42000bac:	21 08 12 00 	
42000bb0:	14 de 02 3c 	
42000bb4:	74 de 02 3c 	
42000bb8:	8c de 02 3c 	
42000bbc:	30 e0 02 3c 	
42000bc0:	34 e0 02 3c 	
42000bc4:	38 e0 02 3c 	
42000bc8:	3c e0 02 3c 	
42000bcc:	40 e0 02 3c 	
42000bd0:	51 e0 02 3c 	
42000bd4:	a4 de 02 3c 	
42000bd8:	ff ff ff ff 	
42000bdc:	ff ff ef 7f 	
42000be0:	00 00 c0 3f 	
42000be4:	00 00 30 40 	
42000be8:	00 00 e0 3f 	
42000bec:	20 e0 02 3c 	
42000bf0:	10 e0 02 3c 	
42000bf4:	bd 28 02 3c 	
42000bf8:	8c 25 00 40 	
42000bfc:	b8 23 00 40 	
42000c00:	dc 23 00 40 	
42000c04:	18 24 00 40 	
42000c08:	8c 22 00 40 	
42000c0c:	fc 24 00 40 	
42000c10:	6c 24 00 40 	
42000c14:	74 25 00 40 	
42000c18:	38 70 37 40 	
42000c1c:	64 e0 02 3c 	
42000c20:	84 e0 02 3c 	
42000c24:	e4 e0 02 3c 	
42000c28:	fc e0 02 3c 	
42000c2c:	30 e0 02 3c 	
42000c30:	34 e0 02 3c 	
42000c34:	38 e0 02 3c 	
42000c38:	3c e0 02 3c 	
42000c3c:	40 e0 02 3c 	
42000c40:	51 e0 02 3c 	
42000c44:	14 e1 02 3c 	
42000c48:	90 e2 02 3c 	
42000c4c:	80 e2 02 3c 	
42000c50:	bd 28 02 3c 	
42000c54:	a0 e2 02 3c 	
42000c58:	a8 e2 02 3c 	
42000c5c:	a9 e2 02 3c 	
42000c60:	ac e2 02 3c 	
42000c64:	bd 28 02 3c 	
42000c68:	ad e2 02 3c 	
42000c6c:	c4 e2 02 3c 	
42000c70:	0f 27 00 00 	
42000c74:	be 28 02 3c 	
42000c78:	00 00 f8 3f 	
42000c7c:	61 43 6f 63 	
42000c80:	a7 87 d2 3f 	
42000c84:	b3 c8 60 8b 	
42000c88:	28 8a c6 3f 	
42000c8c:	fb 79 9f 50 	
42000c90:	13 44 d3 3f 	
42000c94:	e8 e3 02 3c 	
42000c98:	1c e3 02 3c 	
42000c9c:	c0 e3 02 3c 	
42000ca0:	00 00 f0 3f 	
42000ca4:	00 00 24 40 	
42000ca8:	00 00 1c 40 	
42000cac:	00 00 14 40 	
42000cb0:	64 23 00 40 	
42000cb4:	88 23 00 40 	
42000cb8:	fe ff bf df 	
42000cbc:	24 25 01 42 	
42000cc0:	d4 0d c9 3f 	
42000cc4:	ad e2 02 3c 	
42000cc8:	2d e3 02 3c 	
42000ccc:	64 e9 37 40 	
42000cd0:	1c e3 02 3c 	
42000cd4:	39 8e e3 38 	
42000cd8:	88 e3 02 3c 	
42000cdc:	00 00 50 43 	
42000ce0:	ff ff 0f 80 	
42000ce4:	b0 e4 02 3c 	
42000ce8:	d0 e4 02 3c 	
42000cec:	30 e5 02 3c 	
42000cf0:	48 e5 02 3c 	
42000cf4:	51 e0 02 3c 	
42000cf8:	40 e0 02 3c 	
42000cfc:	60 e5 02 3c 	
42000d00:	dc e6 02 3c 	
42000d04:	cc e6 02 3c 	
42000d08:	c4 e8 02 3c 	
42000d0c:	e4 e8 02 3c 	
42000d10:	44 e9 02 3c 	
42000d14:	5c e9 02 3c 	
42000d18:	51 e0 02 3c 	
42000d1c:	40 e0 02 3c 	
42000d20:	74 e9 02 3c 	
42000d24:	f0 ea 02 3c 	
42000d28:	e0 ea 02 3c 	
42000d2c:	5c 17 02 3c 	
42000d30:	c4 17 02 3c 	
42000d34:	a8 17 02 3c 	
42000d38:	08 18 02 3c 	
42000d3c:	b0 17 02 3c 	
42000d40:	18 0d c9 3f 	
42000d44:	10 0d c9 3f 	
42000d48:	08 0d c9 3f 	
42000d4c:	00 0d c9 3f 	
42000d50:	59 2a 00 00 	
42000d54:	c5 27 00 00 	
42000d58:	90 80 00 60 	
42000d5c:	34 80 00 60 	
42000d60:	1c 80 00 60 	
42000d64:	3f c0 ff ff 	
42000d68:	2c 80 00 60 	
42000d6c:	ff 00 ff ff 	
42000d70:	24 80 00 60 	
42000d74:	ff 01 ff ff 	
42000d78:	ff ff 00 fe 	
42000d7c:	30 80 00 60 	
42000d80:	28 80 00 60 	
42000d84:	20 80 00 60 	
42000d88:	ff 7f 00 ff 	
42000d8c:	28 0d c9 3f 	
42000d90:	20 0d c9 3f 	
42000d94:	ec 1b 02 3c 	
42000d98:	32 1c 02 3c 	
42000d9c:	27 1c 02 3c 	
42000da0:	00 70 00 60 	
42000da4:	c7 32 00 00 	
42000da8:	f8 0c c9 3f 	
42000dac:	74 06 c9 3f 	
42000db0:	6c 06 c9 3f 	
42000db4:	70 06 c9 3f 	
42000db8:	68 06 c9 3f 	
42000dbc:	2c 41 0c 60 	
42000dc0:	a8 60 02 60 	
42000dc4:	08 40 0c 60 	
42000dc8:	68 40 0c 60 	
42000dcc:	e8 30 00 60 	
42000dd0:	e8 20 00 60 	
42000dd4:	74 80 00 60 	
42000dd8:	88 80 00 60 	
42000ddc:	ff ff f7 ff 	
42000de0:	84 80 00 60 	
42000de4:	ff ff ff df 	
42000de8:	ff ff ff ef 	
42000dec:	14 00 0c 60 	
42000df0:	ff ff ef ff 	
42000df4:	94 80 00 60 	
42000df8:	ff ff ff cf 	
42000dfc:	ff ff 3f ff 	
42000e00:	ff ff ff f3 	
42000e04:	ff ff ff fc 	
42000e08:	10 00 0c 60 	
42000e0c:	54 02 38 40 	
42000e10:	9c 86 37 40 	
42000e14:	f4 90 37 40 	
42000e18:	f8 89 37 40 	
42000e1c:	98 62 37 40 	
42000e20:	88 8c 37 40 	
42000e24:	74 26 c9 3f 	
42000e28:	f0 c7 37 40 	
42000e2c:	84 c3 37 40 	
42000e30:	bc 27 c9 3f 	
42000e34:	b4 c4 37 40 	
42000e38:	dc c7 37 40 	
42000e3c:	b8 27 c9 3f 	
42000e40:	88 13 00 00 	
42000e44:	40 26 02 3c 	
42000e48:	04 27 02 3c 	
42000e4c:	74 26 02 3c 	
42000e50:	21 0e 02 3c 	
42000e54:	73 0e 02 3c 	
42000e58:	41 0e 02 3c 	
42000e5c:	70 e7 37 40 	
42000e60:	18 8d 01 42 	
42000e64:	5c dc 37 40 	
42000e68:	84 e0 37 40 	
42000e6c:	48 dd 37 40 	
42000e70:	6c dc 37 40 	
42000e74:	8c 0e 02 3c 	
42000e78:	91 0e 02 3c 	
42000e7c:	96 0e 02 3c 	
42000e80:	3c 8d 01 42 	
42000e84:	ac 0e 02 3c 	
42000e88:	26 15 02 3c 	
42000e8c:	dd 0e 02 3c 	
42000e90:	f4 0e 02 3c 	
42000e94:	28 0f 02 3c 	
42000e98:	65 0f 02 3c 	
42000e9c:	14 15 02 3c 	
42000ea0:	b0 0f 02 3c 	
42000ea4:	b7 0f 02 3c 	
42000ea8:	68 dd 37 40 	
42000eac:	28 11 02 3c 	
42000eb0:	5a 11 02 3c 	
42000eb4:	f0 14 02 3c 	

42000eb8 <esp_init_app_elf_sha256>:
{
42000eb8:	004136        	entry	a1, 32
    esp_app_get_elf_sha256(NULL, 0);
42000ebb:	0b0c      	movi.n	a11, 0
42000ebd:	0bad      	mov.n	a10, a11
42000ebf:	fc5881        	l32r	a8, 42000020 <_stext>
42000ec2:	0008e0        	callx8	a8
}
42000ec5:	f01d      	retw.n
	...

42000ec8 <esp_pthread_cfg_key_destructor>:


static int pthread_mutex_lock_internal(esp_pthread_mutex_t *mux, TickType_t tmo);

static void esp_pthread_cfg_key_destructor(void *value)
{
42000ec8:	004136        	entry	a1, 32
    free(value);
42000ecb:	20a220        	or	a10, a2, a2
42000ece:	fc5581        	l32r	a8, 42000024 <_stext+0x4>
42000ed1:	0008e0        	callx8	a8
}
42000ed4:	f01d      	retw.n
	...

42000ed8 <esp_pthread_init>:

esp_err_t esp_pthread_init(void)
{
42000ed8:	004136        	entry	a1, 32
    if (pthread_key_create(&s_pthread_cfg_key, esp_pthread_cfg_key_destructor) != 0) {
42000edb:	fc5431        	l32r	a3, 4200002c <_stext+0xc>
42000ede:	fc52b1        	l32r	a11, 42000028 <_stext+0x8>
42000ee1:	20a330        	or	a10, a3, a3
42000ee4:	000525        	call8	42000f38 <pthread_key_create>
42000ee7:	202aa0        	or	a2, a10, a10
42000eea:	3adc      	bnez.n	a10, 42000f01 <esp_pthread_init+0x29>
        return ESP_ERR_NO_MEM;
    }
    s_threads_mux = xSemaphoreCreateMutex();
42000eec:	1a0c      	movi.n	a10, 1
42000eee:	fc5181        	l32r	a8, 42000034 <_stext+0x14>
42000ef1:	0008e0        	callx8	a8
42000ef4:	fc4f81        	l32r	a8, 42000030 <_stext+0x10>
42000ef7:	08a9      	s32i.n	a10, a8, 0
    if (s_threads_mux == NULL) {
42000ef9:	7acc      	bnez.n	a10, 42000f04 <esp_pthread_init+0x2c>
        pthread_key_delete(s_pthread_cfg_key);
42000efb:	0023a2        	l32i	a10, a3, 0
42000efe:	000825        	call8	42000f80 <pthread_key_delete>
        return ESP_ERR_NO_MEM;
42000f01:	01a122        	movi	a2, 0x101
        return ESP_ERR_NO_MEM;
    }
    return ESP_OK;
}
42000f04:	f01d      	retw.n
	...

42000f08 <find_key>:
    portEXIT_CRITICAL(&s_keys_lock);
    return 0;
}

static key_entry_t *find_key(pthread_key_t key)
{
42000f08:	004136        	entry	a1, 32
42000f0b:	fc4b31        	l32r	a3, 42000038 <_stext+0x18>
42000f0e:	fb7c      	movi.n	a11, -1
42000f10:	03ad      	mov.n	a10, a3
42000f12:	fc4b81        	l32r	a8, 42000040 <_stext+0x20>
42000f15:	0008e0        	callx8	a8
42000f18:	024d      	mov.n	a4, a2
    portENTER_CRITICAL(&s_keys_lock);
    key_entry_t *result = NULL;;
    SLIST_FOREACH(result, &s_keys, next) {
42000f1a:	fc4821        	l32r	a2, 4200003c <_stext+0x1c>
42000f1d:	0228      	l32i.n	a2, a2, 0
42000f1f:	92cc      	bnez.n	a2, 42000f2c <find_key+0x24>
        if(result->key == key) {
            break;
        }
    }
    portEXIT_CRITICAL(&s_keys_lock);
42000f21:	03ad      	mov.n	a10, a3
42000f23:	fc4881        	l32r	a8, 42000044 <_stext+0x24>
42000f26:	0008e0        	callx8	a8
    return result;
}
42000f29:	f01d      	retw.n
42000f2b:	00          	.byte 00
        if(result->key == key) {
42000f2c:	0288      	l32i.n	a8, a2, 0
42000f2e:	ef1847        	beq	a8, a4, 42000f21 <find_key+0x19>
    SLIST_FOREACH(result, &s_keys, next) {
42000f31:	2228      	l32i.n	a2, a2, 8
42000f33:	fffa06        	j	42000f1f <find_key+0x17>
	...

42000f38 <pthread_key_create>:
{
42000f38:	004136        	entry	a1, 32
    key_entry_t *new_key = malloc(sizeof(key_entry_t));
42000f3b:	0ca0a2        	movi	a10, 12
42000f3e:	fc4281        	l32r	a8, 42000048 <_stext+0x28>
42000f41:	0008e0        	callx8	a8
42000f44:	0a4d      	mov.n	a4, a10
        return ENOMEM;
42000f46:	c80c      	movi.n	a8, 12
    if (new_key == NULL) {
42000f48:	eaac      	beqz.n	a10, 42000f7a <pthread_key_create+0x42>
42000f4a:	fc3b51        	l32r	a5, 42000038 <_stext+0x18>
42000f4d:	fb7c      	movi.n	a11, -1
42000f4f:	20a550        	or	a10, a5, a5
42000f52:	fc3b81        	l32r	a8, 42000040 <_stext+0x20>
42000f55:	0008e0        	callx8	a8
    const key_entry_t *head = SLIST_FIRST(&s_keys);
42000f58:	fc39a1        	l32r	a10, 4200003c <_stext+0x1c>
    new_key->key = (head == NULL) ? 1 : (head->key + 1);
42000f5b:	180c      	movi.n	a8, 1
    const key_entry_t *head = SLIST_FIRST(&s_keys);
42000f5d:	0a98      	l32i.n	a9, a10, 0
    new_key->key = (head == NULL) ? 1 : (head->key + 1);
42000f5f:	398c      	beqz.n	a9, 42000f66 <pthread_key_create+0x2e>
42000f61:	0988      	l32i.n	a8, a9, 0
42000f63:	01c882        	addi	a8, a8, 1
    *key = new_key->key;
42000f66:	0289      	s32i.n	a8, a2, 0
    new_key->key = (head == NULL) ? 1 : (head->key + 1);
42000f68:	0489      	s32i.n	a8, a4, 0
    SLIST_INSERT_HEAD(&s_keys, new_key, next);
42000f6a:	0a49      	s32i.n	a4, a10, 0
    new_key->destructor = destructor;
42000f6c:	1439      	s32i.n	a3, a4, 4
    SLIST_INSERT_HEAD(&s_keys, new_key, next);
42000f6e:	2499      	s32i.n	a9, a4, 8
    portEXIT_CRITICAL(&s_keys_lock);
42000f70:	05ad      	mov.n	a10, a5
42000f72:	fc3481        	l32r	a8, 42000044 <_stext+0x24>
42000f75:	0008e0        	callx8	a8
    return 0;
42000f78:	080c      	movi.n	a8, 0
}
42000f7a:	082d      	mov.n	a2, a8
42000f7c:	f01d      	retw.n
	...

42000f80 <pthread_key_delete>:

int pthread_key_delete(pthread_key_t key)
{
42000f80:	004136        	entry	a1, 32
42000f83:	fc2d31        	l32r	a3, 42000038 <_stext+0x18>
42000f86:	ffafb2        	movi	a11, -1
42000f89:	20a330        	or	a10, a3, a3
42000f8c:	fc2d81        	l32r	a8, 42000040 <_stext+0x20>
42000f8f:	0008e0        	callx8	a8

    /* Ideally, we would also walk all tasks' thread local storage value_list here
       and delete any values associated with this key. We do not do this...
    */

    key_entry_t *entry = find_key(key);
42000f92:	20a220        	or	a10, a2, a2
42000f95:	fff725        	call8	42000f08 <find_key>
    if (entry != NULL) {
42000f98:	0a9c      	beqz.n	a10, 42000fac <pthread_key_delete+0x2c>
        SLIST_REMOVE(&s_keys, entry, key_entry_t_, next);
42000f9a:	fc28b1        	l32r	a11, 4200003c <_stext+0x1c>
42000f9d:	2a98      	l32i.n	a9, a10, 8
42000f9f:	0b88      	l32i.n	a8, a11, 0
42000fa1:	1398a7        	bne	a8, a10, 42000fb8 <pthread_key_delete+0x38>
42000fa4:	0b99      	s32i.n	a9, a11, 0
        free(entry);
42000fa6:	fc1f81        	l32r	a8, 42000024 <_stext+0x4>
42000fa9:	0008e0        	callx8	a8
    }

    portEXIT_CRITICAL(&s_keys_lock);
42000fac:	03ad      	mov.n	a10, a3
42000fae:	fc2581        	l32r	a8, 42000044 <_stext+0x24>
42000fb1:	0008e0        	callx8	a8

    return 0;
}
42000fb4:	020c      	movi.n	a2, 0
42000fb6:	f01d      	retw.n
        SLIST_REMOVE(&s_keys, entry, key_entry_t_, next);
42000fb8:	08bd      	mov.n	a11, a8
42000fba:	2888      	l32i.n	a8, a8, 8
42000fbc:	f898a7        	bne	a8, a10, 42000fb8 <pthread_key_delete+0x38>
42000fbf:	2b99      	s32i.n	a9, a11, 8
42000fc1:	fff846        	j	42000fa6 <pthread_key_delete+0x26>

42000fc4 <core_intr_matrix_clear>:
{
42000fc4:	004136        	entry	a1, 32
42000fc7:	03eb40        	rsr.prid	a4
42000fca:	044d40        	extui	a4, a4, 13, 1
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
42000fcd:	020c      	movi.n	a2, 0
42000fcf:	63a032        	movi	a3, 99
        esp_rom_route_intr_matrix(core_id, i, ETS_INVALID_INUM);
42000fd2:	02bd      	mov.n	a11, a2
42000fd4:	6c0c      	movi.n	a12, 6
42000fd6:	04ad      	mov.n	a10, a4
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
42000fd8:	221b      	addi.n	a2, a2, 1
        esp_rom_route_intr_matrix(core_id, i, ETS_INVALID_INUM);
42000fda:	fc1c81        	l32r	a8, 4200004c <_stext+0x2c>
42000fdd:	0008e0        	callx8	a8
    for (int i = 0; i < ETS_MAX_INTR_SOURCE; i++) {
42000fe0:	ee9237        	bne	a2, a3, 42000fd2 <core_intr_matrix_clear+0xe>
}
42000fe3:	f01d      	retw.n
42000fe5:	000000        	ill

42000fe8 <startup_resume_other_cores>:
{
42000fe8:	004136        	entry	a1, 32
    s_resume_cores = true;
42000feb:	fc1981        	l32r	a8, 42000050 <_stext+0x30>
42000fee:	190c      	movi.n	a9, 1
42000ff0:	0020c0        	memw
42000ff3:	004892        	s8i	a9, a8, 0
}
42000ff6:	f01d      	retw.n

42000ff8 <select_rtc_slow_clk>:
    // Re calculate the ccount to make time calculation correct.
    esp_cpu_set_cycle_count( (uint64_t)esp_cpu_get_cycle_count() * new_freq_mhz / old_freq_mhz );
}

static void select_rtc_slow_clk(slow_clk_sel_t slow_clk)
{
42000ff8:	004136        	entry	a1, 32
    soc_rtc_slow_clk_src_t rtc_slow_clk_src = slow_clk & RTC_CNTL_ANA_CLK_RTC_SEL_V;
42000ffb:	023d      	mov.n	a3, a2
    uint32_t cal_val = 0;
    /* number of times to repeat 32k XTAL calibration
     * before giving up and switching to the internal RC
     */
    int retry_32k_xtal = RTC_XTAL_CAL_RETRY;
42000ffd:	140c      	movi.n	a4, 1
                if (cal_val == 0) {
                    if (retry_32k_xtal-- > 0) {
                        continue;
                    }
                    ESP_EARLY_LOGW(TAG, "32 kHz XTAL not found, switching to internal 150 kHz oscillator");
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
42000fff:	050c      	movi.n	a5, 0
        if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
42001001:	201366        	bnei	a3, 1, 42001025 <select_rtc_slow_clk+0x2d>
                rtc_clk_32k_enable(true);
42001004:	036d      	mov.n	a6, a3
            if (slow_clk == SLOW_CLK_32K_XTAL) {
42001006:	071266        	bnei	a2, 1, 42001011 <select_rtc_slow_clk+0x19>
                rtc_clk_32k_enable(true);
42001009:	06ad      	mov.n	a10, a6
4200100b:	fc1281        	l32r	a8, 42000054 <_stext+0x34>
4200100e:	0008e0        	callx8	a8
                cal_val = rtc_clk_cal(RTC_CAL_32K_XTAL, SLOW_CLK_CAL_CYCLES);
42001011:	00a4b2        	movi	a11, 0x400
42001014:	2a0c      	movi.n	a10, 2
42001016:	fc1081        	l32r	a8, 42000058 <_stext+0x38>
42001019:	0008e0        	callx8	a8
                if (cal_val == 0) {
4200101c:	5acc      	bnez.n	a10, 42001025 <select_rtc_slow_clk+0x2d>
                    if (retry_32k_xtal-- > 0) {
4200101e:	221426        	beqi	a4, 1, 42001044 <select_rtc_slow_clk+0x4c>
42001021:	440b      	addi.n	a4, a4, -1
                    rtc_slow_clk_src = SOC_RTC_SLOW_CLK_SRC_RC_SLOW;
42001023:	053d      	mov.n	a3, a5
                }
            }
        } else if (rtc_slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
            rtc_clk_8m_enable(true, true);
        }
        rtc_clk_slow_src_set(rtc_slow_clk_src);
42001025:	20a330        	or	a10, a3, a3
42001028:	fc0d81        	l32r	a8, 4200005c <_stext+0x3c>
4200102b:	0008e0        	callx8	a8

        if (SLOW_CLK_CAL_CYCLES > 0) {
            /* TODO: 32k XTAL oscillator has some frequency drift at startup.
             * Improve calibration routine to wait until the frequency is stable.
             */
            cal_val = rtc_clk_cal(RTC_CAL_RTC_MUX, SLOW_CLK_CAL_CYCLES);
4200102e:	00a4b2        	movi	a11, 0x400
42001031:	20a550        	or	a10, a5, a5
42001034:	fc0981        	l32r	a8, 42000058 <_stext+0x38>
42001037:	0008e0        	callx8	a8
        } else {
            const uint64_t cal_dividend = (1ULL << RTC_CLK_CAL_FRACT) * 1000000ULL;
            cal_val = (uint32_t) (cal_dividend / rtc_clk_slow_freq_get_hz());
        }
    } while (cal_val == 0);
4200103a:	fc3a16        	beqz	a10, 42001001 <select_rtc_slow_clk+0x9>
    ESP_EARLY_LOGD(TAG, "RTC_SLOW_CLK calibration value: %d", cal_val);
    esp_clk_slowclk_cal_set(cal_val);
4200103d:	015d65        	call8	42002614 <esp_clk_slowclk_cal_set>
}
42001040:	000090        	retw
42001043:	00          	.byte 00
                    if (retry_32k_xtal-- > 0) {
42001044:	0a4d      	mov.n	a4, a10
42001046:	ffef06        	j	42001006 <select_rtc_slow_clk+0xe>
42001049:	000000        	ill

4200104c <esp_clk_init>:
{
4200104c:	00a136        	entry	a1, 80
    rtc_config_t cfg = RTC_CONFIG_DEFAULT();
4200104f:	fc0421        	l32r	a2, 42000060 <_stext+0x40>
    rst_reas = esp_rom_get_reset_reason(0);
42001052:	00a0a2        	movi	a10, 0
    rtc_config_t cfg = RTC_CONFIG_DEFAULT();
42001055:	002242        	l32i	a4, a2, 0
    rst_reas = esp_rom_get_reset_reason(0);
42001058:	fc0981        	l32r	a8, 4200007c <_stext+0x5c>
4200105b:	0008e0        	callx8	a8
    if (rst_reas == RESET_REASON_CHIP_POWER_ON) {
4200105e:	00a022        	movi	a2, 0
    rtc_init(cfg);
42001061:	fc0091        	l32r	a9, 42000064 <_stext+0x44>
    if (rst_reas == RESET_REASON_CHIP_POWER_ON) {
42001064:	aa0b      	addi.n	a10, a10, -1
42001066:	130c      	movi.n	a3, 1
42001068:	028d      	mov.n	a8, a2
4200106a:	8383a0        	moveqz	a8, a3, a10
    rtc_init(cfg);
4200106d:	018820        	slli	a8, a8, 30
42001070:	10a490        	and	a10, a4, a9
42001073:	20aa80        	or	a10, a10, a8
42001076:	173be5        	call8	42018434 <rtc_init>
    assert(rtc_clk_xtal_freq_get() == RTC_XTAL_FREQ_40M);
42001079:	fc0181        	l32r	a8, 42000080 <_stext+0x60>
4200107c:	0008e0        	callx8	a8
4200107f:	842c      	movi.n	a4, 40
42001081:	101a47        	beq	a10, a4, 42001095 <esp_clk_init+0x49>
42001084:	fbf9d1        	l32r	a13, 42000068 <_stext+0x48>
42001087:	fbf9c1        	l32r	a12, 4200006c <_stext+0x4c>
4200108a:	4b4c      	movi.n	a11, 68
    assert(res);
4200108c:	fbf9a1        	l32r	a10, 42000070 <_stext+0x50>
4200108f:	fbfd81        	l32r	a8, 42000084 <_stext+0x64>
42001092:	0008e0        	callx8	a8
    bool rc_fast_d256_is_enabled = rtc_clk_8md256_enabled();
42001095:	fbfc81        	l32r	a8, 42000088 <_stext+0x68>
42001098:	0008e0        	callx8	a8
    rtc_clk_8m_enable(true, rc_fast_d256_is_enabled);
4200109b:	0abd      	mov.n	a11, a10
4200109d:	03ad      	mov.n	a10, a3
4200109f:	fbfb81        	l32r	a8, 4200008c <_stext+0x6c>
420010a2:	0008e0        	callx8	a8
    rtc_clk_fast_src_set(SOC_RTC_FAST_CLK_SRC_RC_FAST);
420010a5:	03ad      	mov.n	a10, a3
420010a7:	fbfa81        	l32r	a8, 42000090 <_stext+0x70>
420010aa:	0008e0        	callx8	a8
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
420010ad:	fbf131        	l32r	a3, 42000074 <_stext+0x54>
420010b0:	8129      	s32i.n	a2, a1, 32
420010b2:	9139      	s32i.n	a3, a1, 36
    uint32_t stage_timeout_ticks = (uint32_t)(1600ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
420010b4:	fbf881        	l32r	a8, 42000094 <_stext+0x74>
420010b7:	0008e0        	callx8	a8
420010ba:	0a3d      	mov.n	a3, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
420010bc:	20c1a2        	addi	a10, a1, 32
420010bf:	fbf681        	l32r	a8, 42000098 <_stext+0x78>
420010c2:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
420010c5:	20c1a2        	addi	a10, a1, 32
420010c8:	fbf581        	l32r	a8, 4200009c <_stext+0x7c>
420010cb:	0008e0        	callx8	a8
    uint32_t stage_timeout_ticks = (uint32_t)(1600ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
420010ce:	40a6a2        	movi	a10, 0x640
420010d1:	a2b3a0        	muluh	a11, a3, a10
420010d4:	82a3a0        	mull	a10, a3, a10
420010d7:	e8a3c2        	movi	a12, 0x3e8
420010da:	02dd      	mov.n	a13, a2
420010dc:	fbf181        	l32r	a8, 420000a0 <_stext+0x80>
420010df:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
420010e2:	0acd      	mov.n	a12, a10
420010e4:	4d0c      	movi.n	a13, 4
420010e6:	02bd      	mov.n	a11, a2
420010e8:	20c1a2        	addi	a10, a1, 32
420010eb:	fbee81        	l32r	a8, 420000a4 <_stext+0x84>
420010ee:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
420010f1:	20c1a2        	addi	a10, a1, 32
420010f4:	fbed81        	l32r	a8, 420000a8 <_stext+0x88>
420010f7:	0008e0        	callx8	a8
    select_rtc_slow_clk(SLOW_CLK_RTC);
420010fa:	02ad      	mov.n	a10, a2
420010fc:	ffefa5        	call8	42000ff8 <select_rtc_slow_clk>
    stage_timeout_ticks = (uint32_t)((uint64_t)CONFIG_BOOTLOADER_WDT_TIME_MS * rtc_clk_slow_freq_get_hz() / 1000ULL);
420010ff:	fbe581        	l32r	a8, 42000094 <_stext+0x74>
42001102:	0008e0        	callx8	a8
42001105:	0a3d      	mov.n	a3, a10
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001107:	20c1a2        	addi	a10, a1, 32
4200110a:	fbe381        	l32r	a8, 42000098 <_stext+0x78>
4200110d:	0008e0        	callx8	a8
    wdt_hal_feed(&rtc_wdt_ctx);
42001110:	20c1a2        	addi	a10, a1, 32
42001113:	fbe281        	l32r	a8, 4200009c <_stext+0x7c>
42001116:	0008e0        	callx8	a8
    stage_timeout_ticks = (uint32_t)((uint64_t)CONFIG_BOOTLOADER_WDT_TIME_MS * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001119:	65a4a2        	movi	a10, 0x465
4200111c:	11aad0        	slli	a10, a10, 3
4200111f:	a2b3a0        	muluh	a11, a3, a10
42001122:	82a3a0        	mull	a10, a3, a10
42001125:	e8a3c2        	movi	a12, 0x3e8
42001128:	20d220        	or	a13, a2, a2
4200112b:	fbdd81        	l32r	a8, 420000a0 <_stext+0x80>
4200112e:	0008e0        	callx8	a8
    wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_RTC);
42001131:	0acd      	mov.n	a12, a10
42001133:	02bd      	mov.n	a11, a2
42001135:	4d0c      	movi.n	a13, 4
42001137:	20c1a2        	addi	a10, a1, 32
4200113a:	fbda81        	l32r	a8, 420000a4 <_stext+0x84>
4200113d:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001140:	20c1a2        	addi	a10, a1, 32
42001143:	fbd981        	l32r	a8, 420000a8 <_stext+0x88>
42001146:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_get_config(&old_config);
42001149:	10c1a2        	addi	a10, a1, 16
4200114c:	fbd881        	l32r	a8, 420000ac <_stext+0x8c>
4200114f:	0008e0        	callx8	a8
    bool res = rtc_clk_cpu_freq_mhz_to_config(new_freq_mhz, &new_config);
42001152:	01bd      	mov.n	a11, a1
42001154:	f0a0a2        	movi	a10, 240
    const uint32_t old_freq_mhz = old_config.freq_mhz;
42001157:	072142        	l32i	a4, a1, 28
    bool res = rtc_clk_cpu_freq_mhz_to_config(new_freq_mhz, &new_config);
4200115a:	fbd581        	l32r	a8, 420000b0 <_stext+0x90>
4200115d:	0008e0        	callx8	a8
    assert(res);
42001160:	aacc      	bnez.n	a10, 4200116e <esp_clk_init+0x122>
42001162:	fbc5d1        	l32r	a13, 42000078 <_stext+0x58>
42001165:	fbc1c1        	l32r	a12, 4200006c <_stext+0x4c>
42001168:	72a0b2        	movi	a11, 114
4200116b:	ffc746        	j	4200108c <esp_clk_init+0x40>
        esp_rom_uart_tx_wait_idle(CONFIG_ESP_CONSOLE_UART_NUM);
4200116e:	02ad      	mov.n	a10, a2
42001170:	fbd181        	l32r	a8, 420000b4 <_stext+0x94>
42001173:	0008e0        	callx8	a8
        rtc_clk_cpu_freq_set_config(&new_config);
42001176:	01ad      	mov.n	a10, a1
42001178:	fbd081        	l32r	a8, 420000b8 <_stext+0x98>
4200117b:	0008e0        	callx8	a8
    RSR(CCOUNT, ccount);
4200117e:	03eaa0        	rsr.ccount	a10
    esp_cpu_set_cycle_count( (uint64_t)esp_cpu_get_cycle_count() * new_freq_mhz / old_freq_mhz );
42001181:	f0a032        	movi	a3, 240
42001184:	a2ba30        	muluh	a11, a10, a3
42001187:	82aa30        	mull	a10, a10, a3
4200118a:	04cd      	mov.n	a12, a4
4200118c:	02dd      	mov.n	a13, a2
4200118e:	fbc481        	l32r	a8, 420000a0 <_stext+0x80>
42001191:	0008e0        	callx8	a8
    WSR(CCOUNT, ccount);
42001194:	13eaa0        	wsr.ccount	a10
}
42001197:	f01d      	retw.n
42001199:	000000        	ill

4200119c <esp_perip_clk_init>:
 * This function disables some peripheral clocks when cpu starts.
 * These peripheral clocks are enabled when the peripherals are initialized
 * and disabled when they are de-initialized.
 */
__attribute__((weak)) void esp_perip_clk_init(void)
{
4200119c:	004136        	entry	a1, 32
    soc_reset_reason_t rst_reas[1];
#else
    soc_reset_reason_t rst_reas[2];
#endif

    rst_reas[0] = esp_rom_get_reset_reason(0);
4200119f:	00a0a2        	movi	a10, 0
420011a2:	fbb681        	l32r	a8, 4200007c <_stext+0x5c>
420011a5:	0008e0        	callx8	a8
420011a8:	202aa0        	or	a2, a10, a10
#if !CONFIG_FREERTOS_UNICORE
    rst_reas[1] = esp_rom_get_reset_reason(1);
420011ab:	01a0a2        	movi	a10, 1
420011ae:	fbb381        	l32r	a8, 4200007c <_stext+0x5c>
420011b1:	0008e0        	callx8	a8

    /* For reason that only reset CPU, do not disable the clocks
     * that have been enabled before reset.
     */
    if ((rst_reas[0] == RESET_REASON_CPU0_MWDT0 || rst_reas[0] == RESET_REASON_CPU0_SW ||
            rst_reas[0] == RESET_REASON_CPU0_RTC_WDT || rst_reas[0] == RESET_REASON_CPU0_MWDT1)
420011b4:	f5c282        	addi	a8, a2, -11
420011b7:	1e38b6        	bltui	a8, 3, 420011d9 <esp_perip_clk_init+0x3d>
420011ba:	efc222        	addi	a2, a2, -17
420011bd:	180c      	movi.n	a8, 1
420011bf:	090c      	movi.n	a9, 0
420011c1:	839820        	moveqz	a9, a8, a2
    if ((rst_reas[0] == RESET_REASON_CPU0_MWDT0 || rst_reas[0] == RESET_REASON_CPU0_SW ||
420011c4:	742090        	extui	a2, a9, 0, 8
420011c7:	00e956        	bnez	a9, 420011d9 <esp_perip_clk_init+0x3d>
#if !CONFIG_FREERTOS_UNICORE
        || (rst_reas[1] == RESET_REASON_CPU1_MWDT0 || rst_reas[1] == RESET_REASON_CPU1_SW ||
            rst_reas[1] == RESET_REASON_CPU1_RTC_WDT || rst_reas[1] == RESET_REASON_CPU1_MWDT1)
420011ca:	f5ca92        	addi	a9, a10, -11
420011cd:	0839b6        	bltui	a9, 3, 420011d9 <esp_perip_clk_init+0x3d>
420011d0:	efcaa2        	addi	a10, a10, -17
        || (rst_reas[1] == RESET_REASON_CPU1_MWDT0 || rst_reas[1] == RESET_REASON_CPU1_SW ||
420011d3:	9382a0        	movnez	a8, a2, a10
420011d6:	0fe816        	beqz	a8, 420012d8 <esp_perip_clk_init+0x13c>
#endif
       ) {
        common_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN0_REG);
420011d9:	fbb921        	l32r	a2, 420000c0 <_stext+0xa0>
420011dc:	ffaf82        	movi	a8, -1
420011df:	0020c0        	memw
420011e2:	002292        	l32i	a9, a2, 0
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
420011e5:	fbb721        	l32r	a2, 420000c4 <_stext+0xa4>
        common_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN0_REG);
420011e8:	309890        	xor	a9, a8, a9
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
420011eb:	0020c0        	memw
420011ee:	02b8      	l32i.n	a11, a2, 0
        wifi_bt_sdio_clk = ~READ_PERI_REG(SYSTEM_WIFI_CLK_EN_REG);
420011f0:	fbb621        	l32r	a2, 420000c8 <_stext+0xa8>
        hwcrypto_perip_clk = ~READ_PERI_REG(SYSTEM_PERIP_CLK_EN1_REG);
420011f3:	30b8b0        	xor	a11, a8, a11
        wifi_bt_sdio_clk = ~READ_PERI_REG(SYSTEM_WIFI_CLK_EN_REG);
420011f6:	0020c0        	memw
420011f9:	0228      	l32i.n	a2, a2, 0
420011fb:	308820        	xor	a8, a8, a2
                        SYSTEM_SPI2_DMA_CLK_EN |
                        SYSTEM_SPI3_DMA_CLK_EN;
    common_perip_clk1 = 0;

    /* Disable some peripheral clocks. */
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
420011fe:	fbb0c1        	l32r	a12, 420000c0 <_stext+0xa0>
    common_perip_clk |= SYSTEM_I2S0_CLK_EN |
42001201:	fbb221        	l32r	a2, 420000cc <_stext+0xac>
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
42001204:	0020c0        	memw
42001207:	0cd8      	l32i.n	a13, a12, 0
42001209:	fa7c      	movi.n	a10, -1
    common_perip_clk |= SYSTEM_I2S0_CLK_EN |
4200120b:	209920        	or	a9, a9, a2
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN0_REG, common_perip_clk);
4200120e:	302a90        	xor	a2, a10, a9
42001211:	1022d0        	and	a2, a2, a13
42001214:	0020c0        	memw
42001217:	0c29      	s32i.n	a2, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG, common_perip_clk);
42001219:	fbadc1        	l32r	a12, 420000d0 <_stext+0xb0>
     * implementation in the ROM, the reset signal was not cleared when the
     * backup dma was started, which caused the backup dma operation to fail. */
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_PERI_BACKUP_RST);

    /* Disable WiFi/BT/SDIO clocks. */
    CLEAR_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, wifi_bt_sdio_clk);
4200121c:	308a80        	xor	a8, a10, a8
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN0_REG, common_perip_clk);
4200121f:	0020c0        	memw
42001222:	0c28      	l32i.n	a2, a12, 0
42001224:	202290        	or	a2, a2, a9
42001227:	0020c0        	memw
4200122a:	0c29      	s32i.n	a2, a12, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, common_perip_clk1);
4200122c:	fba6c1        	l32r	a12, 420000c4 <_stext+0xa4>
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, common_perip_clk1);
4200122f:	fba991        	l32r	a9, 420000d4 <_stext+0xb4>
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, common_perip_clk1);
42001232:	0020c0        	memw
42001235:	0c28      	l32i.n	a2, a12, 0
42001237:	0020c0        	memw
4200123a:	0c29      	s32i.n	a2, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, common_perip_clk1);
4200123c:	0020c0        	memw
4200123f:	0928      	l32i.n	a2, a9, 0
42001241:	0020c0        	memw
42001244:	0929      	s32i.n	a2, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_CLK_EN1_REG, hwcrypto_perip_clk);
42001246:	0020c0        	memw
42001249:	0cd8      	l32i.n	a13, a12, 0
4200124b:	302ab0        	xor	a2, a10, a11
4200124e:	1022d0        	and	a2, a2, a13
42001251:	0020c0        	memw
42001254:	0c29      	s32i.n	a2, a12, 0
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, hwcrypto_perip_clk);
42001256:	0020c0        	memw
42001259:	0928      	l32i.n	a2, a9, 0
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);

    /* Set WiFi light sleep clock source to RTC slow clock */
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
4200125b:	11aa40        	slli	a10, a10, 12
    SET_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, hwcrypto_perip_clk);
4200125e:	2022b0        	or	a2, a2, a11
42001261:	0020c0        	memw
42001264:	0929      	s32i.n	a2, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_PERIP_RST_EN1_REG, SYSTEM_PERI_BACKUP_RST);
42001266:	0020c0        	memw
42001269:	0928      	l32i.n	a2, a9, 0
4200126b:	eb7c      	movi.n	a11, -2
4200126d:	1022b0        	and	a2, a2, a11
42001270:	0020c0        	memw
42001273:	0929      	s32i.n	a2, a9, 0
    CLEAR_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, wifi_bt_sdio_clk);
42001275:	fb9491        	l32r	a9, 420000c8 <_stext+0xa8>
42001278:	0020c0        	memw
4200127b:	0928      	l32i.n	a2, a9, 0
4200127d:	108820        	and	a8, a8, a2
42001280:	0020c0        	memw
42001283:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);
42001285:	0020c0        	memw
42001288:	0928      	l32i.n	a2, a9, 0
4200128a:	fb9381        	l32r	a8, 420000d8 <_stext+0xb8>
4200128d:	202280        	or	a2, a2, a8
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
42001290:	fb9381        	l32r	a8, 420000dc <_stext+0xbc>
    SET_PERI_REG_MASK(SYSTEM_WIFI_CLK_EN_REG, SYSTEM_WIFI_CLK_EN);
42001293:	0020c0        	memw
42001296:	0929      	s32i.n	a2, a9, 0
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
42001298:	0020c0        	memw
4200129b:	0828      	l32i.n	a2, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_8M);
4200129d:	fb9191        	l32r	a9, 420000e4 <_stext+0xc4>
    REG_SET_FIELD(SYSTEM_BT_LPCK_DIV_INT_REG, SYSTEM_BT_LPCK_DIV_NUM, 0);
420012a0:	1022a0        	and	a2, a2, a10
420012a3:	0020c0        	memw
420012a6:	0829      	s32i.n	a2, a8, 0
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_8M);
420012a8:	fb8e81        	l32r	a8, 420000e0 <_stext+0xc0>
    SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_RTC_SLOW);

    /* Enable RNG clock. */
    periph_module_enable(PERIPH_RNG_MODULE);
420012ab:	9a1c      	movi.n	a10, 25
    CLEAR_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_8M);
420012ad:	0020c0        	memw
420012b0:	0828      	l32i.n	a2, a8, 0
420012b2:	102290        	and	a2, a2, a9
420012b5:	0020c0        	memw
420012b8:	0829      	s32i.n	a2, a8, 0
    SET_PERI_REG_MASK(SYSTEM_BT_LPCK_DIV_FRAC_REG, SYSTEM_LPCLK_SEL_RTC_SLOW);
420012ba:	0020c0        	memw
420012bd:	0828      	l32i.n	a2, a8, 0
420012bf:	190c      	movi.n	a9, 1
420012c1:	019980        	slli	a9, a9, 24
420012c4:	202290        	or	a2, a2, a9
420012c7:	0020c0        	memw
420012ca:	0829      	s32i.n	a2, a8, 0
    periph_module_enable(PERIPH_RNG_MODULE);
420012cc:	01c3a5        	call8	42002f08 <periph_module_enable>
     * being disabled.
     * If the TimerGroup 0 clock is disabled and then reenabled, the watchdog
     * registers (Flashboot protection included) will be reenabled, and some
     * seconds later, will trigger an unintended reset.
     */
    periph_module_enable(PERIPH_TIMG0_MODULE);
420012cf:	aa0c      	movi.n	a10, 10
420012d1:	01c365        	call8	42002f08 <periph_module_enable>
}
420012d4:	f01d      	retw.n
420012d6:	00          	.byte 00
420012d7:	00          	.byte 00
        wifi_bt_sdio_clk = SYSTEM_WIFI_CLK_WIFI_EN |
420012d8:	81a182        	movi	a8, 0x181
        common_perip_clk = SYSTEM_WDG_CLK_EN |
420012db:	fb7891        	l32r	a9, 420000bc <_stext+0x9c>
        wifi_bt_sdio_clk = SYSTEM_WIFI_CLK_WIFI_EN |
420012de:	1188b0        	slli	a8, a8, 5
        hwcrypto_perip_clk = SYSTEM_CRYPTO_AES_CLK_EN |
420012e1:	eb0c      	movi.n	a11, 14
420012e3:	ffc5c6        	j	420011fe <esp_perip_clk_init+0x62>
	...

420012e8 <esp_cache_err_int_init>:
{
420012e8:	004136        	entry	a1, 32
    asm volatile (
420012eb:	03eb20        	rsr.prid	a2
420012ee:	042d20        	extui	a2, a2, 13, 1
    ESP_INTR_DISABLE(ETS_CACHEERR_INUM);
420012f1:	19a0a2        	movi	a10, 25
420012f4:	014aa5        	call8	420027a0 <esp_intr_disable_source>
    esp_rom_route_intr_matrix(core_id, ETS_CACHE_IA_INTR_SOURCE, ETS_CACHEERR_INUM);
420012f7:	19a0c2        	movi	a12, 25
420012fa:	02ad      	mov.n	a10, a2
420012fc:	8b3c      	movi.n	a11, 56
420012fe:	fb5381        	l32r	a8, 4200004c <_stext+0x2c>
42001301:	0008e0        	callx8	a8
 * @param cache_id    Cache ID
 * @param mask        Interrupt mask
 */
static inline void cache_ll_l1_clear_illegal_error_intr(uint32_t cache_id, uint32_t mask)
{
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_CLR_REG, mask);
42001304:	fb7991        	l32r	a9, 420000e8 <_stext+0xc8>
42001307:	fa3c      	movi.n	a10, 63
42001309:	0020c0        	memw
4200130c:	0988      	l32i.n	a8, a9, 0
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE0_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
4200130e:	9c1c      	movi.n	a12, 25
42001310:	2088a0        	or	a8, a8, a10
42001313:	0020c0        	memw
42001316:	0989      	s32i.n	a8, a9, 0
    SET_PERI_REG_MASK(EXTMEM_CACHE_ILG_INT_ENA_REG, mask);
42001318:	fb7591        	l32r	a9, 420000ec <_stext+0xcc>
4200131b:	0020c0        	memw
4200131e:	0988      	l32i.n	a8, a9, 0
42001320:	2088a0        	or	a8, a8, a10
42001323:	0020c0        	memw
42001326:	0989      	s32i.n	a8, a9, 0
    if (core_id == PRO_CPU_NUM) {
42001328:	22fc      	bnez.n	a2, 4200135e <esp_cache_err_int_init+0x76>
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE0_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
4200132a:	02ad      	mov.n	a10, a2
4200132c:	eb5c      	movi.n	a11, 94
4200132e:	fb4781        	l32r	a8, 4200004c <_stext+0x2c>
42001331:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_CLR_REG, mask);
42001334:	fb6f81        	l32r	a8, 420000f0 <_stext+0xd0>
42001337:	f91c      	movi.n	a9, 31
42001339:	0020c0        	memw
4200133c:	0828      	l32i.n	a2, a8, 0
4200133e:	202290        	or	a2, a2, a9
42001341:	0020c0        	memw
42001344:	0829      	s32i.n	a2, a8, 0
        SET_PERI_REG_MASK(EXTMEM_CORE0_ACS_CACHE_INT_ENA_REG, mask);
42001346:	fb6b81        	l32r	a8, 420000f4 <_stext+0xd4>
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
42001349:	0020c0        	memw
4200134c:	0828      	l32i.n	a2, a8, 0
    ESP_INTR_ENABLE(ETS_CACHEERR_INUM);
4200134e:	9a1c      	movi.n	a10, 25
42001350:	202290        	or	a2, a2, a9
42001353:	0020c0        	memw
42001356:	006822        	s32i	a2, a8, 0
42001359:	014325        	call8	4200278c <esp_intr_enable_source>
}
4200135c:	f01d      	retw.n
        esp_rom_route_intr_matrix(core_id, ETS_CACHE_CORE1_ACS_INTR_SOURCE, ETS_CACHEERR_INUM);
4200135e:	02ad      	mov.n	a10, a2
42001360:	fb5c      	movi.n	a11, 95
42001362:	fb3a81        	l32r	a8, 4200004c <_stext+0x2c>
42001365:	0008e0        	callx8	a8
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_CLR_REG, mask);
42001368:	fb6481        	l32r	a8, 420000f8 <_stext+0xd8>
4200136b:	f91c      	movi.n	a9, 31
4200136d:	0020c0        	memw
42001370:	0828      	l32i.n	a2, a8, 0
42001372:	202290        	or	a2, a2, a9
42001375:	0020c0        	memw
42001378:	0829      	s32i.n	a2, a8, 0
        SET_PERI_REG_MASK(EXTMEM_CORE1_ACS_CACHE_INT_ENA_REG, mask);
4200137a:	fb6081        	l32r	a8, 420000fc <_stext+0xdc>
4200137d:	fff206        	j	42001349 <esp_cache_err_int_init+0x61>

42001380 <esp_int_wdt_init>:

void esp_int_wdt_init(void)
{
42001380:	004136        	entry	a1, 32
    periph_module_enable(PERIPH_TIMG1_MODULE);
42001383:	ba0c      	movi.n	a10, 11
42001385:	01b825        	call8	42002f08 <periph_module_enable>
    /*
     * Initialize the WDT timeout stages. Note that the initial timeout is set to 5 seconds as variable startup times of
     * each CPU can lead to a timeout. The tick hooks will set the WDT timers to the actual timeout.
     * Todo: Fix this
     */
    wdt_hal_init(&iwdt_context, IWDT_INSTANCE, IWDT_PRESCALER, true);
42001388:	fb5e21        	l32r	a2, 42000100 <_stext+0xe0>
4200138b:	71a2c2        	movi	a12, 0x271
4200138e:	1d0c      	movi.n	a13, 1
42001390:	11cca0        	slli	a12, a12, 6
42001393:	2b0c      	movi.n	a11, 2
42001395:	20a220        	or	a10, a2, a2
42001398:	fb5b81        	l32r	a8, 42000104 <_stext+0xe4>
4200139b:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&iwdt_context);
4200139e:	02ad      	mov.n	a10, a2
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);
420013a0:	71a232        	movi	a3, 0x271
    wdt_hal_write_protect_disable(&iwdt_context);
420013a3:	fb3d81        	l32r	a8, 42000098 <_stext+0x78>
420013a6:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE0, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_INT);
420013a9:	1133c0        	slli	a3, a3, 4
420013ac:	03cd      	mov.n	a12, a3
420013ae:	02ad      	mov.n	a10, a2
420013b0:	1d0c      	movi.n	a13, 1
420013b2:	0b0c      	movi.n	a11, 0
420013b4:	fb3c81        	l32r	a8, 420000a4 <_stext+0x84>
420013b7:	0008e0        	callx8	a8
    wdt_hal_config_stage(&iwdt_context, WDT_STAGE1, IWDT_INITIAL_TIMEOUT_S * 1000000 / IWDT_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM);
420013ba:	3d0c      	movi.n	a13, 3
420013bc:	03cd      	mov.n	a12, a3
420013be:	1b0c      	movi.n	a11, 1
420013c0:	02ad      	mov.n	a10, a2
420013c2:	fb3881        	l32r	a8, 420000a4 <_stext+0x84>
420013c5:	0008e0        	callx8	a8
    wdt_hal_enable(&iwdt_context);
420013c8:	02ad      	mov.n	a10, a2
420013ca:	fb4f81        	l32r	a8, 42000108 <_stext+0xe8>
420013cd:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&iwdt_context);
420013d0:	02ad      	mov.n	a10, a2
420013d2:	fb3581        	l32r	a8, 420000a8 <_stext+0x88>
420013d5:	0008e0        	callx8	a8
                : [ERI] "=r" (eriadrs), [REG] "+r" (scratch), [IMM] "+r" (immediate)
            );
        }
    }
#endif // (CONFIG_ESP32_ECO3_CACHE_LOCK_FIX && CONFIG_BTDM_CTRL_HLI)
}
420013d8:	f01d      	retw.n
	...

420013dc <esp_int_wdt_cpu_init>:

void esp_int_wdt_cpu_init(void)
{
420013dc:	004136        	entry	a1, 32
420013df:	03ebb0        	rsr.prid	a11
420013e2:	04bdb0        	extui	a11, a11, 13, 1
    assert((CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (portTICK_PERIOD_MS << 1)) && "Interrupt watchdog timeout needs to be at least twice the RTOS tick period!");
    // Register tick hook for current CPU to feed the INT WDT
    esp_register_freertos_tick_hook_for_cpu(tick_hook, esp_cpu_get_core_id());
420013e5:	fb49a1        	l32r	a10, 4200010c <_stext+0xec>
420013e8:	0085e5        	call8	42001c48 <esp_register_freertos_tick_hook_for_cpu>
    /*
     * Register INT WDT interrupt for current CPU. We do this manually as the timeout interrupt should call an assembly
     * panic handler (see riscv/vector.S and xtensa_vectors.S).
     */
    esp_intr_disable_source(ETS_INT_WDT_INUM);
420013eb:	18a0a2        	movi	a10, 24
420013ee:	013b25        	call8	420027a0 <esp_intr_disable_source>
420013f1:	03eba0        	rsr.prid	a10
420013f4:	04ada0        	extui	a10, a10, 13, 1
    esp_rom_route_intr_matrix(esp_cpu_get_core_id(), WDT_LEVEL_INTR_SOURCE, ETS_INT_WDT_INUM);
420013f7:	8c1c      	movi.n	a12, 24
420013f9:	7b3c      	movi.n	a11, 55
420013fb:	fb1481        	l32r	a8, 4200004c <_stext+0x2c>
420013fe:	0008e0        	callx8	a8
        assert((portTICK_PERIOD_MS << 1) <= IWDT_LIVELOCK_TIMEOUT_MS);
        assert(CONFIG_ESP_INT_WDT_TIMEOUT_MS >= (IWDT_LIVELOCK_TIMEOUT_MS * 3));
        _lx_intr_livelock_max = CONFIG_ESP_INT_WDT_TIMEOUT_MS / IWDT_LIVELOCK_TIMEOUT_MS - 1;
    }
#endif
    esp_intr_enable_source(ETS_INT_WDT_INUM);
42001401:	8a1c      	movi.n	a10, 24
42001403:	0138a5        	call8	4200278c <esp_intr_enable_source>
}
42001406:	f01d      	retw.n

42001408 <do_system_init_fn>:
{
42001408:	004136        	entry	a1, 32
4200140b:	03eb40        	rsr.prid	a4
4200140e:	044d40        	extui	a4, a4, 13, 1
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
42001411:	130c      	movi.n	a3, 1
42001413:	fb3f21        	l32r	a2, 42000110 <_stext+0xf0>
42001416:	401400        	ssl	a4
42001419:	a13300        	sll	a3, a3
4200141c:	fb3e51        	l32r	a5, 42000114 <_stext+0xf4>
4200141f:	0f3257        	bltu	a2, a5, 42001432 <do_system_init_fn+0x2a>
    s_system_inited[core_id] = true;
42001422:	fb3d21        	l32r	a2, 42000118 <_stext+0xf8>
42001425:	130c      	movi.n	a3, 1
42001427:	224a      	add.n	a2, a2, a4
42001429:	0020c0        	memw
4200142c:	004232        	s8i	a3, a2, 0
}
4200142f:	f01d      	retw.n
42001431:	00          	.byte 00
        if (p->cores & BIT(core_id)) {
42001432:	1288      	l32i.n	a8, a2, 4
42001434:	0c0387        	bnone	a3, a8, 42001444 <do_system_init_fn+0x3c>
            esp_err_t err = (*(p->fn))();
42001437:	02a8      	l32i.n	a10, a2, 0
42001439:	000ae0        	callx8	a10
            if (err != ESP_OK) {
4200143c:	4a8c      	beqz.n	a10, 42001444 <do_system_init_fn+0x3c>
                abort();
4200143e:	fb3781        	l32r	a8, 4200011c <_stext+0xfc>
42001441:	0008e0        	callx8	a8
    for (p = &_esp_system_init_fn_array_start; p < &_esp_system_init_fn_array_end; ++p) {
42001444:	228b      	addi.n	a2, a2, 8
42001446:	fff486        	j	4200141c <do_system_init_fn+0x14>
42001449:	000000        	ill

4200144c <start_cpu0>:
    }
#endif
}

static void start_cpu0_default(void)
{
4200144c:	006136        	entry	a1, 48

    ESP_EARLY_LOGI(TAG, "Pro cpu start user code");
    int cpu_freq = esp_clk_cpu_freq();
4200144f:	fb4081        	l32r	a8, 42000150 <_stext+0x130>
42001452:	0008e0        	callx8	a8
    heap_caps_init();
42001455:	00dde5        	call8	42002234 <heap_caps_init>
    esp_timer_early_init();
42001458:	034065        	call8	42004860 <esp_timer_early_init>
    esp_newlib_init();
4200145b:	02fe65        	call8	42004440 <esp_newlib_init>
    esp_brownout_init();
4200145e:	0035a5        	call8	420017b8 <esp_brownout_init>
    esp_newlib_time_init();
42001461:	201110        	or	a1, a1, a1
42001464:	031a65        	call8	4200460c <esp_newlib_time_init>
    esp_err_t vfs_err = esp_vfs_console_register();
42001467:	201110        	or	a1, a1, a1
4200146a:	03daa5        	call8	42005214 <esp_vfs_console_register>
    assert(vfs_err == ESP_OK && "Failed to register vfs console");
4200146d:	0a9c      	beqz.n	a10, 42001481 <start_cpu0+0x35>
4200146f:	fb2cd1        	l32r	a13, 42000120 <_stext+0x100>
42001472:	fb2cc1        	l32r	a12, 42000124 <_stext+0x104>
42001475:	2ea1b2        	movi	a11, 0x12e
    assert(err == ESP_OK && "Failed to init pthread module!");
42001478:	fb2ca1        	l32r	a10, 42000128 <_stext+0x108>
4200147b:	fb0281        	l32r	a8, 42000084 <_stext+0x64>
4200147e:	0008e0        	callx8	a8
    esp_reent_init(_GLOBAL_REENT);
42001481:	fb2a21        	l32r	a2, 4200012c <_stext+0x10c>
42001484:	0022a2        	l32i	a10, a2, 0
42001487:	fb3381        	l32r	a8, 42000154 <_stext+0x134>
4200148a:	0008e0        	callx8	a8
    _GLOBAL_REENT->_stdin  = fopen(default_stdio_dev, "r");
4200148d:	fb2931        	l32r	a3, 42000134 <_stext+0x114>
42001490:	fb28b1        	l32r	a11, 42000130 <_stext+0x110>
42001493:	002242        	l32i	a4, a2, 0
42001496:	03ad      	mov.n	a10, a3
42001498:	0873a5        	call8	42009bd4 <fopen>
4200149b:	14a9      	s32i.n	a10, a4, 4
    _GLOBAL_REENT->_stdout = fopen(default_stdio_dev, "w");
4200149d:	fb2641        	l32r	a4, 42000138 <_stext+0x118>
420014a0:	0258      	l32i.n	a5, a2, 0
420014a2:	04bd      	mov.n	a11, a4
420014a4:	03ad      	mov.n	a10, a3
420014a6:	0872e5        	call8	42009bd4 <fopen>
420014a9:	25a9      	s32i.n	a10, a5, 8
    _GLOBAL_REENT->_stderr = fopen(default_stdio_dev, "w");
420014ab:	04bd      	mov.n	a11, a4
420014ad:	0258      	l32i.n	a5, a2, 0
420014af:	03ad      	mov.n	a10, a3
420014b1:	087225        	call8	42009bd4 <fopen>
420014b4:	35a9      	s32i.n	a10, a5, 12
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stdout);
420014b6:	02a8      	l32i.n	a10, a2, 0
420014b8:	2ab8      	l32i.n	a11, a10, 8
420014ba:	0fea65        	call8	42011360 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stderr);
420014bd:	02a8      	l32i.n	a10, a2, 0
420014bf:	3ab8      	l32i.n	a11, a10, 12
420014c1:	0fe9e5        	call8	42011360 <__swsetup_r>
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stdin);
420014c4:	02a8      	l32i.n	a10, a2, 0
420014c6:	1ab8      	l32i.n	a11, a10, 4
420014c8:	0fe965        	call8	42011360 <__swsetup_r>
    err = esp_pthread_init();
420014cb:	ffa0e5        	call8	42000ed8 <esp_pthread_init>
    assert(err == ESP_OK && "Failed to init pthread module!");
420014ce:	aa8c      	beqz.n	a10, 420014dc <start_cpu0+0x90>
420014d0:	fb1bd1        	l32r	a13, 4200013c <_stext+0x11c>
420014d3:	fb14c1        	l32r	a12, 42000124 <_stext+0x104>
420014d6:	4ca1b2        	movi	a11, 0x14c
420014d9:	ffe6c6        	j	42001478 <start_cpu0+0x2c>
    esp_flash_app_init();
420014dc:	072e25        	call8	420087c0 <esp_flash_app_init>
    esp_err_t flash_ret = esp_flash_init_default_chip();
420014df:	0725a5        	call8	42008738 <esp_flash_init_default_chip>
    assert(flash_ret == ESP_OK);
420014e2:	aa8c      	beqz.n	a10, 420014f0 <start_cpu0+0xa4>
420014e4:	fb17d1        	l32r	a13, 42000140 <_stext+0x120>
420014e7:	fb0fc1        	l32r	a12, 42000124 <_stext+0x104>
420014ea:	54a1b2        	movi	a11, 0x154
420014ed:	ffe1c6        	j	42001478 <start_cpu0+0x2c>
    spi_flash_needs_reset_check();
420014f0:	fb1a81        	l32r	a8, 42000158 <_stext+0x138>
420014f3:	0008e0        	callx8	a8
420014f6:	fb1321        	l32r	a2, 42000144 <_stext+0x124>
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
420014f9:	fb1331        	l32r	a3, 42000148 <_stext+0x128>
420014fc:	fcc222        	addi	a2, a2, -4
420014ff:	4db237        	bgeu	a2, a3, 42001550 <start_cpu0+0x104>
    volatile bool system_inited = false;
42001502:	00a022        	movi	a2, 0
    startup_resume_other_cores();
42001505:	ffae25        	call8	42000fe8 <startup_resume_other_cores>
        system_inited = true;
42001508:	140c      	movi.n	a4, 1
    do_system_init_fn();
4200150a:	ffefe5        	call8	42001408 <do_system_init_fn>
    volatile bool system_inited = false;
4200150d:	0020c0        	memw
42001510:	084122        	s8i	a2, a1, 8
    while (!system_inited) {
42001513:	0020c0        	memw
42001516:	080122        	l8ui	a2, a1, 8
42001519:	742020        	extui	a2, a2, 0, 8
4200151c:	82bc      	beqz.n	a2, 42001558 <start_cpu0+0x10c>
    // until all cores finish (when !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE).
    do_secondary_init();

    // Now that the application is about to start, disable boot watchdog
#ifndef CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
4200151e:	020c      	movi.n	a2, 0
42001520:	0129      	s32i.n	a2, a1, 0
42001522:	fad421        	l32r	a2, 42000074 <_stext+0x54>
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001525:	01ad      	mov.n	a10, a1
    wdt_hal_context_t rtc_wdt_ctx = {.inst = WDT_RWDT, .rwdt_dev = &RTCCNTL};
42001527:	1129      	s32i.n	a2, a1, 4
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001529:	fadb81        	l32r	a8, 42000098 <_stext+0x78>
4200152c:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
4200152f:	01ad      	mov.n	a10, a1
42001531:	fb0a81        	l32r	a8, 4200015c <_stext+0x13c>
42001534:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001537:	01ad      	mov.n	a10, a1
42001539:	fadb81        	l32r	a8, 420000a8 <_stext+0x88>
4200153c:	0008e0        	callx8	a8
#endif

#if SOC_CPU_CORES_NUM > 1 && !CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE
    s_system_full_inited = true;
4200153f:	fb0321        	l32r	a2, 4200014c <_stext+0x12c>
42001542:	130c      	movi.n	a3, 1
42001544:	0020c0        	memw
42001547:	004232        	s8i	a3, a2, 0
#endif

    esp_startup_start_app();
4200154a:	1766a5        	call8	42018bb4 <esp_startup_start_app>
    while (1);
4200154d:	ffff06        	j	4200154d <start_cpu0+0x101>
        (*p)();
42001550:	0248      	l32i.n	a4, a2, 0
42001552:	0004e0        	callx8	a4
    for (p = &__init_array_end - 1; p >= &__init_array_start; --p) {
42001555:	ffe8c6        	j	420014fc <start_cpu0+0xb0>
            system_inited &= s_system_inited[i];
42001558:	faf031        	l32r	a3, 42000118 <_stext+0xf8>
        system_inited = true;
4200155b:	0020c0        	memw
4200155e:	084142        	s8i	a4, a1, 8
            system_inited &= s_system_inited[i];
42001561:	0020c0        	memw
42001564:	000382        	l8ui	a8, a3, 0
42001567:	0020c0        	memw
4200156a:	080122        	l8ui	a2, a1, 8
        esp_rom_delay_us(100);
4200156d:	64a0a2        	movi	a10, 100
            system_inited &= s_system_inited[i];
42001570:	742020        	extui	a2, a2, 0, 8
42001573:	102280        	and	a2, a2, a8
42001576:	0020c0        	memw
42001579:	084122        	s8i	a2, a1, 8
4200157c:	0020c0        	memw
4200157f:	010332        	l8ui	a3, a3, 1
42001582:	0020c0        	memw
42001585:	080122        	l8ui	a2, a1, 8
42001588:	742020        	extui	a2, a2, 0, 8
4200158b:	102230        	and	a2, a2, a3
4200158e:	0020c0        	memw
42001591:	084122        	s8i	a2, a1, 8
        esp_rom_delay_us(100);
42001594:	faf381        	l32r	a8, 42000160 <_stext+0x140>
42001597:	0008e0        	callx8	a8
4200159a:	ffdd46        	j	42001513 <start_cpu0+0xc7>
4200159d:	000000        	ill

420015a0 <__esp_system_init_fn_init_components0>:
}

ESP_SYSTEM_INIT_FN(init_components0, BIT(0), 200)
{
420015a0:	004136        	entry	a1, 32
#if CONFIG_ESP_COREDUMP_ENABLE
    esp_core_dump_init();
#endif

#if SOC_APB_BACKUP_DMA
    esp_apb_backup_dma_lock_init();
420015a3:	002de5        	call8	42001880 <esp_apb_backup_dma_lock_init>
    _Unwind_SetNoFunctionContextInstall(1);
    _Unwind_SetEnableExceptionFdeSorting(0);
#endif // CONFIG_COMPILER_CXX_EXCEPTIONS

    return ESP_OK;
}
420015a6:	020c      	movi.n	a2, 0
420015a8:	f01d      	retw.n
	...

420015ac <panic_handler>:
{
420015ac:	00a136        	entry	a1, 80
    panic_info_t info = { 0 };
420015af:	4c2c      	movi.n	a12, 36
420015b1:	0b0c      	movi.n	a11, 0
420015b3:	20a110        	or	a10, a1, a1
420015b6:	faf881        	l32r	a8, 42000198 <_stext+0x178>
420015b9:	0008e0        	callx8	a8
420015bc:	03eb40        	rsr.prid	a4
420015bf:	044d40        	extui	a4, a4, 13, 1
    g_exc_frames[core_id] = frame;
420015c2:	fae851        	l32r	a5, 42000164 <_stext+0x144>
420015c5:	1164e0        	slli	a6, a4, 2
420015c8:	a08450        	addx4	a8, a4, a5
420015cb:	0829      	s32i.n	a2, a8, 0
    if (pseudo_excause) {
420015cd:	b3bc      	beqz.n	a3, 4200160c <panic_handler+0x60>
        BUSY_WAIT_IF_TRUE(panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0 && core_id == 1);
420015cf:	02ad      	mov.n	a10, a2
420015d1:	166665        	call8	42017c38 <panic_get_cause>
420015d4:	055a66        	bnei	a10, 5, 420015dd <panic_handler+0x31>
420015d7:	021466        	bnei	a4, 1, 420015dd <panic_handler+0x31>
420015da:	ffff06        	j	420015da <panic_handler+0x2e>
        BUSY_WAIT_IF_TRUE(panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1 && core_id == 0);
420015dd:	02ad      	mov.n	a10, a2
420015df:	1665a5        	call8	42017c38 <panic_get_cause>
420015e2:	076a66        	bnei	a10, 6, 420015ed <panic_handler+0x41>
420015e5:	44cc      	bnez.n	a4, 420015ed <panic_handler+0x41>
420015e7:	ffff06        	j	420015e7 <panic_handler+0x3b>
420015ea:	00          	.byte 00
420015eb:	00          	.byte 00
420015ec:	00          	.byte 00
        if (panic_get_cause(frame) == PANIC_RSN_CACHEERR && core_id != esp_cache_err_get_cpuid()) {
420015ed:	20a220        	or	a10, a2, a2
420015f0:	166465        	call8	42017c38 <panic_get_cause>
420015f3:	157a66        	bnei	a10, 7, 4200160c <panic_handler+0x60>
420015f6:	fae981        	l32r	a8, 4200019c <_stext+0x17c>
420015f9:	0008e0        	callx8	a8
420015fc:	0c1a47        	beq	a10, a4, 4200160c <panic_handler+0x60>
            g_exc_frames[core_id] = NULL;
420015ff:	805560        	add	a5, a5, a6
42001602:	00a022        	movi	a2, 0
42001605:	0529      	s32i.n	a2, a5, 0
            while (1) {
42001607:	ffff06        	j	42001607 <panic_handler+0x5b>
4200160a:	00          	.byte 00
4200160b:	00          	.byte 00
    esp_panic_handler_reconfigure_wdts();
4200160c:	201110        	or	a1, a1, a1
4200160f:	007ca5        	call8	42001dd8 <esp_panic_handler_reconfigure_wdts>
    esp_rom_delay_us(1);
42001612:	1a0c      	movi.n	a10, 1
42001614:	fad381        	l32r	a8, 42000160 <_stext+0x140>
42001617:	0008e0        	callx8	a8
        if (i != core_id) {
4200161a:	0be456        	bnez	a4, 420016dc <panic_handler+0x130>
            esp_cpu_stall(i);
4200161d:	1a0c      	movi.n	a10, 1
4200161f:	fae081        	l32r	a8, 420001a0 <_stext+0x180>
42001622:	0008e0        	callx8	a8
    esp_ipc_isr_stall_abort();
42001625:	fadf81        	l32r	a8, 420001a4 <_stext+0x184>
42001628:	0008e0        	callx8	a8
    RER(reg, dcr);
4200162b:	facf41        	l32r	a4, 42000168 <_stext+0x148>
4200162e:	406440        	rer	a4, a4
    if (esp_cpu_dbgr_is_attached()) {
42001631:	736407        	bbci	a4, 0, 420016a8 <panic_handler+0xfc>
        if (!(esp_ptr_executable(esp_cpu_pc_to_addr(panic_get_address(frame))) && (panic_get_address(frame) & 0xC0000000U))) {
42001634:	02ad      	mov.n	a10, a2
42001636:	165fa5        	call8	42017c30 <panic_get_address>
    return (void *)((pc & 0x3fffffffU) | 0x40000000U);
42001639:	facc81        	l32r	a8, 4200016c <_stext+0x14c>
4200163c:	140c      	movi.n	a4, 1
4200163e:	10aa80        	and	a10, a10, a8
42001641:	014420        	slli	a4, a4, 30
    return (ip >= SOC_IROM_LOW && ip < SOC_IROM_HIGH)
42001644:	dfaf82        	movi	a8, -33
42001647:	20aa40        	or	a10, a10, a4
4200164a:	018870        	slli	a8, a8, 25
4200164d:	fac851        	l32r	a5, 42000170 <_stext+0x150>
42001650:	8a8a      	add.n	a8, a10, a8
42001652:	023587        	bltu	a5, a8, 42001658 <panic_handler+0xac>
42001655:	002546        	j	420016ee <panic_handler+0x142>
        || (ip >= SOC_IRAM_LOW && ip < SOC_IRAM_HIGH)
42001658:	fac751        	l32r	a5, 42000174 <_stext+0x154>
4200165b:	fac781        	l32r	a8, 42000178 <_stext+0x158>
4200165e:	5a5a      	add.n	a5, a10, a5
42001660:	023857        	bltu	a8, a5, 42001666 <panic_handler+0xba>
42001663:	0021c6        	j	420016ee <panic_handler+0x142>
        || (ip >= SOC_IROM_MASK_LOW && ip < SOC_IROM_MASK_HIGH)
42001666:	fac551        	l32r	a5, 4200017c <_stext+0x15c>
42001669:	c04a40        	sub	a4, a10, a4
4200166c:	023547        	bltu	a5, a4, 42001672 <panic_handler+0xc6>
4200166f:	001ec6        	j	420016ee <panic_handler+0x142>
        || (ip >= SOC_RTC_IRAM_LOW && ip < SOC_RTC_IRAM_HIGH)
42001672:	fac341        	l32r	a4, 42000180 <_stext+0x160>
42001675:	aa4a      	add.n	a10, a10, a4
42001677:	fac341        	l32r	a4, 42000184 <_stext+0x164>
4200167a:	70b4a7        	bgeu	a4, a10, 420016ee <panic_handler+0x142>
            panic_set_address(frame, (uint32_t)&_invalid_pc_placeholder);
4200167d:	fac2b1        	l32r	a11, 42000188 <_stext+0x168>
42001680:	02ad      	mov.n	a10, a2
42001682:	165be5        	call8	42017c40 <panic_set_address>
        if (panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU0
42001685:	02ad      	mov.n	a10, a2
42001687:	165b25        	call8	42017c38 <panic_get_cause>
4200168a:	765a66        	bnei	a10, 5, 42001704 <panic_handler+0x158>
            wdt_hal_write_protect_disable(&wdt0_context);
4200168d:	fabf41        	l32r	a4, 4200018c <_stext+0x16c>
42001690:	04ad      	mov.n	a10, a4
42001692:	fa8181        	l32r	a8, 42000098 <_stext+0x78>
42001695:	0008e0        	callx8	a8
            wdt_hal_handle_intr(&wdt0_context);
42001698:	04ad      	mov.n	a10, a4
4200169a:	fac381        	l32r	a8, 420001a8 <_stext+0x188>
4200169d:	0008e0        	callx8	a8
            wdt_hal_write_protect_enable(&wdt0_context);
420016a0:	04ad      	mov.n	a10, a4
420016a2:	fa8181        	l32r	a8, 420000a8 <_stext+0x88>
420016a5:	0008e0        	callx8	a8
    asm volatile (
420016a8:	03eb40        	rsr.prid	a4
420016ab:	044d40        	extui	a4, a4, 13, 1
    info->core = esp_cpu_get_core_id();
420016ae:	0149      	s32i.n	a4, a1, 0
    info->exception = PANIC_EXCEPTION_FAULT;
420016b0:	440c      	movi.n	a4, 4
420016b2:	1149      	s32i.n	a4, a1, 4
    info->details = NULL;
420016b4:	040c      	movi.n	a4, 0
420016b6:	4149      	s32i.n	a4, a1, 16
    info->reason = "Unknown";
420016b8:	fab641        	l32r	a4, 42000190 <_stext+0x170>
    info->pseudo_excause = pseudo_excause;
420016bb:	204132        	s8i	a3, a1, 32
    info->reason = "Unknown";
420016be:	026142        	s32i	a4, a1, 8
        panic_soc_fill_info(frame, info);
420016c1:	20b110        	or	a11, a1, a1
420016c4:	20a220        	or	a10, a2, a2
    if (pseudo_excause) {
420016c7:	045316        	beqz	a3, 42001710 <panic_handler+0x164>
        panic_soc_fill_info(frame, info);
420016ca:	004425        	call8	42001b0c <panic_soc_fill_info>
    info->state = print_state;
420016cd:	fab131        	l32r	a3, 42000194 <_stext+0x174>
    esp_panic_handler(&info);
420016d0:	01ad      	mov.n	a10, a1
    info->state = print_state;
420016d2:	5139      	s32i.n	a3, a1, 20
    info->frame = frame;
420016d4:	7129      	s32i.n	a2, a1, 28
    esp_panic_handler(&info);
420016d6:	007725        	call8	42001e48 <esp_panic_handler>
}
420016d9:	f01d      	retw.n
420016db:	00          	.byte 00
            esp_cpu_stall(i);
420016dc:	0a0c      	movi.n	a10, 0
420016de:	fab081        	l32r	a8, 420001a0 <_stext+0x180>
420016e1:	0008e0        	callx8	a8
        if (i != core_id) {
420016e4:	021466        	bnei	a4, 1, 420016ea <panic_handler+0x13e>
420016e7:	ffce86        	j	42001625 <panic_handler+0x79>
420016ea:	ffcbc6        	j	4200161d <panic_handler+0x71>
420016ed:	00          	.byte 00
        if (!(esp_ptr_executable(esp_cpu_pc_to_addr(panic_get_address(frame))) && (panic_get_address(frame) & 0xC0000000U))) {
420016ee:	02ad      	mov.n	a10, a2
420016f0:	f47c      	movi.n	a4, -1
420016f2:	1653e5        	call8	42017c30 <panic_get_address>
420016f5:	014420        	slli	a4, a4, 30
420016f8:	028a47        	bany	a10, a4, 420016fe <panic_handler+0x152>
420016fb:	ffdf86        	j	4200167d <panic_handler+0xd1>
420016fe:	ffe0c6        	j	42001685 <panic_handler+0xd9>
42001701:	00          	.byte 00
42001702:	00          	.byte 00
42001703:	00          	.byte 00
                || panic_get_cause(frame) == PANIC_RSN_INTWDT_CPU1
42001704:	02ad      	mov.n	a10, a2
42001706:	165325        	call8	42017c38 <panic_get_cause>
42001709:	9b6a66        	bnei	a10, 6, 420016a8 <panic_handler+0xfc>
4200170c:	ffdf46        	j	4200168d <panic_handler+0xe1>
4200170f:	00          	.byte 00
        panic_arch_fill_info(frame, info);
42001710:	003ce5        	call8	42001ae0 <panic_arch_fill_info>
42001713:	ffed86        	j	420016cd <panic_handler+0x121>
	...

42001718 <print_state_for_core>:
{
42001718:	004136        	entry	a1, 32
    if (!g_panic_abort) {
4200171b:	faa481        	l32r	a8, 420001ac <_stext+0x18c>
4200171e:	000882        	l8ui	a8, a8, 0
42001721:	00d856        	bnez	a8, 42001732 <print_state_for_core+0x1a>
        panic_print_registers(f, core);
42001724:	20a220        	or	a10, a2, a2
42001727:	03bd      	mov.n	a11, a3
42001729:	002da5        	call8	42001a04 <panic_print_registers>
        panic_print_str("\r\n");
4200172c:	faa1a1        	l32r	a10, 420001b0 <_stext+0x190>
4200172f:	0061a5        	call8	42001d48 <panic_print_str>
    panic_print_backtrace(f, core);
42001732:	20b330        	or	a11, a3, a3
42001735:	20a220        	or	a10, a2, a2
42001738:	004325        	call8	42001b6c <panic_print_backtrace>
}
4200173b:	000090        	retw
	...

42001740 <print_state>:
{
42001740:	004136        	entry	a1, 32
    int err_core = f == g_exc_frames[0] ? 0 : 1;
42001743:	fa8831        	l32r	a3, 42000164 <_stext+0x144>
42001746:	00a062        	movi	a6, 0
42001749:	002372        	l32i	a7, a3, 0
4200174c:	150c      	movi.n	a5, 1
4200174e:	c04720        	sub	a4, a7, a2
42001751:	06bd      	mov.n	a11, a6
42001753:	93b540        	movnez	a11, a5, a4
    print_state_for_core(f, err_core);
42001756:	20a220        	or	a10, a2, a2
42001759:	fffbe5        	call8	42001718 <print_state_for_core>
    panic_print_str("\r\n");
4200175c:	fa9541        	l32r	a4, 420001b0 <_stext+0x190>
4200175f:	04ad      	mov.n	a10, a4
42001761:	005e65        	call8	42001d48 <panic_print_str>
        if (err_core != i && g_exc_frames[i] != NULL) {
42001764:	081727        	beq	a7, a2, 42001770 <print_state+0x30>
42001767:	03a8      	l32i.n	a10, a3, 0
            print_state_for_core(g_exc_frames[i], i);
42001769:	06bd      	mov.n	a11, a6
        if (err_core != i && g_exc_frames[i] != NULL) {
4200176b:	099a67        	bne	a10, a6, 42001778 <print_state+0x38>
}
4200176e:	f01d      	retw.n
        if (err_core != i && g_exc_frames[i] != NULL) {
42001770:	0123a2        	l32i	a10, a3, 4
            print_state_for_core(g_exc_frames[i], i);
42001773:	05bd      	mov.n	a11, a5
        if (err_core != i && g_exc_frames[i] != NULL) {
42001775:	ff5a16        	beqz	a10, 4200176e <print_state+0x2e>
            print_state_for_core(g_exc_frames[i], i);
42001778:	fff9e5        	call8	42001718 <print_state_for_core>
            panic_print_str("\r\n");
4200177b:	04ad      	mov.n	a10, a4
4200177d:	005ca5        	call8	42001d48 <panic_print_str>
}
42001780:	fffa86        	j	4200176e <print_state+0x2e>
	...

42001784 <panic_restart>:

void __attribute__((noreturn)) panic_restart(void)
{
42001784:	006136        	entry	a1, 48
#if CONFIG_IDF_TARGET_ESP32S2
    if (esp_memprot_is_intr_ena_any() || esp_memprot_is_locked_any()) {
        digital_reset_needed = true;
    }
#else
    bool is_on = false;
42001787:	080c      	movi.n	a8, 0
    if (esp_mprot_is_intr_ena_any(&is_on) != ESP_OK || is_on) {
42001789:	20a110        	or	a10, a1, a1
    bool is_on = false;
4200178c:	004182        	s8i	a8, a1, 0
    if (esp_mprot_is_intr_ena_any(&is_on) != ESP_OK || is_on) {
4200178f:	fa8981        	l32r	a8, 420001b4 <_stext+0x194>
42001792:	0008e0        	callx8	a8
42001795:	8adc      	bnez.n	a10, 420017b1 <panic_restart+0x2d>
42001797:	000182        	l8ui	a8, a1, 0
4200179a:	38dc      	bnez.n	a8, 420017b1 <panic_restart+0x2d>
        digital_reset_needed = true;
    } else if (esp_mprot_is_conf_locked_any(&is_on) != ESP_OK || is_on) {
4200179c:	01ad      	mov.n	a10, a1
4200179e:	fa8681        	l32r	a8, 420001b8 <_stext+0x198>
420017a1:	0008e0        	callx8	a8
420017a4:	9acc      	bnez.n	a10, 420017b1 <panic_restart+0x2d>
420017a6:	000182        	l8ui	a8, a1, 0
420017a9:	48cc      	bnez.n	a8, 420017b1 <panic_restart+0x2d>
#endif
#endif
    if (digital_reset_needed) {
        esp_restart_noos_dig();
    }
    esp_restart_noos();
420017ab:	fa8481        	l32r	a8, 420001bc <_stext+0x19c>
420017ae:	0008e0        	callx8	a8
        esp_restart_noos_dig();
420017b1:	fa8381        	l32r	a8, 420001c0 <_stext+0x1a0>
420017b4:	0008e0        	callx8	a8
	...

420017b8 <esp_brownout_init>:
}
#endif // CONFIG_ESP_SYSTEM_BROWNOUT_INTR

void esp_brownout_init(void)
{
420017b8:	006136        	entry	a1, 48
#if CONFIG_ESP_SYSTEM_BROWNOUT_INTR
    brownout_hal_config_t cfg = {
420017bb:	fa82b1        	l32r	a11, 420001c4 <_stext+0x1a4>
420017be:	05a0c2        	movi	a12, 5
420017c1:	01ad      	mov.n	a10, a1
420017c3:	fa8281        	l32r	a8, 420001cc <_stext+0x1ac>
420017c6:	0008e0        	callx8	a8
        .reset_enabled = false,
        .flash_power_down = true,
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
420017c9:	01ad      	mov.n	a10, a1
420017cb:	008925        	call8	4200205c <brownout_hal_config>
    brownout_hal_intr_clear();
420017ce:	fa8081        	l32r	a8, 420001d0 <_stext+0x1b0>
420017d1:	0008e0        	callx8	a8
    rtc_isr_register(rtc_brownout_isr_handler, NULL, RTC_CNTL_BROWN_OUT_INT_ENA_M, RTC_INTR_FLAG_IRAM);
420017d4:	fa7da1        	l32r	a10, 420001c8 <_stext+0x1a8>
420017d7:	1d0c      	movi.n	a13, 1
420017d9:	00a2c2        	movi	a12, 0x200
420017dc:	0b0c      	movi.n	a11, 0
420017de:	018aa5        	call8	42003088 <rtc_isr_register>
    brownout_hal_intr_enable(true);
420017e1:	1a0c      	movi.n	a10, 1
420017e3:	009565        	call8	42002138 <brownout_hal_intr_enable>
        .rf_power_down = true,
    };

    brownout_hal_config(&cfg);
#endif
}
420017e6:	f01d      	retw.n

420017e8 <esp_reset_reason_init>:
{
420017e8:	004136        	entry	a1, 32
    esp_reset_reason_t hint = esp_reset_reason_get_hint();
420017eb:	fa7c81        	l32r	a8, 420001dc <_stext+0x1bc>
420017ee:	0008e0        	callx8	a8
420017f1:	0a2d      	mov.n	a2, a10
    s_reset_reason = get_reset_reason(esp_rom_get_reset_reason(PRO_CPU_NUM), hint);
420017f3:	00a0a2        	movi	a10, 0
420017f6:	fa2181        	l32r	a8, 4200007c <_stext+0x5c>
420017f9:	0008e0        	callx8	a8
    switch (rtc_reset_reason) {
420017fc:	688a26        	beqi	a10, 8, 42001868 <esp_reset_reason_init+0x80>
420017ff:	880c      	movi.n	a8, 8
42001801:	2c38a7        	bltu	a8, a10, 42001831 <esp_reset_reason_init+0x49>
42001804:	655a26        	beqi	a10, 5, 4200186d <esp_reset_reason_init+0x85>
42001807:	0a6af6        	bgeui	a10, 6, 42001815 <esp_reset_reason_init+0x2d>
4200180a:	0c1a26        	beqi	a10, 1, 4200181a <esp_reset_reason_init+0x32>
4200180d:	433a26        	beqi	a10, 3, 42001854 <esp_reset_reason_init+0x6c>
        return ESP_RST_UNKNOWN;
42001810:	0a0c      	movi.n	a10, 0
42001812:	000106        	j	4200181a <esp_reset_reason_init+0x32>
    switch (rtc_reset_reason) {
42001815:	f77a66        	bnei	a10, 7, 42001810 <esp_reset_reason_init+0x28>
        return ESP_RST_TASK_WDT;
42001818:	6a0c      	movi.n	a10, 6
    s_reset_reason = get_reset_reason(esp_rom_get_reset_reason(PRO_CPU_NUM), hint);
4200181a:	fa6e81        	l32r	a8, 420001d4 <_stext+0x1b4>
4200181d:	08a9      	s32i.n	a10, a8, 0
    if (hint != ESP_RST_UNKNOWN) {
4200181f:	928c      	beqz.n	a2, 4200182c <esp_reset_reason_init+0x44>
static void esp_reset_reason_clear_hint(void)
{
    REG_WRITE(RTC_RESET_CAUSE_REG, 0);
42001821:	fa6d21        	l32r	a2, 420001d8 <_stext+0x1b8>
42001824:	080c      	movi.n	a8, 0
42001826:	0020c0        	memw
42001829:	006282        	s32i	a8, a2, 0
}
4200182c:	f01d      	retw.n
4200182e:	00          	.byte 00
4200182f:	00          	.byte 00
42001830:	00          	.byte 00
    switch (rtc_reset_reason) {
42001831:	f7ca82        	addi	a8, a10, -9
42001834:	9b0c      	movi.n	a11, 9
42001836:	d63b87        	bltu	a11, a8, 42001810 <esp_reset_reason_init+0x28>
42001839:	180c      	movi.n	a8, 1
4200183b:	95a392        	movi	a9, 0x395
4200183e:	401a00        	ssl	a10
42001841:	a18800        	sll	a8, a8
42001844:	119970        	slli	a9, a9, 9
42001847:	108890        	and	a8, a8, a9
4200184a:	48ec      	bnez.n	a8, 42001872 <esp_reset_reason_init+0x8a>
4200184c:	f90c      	movi.n	a9, 15
4200184e:	261a97        	beq	a10, a9, 42001878 <esp_reset_reason_init+0x90>
42001851:	bbaa66        	bnei	a10, 12, 42001810 <esp_reset_reason_init+0x28>
        if (reset_reason_hint == ESP_RST_PANIC ||
42001854:	fcc282        	addi	a8, a2, -4
42001857:	0738b6        	bltui	a8, 3, 42001862 <esp_reset_reason_init+0x7a>
            reset_reason_hint == ESP_RST_BROWNOUT ||
4200185a:	f7c282        	addi	a8, a2, -9
        return ESP_RST_SW;
4200185d:	3a0c      	movi.n	a10, 3
        if (reset_reason_hint == ESP_RST_PANIC ||
4200185f:	fb7856        	bnez	a8, 4200181a <esp_reset_reason_init+0x32>
    esp_reset_reason_t hint = esp_reset_reason_get_hint();
42001862:	02ad      	mov.n	a10, a2
42001864:	ffec86        	j	4200181a <esp_reset_reason_init+0x32>
42001867:	00          	.byte 00
        return ESP_RST_INT_WDT;
42001868:	5a0c      	movi.n	a10, 5
4200186a:	ffeb06        	j	4200181a <esp_reset_reason_init+0x32>
    switch (rtc_reset_reason) {
4200186d:	08ad      	mov.n	a10, a8
4200186f:	ffe9c6        	j	4200181a <esp_reset_reason_init+0x32>
        return ESP_RST_WDT;
42001872:	7a0c      	movi.n	a10, 7
42001874:	ffe886        	j	4200181a <esp_reset_reason_init+0x32>
42001877:	00          	.byte 00
        return ESP_RST_BROWNOUT;
42001878:	0bad      	mov.n	a10, a11
4200187a:	ffe706        	j	4200181a <esp_reset_reason_init+0x32>
4200187d:	000000        	ill

42001880 <esp_apb_backup_dma_lock_init>:

void esp_apb_backup_dma_lock_init(void)
{
42001880:	004136        	entry	a1, 32
    ets_apb_backup_init_lock_func(apb_backup_dma_lock, apb_backup_dma_unlock);
42001883:	fa57b1        	l32r	a11, 420001e0 <_stext+0x1c0>
42001886:	fa57a1        	l32r	a10, 420001e4 <_stext+0x1c4>
42001889:	fa5781        	l32r	a8, 420001e8 <_stext+0x1c8>
4200188c:	0008e0        	callx8	a8
}
4200188f:	f01d      	retw.n
42001891:	000000        	ill

42001894 <print_debug_exception_details>:
    panic_print_hex(*(pepc + 2));
}


static void print_debug_exception_details(const void *f)
{
42001894:	004136        	entry	a1, 32
    int debug_rsn;
    asm("rsr.debugcause %0":"=r"(debug_rsn));
    panic_print_str("Debug exception reason: ");
42001897:	fa55a1        	l32r	a10, 420001ec <_stext+0x1cc>
    asm("rsr.debugcause %0":"=r"(debug_rsn));
4200189a:	03e920        	rsr.debugcause	a2
    panic_print_str("Debug exception reason: ");
4200189d:	004aa5        	call8	42001d48 <panic_print_str>
    if (debug_rsn & XCHAL_DEBUGCAUSE_ICOUNT_MASK) {
420018a0:	056207        	bbci	a2, 0, 420018a9 <print_debug_exception_details+0x15>
        panic_print_str("SingleStep ");
420018a3:	fa53a1        	l32r	a10, 420001f0 <_stext+0x1d0>
420018a6:	004a25        	call8	42001d48 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_IBREAK_MASK) {
420018a9:	056217        	bbci	a2, 1, 420018b2 <print_debug_exception_details+0x1e>
        panic_print_str("HwBreakpoint ");
420018ac:	fa52a1        	l32r	a10, 420001f4 <_stext+0x1d4>
420018af:	0049a5        	call8	42001d48 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DBREAK_MASK) {
420018b2:	0b6227        	bbci	a2, 2, 420018c1 <print_debug_exception_details+0x2d>
            const char *name = pcTaskGetName(xTaskGetCurrentTaskHandleForCPU(core));
            panic_print_str("Stack canary watchpoint triggered (");
            panic_print_str(name);
            panic_print_str(") ");
#else
            panic_print_str("Watchpoint 1 triggered ");
420018b5:	fa50a1        	l32r	a10, 420001f8 <_stext+0x1d8>
        if (debug_rsn & (1 << 8)) {
420018b8:	02e287        	bbsi	a2, 8, 420018be <print_debug_exception_details+0x2a>
#endif
        } else {
            panic_print_str("Watchpoint 0 triggered ");
420018bb:	fa50a1        	l32r	a10, 420001fc <_stext+0x1dc>
420018be:	0048a5        	call8	42001d48 <panic_print_str>
        }
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAK_MASK) {
420018c1:	086237        	bbci	a2, 3, 420018cd <print_debug_exception_details+0x39>
        panic_print_str("BREAK instr ");
420018c4:	fa4fa1        	l32r	a10, 42000200 <_stext+0x1e0>
420018c7:	201110        	or	a1, a1, a1
420018ca:	0047e5        	call8	42001d48 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_BREAKN_MASK) {
420018cd:	086247        	bbci	a2, 4, 420018d9 <print_debug_exception_details+0x45>
        panic_print_str("BREAKN instr ");
420018d0:	fa4da1        	l32r	a10, 42000204 <_stext+0x1e4>
420018d3:	201110        	or	a1, a1, a1
420018d6:	004725        	call8	42001d48 <panic_print_str>
    }
    if (debug_rsn & XCHAL_DEBUGCAUSE_DEBUGINT_MASK) {
420018d9:	056257        	bbci	a2, 5, 420018e2 <print_debug_exception_details+0x4e>
        panic_print_str("DebugIntr ");
420018dc:	fa4ba1        	l32r	a10, 42000208 <_stext+0x1e8>
420018df:	0046a5        	call8	42001d48 <panic_print_str>
    }
}
420018e2:	f01d      	retw.n

420018e4 <print_illegal_instruction_details>:
{
420018e4:	004136        	entry	a1, 32
    epc = (epc & ~0x3) - 4;
420018e7:	1238      	l32i.n	a3, a2, 4
    if (epc < SOC_IROM_MASK_LOW || epc >= SOC_IROM_HIGH) {
420018e9:	fa4881        	l32r	a8, 4200020c <_stext+0x1ec>
    epc = (epc & ~0x3) - 4;
420018ec:	c27c      	movi.n	a2, -4
420018ee:	102230        	and	a2, a2, a3
    if (epc < SOC_IROM_MASK_LOW || epc >= SOC_IROM_HIGH) {
420018f1:	fa4731        	l32r	a3, 42000210 <_stext+0x1f0>
420018f4:	828a      	add.n	a8, a2, a8
420018f6:	3a3387        	bltu	a3, a8, 42001934 <print_illegal_instruction_details+0x50>
    panic_print_str("Memory dump at 0x");
420018f9:	fa46a1        	l32r	a10, 42000214 <_stext+0x1f4>
    epc = (epc & ~0x3) - 4;
420018fc:	fcc222        	addi	a2, a2, -4
    panic_print_str("Memory dump at 0x");
420018ff:	0044a5        	call8	42001d48 <panic_print_str>
    panic_print_hex(epc);
42001902:	02ad      	mov.n	a10, a2
42001904:	0046a5        	call8	42001d70 <panic_print_hex>
    panic_print_str(": ");
42001907:	fa44a1        	l32r	a10, 42000218 <_stext+0x1f8>
4200190a:	0043e5        	call8	42001d48 <panic_print_str>
    panic_print_hex(*pepc);
4200190d:	0020c0        	memw
42001910:	02a8      	l32i.n	a10, a2, 0
42001912:	0045e5        	call8	42001d70 <panic_print_hex>
    panic_print_str(" ");
42001915:	fa4131        	l32r	a3, 4200021c <_stext+0x1fc>
42001918:	20a330        	or	a10, a3, a3
4200191b:	0042e5        	call8	42001d48 <panic_print_str>
    panic_print_hex(*(pepc + 1));
4200191e:	0020c0        	memw
42001921:	0122a2        	l32i	a10, a2, 4
42001924:	0044a5        	call8	42001d70 <panic_print_hex>
    panic_print_str(" ");
42001927:	03ad      	mov.n	a10, a3
42001929:	0041e5        	call8	42001d48 <panic_print_str>
    panic_print_hex(*(pepc + 2));
4200192c:	0020c0        	memw
4200192f:	22a8      	l32i.n	a10, a2, 8
42001931:	0043e5        	call8	42001d70 <panic_print_hex>
}
42001934:	f01d      	retw.n
	...

42001938 <print_cache_err_details>:
}
#endif

#elif CONFIG_IDF_TARGET_ESP32S3
static inline void print_cache_err_details(const void *f)
{
42001938:	004136        	entry	a1, 32
    uint32_t vaddr = 0, size = 0;
    uint32_t status;
    status = REG_READ(EXTMEM_CACHE_ILG_INT_ST_REG);
4200193b:	fa3921        	l32r	a2, 42000220 <_stext+0x200>
    for (int i = 0; i < 32; i++) {
4200193e:	030c      	movi.n	a3, 0
    status = REG_READ(EXTMEM_CACHE_ILG_INT_ST_REG);
42001940:	0020c0        	memw
42001943:	0258      	l32i.n	a5, a2, 0
    uint32_t vaddr = 0, size = 0;
42001945:	034d      	mov.n	a4, a3
42001947:	202330        	or	a2, a3, a3
        switch (status & BIT(i)) {
4200194a:	01a062        	movi	a6, 1
4200194d:	401300        	ssl	a3
42001950:	a18600        	sll	a8, a6
42001953:	108850        	and	a8, a8, a5
42001956:	028866        	bnei	a8, 8, 4200195c <print_cache_err_details+0x24>
42001959:	0021c6        	j	420019e4 <print_cache_err_details+0xac>
4200195c:	890c      	movi.n	a9, 8
4200195e:	1b3987        	bltu	a9, a8, 4200197d <print_cache_err_details+0x45>
42001961:	502826        	beqi	a8, 2, 420019b5 <print_cache_err_details+0x7d>
            break;
        case EXTMEM_DCACHE_SYNC_OP_FAULT_ST:
            //TODO, which size should fetch
            //vaddr = REG_READ(EXTMEM_DCACHE_MEM_SYNC0_REG);
            //size = REG_READ(EXTMEM_DCACHE_MEM_SYNC1_REG);
            panic_print_str("Dcache sync parameter configuration error, the error address and size is 0x");
42001964:	fa36a1        	l32r	a10, 4200023c <_stext+0x21c>
        switch (status & BIT(i)) {
42001967:	5d4826        	beqi	a8, 4, 420019c8 <print_cache_err_details+0x90>
            panic_print_str("Icache sync parameter configuration error, the error address and size is 0x");
4200196a:	fa2ea1        	l32r	a10, 42000224 <_stext+0x204>
        switch (status & BIT(i)) {
4200196d:	571826        	beqi	a8, 1, 420019c8 <print_cache_err_details+0x90>
    for (int i = 0; i < 32; i++) {
42001970:	331b      	addi.n	a3, a3, 1
42001972:	d7c366        	bnei	a3, 32, 4200194d <print_cache_err_details+0x15>
            break;
        default:
            break;
        }
    }
    panic_print_str("\r\n");
42001975:	fa3aa1        	l32r	a10, 42000260 <_stext+0x240>
42001978:	003ce5        	call8	42001d48 <panic_print_str>
}
4200197b:	f01d      	retw.n
        switch (status & BIT(i)) {
4200197d:	02b866        	bnei	a8, 16, 42001983 <print_cache_err_details+0x4b>
42001980:	001e06        	j	420019fc <print_cache_err_details+0xc4>
42001983:	e9c866        	bnei	a8, 32, 42001970 <print_cache_err_details+0x38>
            vaddr = REG_READ(EXTMEM_CACHE_MMU_FAULT_VADDR_REG);
42001986:	fa3221        	l32r	a2, 42000250 <_stext+0x230>
            panic_print_str("MMU entry fault error occurred while accessing the address 0x");
42001989:	fa32a1        	l32r	a10, 42000254 <_stext+0x234>
            vaddr = REG_READ(EXTMEM_CACHE_MMU_FAULT_VADDR_REG);
4200198c:	0020c0        	memw
4200198f:	002222        	l32i	a2, a2, 0
            panic_print_str("MMU entry fault error occurred while accessing the address 0x");
42001992:	003b65        	call8	42001d48 <panic_print_str>
            panic_print_hex(vaddr);
42001995:	20a220        	or	a10, a2, a2
42001998:	003d65        	call8	42001d70 <panic_print_hex>
            if (REG_READ(EXTMEM_CACHE_MMU_FAULT_CONTENT_REG) & MMU_INVALID) {
4200199b:	fa2f81        	l32r	a8, 42000258 <_stext+0x238>
4200199e:	0020c0        	memw
420019a1:	0888      	l32i.n	a8, a8, 0
420019a3:	0568e7        	bbci	a8, 14, 420019ac <print_cache_err_details+0x74>
                panic_print_str(" (invalid mmu entry)");
420019a6:	fa2da1        	l32r	a10, 4200025c <_stext+0x23c>
420019a9:	0039e5        	call8	42001d48 <panic_print_str>
            panic_print_str("\r\n");
420019ac:	fa2da1        	l32r	a10, 42000260 <_stext+0x240>
420019af:	000ac6        	j	420019de <print_cache_err_details+0xa6>
420019b2:	00          	.byte 00
420019b3:	00          	.byte 00
420019b4:	00          	.byte 00
            vaddr = REG_READ(EXTMEM_ICACHE_PRELOAD_ADDR_REG);
420019b5:	fa1e21        	l32r	a2, 42000230 <_stext+0x210>
            size = REG_READ(EXTMEM_ICACHE_PRELOAD_SIZE_REG);
420019b8:	fa1f41        	l32r	a4, 42000234 <_stext+0x214>
            vaddr = REG_READ(EXTMEM_ICACHE_PRELOAD_ADDR_REG);
420019bb:	0020c0        	memw
420019be:	0228      	l32i.n	a2, a2, 0
            panic_print_str("Icache preload parameter configuration error, the error address and size is 0x");
420019c0:	fa1ea1        	l32r	a10, 42000238 <_stext+0x218>
            size = REG_READ(EXTMEM_ICACHE_PRELOAD_SIZE_REG);
420019c3:	0020c0        	memw
420019c6:	0448      	l32i.n	a4, a4, 0
            panic_print_str("Icache preload parameter configuration error, the error address and size is 0x");
420019c8:	0037e5        	call8	42001d48 <panic_print_str>
            panic_print_hex(vaddr);
420019cb:	02ad      	mov.n	a10, a2
420019cd:	003a25        	call8	42001d70 <panic_print_hex>
            panic_print_str("(0x");
420019d0:	fa16a1        	l32r	a10, 42000228 <_stext+0x208>
420019d3:	003765        	call8	42001d48 <panic_print_str>
            panic_print_hex(size);
420019d6:	04ad      	mov.n	a10, a4
420019d8:	003965        	call8	42001d70 <panic_print_hex>
            panic_print_str(")\r\n");
420019db:	fa14a1        	l32r	a10, 4200022c <_stext+0x20c>
            panic_print_str("\r\n");
420019de:	0036a5        	call8	42001d48 <panic_print_str>
            break;
420019e1:	ffe2c6        	j	42001970 <print_cache_err_details+0x38>
            vaddr = REG_READ(EXTMEM_DCACHE_PRELOAD_ADDR_REG);
420019e4:	fa1721        	l32r	a2, 42000240 <_stext+0x220>
            size = REG_READ(EXTMEM_DCACHE_PRELOAD_SIZE_REG);
420019e7:	fa1741        	l32r	a4, 42000244 <_stext+0x224>
            vaddr = REG_READ(EXTMEM_DCACHE_PRELOAD_ADDR_REG);
420019ea:	0020c0        	memw
420019ed:	0228      	l32i.n	a2, a2, 0
            panic_print_str("Dcache preload parameter configuration error, the error address and size is 0x");
420019ef:	fa16a1        	l32r	a10, 42000248 <_stext+0x228>
            size = REG_READ(EXTMEM_DCACHE_PRELOAD_SIZE_REG);
420019f2:	0020c0        	memw
420019f5:	0448      	l32i.n	a4, a4, 0
            panic_print_str("Dcache preload parameter configuration error, the error address and size is 0x");
420019f7:	fff346        	j	420019c8 <print_cache_err_details+0x90>
420019fa:	00          	.byte 00
420019fb:	00          	.byte 00
            panic_print_str("Write back error occurred while dcache tries to write back to flash\r\n");
420019fc:	fa14a1        	l32r	a10, 4200024c <_stext+0x22c>
420019ff:	fff6c6        	j	420019de <print_cache_err_details+0xa6>
	...

42001a04 <panic_print_registers>:
{
42001a04:	012136        	entry	a1, 144
    const char *sdesc[] = {
42001a07:	fa17b1        	l32r	a11, 42000264 <_stext+0x244>
42001a0a:	60a0c2        	movi	a12, 96
42001a0d:	20a110        	or	a10, a1, a1
42001a10:	f9ef81        	l32r	a8, 420001cc <_stext+0x1ac>
42001a13:	0008e0        	callx8	a8
    panic_print_str("Core ");
42001a16:	fa14a1        	l32r	a10, 42000268 <_stext+0x248>
    for (int x = 0; x < 24; x += 4) {
42001a19:	040c      	movi.n	a4, 0
    panic_print_str("Core ");
42001a1b:	0032e5        	call8	42001d48 <panic_print_str>
    panic_print_dec(core);
42001a1e:	03ad      	mov.n	a10, a3
42001a20:	003765        	call8	42001d98 <panic_print_dec>
    panic_print_str(" register dump:");
42001a23:	fa12a1        	l32r	a10, 4200026c <_stext+0x24c>
42001a26:	003225        	call8	42001d48 <panic_print_str>
        panic_print_str("\r\n");
42001a29:	fa0d71        	l32r	a7, 42000260 <_stext+0x240>
42001a2c:	07ad      	mov.n	a10, a7
42001a2e:	0031a5        	call8	42001d48 <panic_print_str>
        for (int y = 0; y < 4; y++) {
42001a31:	a06420        	addx4	a6, a4, a2
42001a34:	a09410        	addx4	a9, a4, a1
        panic_print_str("\r\n");
42001a37:	050c      	movi.n	a5, 0
            if (sdesc[x + y][0] != 0) {
42001a39:	a95a      	add.n	a10, a9, a5
42001a3b:	0aa8      	l32i.n	a10, a10, 0
42001a3d:	000ab2        	l8ui	a11, a10, 0
42001a40:	019b16        	beqz	a11, 42001a5d <panic_print_registers+0x59>
                panic_print_str(sdesc[x + y]);
42001a43:	186192        	s32i	a9, a1, 96
42001a46:	003025        	call8	42001d48 <panic_print_str>
                panic_print_str(": 0x");
42001a49:	fa09a1        	l32r	a10, 42000270 <_stext+0x250>
42001a4c:	002fa5        	call8	42001d48 <panic_print_str>
                panic_print_hex(regs[x + y + 1]);
42001a4f:	16a8      	l32i.n	a10, a6, 4
42001a51:	0031e5        	call8	42001d70 <panic_print_hex>
                panic_print_str("  ");
42001a54:	fa08a1        	l32r	a10, 42000274 <_stext+0x254>
42001a57:	002f25        	call8	42001d48 <panic_print_str>
42001a5a:	182192        	l32i	a9, a1, 96
        for (int y = 0; y < 4; y++) {
42001a5d:	554b      	addi.n	a5, a5, 4
42001a5f:	664b      	addi.n	a6, a6, 4
42001a61:	d4b566        	bnei	a5, 16, 42001a39 <panic_print_registers+0x35>
    for (int x = 0; x < 24; x += 4) {
42001a64:	444b      	addi.n	a4, a4, 4
42001a66:	851c      	movi.n	a5, 24
42001a68:	c09457        	bne	a4, a5, 42001a2c <panic_print_registers+0x28>
    if (xPortInterruptedFromISRContext()
42001a6b:	fa0881        	l32r	a8, 4200028c <_stext+0x26c>
42001a6e:	0008e0        	callx8	a8
42001a71:	068a16        	beqz	a10, 42001add <panic_print_registers+0xd9>
            && ((core == 0 && frame->exccause == PANIC_RSN_INTWDT_CPU0) ||
42001a74:	059356        	bnez	a3, 42001ad1 <panic_print_registers+0xcd>
42001a77:	142222        	l32i	a2, a2, 80
42001a7a:	025226        	beqi	a2, 5, 42001a80 <panic_print_registers+0x7c>
42001a7d:	001706        	j	42001add <panic_print_registers+0xd9>
        panic_print_str("\r\n");
42001a80:	07ad      	mov.n	a10, a7
42001a82:	002c65        	call8	42001d48 <panic_print_str>
        panic_print_str("Core ");
42001a85:	f9f8a1        	l32r	a10, 42000268 <_stext+0x248>
42001a88:	002be5        	call8	42001d48 <panic_print_str>
        panic_print_dec(core);
42001a8b:	03ad      	mov.n	a10, a3
42001a8d:	0030a5        	call8	42001d98 <panic_print_dec>
        panic_print_str(" was running in ISR context:\r\n");
42001a90:	f9faa1        	l32r	a10, 42000278 <_stext+0x258>
        __asm__("rsr.epc1 %0" : "=a"(__value));
42001a93:	03b130        	rsr.epc1	a3
        panic_print_str(" was running in ISR context:\r\n");
42001a96:	002b25        	call8	42001d48 <panic_print_str>
        panic_print_str("EPC1    : 0x");
42001a99:	f9f8a1        	l32r	a10, 4200027c <_stext+0x25c>
42001a9c:	002aa5        	call8	42001d48 <panic_print_str>
        panic_print_hex(__value);
42001a9f:	03ad      	mov.n	a10, a3
42001aa1:	002ce5        	call8	42001d70 <panic_print_hex>
        panic_print_str("  EPC2    : 0x");
42001aa4:	f9f7a1        	l32r	a10, 42000280 <_stext+0x260>
        __asm__("rsr.epc2 %0" : "=a"(__value));
42001aa7:	03b230        	rsr.epc2	a3
        panic_print_str("  EPC2    : 0x");
42001aaa:	0029e5        	call8	42001d48 <panic_print_str>
        panic_print_hex(__value);
42001aad:	03ad      	mov.n	a10, a3
42001aaf:	002c25        	call8	42001d70 <panic_print_hex>
        panic_print_str("  EPC3    : 0x");
42001ab2:	f9f4a1        	l32r	a10, 42000284 <_stext+0x264>
        __asm__("rsr.epc3 %0" : "=a"(__value));
42001ab5:	03b330        	rsr.epc3	a3
        panic_print_str("  EPC3    : 0x");
42001ab8:	0028e5        	call8	42001d48 <panic_print_str>
        panic_print_hex(__value);
42001abb:	03ad      	mov.n	a10, a3
42001abd:	002b25        	call8	42001d70 <panic_print_hex>
        panic_print_str("  EPC4    : 0x");
42001ac0:	f9f2a1        	l32r	a10, 42000288 <_stext+0x268>
        __asm__("rsr.epc4 %0" : "=a"(__value));
42001ac3:	03b430        	rsr.epc4	a3
        panic_print_str("  EPC4    : 0x");
42001ac6:	002825        	call8	42001d48 <panic_print_str>
        panic_print_hex(__value);
42001ac9:	03ad      	mov.n	a10, a3
42001acb:	002a65        	call8	42001d70 <panic_print_hex>
}
42001ace:	0002c6        	j	42001add <panic_print_registers+0xd9>
            && ((core == 0 && frame->exccause == PANIC_RSN_INTWDT_CPU0) ||
42001ad1:	081366        	bnei	a3, 1, 42001add <panic_print_registers+0xd9>
                (core == 1 && frame->exccause == PANIC_RSN_INTWDT_CPU1))
42001ad4:	142222        	l32i	a2, a2, 80
42001ad7:	026266        	bnei	a2, 6, 42001add <panic_print_registers+0xd9>
42001ada:	ffe886        	j	42001a80 <panic_print_registers+0x7c>
}
42001add:	f01d      	retw.n
	...

42001ae0 <panic_arch_fill_info>:
#endif


void panic_arch_fill_info(void *f, panic_info_t *info)
{
42001ae0:	004136        	entry	a1, 32
        "LoadProhibited", "StoreProhibited", "res", "res",
        "Cp0Dis", "Cp1Dis", "Cp2Dis", "Cp3Dis",
        "Cp4Dis", "Cp5Dis", "Cp6Dis", "Cp7Dis"
    };

    if (frame->exccause < (sizeof(reason) / sizeof(char *))) {
42001ae3:	142282        	l32i	a8, a2, 80
42001ae6:	7a2c      	movi.n	a10, 39
        info->reason = (reason[frame->exccause]);
    } else {
        info->reason = "Unknown";
42001ae8:	f9ea91        	l32r	a9, 42000290 <_stext+0x270>
    if (frame->exccause < (sizeof(reason) / sizeof(char *))) {
42001aeb:	073a87        	bltu	a10, a8, 42001af6 <panic_arch_fill_info+0x16>
        info->reason = (reason[frame->exccause]);
42001aee:	f9e991        	l32r	a9, 42000294 <_stext+0x274>
42001af1:	a09890        	addx4	a9, a8, a9
42001af4:	0998      	l32i.n	a9, a9, 0
42001af6:	2399      	s32i.n	a9, a3, 8
    }

    info->description = "Exception was unhandled.";
42001af8:	f9e891        	l32r	a9, 42000298 <_stext+0x278>
42001afb:	3399      	s32i.n	a9, a3, 12

    if (frame->exccause == EXCCAUSE_ILLEGAL) {
42001afd:	38cc      	bnez.n	a8, 42001b04 <panic_arch_fill_info+0x24>
        info->details = print_illegal_instruction_details;
42001aff:	f9e781        	l32r	a8, 4200029c <_stext+0x27c>
42001b02:	4389      	s32i.n	a8, a3, 16
    }

    info->addr = ((void *) ((XtExcFrame *) frame)->pc);
42001b04:	1228      	l32i.n	a2, a2, 4
42001b06:	6329      	s32i.n	a2, a3, 24
}
42001b08:	f01d      	retw.n
	...

42001b0c <panic_soc_fill_info>:

void panic_soc_fill_info(void *f, panic_info_t *info)
{
42001b0c:	004136        	entry	a1, 32
    // [refactor-todo] this should be in the common port panic_handler.c, once
    // these special exceptions are supported in there.
    XtExcFrame *frame = (XtExcFrame *) f;
    if (frame->exccause == PANIC_RSN_INTWDT_CPU0) {
42001b0f:	142282        	l32i	a8, a2, 80
42001b12:	285866        	bnei	a8, 5, 42001b3e <panic_soc_fill_info+0x32>
        info->core = 0;
42001b15:	080c      	movi.n	a8, 0
42001b17:	0389      	s32i.n	a8, a3, 0
        info->exception = PANIC_EXCEPTION_IWDT;
42001b19:	180c      	movi.n	a8, 1
    } else if (frame->exccause == PANIC_RSN_INTWDT_CPU1) {
        info->core = 1;
        info->exception = PANIC_EXCEPTION_IWDT;
42001b1b:	1389      	s32i.n	a8, a3, 4
        "Interrupt wdt timeout on CPU0",
        "Interrupt wdt timeout on CPU1",
        "Cache disabled but cached memory region accessed",
    };

    info->reason = pseudo_reason[0];
42001b1d:	f9e081        	l32r	a8, 420002a0 <_stext+0x280>
    info->description = NULL;
42001b20:	0a0c      	movi.n	a10, 0
    info->reason = pseudo_reason[0];
42001b22:	2389      	s32i.n	a8, a3, 8

    if (frame->exccause <= PANIC_RSN_MAX) {
42001b24:	142282        	l32i	a8, a2, 80
    info->description = NULL;
42001b27:	33a9      	s32i.n	a10, a3, 12
    if (frame->exccause <= PANIC_RSN_MAX) {
42001b29:	0f88e6        	bgei	a8, 8, 42001b3c <panic_soc_fill_info+0x30>
        info->reason = pseudo_reason[frame->exccause];
42001b2c:	f9de91        	l32r	a9, 420002a4 <_stext+0x284>
42001b2f:	a09890        	addx4	a9, a8, a9
42001b32:	0928      	l32i.n	a2, a9, 0
42001b34:	2329      	s32i.n	a2, a3, 8
    }

    if (frame->exccause == PANIC_RSN_DEBUGEXCEPTION) {
42001b36:	1e1826        	beqi	a8, 1, 42001b58 <panic_soc_fill_info+0x4c>
    }

    //MV note: ESP32S3 PMS handling?

#if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3
    if (frame->exccause == PANIC_RSN_CACHEERR) {
42001b39:	277826        	beqi	a8, 7, 42001b64 <panic_soc_fill_info+0x58>
        {
            info->details = print_cache_err_details;
        }
    }
#endif
}
42001b3c:	f01d      	retw.n
    } else if (frame->exccause == PANIC_RSN_INTWDT_CPU1) {
42001b3e:	066866        	bnei	a8, 6, 42001b48 <panic_soc_fill_info+0x3c>
        info->core = 1;
42001b41:	180c      	movi.n	a8, 1
42001b43:	0389      	s32i.n	a8, a3, 0
42001b45:	fff486        	j	42001b1b <panic_soc_fill_info+0xf>
    } else if (frame->exccause == PANIC_RSN_CACHEERR) {
42001b48:	d17866        	bnei	a8, 7, 42001b1d <panic_soc_fill_info+0x11>
        info->core =  esp_cache_err_get_cpuid();
42001b4b:	f99481        	l32r	a8, 4200019c <_stext+0x17c>
42001b4e:	0008e0        	callx8	a8
42001b51:	03a9      	s32i.n	a10, a3, 0
42001b53:	fff186        	j	42001b1d <panic_soc_fill_info+0x11>
42001b56:	00          	.byte 00
42001b57:	00          	.byte 00
        info->details = print_debug_exception_details;
42001b58:	f9d421        	l32r	a2, 420002a8 <_stext+0x288>
        info->exception = PANIC_EXCEPTION_DEBUG;
42001b5b:	13a9      	s32i.n	a10, a3, 4
        info->details = print_debug_exception_details;
42001b5d:	4329      	s32i.n	a2, a3, 16
    if (frame->exccause == PANIC_RSN_CACHEERR) {
42001b5f:	fff646        	j	42001b3c <panic_soc_fill_info+0x30>
42001b62:	00          	.byte 00
42001b63:	00          	.byte 00
            info->details = print_cache_err_details;
42001b64:	f9d221        	l32r	a2, 420002ac <_stext+0x28c>
42001b67:	4329      	s32i.n	a2, a3, 16
}
42001b69:	fff3c6        	j	42001b3c <panic_soc_fill_info+0x30>

42001b6c <panic_print_backtrace>:
{
    ((XtExcFrame *)f)->pc = addr;
}

void panic_print_backtrace(const void *f, int core)
{
42001b6c:	006136        	entry	a1, 48
    XtExcFrame *xt_frame = (XtExcFrame *) f;
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
42001b6f:	1288      	l32i.n	a8, a2, 4
    esp_backtrace_print_from_frame(100, &frame, true);
42001b71:	1c0c      	movi.n	a12, 1
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
42001b73:	0189      	s32i.n	a8, a1, 0
42001b75:	4288      	l32i.n	a8, a2, 16
    esp_backtrace_print_from_frame(100, &frame, true);
42001b77:	01bd      	mov.n	a11, a1
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
42001b79:	1189      	s32i.n	a8, a1, 4
42001b7b:	3288      	l32i.n	a8, a2, 12
    esp_backtrace_print_from_frame(100, &frame, true);
42001b7d:	64a0a2        	movi	a10, 100
    esp_backtrace_frame_t frame = {.pc = xt_frame->pc, .sp = xt_frame->a1, .next_pc = xt_frame->a0, .exc_frame = xt_frame};
42001b80:	2189      	s32i.n	a8, a1, 8
42001b82:	3129      	s32i.n	a2, a1, 12
    esp_backtrace_print_from_frame(100, &frame, true);
42001b84:	f9cb81        	l32r	a8, 420002b0 <_stext+0x290>
42001b87:	0008e0        	callx8	a8
}
42001b8a:	f01d      	retw.n

42001b8c <esp_ipc_isr_init>:
{
42001b8c:	004136        	entry	a1, 32
42001b8f:	03eb20        	rsr.prid	a2
42001b92:	042d20        	extui	a2, a2, 13, 1
    ESP_INTR_DISABLE(ETS_IPC_ISR_INUM);
42001b95:	1ca0a2        	movi	a10, 28
42001b98:	00c065        	call8	420027a0 <esp_intr_disable_source>
    esp_rom_route_intr_matrix(cpuid, intr_source, ETS_IPC_ISR_INUM);
42001b9b:	20a220        	or	a10, a2, a2
42001b9e:	cc1c      	movi.n	a12, 28
42001ba0:	51c2b2        	addi	a11, a2, 81
42001ba3:	f92a81        	l32r	a8, 4200004c <_stext+0x2c>
42001ba6:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_IPC_ISR_INUM);
42001ba9:	ca1c      	movi.n	a10, 28
42001bab:	00be25        	call8	4200278c <esp_intr_enable_source>
    if (cpuid != 0) {
42001bae:	828c      	beqz.n	a2, 42001bba <esp_ipc_isr_init+0x2e>
        s_stall_state = STALL_STATE_RUNNING;
42001bb0:	f9c121        	l32r	a2, 420002b4 <_stext+0x294>
42001bb3:	180c      	movi.n	a8, 1
42001bb5:	0020c0        	memw
42001bb8:	0289      	s32i.n	a8, a2, 0
}
42001bba:	f01d      	retw.n

42001bbc <esp_vApplicationIdleHook>:

void esp_vApplicationIdleHook(void)
{
42001bbc:	004136        	entry	a1, 32
42001bbf:	03eb20        	rsr.prid	a2
42001bc2:	042d20        	extui	a2, a2, 13, 1
    bool can_go_idle=true;
    int core = xPortGetCoreID();
    for (int n = 0; n < MAX_HOOKS; n++) {
42001bc5:	f9bc31        	l32r	a3, 420002b8 <_stext+0x298>
42001bc8:	1122b0        	slli	a2, a2, 5
42001bcb:	223a      	add.n	a2, a2, a3
42001bcd:	00a032        	movi	a3, 0
    bool can_go_idle=true;
42001bd0:	01a042        	movi	a4, 1
        if (idle_cb[core][n] != NULL && !idle_cb[core][n]()) {
            can_go_idle = false;
42001bd3:	205330        	or	a5, a3, a3
        if (idle_cb[core][n] != NULL && !idle_cb[core][n]()) {
42001bd6:	02a8      	l32i.n	a10, a2, 0
42001bd8:	4a8c      	beqz.n	a10, 42001be0 <esp_vApplicationIdleHook+0x24>
42001bda:	000ae0        	callx8	a10
            can_go_idle = false;
42001bdd:	8345a0        	moveqz	a4, a5, a10
    for (int n = 0; n < MAX_HOOKS; n++) {
42001be0:	331b      	addi.n	a3, a3, 1
42001be2:	224b      	addi.n	a2, a2, 4
42001be4:	ee8366        	bnei	a3, 8, 42001bd6 <esp_vApplicationIdleHook+0x1a>
        }
    }
    if (!can_go_idle) {
42001be7:	005416        	beqz	a4, 42001bf0 <esp_vApplicationIdleHook+0x34>

#ifdef CONFIG_PM_ENABLE
    esp_pm_impl_idle_hook();
    esp_pm_impl_waiti();
#else
    esp_cpu_wait_for_intr();
42001bea:	f9b481        	l32r	a8, 420002bc <_stext+0x29c>
42001bed:	0008e0        	callx8	a8
#endif


}
42001bf0:	f01d      	retw.n
	...

42001bf4 <esp_register_freertos_idle_hook_for_cpu>:

esp_err_t esp_register_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t new_idle_cb, UBaseType_t cpuid)
{
42001bf4:	004136        	entry	a1, 32
42001bf7:	026d      	mov.n	a6, a2
    if(cpuid >= portNUM_PROCESSORS){
        return ESP_ERR_INVALID_ARG;
42001bf9:	02a122        	movi	a2, 0x102
    if(cpuid >= portNUM_PROCESSORS){
42001bfc:	3223f6        	bgeui	a3, 2, 42001c32 <esp_register_freertos_idle_hook_for_cpu+0x3e>
42001bff:	f9b051        	l32r	a5, 420002c0 <_stext+0x2a0>
42001c02:	fb7c      	movi.n	a11, -1
42001c04:	20a550        	or	a10, a5, a5
42001c07:	f90e81        	l32r	a8, 42000040 <_stext+0x20>
42001c0a:	0008e0        	callx8	a8
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for(int n = 0; n < MAX_HOOKS; n++){
42001c0d:	f9aa21        	l32r	a2, 420002b8 <_stext+0x298>
42001c10:	1183b0        	slli	a8, a3, 5
42001c13:	882a      	add.n	a8, a8, a2
42001c15:	0a0c      	movi.n	a10, 0
42001c17:	890c      	movi.n	a9, 8
42001c19:	1b8976        	loop	a9, 42001c38 <esp_register_freertos_idle_hook_for_cpu+0x44>
        if (idle_cb[cpuid][n]==NULL) {
42001c1c:	0848      	l32i.n	a4, a8, 0
42001c1e:	24dc      	bnez.n	a4, 42001c34 <esp_register_freertos_idle_hook_for_cpu+0x40>
            idle_cb[cpuid][n]=new_idle_cb;
42001c20:	b033a0        	addx8	a3, a3, a10
42001c23:	a03320        	addx4	a3, a3, a2
42001c26:	0369      	s32i.n	a6, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42001c28:	05ad      	mov.n	a10, a5
42001c2a:	f90681        	l32r	a8, 42000044 <_stext+0x24>
42001c2d:	0008e0        	callx8	a8
            return ESP_OK;
42001c30:	042d      	mov.n	a2, a4
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
    return ESP_ERR_NO_MEM;
}
42001c32:	f01d      	retw.n
    for(int n = 0; n < MAX_HOOKS; n++){
42001c34:	aa1b      	addi.n	a10, a10, 1
42001c36:	884b      	addi.n	a8, a8, 4
    portEXIT_CRITICAL(&hooks_spinlock);
42001c38:	05ad      	mov.n	a10, a5
42001c3a:	f90281        	l32r	a8, 42000044 <_stext+0x24>
42001c3d:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42001c40:	01a122        	movi	a2, 0x101
42001c43:	fffac6        	j	42001c32 <esp_register_freertos_idle_hook_for_cpu+0x3e>
	...

42001c48 <esp_register_freertos_tick_hook_for_cpu>:
{
    return esp_register_freertos_idle_hook_for_cpu(new_idle_cb, xPortGetCoreID());
}

esp_err_t esp_register_freertos_tick_hook_for_cpu(esp_freertos_tick_cb_t new_tick_cb, UBaseType_t cpuid)
{
42001c48:	004136        	entry	a1, 32
42001c4b:	026d      	mov.n	a6, a2
    if(cpuid >= portNUM_PROCESSORS){
        return ESP_ERR_INVALID_ARG;
42001c4d:	02a122        	movi	a2, 0x102
    if(cpuid >= portNUM_PROCESSORS){
42001c50:	3223f6        	bgeui	a3, 2, 42001c86 <esp_register_freertos_tick_hook_for_cpu+0x3e>
42001c53:	f99b51        	l32r	a5, 420002c0 <_stext+0x2a0>
42001c56:	fb7c      	movi.n	a11, -1
42001c58:	20a550        	or	a10, a5, a5
42001c5b:	f8f981        	l32r	a8, 42000040 <_stext+0x20>
42001c5e:	0008e0        	callx8	a8
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for(int n = 0; n < MAX_HOOKS; n++){
42001c61:	f99821        	l32r	a2, 420002c4 <_stext+0x2a4>
42001c64:	1183b0        	slli	a8, a3, 5
42001c67:	882a      	add.n	a8, a8, a2
42001c69:	0a0c      	movi.n	a10, 0
42001c6b:	890c      	movi.n	a9, 8
42001c6d:	1b8976        	loop	a9, 42001c8c <esp_register_freertos_tick_hook_for_cpu+0x44>
        if (tick_cb[cpuid][n]==NULL) {
42001c70:	0848      	l32i.n	a4, a8, 0
42001c72:	24dc      	bnez.n	a4, 42001c88 <esp_register_freertos_tick_hook_for_cpu+0x40>
            tick_cb[cpuid][n]=new_tick_cb;
42001c74:	b033a0        	addx8	a3, a3, a10
42001c77:	a03320        	addx4	a3, a3, a2
42001c7a:	0369      	s32i.n	a6, a3, 0
            portEXIT_CRITICAL(&hooks_spinlock);
42001c7c:	05ad      	mov.n	a10, a5
42001c7e:	f8f181        	l32r	a8, 42000044 <_stext+0x24>
42001c81:	0008e0        	callx8	a8
            return ESP_OK;
42001c84:	042d      	mov.n	a2, a4
        }
    }
    portEXIT_CRITICAL(&hooks_spinlock);
    return ESP_ERR_NO_MEM;
}
42001c86:	f01d      	retw.n
    for(int n = 0; n < MAX_HOOKS; n++){
42001c88:	aa1b      	addi.n	a10, a10, 1
42001c8a:	884b      	addi.n	a8, a8, 4
    portEXIT_CRITICAL(&hooks_spinlock);
42001c8c:	05ad      	mov.n	a10, a5
42001c8e:	f8ed81        	l32r	a8, 42000044 <_stext+0x24>
42001c91:	0008e0        	callx8	a8
    return ESP_ERR_NO_MEM;
42001c94:	01a122        	movi	a2, 0x101
42001c97:	fffac6        	j	42001c86 <esp_register_freertos_tick_hook_for_cpu+0x3e>
	...

42001c9c <esp_deregister_freertos_idle_hook_for_cpu>:
{
    return esp_register_freertos_tick_hook_for_cpu(new_tick_cb, xPortGetCoreID());
}

void esp_deregister_freertos_idle_hook_for_cpu(esp_freertos_idle_cb_t old_idle_cb, UBaseType_t cpuid)
{
42001c9c:	004136        	entry	a1, 32
    if(cpuid >= portNUM_PROCESSORS){
42001c9f:	2f23f6        	bgeui	a3, 2, 42001cd2 <esp_deregister_freertos_idle_hook_for_cpu+0x36>
42001ca2:	f98741        	l32r	a4, 420002c0 <_stext+0x2a0>
42001ca5:	ffafb2        	movi	a11, -1
42001ca8:	20a440        	or	a10, a4, a4
42001cab:	f8e581        	l32r	a8, 42000040 <_stext+0x20>
42001cae:	0008e0        	callx8	a8
        return;
    }
    portENTER_CRITICAL(&hooks_spinlock);
    for(int n = 0; n < MAX_HOOKS; n++){
42001cb1:	f98181        	l32r	a8, 420002b8 <_stext+0x298>
42001cb4:	1133b0        	slli	a3, a3, 5
42001cb7:	338a      	add.n	a3, a3, a8
        if(idle_cb[cpuid][n] == old_idle_cb) idle_cb[cpuid][n] = NULL;
42001cb9:	090c      	movi.n	a9, 0
42001cbb:	08a082        	movi	a8, 8
42001cbe:	088876        	loop	a8, 42001cca <esp_deregister_freertos_idle_hook_for_cpu+0x2e>
42001cc1:	03a8      	l32i.n	a10, a3, 0
42001cc3:	0192a7        	bne	a2, a10, 42001cc8 <esp_deregister_freertos_idle_hook_for_cpu+0x2c>
42001cc6:	0399      	s32i.n	a9, a3, 0
    for(int n = 0; n < MAX_HOOKS; n++){
42001cc8:	334b      	addi.n	a3, a3, 4
    }
    portEXIT_CRITICAL(&hooks_spinlock);
42001cca:	04ad      	mov.n	a10, a4
42001ccc:	f8de81        	l32r	a8, 42000044 <_stext+0x24>
42001ccf:	0008e0        	callx8	a8
}
42001cd2:	f01d      	retw.n

42001cd4 <panic_print_char>:
{
42001cd4:	006136        	entry	a1, 48
    while (!uart_hal_get_txfifo_len(&s_panic_uart));
42001cd7:	f97ca1        	l32r	a10, 420002c8 <_stext+0x2a8>
{
42001cda:	742020        	extui	a2, a2, 0, 8
    uint32_t sz = 0;
42001cdd:	030c      	movi.n	a3, 0
    while (!uart_hal_get_txfifo_len(&s_panic_uart));
42001cdf:	002a42        	l32i	a4, a10, 0
42001ce2:	044122        	s8i	a2, a1, 4
    uint32_t sz = 0;
42001ce5:	006132        	s32i	a3, a1, 0
 *
 * @return The data length of txfifo can be written.
 */
FORCE_INLINE_ATTR uint32_t uart_ll_get_txfifo_len(uart_dev_t *hw)
{
    return UART_LL_FIFO_DEF_LEN - hw->status.txfifo_cnt;
42001ce8:	0020c0        	memw
42001ceb:	7438      	l32i.n	a3, a4, 28
42001ced:	953030        	extui	a3, a3, 16, 10
    while (!uart_hal_get_txfifo_len(&s_panic_uart));
42001cf0:	f4e326        	beqi	a3, 128, 42001ce8 <panic_print_char+0x14>
    uart_hal_write_txfifo(&s_panic_uart, (uint8_t *) &c, 1, &sz);
42001cf3:	01dd      	mov.n	a13, a1
42001cf5:	1c0c      	movi.n	a12, 1
42001cf7:	04c1b2        	addi	a11, a1, 4
42001cfa:	15fa25        	call8	42017c9c <uart_hal_write_txfifo>
42001cfd:	f97431        	l32r	a3, 420002d0 <_stext+0x2b0>
42001d00:	0020c0        	memw
42001d03:	1348      	l32i.n	a4, a3, 4
    while (!usb_serial_jtag_ll_txfifo_writable() && s_usbserial_timeout < (USBSERIAL_TIMEOUT_MAX_US / 100)) {
42001d05:	0be417        	bbsi	a4, 1, 42001d14 <panic_print_char+0x40>
42001d08:	f97141        	l32r	a4, 420002cc <_stext+0x2ac>
42001d0b:	f3a192        	movi	a9, 0x1f3
42001d0e:	002482        	l32i	a8, a4, 0
42001d11:	1fa987        	bge	a9, a8, 42001d34 <panic_print_char+0x60>
42001d14:	0020c0        	memw
42001d17:	1348      	l32i.n	a4, a3, 4
    if (usb_serial_jtag_ll_txfifo_writable()) {
42001d19:	136417        	bbci	a4, 1, 42001d30 <panic_print_char+0x5c>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
42001d1c:	0020c0        	memw
42001d1f:	1348      	l32i.n	a4, a3, 4
42001d21:	046417        	bbci	a4, 1, 42001d29 <panic_print_char+0x55>
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
42001d24:	0020c0        	memw
42001d27:	0329      	s32i.n	a2, a3, 0
        s_usbserial_timeout = 0;
42001d29:	f96821        	l32r	a2, 420002cc <_stext+0x2ac>
42001d2c:	030c      	movi.n	a3, 0
42001d2e:	0239      	s32i.n	a3, a2, 0
}
42001d30:	f01d      	retw.n
42001d32:	00          	.byte 00
42001d33:	00          	.byte 00
        esp_rom_delay_us(100);
42001d34:	64a0a2        	movi	a10, 100
42001d37:	f90a81        	l32r	a8, 42000160 <_stext+0x140>
42001d3a:	0008e0        	callx8	a8
        s_usbserial_timeout++;
42001d3d:	0488      	l32i.n	a8, a4, 0
42001d3f:	881b      	addi.n	a8, a8, 1
42001d41:	0489      	s32i.n	a8, a4, 0
42001d43:	ffee46        	j	42001d00 <panic_print_char+0x2c>
	...

42001d48 <panic_print_str>:
{
42001d48:	004136        	entry	a1, 32
    for (int i = 0; str[i] != 0; i++) {
42001d4b:	221b      	addi.n	a2, a2, 1
42001d4d:	820b      	addi.n	a8, a2, -1
42001d4f:	0008a2        	l8ui	a10, a8, 0
42001d52:	2acc      	bnez.n	a10, 42001d58 <panic_print_str+0x10>
}
42001d54:	f01d      	retw.n
42001d56:	00          	.byte 00
42001d57:	00          	.byte 00
        panic_print_char(str[i]);
42001d58:	fff7a5        	call8	42001cd4 <panic_print_char>
    for (int i = 0; str[i] != 0; i++) {
42001d5b:	fffb06        	j	42001d4b <panic_print_str+0x3>
	...

42001d60 <print_abort_details>:
{
42001d60:	004136        	entry	a1, 32
    panic_print_str(s_panic_abort_details);
42001d63:	f95c81        	l32r	a8, 420002d4 <_stext+0x2b4>
42001d66:	08a8      	l32i.n	a10, a8, 0
42001d68:	fffde5        	call8	42001d48 <panic_print_str>
}
42001d6b:	f01d      	retw.n
42001d6d:	000000        	ill

42001d70 <panic_print_hex>:
{
42001d70:	004136        	entry	a1, 32
42001d73:	830c      	movi.n	a3, 8
        if (c < 10) {
42001d75:	09a042        	movi	a4, 9
        c = (h >> 28) & 0xf; // extract the leftmost byte
42001d78:	358c20        	extui	a8, a2, 28, 4
        if (c < 10) {
42001d7b:	123487        	bltu	a4, a8, 42001d91 <panic_print_hex+0x21>
            panic_print_char('0' + c);
42001d7e:	30c8a2        	addi	a10, a8, 48
    for (x = 0; x < 8; x++) {
42001d81:	330b      	addi.n	a3, a3, -1
            panic_print_char('a' + c - 10);
42001d83:	fff525        	call8	42001cd4 <panic_print_char>
        h <<= 4; // move the 2nd leftmost byte to the left, to be extracted next
42001d86:	1122c0        	slli	a2, a2, 4
    for (x = 0; x < 8; x++) {
42001d89:	feb356        	bnez	a3, 42001d78 <panic_print_hex+0x8>
}
42001d8c:	f01d      	retw.n
42001d8e:	00          	.byte 00
42001d8f:	00          	.byte 00
42001d90:	00          	.byte 00
            panic_print_char('a' + c - 10);
42001d91:	57c8a2        	addi	a10, a8, 87
42001d94:	fffa46        	j	42001d81 <panic_print_hex+0x11>
	...

42001d98 <panic_print_dec>:
{
42001d98:	004136        	entry	a1, 32
    n1 = d % 10; // extract ones digit
42001d9b:	f94f31        	l32r	a3, 420002d8 <_stext+0x2b8>
42001d9e:	318f20        	srai	a8, a2, 31
42001da1:	b23230        	mulsh	a3, a2, a3
42001da4:	213230        	srai	a3, a3, 2
42001da7:	c03380        	sub	a3, a3, a8
42001daa:	20a330        	or	a10, a3, a3
42001dad:	a03330        	addx4	a3, a3, a3
42001db0:	803330        	add	a3, a3, a3
42001db3:	c03230        	sub	a3, a2, a3
    if (n2 == 0) {
42001db6:	012a56        	bnez	a10, 42001dcc <panic_print_dec+0x34>
        panic_print_char(' ');
42001db9:	20a0a2        	movi	a10, 32
        panic_print_char(n2 + '0');
42001dbc:	fff165        	call8	42001cd4 <panic_print_char>
    panic_print_char(n1 + '0');
42001dbf:	30c3a2        	addi	a10, a3, 48
42001dc2:	74a0a0        	extui	a10, a10, 0, 8
42001dc5:	fff0e5        	call8	42001cd4 <panic_print_char>
}
42001dc8:	f01d      	retw.n
42001dca:	00          	.byte 00
42001dcb:	00          	.byte 00
        panic_print_char(n2 + '0');
42001dcc:	30caa2        	addi	a10, a10, 48
42001dcf:	74a0a0        	extui	a10, a10, 0, 8
42001dd2:	fff986        	j	42001dbc <panic_print_dec+0x24>
42001dd5:	000000        	ill

42001dd8 <esp_panic_handler_reconfigure_wdts>:
{
42001dd8:	006136        	entry	a1, 48
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001ddb:	f94081        	l32r	a8, 420002dc <_stext+0x2bc>
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001dde:	71a2c2        	movi	a12, 0x271
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001de1:	0898      	l32i.n	a9, a8, 0
42001de3:	1888      	l32i.n	a8, a8, 4
42001de5:	2199      	s32i.n	a9, a1, 8
42001de7:	3189      	s32i.n	a8, a1, 12
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001de9:	f93d81        	l32r	a8, 420002e0 <_stext+0x2c0>
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001dec:	0d0c      	movi.n	a13, 0
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001dee:	0898      	l32i.n	a9, a8, 0
42001df0:	1888      	l32i.n	a8, a8, 4
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001df2:	11cca0        	slli	a12, a12, 6
42001df5:	1b0c      	movi.n	a11, 1
42001df7:	a18b      	addi.n	a10, a1, 8
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001df9:	006192        	s32i	a9, a1, 0
42001dfc:	016182        	s32i	a8, a1, 4
    wdt_hal_init(&wdt0_context, WDT_MWDT0, MWDT0_TICK_PRESCALER, false); //Prescaler: wdt counts in ticks of TG0_WDT_TICK_US
42001dff:	f8c181        	l32r	a8, 42000104 <_stext+0xe4>
42001e02:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt0_context);
42001e05:	a18b      	addi.n	a10, a1, 8
42001e07:	f8a481        	l32r	a8, 42000098 <_stext+0x78>
42001e0a:	0008e0        	callx8	a8
    wdt_hal_config_stage(&wdt0_context, 0, 1000 * 1000 / MWDT0_TICKS_PER_US, WDT_STAGE_ACTION_RESET_SYSTEM); //1 second before reset
42001e0d:	3d0c      	movi.n	a13, 3
42001e0f:	d0a7c2        	movi	a12, 0x7d0
42001e12:	0b0c      	movi.n	a11, 0
42001e14:	a18b      	addi.n	a10, a1, 8
42001e16:	f8a381        	l32r	a8, 420000a4 <_stext+0x84>
42001e19:	0008e0        	callx8	a8
    wdt_hal_enable(&wdt0_context);
42001e1c:	a18b      	addi.n	a10, a1, 8
42001e1e:	f8ba81        	l32r	a8, 42000108 <_stext+0xe8>
42001e21:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001e24:	a18b      	addi.n	a10, a1, 8
42001e26:	f8a081        	l32r	a8, 420000a8 <_stext+0x88>
42001e29:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001e2c:	01ad      	mov.n	a10, a1
42001e2e:	f89a81        	l32r	a8, 42000098 <_stext+0x78>
42001e31:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001e34:	01ad      	mov.n	a10, a1
42001e36:	f8c981        	l32r	a8, 4200015c <_stext+0x13c>
42001e39:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001e3c:	01ad      	mov.n	a10, a1
42001e3e:	f89a81        	l32r	a8, 420000a8 <_stext+0x88>
42001e41:	0008e0        	callx8	a8
}
42001e44:	f01d      	retw.n
	...

42001e48 <esp_panic_handler>:
{
42001e48:	00e136        	entry	a1, 112
    esp_panic_handler_reconfigure_wdts();
42001e4b:	fff8e5        	call8	42001dd8 <esp_panic_handler_reconfigure_wdts>
    if (g_panic_abort) {
42001e4e:	f8d761        	l32r	a6, 420001ac <_stext+0x18c>
42001e51:	000632        	l8ui	a3, a6, 0
42001e54:	0ae316        	beqz	a3, 42001f06 <esp_panic_handler+0xbe>
        info->details = s_panic_abort_details ? print_abort_details : NULL;
42001e57:	f91f41        	l32r	a4, 420002d4 <_stext+0x2b4>
        info->description = NULL;
42001e5a:	030c      	movi.n	a3, 0
        info->details = s_panic_abort_details ? print_abort_details : NULL;
42001e5c:	0458      	l32i.n	a5, a4, 0
42001e5e:	f92141        	l32r	a4, 420002e4 <_stext+0x2c4>
        info->description = NULL;
42001e61:	3239      	s32i.n	a3, a2, 12
        info->details = s_panic_abort_details ? print_abort_details : NULL;
42001e63:	834350        	moveqz	a4, a3, a5
        info->reason = NULL;
42001e66:	2239      	s32i.n	a3, a2, 8
        info->exception = PANIC_EXCEPTION_ABORT;
42001e68:	330c      	movi.n	a3, 3
        info->details = s_panic_abort_details ? print_abort_details : NULL;
42001e6a:	4249      	s32i.n	a4, a2, 16
        info->exception = PANIC_EXCEPTION_ABORT;
42001e6c:	1239      	s32i.n	a3, a2, 4
    if (info->description) {
42001e6e:	32a8      	l32i.n	a10, a2, 12
42001e70:	005a16        	beqz	a10, 42001e79 <esp_panic_handler+0x31>
        panic_print_str(info->description);
42001e73:	201110        	or	a1, a1, a1
42001e76:	ffed25        	call8	42001d48 <panic_print_str>
    panic_print_str("\r\n");
42001e79:	f91e51        	l32r	a5, 420002f4 <_stext+0x2d4>
42001e7c:	20a550        	or	a10, a5, a5
42001e7f:	ffeca5        	call8	42001d48 <panic_print_str>
    PANIC_INFO_DUMP(info, details);
42001e82:	042232        	l32i	a3, a2, 16
42001e85:	004316        	beqz	a3, 42001e8d <esp_panic_handler+0x45>
42001e88:	72a8      	l32i.n	a10, a2, 28
42001e8a:	0003e0        	callx8	a3
    panic_print_str("\r\n");
42001e8d:	20a550        	or	a10, a5, a5
42001e90:	ffeb65        	call8	42001d48 <panic_print_str>
    RER(reg, dcr);
42001e93:	f8b531        	l32r	a3, 42000168 <_stext+0x148>
42001e96:	406330        	rer	a3, a3
    if (esp_cpu_dbgr_is_attached()) {
42001e99:	02e307        	bbsi	a3, 0, 42001e9f <esp_panic_handler+0x57>
42001e9c:	002346        	j	42001f2d <esp_panic_handler+0xe5>
        panic_print_str("Setting breakpoint at 0x");
42001e9f:	f916a1        	l32r	a10, 420002f8 <_stext+0x2d8>
42001ea2:	ffea65        	call8	42001d48 <panic_print_str>
        panic_print_hex((uint32_t)info->addr);
42001ea5:	0622a2        	l32i	a10, a2, 24
42001ea8:	ffec65        	call8	42001d70 <panic_print_hex>
        panic_print_str(" and returning...\r\n");
42001eab:	f914a1        	l32r	a10, 420002fc <_stext+0x2dc>
42001eae:	ffe9a5        	call8	42001d48 <panic_print_str>
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001eb1:	f90a31        	l32r	a3, 420002dc <_stext+0x2bc>
    wdt_hal_write_protect_disable(&wdt0_context);
42001eb4:	44c1a2        	addi	a10, a1, 68
    wdt_hal_context_t wdt0_context = {.inst = WDT_MWDT0, .mwdt_dev = &TIMERG0};
42001eb7:	002342        	l32i	a4, a3, 0
42001eba:	1338      	l32i.n	a3, a3, 4
42001ebc:	116142        	s32i	a4, a1, 68
42001ebf:	126132        	s32i	a3, a1, 72
    wdt_hal_context_t wdt1_context = {.inst = WDT_MWDT1, .mwdt_dev = &TIMERG1};
42001ec2:	f90731        	l32r	a3, 420002e0 <_stext+0x2c0>
42001ec5:	0348      	l32i.n	a4, a3, 0
42001ec7:	1338      	l32i.n	a3, a3, 4
42001ec9:	0149      	s32i.n	a4, a1, 0
42001ecb:	1139      	s32i.n	a3, a1, 4
    wdt_hal_write_protect_disable(&wdt0_context);
42001ecd:	f87281        	l32r	a8, 42000098 <_stext+0x78>
42001ed0:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt0_context);
42001ed3:	44c1a2        	addi	a10, a1, 68
42001ed6:	f8a181        	l32r	a8, 4200015c <_stext+0x13c>
42001ed9:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt0_context);
42001edc:	44c1a2        	addi	a10, a1, 68
42001edf:	f87281        	l32r	a8, 420000a8 <_stext+0x88>
42001ee2:	0008e0        	callx8	a8
    wdt_hal_write_protect_disable(&wdt1_context);
42001ee5:	01ad      	mov.n	a10, a1
42001ee7:	f86c81        	l32r	a8, 42000098 <_stext+0x78>
42001eea:	0008e0        	callx8	a8
    wdt_hal_disable(&wdt1_context);
42001eed:	01ad      	mov.n	a10, a1
42001eef:	f89b81        	l32r	a8, 4200015c <_stext+0x13c>
42001ef2:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&wdt1_context);
42001ef5:	01ad      	mov.n	a10, a1
42001ef7:	f86c81        	l32r	a8, 420000a8 <_stext+0x88>
42001efa:	0008e0        	callx8	a8
        esp_cpu_set_breakpoint(0, info->addr); // use breakpoint 0
42001efd:	62b8      	l32i.n	a11, a2, 24
42001eff:	0a0c      	movi.n	a10, 0
42001f01:	164265        	call8	42018328 <esp_cpu_set_breakpoint>
}
42001f04:	f01d      	retw.n
    if (info->reason) {
42001f06:	022232        	l32i	a3, a2, 8
42001f09:	f61316        	beqz	a3, 42001e6e <esp_panic_handler+0x26>
        panic_print_str("Guru Meditation Error: Core ");
42001f0c:	f8f7a1        	l32r	a10, 420002e8 <_stext+0x2c8>
42001f0f:	ffe3a5        	call8	42001d48 <panic_print_str>
        panic_print_dec(info->core);
42001f12:	0022a2        	l32i	a10, a2, 0
42001f15:	ffe825        	call8	42001d98 <panic_print_dec>
        panic_print_str(" panic'ed (");
42001f18:	f8f5a1        	l32r	a10, 420002ec <_stext+0x2cc>
42001f1b:	ffe2e5        	call8	42001d48 <panic_print_str>
        panic_print_str(info->reason);
42001f1e:	0222a2        	l32i	a10, a2, 8
42001f21:	ffe265        	call8	42001d48 <panic_print_str>
        panic_print_str("). ");
42001f24:	f8f3a1        	l32r	a10, 420002f0 <_stext+0x2d0>
42001f27:	ffe225        	call8	42001d48 <panic_print_str>
42001f2a:	ffd006        	j	42001e6e <esp_panic_handler+0x26>
    if (!wdt_hal_is_enabled(&rtc_wdt_ctx)) {
42001f2d:	f8f431        	l32r	a3, 42000300 <_stext+0x2e0>
42001f30:	03ad      	mov.n	a10, a3
42001f32:	f8f681        	l32r	a8, 4200030c <_stext+0x2ec>
42001f35:	0008e0        	callx8	a8
42001f38:	0a4d      	mov.n	a4, a10
42001f3a:	053a56        	bnez	a10, 42001f91 <esp_panic_handler+0x149>
        wdt_hal_init(&rtc_wdt_ctx, WDT_RWDT, 0, false);
42001f3d:	0add      	mov.n	a13, a10
42001f3f:	0acd      	mov.n	a12, a10
42001f41:	0abd      	mov.n	a11, a10
42001f43:	03ad      	mov.n	a10, a3
42001f45:	f86f81        	l32r	a8, 42000104 <_stext+0xe4>
42001f48:	0008e0        	callx8	a8
        uint32_t stage_timeout_ticks = (uint32_t)(7000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001f4b:	f85281        	l32r	a8, 42000094 <_stext+0x74>
42001f4e:	0008e0        	callx8	a8
42001f51:	0a7d      	mov.n	a7, a10
        wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001f53:	20a330        	or	a10, a3, a3
42001f56:	f85081        	l32r	a8, 42000098 <_stext+0x78>
42001f59:	0008e0        	callx8	a8
        uint32_t stage_timeout_ticks = (uint32_t)(7000ULL * rtc_clk_slow_freq_get_hz() / 1000ULL);
42001f5c:	6ba3a2        	movi	a10, 0x36b
42001f5f:	11aad0        	slli	a10, a10, 3
42001f62:	a2b7a0        	muluh	a11, a7, a10
42001f65:	82a7a0        	mull	a10, a7, a10
42001f68:	e8a3c2        	movi	a12, 0x3e8
42001f6b:	04dd      	mov.n	a13, a4
42001f6d:	f84c81        	l32r	a8, 420000a0 <_stext+0x80>
42001f70:	0008e0        	callx8	a8
        wdt_hal_config_stage(&rtc_wdt_ctx, WDT_STAGE0, stage_timeout_ticks, WDT_STAGE_ACTION_RESET_SYSTEM);
42001f73:	0acd      	mov.n	a12, a10
42001f75:	3d0c      	movi.n	a13, 3
42001f77:	04bd      	mov.n	a11, a4
42001f79:	03ad      	mov.n	a10, a3
42001f7b:	f84a81        	l32r	a8, 420000a4 <_stext+0x84>
42001f7e:	0008e0        	callx8	a8
        wdt_hal_enable(&rtc_wdt_ctx);
42001f81:	03ad      	mov.n	a10, a3
42001f83:	f86181        	l32r	a8, 42000108 <_stext+0xe8>
42001f86:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001f89:	03ad      	mov.n	a10, a3
42001f8b:	f84781        	l32r	a8, 420000a8 <_stext+0x88>
42001f8e:	0008e0        	callx8	a8
    esp_panic_handler_reconfigure_wdts(); // Restart WDT again
42001f91:	ffe465        	call8	42001dd8 <esp_panic_handler_reconfigure_wdts>
    PANIC_INFO_DUMP(info, state);
42001f94:	5248      	l32i.n	a4, a2, 20
42001f96:	348c      	beqz.n	a4, 42001f9d <esp_panic_handler+0x155>
42001f98:	72a8      	l32i.n	a10, a2, 28
42001f9a:	0004e0        	callx8	a4
    panic_print_str("\r\n");
42001f9d:	05ad      	mov.n	a10, a5
42001f9f:	ffdaa5        	call8	42001d48 <panic_print_str>
    panic_print_str("\r\nELF file SHA256: ");
42001fa2:	f8d8a1        	l32r	a10, 42000304 <_stext+0x2e4>
    g_panic_abort = false;
42001fa5:	040c      	movi.n	a4, 0
42001fa7:	004642        	s8i	a4, a6, 0
    panic_print_str("\r\nELF file SHA256: ");
42001faa:	ffd9e5        	call8	42001d48 <panic_print_str>
    esp_app_get_elf_sha256(sha256_buf, sizeof(sha256_buf));
42001fad:	1b4c      	movi.n	a11, 65
42001faf:	01ad      	mov.n	a10, a1
42001fb1:	f81b81        	l32r	a8, 42000020 <_stext>
42001fb4:	0008e0        	callx8	a8
    panic_print_str(sha256_buf);
42001fb7:	01ad      	mov.n	a10, a1
42001fb9:	ffd8e5        	call8	42001d48 <panic_print_str>
    panic_print_str("\r\n");
42001fbc:	05ad      	mov.n	a10, a5
42001fbe:	ffd8a5        	call8	42001d48 <panic_print_str>
    panic_print_str("\r\n");
42001fc1:	05ad      	mov.n	a10, a5
42001fc3:	ffd865        	call8	42001d48 <panic_print_str>
    wdt_hal_write_protect_disable(&rtc_wdt_ctx);
42001fc6:	03ad      	mov.n	a10, a3
42001fc8:	f83481        	l32r	a8, 42000098 <_stext+0x78>
42001fcb:	0008e0        	callx8	a8
    wdt_hal_disable(&rtc_wdt_ctx);
42001fce:	03ad      	mov.n	a10, a3
42001fd0:	f86381        	l32r	a8, 4200015c <_stext+0x13c>
42001fd3:	0008e0        	callx8	a8
    wdt_hal_write_protect_enable(&rtc_wdt_ctx);
42001fd6:	03ad      	mov.n	a10, a3
42001fd8:	f83481        	l32r	a8, 420000a8 <_stext+0x88>
42001fdb:	0008e0        	callx8	a8
    if (esp_reset_reason_get_hint() == ESP_RST_UNKNOWN) {
42001fde:	f87f81        	l32r	a8, 420001dc <_stext+0x1bc>
42001fe1:	0008e0        	callx8	a8
42001fe4:	3adc      	bnez.n	a10, 42001ffb <esp_panic_handler+0x1b3>
        switch (info->exception) {
42001fe6:	1228      	l32i.n	a2, a2, 4
            esp_reset_reason_set_hint(ESP_RST_INT_WDT);
42001fe8:	5a0c      	movi.n	a10, 5
        switch (info->exception) {
42001fea:	071226        	beqi	a2, 1, 42001ff5 <esp_panic_handler+0x1ad>
            esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
42001fed:	6a0c      	movi.n	a10, 6
        switch (info->exception) {
42001fef:	022226        	beqi	a2, 2, 42001ff5 <esp_panic_handler+0x1ad>
            esp_reset_reason_set_hint(ESP_RST_PANIC);
42001ff2:	04a0a2        	movi	a10, 4
42001ff5:	f8c681        	l32r	a8, 42000310 <_stext+0x2f0>
42001ff8:	0008e0        	callx8	a8
    panic_print_str("Rebooting...\r\n");
42001ffb:	f8c3a1        	l32r	a10, 42000308 <_stext+0x2e8>
42001ffe:	ffd4a5        	call8	42001d48 <panic_print_str>
    panic_restart();
42002001:	ff7825        	call8	42001784 <panic_restart>

42002004 <uart_hal_txfifo_rst>:

// The HAL layer for UART (IRAM part)
#include "hal/uart_hal.h"

void uart_hal_txfifo_rst(uart_hal_context_t *hal)
{
42002004:	004136        	entry	a1, 32
    uart_ll_txfifo_rst(hal->dev);
42002007:	0288      	l32i.n	a8, a2, 0
    hw->conf0.txfifo_rst = 1;
42002009:	1a0c      	movi.n	a10, 1
4200200b:	0020c0        	memw
4200200e:	8898      	l32i.n	a9, a8, 32
42002010:	01aae0        	slli	a10, a10, 18
42002013:	2099a0        	or	a9, a9, a10
42002016:	0020c0        	memw
42002019:	8899      	s32i.n	a9, a8, 32
    hw->conf0.txfifo_rst = 0;
4200201b:	0020c0        	memw
4200201e:	8898      	l32i.n	a9, a8, 32
42002020:	f8bda1        	l32r	a10, 42000314 <_stext+0x2f4>
42002023:	1099a0        	and	a9, a9, a10
42002026:	0020c0        	memw
42002029:	8899      	s32i.n	a9, a8, 32
}
4200202b:	f01d      	retw.n
4200202d:	000000        	ill

42002030 <uart_hal_rxfifo_rst>:

void uart_hal_rxfifo_rst(uart_hal_context_t *hal)
{
42002030:	004136        	entry	a1, 32
    uart_ll_rxfifo_rst(hal->dev);
42002033:	0288      	l32i.n	a8, a2, 0
    hw->conf0.rxfifo_rst = 1;
42002035:	1a0c      	movi.n	a10, 1
42002037:	0020c0        	memw
4200203a:	8898      	l32i.n	a9, a8, 32
4200203c:	01aaf0        	slli	a10, a10, 17
4200203f:	2099a0        	or	a9, a9, a10
42002042:	0020c0        	memw
42002045:	8899      	s32i.n	a9, a8, 32
    hw->conf0.rxfifo_rst = 0;
42002047:	0020c0        	memw
4200204a:	8898      	l32i.n	a9, a8, 32
4200204c:	f8b3a1        	l32r	a10, 42000318 <_stext+0x2f8>
4200204f:	1099a0        	and	a9, a9, a10
42002052:	0020c0        	memw
42002055:	8899      	s32i.n	a9, a8, 32
}
42002057:	f01d      	retw.n
42002059:	000000        	ill

4200205c <brownout_hal_config>:
{
4200205c:	006136        	entry	a1, 48
    REGI2C_WRITE_MASK(I2C_BOD, I2C_BOD_THRESHOLD, cfg->threshold);
4200205f:	0002f2        	l8ui	a15, a2, 0
42002062:	61a0a2        	movi	a10, 97
42002065:	0e0c      	movi.n	a14, 0
42002067:	2d0c      	movi.n	a13, 2
42002069:	5c0c      	movi.n	a12, 5
4200206b:	01a0b2        	movi	a11, 1
4200206e:	f8af81        	l32r	a8, 4200032c <_stext+0x30c>
42002071:	0008e0        	callx8	a8
    typeof(RTCCNTL.brown_out) brown_out_reg = {
42002074:	080c      	movi.n	a8, 0
42002076:	0020c0        	memw
42002079:	0189      	s32i.n	a8, a1, 0
4200207b:	0020c0        	memw
4200207e:	0188      	l32i.n	a8, a1, 0
42002080:	f8a791        	l32r	a9, 4200031c <_stext+0x2fc>
42002083:	f8a7a1        	l32r	a10, 42000320 <_stext+0x300>
42002086:	108890        	and	a8, a8, a9
42002089:	092c      	movi.n	a9, 32
4200208b:	208890        	or	a8, a8, a9
4200208e:	0020c0        	memw
42002091:	0189      	s32i.n	a8, a1, 0
        .close_flash_ena = cfg->flash_power_down,
42002093:	030292        	l8ui	a9, a2, 3
    typeof(RTCCNTL.brown_out) brown_out_reg = {
42002096:	0020c0        	memw
42002099:	0188      	l32i.n	a8, a1, 0
4200209b:	049090        	extui	a9, a9, 0, 1
4200209e:	119920        	slli	a9, a9, 14
420020a1:	1088a0        	and	a8, a8, a10
420020a4:	208890        	or	a8, a8, a9
420020a7:	0020c0        	memw
420020aa:	0189      	s32i.n	a8, a1, 0
        .pd_rf_ena = cfg->rf_power_down,
420020ac:	040292        	l8ui	a9, a2, 4
    typeof(RTCCNTL.brown_out) brown_out_reg = {
420020af:	0020c0        	memw
420020b2:	0188      	l32i.n	a8, a1, 0
420020b4:	f89ca1        	l32r	a10, 42000324 <_stext+0x304>
420020b7:	049090        	extui	a9, a9, 0, 1
420020ba:	119910        	slli	a9, a9, 15
420020bd:	1088a0        	and	a8, a8, a10
420020c0:	208890        	or	a8, a8, a9
420020c3:	0020c0        	memw
420020c6:	0189      	s32i.n	a8, a1, 0
420020c8:	0020c0        	memw
420020cb:	0188      	l32i.n	a8, a1, 0
420020cd:	ffa392        	movi	a9, 0x3ff
420020d0:	119900        	slli	a9, a9, 16
420020d3:	208890        	or	a8, a8, a9
420020d6:	0020c0        	memw
420020d9:	0189      	s32i.n	a8, a1, 0
        .rst_ena = cfg->reset_enabled,
420020db:	020292        	l8ui	a9, a2, 2
    typeof(RTCCNTL.brown_out) brown_out_reg = {
420020de:	0020c0        	memw
420020e1:	0188      	l32i.n	a8, a1, 0
420020e3:	f891a1        	l32r	a10, 42000328 <_stext+0x308>
420020e6:	049090        	extui	a9, a9, 0, 1
420020e9:	019960        	slli	a9, a9, 26
420020ec:	1088a0        	and	a8, a8, a10
420020ef:	208890        	or	a8, a8, a9
420020f2:	0020c0        	memw
420020f5:	0189      	s32i.n	a8, a1, 0
420020f7:	0020c0        	memw
420020fa:	0188      	l32i.n	a8, a1, 0
420020fc:	190c      	movi.n	a9, 1
420020fe:	019950        	slli	a9, a9, 27
42002101:	208890        	or	a8, a8, a9
42002104:	0020c0        	memw
42002107:	0189      	s32i.n	a8, a1, 0
        .ena = cfg->enabled,
42002109:	010292        	l8ui	a9, a2, 1
    typeof(RTCCNTL.brown_out) brown_out_reg = {
4200210c:	0020c0        	memw
4200210f:	0188      	l32i.n	a8, a1, 0
42002111:	f7d421        	l32r	a2, 42000064 <_stext+0x44>
42002114:	049090        	extui	a9, a9, 0, 1
42002117:	108820        	and	a8, a8, a2
4200211a:	019920        	slli	a9, a9, 30
4200211d:	208890        	or	a8, a8, a9
42002120:	0020c0        	memw
42002123:	0189      	s32i.n	a8, a1, 0
    RTCCNTL.brown_out = brown_out_reg;
42002125:	0020c0        	memw
42002128:	0188      	l32i.n	a8, a1, 0
4200212a:	f7d221        	l32r	a2, 42000074 <_stext+0x54>
4200212d:	0020c0        	memw
42002130:	3a6282        	s32i	a8, a2, 232
}
42002133:	f01d      	retw.n
42002135:	000000        	ill

42002138 <brownout_hal_intr_enable>:
{
42002138:	004136        	entry	a1, 32
    RTCCNTL.int_ena.rtc_brown_out = enable;
4200213b:	f7ce91        	l32r	a9, 42000074 <_stext+0x54>
4200213e:	042020        	extui	a2, a2, 0, 1
42002141:	0020c0        	memw
42002144:	102982        	l32i	a8, a9, 64
42002147:	ffada2        	movi	a10, 0xfffffdff
4200214a:	112270        	slli	a2, a2, 9
4200214d:	1088a0        	and	a8, a8, a10
42002150:	208820        	or	a8, a8, a2
42002153:	0020c0        	memw
42002156:	106982        	s32i	a8, a9, 64
}
42002159:	f01d      	retw.n
	...

4200215c <heap_caps_get_info>:
    heap_caps_get_info(&info, caps);
    return info.largest_free_block;
}

void heap_caps_get_info( multi_heap_info_t *info, uint32_t caps )
{
4200215c:	008136        	entry	a1, 64
    bzero(info, sizeof(multi_heap_info_t));
4200215f:	cc1c      	movi.n	a12, 28
42002161:	0b0c      	movi.n	a11, 0
42002163:	20a220        	or	a10, a2, a2
42002166:	f80c81        	l32r	a8, 42000198 <_stext+0x178>
42002169:	0008e0        	callx8	a8

    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
4200216c:	f87141        	l32r	a4, 42000330 <_stext+0x310>
4200216f:	0448      	l32i.n	a4, a4, 0
42002171:	14cc      	bnez.n	a4, 42002176 <heap_caps_get_info+0x1a>
            info->allocated_blocks += hinfo.allocated_blocks;
            info->free_blocks += hinfo.free_blocks;
            info->total_blocks += hinfo.total_blocks;
        }
    }
}
42002173:	f01d      	retw.n
42002175:	00          	.byte 00
        if (heap_caps_match(heap, caps)) {
42002176:	20b330        	or	a11, a3, a3
42002179:	20a440        	or	a10, a4, a4
4200217c:	15b825        	call8	42017d00 <heap_caps_match>
4200217f:	03fa16        	beqz	a10, 420021c2 <heap_caps_get_info+0x66>
            multi_heap_get_info(heap->heap, &hinfo);
42002182:	74a8      	l32i.n	a10, a4, 28
42002184:	01bd      	mov.n	a11, a1
42002186:	16b2a5        	call8	42018cb0 <multi_heap_get_info>
            info->total_free_bytes += hinfo.total_free_bytes;
42002189:	0288      	l32i.n	a8, a2, 0
4200218b:	0198      	l32i.n	a9, a1, 0
4200218d:	889a      	add.n	a8, a8, a9
4200218f:	0289      	s32i.n	a8, a2, 0
            info->total_allocated_bytes += hinfo.total_allocated_bytes;
42002191:	1198      	l32i.n	a9, a1, 4
42002193:	1288      	l32i.n	a8, a2, 4
42002195:	889a      	add.n	a8, a8, a9
42002197:	1289      	s32i.n	a8, a2, 4
            info->largest_free_block = MAX(info->largest_free_block,
42002199:	2198      	l32i.n	a9, a1, 8
4200219b:	2288      	l32i.n	a8, a2, 8
4200219d:	738890        	maxu	a8, a8, a9
420021a0:	2289      	s32i.n	a8, a2, 8
            info->minimum_free_bytes += hinfo.minimum_free_bytes;
420021a2:	3198      	l32i.n	a9, a1, 12
420021a4:	3288      	l32i.n	a8, a2, 12
420021a6:	889a      	add.n	a8, a8, a9
420021a8:	3289      	s32i.n	a8, a2, 12
            info->allocated_blocks += hinfo.allocated_blocks;
420021aa:	4198      	l32i.n	a9, a1, 16
420021ac:	4288      	l32i.n	a8, a2, 16
420021ae:	889a      	add.n	a8, a8, a9
420021b0:	4289      	s32i.n	a8, a2, 16
            info->free_blocks += hinfo.free_blocks;
420021b2:	5198      	l32i.n	a9, a1, 20
420021b4:	5288      	l32i.n	a8, a2, 20
420021b6:	889a      	add.n	a8, a8, a9
420021b8:	5289      	s32i.n	a8, a2, 20
            info->total_blocks += hinfo.total_blocks;
420021ba:	6198      	l32i.n	a9, a1, 24
420021bc:	6288      	l32i.n	a8, a2, 24
420021be:	889a      	add.n	a8, a8, a9
420021c0:	6289      	s32i.n	a8, a2, 24
    SLIST_FOREACH(heap, &registered_heaps, next) {
420021c2:	8448      	l32i.n	a4, a4, 32
420021c4:	ffea46        	j	42002171 <heap_caps_get_info+0x15>
	...

420021c8 <heap_caps_get_largest_free_block>:
{
420021c8:	008136        	entry	a1, 64
    heap_caps_get_info(&info, caps);
420021cb:	20b220        	or	a11, a2, a2
420021ce:	20a110        	or	a10, a1, a1
420021d1:	fff8a5        	call8	4200215c <heap_caps_get_info>
}
420021d4:	022122        	l32i	a2, a1, 8
420021d7:	f01d      	retw.n
420021d9:	000000        	ill

420021dc <register_heap>:

/* Linked-list of registered heaps */
struct registered_heap_ll registered_heaps;

static void register_heap(heap_t *region)
{
420021dc:	004136        	entry	a1, 32
    size_t heap_size = region->end - region->start;
420021df:	32a8      	l32i.n	a10, a2, 12
420021e1:	42b8      	l32i.n	a11, a2, 16
    assert(heap_size <= HEAP_SIZE_MAX);
420021e3:	180c      	movi.n	a8, 1
    size_t heap_size = region->end - region->start;
420021e5:	c0bba0        	sub	a11, a11, a10
    assert(heap_size <= HEAP_SIZE_MAX);
420021e8:	018870        	slli	a8, a8, 25
420021eb:	10b8b7        	bgeu	a8, a11, 420021ff <register_heap+0x23>
420021ee:	f851d1        	l32r	a13, 42000334 <_stext+0x314>
420021f1:	f851c1        	l32r	a12, 42000338 <_stext+0x318>
420021f4:	f852a1        	l32r	a10, 4200033c <_stext+0x31c>
420021f7:	9b1c      	movi.n	a11, 25
420021f9:	f7a281        	l32r	a8, 42000084 <_stext+0x64>
420021fc:	0008e0        	callx8	a8
    region->heap = multi_heap_register((void *)region->start, heap_size);
420021ff:	16a665        	call8	42018c64 <multi_heap_register>
42002202:	72a9      	s32i.n	a10, a2, 28
    if (region->heap != NULL) {
        ESP_EARLY_LOGD(TAG, "New heap initialised at %p", region->heap);
    }
}
42002204:	f01d      	retw.n
	...

42002208 <heap_caps_enable_nonos_stack_heaps>:

void heap_caps_enable_nonos_stack_heaps(void)
{
42002208:	004136        	entry	a1, 32
    heap_t *heap;
    SLIST_FOREACH(heap, &registered_heaps, next) {
4200220b:	f84921        	l32r	a2, 42000330 <_stext+0x310>
4200220e:	0228      	l32i.n	a2, a2, 0
42002210:	02cc      	bnez.n	a2, 42002214 <heap_caps_enable_nonos_stack_heaps+0xc>
            if (heap->heap != NULL) {
                multi_heap_set_lock(heap->heap, &heap->heap_mux);
            }
        }
    }
}
42002212:	f01d      	retw.n
        if (heap->heap == NULL) {
42002214:	072282        	l32i	a8, a2, 28
42002217:	012856        	bnez	a8, 4200222d <heap_caps_enable_nonos_stack_heaps+0x25>
            register_heap(heap);
4200221a:	20a220        	or	a10, a2, a2
4200221d:	fffbe5        	call8	420021dc <register_heap>
            if (heap->heap != NULL) {
42002220:	72a8      	l32i.n	a10, a2, 28
42002222:	7a8c      	beqz.n	a10, 4200222d <heap_caps_enable_nonos_stack_heaps+0x25>
                multi_heap_set_lock(heap->heap, &heap->heap_mux);
42002224:	14c2b2        	addi	a11, a2, 20
42002227:	f84681        	l32r	a8, 42000340 <_stext+0x320>
4200222a:	0008e0        	callx8	a8
    SLIST_FOREACH(heap, &registered_heaps, next) {
4200222d:	8228      	l32i.n	a2, a2, 32
4200222f:	fff746        	j	42002210 <heap_caps_enable_nonos_stack_heaps+0x8>
	...

42002234 <heap_caps_init>:

/* Initialize the heap allocator to use all of the memory not
   used by static data or reserved for other purposes
 */
void heap_caps_init(void)
{
42002234:	006136        	entry	a1, 48
42002237:	207110        	or	a7, a1, a1
    multi_heap_in_rom_init();
#endif
    /* Get the array of regions that we can use for heaps
       (with reserved memory removed already.)
     */
    size_t num_regions = soc_get_available_memory_region_max_count();
4200223a:	001965        	call8	420023d0 <soc_get_available_memory_region_max_count>
    soc_memory_region_t regions[num_regions];
4200223d:	11aac0        	slli	a10, a10, 4
42002240:	c0a1a0        	sub	a10, a1, a10
42002243:	001a10        	movsp	a1, a10
    num_regions = soc_get_available_memory_regions(regions);
42002246:	001a65        	call8	420023ec <soc_get_available_memory_regions>
    soc_memory_region_t regions[num_regions];
42002249:	202110        	or	a2, a1, a1
    num_regions = soc_get_available_memory_regions(regions);
4200224c:	20caa0        	or	a12, a10, a10
    // based on how many regions were coalesed.
    size_t num_heaps = num_regions;

    //The heap allocator will treat every region given to it as separate. In order to get bigger ranges of contiguous memory,
    //it's useful to coalesce adjacent regions that have the same type.
    for (size_t i = 1; i < num_regions; i++) {
4200224f:	024d      	mov.n	a4, a2
    num_regions = soc_get_available_memory_regions(regions);
42002251:	0a3d      	mov.n	a3, a10
    for (size_t i = 1; i < num_regions; i++) {
42002253:	150c      	movi.n	a5, 1
        soc_memory_region_t *a = &regions[i - 1];
        soc_memory_region_t *b = &regions[i];
        if (b->start == (intptr_t)(a->start + a->size) && b->type == a->type ) {
            a->type = -1;
42002255:	f97c      	movi.n	a9, -1
    for (size_t i = 1; i < num_regions; i++) {
42002257:	2f35c7        	bltu	a5, a12, 4200228a <heap_caps_init+0x56>

    /* Start by allocating the registered heap data on the stack.

       Once we have a heap to copy it to, we will copy it to a heap buffer.
    */
    heap_t temp_heaps[num_heaps];
4200225a:	b05330        	addx8	a5, a3, a3
4200225d:	1155e0        	slli	a5, a5, 2
42002260:	45fb      	addi.n	a4, a5, 15
42002262:	414440        	srli	a4, a4, 4
42002265:	1144c0        	slli	a4, a4, 4
42002268:	c04140        	sub	a4, a1, a4
4200226b:	001410        	movsp	a1, a4
    size_t heap_idx = 0;

    ESP_EARLY_LOGI(TAG, "Initializing. RAM available for dynamic allocation:");
    for (size_t i = 0; i < num_regions; i++) {
4200226e:	0b0c      	movi.n	a11, 0
    heap_t temp_heaps[num_heaps];
42002270:	016d      	mov.n	a6, a1
    size_t heap_idx = 0;
42002272:	0b4d      	mov.n	a4, a11
    for (size_t i = 0; i < num_regions; i++) {
42002274:	389bc7        	bne	a11, a12, 420022b0 <heap_caps_init+0x7c>

        ESP_EARLY_LOGI(TAG, "At %08X len %08X (%d KiB): %s",
                       region->start, region->size, region->size / 1024, type->name);
    }

    assert(heap_idx == num_heaps);
42002277:	029347        	bne	a3, a4, 4200227d <heap_caps_init+0x49>
4200227a:	002f86        	j	4200233c <heap_caps_init+0x108>
4200227d:	f835d1        	l32r	a13, 42000354 <_stext+0x334>
42002280:	f832c1        	l32r	a12, 42000348 <_stext+0x328>
42002283:	75a0b2        	movi	a11, 117
42002286:	000e46        	j	420022c3 <heap_caps_init+0x8f>
42002289:	00          	.byte 00
        if (b->start == (intptr_t)(a->start + a->size) && b->type == a->type ) {
4200228a:	0468      	l32i.n	a6, a4, 0
4200228c:	1488      	l32i.n	a8, a4, 4
4200228e:	44b8      	l32i.n	a11, a4, 16
42002290:	a68a      	add.n	a10, a6, a8
42002292:	129ba7        	bne	a11, a10, 420022a8 <heap_caps_init+0x74>
42002295:	64b8      	l32i.n	a11, a4, 24
42002297:	24a8      	l32i.n	a10, a4, 8
42002299:	0b9ba7        	bne	a11, a10, 420022a8 <heap_caps_init+0x74>
            b->start = a->start;
4200229c:	4469      	s32i.n	a6, a4, 16
            b->size += a->size;
4200229e:	5468      	l32i.n	a6, a4, 20
            a->type = -1;
420022a0:	2499      	s32i.n	a9, a4, 8
            b->size += a->size;
420022a2:	668a      	add.n	a6, a6, a8
420022a4:	5469      	s32i.n	a6, a4, 20
            num_heaps--;
420022a6:	330b      	addi.n	a3, a3, -1
    for (size_t i = 1; i < num_regions; i++) {
420022a8:	551b      	addi.n	a5, a5, 1
420022aa:	10c442        	addi	a4, a4, 16
420022ad:	ffe986        	j	42002257 <heap_caps_init+0x23>
        const soc_memory_type_desc_t *type = &soc_memory_types[region->type];
420022b0:	2288      	l32i.n	a8, a2, 8
        if (region->type == -1) {
420022b2:	670826        	beqi	a8, -1, 4200231d <heap_caps_init+0xe9>
        heap_idx++;
420022b5:	d41b      	addi.n	a13, a4, 1
        assert(heap_idx <= num_heaps);
420022b7:	11b3d7        	bgeu	a3, a13, 420022cc <heap_caps_init+0x98>
420022ba:	f822d1        	l32r	a13, 42000344 <_stext+0x324>
420022bd:	f822c1        	l32r	a12, 42000348 <_stext+0x328>
420022c0:	63a0b2        	movi	a11, 99
    assert(heap_idx == num_heaps);
420022c3:	f81ea1        	l32r	a10, 4200033c <_stext+0x31c>
420022c6:	f76f81        	l32r	a8, 42000084 <_stext+0x64>
420022c9:	0008e0        	callx8	a8
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
420022cc:	a08880        	addx4	a8, a8, a8
420022cf:	f81fe1        	l32r	a14, 4200034c <_stext+0x32c>
        heap_t *heap = &temp_heaps[heap_idx];
420022d2:	1194d0        	slli	a9, a4, 3
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
420022d5:	1188e0        	slli	a8, a8, 2
        heap_t *heap = &temp_heaps[heap_idx];
420022d8:	0799      	s32i.n	a9, a7, 0
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
420022da:	984b      	addi.n	a9, a8, 4
420022dc:	99ea      	add.n	a9, a9, a14
420022de:	19e8      	l32i.n	a14, a9, 4
420022e0:	09f8      	l32i.n	a15, a9, 0
        heap_t *heap = &temp_heaps[heap_idx];
420022e2:	b0a440        	addx8	a10, a4, a4
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
420022e5:	2998      	l32i.n	a9, a9, 8
        heap_t *heap = &temp_heaps[heap_idx];
420022e7:	a0aa60        	addx4	a10, a10, a6
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
420022ea:	1ae9      	s32i.n	a14, a10, 4
420022ec:	2a99      	s32i.n	a9, a10, 8
        heap->start = region->start;
420022ee:	02e8      	l32i.n	a14, a2, 0
        heap->end = region->start + region->size;
420022f0:	1298      	l32i.n	a9, a2, 4
        heap->start = region->start;
420022f2:	3ae9      	s32i.n	a14, a10, 12
        heap->end = region->start + region->size;
420022f4:	99ea      	add.n	a9, a9, a14
        if (type->startup_stack) {
420022f6:	f815e1        	l32r	a14, 4200034c <_stext+0x32c>
        heap->end = region->start + region->size;
420022f9:	4a99      	s32i.n	a9, a10, 16
    lock->owner = SPINLOCK_FREE;
420022fb:	f81591        	l32r	a9, 42000350 <_stext+0x330>
        if (type->startup_stack) {
420022fe:	8e8a      	add.n	a8, a14, a8
42002300:	5a99      	s32i.n	a9, a10, 20
42002302:	110882        	l8ui	a8, a8, 17
    lock->count = 0;
42002305:	090c      	movi.n	a9, 0
        memcpy(heap->caps, type->caps, sizeof(heap->caps));
42002307:	0af9      	s32i.n	a15, a10, 0
42002309:	6a99      	s32i.n	a9, a10, 24
        if (type->startup_stack) {
4200230b:	161897        	beq	a8, a9, 42002325 <heap_caps_init+0xf1>
            heap->heap = NULL;
4200230e:	7a99      	s32i.n	a9, a10, 28
        SLIST_NEXT(heap, next) = NULL;
42002310:	0788      	l32i.n	a8, a7, 0
42002312:	484a      	add.n	a4, a8, a4
42002314:	a04460        	addx4	a4, a4, a6
42002317:	080c      	movi.n	a8, 0
42002319:	8489      	s32i.n	a8, a4, 32
        ESP_EARLY_LOGI(TAG, "At %08X len %08X (%d KiB): %s",
4200231b:	0d4d      	mov.n	a4, a13
    for (size_t i = 0; i < num_regions; i++) {
4200231d:	bb1b      	addi.n	a11, a11, 1
4200231f:	10c222        	addi	a2, a2, 16
42002322:	ffd386        	j	42002274 <heap_caps_init+0x40>
            register_heap(heap);
42002325:	0167b2        	s32i	a11, a7, 4
42002328:	0267c2        	s32i	a12, a7, 8
4200232b:	0367d2        	s32i	a13, a7, 12
4200232e:	ffeae5        	call8	420021dc <register_heap>
42002331:	37d8      	l32i.n	a13, a7, 12
42002333:	27c8      	l32i.n	a12, a7, 8
42002335:	17b8      	l32i.n	a11, a7, 4
42002337:	fff546        	j	42002310 <heap_caps_init+0xdc>
4200233a:	00          	.byte 00
4200233b:	00          	.byte 00

    /* Allocate the permanent heap data that we'll use as a linked list at runtime.

       Allocate this part of data contiguously, even though it's a linked list... */
    assert(SLIST_EMPTY(&registered_heaps));
4200233c:	f7fd91        	l32r	a9, 42000330 <_stext+0x310>
4200233f:	0928      	l32i.n	a2, a9, 0
42002341:	069d      	mov.n	a9, a6
42002343:	32ac      	beqz.n	a2, 4200236a <heap_caps_init+0x136>
42002345:	f804d1        	l32r	a13, 42000358 <_stext+0x338>
42002348:	f800c1        	l32r	a12, 42000348 <_stext+0x328>
4200234b:	7aa0b2        	movi	a11, 122
4200234e:	ffdc46        	j	420022c3 <heap_caps_init+0x8f>

    heap_t *heaps_array = NULL;
    for (size_t i = 0; i < num_heaps; i++) {
        if (heap_caps_match(&temp_heaps[i], MALLOC_CAP_8BIT|MALLOC_CAP_INTERNAL)) {
42002351:	01a2b2        	movi	a11, 0x201
42002354:	20a990        	or	a10, a9, a9
42002357:	11bbe0        	slli	a11, a11, 2
4200235a:	016792        	s32i	a9, a7, 4
4200235d:	159a25        	call8	42017d00 <heap_caps_match>
42002360:	012792        	l32i	a9, a7, 4
42002363:	2adc      	bnez.n	a10, 42002379 <heap_caps_init+0x145>
    for (size_t i = 0; i < num_heaps; i++) {
42002365:	221b      	addi.n	a2, a2, 1
42002367:	24c992        	addi	a9, a9, 36
4200236a:	e39327        	bne	a3, a2, 42002351 <heap_caps_init+0x11d>
            if (heaps_array != NULL) {
                break;
            }
        }
    }
    assert(heaps_array != NULL); /* if NULL, there's not enough free startup heap space */
4200236d:	f7fbd1        	l32r	a13, 4200035c <_stext+0x33c>
42002370:	f7f6c1        	l32r	a12, 42000348 <_stext+0x328>
42002373:	86a0b2        	movi	a11, 134
42002376:	ffd246        	j	420022c3 <heap_caps_init+0x8f>
            heaps_array = multi_heap_malloc(temp_heaps[i].heap, sizeof(heap_t) * num_heaps);
42002379:	79a8      	l32i.n	a10, a9, 28
4200237b:	05bd      	mov.n	a11, a5
4200237d:	1799      	s32i.n	a9, a7, 4
4200237f:	f7f881        	l32r	a8, 42000360 <_stext+0x340>
42002382:	0008e0        	callx8	a8
            if (heaps_array != NULL) {
42002385:	1798      	l32i.n	a9, a7, 4
            heaps_array = multi_heap_malloc(temp_heaps[i].heap, sizeof(heap_t) * num_heaps);
42002387:	0a4d      	mov.n	a4, a10
            if (heaps_array != NULL) {
42002389:	fd8a16        	beqz	a10, 42002365 <heap_caps_init+0x131>

    memcpy(heaps_array, temp_heaps, sizeof(heap_t)*num_heaps);
4200238c:	20c550        	or	a12, a5, a5
4200238f:	20b660        	or	a11, a6, a6
42002392:	f78e81        	l32r	a8, 420001cc <_stext+0x1ac>
42002395:	0008e0        	callx8	a8

    /* Iterate the heaps and set their locks, also add them to the linked list. */
    for (size_t i = 0; i < num_heaps; i++) {
42002398:	fcc422        	addi	a2, a4, -4
4200239b:	050c      	movi.n	a5, 0
4200239d:	0007c6        	j	420023c0 <heap_caps_init+0x18c>
420023a0:	00          	.byte 00
        if (heaps_array[i].heap != NULL) {
420023a1:	82a8      	l32i.n	a10, a2, 32
420023a3:	624b      	addi.n	a6, a2, 4
420023a5:	7a8c      	beqz.n	a10, 420023b0 <heap_caps_init+0x17c>
            multi_heap_set_lock(heaps_array[i].heap, &heaps_array[i].heap_mux);
420023a7:	18c2b2        	addi	a11, a2, 24
420023aa:	f7e581        	l32r	a8, 42000340 <_stext+0x320>
420023ad:	0008e0        	callx8	a8
        }
        if (i == 0) {
420023b0:	15dc      	bnez.n	a5, 420023c5 <heap_caps_init+0x191>
            SLIST_INSERT_HEAD(&registered_heaps, &heaps_array[0], next);
420023b2:	f7dfe1        	l32r	a14, 42000330 <_stext+0x310>
420023b5:	0e68      	l32i.n	a6, a14, 0
420023b7:	0e49      	s32i.n	a4, a14, 0
420023b9:	8469      	s32i.n	a6, a4, 32
    for (size_t i = 0; i < num_heaps; i++) {
420023bb:	551b      	addi.n	a5, a5, 1
420023bd:	24c222        	addi	a2, a2, 36
420023c0:	dd9357        	bne	a3, a5, 420023a1 <heap_caps_init+0x16d>
        } else {
            SLIST_INSERT_AFTER(&heaps_array[i-1], &heaps_array[i], next);
        }
    }
}
420023c3:	f01d      	retw.n
            SLIST_INSERT_AFTER(&heaps_array[i-1], &heaps_array[i], next);
420023c5:	0298      	l32i.n	a9, a2, 0
420023c7:	0269      	s32i.n	a6, a2, 0
420023c9:	9299      	s32i.n	a9, a2, 36
420023cb:	fffb06        	j	420023bb <heap_caps_init+0x187>
	...

420023d0 <soc_get_available_memory_region_max_count>:
    return result;
#endif
}

size_t soc_get_available_memory_region_max_count(void)
{
420023d0:	004136        	entry	a1, 32
             - &soc_reserved_memory_region_start );
420023d3:	f7e521        	l32r	a2, 42000368 <_stext+0x348>
420023d6:	f7e381        	l32r	a8, 42000364 <_stext+0x344>
420023d9:	c08820        	sub	a8, a8, a2
    /* Worst-case: each reserved memory region splits an available
       region in two, so the maximum possible number of regions
       is the number of regions of memory plus the number of reservations */
    return soc_memory_region_count + s_get_num_reserved_regions();
420023dc:	f7e421        	l32r	a2, 4200036c <_stext+0x34c>
             - &soc_reserved_memory_region_start );
420023df:	218380        	srai	a8, a8, 3
    return soc_memory_region_count + s_get_num_reserved_regions();
420023e2:	0228      	l32i.n	a2, a2, 0
420023e4:	221b      	addi.n	a2, a2, 1
}
420023e6:	282a      	add.n	a2, a8, a2
420023e8:	f01d      	retw.n
	...

420023ec <soc_get_available_memory_regions>:
        }
    }
}

size_t soc_get_available_memory_regions(soc_memory_region_t *regions)
{
420023ec:	008136        	entry	a1, 64
420023ef:	017d      	mov.n	a7, a1
420023f1:	5729      	s32i.n	a2, a7, 20
    soc_memory_region_t *out_region = regions;
    /* make a local copy of the "input" regions so we can modify them */
    soc_memory_region_t in_regions[soc_memory_region_count];
420023f3:	f7de21        	l32r	a2, 4200036c <_stext+0x34c>
420023f6:	0258      	l32i.n	a5, a2, 0
420023f8:	1155c0        	slli	a5, a5, 4
420023fb:	c02150        	sub	a2, a1, a5
420023fe:	001210        	movsp	a1, a2
    memcpy(in_regions, soc_memory_regions, sizeof(in_regions));
42002401:	f7dbb1        	l32r	a11, 42000370 <_stext+0x350>
    soc_memory_region_t in_regions[soc_memory_region_count];
42002404:	016d      	mov.n	a6, a1
    memcpy(in_regions, soc_memory_regions, sizeof(in_regions));
42002406:	05cd      	mov.n	a12, a5
42002408:	20a660        	or	a10, a6, a6
4200240b:	f77081        	l32r	a8, 420001cc <_stext+0x1ac>
4200240e:	0008e0        	callx8	a8
             - &soc_reserved_memory_region_start );
42002411:	f7d5b1        	l32r	a11, 42000368 <_stext+0x348>
42002414:	f7d4c1        	l32r	a12, 42000364 <_stext+0x344>
42002417:	c0ccb0        	sub	a12, a12, a11
    soc_memory_region_t *in_region = in_regions;

    size_t num_reserved = s_get_num_reserved_regions();
    soc_reserved_region_t reserved[num_reserved];
4200241a:	17cc22        	addi	a2, a12, 23
4200241d:	412420        	srli	a2, a2, 4
             - &soc_reserved_memory_region_start );
42002420:	2183c0        	srai	a8, a12, 3
    soc_reserved_region_t reserved[num_reserved];
42002423:	1122c0        	slli	a2, a2, 4
42002426:	c02120        	sub	a2, a1, a2
    return result + 1; // ROM table means one entry needs to be added at runtime
42002429:	381b      	addi.n	a3, a8, 1
4200242b:	4739      	s32i.n	a3, a7, 16
    soc_reserved_region_t reserved[num_reserved];
4200242d:	001210        	movsp	a1, a2
    reserved[0].start = (intptr_t)layout->dram0_rtos_reserved_start;
42002430:	f7d131        	l32r	a3, 42000374 <_stext+0x354>
    memcpy(reserved + 1, &soc_reserved_memory_region_start, (count - 1) * sizeof(soc_reserved_region_t));
42002433:	a28b      	addi.n	a10, a2, 8
    reserved[0].start = (intptr_t)layout->dram0_rtos_reserved_start;
42002435:	0338      	l32i.n	a3, a3, 0
42002437:	1338      	l32i.n	a3, a3, 4
42002439:	0239      	s32i.n	a3, a2, 0
    reserved[0].end = SOC_DIRAM_DRAM_HIGH;
4200243b:	f7cf31        	l32r	a3, 42000378 <_stext+0x358>
4200243e:	1239      	s32i.n	a3, a2, 4
    memcpy(reserved + 1, &soc_reserved_memory_region_start, (count - 1) * sizeof(soc_reserved_region_t));
42002440:	076782        	s32i	a8, a7, 28
42002443:	f76281        	l32r	a8, 420001cc <_stext+0x1ac>
42002446:	0008e0        	callx8	a8
    qsort(reserved, count, sizeof(soc_reserved_region_t), s_compare_reserved_regions);
42002449:	47b8      	l32i.n	a11, a7, 16
4200244b:	f7ccd1        	l32r	a13, 4200037c <_stext+0x35c>
4200244e:	02ad      	mov.n	a10, a2
42002450:	8c0c      	movi.n	a12, 8
42002452:	f7cf81        	l32r	a8, 42000390 <_stext+0x370>
42002455:	0008e0        	callx8	a8
    for (size_t i = 0; i < count; i++) {
42002458:	7788      	l32i.n	a8, a7, 28
4200245a:	023d      	mov.n	a3, a2
4200245c:	0a0c      	movi.n	a10, 0
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
4200245e:	cb7c      	movi.n	a11, -4
    for (size_t i = 0; i < count; i++) {
42002460:	4748      	l32i.n	a4, a7, 16
42002462:	163a47        	bltu	a10, a4, 4200247c <soc_get_available_memory_regions+0x90>
    /* Go through the "in" regions (full regions, with no reserved
       sections removed from them) one at a time, trim off each reserved
       region, and then copy them to an out_region once trimmed
    */
    ESP_EARLY_LOGD(TAG, "Building list of available memory regions:");
    while (in_region != in_regions + soc_memory_region_count) {
42002465:	565a      	add.n	a5, a6, a5
    soc_memory_region_t *out_region = regions;
42002467:	5788      	l32i.n	a8, a7, 20
42002469:	06ad      	mov.n	a10, a6
    while (in_region != in_regions + soc_memory_region_count) {
4200246b:	6759      	s32i.n	a5, a7, 24
4200246d:	6738      	l32i.n	a3, a7, 24
4200246f:	529a37        	bne	a10, a3, 420024c5 <soc_get_available_memory_regions+0xd9>
        if (move_to_next) {
            in_region++;
        }
    }

    return (out_region - regions); /* return number of regions */
42002472:	5748      	l32i.n	a4, a7, 20
42002474:	c02840        	sub	a2, a8, a4
42002477:	212420        	srai	a2, a2, 4
}
4200247a:	f01d      	retw.n
        reserved[i].end = (reserved[i].end + 3) & ~3;
4200247c:	1348      	l32i.n	a4, a3, 4
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
4200247e:	0398      	l32i.n	a9, a3, 0
        reserved[i].end = (reserved[i].end + 3) & ~3;
42002480:	443b      	addi.n	a4, a4, 3
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
42002482:	109b90        	and	a9, a11, a9
        reserved[i].end = (reserved[i].end + 3) & ~3;
42002485:	1044b0        	and	a4, a4, a11
        reserved[i].start = reserved[i].start & ~3; /* expand all reserved areas to word boundaries */
42002488:	0399      	s32i.n	a9, a3, 0
        reserved[i].end = (reserved[i].end + 3) & ~3;
4200248a:	1349      	s32i.n	a4, a3, 4
        assert(reserved[i].start <= reserved[i].end);
4200248c:	10a497        	bge	a4, a9, 420024a0 <soc_get_available_memory_regions+0xb4>
4200248f:	f7bcd1        	l32r	a13, 42000380 <_stext+0x360>
42002492:	f7bcc1        	l32r	a12, 42000384 <_stext+0x364>
42002495:	db5c      	movi.n	a11, 93
            assert(reserved[i + 1].start > reserved[i].start);
42002497:	f7bca1        	l32r	a10, 42000388 <_stext+0x368>
4200249a:	f6fa81        	l32r	a8, 42000084 <_stext+0x64>
4200249d:	0008e0        	callx8	a8
        if (i < count - 1) {
420024a0:	19ba87        	bgeu	a10, a8, 420024bd <soc_get_available_memory_regions+0xd1>
            assert(reserved[i + 1].start > reserved[i].start);
420024a3:	23c8      	l32i.n	a12, a3, 8
420024a5:	0b29c7        	blt	a9, a12, 420024b4 <soc_get_available_memory_regions+0xc8>
420024a8:	f7b9d1        	l32r	a13, 4200038c <_stext+0x36c>
420024ab:	f7b6c1        	l32r	a12, 42000384 <_stext+0x364>
420024ae:	fb5c      	movi.n	a11, 95
420024b0:	fff8c6        	j	42002497 <soc_get_available_memory_regions+0xab>
420024b3:	00          	.byte 00
            if (reserved[i].end > reserved[i + 1].start) {
420024b4:	05ac47        	bge	a12, a4, 420024bd <soc_get_available_memory_regions+0xd1>
                abort();
420024b7:	f71981        	l32r	a8, 4200011c <_stext+0xfc>
420024ba:	0008e0        	callx8	a8
420024bd:	aa1b      	addi.n	a10, a10, 1
420024bf:	338b      	addi.n	a3, a3, 8
420024c1:	ffe6c6        	j	42002460 <soc_get_available_memory_regions+0x74>
420024c4:	00          	.byte 00
        soc_memory_region_t in = *in_region;
420024c5:	0ac8      	l32i.n	a12, a10, 0
420024c7:	1a48      	l32i.n	a4, a10, 4
420024c9:	2a58      	l32i.n	a5, a10, 8
420024cb:	3a38      	l32i.n	a3, a10, 12
420024cd:	2759      	s32i.n	a5, a7, 8
420024cf:	3739      	s32i.n	a3, a7, 12
420024d1:	07c9      	s32i.n	a12, a7, 0
420024d3:	1749      	s32i.n	a4, a7, 4
        intptr_t in_end = in_start + in.size;
420024d5:	fc4a      	add.n	a15, a12, a4
        for (size_t i = 0; i < num_reserved; i++) {
420024d7:	023d      	mov.n	a3, a2
        soc_memory_region_t in = *in_region;
420024d9:	046d      	mov.n	a6, a4
        intptr_t in_start = in.start;
420024db:	0c9d      	mov.n	a9, a12
        for (size_t i = 0; i < num_reserved; i++) {
420024dd:	050c      	movi.n	a5, 0
420024df:	47b8      	l32i.n	a11, a7, 16
420024e1:	0935b7        	bltu	a5, a11, 420024ee <soc_get_available_memory_regions+0x102>
        if (in.size <= 16) {
420024e4:	0b1c      	movi.n	a11, 16
420024e6:	57bb67        	bgeu	a11, a6, 42002541 <soc_get_available_memory_regions+0x155>
420024e9:	1b0c      	movi.n	a11, 1
420024eb:	000ec6        	j	4200252a <soc_get_available_memory_regions+0x13e>
            if (reserved[i].end <= in_start) {
420024ee:	13e8      	l32i.n	a14, a3, 4
420024f0:	61a9e7        	bge	a9, a14, 42002555 <soc_get_available_memory_regions+0x169>
            } else if (reserved[i].start >= in_end) {
420024f3:	03d8      	l32i.n	a13, a3, 0
420024f5:	ebadf7        	bge	a13, a15, 420024e4 <soc_get_available_memory_regions+0xf8>
            } else if (reserved[i].start <= in_start &&
420024f8:	01a0b2        	movi	a11, 1
420024fb:	02aef7        	bge	a14, a15, 42002501 <soc_get_available_memory_regions+0x115>
420024fe:	00a0b2        	movi	a11, 0
42002501:	160c      	movi.n	a6, 1
42002503:	01a9d7        	bge	a9, a13, 42002508 <soc_get_available_memory_regions+0x11c>
42002506:	060c      	movi.n	a6, 0
42002508:	10bb60        	and	a11, a11, a6
4200250b:	74b0b0        	extui	a11, a11, 0, 8
4200250e:	fbec      	bnez.n	a11, 42002541 <soc_get_available_memory_regions+0x155>
            } else if (in_start < reserved[i].start &&
42002510:	39aef7        	bge	a14, a15, 4200254d <soc_get_available_memory_regions+0x161>
42002513:	39a9d7        	bge	a9, a13, 42002550 <soc_get_available_memory_regions+0x164>
                in_region->size -= (reserved[i].end - in_region->start);
42002516:	c0cec0        	sub	a12, a14, a12
42002519:	c0c4c0        	sub	a12, a4, a12
                in.size = in_end - in_start;
4200251c:	c06d90        	sub	a6, a13, a9
                in_region->size -= (reserved[i].end - in_region->start);
4200251f:	1ac9      	s32i.n	a12, a10, 4
                in_region->start = reserved[i].end;
42002521:	0ae9      	s32i.n	a14, a10, 0
        if (in.size <= 16) {
42002523:	041c      	movi.n	a4, 16
42002525:	083d      	mov.n	a3, a8
42002527:	1bb467        	bgeu	a4, a6, 42002546 <soc_get_available_memory_regions+0x15a>
            *out_region++ = in;
4200252a:	2748      	l32i.n	a4, a7, 8
4200252c:	0799      	s32i.n	a9, a7, 0
4200252e:	2849      	s32i.n	a4, a8, 8
42002530:	3748      	l32i.n	a4, a7, 12
42002532:	1769      	s32i.n	a6, a7, 4
42002534:	0899      	s32i.n	a9, a8, 0
42002536:	1869      	s32i.n	a6, a8, 4
42002538:	3849      	s32i.n	a4, a8, 12
4200253a:	10c832        	addi	a3, a8, 16
        if (move_to_next) {
4200253d:	5b8c      	beqz.n	a11, 42002546 <soc_get_available_memory_regions+0x15a>
            *out_region++ = in;
4200253f:	038d      	mov.n	a8, a3
            in_region++;
42002541:	10caa2        	addi	a10, a10, 16
42002544:	083d      	mov.n	a3, a8
42002546:	038d      	mov.n	a8, a3
42002548:	ffc846        	j	4200246d <soc_get_available_memory_regions+0x81>
4200254b:	00          	.byte 00
4200254c:	00          	.byte 00
            } else if (reserved[i].start <= in_start) { /* reserved overlaps start of 'in' */
4200254d:	0b29d7        	blt	a9, a13, 4200255c <soc_get_available_memory_regions+0x170>
                in.size = in_end - in_start;
42002550:	c06fe0        	sub	a6, a15, a14
42002553:	0e9d      	mov.n	a9, a14
        for (size_t i = 0; i < num_reserved; i++) {
42002555:	551b      	addi.n	a5, a5, 1
42002557:	338b      	addi.n	a3, a3, 8
42002559:	ffe086        	j	420024df <soc_get_available_memory_regions+0xf3>
                in.size = in_end - in_start;
4200255c:	c06d90        	sub	a6, a13, a9
4200255f:	0dfd      	mov.n	a15, a13
42002561:	fffc06        	j	42002555 <soc_get_available_memory_regions+0x169>

42002564 <esp_rtc_get_time_us>:
#endif
}
#endif

uint64_t esp_rtc_get_time_us(void)
{
42002564:	004136        	entry	a1, 32
    if (xPortInIsrContext()) {
42002567:	f78f81        	l32r	a8, 420003a4 <_stext+0x384>
4200256a:	0008e0        	callx8	a8
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4200256d:	f78921        	l32r	a2, 42000394 <_stext+0x374>
42002570:	ffafb2        	movi	a11, -1
42002573:	20a220        	or	a10, a2, a2
42002576:	f6b281        	l32r	a8, 42000040 <_stext+0x20>
42002579:	0008e0        	callx8	a8
 *
 * @return The calibration value of slow clock period in microseconds, in Q13.19 fixed point format
 */
static inline uint32_t clk_ll_rtc_slow_load_cal(void)
{
    return REG_READ(RTC_SLOW_CLK_CAL_REG);
4200257c:	f78731        	l32r	a3, 42000398 <_stext+0x378>
4200257f:	f78841        	l32r	a4, 420003a0 <_stext+0x380>
42002582:	0020c0        	memw
42002585:	0358      	l32i.n	a5, a3, 0
    portENTER_CRITICAL_SAFE(&s_esp_rtc_time_lock);
    const uint32_t cal = esp_clk_slowclk_cal_get();
#if SOC_RTC_FAST_MEM_SUPPORTED
    if (cal == 0) {
42002587:	f78531        	l32r	a3, 4200039c <_stext+0x37c>
4200258a:	a5cc      	bnez.n	a5, 42002598 <esp_rtc_get_time_us+0x34>
        s_esp_rtc_time_us = 0;
4200258c:	080c      	movi.n	a8, 0
4200258e:	0389      	s32i.n	a8, a3, 0
42002590:	1389      	s32i.n	a8, a3, 4
        s_rtc_last_ticks = 0;
42002592:	006482        	s32i	a8, a4, 0
42002595:	016482        	s32i	a8, a4, 4
    }
    const uint64_t rtc_this_ticks = rtc_time_get();
42002598:	f78481        	l32r	a8, 420003a8 <_stext+0x388>
4200259b:	0008e0        	callx8	a8
    const uint64_t ticks = rtc_this_ticks - s_rtc_last_ticks;
4200259e:	0498      	l32i.n	a9, a4, 0
420025a0:	1488      	l32i.n	a8, a4, 4
420025a2:	c09a90        	sub	a9, a10, a9
420025a5:	1c0c      	movi.n	a12, 1
420025a7:	023a97        	bltu	a10, a9, 420025ad <esp_rtc_get_time_us+0x49>
420025aa:	00a0c2        	movi	a12, 0
     * and the upper 16-bit parts of "ticks", i.e.:
     *   ((ticks_low + 2^32 * ticks_high) * cal) >> RTC_CLK_CAL_FRACT
     */
    const uint64_t ticks_low = ticks & UINT32_MAX;
    const uint64_t ticks_high = ticks >> 32;
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
420025ad:	82d950        	mull	a13, a9, a5
420025b0:	a29950        	muluh	a9, a9, a5
    const uint64_t ticks = rtc_this_ticks - s_rtc_last_ticks;
420025b3:	c08b80        	sub	a8, a11, a8
420025b6:	c088c0        	sub	a8, a8, a12
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
420025b9:	c5d3d0        	extui	a13, a13, 19, 13
420025bc:	11c930        	slli	a12, a9, 13
420025bf:	20dcd0        	or	a13, a12, a13
420025c2:	c5c390        	extui	a12, a9, 19, 13
                                   ((ticks_high * cal) << (32 - RTC_CLK_CAL_FRACT));
420025c5:	829850        	mull	a9, a8, a5
420025c8:	a28850        	muluh	a8, a8, a5
420025cb:	c55390        	extui	a5, a9, 19, 13
420025ce:	119930        	slli	a9, a9, 13
420025d1:	118830        	slli	a8, a8, 13
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
420025d4:	9d9a      	add.n	a9, a13, a9
                                   ((ticks_high * cal) << (32 - RTC_CLK_CAL_FRACT));
420025d6:	208580        	or	a8, a5, a8
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
420025d9:	150c      	movi.n	a5, 1
420025db:	0239d7        	bltu	a9, a13, 420025e1 <esp_rtc_get_time_us+0x7d>
420025de:	00a052        	movi	a5, 0
420025e1:	8c8a      	add.n	a8, a12, a8
#if SOC_RTC_FAST_MEM_SUPPORTED
    s_esp_rtc_time_us += delta_time_us;
420025e3:	03c8      	l32i.n	a12, a3, 0
    const uint64_t delta_time_us = ((ticks_low * cal) >> RTC_CLK_CAL_FRACT) +
420025e5:	858a      	add.n	a8, a5, a8
    s_esp_rtc_time_us += delta_time_us;
420025e7:	c9ca      	add.n	a12, a9, a12
420025e9:	13d8      	l32i.n	a13, a3, 4
420025eb:	150c      	movi.n	a5, 1
420025ed:	013c97        	bltu	a12, a9, 420025f2 <esp_rtc_get_time_us+0x8e>
420025f0:	050c      	movi.n	a5, 0
420025f2:	88da      	add.n	a8, a8, a13
420025f4:	558a      	add.n	a5, a5, a8
420025f6:	03c9      	s32i.n	a12, a3, 0
420025f8:	1359      	s32i.n	a5, a3, 4
    s_rtc_last_ticks = rtc_this_ticks;
420025fa:	14b9      	s32i.n	a11, a4, 4
420025fc:	04a9      	s32i.n	a10, a4, 0
    if (xPortInIsrContext()) {
420025fe:	f76981        	l32r	a8, 420003a4 <_stext+0x384>
42002601:	0008e0        	callx8	a8
        portEXIT_CRITICAL_ISR(mux);
42002604:	02ad      	mov.n	a10, a2
42002606:	f68f81        	l32r	a8, 42000044 <_stext+0x24>
42002609:	0008e0        	callx8	a8
#else
    uint64_t esp_rtc_time_us = delta_time_us + clk_ll_rtc_slow_load_rtc_fix_us();
    portEXIT_CRITICAL_SAFE(&s_esp_rtc_time_lock);
    return esp_rtc_time_us;
#endif
}
4200260c:	0328      	l32i.n	a2, a3, 0
4200260e:	1338      	l32i.n	a3, a3, 4
42002610:	f01d      	retw.n
	...

42002614 <esp_clk_slowclk_cal_set>:

void esp_clk_slowclk_cal_set(uint32_t new_cal)
{
42002614:	004136        	entry	a1, 32
#if defined(CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER)
    /* To force monotonic time values even when clock calibration value changes,
     * we adjust esp_rtc_time
     */
#if SOC_RTC_FAST_MEM_SUPPORTED
    esp_rtc_get_time_us();
42002617:	fff4e5        	call8	42002564 <esp_rtc_get_time_us>
    REG_WRITE(RTC_SLOW_CLK_CAL_REG, cal_value);
4200261a:	f75f81        	l32r	a8, 42000398 <_stext+0x378>
4200261d:	0020c0        	memw
42002620:	0829      	s32i.n	a2, a8, 0
    }
    portEXIT_CRITICAL_SAFE(&s_esp_rtc_time_lock);
#endif // SOC_RTC_FAST_MEM_SUPPORTED
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    clk_ll_rtc_slow_store_cal(new_cal);
}
42002622:	f01d      	retw.n

42002624 <find_desc_for_int>:
{
42002624:	004136        	entry	a1, 32
    vector_desc_t *vd = vector_desc_head;
42002627:	f76181        	l32r	a8, 420003ac <_stext+0x38c>
4200262a:	0888      	l32i.n	a8, a8, 0
    while(vd != NULL) {
4200262c:	28cc      	bnez.n	a8, 42002632 <find_desc_for_int+0xe>
}
4200262e:	082d      	mov.n	a2, a8
42002630:	f01d      	retw.n
        if (vd->cpu == cpu && vd->intno == intno) {
42002632:	0898      	l32i.n	a9, a8, 0
42002634:	05a090        	extui	a10, a9, 16, 1
42002637:	059a37        	bne	a10, a3, 42002640 <find_desc_for_int+0x1c>
4200263a:	459190        	extui	a9, a9, 17, 5
4200263d:	ed1927        	beq	a9, a2, 4200262e <find_desc_for_int+0xa>
        vd = vd->next;
42002640:	2888      	l32i.n	a8, a8, 8
42002642:	fff986        	j	4200262c <find_desc_for_int+0x8>
42002645:	000000        	ill

42002648 <is_vect_desc_usable>:
{
42002648:	006136        	entry	a1, 48
    int x = vd->intno;
4200264b:	002262        	l32i	a6, a2, 0
    esp_cpu_intr_get_desc(cpu, x, &intr_desc);
4200264e:	20c110        	or	a12, a1, a1
    int x = vd->intno;
42002651:	456160        	extui	a6, a6, 17, 5
    esp_cpu_intr_get_desc(cpu, x, &intr_desc);
42002654:	20b660        	or	a11, a6, a6
42002657:	04ad      	mov.n	a10, a4
42002659:	15c6a5        	call8	420182c4 <esp_cpu_intr_get_desc>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_RESVD) {
4200265c:	2198      	l32i.n	a9, a1, 8
4200265e:	280c      	movi.n	a8, 2
42002660:	108980        	and	a8, a9, a8
42002663:	07e856        	bnez	a8, 420026e5 <is_vect_desc_usable+0x9d>
    if (intr_desc.flags & ESP_CPU_INTR_DESC_FLAG_SPECIAL && force == -1) {
42002666:	551b      	addi.n	a5, a5, 1
42002668:	1a0c      	movi.n	a10, 1
4200266a:	93a850        	movnez	a10, a8, a5
4200266d:	049090        	extui	a9, a9, 0, 1
42002670:	10aa90        	and	a10, a10, a9
42002673:	073a56        	bnez	a10, 420026ea <is_vect_desc_usable+0xa2>
    if (!(flags & (1 << intr_desc.priority))) {
42002676:	0158      	l32i.n	a5, a1, 0
42002678:	065357        	bbc	a3, a5, 42002682 <is_vect_desc_usable+0x3a>
    if (((flags & ESP_INTR_FLAG_EDGE) && (intr_desc.type == ESP_CPU_INTR_TYPE_LEVEL)) ||
4200267b:	1158      	l32i.n	a5, a1, 4
4200267d:	086397        	bbci	a3, 9, 42002689 <is_vect_desc_usable+0x41>
42002680:	85cc      	bnez.n	a5, 4200268c <is_vect_desc_usable+0x44>
}
42002682:	0a2d      	mov.n	a2, a10
42002684:	f01d      	retw.n
42002686:	00          	.byte 00
42002687:	00          	.byte 00
42002688:	00          	.byte 00
        (((!(flags & ESP_INTR_FLAG_EDGE)) && (intr_desc.type == ESP_CPU_INTR_TYPE_EDGE)))) {
42002689:	f51526        	beqi	a5, 1, 42002682 <is_vect_desc_usable+0x3a>
    if (vd->flags & VECDESC_FL_RESERVED)  {
4200268c:	001222        	l16ui	a2, a2, 0
4200268f:	efe207        	bbsi	a2, 0, 42002682 <is_vect_desc_usable+0x3a>
    assert(!((vd->flags & VECDESC_FL_SHARED) && (vd->flags & VECDESC_FL_NONSHARED)));
42002692:	c80c      	movi.n	a8, 12
42002694:	108280        	and	a8, a2, a8
42002697:	11a866        	bnei	a8, 12, 420026ac <is_vect_desc_usable+0x64>
4200269a:	f745d1        	l32r	a13, 420003b0 <_stext+0x390>
4200269d:	f745c1        	l32r	a12, 420003b4 <_stext+0x394>
420026a0:	f746a1        	l32r	a10, 420003b8 <_stext+0x398>
420026a3:	11a1b2        	movi	a11, 0x111
420026a6:	f67781        	l32r	a8, 42000084 <_stext+0x64>
420026a9:	0008e0        	callx8	a8
    if (vd->flags & VECDESC_FL_NONSHARED) {
420026ac:	880c      	movi.n	a8, 8
420026ae:	108280        	and	a8, a2, a8
420026b1:	fcd856        	bnez	a8, 42002682 <is_vect_desc_usable+0x3a>
    if (vd->flags & VECDESC_FL_SHARED) {
420026b4:	146227        	bbci	a2, 2, 420026cc <is_vect_desc_usable+0x84>
        if (flags & ESP_INTR_FLAG_SHARED) {
420026b7:	c76387        	bbci	a3, 8, 42002682 <is_vect_desc_usable+0x3a>
            if ((vd->flags & VECDESC_FL_SHARED) && (desc_in_iram_flag != in_iram_flag))  {
420026ba:	043a30        	extui	a3, a3, 10, 1
420026bd:	042120        	extui	a2, a2, 1, 1
420026c0:	c03320        	sub	a3, a3, a2
420026c3:	1a0c      	movi.n	a10, 1
420026c5:	93a830        	movnez	a10, a8, a3
420026c8:	ffed86        	j	42002682 <is_vect_desc_usable+0x3a>
420026cb:	00          	.byte 00
    asm volatile (
420026cc:	03ebb0        	rsr.prid	a11
420026cf:	04bdb0        	extui	a11, a11, 13, 1
    has_handler = xt_int_has_handler(intr_num, esp_cpu_get_core_id());
420026d2:	06ad      	mov.n	a10, a6
420026d4:	03dd65        	call8	420064ac <xt_int_has_handler>
    } else if (esp_cpu_intr_has_handler(x)) {
420026d7:	120c      	movi.n	a2, 1
420026d9:	30aa20        	xor	a10, a10, a2
420026dc:	74a0a0        	extui	a10, a10, 0, 8
420026df:	ffe7c6        	j	42002682 <is_vect_desc_usable+0x3a>
420026e2:	00          	.byte 00
420026e3:	00          	.byte 00
420026e4:	00          	.byte 00
        return false;
420026e5:	0a0c      	movi.n	a10, 0
420026e7:	ffe5c6        	j	42002682 <is_vect_desc_usable+0x3a>
420026ea:	08ad      	mov.n	a10, a8
420026ec:	ffe486        	j	42002682 <is_vect_desc_usable+0x3a>
	...

420026f0 <get_desc_for_int>:
{
420026f0:	004136        	entry	a1, 32
    vector_desc_t *vd = find_desc_for_int(intno, cpu);
420026f3:	20b330        	or	a11, a3, a3
420026f6:	20a220        	or	a10, a2, a2
420026f9:	fff2a5        	call8	42002624 <find_desc_for_int>
420026fc:	204aa0        	or	a4, a10, a10
    if (vd == NULL) {
420026ff:	0a8d      	mov.n	a8, a10
42002701:	05fa56        	bnez	a10, 42002764 <get_desc_for_int+0x74>
        vector_desc_t *newvd = heap_caps_malloc(sizeof(vector_desc_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42002704:	01a2b2        	movi	a11, 0x201
42002707:	11bbe0        	slli	a11, a11, 2
4200270a:	ca0c      	movi.n	a10, 12
4200270c:	f72e81        	l32r	a8, 420003c4 <_stext+0x3a4>
4200270f:	0008e0        	callx8	a8
42002712:	0a8d      	mov.n	a8, a10
        if (newvd == NULL) {
42002714:	04ca16        	beqz	a10, 42002764 <get_desc_for_int+0x74>
        memset(newvd, 0, sizeof(vector_desc_t));
42002717:	cc0c      	movi.n	a12, 12
42002719:	04bd      	mov.n	a11, a4
4200271b:	f69f81        	l32r	a8, 42000198 <_stext+0x178>
4200271e:	0008e0        	callx8	a8
42002721:	0a8d      	mov.n	a8, a10
        newvd->intno = intno;
42002723:	0898      	l32i.n	a9, a8, 0
42002725:	f725b1        	l32r	a11, 420003bc <_stext+0x39c>
42002728:	44a020        	extui	a10, a2, 0, 5
4200272b:	012af0        	slli	a2, a10, 17
4200272e:	1099b0        	and	a9, a9, a11
42002731:	209920        	or	a9, a9, a2
        newvd->cpu = cpu;
42002734:	f72321        	l32r	a2, 420003c0 <_stext+0x3a0>
42002737:	04b030        	extui	a11, a3, 0, 1
4200273a:	113b00        	slli	a3, a11, 16
4200273d:	109920        	and	a9, a9, a2
42002740:	209930        	or	a9, a9, a3
    vector_desc_t *vd = vector_desc_head;
42002743:	f71ac1        	l32r	a12, 420003ac <_stext+0x38c>
        newvd->cpu = cpu;
42002746:	0899      	s32i.n	a9, a8, 0
    vector_desc_t *vd = vector_desc_head;
42002748:	0cd8      	l32i.n	a13, a12, 0
4200274a:	0d9d      	mov.n	a9, a13
    while(vd != NULL) {
4200274c:	89dc      	bnez.n	a9, 42002768 <get_desc_for_int+0x78>
    if ((vector_desc_head == NULL) || (prev == NULL)) {
4200274e:	120c      	movi.n	a2, 1
42002750:	030c      	movi.n	a3, 0
42002752:	833240        	moveqz	a3, a2, a4
42002755:	74a030        	extui	a10, a3, 0, 8
42002758:	004356        	bnez	a3, 42002760 <get_desc_for_int+0x70>
4200275b:	932ad0        	movnez	a2, a10, a13
4200275e:	32ac      	beqz.n	a2, 42002785 <get_desc_for_int+0x95>
        to_insert->next = vd;
42002760:	2899      	s32i.n	a9, a8, 8
        vector_desc_head = to_insert;
42002762:	0c89      	s32i.n	a8, a12, 0
}
42002764:	082d      	mov.n	a2, a8
42002766:	f01d      	retw.n
        if (vd->cpu > to_insert->cpu) break;
42002768:	0928      	l32i.n	a2, a9, 0
4200276a:	053020        	extui	a3, a2, 16, 1
4200276d:	dd3b37        	bltu	a11, a3, 4200274e <get_desc_for_int+0x5e>
        if (vd->cpu == to_insert->cpu && vd->intno >= to_insert->intno) break;
42002770:	0838      	l32i.n	a3, a8, 0
42002772:	303230        	xor	a3, a2, a3
42002775:	05f307        	bbsi	a3, 16, 4200277e <get_desc_for_int+0x8e>
42002778:	452120        	extui	a2, a2, 17, 5
4200277b:	cfb2a7        	bgeu	a2, a10, 4200274e <get_desc_for_int+0x5e>
        vd = vd->next;
4200277e:	094d      	mov.n	a4, a9
42002780:	2998      	l32i.n	a9, a9, 8
42002782:	fff186        	j	4200274c <get_desc_for_int+0x5c>
        prev->next = to_insert;
42002785:	2489      	s32i.n	a8, a4, 8
        to_insert->next = vd;
42002787:	2899      	s32i.n	a9, a8, 8
42002789:	fff5c6        	j	42002764 <get_desc_for_int+0x74>

4200278c <esp_intr_enable_source>:
void IRAM_ATTR ets_isr_mask(uint32_t mask) {
    esp_cpu_intr_disable(mask);
}

void esp_intr_enable_source(int inum)
{
4200278c:	004136        	entry	a1, 32
    xt_ints_on(intr_mask);
4200278f:	1a0c      	movi.n	a10, 1
42002791:	401200        	ssl	a2
42002794:	a1aa00        	sll	a10, a10
42002797:	f70c81        	l32r	a8, 420003c8 <_stext+0x3a8>
4200279a:	0008e0        	callx8	a8
    esp_cpu_intr_enable(1 << inum);
}
4200279d:	f01d      	retw.n
	...

420027a0 <esp_intr_disable_source>:

void esp_intr_disable_source(int inum)
{
420027a0:	004136        	entry	a1, 32
    xt_ints_off(intr_mask);
420027a3:	1a0c      	movi.n	a10, 1
420027a5:	401200        	ssl	a2
420027a8:	a1aa00        	sll	a10, a10
420027ab:	f70881        	l32r	a8, 420003cc <_stext+0x3ac>
420027ae:	0008e0        	callx8	a8
    esp_cpu_intr_disable(1 << inum);
}
420027b1:	f01d      	retw.n
	...

420027b4 <esp_intr_alloc_intrstatus>:
{
420027b4:	00e136        	entry	a1, 112
420027b7:	a149      	s32i.n	a4, a1, 40
    if ((flags & ESP_INTR_FLAG_SHARED) && (flags & ESP_INTR_FLAG_EDGE)) {
420027b9:	00a342        	movi	a4, 0x300
{
420027bc:	b159      	s32i.n	a5, a1, 44
420027be:	c179      	s32i.n	a7, a1, 48
    if ((flags & ESP_INTR_FLAG_SHARED) && (flags & ESP_INTR_FLAG_EDGE)) {
420027c0:	105340        	and	a5, a3, a4
420027c3:	029547        	bne	a5, a4, 420027c9 <esp_intr_alloc_intrstatus+0x15>
420027c6:	00ef86        	j	42002b88 <esp_intr_alloc_intrstatus+0x3d4>
    if ((flags & ESP_INTR_FLAG_HIGH) && (handler)) {
420027c9:	050c      	movi.n	a5, 0
420027cb:	140c      	movi.n	a4, 1
420027cd:	834560        	moveqz	a4, a5, a6
420027d0:	f0a052        	movi	a5, 240
420027d3:	744040        	extui	a4, a4, 0, 8
420027d6:	020357        	bnone	a3, a5, 420027dc <esp_intr_alloc_intrstatus+0x28>
420027d9:	3ab456        	bnez	a4, 42002b88 <esp_intr_alloc_intrstatus+0x3d4>
    if ((flags & ESP_INTR_FLAG_SHARED) && (!handler || source<0)) {
420027dc:	00a152        	movi	a5, 0x100
420027df:	105350        	and	a5, a3, a5
420027e2:	458c      	beqz.n	a5, 420027ea <esp_intr_alloc_intrstatus+0x36>
420027e4:	3a0616        	beqz	a6, 42002b88 <esp_intr_alloc_intrstatus+0x3d4>
420027e7:	39d296        	bltz	a2, 42002b88 <esp_intr_alloc_intrstatus+0x3d4>
    if (intrstatusreg && !intrstatusmask) {
420027ea:	a188      	l32i.n	a8, a1, 40
420027ec:	004816        	beqz	a8, 420027f4 <esp_intr_alloc_intrstatus+0x40>
420027ef:	b188      	l32i.n	a8, a1, 44
420027f1:	393816        	beqz	a8, 42002b88 <esp_intr_alloc_intrstatus+0x3d4>
    if ((flags & ESP_INTR_FLAG_IRAM) && handler && !esp_ptr_in_iram(handler) && !esp_ptr_in_rtc_iram_fast(handler)) {
420027f4:	1d63a7        	bbci	a3, 10, 42002815 <esp_intr_alloc_intrstatus+0x61>
420027f7:	01a416        	beqz	a4, 42002815 <esp_intr_alloc_intrstatus+0x61>
    return ((intptr_t)p >= SOC_IRAM_LOW && (intptr_t)p < SOC_IRAM_HIGH);
420027fa:	f65e41        	l32r	a4, 42000174 <_stext+0x154>
420027fd:	f65e71        	l32r	a7, 42000178 <_stext+0x158>
42002800:	804640        	add	a4, a6, a4
42002803:	0eb747        	bgeu	a7, a4, 42002815 <esp_intr_alloc_intrstatus+0x61>
    return ((intptr_t)p >= SOC_RTC_IRAM_LOW && (intptr_t)p < SOC_RTC_IRAM_HIGH);
42002806:	f65e41        	l32r	a4, 42000180 <_stext+0x160>
42002809:	f65e71        	l32r	a7, 42000184 <_stext+0x164>
4200280c:	804640        	add	a4, a6, a4
4200280f:	02b747        	bgeu	a7, a4, 42002815 <esp_intr_alloc_intrstatus+0x61>
42002812:	00dc86        	j	42002b88 <esp_intr_alloc_intrstatus+0x3d4>
    if ((flags & ESP_INTR_FLAG_LEVELMASK) == 0) {
42002815:	fea042        	movi	a4, 254
42002818:	088347        	bany	a3, a4, 42002824 <esp_intr_alloc_intrstatus+0x70>
            flags |= ESP_INTR_FLAG_LEVEL1;
4200281b:	240c      	movi.n	a4, 2
        if (flags & ESP_INTR_FLAG_SHARED) {
4200281d:	05cc      	bnez.n	a5, 42002821 <esp_intr_alloc_intrstatus+0x6d>
            flags |= ESP_INTR_FLAG_LOWMED;
4200281f:	e40c      	movi.n	a4, 14
42002821:	203340        	or	a3, a3, a4
    if (source == ETS_INTERNAL_TIMER0_INTR_SOURCE) {
42002824:	020266        	bnei	a2, -1, 4200282a <esp_intr_alloc_intrstatus+0x76>
42002827:	0047c6        	j	4200294a <esp_intr_alloc_intrstatus+0x196>
    if (source == ETS_INTERNAL_TIMER1_INTR_SOURCE) {
4200282a:	e47c      	movi.n	a4, -2
        force = ETS_INTERNAL_TIMER1_INTR_NO;
4200282c:	f50c      	movi.n	a5, 15
    if (source == ETS_INTERNAL_TIMER1_INTR_SOURCE) {
4200282e:	171247        	beq	a2, a4, 42002849 <esp_intr_alloc_intrstatus+0x95>
    if (source == ETS_INTERNAL_TIMER2_INTR_SOURCE) {
42002831:	d47c      	movi.n	a4, -3
        force = ETS_INTERNAL_TIMER2_INTR_NO;
42002833:	051c      	movi.n	a5, 16
    if (source == ETS_INTERNAL_TIMER2_INTR_SOURCE) {
42002835:	171247        	beq	a2, a4, 42002850 <esp_intr_alloc_intrstatus+0x9c>
    if (source == ETS_INTERNAL_SW0_INTR_SOURCE) {
42002838:	c47c      	movi.n	a4, -4
        force = ETS_INTERNAL_SW0_INTR_NO;
4200283a:	750c      	movi.n	a5, 7
    if (source == ETS_INTERNAL_SW0_INTR_SOURCE) {
4200283c:	101247        	beq	a2, a4, 42002850 <esp_intr_alloc_intrstatus+0x9c>
    if (source == ETS_INTERNAL_SW1_INTR_SOURCE) {
4200283f:	b47c      	movi.n	a4, -5
        force = ETS_INTERNAL_SW1_INTR_NO;
42002841:	d51c      	movi.n	a5, 29
    if (source == ETS_INTERNAL_SW1_INTR_SOURCE) {
42002843:	091247        	beq	a2, a4, 42002850 <esp_intr_alloc_intrstatus+0x9c>
    int force = -1;
42002846:	ffaf52        	movi	a5, -1
        force = ETS_INTERNAL_PROFILING_INTR_NO;
42002849:	426b      	addi.n	a4, a2, 6
4200284b:	b70c      	movi.n	a7, 11
4200284d:	835740        	moveqz	a5, a7, a4
    ret = heap_caps_malloc(sizeof(intr_handle_data_t), MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
42002850:	01a2b2        	movi	a11, 0x201
42002853:	11bbe0        	slli	a11, a11, 2
42002856:	8a0c      	movi.n	a10, 8
42002858:	f6db81        	l32r	a8, 420003c4 <_stext+0x3a4>
4200285b:	0008e0        	callx8	a8
4200285e:	0861a2        	s32i	a10, a1, 32
    if (ret == NULL) {
42002861:	14ba16        	beqz	a10, 420029b0 <esp_intr_alloc_intrstatus+0x1fc>
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42002864:	f6dca1        	l32r	a10, 420003d4 <_stext+0x3b4>
42002867:	ffafb2        	movi	a11, -1
4200286a:	f5f581        	l32r	a8, 42000040 <_stext+0x20>
4200286d:	0008e0        	callx8	a8
42002870:	03eb40        	rsr.prid	a4
42002873:	044d40        	extui	a4, a4, 13, 1
    memset(&empty_vect_desc, 0, sizeof(vector_desc_t));
42002876:	0ca0c2        	movi	a12, 12
42002879:	0b0c      	movi.n	a11, 0
4200287b:	80a1c0        	add	a10, a1, a12
4200287e:	f64681        	l32r	a8, 42000198 <_stext+0x178>
42002881:	0008e0        	callx8	a8
    if (!(flags & ESP_INTR_FLAG_LEVELMASK)) {
42002884:	fea092        	movi	a9, 254
42002887:	037d      	mov.n	a7, a3
42002889:	048397        	bany	a3, a9, 42002891 <esp_intr_alloc_intrstatus+0xdd>
        flags |= ESP_INTR_FLAG_LOWMED;
4200288c:	e70c      	movi.n	a7, 14
4200288e:	207370        	or	a7, a3, a7
    vector_desc_t *vd = vector_desc_head;
42002891:	f6c691        	l32r	a9, 420003ac <_stext+0x38c>
        if (!(vd->flags & VECDESC_FL_SHARED)) {
42002894:	4d0c      	movi.n	a13, 4
    vector_desc_t *vd = vector_desc_head;
42002896:	0998      	l32i.n	a9, a9, 0
    while(vd != NULL) {
42002898:	0b5956        	bnez	a9, 42002951 <esp_intr_alloc_intrstatus+0x19d>
    if (force != -1) {
4200289b:	020526        	beqi	a5, -1, 420028a1 <esp_intr_alloc_intrstatus+0xed>
4200289e:	005206        	j	420029ea <esp_intr_alloc_intrstatus+0x236>
    int bestSharedCt=INT_MAX;
420028a1:	f6cb81        	l32r	a8, 420003d0 <_stext+0x3b0>
        if (flags & ESP_INTR_FLAG_SHARED) {
420028a4:	00a1a2        	movi	a10, 0x100
420028a7:	10a7a0        	and	a10, a7, a10
    int bestPriority=9;
420028aa:	9e0c      	movi.n	a14, 9
    int bestSharedCt=INT_MAX;
420028ac:	9189      	s32i.n	a8, a1, 36
        if (flags & ESP_INTR_FLAG_SHARED) {
420028ae:	0d61a2        	s32i	a10, a1, 52
        vd = find_desc_for_int(x, cpu);
420028b1:	20a990        	or	a10, a9, a9
420028b4:	20b440        	or	a11, a4, a4
420028b7:	106192        	s32i	a9, a1, 64
420028ba:	0f61e2        	s32i	a14, a1, 60
420028bd:	ffd665        	call8	42002624 <find_desc_for_int>
        if (vd == NULL) {
420028c0:	102192        	l32i	a9, a1, 64
420028c3:	f1e8      	l32i.n	a14, a1, 60
        vd = find_desc_for_int(x, cpu);
420028c5:	0afd      	mov.n	a15, a10
        if (vd == NULL) {
420028c7:	3adc      	bnez.n	a10, 420028de <esp_intr_alloc_intrstatus+0x12a>
            empty_vect_desc.intno = x;
420028c9:	31a8      	l32i.n	a10, a1, 12
420028cb:	f6bc81        	l32r	a8, 420003bc <_stext+0x39c>
420028ce:	44b090        	extui	a11, a9, 0, 5
420028d1:	01bbf0        	slli	a11, a11, 17
420028d4:	10aa80        	and	a10, a10, a8
420028d7:	20aab0        	or	a10, a10, a11
420028da:	31a9      	s32i.n	a10, a1, 12
            vd = &empty_vect_desc;
420028dc:	f1cb      	addi.n	a15, a1, 12
        esp_cpu_intr_get_desc(cpu, x, &intr_desc);
420028de:	09bd      	mov.n	a11, a9
420028e0:	01cd      	mov.n	a12, a1
420028e2:	04ad      	mov.n	a10, a4
420028e4:	106192        	s32i	a9, a1, 64
420028e7:	f1e9      	s32i.n	a14, a1, 60
420028e9:	e1f9      	s32i.n	a15, a1, 56
420028eb:	159da5        	call8	420182c4 <esp_cpu_intr_get_desc>
        if (!is_vect_desc_usable(vd, flags, cpu, force)) {
420028ee:	e1f8      	l32i.n	a15, a1, 56
420028f0:	fd7c      	movi.n	a13, -1
420028f2:	0fad      	mov.n	a10, a15
420028f4:	04cd      	mov.n	a12, a4
420028f6:	07bd      	mov.n	a11, a7
420028f8:	ffd4e5        	call8	42002648 <is_vect_desc_usable>
420028fb:	102192        	l32i	a9, a1, 64
420028fe:	f1e8      	l32i.n	a14, a1, 60
42002900:	e1f8      	l32i.n	a15, a1, 56
42002902:	3aac      	beqz.n	a10, 42002929 <esp_intr_alloc_intrstatus+0x175>
        if (flags & ESP_INTR_FLAG_SHARED) {
42002904:	d188      	l32i.n	a8, a1, 52
42002906:	114816        	beqz	a8, 42002a1e <esp_intr_alloc_intrstatus+0x26a>
            if (vd->flags & VECDESC_FL_SHARED) {
42002909:	001fa2        	l16ui	a10, a15, 0
4200290c:	02ea27        	bbsi	a10, 2, 42002912 <esp_intr_alloc_intrstatus+0x15e>
4200290f:	004146        	j	42002a18 <esp_intr_alloc_intrstatus+0x264>
                shared_vector_desc_t *svdesc = vd->shared_vec_info;
42002912:	1fb8      	l32i.n	a11, a15, 4
                int no = 0;
42002914:	0a0c      	movi.n	a10, 0
                while (svdesc != NULL) {
42002916:	0f7b56        	bnez	a11, 42002a11 <esp_intr_alloc_intrstatus+0x25d>
                if (no<bestSharedCt || bestPriority > intr_desc.priority) {
42002919:	9188      	l32i.n	a8, a1, 36
4200291b:	01b8      	l32i.n	a11, a1, 0
4200291d:	02aa87        	bge	a10, a8, 42002923 <esp_intr_alloc_intrstatus+0x16f>
42002920:	004246        	j	42002a2d <esp_intr_alloc_intrstatus+0x279>
42002923:	02abe7        	bge	a11, a14, 42002929 <esp_intr_alloc_intrstatus+0x175>
42002926:	0040c6        	j	42002a2d <esp_intr_alloc_intrstatus+0x279>
    for (x = 0; x < 32; x++) {
42002929:	991b      	addi.n	a9, a9, 1
4200292b:	02c926        	beqi	a9, 32, 42002931 <esp_intr_alloc_intrstatus+0x17d>
4200292e:	ffdfc6        	j	420028b1 <esp_intr_alloc_intrstatus+0xfd>
    if (intr == -1) {
42002931:	5a0566        	bnei	a5, -1, 4200298f <esp_intr_alloc_intrstatus+0x1db>
        portEXIT_CRITICAL(&spinlock);
42002934:	f6a8a1        	l32r	a10, 420003d4 <_stext+0x3b4>
        return ESP_ERR_NOT_FOUND;
42002937:	05a122        	movi	a2, 0x105
        portEXIT_CRITICAL(&spinlock);
4200293a:	f5c281        	l32r	a8, 42000044 <_stext+0x24>
4200293d:	0008e0        	callx8	a8
        free(ret);
42002940:	81a8      	l32i.n	a10, a1, 32
42002942:	f5b881        	l32r	a8, 42000024 <_stext+0x4>
42002945:	0008e0        	callx8	a8
}
42002948:	f01d      	retw.n
        force = ETS_INTERNAL_TIMER0_INTR_NO;
4200294a:	650c      	movi.n	a5, 6
4200294c:	ffbe46        	j	42002849 <esp_intr_alloc_intrstatus+0x95>
4200294f:	00          	.byte 00
42002950:	00          	.byte 00
        if (!(vd->flags & VECDESC_FL_SHARED)) {
42002951:	0019b2        	l16ui	a11, a9, 0
42002954:	0029a2        	l32i	a10, a9, 0
42002957:	5d8bd7        	bany	a11, a13, 420029b8 <esp_intr_alloc_intrstatus+0x204>
            if (vd->source == source && cpu == vd->cpu) {
4200295a:	11bae0        	slli	a11, a10, 2
4200295d:	31b8b0        	srai	a11, a11, 24
42002960:	0212b7        	beq	a2, a11, 42002966 <esp_intr_alloc_intrstatus+0x1b2>
42002963:	001f46        	j	420029e4 <esp_intr_alloc_intrstatus+0x230>
42002966:	05b0a0        	extui	a11, a10, 16, 1
42002969:	7794b7        	bne	a4, a11, 420029e4 <esp_intr_alloc_intrstatus+0x230>
        if ( force != -1 && force != vd->intno ) {
4200296c:	050526        	beqi	a5, -1, 42002975 <esp_intr_alloc_intrstatus+0x1c1>
4200296f:	45a1a0        	extui	a10, a10, 17, 5
42002972:	be95a7        	bne	a5, a10, 42002934 <esp_intr_alloc_intrstatus+0x180>
        if (is_vect_desc_usable(vd, flags, cpu, force)) {
42002975:	09ad      	mov.n	a10, a9
42002977:	05dd      	mov.n	a13, a5
42002979:	04cd      	mov.n	a12, a4
4200297b:	07bd      	mov.n	a11, a7
4200297d:	106192        	s32i	a9, a1, 64
42002980:	ffcc65        	call8	42002648 <is_vect_desc_usable>
42002983:	102192        	l32i	a9, a1, 64
42002986:	faaa16        	beqz	a10, 42002934 <esp_intr_alloc_intrstatus+0x180>
            best = vd->intno;
42002989:	002982        	l32i	a8, a9, 0
4200298c:	455180        	extui	a5, a8, 17, 5
    vector_desc_t *vd = get_desc_for_int(intr, cpu);
4200298f:	20b440        	or	a11, a4, a4
42002992:	20a550        	or	a10, a5, a5
42002995:	ffd5a5        	call8	420026f0 <get_desc_for_int>
42002998:	f68fb1        	l32r	a11, 420003d4 <_stext+0x3b4>
4200299b:	0a7d      	mov.n	a7, a10
    if (vd == NULL) {
4200299d:	093a56        	bnez	a10, 42002a34 <esp_intr_alloc_intrstatus+0x280>
            portEXIT_CRITICAL(&spinlock);
420029a0:	0bad      	mov.n	a10, a11
420029a2:	f5a881        	l32r	a8, 42000044 <_stext+0x24>
420029a5:	0008e0        	callx8	a8
            free(ret);
420029a8:	81a8      	l32i.n	a10, a1, 32
420029aa:	f59e81        	l32r	a8, 42000024 <_stext+0x4>
420029ad:	0008e0        	callx8	a8
        return ESP_ERR_NO_MEM;
420029b0:	01a122        	movi	a2, 0x101
420029b3:	ffe446        	j	42002948 <esp_intr_alloc_intrstatus+0x194>
420029b6:	00          	.byte 00
420029b7:	00          	.byte 00
        } else if (vd->cpu == cpu) {
420029b8:	05b0a0        	extui	a11, a10, 16, 1
420029bb:	2594b7        	bne	a4, a11, 420029e4 <esp_intr_alloc_intrstatus+0x230>
            shared_vector_desc_t *svd = vd->shared_vec_info;
420029be:	19b8      	l32i.n	a11, a9, 4
            assert(svd != NULL);
420029c0:	0bdc      	bnez.n	a11, 420029d4 <esp_intr_alloc_intrstatus+0x220>
420029c2:	f685d1        	l32r	a13, 420003d8 <_stext+0x3b8>
420029c5:	f685c1        	l32r	a12, 420003dc <_stext+0x3bc>
420029c8:	f67ca1        	l32r	a10, 420003b8 <_stext+0x398>
420029cb:	aea0b2        	movi	a11, 174
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
420029ce:	f5ad81        	l32r	a8, 42000084 <_stext+0x64>
420029d1:	0008e0        	callx8	a8
                if (svd->source == source) {
420029d4:	0bc8      	l32i.n	a12, a11, 0
420029d6:	01cc90        	slli	a12, a12, 23
420029d9:	31c8c0        	srai	a12, a12, 24
420029dc:	8c12c7        	beq	a2, a12, 4200296c <esp_intr_alloc_intrstatus+0x1b8>
                svd = svd->next;
420029df:	5bb8      	l32i.n	a11, a11, 20
            while(svd) {
420029e1:	fefb56        	bnez	a11, 420029d4 <esp_intr_alloc_intrstatus+0x220>
        vd = vd->next;
420029e4:	2998      	l32i.n	a9, a9, 8
420029e6:	ffab86        	j	42002898 <esp_intr_alloc_intrstatus+0xe4>
420029e9:	00          	.byte 00
        vd = find_desc_for_int(force, cpu);
420029ea:	20b440        	or	a11, a4, a4
420029ed:	20a550        	or	a10, a5, a5
420029f0:	ffc325        	call8	42002624 <find_desc_for_int>
420029f3:	209aa0        	or	a9, a10, a10
        if (vd == NULL) {
420029f6:	f7ba56        	bnez	a10, 42002975 <esp_intr_alloc_intrstatus+0x1c1>
            empty_vect_desc.intno = force;
420029f9:	3198      	l32i.n	a9, a1, 12
420029fb:	f670b1        	l32r	a11, 420003bc <_stext+0x39c>
420029fe:	44a050        	extui	a10, a5, 0, 5
42002a01:	01aaf0        	slli	a10, a10, 17
42002a04:	1099b0        	and	a9, a9, a11
42002a07:	2099a0        	or	a9, a9, a10
42002a0a:	3199      	s32i.n	a9, a1, 12
            vd = &empty_vect_desc;
42002a0c:	91cb      	addi.n	a9, a1, 12
42002a0e:	ffd8c6        	j	42002975 <esp_intr_alloc_intrstatus+0x1c1>
                    svdesc = svdesc->next;
42002a11:	5bb8      	l32i.n	a11, a11, 20
                    no++;
42002a13:	aa1b      	addi.n	a10, a10, 1
                    svdesc = svdesc->next;
42002a15:	ffbf46        	j	42002916 <esp_intr_alloc_intrstatus+0x162>
                if (best == -1) {
42002a18:	020526        	beqi	a5, -1, 42002a1e <esp_intr_alloc_intrstatus+0x26a>
42002a1b:	ffc286        	j	42002929 <esp_intr_alloc_intrstatus+0x175>
            if (bestPriority > intr_desc.priority) {
42002a1e:	01a8      	l32i.n	a10, a1, 0
42002a20:	022ae7        	blt	a10, a14, 42002a26 <esp_intr_alloc_intrstatus+0x272>
42002a23:	ffc086        	j	42002929 <esp_intr_alloc_intrstatus+0x175>
42002a26:	0aed      	mov.n	a14, a10
42002a28:	095d      	mov.n	a5, a9
                ALCHLOG("...worse than int %d", best);
42002a2a:	ffbec6        	j	42002929 <esp_intr_alloc_intrstatus+0x175>
42002a2d:	91a9      	s32i.n	a10, a1, 36
42002a2f:	0bed      	mov.n	a14, a11
42002a31:	fffcc6        	j	42002a28 <esp_intr_alloc_intrstatus+0x274>
    if (flags & ESP_INTR_FLAG_SHARED) {
42002a34:	02e387        	bbsi	a3, 8, 42002a3a <esp_intr_alloc_intrstatus+0x286>
42002a37:	003886        	j	42002b1d <esp_intr_alloc_intrstatus+0x369>
        shared_vector_desc_t *sh_vec=malloc(sizeof(shared_vector_desc_t));
42002a3a:	18a0a2        	movi	a10, 24
42002a3d:	e1b9      	s32i.n	a11, a1, 56
42002a3f:	f58281        	l32r	a8, 42000048 <_stext+0x28>
42002a42:	0008e0        	callx8	a8
        if (sh_vec == NULL) {
42002a45:	e1b8      	l32i.n	a11, a1, 56
42002a47:	f55a16        	beqz	a10, 420029a0 <esp_intr_alloc_intrstatus+0x1ec>
        memset(sh_vec, 0, sizeof(shared_vector_desc_t));
42002a4a:	00a0b2        	movi	a11, 0
42002a4d:	18a0c2        	movi	a12, 24
42002a50:	f5d281        	l32r	a8, 42000198 <_stext+0x178>
42002a53:	0008e0        	callx8	a8
        sh_vec->statusreg = (uint32_t*)intrstatusreg;
42002a56:	a188      	l32i.n	a8, a1, 40
        sh_vec->isr = handler;
42002a58:	3a69      	s32i.n	a6, a10, 12
        sh_vec->statusreg = (uint32_t*)intrstatusreg;
42002a5a:	1a89      	s32i.n	a8, a10, 4
        sh_vec->statusmask = intrstatusmask;
42002a5c:	b188      	l32i.n	a8, a1, 44
        sh_vec->next = vd->shared_vec_info;
42002a5e:	1768      	l32i.n	a6, a7, 4
        sh_vec->statusmask = intrstatusmask;
42002a60:	2a89      	s32i.n	a8, a10, 8
        sh_vec->arg = arg;
42002a62:	c188      	l32i.n	a8, a1, 48
        memset(sh_vec, 0, sizeof(shared_vector_desc_t));
42002a64:	0a9d      	mov.n	a9, a10
        sh_vec->arg = arg;
42002a66:	4a89      	s32i.n	a8, a10, 16
        sh_vec->next = vd->shared_vec_info;
42002a68:	5a69      	s32i.n	a6, a10, 20
        sh_vec->source = source;
42002a6a:	001962        	l16ui	a6, a9, 0
42002a6d:	74a020        	extui	a10, a2, 0, 8
42002a70:	01aeb2        	movi	a11, 0xfffffe01
42002a73:	aaaa      	add.n	a10, a10, a10
42002a75:	1066b0        	and	a6, a6, a11
42002a78:	2066a0        	or	a6, a6, a10
42002a7b:	005962        	s16i	a6, a9, 0
        vd->flags |= VECDESC_FL_SHARED;
42002a7e:	001762        	l16ui	a6, a7, 0
        vd->shared_vec_info = sh_vec;
42002a81:	1799      	s32i.n	a9, a7, 4
        vd->flags |= VECDESC_FL_SHARED;
42002a83:	490c      	movi.n	a9, 4
42002a85:	206690        	or	a6, a6, a9
42002a88:	005762        	s16i	a6, a7, 0
42002a8b:	f61c      	movi.n	a6, 31
42002a8d:	0fa657        	bge	a6, a5, 42002aa0 <esp_intr_alloc_intrstatus+0x2ec>
42002a90:	f654d1        	l32r	a13, 420003e0 <_stext+0x3c0>
42002a93:	f654c1        	l32r	a12, 420003e4 <_stext+0x3c4>
42002a96:	4fa1b2        	movi	a11, 0x14f
42002a99:	f653a1        	l32r	a10, 420003e8 <_stext+0x3c8>
42002a9c:	ffcb86        	j	420029ce <esp_intr_alloc_intrstatus+0x21a>
42002a9f:	00          	.byte 00
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42002aa0:	f653b1        	l32r	a11, 420003ec <_stext+0x3cc>
42002aa3:	07cd      	mov.n	a12, a7
42002aa5:	05ad      	mov.n	a10, a5
42002aa7:	03a265        	call8	420064cc <xt_set_interrupt_handler>
        non_iram_int_mask[cpu] &= ~(1<<intr);
42002aaa:	f653a1        	l32r	a10, 420003f8 <_stext+0x3d8>
 */
FORCE_INLINE_ATTR void esp_cpu_intr_edge_ack(int intr_num)
{
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
#ifdef __XTENSA__
    xthal_set_intclear(1 << intr_num);
42002aad:	1b0c      	movi.n	a11, 1
42002aaf:	a064a0        	addx4	a6, a4, a10
        vd->flags |= VECDESC_FL_INIRAM;
42002ab2:	009792        	l16si	a9, a7, 0
        non_iram_int_mask[cpu] &= ~(1<<intr);
42002ab5:	0668      	l32i.n	a6, a6, 0
42002ab7:	11c4e0        	slli	a12, a4, 2
42002aba:	401500        	ssl	a5
42002abd:	a1bb00        	sll	a11, a11
    if (flags & ESP_INTR_FLAG_IRAM) {
42002ac0:	02e3a7        	bbsi	a3, 10, 42002ac6 <esp_intr_alloc_intrstatus+0x312>
42002ac3:	002a46        	j	42002b70 <esp_intr_alloc_intrstatus+0x3bc>
        vd->flags |= VECDESC_FL_INIRAM;
42002ac6:	2d0c      	movi.n	a13, 2
42002ac8:	2099d0        	or	a9, a9, a13
        non_iram_int_mask[cpu] &= ~(1<<intr);
42002acb:	fd7c      	movi.n	a13, -1
42002acd:	30bdb0        	xor	a11, a13, a11
42002ad0:	106b60        	and	a6, a11, a6
42002ad3:	aaca      	add.n	a10, a10, a12
        vd->flags |= VECDESC_FL_INIRAM;
42002ad5:	005792        	s16i	a9, a7, 0
        non_iram_int_mask[cpu] &= ~(1<<intr);
42002ad8:	0a69      	s32i.n	a6, a10, 0
    if (source>=0) {
42002ada:	00c296        	bltz	a2, 42002aea <esp_intr_alloc_intrstatus+0x336>
        esp_rom_route_intr_matrix(cpu, source, intr);
42002add:	05cd      	mov.n	a12, a5
42002adf:	02bd      	mov.n	a11, a2
42002ae1:	20a440        	or	a10, a4, a4
42002ae4:	f55a81        	l32r	a8, 4200004c <_stext+0x2c>
42002ae7:	0008e0        	callx8	a8
    ret->vector_desc = vd;
42002aea:	8128      	l32i.n	a2, a1, 32
    ret->shared_vector_desc = vd->shared_vec_info;
42002aec:	8148      	l32i.n	a4, a1, 32
    ret->vector_desc = vd;
42002aee:	0279      	s32i.n	a7, a2, 0
    ret->shared_vector_desc = vd->shared_vec_info;
42002af0:	1728      	l32i.n	a2, a7, 4
    ESP_INTR_ENABLE(intr);
42002af2:	05ad      	mov.n	a10, a5
    ret->shared_vector_desc = vd->shared_vec_info;
42002af4:	1429      	s32i.n	a2, a4, 4
    ESP_INTR_ENABLE(intr);
42002af6:	ffc965        	call8	4200278c <esp_intr_enable_source>
    if (flags & ESP_INTR_FLAG_INTRDISABLED) {
42002af9:	0763b7        	bbci	a3, 11, 42002b04 <esp_intr_alloc_intrstatus+0x350>
        esp_intr_disable(ret);
42002afc:	81a8      	l32i.n	a10, a1, 32
42002afe:	f63f81        	l32r	a8, 420003fc <_stext+0x3dc>
42002b01:	0008e0        	callx8	a8
    portEXIT_CRITICAL(&spinlock);
42002b04:	f634a1        	l32r	a10, 420003d4 <_stext+0x3b4>
42002b07:	f54f81        	l32r	a8, 42000044 <_stext+0x24>
42002b0a:	0008e0        	callx8	a8
    if (ret_handle != NULL) {
42002b0d:	1c2162        	l32i	a6, a1, 112
42002b10:	068616        	beqz	a6, 42002b7c <esp_intr_alloc_intrstatus+0x3c8>
        *ret_handle = ret;
42002b13:	8188      	l32i.n	a8, a1, 32
42002b15:	0689      	s32i.n	a8, a6, 0
    return ESP_OK;
42002b17:	020c      	movi.n	a2, 0
42002b19:	ff8ac6        	j	42002948 <esp_intr_alloc_intrstatus+0x194>
42002b1c:	00          	.byte 00
        vd->flags = VECDESC_FL_NONSHARED;
42002b1d:	08a092        	movi	a9, 8
42002b20:	005a92        	s16i	a9, a10, 0
        if (handler) {
42002b23:	011616        	beqz	a6, 42002b38 <esp_intr_alloc_intrstatus+0x384>
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42002b26:	1fa092        	movi	a9, 31
42002b29:	02a957        	bge	a9, a5, 42002b2f <esp_intr_alloc_intrstatus+0x37b>
42002b2c:	ffd806        	j	42002a90 <esp_intr_alloc_intrstatus+0x2dc>
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42002b2f:	c1c8      	l32i.n	a12, a1, 48
42002b31:	06bd      	mov.n	a11, a6
42002b33:	05ad      	mov.n	a10, a5
42002b35:	039965        	call8	420064cc <xt_set_interrupt_handler>
        if (flags & ESP_INTR_FLAG_EDGE) {
42002b38:	1e6397        	bbci	a3, 9, 42002b5a <esp_intr_alloc_intrstatus+0x3a6>
    assert(intr_num >= 0 && intr_num < SOC_CPU_INTR_NUM);
42002b3b:	f61c      	movi.n	a6, 31
42002b3d:	0ba657        	bge	a6, a5, 42002b4c <esp_intr_alloc_intrstatus+0x398>
42002b40:	f628d1        	l32r	a13, 420003e0 <_stext+0x3c0>
42002b43:	f62bc1        	l32r	a12, 420003f0 <_stext+0x3d0>
42002b46:	9ea1b2        	movi	a11, 0x19e
42002b49:	ffd306        	j	42002a99 <esp_intr_alloc_intrstatus+0x2e5>
    xthal_set_intclear(1 << intr_num);
42002b4c:	1a0c      	movi.n	a10, 1
42002b4e:	401500        	ssl	a5
42002b51:	a1aa00        	sll	a10, a10
42002b54:	f62b81        	l32r	a8, 42000400 <_stext+0x3e0>
42002b57:	0008e0        	callx8	a8
        vd->source = source;
42002b5a:	0768      	l32i.n	a6, a7, 0
42002b5c:	f626a1        	l32r	a10, 420003f4 <_stext+0x3d4>
42002b5f:	749020        	extui	a9, a2, 0, 8
42002b62:	0199a0        	slli	a9, a9, 22
42002b65:	1066a0        	and	a6, a6, a10
42002b68:	206690        	or	a6, a6, a9
42002b6b:	0769      	s32i.n	a6, a7, 0
42002b6d:	ffce46        	j	42002aaa <esp_intr_alloc_intrstatus+0x2f6>
        vd->flags &= ~VECDESC_FL_INIRAM;
42002b70:	dd7c      	movi.n	a13, -3
42002b72:	1099d0        	and	a9, a9, a13
        non_iram_int_mask[cpu] |= (1<<intr);
42002b75:	206b60        	or	a6, a11, a6
42002b78:	ffd5c6        	j	42002ad3 <esp_intr_alloc_intrstatus+0x31f>
42002b7b:	00          	.byte 00
        free(ret);
42002b7c:	81a8      	l32i.n	a10, a1, 32
42002b7e:	f52981        	l32r	a8, 42000024 <_stext+0x4>
42002b81:	0008e0        	callx8	a8
42002b84:	ffe3c6        	j	42002b17 <esp_intr_alloc_intrstatus+0x363>
42002b87:	00          	.byte 00
        return ESP_ERR_INVALID_ARG;
42002b88:	02a122        	movi	a2, 0x102
42002b8b:	ff6e46        	j	42002948 <esp_intr_alloc_intrstatus+0x194>
	...

42002b90 <esp_intr_alloc>:
{
42002b90:	006136        	entry	a1, 48
    return esp_intr_alloc_intrstatus(source, flags, 0, 0, handler, arg, ret_handle);
42002b93:	0d0c      	movi.n	a13, 0
42002b95:	0169      	s32i.n	a6, a1, 0
42002b97:	05fd      	mov.n	a15, a5
42002b99:	04ed      	mov.n	a14, a4
42002b9b:	0dcd      	mov.n	a12, a13
42002b9d:	03bd      	mov.n	a11, a3
42002b9f:	02ad      	mov.n	a10, a2
42002ba1:	ffc125        	call8	420027b4 <esp_intr_alloc_intrstatus>
}
42002ba4:	0a2d      	mov.n	a2, a10
42002ba6:	f01d      	retw.n

42002ba8 <esp_intr_free>:
{
42002ba8:	004136        	entry	a1, 32
    if (!handle) {
42002bab:	101216        	beqz	a2, 42002cb0 <esp_intr_free+0x108>
    if (handle->vector_desc->cpu != esp_cpu_get_core_id()) {
42002bae:	002232        	l32i	a3, a2, 0
42002bb1:	0023a2        	l32i	a10, a3, 0
42002bb4:	05a0a0        	extui	a10, a10, 16, 1
42002bb7:	03eb30        	rsr.prid	a3
42002bba:	043d30        	extui	a3, a3, 13, 1
42002bbd:	141a37        	beq	a10, a3, 42002bd5 <esp_intr_free+0x2d>
        esp_err_t ret = esp_ipc_call_blocking(handle->vector_desc->cpu, &esp_intr_free_cb, (void *)handle);
42002bc0:	f611b1        	l32r	a11, 42000404 <_stext+0x3e4>
42002bc3:	20c220        	or	a12, a2, a2
42002bc6:	05e265        	call8	420089ec <esp_ipc_call_blocking>
        return ret == ESP_OK ? ESP_OK : ESP_FAIL;
42002bc9:	120c      	movi.n	a2, 1
42002bcb:	030c      	movi.n	a3, 0
42002bcd:	8323a0        	moveqz	a2, a3, a10
42002bd0:	602020        	neg	a2, a2
}
42002bd3:	f01d      	retw.n
42002bd5:	f5ff31        	l32r	a3, 420003d4 <_stext+0x3b4>
42002bd8:	fb7c      	movi.n	a11, -1
42002bda:	03ad      	mov.n	a10, a3
42002bdc:	f51981        	l32r	a8, 42000040 <_stext+0x20>
42002bdf:	0008e0        	callx8	a8
    esp_intr_disable(handle);
42002be2:	02ad      	mov.n	a10, a2
42002be4:	f60681        	l32r	a8, 420003fc <_stext+0x3dc>
42002be7:	0008e0        	callx8	a8
    if (handle->vector_desc->flags & VECDESC_FL_SHARED) {
42002bea:	02b8      	l32i.n	a11, a2, 0
42002bec:	490c      	movi.n	a9, 4
42002bee:	001b82        	l16ui	a8, a11, 0
42002bf1:	108890        	and	a8, a8, a9
42002bf4:	e8bc      	beqz.n	a8, 42002c36 <esp_intr_free+0x8e>
        shared_vector_desc_t *svd = handle->vector_desc->shared_vec_info;
42002bf6:	012ba2        	l32i	a10, a11, 4
        assert(svd); //should be something in there for a shared int
42002bf9:	011a56        	bnez	a10, 42002c0e <esp_intr_free+0x66>
42002bfc:	f603d1        	l32r	a13, 42000408 <_stext+0x3e8>
42002bff:	f603c1        	l32r	a12, 4200040c <_stext+0x3ec>
42002c02:	f5eda1        	l32r	a10, 420003b8 <_stext+0x398>
42002c05:	c4a2b2        	movi	a11, 0x2c4
42002c08:	f51f81        	l32r	a8, 42000084 <_stext+0x64>
42002c0b:	0008e0        	callx8	a8
            if (svd == handle->shared_vector_desc) {
42002c0e:	12c8      	l32i.n	a12, a2, 4
        shared_vector_desc_t *prevsvd = NULL;
42002c10:	090c      	movi.n	a9, 0
                    prevsvd->next = svd->next;
42002c12:	5a88      	l32i.n	a8, a10, 20
            if (svd == handle->shared_vector_desc) {
42002c14:	021ca7        	beq	a12, a10, 42002c1a <esp_intr_free+0x72>
42002c17:	0022c6        	j	42002ca6 <esp_intr_free+0xfe>
                if (prevsvd) {
42002c1a:	083916        	beqz	a9, 42002ca1 <esp_intr_free+0xf9>
                    prevsvd->next = svd->next;
42002c1d:	056982        	s32i	a8, a9, 20
                free(svd);
42002c20:	f50181        	l32r	a8, 42000024 <_stext+0x4>
42002c23:	0008e0        	callx8	a8
        if (handle->vector_desc->shared_vec_info == NULL) {
42002c26:	0288      	l32i.n	a8, a2, 0
42002c28:	090c      	movi.n	a9, 0
42002c2a:	0128a2        	l32i	a10, a8, 4
42002c2d:	01a082        	movi	a8, 1
42002c30:	9389a0        	movnez	a8, a9, a10
42002c33:	748080        	extui	a8, a8, 0, 8
    if ((handle->vector_desc->flags & VECDESC_FL_NONSHARED) || free_shared_vector) {
42002c36:	002292        	l32i	a9, a2, 0
42002c39:	0019a2        	l16ui	a10, a9, 0
42002c3c:	02ea37        	bbsi	a10, 3, 42002c42 <esp_intr_free+0x9a>
42002c3f:	049816        	beqz	a8, 42002c8c <esp_intr_free+0xe4>
        esp_cpu_intr_set_handler(handle->vector_desc->intno, NULL, (void*)((int)handle->vector_desc->intno));
42002c42:	0029a2        	l32i	a10, a9, 0
    xt_set_interrupt_handler(intr_num, (xt_handler)handler, handler_arg);
42002c45:	00a0b2        	movi	a11, 0
42002c48:	45a1a0        	extui	a10, a10, 17, 5
42002c4b:	20caa0        	or	a12, a10, a10
42002c4e:	0387e5        	call8	420064cc <xt_set_interrupt_handler>
        handle->vector_desc->flags &= ~(VECDESC_FL_NONSHARED|VECDESC_FL_RESERVED|VECDESC_FL_SHARED);
42002c51:	0298      	l32i.n	a9, a2, 0
42002c53:	2a7c      	movi.n	a10, -14
42002c55:	001982        	l16ui	a8, a9, 0
42002c58:	1088a0        	and	a8, a8, a10
42002c5b:	005982        	s16i	a8, a9, 0
        handle->vector_desc->source = ETS_INTERNAL_UNUSED_INTR_SOURCE;
42002c5e:	0988      	l32i.n	a8, a9, 0
42002c60:	f5e5a1        	l32r	a10, 420003f4 <_stext+0x3d4>
42002c63:	1088a0        	and	a8, a8, a10
42002c66:	9da0a2        	movi	a10, 157
42002c69:	01aaa0        	slli	a10, a10, 22
42002c6c:	2088a0        	or	a8, a8, a10
42002c6f:	0989      	s32i.n	a8, a9, 0
        non_iram_int_mask[handle->vector_desc->cpu] &= ~(1<<(handle->vector_desc->intno));
42002c71:	f5e191        	l32r	a9, 420003f8 <_stext+0x3d8>
42002c74:	05a080        	extui	a10, a8, 16, 1
42002c77:	a0aa90        	addx4	a10, a10, a9
42002c7a:	458180        	extui	a8, a8, 17, 5
42002c7d:	e97c      	movi.n	a9, -2
42002c7f:	401800        	ssl	a8
42002c82:	818990        	src	a8, a9, a9
42002c85:	0a98      	l32i.n	a9, a10, 0
42002c87:	108890        	and	a8, a8, a9
42002c8a:	0a89      	s32i.n	a8, a10, 0
    portEXIT_CRITICAL(&spinlock);
42002c8c:	03ad      	mov.n	a10, a3
42002c8e:	f4ed81        	l32r	a8, 42000044 <_stext+0x24>
42002c91:	0008e0        	callx8	a8
    free(handle);
42002c94:	02ad      	mov.n	a10, a2
42002c96:	f4e381        	l32r	a8, 42000024 <_stext+0x4>
42002c99:	0008e0        	callx8	a8
42002c9c:	020c      	movi.n	a2, 0
42002c9e:	ffcc46        	j	42002bd3 <esp_intr_free+0x2b>
                    handle->vector_desc->shared_vec_info = svd->next;
42002ca1:	1b89      	s32i.n	a8, a11, 4
42002ca3:	ffde46        	j	42002c20 <esp_intr_free+0x78>
        while (svd != NULL) {
42002ca6:	0a9d      	mov.n	a9, a10
42002ca8:	f7a816        	beqz	a8, 42002c26 <esp_intr_free+0x7e>
42002cab:	08ad      	mov.n	a10, a8
42002cad:	ffd846        	j	42002c12 <esp_intr_free+0x6a>
        return ESP_ERR_INVALID_ARG;
42002cb0:	02a122        	movi	a2, 0x102
42002cb3:	ffc706        	j	42002bd3 <esp_intr_free+0x2b>
	...

42002cb8 <esp_intr_free_cb>:
{
42002cb8:	004136        	entry	a1, 32
    (void)esp_intr_free((intr_handle_t)arg);
42002cbb:	02ad      	mov.n	a10, a2
42002cbd:	ffeea5        	call8	42002ba8 <esp_intr_free>
}
42002cc0:	f01d      	retw.n
	...

42002cc4 <periph_ll_get_clk_en_mask>:
#include "soc/system_reg.h"
#include "soc/syscon_reg.h"
#include "soc/dport_access.h"

static inline uint32_t periph_ll_get_clk_en_mask(periph_module_t periph)
{
42002cc4:	004136        	entry	a1, 32
42002cc7:	028d      	mov.n	a8, a2
    switch (periph) {
42002cc9:	591c      	movi.n	a9, 21
    case PERIPH_PCNT_MODULE:
        return SYSTEM_PCNT_CLK_EN;
    case PERIPH_SPI_MODULE:
        return SYSTEM_SPI01_CLK_EN;
    case PERIPH_SPI2_MODULE:
        return SYSTEM_SPI2_CLK_EN;
42002ccb:	024c      	movi.n	a2, 64
    switch (periph) {
42002ccd:	341897        	beq	a8, a9, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002cd0:	02b987        	bgeu	a9, a8, 42002cd6 <periph_ll_get_clk_en_mask+0x12>
42002cd3:	0033c6        	j	42002da6 <periph_ll_get_clk_en_mask+0xe2>
42002cd6:	990c      	movi.n	a9, 9
        return SYSTEM_LCD_CAM_CLK_EN;
42002cd8:	00a122        	movi	a2, 0x100
    switch (periph) {
42002cdb:	261897        	beq	a8, a9, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002cde:	623987        	bltu	a9, a8, 42002d44 <periph_ll_get_clk_en_mask+0x80>
        return SYSTEM_USB_CLK_EN;
42002ce1:	120c      	movi.n	a2, 1
42002ce3:	012290        	slli	a2, a2, 23
    switch (periph) {
42002ce6:	1b4826        	beqi	a8, 4, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002ce9:	2958f6        	bgeui	a8, 5, 42002d16 <periph_ll_get_clk_en_mask+0x52>
        return SYSTEM_UART1_CLK_EN;
42002cec:	022c      	movi.n	a2, 32
    switch (periph) {
42002cee:	132826        	beqi	a8, 2, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002cf1:	190c      	movi.n	a9, 1
42002cf3:	1138f6        	bgeui	a8, 3, 42002d08 <periph_ll_get_clk_en_mask+0x44>
        return SYSTEM_LEDC_CLK_EN;
42002cf6:	112950        	slli	a2, a9, 11
    switch (periph) {
42002cf9:	888c      	beqz.n	a8, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002cfb:	020c      	movi.n	a2, 0
42002cfd:	880b      	addi.n	a8, a8, -1
42002cff:	939280        	movnez	a9, a2, a8
42002d02:	1129e0        	slli	a2, a9, 2
    case PERIPH_DS_MODULE:
        return SYSTEM_CRYPTO_DS_CLK_EN;
    default:
        return 0;
    }
}
42002d05:	f01d      	retw.n
42002d07:	00          	.byte 00
    switch (periph) {
42002d08:	fdc882        	addi	a8, a8, -3
42002d0b:	020c      	movi.n	a2, 0
42002d0d:	939280        	movnez	a9, a2, a8
42002d10:	112970        	slli	a2, a9, 9
42002d13:	fffb86        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_I2S0_CLK_EN;
42002d16:	021c      	movi.n	a2, 16
    switch (periph) {
42002d18:	e97826        	beqi	a8, 7, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d1b:	1588f6        	bgeui	a8, 8, 42002d34 <periph_ll_get_clk_en_mask+0x70>
        return SYSTEM_I2C_EXT0_CLK_EN;
42002d1e:	80a022        	movi	a2, 128
    switch (periph) {
42002d21:	e05826        	beqi	a8, 5, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d24:	fac882        	addi	a8, a8, -6
42002d27:	120c      	movi.n	a2, 1
42002d29:	090c      	movi.n	a9, 0
42002d2b:	932980        	movnez	a2, a9, a8
42002d2e:	0122e0        	slli	a2, a2, 18
42002d31:	fff406        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d34:	f8c882        	addi	a8, a8, -8
42002d37:	120c      	movi.n	a2, 1
42002d39:	090c      	movi.n	a9, 0
42002d3b:	932980        	movnez	a2, a9, a8
42002d3e:	0122b0        	slli	a2, a2, 21
42002d41:	fff006        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_LCD_CAM_CLK_EN;
42002d44:	00a122        	movi	a2, 0x100
    switch (periph) {
42002d47:	bab826        	beqi	a8, 16, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d4a:	021c      	movi.n	a2, 16
42002d4c:	2e3287        	bltu	a2, a8, 42002d7e <periph_ll_get_clk_en_mask+0xba>
42002d4f:	190c      	movi.n	a9, 1
        return SYSTEM_PWM0_CLK_EN;
42002d51:	0129f0        	slli	a2, a9, 17
    switch (periph) {
42002d54:	ada826        	beqi	a8, 12, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d57:	c20c      	movi.n	a2, 12
42002d59:	133287        	bltu	a2, a8, 42002d70 <periph_ll_get_clk_en_mask+0xac>
        return SYSTEM_TIMERGROUP_CLK_EN;
42002d5c:	112930        	slli	a2, a9, 13
    switch (periph) {
42002d5f:	a29826        	beqi	a8, 10, 42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d62:	020c      	movi.n	a2, 0
42002d64:	f5c882        	addi	a8, a8, -11
42002d67:	939280        	movnez	a9, a2, a8
42002d6a:	112910        	slli	a2, a9, 15
42002d6d:	ffe506        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d70:	020c      	movi.n	a2, 0
42002d72:	f3c882        	addi	a8, a8, -13
42002d75:	939280        	movnez	a9, a2, a8
42002d78:	0129c0        	slli	a2, a9, 20
42002d7b:	ffe186        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d7e:	391c      	movi.n	a9, 19
        return SYSTEM_PCNT_CLK_EN;
42002d80:	00a422        	movi	a2, 0x400
    switch (periph) {
42002d83:	029897        	bne	a8, a9, 42002d89 <periph_ll_get_clk_en_mask+0xc5>
42002d86:	ffdec6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d89:	491c      	movi.n	a9, 20
        return SYSTEM_SPI01_CLK_EN;
42002d8b:	220c      	movi.n	a2, 2
    switch (periph) {
42002d8d:	029897        	bne	a8, a9, 42002d93 <periph_ll_get_clk_en_mask+0xcf>
42002d90:	ffdc46        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002d93:	190c      	movi.n	a9, 1
42002d95:	1a1c      	movi.n	a10, 17
        return SYSTEM_UHCI1_CLK_EN;
42002d97:	112940        	slli	a2, a9, 12
    switch (periph) {
42002d9a:	0298a7        	bne	a8, a10, 42002da0 <periph_ll_get_clk_en_mask+0xdc>
42002d9d:	ffd906        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002da0:	eec882        	addi	a8, a8, -18
42002da3:	ffd906        	j	42002d0b <periph_ll_get_clk_en_mask+0x47>
42002da6:	f91c      	movi.n	a9, 31
        return SYSTEM_CRYPTO_AES_CLK_EN;
42002da8:	220c      	movi.n	a2, 2
    switch (periph) {
42002daa:	029897        	bne	a8, a9, 42002db0 <periph_ll_get_clk_en_mask+0xec>
42002dad:	ffd506        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002db0:	683987        	bltu	a9, a8, 42002e1c <periph_ll_get_clk_en_mask+0x158>
42002db3:	b21c      	movi.n	a2, 27
42002db5:	383287        	bltu	a2, a8, 42002df1 <periph_ll_get_clk_en_mask+0x12d>
42002db8:	9a1c      	movi.n	a10, 25
        return SYSTEM_WIFI_CLK_WIFI_EN_M;
42002dba:	020c      	movi.n	a2, 0
    switch (periph) {
42002dbc:	02ba87        	bgeu	a10, a8, 42002dc2 <periph_ll_get_clk_en_mask+0xfe>
42002dbf:	ffd086        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002dc2:	190c      	movi.n	a9, 1
42002dc4:	8b1c      	movi.n	a11, 24
        return SYSTEM_TWAI_CLK_EN;
42002dc6:	0129d0        	slli	a2, a9, 19
    switch (periph) {
42002dc9:	0298b7        	bne	a8, a11, 42002dcf <periph_ll_get_clk_en_mask+0x10b>
42002dcc:	ffcd46        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_WIFI_CLK_RNG_EN;
42002dcf:	112910        	slli	a2, a9, 15
    switch (periph) {
42002dd2:	0298a7        	bne	a8, a10, 42002dd8 <periph_ll_get_clk_en_mask+0x114>
42002dd5:	ffcb06        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002dd8:	6a1c      	movi.n	a10, 22
        return SYSTEM_SPI3_CLK_EN;
42002dda:	112900        	slli	a2, a9, 16
    switch (periph) {
42002ddd:	0298a7        	bne	a8, a10, 42002de3 <periph_ll_get_clk_en_mask+0x11f>
42002de0:	ffc846        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002de3:	020c      	movi.n	a2, 0
42002de5:	e9c882        	addi	a8, a8, -23
42002de8:	939280        	movnez	a9, a2, a8
42002deb:	112990        	slli	a2, a9, 7
42002dee:	ffc4c6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_BT_BASEBAND_EN;
42002df1:	120c      	movi.n	a2, 1
    switch (periph) {
42002df3:	d91c      	movi.n	a9, 29
        return SYSTEM_BT_BASEBAND_EN;
42002df5:	112250        	slli	a2, a2, 11
    switch (periph) {
42002df8:	029897        	bne	a8, a9, 42002dfe <periph_ll_get_clk_en_mask+0x13a>
42002dfb:	ffc186        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_BT_LC_EN;
42002dfe:	320c      	movi.n	a2, 3
    switch (periph) {
42002e00:	e91c      	movi.n	a9, 30
        return SYSTEM_BT_LC_EN;
42002e02:	112200        	slli	a2, a2, 16
    switch (periph) {
42002e05:	029897        	bne	a8, a9, 42002e0b <periph_ll_get_clk_en_mask+0x147>
42002e08:	ffbe46        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e0b:	c91c      	movi.n	a9, 28
        return 0;
42002e0d:	020c      	movi.n	a2, 0
    switch (periph) {
42002e0f:	021897        	beq	a8, a9, 42002e15 <periph_ll_get_clk_en_mask+0x151>
42002e12:	ffbbc6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
        return SYSTEM_WIFI_CLK_WIFI_BT_COMMON_M;
42002e15:	f57e21        	l32r	a2, 42000410 <_stext+0x3f0>
42002e18:	ffba46        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e1b:	00          	.byte 00
        return SYSTEM_SYSTIMER_CLK_EN;
42002e1c:	120c      	movi.n	a2, 1
    switch (periph) {
42002e1e:	492c      	movi.n	a9, 36
        return SYSTEM_SYSTIMER_CLK_EN;
42002e20:	012230        	slli	a2, a2, 29
    switch (periph) {
42002e23:	029897        	bne	a8, a9, 42002e29 <periph_ll_get_clk_en_mask+0x165>
42002e26:	ffb6c6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e29:	343987        	bltu	a9, a8, 42002e61 <periph_ll_get_clk_en_mask+0x19d>
42002e2c:	292c      	movi.n	a9, 34
        return SYSTEM_CRYPTO_DS_CLK_EN;
42002e2e:	021c      	movi.n	a2, 16
    switch (periph) {
42002e30:	029897        	bne	a8, a9, 42002e36 <periph_ll_get_clk_en_mask+0x172>
42002e33:	ffb386        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e36:	173987        	bltu	a9, a8, 42002e51 <periph_ll_get_clk_en_mask+0x18d>
        return SYSTEM_CRYPTO_SHA_CLK_EN;
42002e39:	420c      	movi.n	a2, 4
    switch (periph) {
42002e3b:	02c866        	bnei	a8, 32, 42002e41 <periph_ll_get_clk_en_mask+0x17d>
42002e3e:	ffb0c6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e41:	dfc882        	addi	a8, a8, -33
42002e44:	120c      	movi.n	a2, 1
42002e46:	090c      	movi.n	a9, 0
42002e48:	932980        	movnez	a2, a9, a8
42002e4b:	1122b0        	slli	a2, a2, 5
42002e4e:	ffacc6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e51:	ddc882        	addi	a8, a8, -35
42002e54:	120c      	movi.n	a2, 1
42002e56:	090c      	movi.n	a9, 0
42002e58:	932980        	movnez	a2, a9, a8
42002e5b:	1122d0        	slli	a2, a2, 3
42002e5e:	ffa8c6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e61:	692c      	movi.n	a9, 38
        return SYSTEM_SDIO_HOST_CLK_EN;
42002e63:	80a022        	movi	a2, 128
    switch (periph) {
42002e66:	029897        	bne	a8, a9, 42002e6c <periph_ll_get_clk_en_mask+0x1a8>
42002e69:	ffa606        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e6c:	190c      	movi.n	a9, 1
42002e6e:	7a2c      	movi.n	a10, 39
        return SYSTEM_APB_SARADC_CLK_EN;
42002e70:	012940        	slli	a2, a9, 28
    switch (periph) {
42002e73:	0298a7        	bne	a8, a10, 42002e79 <periph_ll_get_clk_en_mask+0x1b5>
42002e76:	ffa2c6        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
42002e79:	020c      	movi.n	a2, 0
42002e7b:	dbc882        	addi	a8, a8, -37
42002e7e:	939280        	movnez	a9, a2, a8
42002e81:	1129a0        	slli	a2, a9, 6
42002e84:	ff9f46        	j	42002d05 <periph_ll_get_clk_en_mask+0x41>
	...

42002e88 <periph_ll_get_clk_en_reg>:
        return 0;
    }
}

static uint32_t periph_ll_get_clk_en_reg(periph_module_t periph)
{
42002e88:	004136        	entry	a1, 32
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_CLK_EN1_REG;
42002e8b:	f48e81        	l32r	a8, 420000c4 <_stext+0xa4>
    switch (periph) {
42002e8e:	2f3226        	beqi	a2, 3, 42002ec1 <periph_ll_get_clk_en_reg+0x39>
42002e91:	f7c222        	addi	a2, a2, -9
42002e94:	db1c      	movi.n	a11, 29
    default:
        return SYSTEM_PERIP_CLK_EN0_REG;
42002e96:	f48a81        	l32r	a8, 420000c0 <_stext+0xa0>
    switch (periph) {
42002e99:	243b27        	bltu	a11, a2, 42002ec1 <periph_ll_get_clk_en_reg+0x39>
42002e9c:	190c      	movi.n	a9, 1
42002e9e:	f55ea1        	l32r	a10, 42000418 <_stext+0x3f8>
42002ea1:	401200        	ssl	a2
42002ea4:	a19900        	sll	a9, a9
        return SYSTEM_PERIP_CLK_EN1_REG;
42002ea7:	f48781        	l32r	a8, 420000c4 <_stext+0xa4>
42002eaa:	1389a7        	bany	a9, a10, 42002ec1 <periph_ll_get_clk_en_reg+0x39>
42002ead:	fa3c      	movi.n	a10, 63
42002eaf:	11aa00        	slli	a10, a10, 16
    switch (periph) {
42002eb2:	f48581        	l32r	a8, 420000c8 <_stext+0xa8>
42002eb5:	0889a7        	bany	a9, a10, 42002ec1 <periph_ll_get_clk_en_reg+0x39>
        return SYSTEM_PERIP_CLK_EN0_REG;
42002eb8:	f48281        	l32r	a8, 420000c0 <_stext+0xa0>
42002ebb:	0292b7        	bne	a2, a11, 42002ec1 <periph_ll_get_clk_en_reg+0x39>
        return SYSTEM_CPU_PERI_CLK_EN_REG;
42002ebe:	f55581        	l32r	a8, 42000414 <_stext+0x3f4>
    }
}
42002ec1:	082d      	mov.n	a2, a8
42002ec3:	f01d      	retw.n
42002ec5:	000000        	ill

42002ec8 <periph_ll_get_rst_en_reg>:

static uint32_t periph_ll_get_rst_en_reg(periph_module_t periph)
{
42002ec8:	004136        	entry	a1, 32
    case PERIPH_HMAC_MODULE:
    case PERIPH_DS_MODULE:
    case PERIPH_AES_MODULE:
    case PERIPH_SHA_MODULE:
    case PERIPH_RSA_MODULE:
        return SYSTEM_PERIP_RST_EN1_REG;
42002ecb:	f48281        	l32r	a8, 420000d4 <_stext+0xb4>
    switch (periph) {
42002ece:	2f3226        	beqi	a2, 3, 42002f01 <periph_ll_get_rst_en_reg+0x39>
42002ed1:	f7c222        	addi	a2, a2, -9
42002ed4:	db1c      	movi.n	a11, 29
    default:
        return SYSTEM_PERIP_RST_EN0_REG;
42002ed6:	f47e81        	l32r	a8, 420000d0 <_stext+0xb0>
    switch (periph) {
42002ed9:	243b27        	bltu	a11, a2, 42002f01 <periph_ll_get_rst_en_reg+0x39>
42002edc:	190c      	movi.n	a9, 1
42002ede:	f54ea1        	l32r	a10, 42000418 <_stext+0x3f8>
42002ee1:	401200        	ssl	a2
42002ee4:	a19900        	sll	a9, a9
        return SYSTEM_PERIP_RST_EN1_REG;
42002ee7:	f47b81        	l32r	a8, 420000d4 <_stext+0xb4>
42002eea:	1389a7        	bany	a9, a10, 42002f01 <periph_ll_get_rst_en_reg+0x39>
42002eed:	fa3c      	movi.n	a10, 63
42002eef:	11aa00        	slli	a10, a10, 16
    switch (periph) {
42002ef2:	f54b81        	l32r	a8, 42000420 <_stext+0x400>
42002ef5:	0889a7        	bany	a9, a10, 42002f01 <periph_ll_get_rst_en_reg+0x39>
        return SYSTEM_PERIP_RST_EN0_REG;
42002ef8:	f47681        	l32r	a8, 420000d0 <_stext+0xb0>
42002efb:	0292b7        	bne	a2, a11, 42002f01 <periph_ll_get_rst_en_reg+0x39>
        return SYSTEM_CPU_PERI_RST_EN_REG;
42002efe:	f54781        	l32r	a8, 4200041c <_stext+0x3fc>
    }
}
42002f01:	082d      	mov.n	a2, a8
42002f03:	f01d      	retw.n
42002f05:	000000        	ill

42002f08 <periph_module_enable>:
static portMUX_TYPE periph_spinlock = portMUX_INITIALIZER_UNLOCKED;

static uint8_t ref_counts[PERIPH_MODULE_MAX] = {0};

void periph_module_enable(periph_module_t periph)
{
42002f08:	004136        	entry	a1, 32
    assert(periph < PERIPH_MODULE_MAX);
42002f0b:	832c      	movi.n	a3, 40
42002f0d:	10b327        	bgeu	a3, a2, 42002f21 <periph_module_enable+0x19>
42002f10:	f545d1        	l32r	a13, 42000424 <_stext+0x404>
42002f13:	f545c1        	l32r	a12, 42000428 <_stext+0x408>
42002f16:	f545a1        	l32r	a10, 4200042c <_stext+0x40c>
42002f19:	1b1c      	movi.n	a11, 17
42002f1b:	f45a81        	l32r	a8, 42000084 <_stext+0x64>
42002f1e:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42002f21:	f52081        	l32r	a8, 420003a4 <_stext+0x384>
42002f24:	0008e0        	callx8	a8
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42002f27:	f54241        	l32r	a4, 42000430 <_stext+0x410>
42002f2a:	fb7c      	movi.n	a11, -1
42002f2c:	20a440        	or	a10, a4, a4
42002f2f:	f44481        	l32r	a8, 42000040 <_stext+0x20>
42002f32:	0008e0        	callx8	a8
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    if (ref_counts[periph] == 0) {
42002f35:	f53f31        	l32r	a3, 42000434 <_stext+0x414>
42002f38:	532a      	add.n	a5, a3, a2
42002f3a:	000552        	l8ui	a5, a5, 0
42002f3d:	039556        	bnez	a5, 42002f7a <periph_module_enable+0x72>

static inline void periph_ll_enable_clk_clear_rst(periph_module_t periph)
{
    DPORT_SET_PERI_REG_MASK(periph_ll_get_clk_en_reg(periph), periph_ll_get_clk_en_mask(periph));
42002f40:	20a220        	or	a10, a2, a2
42002f43:	fff465        	call8	42002e88 <periph_ll_get_clk_en_reg>
42002f46:	0020c0        	memw
42002f49:	0a68      	l32i.n	a6, a10, 0
42002f4b:	0a7d      	mov.n	a7, a10
42002f4d:	02ad      	mov.n	a10, a2
42002f4f:	ffd765        	call8	42002cc4 <periph_ll_get_clk_en_mask>
42002f52:	20a6a0        	or	a10, a6, a10
42002f55:	0020c0        	memw
42002f58:	07a9      	s32i.n	a10, a7, 0
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, true));
42002f5a:	02ad      	mov.n	a10, a2
42002f5c:	fff6a5        	call8	42002ec8 <periph_ll_get_rst_en_reg>
42002f5f:	0020c0        	memw
42002f62:	0a78      	l32i.n	a7, a10, 0
42002f64:	0a6d      	mov.n	a6, a10
42002f66:	1b0c      	movi.n	a11, 1
42002f68:	02ad      	mov.n	a10, a2
42002f6a:	14dd65        	call8	42017d40 <periph_ll_get_rst_en_mask>
42002f6d:	f87c      	movi.n	a8, -1
42002f6f:	30a8a0        	xor	a10, a8, a10
42002f72:	10aa70        	and	a10, a10, a7
42002f75:	0020c0        	memw
42002f78:	06a9      	s32i.n	a10, a6, 0
        periph_ll_enable_clk_clear_rst(periph);
    }
    ref_counts[periph]++;
42002f7a:	332a      	add.n	a3, a3, a2
42002f7c:	01c552        	addi	a5, a5, 1
42002f7f:	004352        	s8i	a5, a3, 0
    if (xPortInIsrContext()) {
42002f82:	f50881        	l32r	a8, 420003a4 <_stext+0x384>
42002f85:	0008e0        	callx8	a8
        portEXIT_CRITICAL_ISR(mux);
42002f88:	04ad      	mov.n	a10, a4
42002f8a:	f42e81        	l32r	a8, 42000044 <_stext+0x24>
42002f8d:	0008e0        	callx8	a8
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}
42002f90:	f01d      	retw.n
	...

42002f94 <periph_module_disable>:

void periph_module_disable(periph_module_t periph)
{
42002f94:	004136        	entry	a1, 32
    assert(periph < PERIPH_MODULE_MAX);
42002f97:	832c      	movi.n	a3, 40
42002f99:	10b327        	bgeu	a3, a2, 42002fad <periph_module_disable+0x19>
42002f9c:	f522d1        	l32r	a13, 42000424 <_stext+0x404>
42002f9f:	f526c1        	l32r	a12, 42000438 <_stext+0x418>
42002fa2:	f522a1        	l32r	a10, 4200042c <_stext+0x40c>
42002fa5:	cb1c      	movi.n	a11, 28
42002fa7:	f43781        	l32r	a8, 42000084 <_stext+0x64>
42002faa:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42002fad:	f4fd81        	l32r	a8, 420003a4 <_stext+0x384>
42002fb0:	0008e0        	callx8	a8
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
42002fb3:	f51f41        	l32r	a4, 42000430 <_stext+0x410>
42002fb6:	fb7c      	movi.n	a11, -1
42002fb8:	04ad      	mov.n	a10, a4
42002fba:	f42181        	l32r	a8, 42000040 <_stext+0x20>
42002fbd:	0008e0        	callx8	a8
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    ref_counts[periph]--;
42002fc0:	f51d81        	l32r	a8, 42000434 <_stext+0x414>
42002fc3:	882a      	add.n	a8, a8, a2
42002fc5:	000832        	l8ui	a3, a8, 0
42002fc8:	330b      	addi.n	a3, a3, -1
42002fca:	743030        	extui	a3, a3, 0, 8
42002fcd:	004832        	s8i	a3, a8, 0
    if (ref_counts[periph] == 0) {
42002fd0:	038356        	bnez	a3, 4200300c <periph_module_disable+0x78>
}

static inline void periph_ll_disable_clk_set_rst(periph_module_t periph)
{
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_clk_en_reg(periph), periph_ll_get_clk_en_mask(periph));
42002fd3:	02ad      	mov.n	a10, a2
42002fd5:	ffeb25        	call8	42002e88 <periph_ll_get_clk_en_reg>
42002fd8:	0020c0        	memw
42002fdb:	0a68      	l32i.n	a6, a10, 0
42002fdd:	0a5d      	mov.n	a5, a10
42002fdf:	02ad      	mov.n	a10, a2
42002fe1:	ffce25        	call8	42002cc4 <periph_ll_get_clk_en_mask>
42002fe4:	f87c      	movi.n	a8, -1
42002fe6:	30a8a0        	xor	a10, a8, a10
42002fe9:	10aa60        	and	a10, a10, a6
42002fec:	0020c0        	memw
42002fef:	05a9      	s32i.n	a10, a5, 0
    DPORT_SET_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, false));
42002ff1:	02ad      	mov.n	a10, a2
42002ff3:	ffed65        	call8	42002ec8 <periph_ll_get_rst_en_reg>
42002ff6:	0020c0        	memw
42002ff9:	0a58      	l32i.n	a5, a10, 0
42002ffb:	0a6d      	mov.n	a6, a10
42002ffd:	03bd      	mov.n	a11, a3
42002fff:	02ad      	mov.n	a10, a2
42003001:	14d3e5        	call8	42017d40 <periph_ll_get_rst_en_mask>
42003004:	20a5a0        	or	a10, a5, a10
42003007:	0020c0        	memw
4200300a:	06a9      	s32i.n	a10, a6, 0
    if (xPortInIsrContext()) {
4200300c:	f4e681        	l32r	a8, 420003a4 <_stext+0x384>
4200300f:	0008e0        	callx8	a8
        portEXIT_CRITICAL_ISR(mux);
42003012:	04ad      	mov.n	a10, a4
42003014:	f40c81        	l32r	a8, 42000044 <_stext+0x24>
42003017:	0008e0        	callx8	a8
        periph_ll_disable_clk_set_rst(periph);
    }
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}
4200301a:	f01d      	retw.n

4200301c <periph_module_reset>:

void periph_module_reset(periph_module_t periph)
{
4200301c:	004136        	entry	a1, 32
    assert(periph < PERIPH_MODULE_MAX);
4200301f:	28a032        	movi	a3, 40
42003022:	11b327        	bgeu	a3, a2, 42003037 <periph_module_reset+0x1b>
42003025:	f4ffd1        	l32r	a13, 42000424 <_stext+0x404>
42003028:	f505c1        	l32r	a12, 4200043c <_stext+0x41c>
4200302b:	f500a1        	l32r	a10, 4200042c <_stext+0x40c>
4200302e:	27a0b2        	movi	a11, 39
42003031:	f41481        	l32r	a8, 42000084 <_stext+0x64>
42003034:	0008e0        	callx8	a8
    if (xPortInIsrContext()) {
42003037:	f4db81        	l32r	a8, 420003a4 <_stext+0x384>
4200303a:	0008e0        	callx8	a8
        ret = portTRY_ENTER_CRITICAL_ISR(mux, timeout);
4200303d:	f4fc51        	l32r	a5, 42000430 <_stext+0x410>
42003040:	fb7c      	movi.n	a11, -1
42003042:	05ad      	mov.n	a10, a5
42003044:	f3ff81        	l32r	a8, 42000040 <_stext+0x20>
42003047:	0008e0        	callx8	a8
    DPORT_SET_PERI_REG_MASK(SYSTEM_CORE_RST_EN_REG, 0);
}

static inline void periph_ll_reset(periph_module_t periph)
{
    DPORT_SET_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, false));
4200304a:	02ad      	mov.n	a10, a2
4200304c:	ffe7a5        	call8	42002ec8 <periph_ll_get_rst_en_reg>
4200304f:	0020c0        	memw
42003052:	0a48      	l32i.n	a4, a10, 0
42003054:	0a3d      	mov.n	a3, a10
42003056:	0b0c      	movi.n	a11, 0
42003058:	02ad      	mov.n	a10, a2
4200305a:	14ce65        	call8	42017d40 <periph_ll_get_rst_en_mask>
4200305d:	2044a0        	or	a4, a4, a10
42003060:	0020c0        	memw
42003063:	0349      	s32i.n	a4, a3, 0
    DPORT_CLEAR_PERI_REG_MASK(periph_ll_get_rst_en_reg(periph), periph_ll_get_rst_en_mask(periph, false));
42003065:	0020c0        	memw
42003068:	0328      	l32i.n	a2, a3, 0
4200306a:	f87c      	movi.n	a8, -1
4200306c:	3088a0        	xor	a8, a8, a10
4200306f:	108820        	and	a8, a8, a2
42003072:	0020c0        	memw
42003075:	0389      	s32i.n	a8, a3, 0
    if (xPortInIsrContext()) {
42003077:	f4cb81        	l32r	a8, 420003a4 <_stext+0x384>
4200307a:	0008e0        	callx8	a8
        portEXIT_CRITICAL_ISR(mux);
4200307d:	05ad      	mov.n	a10, a5
4200307f:	f3f181        	l32r	a8, 42000044 <_stext+0x24>
42003082:	0008e0        	callx8	a8
    portENTER_CRITICAL_SAFE(&periph_spinlock);
    periph_ll_reset(periph);
    portEXIT_CRITICAL_SAFE(&periph_spinlock);
}
42003085:	f01d      	retw.n
	...

42003088 <rtc_isr_register>:
{
42003088:	006136        	entry	a1, 48
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
4200308b:	f4ed61        	l32r	a6, 42000440 <_stext+0x420>
4200308e:	fb7c      	movi.n	a11, -1
42003090:	06ad      	mov.n	a10, a6
42003092:	f3eb81        	l32r	a8, 42000040 <_stext+0x20>
42003095:	0008e0        	callx8	a8
    if (s_rtc_isr_handle) {
42003098:	f4eb81        	l32r	a8, 42000444 <_stext+0x424>
    esp_err_t err = ESP_OK;
4200309b:	070c      	movi.n	a7, 0
    if (s_rtc_isr_handle) {
4200309d:	0898      	l32i.n	a9, a8, 0
4200309f:	329977        	bne	a9, a7, 420030d5 <rtc_isr_register+0x4d>
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
420030a2:	f4e991        	l32r	a9, 42000448 <_stext+0x428>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
420030a5:	fa7c      	movi.n	a10, -1
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
420030a7:	0020c0        	memw
420030aa:	0979      	s32i.n	a7, a9, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
420030ac:	f4e891        	l32r	a9, 4200044c <_stext+0x42c>
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
420030af:	f4e8c1        	l32r	a12, 42000450 <_stext+0x430>
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
420030b2:	0020c0        	memw
420030b5:	09a9      	s32i.n	a10, a9, 0
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
420030b7:	08ed      	mov.n	a14, a8
420030b9:	07dd      	mov.n	a13, a7
420030bb:	00a4b2        	movi	a11, 0x400
420030be:	7a2c      	movi.n	a10, 39
420030c0:	0189      	s32i.n	a8, a1, 0
420030c2:	fface5        	call8	42002b90 <esp_intr_alloc>
    if (err != ESP_OK) {
420030c5:	0188      	l32i.n	a8, a1, 0
    err = esp_intr_alloc(ETS_RTC_CORE_INTR_SOURCE, ESP_INTR_FLAG_IRAM, &rtc_isr, NULL, &s_rtc_isr_handle);
420030c7:	0a7d      	mov.n	a7, a10
    if (err != ESP_OK) {
420030c9:	8acc      	bnez.n	a10, 420030d5 <rtc_isr_register+0x4d>
    rtc_isr_cpu = esp_intr_get_cpu(s_rtc_isr_handle);
420030cb:	08a8      	l32i.n	a10, a8, 0
420030cd:	14c665        	call8	42017d34 <esp_intr_get_cpu>
420030d0:	f4e181        	l32r	a8, 42000454 <_stext+0x434>
420030d3:	08a9      	s32i.n	a10, a8, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
420030d5:	06ad      	mov.n	a10, a6
420030d7:	f3db81        	l32r	a8, 42000044 <_stext+0x24>
420030da:	0008e0        	callx8	a8
    if (err != ESP_OK) {
420030dd:	045756        	bnez	a7, 42003126 <rtc_isr_register+0x9e>
    rtc_isr_handler_t* item = heap_caps_malloc(sizeof(*item), MALLOC_CAP_INTERNAL);
420030e0:	1b0c      	movi.n	a11, 1
420030e2:	11bb50        	slli	a11, a11, 11
420030e5:	4a1c      	movi.n	a10, 20
420030e7:	f4b781        	l32r	a8, 420003c4 <_stext+0x3a4>
420030ea:	0008e0        	callx8	a8
420030ed:	0a9d      	mov.n	a9, a10
    if (item == NULL) {
420030ef:	045a16        	beqz	a10, 42003138 <rtc_isr_register+0xb0>
    item->handler_arg = handler_arg;
420030f2:	2a39      	s32i.n	a3, a10, 8
    item->handler = handler;
420030f4:	1a29      	s32i.n	a2, a10, 4
    item->mask = rtc_intr_mask;
420030f6:	0a49      	s32i.n	a4, a10, 0
    item->flags = flags;
420030f8:	3a59      	s32i.n	a5, a10, 12
420030fa:	fb7c      	movi.n	a11, -1
420030fc:	06ad      	mov.n	a10, a6
420030fe:	0199      	s32i.n	a9, a1, 0
42003100:	f3d081        	l32r	a8, 42000040 <_stext+0x20>
42003103:	0008e0        	callx8	a8
    if (flags & RTC_INTR_FLAG_IRAM) {
42003106:	0198      	l32i.n	a9, a1, 0
42003108:	f4d431        	l32r	a3, 42000458 <_stext+0x438>
4200310b:	1b6507        	bbci	a5, 0, 4200312a <rtc_isr_register+0xa2>
    rtc_intr_cache |= rtc_intr_mask;
4200310e:	0328      	l32i.n	a2, a3, 0
42003110:	204420        	or	a4, a4, a2
    SLIST_INSERT_HEAD(&s_rtc_isr_handler_list, item, next);
42003113:	f4d221        	l32r	a2, 4200045c <_stext+0x43c>
42003116:	0349      	s32i.n	a4, a3, 0
42003118:	0238      	l32i.n	a3, a2, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
4200311a:	06ad      	mov.n	a10, a6
    SLIST_INSERT_HEAD(&s_rtc_isr_handler_list, item, next);
4200311c:	4939      	s32i.n	a3, a9, 16
4200311e:	0299      	s32i.n	a9, a2, 0
    portEXIT_CRITICAL(&s_rtc_isr_handler_list_lock);
42003120:	f3c981        	l32r	a8, 42000044 <_stext+0x24>
42003123:	0008e0        	callx8	a8
}
42003126:	072d      	mov.n	a2, a7
42003128:	f01d      	retw.n
    rtc_intr_cache &= ~rtc_intr_mask;
4200312a:	0328      	l32i.n	a2, a3, 0
4200312c:	f87c      	movi.n	a8, -1
4200312e:	304840        	xor	a4, a8, a4
42003131:	104420        	and	a4, a4, a2
}
42003134:	fff6c6        	j	42003113 <rtc_isr_register+0x8b>
42003137:	00          	.byte 00
        return ESP_ERR_NO_MEM;
42003138:	01a172        	movi	a7, 0x101
4200313b:	fff9c6        	j	42003126 <rtc_isr_register+0x9e>
	...

42003140 <esp_deep_sleep_wakeup_io_reset>:
    }
}
#endif

void esp_deep_sleep_wakeup_io_reset(void)
{
42003140:	004136        	entry	a1, 32
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
}

static inline uint32_t rtc_cntl_ll_ext1_get_wakeup_pins(void)
{
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003143:	f4c721        	l32r	a2, 42000460 <_stext+0x440>
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
42003146:	fa7c      	movi.n	a10, -1
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003148:	0020c0        	memw
4200314b:	0298      	l32i.n	a9, a2, 0
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
4200314d:	0020c0        	memw
42003150:	0288      	l32i.n	a8, a2, 0
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003152:	f4c431        	l32r	a3, 42000464 <_stext+0x444>
    CLEAR_PERI_REG_MASK(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL_M);
42003155:	01aaa0        	slli	a10, a10, 22
42003158:	1088a0        	and	a8, a8, a10
4200315b:	f4c3c1        	l32r	a12, 42000468 <_stext+0x448>
 * @note If disable the pad hold, the status of pad maybe changed in sleep mode.
 * @param rtcio_num The index of rtcio. 0 ~ MAX(rtcio).
 */
static inline void rtcio_ll_force_hold_disable(int rtcio_num)
{
    CLEAR_PERI_REG_MASK(RTC_CNTL_PAD_HOLD_REG, rtc_io_desc[rtcio_num].hold_force);
4200315e:	f4c3d1        	l32r	a13, 4200046c <_stext+0x44c>
42003161:	0020c0        	memw
42003164:	0289      	s32i.n	a8, a2, 0
    return REG_GET_FIELD(RTC_CNTL_EXT_WAKEUP1_REG, RTC_CNTL_EXT_WAKEUP1_SEL);
42003166:	109930        	and	a9, a9, a3
#if SOC_PM_SUPPORT_EXT_WAKEUP
    uint32_t rtc_io_mask = rtc_hal_ext1_get_wakeup_pins();
    // Disable ext1 wakeup before releasing hold, such that wakeup status can reflect the correct wakeup pin
    rtc_hal_ext1_clear_wakeup_pins();
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
42003169:	0b0c      	movi.n	a11, 0
4200316b:	0f3c      	movi.n	a15, 48
4200316d:	120c      	movi.n	a2, 1
4200316f:	fe7c      	movi.n	a14, -1
42003171:	012fb7        	blt	a15, a11, 42003176 <esp_deep_sleep_wakeup_io_reset+0x36>
42003174:	09cc      	bnez.n	a9, 42003178 <esp_deep_sleep_wakeup_io_reset+0x38>
            gpio_hal_hold_dis(&gpio_hal, gpio_num);
        }
        dl_io_mask &= ~BIT(gpio_num);
    }
#endif
}
42003176:	f01d      	retw.n
        int rtcio_num = rtc_io_num_map[gpio_num];
42003178:	0c88      	l32i.n	a8, a12, 0
        if ((rtc_io_mask & BIT(rtcio_num)) == 0) {
4200317a:	265987        	bbc	a9, a8, 420031a4 <esp_deep_sleep_wakeup_io_reset+0x64>
4200317d:	f4bc41        	l32r	a4, 42000470 <_stext+0x450>
42003180:	f0a880        	subx8	a10, a8, a8
42003183:	b0aa40        	addx8	a10, a10, a4
42003186:	aaa8      	l32i.n	a10, a10, 40
42003188:	0020c0        	memw
4200318b:	0d38      	l32i.n	a3, a13, 0
4200318d:	30aea0        	xor	a10, a14, a10
        rtc_io_mask &= ~BIT(rtcio_num);
42003190:	401800        	ssl	a8
42003193:	a18200        	sll	a8, a2
42003196:	10aa30        	and	a10, a10, a3
42003199:	308e80        	xor	a8, a14, a8
4200319c:	0020c0        	memw
4200319f:	0da9      	s32i.n	a10, a13, 0
420031a1:	109980        	and	a9, a9, a8
    for (int gpio_num = 0; gpio_num < SOC_GPIO_PIN_COUNT && rtc_io_mask != 0; ++gpio_num) {
420031a4:	bb1b      	addi.n	a11, a11, 1
420031a6:	cc4b      	addi.n	a12, a12, 4
420031a8:	fff146        	j	42003171 <esp_deep_sleep_wakeup_io_reset+0x31>
	...

420031ac <esp_chip_info>:
#include <string.h>
#include "esp_chip_info.h"
#include "hal/efuse_hal.h"

void esp_chip_info(esp_chip_info_t *out_info)
{
420031ac:	004136        	entry	a1, 32
    memset(out_info, 0, sizeof(*out_info));
420031af:	8c0c      	movi.n	a12, 8
420031b1:	00a0b2        	movi	a11, 0
420031b4:	a24b      	addi.n	a10, a2, 4
420031b6:	f3f881        	l32r	a8, 42000198 <_stext+0x178>
420031b9:	0008e0        	callx8	a8
    out_info->model = CHIP_ESP32S3;
420031bc:	980c      	movi.n	a8, 9
420031be:	0289      	s32i.n	a8, a2, 0
    out_info->revision = efuse_hal_chip_revision();
420031c0:	f4ad81        	l32r	a8, 42000474 <_stext+0x454>
420031c3:	0008e0        	callx8	a8
    out_info->cores = 2;
420031c6:	280c      	movi.n	a8, 2
420031c8:	0a4282        	s8i	a8, a2, 10
    out_info->features = CHIP_FEATURE_WIFI_BGN | CHIP_FEATURE_BLE;
420031cb:	281c      	movi.n	a8, 18
    out_info->revision = efuse_hal_chip_revision();
420031cd:	0452a2        	s16i	a10, a2, 8
    out_info->features = CHIP_FEATURE_WIFI_BGN | CHIP_FEATURE_BLE;
420031d0:	1289      	s32i.n	a8, a2, 4
}
420031d2:	f01d      	retw.n

420031d4 <memprot_ll_prepare_iram0_split_line_regval>:
{
420031d4:	008136        	entry	a1, 64
    uint32_t cat[7] = {[0 ... 6]=MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA};
420031d7:	f4a8b1        	l32r	a11, 42000478 <_stext+0x458>
420031da:	cc1c      	movi.n	a12, 28
420031dc:	01ad      	mov.n	a10, a1
420031de:	f3fb81        	l32r	a8, 420001cc <_stext+0x1ac>
420031e1:	0008e0        	callx8	a8
    for (size_t x=0; x<7; x++) {
420031e4:	080c      	movi.n	a8, 0
420031e6:	f4a5b1        	l32r	a11, 4200047c <_stext+0x45c>
420031e9:	01ad      	mov.n	a10, a1
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
420031eb:	08cd      	mov.n	a12, a8
420031ed:	790c      	movi.n	a9, 7
420031ef:	818976        	loop	a9, 42003274 <memprot_ll_prepare_iram0_split_line_regval+0xa0>
        if (addr <= sram_rg3_level_hlimits[x]) {
420031f2:	0bd8      	l32i.n	a13, a11, 0
420031f4:	743d27        	bltu	a13, a2, 4200326c <memprot_ll_prepare_iram0_split_line_regval+0x98>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
420031f7:	a08810        	addx4	a8, a8, a1
420031fa:	290c      	movi.n	a9, 2
420031fc:	0899      	s32i.n	a9, a8, 0
    constrain_reg_fields_t cfg_reg_val = {
420031fe:	1188      	l32i.n	a8, a1, 4
42003200:	c90c      	movi.n	a9, 12
42003202:	1188e0        	slli	a8, a8, 2
42003205:	108890        	and	a8, a8, a9
42003208:	0198      	l32i.n	a9, a1, 0
4200320a:	0a3c      	movi.n	a10, 48
4200320c:	149090        	extui	a9, a9, 0, 2
4200320f:	208890        	or	a8, a8, a9
42003212:	2198      	l32i.n	a9, a1, 8
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR_V);
42003214:	412820        	srli	a2, a2, 8
    constrain_reg_fields_t cfg_reg_val = {
42003217:	1199c0        	slli	a9, a9, 4
4200321a:	1099a0        	and	a9, a9, a10
4200321d:	208890        	or	a8, a8, a9
42003220:	3198      	l32i.n	a9, a1, 12
42003222:	00a3a2        	movi	a10, 0x300
42003225:	1199a0        	slli	a9, a9, 6
42003228:	749090        	extui	a9, a9, 0, 8
4200322b:	208890        	or	a8, a8, a9
4200322e:	4198      	l32i.n	a9, a1, 16
42003230:	112220        	slli	a2, a2, 14
42003233:	119980        	slli	a9, a9, 8
42003236:	1099a0        	and	a9, a9, a10
42003239:	208890        	or	a8, a8, a9
4200323c:	5198      	l32i.n	a9, a1, 20
4200323e:	3a0c      	movi.n	a10, 3
42003240:	11aa60        	slli	a10, a10, 10
42003243:	119960        	slli	a9, a9, 10
42003246:	1099a0        	and	a9, a9, a10
42003249:	208890        	or	a8, a8, a9
4200324c:	6198      	l32i.n	a9, a1, 24
4200324e:	3a0c      	movi.n	a10, 3
42003250:	119940        	slli	a9, a9, 12
42003253:	11aa40        	slli	a10, a10, 12
42003256:	1099a0        	and	a9, a9, a10
42003259:	208890        	or	a8, a8, a9
4200325c:	ffa092        	movi	a9, 255
4200325f:	119920        	slli	a9, a9, 14
42003262:	102290        	and	a2, a2, a9
42003265:	208820        	or	a8, a8, a2
    *regval = cfg_reg_val.val;
42003268:	0389      	s32i.n	a8, a3, 0
}
4200326a:	f01d      	retw.n
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
4200326c:	0ac9      	s32i.n	a12, a10, 0
    for (size_t x=0; x<7; x++) {
4200326e:	881b      	addi.n	a8, a8, 1
42003270:	bb4b      	addi.n	a11, a11, 4
42003272:	aa4b      	addi.n	a10, a10, 4
42003274:	ffe186        	j	420031fe <memprot_ll_prepare_iram0_split_line_regval+0x2a>
	...

42003278 <memprot_ll_set_iram0_split_line>:
{
42003278:	006136        	entry	a1, 48
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
4200327b:	f48191        	l32r	a9, 42000480 <_stext+0x460>
{
4200327e:	20a220        	or	a10, a2, a2
    MEMP_HAL_CHECK_IRAM_ADDR_IN_RANGE(addr)
42003281:	809290        	add	a9, a2, a9
42003284:	f48021        	l32r	a2, 42000484 <_stext+0x464>
42003287:	02a082        	movi	a8, 2
4200328a:	143297        	bltu	a2, a9, 420032a2 <memprot_ll_set_iram0_split_line+0x2a>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
4200328d:	7420a0        	extui	a2, a10, 0, 8
42003290:	380c      	movi.n	a8, 3
42003292:	c2cc      	bnez.n	a2, 420032a2 <memprot_ll_set_iram0_split_line+0x2a>
    memprot_ll_prepare_iram0_split_line_regval(addr, &regval);
42003294:	01bd      	mov.n	a11, a1
42003296:	fff3e5        	call8	420031d4 <memprot_ll_prepare_iram0_split_line_regval>
    REG_WRITE(sensitive_reg, regval);
42003299:	0188      	l32i.n	a8, a1, 0
4200329b:	0020c0        	memw
4200329e:	0389      	s32i.n	a8, a3, 0
    return MEMP_HAL_OK;
420032a0:	028d      	mov.n	a8, a2
}
420032a2:	082d      	mov.n	a2, a8
420032a4:	f01d      	retw.n
	...

420032a8 <memprot_ll_prepare_dram0_split_line_regval>:
{
420032a8:	008136        	entry	a1, 64
    uint32_t cat[7] = {[0 ... 6]=MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_ABOVE_SA};
420032ab:	f473b1        	l32r	a11, 42000478 <_stext+0x458>
420032ae:	cc1c      	movi.n	a12, 28
420032b0:	01ad      	mov.n	a10, a1
420032b2:	f3c681        	l32r	a8, 420001cc <_stext+0x1ac>
420032b5:	0008e0        	callx8	a8
    for (size_t x=0; x<7; x++) {
420032b8:	080c      	movi.n	a8, 0
420032ba:	f470b1        	l32r	a11, 4200047c <_stext+0x45c>
420032bd:	01ad      	mov.n	a10, a1
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
420032bf:	08ed      	mov.n	a14, a8
420032c1:	790c      	movi.n	a9, 7
420032c3:	898976        	loop	a9, 42003350 <memprot_ll_prepare_dram0_split_line_regval+0xa8>
        if (addr <= MAP_IRAM_TO_DRAM(sram_rg3_level_hlimits[x])) {
420032c6:	0bc8      	l32i.n	a12, a11, 0
420032c8:	91afd2        	movi	a13, -111
420032cb:	11dd00        	slli	a13, a13, 16
420032ce:	ccda      	add.n	a12, a12, a13
420032d0:	743c27        	bltu	a12, a2, 42003348 <memprot_ll_prepare_dram0_split_line_regval+0xa0>
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_EQUAL_SA;
420032d3:	a08810        	addx4	a8, a8, a1
420032d6:	290c      	movi.n	a9, 2
420032d8:	0899      	s32i.n	a9, a8, 0
    constrain_reg_fields_t cfg_reg_val = {
420032da:	1188      	l32i.n	a8, a1, 4
420032dc:	c90c      	movi.n	a9, 12
420032de:	1188e0        	slli	a8, a8, 2
420032e1:	108890        	and	a8, a8, a9
420032e4:	0198      	l32i.n	a9, a1, 0
420032e6:	0a3c      	movi.n	a10, 48
420032e8:	149090        	extui	a9, a9, 0, 2
420032eb:	208890        	or	a8, a8, a9
420032ee:	2198      	l32i.n	a9, a1, 8
    uint32_t conf_add = ((addr >> I_D_SPLIT_LINE_SHIFT) & SENSITIVE_CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR_V);
420032f0:	412820        	srli	a2, a2, 8
    constrain_reg_fields_t cfg_reg_val = {
420032f3:	1199c0        	slli	a9, a9, 4
420032f6:	1099a0        	and	a9, a9, a10
420032f9:	208890        	or	a8, a8, a9
420032fc:	3198      	l32i.n	a9, a1, 12
420032fe:	00a3a2        	movi	a10, 0x300
42003301:	1199a0        	slli	a9, a9, 6
42003304:	749090        	extui	a9, a9, 0, 8
42003307:	208890        	or	a8, a8, a9
4200330a:	4198      	l32i.n	a9, a1, 16
4200330c:	112220        	slli	a2, a2, 14
4200330f:	119980        	slli	a9, a9, 8
42003312:	1099a0        	and	a9, a9, a10
42003315:	208890        	or	a8, a8, a9
42003318:	5198      	l32i.n	a9, a1, 20
4200331a:	3a0c      	movi.n	a10, 3
4200331c:	11aa60        	slli	a10, a10, 10
4200331f:	119960        	slli	a9, a9, 10
42003322:	1099a0        	and	a9, a9, a10
42003325:	208890        	or	a8, a8, a9
42003328:	6198      	l32i.n	a9, a1, 24
4200332a:	3a0c      	movi.n	a10, 3
4200332c:	119940        	slli	a9, a9, 12
4200332f:	11aa40        	slli	a10, a10, 12
42003332:	1099a0        	and	a9, a9, a10
42003335:	208890        	or	a8, a8, a9
42003338:	ffa092        	movi	a9, 255
4200333b:	119920        	slli	a9, a9, 14
4200333e:	102290        	and	a2, a2, a9
42003341:	208820        	or	a8, a8, a2
    *regval = cfg_reg_val.val;
42003344:	0389      	s32i.n	a8, a3, 0
}
42003346:	f01d      	retw.n
            cat[x] = MEMP_HAL_CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_BITS_BELOW_SA;
42003348:	0ae9      	s32i.n	a14, a10, 0
    for (size_t x=0; x<7; x++) {
4200334a:	881b      	addi.n	a8, a8, 1
4200334c:	bb4b      	addi.n	a11, a11, 4
4200334e:	aa4b      	addi.n	a10, a10, 4
42003350:	ffe186        	j	420032da <memprot_ll_prepare_dram0_split_line_regval+0x32>
	...

42003354 <memprot_ll_set_dram0_split_line>:
{
42003354:	006136        	entry	a1, 48
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
42003357:	f44c91        	l32r	a9, 42000488 <_stext+0x468>
{
4200335a:	20a220        	or	a10, a2, a2
    MEMP_HAL_CHECK_DRAM_ADDR_IN_RANGE(addr)
4200335d:	809290        	add	a9, a2, a9
42003360:	f44921        	l32r	a2, 42000484 <_stext+0x464>
42003363:	02a082        	movi	a8, 2
42003366:	143297        	bltu	a2, a9, 4200337e <memprot_ll_set_dram0_split_line+0x2a>
    MEMP_HAL_CHECK_SPLIT_ADDR_ALIGNED(addr)
42003369:	7420a0        	extui	a2, a10, 0, 8
4200336c:	380c      	movi.n	a8, 3
4200336e:	c2cc      	bnez.n	a2, 4200337e <memprot_ll_set_dram0_split_line+0x2a>
    memprot_ll_prepare_dram0_split_line_regval(addr, &regval);
42003370:	01bd      	mov.n	a11, a1
42003372:	fff365        	call8	420032a8 <memprot_ll_prepare_dram0_split_line_regval>
    REG_WRITE(sensitive_reg, regval);
42003375:	0188      	l32i.n	a8, a1, 0
42003377:	0020c0        	memw
4200337a:	0389      	s32i.n	a8, a3, 0
    return MEMP_HAL_OK;
4200337c:	028d      	mov.n	a8, a2
}
4200337e:	082d      	mov.n	a2, a8
42003380:	f01d      	retw.n
	...

42003384 <esp_mprot_cpuid_valid>:
{
42003384:	004136        	entry	a1, 32
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
42003387:	f44281        	l32r	a8, 42000490 <_stext+0x470>
4200338a:	090c      	movi.n	a9, 0
4200338c:	38a8      	l32i.n	a10, a8, 12
4200338e:	049a97        	bne	a10, a9, 42003396 <esp_mprot_cpuid_valid+0x12>
    return ESP_ERR_MEMPROT_CPUID_INVALID;
42003391:	f43e21        	l32r	a2, 4200048c <_stext+0x46c>
}
42003394:	f01d      	retw.n
        if (core == s_memp_cfg.target_cpu[x]) {
42003396:	48b8      	l32i.n	a11, a8, 16
42003398:	884b      	addi.n	a8, a8, 4
4200339a:	041b27        	beq	a11, a2, 420033a2 <esp_mprot_cpuid_valid+0x1e>
    for (size_t x = 0; x < s_memp_cfg.target_cpu_count; x++) {
4200339d:	991b      	addi.n	a9, a9, 1
4200339f:	fffac6        	j	4200338e <esp_mprot_cpuid_valid+0xa>
            return ESP_OK;
420033a2:	020c      	movi.n	a2, 0
420033a4:	fffb06        	j	42003394 <esp_mprot_cpuid_valid+0x10>
	...

420033a8 <esp_mprot_set_pms_lock$part$0>:
esp_err_t esp_mprot_set_split_addr_lock(const esp_mprot_mem_t mem_type, const int core __attribute__((unused)))
420033a8:	004136        	entry	a1, 32
420033ab:	20a220        	or	a10, a2, a2
    switch (core) {
420033ae:	00e216        	beqz	a2, 420033c0 <esp_mprot_set_pms_lock$part$0+0x18>
420033b1:	181226        	beqi	a2, 1, 420033cd <esp_mprot_set_pms_lock$part$0+0x25>
420033b4:	07a0a2        	movi	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_pif_constraint_lock(core)))
420033b7:	00fe65        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
420033ba:	0a2d      	mov.n	a2, a10
420033bc:	f01d      	retw.n
420033be:	00          	.byte 00
420033bf:	00          	.byte 00
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG, 1);
420033c0:	f43581        	l32r	a8, 42000494 <_stext+0x474>
420033c3:	190c      	movi.n	a9, 1
420033c5:	0020c0        	memw
420033c8:	0899      	s32i.n	a9, a8, 0
            break;
420033ca:	fffa46        	j	420033b7 <esp_mprot_set_pms_lock$part$0+0xf>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
420033cd:	f43281        	l32r	a8, 42000498 <_stext+0x478>
    return MEMP_HAL_OK;
420033d0:	0a0c      	movi.n	a10, 0
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG, 1);
420033d2:	0020c0        	memw
420033d5:	0829      	s32i.n	a2, a8, 0
            break;
420033d7:	fff706        	j	420033b7 <esp_mprot_set_pms_lock$part$0+0xf>
	...

420033dc <esp_mprot_get_pms_lock$part$0>:
esp_err_t esp_mprot_get_pms_lock(const esp_mprot_mem_t mem_type, bool *locked, const int core __attribute__((unused)))
420033dc:	004136        	entry	a1, 32
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420033df:	03ad      	mov.n	a10, a3
420033e1:	fffa25        	call8	42003384 <esp_mprot_cpuid_valid>
420033e4:	8acc      	bnez.n	a10, 420033f0 <esp_mprot_get_pms_lock$part$0+0x14>
    switch (core) {
420033e6:	a38c      	beqz.n	a3, 420033f4 <esp_mprot_get_pms_lock$part$0+0x18>
420033e8:	1d1326        	beqi	a3, 1, 42003409 <esp_mprot_get_pms_lock$part$0+0x2d>
420033eb:	7a0c      	movi.n	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_get_pif_constraint_lock(core, locked)))
420033ed:	00fae5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
420033f0:	0a2d      	mov.n	a2, a10
420033f2:	f01d      	retw.n
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG) == 1;
420033f4:	f42831        	l32r	a3, 42000494 <_stext+0x474>
420033f7:	0020c0        	memw
420033fa:	0388      	l32i.n	a8, a3, 0
420033fc:	130c      	movi.n	a3, 1
420033fe:	880b      	addi.n	a8, a8, -1
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG) == 1;
42003400:	933a80        	movnez	a3, a10, a8
42003403:	004232        	s8i	a3, a2, 0
            break;
42003406:	fff8c6        	j	420033ed <esp_mprot_get_pms_lock$part$0+0x11>
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_0_REG) == 1;
42003409:	f42381        	l32r	a8, 42000498 <_stext+0x478>
4200340c:	0020c0        	memw
4200340f:	0888      	l32i.n	a8, a8, 0
42003411:	880b      	addi.n	a8, a8, -1
42003413:	fffa46        	j	42003400 <esp_mprot_get_pms_lock$part$0+0x24>
	...

42003418 <esp_mprot_set_split_addr>:
{
42003418:	004136        	entry	a1, 32
    switch (mem_type) {
4200341b:	352226        	beqi	a2, 2, 42003454 <esp_mprot_set_split_addr+0x3c>
4200341e:	4e4226        	beqi	a2, 4, 42003470 <esp_mprot_set_split_addr+0x58>
42003421:	f421a1        	l32r	a10, 420004a8 <_stext+0x488>
42003424:	0e1266        	bnei	a2, 1, 42003436 <esp_mprot_set_split_addr+0x1e>
        switch (line_type) {
42003427:	122326        	beqi	a3, 2, 4200343d <esp_mprot_set_split_addr+0x25>
4200342a:	1f4326        	beqi	a3, 4, 4200344d <esp_mprot_set_split_addr+0x35>
4200342d:	f41da1        	l32r	a10, 420004a4 <_stext+0x484>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
42003430:	f41fb1        	l32r	a11, 420004ac <_stext+0x48c>
42003433:	091326        	beqi	a3, 1, 42003440 <esp_mprot_set_split_addr+0x28>
}
42003436:	0a2d      	mov.n	a2, a10
42003438:	f01d      	retw.n
4200343a:	00          	.byte 00
4200343b:	00          	.byte 00
4200343c:	00          	.byte 00
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
4200343d:	f41cb1        	l32r	a11, 420004b0 <_stext+0x490>
42003440:	04ad      	mov.n	a10, a4
42003442:	ffe365        	call8	42003278 <memprot_ll_set_iram0_split_line>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_set_rtcfast_split_line(core, line_addr, MEMP_HAL_WORLD_0)))
42003445:	00f565        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
42003448:	fffa86        	j	42003436 <esp_mprot_set_split_addr+0x1e>
4200344b:	00          	.byte 00
4200344c:	00          	.byte 00
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
4200344d:	f419b1        	l32r	a11, 420004b4 <_stext+0x494>
42003450:	fffb06        	j	42003440 <esp_mprot_set_split_addr+0x28>
42003453:	00          	.byte 00
        switch (line_type) {
42003454:	0d8326        	beqi	a3, 8, 42003465 <esp_mprot_set_split_addr+0x4d>
42003457:	f413a1        	l32r	a10, 420004a4 <_stext+0x484>
4200345a:	d8b366        	bnei	a3, 16, 42003436 <esp_mprot_set_split_addr+0x1e>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
4200345d:	f417b1        	l32r	a11, 420004bc <_stext+0x49c>
42003460:	000106        	j	42003468 <esp_mprot_set_split_addr+0x50>
42003463:	00          	.byte 00
42003464:	00          	.byte 00
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42003465:	f414b1        	l32r	a11, 420004b8 <_stext+0x498>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42003468:	04ad      	mov.n	a10, a4
4200346a:	ffeea5        	call8	42003354 <memprot_ll_set_dram0_split_line>
4200346d:	fff506        	j	42003445 <esp_mprot_set_split_addr+0x2d>
            return ESP_ERR_MEMPROT_SPLIT_ADDR_INVALID;
42003470:	f40da1        	l32r	a10, 420004a4 <_stext+0x484>
        if (line_type == MEMPROT_SPLIT_ADDR_MAIN) { /* so far only WORLD_0 is supported */
42003473:	bf1366        	bnei	a3, 1, 42003436 <esp_mprot_set_split_addr+0x1e>
            ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003476:	20a550        	or	a10, a5, a5
42003479:	fff0a5        	call8	42003384 <esp_mprot_cpuid_valid>
4200347c:	fb6a56        	bnez	a10, 42003436 <esp_mprot_set_split_addr+0x1e>
    if (addr < SOC_RTC_IRAM_LOW || addr >= SOC_RTC_IRAM_HIGH) {
4200347f:	f34031        	l32r	a3, 42000180 <_stext+0x160>
42003482:	f34021        	l32r	a2, 42000184 <_stext+0x164>
42003485:	803430        	add	a3, a4, a3
42003488:	343237        	bltu	a2, a3, 420034c0 <esp_mprot_set_split_addr+0xa8>
    if (addr % 0x4 != 0) {
4200348b:	142040        	extui	a2, a4, 0, 2
4200348e:	033256        	bnez	a2, 420034c5 <esp_mprot_set_split_addr+0xad>
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42003491:	3525f6        	bgeui	a5, 2, 420034ca <esp_mprot_set_split_addr+0xb2>
    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_9_REG;
42003494:	f40231        	l32r	a3, 4200049c <_stext+0x47c>
42003497:	158c      	beqz.n	a5, 4200349c <esp_mprot_set_split_addr+0x84>
42003499:	f40131        	l32r	a3, 420004a0 <_stext+0x480>
    CLEAR_PERI_REG_MASK(reg, mask);
4200349c:	0020c0        	memw
4200349f:	0388      	l32i.n	a8, a3, 0
420034a1:	00a822        	movi	a2, 0xfffff800
420034a4:	108820        	and	a8, a8, a2
420034a7:	0020c0        	memw
420034aa:	0389      	s32i.n	a8, a3, 0
    REG_SET_BITS(reg, mask, (addr >> 2) & val);
420034ac:	0020c0        	memw
420034af:	0328      	l32i.n	a2, a3, 0
420034b1:	a44240        	extui	a4, a4, 2, 11
420034b4:	204420        	or	a4, a4, a2
420034b7:	0020c0        	memw
420034ba:	0349      	s32i.n	a4, a3, 0
    return MEMP_HAL_OK;
420034bc:	ffe146        	j	42003445 <esp_mprot_set_split_addr+0x2d>
420034bf:	00          	.byte 00
        return MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE;
420034c0:	2a0c      	movi.n	a10, 2
420034c2:	ffdfc6        	j	42003445 <esp_mprot_set_split_addr+0x2d>
        return MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED;
420034c5:	3a0c      	movi.n	a10, 3
420034c7:	ffde86        	j	42003445 <esp_mprot_set_split_addr+0x2d>
        return MEMP_HAL_ERR_CORE_INVALID;
420034ca:	7a0c      	movi.n	a10, 7
420034cc:	ffdd46        	j	42003445 <esp_mprot_set_split_addr+0x2d>
	...

420034d0 <esp_mprot_set_pms_lock>:
{
420034d0:	004136        	entry	a1, 32
    switch (mem_type) {
420034d3:	162226        	beqi	a2, 2, 420034ed <esp_mprot_set_pms_lock+0x1d>
420034d6:	204226        	beqi	a2, 4, 420034fa <esp_mprot_set_pms_lock+0x2a>
420034d9:	f3f3a1        	l32r	a10, 420004a8 <_stext+0x488>
420034dc:	091266        	bnei	a2, 1, 420034e9 <esp_mprot_set_pms_lock+0x19>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG, 1);
420034df:	f3f831        	l32r	a3, 420004c0 <_stext+0x4a0>
420034e2:	0020c0        	memw
420034e5:	0329      	s32i.n	a2, a3, 0
    return ESP_OK;
420034e7:	0a0c      	movi.n	a10, 0
}
420034e9:	0a2d      	mov.n	a2, a10
420034eb:	f01d      	retw.n
    REG_WRITE(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG, 1);
420034ed:	f3f521        	l32r	a2, 420004c4 <_stext+0x4a4>
420034f0:	130c      	movi.n	a3, 1
420034f2:	0020c0        	memw
420034f5:	0239      	s32i.n	a3, a2, 0
420034f7:	fffb06        	j	420034e7 <esp_mprot_set_pms_lock+0x17>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420034fa:	20a330        	or	a10, a3, a3
420034fd:	ffe865        	call8	42003384 <esp_mprot_cpuid_valid>
42003500:	fe5a56        	bnez	a10, 420034e9 <esp_mprot_set_pms_lock+0x19>
42003503:	20a330        	or	a10, a3, a3
42003506:	ffea25        	call8	420033a8 <esp_mprot_set_pms_lock$part$0>
42003509:	fff706        	j	420034e9 <esp_mprot_set_pms_lock+0x19>

4200350c <esp_mprot_set_pms_area>:
{
4200350c:	006136        	entry	a1, 48
    bool w = flags & MEMPROT_OP_WRITE;
4200350f:	050c      	movi.n	a5, 0
42003511:	290c      	movi.n	a9, 2
    bool x = flags & MEMPROT_OP_EXEC;
42003513:	480c      	movi.n	a8, 4
    bool w = flags & MEMPROT_OP_WRITE;
42003515:	160c      	movi.n	a6, 1
42003517:	107390        	and	a7, a3, a9
4200351a:	05bd      	mov.n	a11, a5
    bool x = flags & MEMPROT_OP_EXEC;
4200351c:	108380        	and	a8, a3, a8
4200351f:	05cd      	mov.n	a12, a5
    bool w = flags & MEMPROT_OP_WRITE;
42003521:	93b670        	movnez	a11, a6, a7
    bool x = flags & MEMPROT_OP_EXEC;
42003524:	93c680        	movnez	a12, a6, a8
    bool w = flags & MEMPROT_OP_WRITE;
42003527:	74b0b0        	extui	a11, a11, 0, 8
    bool x = flags & MEMPROT_OP_EXEC;
4200352a:	74c0c0        	extui	a12, a12, 0, 8
    switch (area_type) {
4200352d:	02d266        	bnei	a2, 64, 42003533 <esp_mprot_set_pms_area+0x27>
42003530:	006e06        	j	420036ec <esp_mprot_set_pms_area+0x1e0>
42003533:	0a4c      	movi.n	a10, 64
42003535:	533a27        	bltu	a10, a2, 4200358c <esp_mprot_set_pms_area+0x80>
42003538:	028266        	bnei	a2, 8, 4200353e <esp_mprot_set_pms_area+0x32>
4200353b:	005a46        	j	420036a8 <esp_mprot_set_pms_area+0x19c>
4200353e:	840c      	movi.n	a4, 8
42003540:	183427        	bltu	a4, a2, 4200355c <esp_mprot_set_pms_area+0x50>
42003543:	029297        	bne	a2, a9, 42003549 <esp_mprot_set_pms_area+0x3d>
42003546:	004486        	j	4200365c <esp_mprot_set_pms_area+0x150>
42003549:	024266        	bnei	a2, 4, 4200354f <esp_mprot_set_pms_area+0x43>
4200354c:	004e06        	j	42003688 <esp_mprot_set_pms_area+0x17c>
4200354f:	029267        	bne	a2, a6, 42003555 <esp_mprot_set_pms_area+0x49>
42003552:	0037c6        	j	42003635 <esp_mprot_set_pms_area+0x129>
42003555:	06a1a2        	movi	a10, 0x106
}
42003558:	0a2d      	mov.n	a2, a10
4200355a:	f01d      	retw.n
    switch (area_type) {
4200355c:	02b266        	bnei	a2, 16, 42003562 <esp_mprot_set_pms_area+0x56>
4200355f:	005946        	j	420036c8 <esp_mprot_set_pms_area+0x1bc>
42003562:	efc266        	bnei	a2, 32, 42003555 <esp_mprot_set_pms_area+0x49>
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
42003565:	f3dc41        	l32r	a4, 420004d8 <_stext+0x4b8>
42003568:	357c      	movi.n	a5, -13
4200356a:	0020c0        	memw
4200356d:	002422        	l32i	a2, a4, 0
42003570:	043030        	extui	a3, a3, 0, 1
42003573:	102250        	and	a2, a2, a5
    if (w) {
42003576:	002716        	beqz	a7, 4200357c <esp_mprot_set_pms_area+0x70>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003579:	203390        	or	a3, a3, a9
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
4200357c:	1133e0        	slli	a3, a3, 2
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
4200357f:	203320        	or	a3, a3, a2
42003582:	0020c0        	memw
42003585:	0439      	s32i.n	a3, a4, 0
42003587:	005686        	j	420036e5 <esp_mprot_set_pms_area+0x1d9>
4200358a:	00          	.byte 00
4200358b:	00          	.byte 00
4200358c:	00a2a2        	movi	a10, 0x200
4200358f:	0292a7        	bne	a2, a10, 42003595 <esp_mprot_set_pms_area+0x89>
42003592:	006406        	j	42003726 <esp_mprot_set_pms_area+0x21a>
42003595:	683a27        	bltu	a10, a2, 42003601 <esp_mprot_set_pms_area+0xf5>
42003598:	02e266        	bnei	a2, 128, 4200359e <esp_mprot_set_pms_area+0x92>
4200359b:	005ac6        	j	4200370a <esp_mprot_set_pms_area+0x1fe>
4200359e:	b3f266        	bnei	a2, 0x100, 42003555 <esp_mprot_set_pms_area+0x49>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420035a1:	20a440        	or	a10, a4, a4
420035a4:	006182        	s32i	a8, a1, 0
420035a7:	016192        	s32i	a9, a1, 4
420035aa:	ffdda5        	call8	42003384 <esp_mprot_cpuid_valid>
420035ad:	0188      	l32i.n	a8, a1, 0
420035af:	1198      	l32i.n	a9, a1, 4
420035b1:	fa3a56        	bnez	a10, 42003558 <esp_mprot_set_pms_area+0x4c>
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
420035b4:	0224b6        	bltui	a4, 2, 420035ba <esp_mprot_set_pms_area+0xae>
420035b7:	006f46        	j	42003778 <esp_mprot_set_pms_area+0x26c>
    if (r) {
420035ba:	333a      	add.n	a3, a3, a3
420035bc:	103390        	and	a3, a3, a9
    if (w) {
420035bf:	002716        	beqz	a7, 420035c5 <esp_mprot_set_pms_area+0xb9>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
420035c2:	203360        	or	a3, a3, a6
    if (x) {
420035c5:	005816        	beqz	a8, 420035ce <esp_mprot_set_pms_area+0xc2>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
420035c8:	04a022        	movi	a2, 4
420035cb:	203320        	or	a3, a3, a2
    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
420035ce:	f3be21        	l32r	a2, 420004c8 <_stext+0x4a8>
420035d1:	002416        	beqz	a4, 420035d7 <esp_mprot_set_pms_area+0xcb>
420035d4:	f3be21        	l32r	a2, 420004cc <_stext+0x4ac>
    CLEAR_PERI_REG_MASK(reg, mask);
420035d7:	0020c0        	memw
420035da:	0248      	l32i.n	a4, a2, 0
420035dc:	857c      	movi.n	a5, -8
420035de:	104450        	and	a4, a4, a5
420035e1:	0020c0        	memw
420035e4:	0249      	s32i.n	a4, a2, 0
    REG_SET_BITS(reg, bits, mask);
420035e6:	0020c0        	memw
420035e9:	0248      	l32i.n	a4, a2, 0
420035eb:	303430        	xor	a3, a4, a3
420035ee:	243030        	extui	a3, a3, 0, 3
420035f1:	303340        	xor	a3, a3, a4
420035f4:	0020c0        	memw
420035f7:	0239      	s32i.n	a3, a2, 0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_pms_area(core, r, w, x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
420035f9:	00da25        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
420035fc:	ffd606        	j	42003558 <esp_mprot_set_pms_area+0x4c>
420035ff:	00          	.byte 00
42003600:	00          	.byte 00
    switch (area_type) {
42003601:	00a442        	movi	a4, 0x400
42003604:	029247        	bne	a2, a4, 4200360a <esp_mprot_set_pms_area+0xfe>
42003607:	005c86        	j	4200377d <esp_mprot_set_pms_area+0x271>
4200360a:	116650        	slli	a6, a6, 11
4200360d:	021267        	beq	a2, a6, 42003613 <esp_mprot_set_pms_area+0x107>
42003610:	ffd046        	j	42003555 <esp_mprot_set_pms_area+0x49>
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003613:	04a030        	extui	a10, a3, 0, 1
42003616:	148ea5        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003619:	f3ad21        	l32r	a2, 420004d0 <_stext+0x4b0>
4200361c:	730c      	movi.n	a3, 7
4200361e:	113310        	slli	a3, a3, 15
42003621:	11aa10        	slli	a10, a10, 15
42003624:	10aa30        	and	a10, a10, a3
42003627:	0020c0        	memw
4200362a:	0248      	l32i.n	a4, a2, 0
4200362c:	f3ad31        	l32r	a3, 420004e0 <_stext+0x4c0>
4200362f:	001106        	j	42003677 <esp_mprot_set_pms_area+0x16b>
42003632:	00          	.byte 00
42003633:	00          	.byte 00
42003634:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003635:	f3a641        	l32r	a4, 420004d0 <_stext+0x4b0>
42003638:	04a030        	extui	a10, a3, 0, 1
4200363b:	0020c0        	memw
4200363e:	002422        	l32i	a2, a4, 0
42003641:	148be5        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003644:	f8af32        	movi	a3, -8
42003647:	102230        	and	a2, a2, a3
4200364a:	24a0a0        	extui	a10, a10, 0, 3
4200364d:	2022a0        	or	a2, a2, a10
42003650:	0020c0        	memw
42003653:	006422        	s32i	a2, a4, 0
    return ESP_OK;
42003656:	05ad      	mov.n	a10, a5
}
42003658:	ffbf06        	j	42003558 <esp_mprot_set_pms_area+0x4c>
4200365b:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
4200365c:	04a030        	extui	a10, a3, 0, 1
4200365f:	f39c21        	l32r	a2, 420004d0 <_stext+0x4b0>
42003662:	1489e5        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003665:	38a032        	movi	a3, 56
42003668:	11aad0        	slli	a10, a10, 3
4200366b:	0020c0        	memw
4200366e:	002242        	l32i	a4, a2, 0
42003671:	10aa30        	and	a10, a10, a3
42003674:	c7af32        	movi	a3, -57
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003677:	104430        	and	a4, a4, a3
4200367a:	20aa40        	or	a10, a10, a4
4200367d:	0020c0        	memw
42003680:	0062a2        	s32i	a10, a2, 0
42003683:	fff3c6        	j	42003656 <esp_mprot_set_pms_area+0x14a>
42003686:	00          	.byte 00
42003687:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003688:	04a030        	extui	a10, a3, 0, 1
4200368b:	f39121        	l32r	a2, 420004d0 <_stext+0x4b0>
4200368e:	148725        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003691:	c0a132        	movi	a3, 0x1c0
42003694:	11aaa0        	slli	a10, a10, 6
42003697:	10aa30        	and	a10, a10, a3
4200369a:	0020c0        	memw
4200369d:	0248      	l32i.n	a4, a2, 0
4200369f:	3fae32        	movi	a3, 0xfffffe3f
420036a2:	fff446        	j	42003677 <esp_mprot_set_pms_area+0x16b>
420036a5:	00          	.byte 00
420036a6:	00          	.byte 00
420036a7:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
420036a8:	04a030        	extui	a10, a3, 0, 1
420036ab:	148565        	call8	42017f00 <memprot_ll_icache_set_permissions>
420036ae:	f38821        	l32r	a2, 420004d0 <_stext+0x4b0>
420036b1:	730c      	movi.n	a3, 7
420036b3:	113370        	slli	a3, a3, 9
420036b6:	11aa70        	slli	a10, a10, 9
420036b9:	10aa30        	and	a10, a10, a3
420036bc:	0020c0        	memw
420036bf:	0248      	l32i.n	a4, a2, 0
420036c1:	f38431        	l32r	a3, 420004d4 <_stext+0x4b4>
420036c4:	ffebc6        	j	42003677 <esp_mprot_set_pms_area+0x16b>
420036c7:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420036c8:	f38441        	l32r	a4, 420004d8 <_stext+0x4b8>
420036cb:	c57c      	movi.n	a5, -4
420036cd:	0020c0        	memw
420036d0:	0428      	l32i.n	a2, a4, 0
420036d2:	043030        	extui	a3, a3, 0, 1
420036d5:	102250        	and	a2, a2, a5
    if (w) {
420036d8:	178c      	beqz.n	a7, 420036dd <esp_mprot_set_pms_area+0x1d1>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420036da:	203390        	or	a3, a3, a9
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
420036dd:	202230        	or	a2, a2, a3
420036e0:	0020c0        	memw
420036e3:	0429      	s32i.n	a2, a4, 0
420036e5:	0a0c      	movi.n	a10, 0
}
420036e7:	ff9b46        	j	42003558 <esp_mprot_set_pms_area+0x4c>
420036ea:	00          	.byte 00
420036eb:	00          	.byte 00
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
420036ec:	f37b41        	l32r	a4, 420004d8 <_stext+0x4b8>
420036ef:	cfaf52        	movi	a5, -49
420036f2:	0020c0        	memw
420036f5:	002422        	l32i	a2, a4, 0
420036f8:	043030        	extui	a3, a3, 0, 1
420036fb:	102250        	and	a2, a2, a5
    if (w) {
420036fe:	002716        	beqz	a7, 42003704 <esp_mprot_set_pms_area+0x1f8>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003701:	203390        	or	a3, a3, a9
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42003704:	1133c0        	slli	a3, a3, 4
42003707:	ff9d06        	j	4200357f <esp_mprot_set_pms_area+0x73>
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
4200370a:	f37341        	l32r	a4, 420004d8 <_stext+0x4b8>
4200370d:	3faf52        	movi	a5, -193
42003710:	0020c0        	memw
42003713:	0428      	l32i.n	a2, a4, 0
42003715:	043030        	extui	a3, a3, 0, 1
42003718:	102250        	and	a2, a2, a5
    if (w) {
4200371b:	178c      	beqz.n	a7, 42003720 <esp_mprot_set_pms_area+0x214>
        permissions |= SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
4200371d:	203390        	or	a3, a3, a9
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
42003720:	1133a0        	slli	a3, a3, 6
42003723:	ff9606        	j	4200357f <esp_mprot_set_pms_area+0x73>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003726:	20a440        	or	a10, a4, a4
42003729:	006182        	s32i	a8, a1, 0
4200372c:	016192        	s32i	a9, a1, 4
4200372f:	ffc565        	call8	42003384 <esp_mprot_cpuid_valid>
42003732:	0188      	l32i.n	a8, a1, 0
42003734:	1198      	l32i.n	a9, a1, 4
42003736:	e1ea56        	bnez	a10, 42003558 <esp_mprot_set_pms_area+0x4c>
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42003739:	3b24f6        	bgeui	a4, 2, 42003778 <esp_mprot_set_pms_area+0x26c>
    if (r) {
4200373c:	333a      	add.n	a3, a3, a3
4200373e:	103390        	and	a3, a3, a9
    if (w) {
42003741:	178c      	beqz.n	a7, 42003746 <esp_mprot_set_pms_area+0x23a>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42003743:	203360        	or	a3, a3, a6
    if (x) {
42003746:	388c      	beqz.n	a8, 4200374d <esp_mprot_set_pms_area+0x241>
        permissions |= SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42003748:	420c      	movi.n	a2, 4
4200374a:	203320        	or	a3, a3, a2
    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
4200374d:	f35e21        	l32r	a2, 420004c8 <_stext+0x4a8>
            bits = memprot_ll_rtcfast_set_permissions(r, w, x) << (core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H_S);
42003750:	1133d0        	slli	a3, a3, 3
    uint32_t reg = core == PRO_CPU_NUM ? SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG : SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG;
42003753:	148c      	beqz.n	a4, 42003758 <esp_mprot_set_pms_area+0x24c>
42003755:	f35d21        	l32r	a2, 420004cc <_stext+0x4ac>
    CLEAR_PERI_REG_MASK(reg, mask);
42003758:	0020c0        	memw
4200375b:	0248      	l32i.n	a4, a2, 0
4200375d:	c7af52        	movi	a5, -57
42003760:	104450        	and	a4, a4, a5
42003763:	0020c0        	memw
42003766:	0249      	s32i.n	a4, a2, 0
    REG_SET_BITS(reg, bits, mask);
42003768:	0020c0        	memw
4200376b:	0248      	l32i.n	a4, a2, 0
4200376d:	853c      	movi.n	a5, 56
4200376f:	303340        	xor	a3, a3, a4
42003772:	103350        	and	a3, a3, a5
42003775:	ff9e06        	j	420035f1 <esp_mprot_set_pms_area+0xe5>
        return MEMP_HAL_ERR_CORE_INVALID;
42003778:	7a0c      	movi.n	a10, 7
4200377a:	ff9ec6        	j	420035f9 <esp_mprot_set_pms_area+0xed>
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
4200377d:	04a030        	extui	a10, a3, 0, 1
42003780:	1477e5        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003783:	f35321        	l32r	a2, 420004d0 <_stext+0x4b0>
42003786:	730c      	movi.n	a3, 7
42003788:	113340        	slli	a3, a3, 12
4200378b:	11aa40        	slli	a10, a10, 12
4200378e:	10aa30        	and	a10, a10, a3
42003791:	0020c0        	memw
42003794:	0248      	l32i.n	a4, a2, 0
42003796:	f35131        	l32r	a3, 420004dc <_stext+0x4bc>
42003799:	ffb686        	j	42003677 <esp_mprot_set_pms_area+0x16b>

4200379c <esp_mprot_get_pms_area>:
{
4200379c:	004136        	entry	a1, 32
        return ESP_ERR_INVALID_ARG;
4200379f:	02a1a2        	movi	a10, 0x102
    if (flags == NULL) {
420037a2:	a3ac      	beqz.n	a3, 420037d0 <esp_mprot_get_pms_area+0x34>
    switch (area_type) {
420037a4:	02d266        	bnei	a2, 64, 420037aa <esp_mprot_get_pms_area+0xe>
420037a7:	004b46        	j	420038d8 <esp_mprot_get_pms_area+0x13c>
420037aa:	054c      	movi.n	a5, 64
420037ac:	403527        	bltu	a5, a2, 420037f0 <esp_mprot_get_pms_area+0x54>
420037af:	028266        	bnei	a2, 8, 420037b5 <esp_mprot_get_pms_area+0x19>
420037b2:	003e86        	j	420038b0 <esp_mprot_get_pms_area+0x114>
420037b5:	08a042        	movi	a4, 8
420037b8:	183427        	bltu	a4, a2, 420037d4 <esp_mprot_get_pms_area+0x38>
420037bb:	022266        	bnei	a2, 2, 420037c1 <esp_mprot_get_pms_area+0x25>
420037be:	003186        	j	42003888 <esp_mprot_get_pms_area+0xec>
420037c1:	024266        	bnei	a2, 4, 420037c7 <esp_mprot_get_pms_area+0x2b>
420037c4:	003506        	j	4200389c <esp_mprot_get_pms_area+0x100>
420037c7:	021266        	bnei	a2, 1, 420037cd <esp_mprot_get_pms_area+0x31>
420037ca:	002386        	j	4200385c <esp_mprot_get_pms_area+0xc0>
420037cd:	f336a1        	l32r	a10, 420004a8 <_stext+0x488>
}
420037d0:	0a2d      	mov.n	a2, a10
420037d2:	f01d      	retw.n
    switch (area_type) {
420037d4:	02b266        	bnei	a2, 16, 420037da <esp_mprot_get_pms_area+0x3e>
420037d7:	003a46        	j	420038c4 <esp_mprot_get_pms_area+0x128>
420037da:	efc266        	bnei	a2, 32, 420037cd <esp_mprot_get_pms_area+0x31>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
420037dd:	f33e21        	l32r	a2, 420004d8 <_stext+0x4b8>
420037e0:	0020c0        	memw
420037e3:	0258      	l32i.n	a5, a2, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420037e5:	046250        	extui	a6, a5, 2, 1
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420037e8:	045350        	extui	a5, a5, 3, 1
420037eb:	0038c6        	j	420038d2 <esp_mprot_get_pms_area+0x136>
420037ee:	00          	.byte 00
420037ef:	00          	.byte 00
420037f0:	00a252        	movi	a5, 0x200
420037f3:	029257        	bne	a2, a5, 420037f9 <esp_mprot_get_pms_area+0x5d>
420037f6:	004406        	j	4200390a <esp_mprot_get_pms_area+0x16e>
420037f9:	383527        	bltu	a5, a2, 42003835 <esp_mprot_get_pms_area+0x99>
420037fc:	02e266        	bnei	a2, 128, 42003802 <esp_mprot_get_pms_area+0x66>
420037ff:	003986        	j	420038e9 <esp_mprot_get_pms_area+0x14d>
42003802:	c7f266        	bnei	a2, 0x100, 420037cd <esp_mprot_get_pms_area+0x31>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003805:	20a440        	or	a10, a4, a4
42003808:	ffb7a5        	call8	42003384 <esp_mprot_cpuid_valid>
4200380b:	fc1a56        	bnez	a10, 420037d0 <esp_mprot_get_pms_area+0x34>
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
4200380e:	0224b6        	bltui	a4, 2, 42003814 <esp_mprot_get_pms_area+0x78>
42003811:	0044c6        	j	42003928 <esp_mprot_get_pms_area+0x18c>
            if (core == PRO_CPU_NUM) {
42003814:	0e4456        	bnez	a4, 420038fc <esp_mprot_get_pms_area+0x160>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L);
42003817:	f32c21        	l32r	a2, 420004c8 <_stext+0x4a8>
4200381a:	0020c0        	memw
4200381d:	002242        	l32i	a4, a2, 0
42003820:	244040        	extui	a4, a4, 0, 3
    *r = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_R;
42003823:	046140        	extui	a6, a4, 1, 1
    *w = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_W;
42003826:	045040        	extui	a5, a4, 0, 1
    *x = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_F;
42003829:	414240        	srli	a4, a4, 2
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_pms_area(core, &r, &w, &x, MEMP_HAL_WORLD_0, MEMP_HAL_AREA_HIGH)))
4200382c:	00b6e5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
4200382f:	03aa16        	beqz	a10, 4200386d <esp_mprot_get_pms_area+0xd1>
42003832:	ffe686        	j	420037d0 <esp_mprot_get_pms_area+0x34>
    switch (area_type) {
42003835:	00a442        	movi	a4, 0x400
42003838:	029247        	bne	a2, a4, 4200383e <esp_mprot_get_pms_area+0xa2>
4200383b:	003d46        	j	42003934 <esp_mprot_get_pms_area+0x198>
4200383e:	140c      	movi.n	a4, 1
42003840:	114450        	slli	a4, a4, 11
42003843:	869247        	bne	a2, a4, 420037cd <esp_mprot_get_pms_area+0x31>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1);
42003846:	f32221        	l32r	a2, 420004d0 <_stext+0x4b0>
42003849:	0020c0        	memw
4200384c:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
4200384e:	046f40        	extui	a6, a4, 15, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003851:	055040        	extui	a5, a4, 16, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003854:	054140        	extui	a4, a4, 17, 1
}
42003857:	000486        	j	4200386d <esp_mprot_get_pms_area+0xd1>
4200385a:	00          	.byte 00
4200385b:	00          	.byte 00
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
4200385c:	f31d21        	l32r	a2, 420004d0 <_stext+0x4b0>
4200385f:	0020c0        	memw
42003862:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003864:	046040        	extui	a6, a4, 0, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003867:	045140        	extui	a5, a4, 1, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
4200386a:	044240        	extui	a4, a4, 2, 1
    if (w) {
4200386d:	0d7556        	bnez	a5, 42003948 <esp_mprot_get_pms_area+0x1ac>
        *flags |= MEMPROT_OP_WRITE;
42003870:	0369      	s32i.n	a6, a3, 0
    return ESP_OK;
42003872:	0a0c      	movi.n	a10, 0
    if (x) {
42003874:	0294a7        	bne	a4, a10, 4200387a <esp_mprot_get_pms_area+0xde>
42003877:	ffd546        	j	420037d0 <esp_mprot_get_pms_area+0x34>
        *flags |= MEMPROT_OP_EXEC;
4200387a:	0328      	l32i.n	a2, a3, 0
4200387c:	440c      	movi.n	a4, 4
4200387e:	202240        	or	a2, a2, a4
42003881:	0329      	s32i.n	a2, a3, 0
42003883:	ffd246        	j	420037d0 <esp_mprot_get_pms_area+0x34>
42003886:	00          	.byte 00
42003887:	00          	.byte 00
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1);
42003888:	f31221        	l32r	a2, 420004d0 <_stext+0x4b0>
4200388b:	0020c0        	memw
4200388e:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
42003890:	046340        	extui	a6, a4, 3, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42003893:	045440        	extui	a5, a4, 4, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003896:	044540        	extui	a4, a4, 5, 1
}
42003899:	fff406        	j	4200386d <esp_mprot_get_pms_area+0xd1>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
4200389c:	f30d21        	l32r	a2, 420004d0 <_stext+0x4b0>
4200389f:	0020c0        	memw
420038a2:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420038a4:	046640        	extui	a6, a4, 6, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420038a7:	045740        	extui	a5, a4, 7, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
420038aa:	044840        	extui	a4, a4, 8, 1
}
420038ad:	ffef06        	j	4200386d <esp_mprot_get_pms_area+0xd1>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
420038b0:	f30821        	l32r	a2, 420004d0 <_stext+0x4b0>
420038b3:	0020c0        	memw
420038b6:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420038b8:	046940        	extui	a6, a4, 9, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420038bb:	045a40        	extui	a5, a4, 10, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
420038be:	044b40        	extui	a4, a4, 11, 1
}
420038c1:	ffea06        	j	4200386d <esp_mprot_get_pms_area+0xd1>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0);
420038c4:	f30521        	l32r	a2, 420004d8 <_stext+0x4b8>
420038c7:	0020c0        	memw
420038ca:	0258      	l32i.n	a5, a2, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420038cc:	046050        	extui	a6, a5, 0, 1
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420038cf:	045150        	extui	a5, a5, 1, 1
    bool x = false;
420038d2:	040c      	movi.n	a4, 0
}
420038d4:	ffe546        	j	4200386d <esp_mprot_get_pms_area+0xd1>
420038d7:	00          	.byte 00
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2);
420038d8:	f30021        	l32r	a2, 420004d8 <_stext+0x4b8>
420038db:	0020c0        	memw
420038de:	0258      	l32i.n	a5, a2, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420038e0:	046450        	extui	a6, a5, 4, 1
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420038e3:	045550        	extui	a5, a5, 5, 1
420038e6:	fffa06        	j	420038d2 <esp_mprot_get_pms_area+0x136>
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3);
420038e9:	f2fb21        	l32r	a2, 420004d8 <_stext+0x4b8>
420038ec:	0020c0        	memw
420038ef:	0258      	l32i.n	a5, a2, 0
    *r = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_R;
420038f1:	046650        	extui	a6, a5, 6, 1
    *w = perms & SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_X_W;
420038f4:	045750        	extui	a5, a5, 7, 1
420038f7:	fff5c6        	j	420038d2 <esp_mprot_get_pms_area+0x136>
420038fa:	00          	.byte 00
420038fb:	00          	.byte 00
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L);
420038fc:	f2f421        	l32r	a2, 420004cc <_stext+0x4ac>
420038ff:	0020c0        	memw
42003902:	0248      	l32i.n	a4, a2, 0
42003904:	244640        	extui	a4, a4, 6, 3
    *r = perms & SENSITIVE_CORE_X_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_X_R;
42003907:	ffc606        	j	42003823 <esp_mprot_get_pms_area+0x87>
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
4200390a:	04ad      	mov.n	a10, a4
4200390c:	ffa765        	call8	42003384 <esp_mprot_cpuid_valid>
4200390f:	ebda56        	bnez	a10, 420037d0 <esp_mprot_get_pms_area+0x34>
    if (core != PRO_CPU_NUM && core != APP_CPU_NUM) {
42003912:	1224f6        	bgeui	a4, 2, 42003928 <esp_mprot_get_pms_area+0x18c>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
42003915:	f2ec21        	l32r	a2, 420004c8 <_stext+0x4a8>
            if (core == PRO_CPU_NUM) {
42003918:	148c      	beqz.n	a4, 4200391d <esp_mprot_get_pms_area+0x181>
                permissions = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_10_REG, SENSITIVE_CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H);
4200391a:	f2ec21        	l32r	a2, 420004cc <_stext+0x4ac>
4200391d:	0020c0        	memw
42003920:	0248      	l32i.n	a4, a2, 0
42003922:	244340        	extui	a4, a4, 3, 3
42003925:	ffbe86        	j	42003823 <esp_mprot_get_pms_area+0x87>
    bool x = false;
42003928:	0a4d      	mov.n	a4, a10
    bool w = false;
4200392a:	0a5d      	mov.n	a5, a10
    bool r = false;
4200392c:	0a6d      	mov.n	a6, a10
        return MEMP_HAL_ERR_CORE_INVALID;
4200392e:	7a0c      	movi.n	a10, 7
42003930:	ffbe06        	j	4200382c <esp_mprot_get_pms_area+0x90>
42003933:	00          	.byte 00
    uint32_t permissions = REG_GET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0);
42003934:	f2e721        	l32r	a2, 420004d0 <_stext+0x4b0>
42003937:	0020c0        	memw
4200393a:	0248      	l32i.n	a4, a2, 0
    *r = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_R;
4200393c:	046c40        	extui	a6, a4, 12, 1
    *w = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
4200393f:	045d40        	extui	a5, a4, 13, 1
    *x = perms & SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42003942:	044e40        	extui	a4, a4, 14, 1
}
42003945:	ffc906        	j	4200386d <esp_mprot_get_pms_area+0xd1>
        *flags |= MEMPROT_OP_WRITE;
42003948:	220c      	movi.n	a2, 2
4200394a:	206620        	or	a6, a6, a2
4200394d:	ffc7c6        	j	42003870 <esp_mprot_get_pms_area+0xd4>

42003950 <esp_mprot_set_monitor_lock>:
{
42003950:	004136        	entry	a1, 32
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003953:	03ad      	mov.n	a10, a3
42003955:	ffa2e5        	call8	42003384 <esp_mprot_cpuid_valid>
42003958:	cadc      	bnez.n	a10, 42003978 <esp_mprot_set_monitor_lock+0x28>
    switch (mem_type) {
4200395a:	2a2226        	beqi	a2, 2, 42003988 <esp_mprot_set_monitor_lock+0x38>
4200395d:	3b4226        	beqi	a2, 4, 4200399c <esp_mprot_set_monitor_lock+0x4c>
42003960:	4c1266        	bnei	a2, 1, 420039b0 <esp_mprot_set_monitor_lock+0x60>
    switch (core) {
42003963:	638c      	beqz.n	a3, 4200396d <esp_mprot_set_monitor_lock+0x1d>
42003965:	131326        	beqi	a3, 1, 4200397c <esp_mprot_set_monitor_lock+0x2c>
    switch (core) {
42003968:	7a0c      	movi.n	a10, 7
4200396a:	0001c6        	j	42003975 <esp_mprot_set_monitor_lock+0x25>
            REG_WRITE(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG, 1);
4200396d:	f2dd31        	l32r	a3, 420004e4 <_stext+0x4c4>
42003970:	0020c0        	memw
42003973:	0329      	s32i.n	a2, a3, 0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_lock(core)))
42003975:	00a265        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
42003978:	0a2d      	mov.n	a2, a10
4200397a:	f01d      	retw.n
            REG_WRITE(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG, 1);
4200397c:	f2db21        	l32r	a2, 420004e8 <_stext+0x4c8>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG, 1);
4200397f:	0020c0        	memw
42003982:	0239      	s32i.n	a3, a2, 0
            break;
42003984:	fffb46        	j	42003975 <esp_mprot_set_monitor_lock+0x25>
42003987:	00          	.byte 00
    switch (core) {
42003988:	838c      	beqz.n	a3, 42003994 <esp_mprot_set_monitor_lock+0x44>
4200398a:	da1366        	bnei	a3, 1, 42003968 <esp_mprot_set_monitor_lock+0x18>
            REG_WRITE(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG, 1);
4200398d:	f2d821        	l32r	a2, 420004f0 <_stext+0x4d0>
42003990:	fffac6        	j	4200397f <esp_mprot_set_monitor_lock+0x2f>
42003993:	00          	.byte 00
            REG_WRITE(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG, 1);
42003994:	f2d621        	l32r	a2, 420004ec <_stext+0x4cc>
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG, 1);
42003997:	130c      	movi.n	a3, 1
42003999:	fff886        	j	4200397f <esp_mprot_set_monitor_lock+0x2f>
    switch (core) {
4200399c:	838c      	beqz.n	a3, 420039a8 <esp_mprot_set_monitor_lock+0x58>
4200399e:	c61366        	bnei	a3, 1, 42003968 <esp_mprot_set_monitor_lock+0x18>
            REG_WRITE(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG, 1);
420039a1:	f2d521        	l32r	a2, 420004f8 <_stext+0x4d8>
420039a4:	fff5c6        	j	4200397f <esp_mprot_set_monitor_lock+0x2f>
420039a7:	00          	.byte 00
            REG_WRITE(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG, 1);
420039a8:	f2d321        	l32r	a2, 420004f4 <_stext+0x4d4>
420039ab:	fffa06        	j	42003997 <esp_mprot_set_monitor_lock+0x47>
420039ae:	00          	.byte 00
420039af:	00          	.byte 00
    switch (mem_type) {
420039b0:	f2bea1        	l32r	a10, 420004a8 <_stext+0x488>
420039b3:	fff046        	j	42003978 <esp_mprot_set_monitor_lock+0x28>
	...

420039b8 <esp_mprot_get_monitor_lock>:
{
420039b8:	004136        	entry	a1, 32
        return ESP_ERR_INVALID_ARG;
420039bb:	02a1a2        	movi	a10, 0x102
    if (locked == NULL) {
420039be:	01c316        	beqz	a3, 420039de <esp_mprot_get_monitor_lock+0x26>
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
420039c1:	20a440        	or	a10, a4, a4
420039c4:	ff9be5        	call8	42003384 <esp_mprot_cpuid_valid>
420039c7:	013a56        	bnez	a10, 420039de <esp_mprot_get_monitor_lock+0x26>
    switch (mem_type) {
420039ca:	3e2226        	beqi	a2, 2, 42003a0c <esp_mprot_get_monitor_lock+0x54>
420039cd:	564226        	beqi	a2, 4, 42003a27 <esp_mprot_get_monitor_lock+0x6f>
420039d0:	681266        	bnei	a2, 1, 42003a3c <esp_mprot_get_monitor_lock+0x84>
    switch (core) {
420039d3:	d48c      	beqz.n	a4, 420039e4 <esp_mprot_get_monitor_lock+0x2c>
420039d5:	1f1426        	beqi	a4, 1, 420039f8 <esp_mprot_get_monitor_lock+0x40>
    switch (core) {
420039d8:	07a0a2        	movi	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_lock(core, locked)))
420039db:	009c25        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
420039de:	202aa0        	or	a2, a10, a10
420039e1:	000090        	retw
            *locked = REG_READ(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG) == 1;
420039e4:	f2c041        	l32r	a4, 420004e4 <_stext+0x4c4>
420039e7:	0020c0        	memw
420039ea:	0448      	l32i.n	a4, a4, 0
420039ec:	440b      	addi.n	a4, a4, -1
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
420039ee:	932a40        	movnez	a2, a10, a4
420039f1:	004322        	s8i	a2, a3, 0
            break;
420039f4:	fff8c6        	j	420039db <esp_mprot_get_monitor_lock+0x23>
420039f7:	00          	.byte 00
            *locked = REG_READ(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_0_REG) == 1;
420039f8:	f2bc21        	l32r	a2, 420004e8 <_stext+0x4c8>
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG) == 1;
420039fb:	0020c0        	memw
420039fe:	0228      	l32i.n	a2, a2, 0
42003a00:	220b      	addi.n	a2, a2, -1
42003a02:	934a20        	movnez	a4, a10, a2
42003a05:	004342        	s8i	a4, a3, 0
            break;
42003a08:	fff3c6        	j	420039db <esp_mprot_get_monitor_lock+0x23>
42003a0b:	00          	.byte 00
    switch (core) {
42003a0c:	848c      	beqz.n	a4, 42003a18 <esp_mprot_get_monitor_lock+0x60>
42003a0e:	c61466        	bnei	a4, 1, 420039d8 <esp_mprot_get_monitor_lock+0x20>
            *locked = REG_READ(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_0_REG) == 1;
42003a11:	f2b721        	l32r	a2, 420004f0 <_stext+0x4d0>
42003a14:	fff8c6        	j	420039fb <esp_mprot_get_monitor_lock+0x43>
42003a17:	00          	.byte 00
            *locked = REG_READ(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG) == 1;
42003a18:	f2b521        	l32r	a2, 420004ec <_stext+0x4cc>
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
42003a1b:	0020c0        	memw
42003a1e:	0248      	l32i.n	a4, a2, 0
42003a20:	120c      	movi.n	a2, 1
42003a22:	440b      	addi.n	a4, a4, -1
42003a24:	fff186        	j	420039ee <esp_mprot_get_monitor_lock+0x36>
    switch (core) {
42003a27:	948c      	beqz.n	a4, 42003a34 <esp_mprot_get_monitor_lock+0x7c>
42003a29:	ab1466        	bnei	a4, 1, 420039d8 <esp_mprot_get_monitor_lock+0x20>
            *locked = REG_READ(SENSITIVE_CORE_1_PIF_PMS_MONITOR_0_REG) == 1;
42003a2c:	f2b321        	l32r	a2, 420004f8 <_stext+0x4d8>
42003a2f:	fff206        	j	420039fb <esp_mprot_get_monitor_lock+0x43>
42003a32:	00          	.byte 00
42003a33:	00          	.byte 00
            *locked = REG_READ(SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG) == 1;
42003a34:	f2b021        	l32r	a2, 420004f4 <_stext+0x4d4>
42003a37:	fff806        	j	42003a1b <esp_mprot_get_monitor_lock+0x63>
42003a3a:	00          	.byte 00
42003a3b:	00          	.byte 00
    switch (mem_type) {
42003a3c:	f29ba1        	l32r	a10, 420004a8 <_stext+0x488>
42003a3f:	ffe6c6        	j	420039de <esp_mprot_get_monitor_lock+0x26>
	...

42003a44 <esp_mprot_set_monitor_en>:
{
42003a44:	004136        	entry	a1, 32
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003a47:	04ad      	mov.n	a10, a4
{
42003a49:	743030        	extui	a3, a3, 0, 8
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003a4c:	201110        	or	a1, a1, a1
42003a4f:	ff9365        	call8	42003384 <esp_mprot_cpuid_valid>
42003a52:	057a56        	bnez	a10, 42003aad <esp_mprot_set_monitor_en+0x69>
    switch (mem_type) {
42003a55:	312226        	beqi	a2, 2, 42003a8a <esp_mprot_set_monitor_en+0x46>
42003a58:	684226        	beqi	a2, 4, 42003ac4 <esp_mprot_set_monitor_en+0x80>
42003a5b:	021226        	beqi	a2, 1, 42003a61 <esp_mprot_set_monitor_en+0x1d>
42003a5e:	002086        	j	42003ae4 <esp_mprot_set_monitor_en+0xa0>
    switch (core) {
42003a61:	748c      	beqz.n	a4, 42003a6c <esp_mprot_set_monitor_en+0x28>
42003a63:	1d1426        	beqi	a4, 1, 42003a84 <esp_mprot_set_monitor_en+0x40>
    switch (core) {
42003a66:	7a0c      	movi.n	a10, 7
42003a68:	000f86        	j	42003aaa <esp_mprot_set_monitor_en+0x66>
42003a6b:	00          	.byte 00
            if (enable) {
42003a6c:	f2a421        	l32r	a2, 420004fc <_stext+0x4dc>
            if (enable) {
42003a6f:	063316        	beqz	a3, 42003ad6 <esp_mprot_set_monitor_en+0x92>
                REG_SET_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42003a72:	0020c0        	memw
42003a75:	0238      	l32i.n	a3, a2, 0
42003a77:	240c      	movi.n	a4, 2
42003a79:	203340        	or	a3, a3, a4
                REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42003a7c:	0020c0        	memw
42003a7f:	0239      	s32i.n	a3, a2, 0
42003a81:	000946        	j	42003aaa <esp_mprot_set_monitor_en+0x66>
            if (enable) {
42003a84:	f29f21        	l32r	a2, 42000500 <_stext+0x4e0>
42003a87:	fff906        	j	42003a6f <esp_mprot_set_monitor_en+0x2b>
    switch (core) {
42003a8a:	748c      	beqz.n	a4, 42003a95 <esp_mprot_set_monitor_en+0x51>
42003a8c:	d61466        	bnei	a4, 1, 42003a66 <esp_mprot_set_monitor_en+0x22>
            if (enable) {
42003a8f:	f29e41        	l32r	a4, 42000508 <_stext+0x4e8>
42003a92:	000086        	j	42003a98 <esp_mprot_set_monitor_en+0x54>
            if (enable) {
42003a95:	f29b41        	l32r	a4, 42000504 <_stext+0x4e4>
            if (enable) {
42003a98:	015316        	beqz	a3, 42003ab1 <esp_mprot_set_monitor_en+0x6d>
                REG_SET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
42003a9b:	0020c0        	memw
42003a9e:	002432        	l32i	a3, a4, 0
42003aa1:	203320        	or	a3, a3, a2
42003aa4:	0020c0        	memw
42003aa7:	006432        	s32i	a3, a4, 0
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_set_monitor_en(core, enable)))
42003aaa:	008f25        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
42003aad:	0a2d      	mov.n	a2, a10
42003aaf:	f01d      	retw.n
                REG_CLR_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN);
42003ab1:	0020c0        	memw
42003ab4:	0428      	l32i.n	a2, a4, 0
42003ab6:	d37c      	movi.n	a3, -3
42003ab8:	102230        	and	a2, a2, a3
42003abb:	0020c0        	memw
42003abe:	0429      	s32i.n	a2, a4, 0
42003ac0:	fff986        	j	42003aaa <esp_mprot_set_monitor_en+0x66>
42003ac3:	00          	.byte 00
    switch (core) {
42003ac4:	848c      	beqz.n	a4, 42003ad0 <esp_mprot_set_monitor_en+0x8c>
42003ac6:	9c1466        	bnei	a4, 1, 42003a66 <esp_mprot_set_monitor_en+0x22>
            if (enable) {
42003ac9:	f29121        	l32r	a2, 42000510 <_stext+0x4f0>
42003acc:	ffe7c6        	j	42003a6f <esp_mprot_set_monitor_en+0x2b>
42003acf:	00          	.byte 00
            if (enable) {
42003ad0:	f28f21        	l32r	a2, 4200050c <_stext+0x4ec>
42003ad3:	ffe606        	j	42003a6f <esp_mprot_set_monitor_en+0x2b>
                REG_CLR_BIT(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN);
42003ad6:	0020c0        	memw
42003ad9:	0238      	l32i.n	a3, a2, 0
42003adb:	d47c      	movi.n	a4, -3
42003add:	103340        	and	a3, a3, a4
42003ae0:	ffe606        	j	42003a7c <esp_mprot_set_monitor_en+0x38>
42003ae3:	00          	.byte 00
    switch (mem_type) {
42003ae4:	f271a1        	l32r	a10, 420004a8 <_stext+0x488>
42003ae7:	fff086        	j	42003aad <esp_mprot_set_monitor_en+0x69>
	...

42003aec <esp_mprot_get_monitor_en>:
{
42003aec:	004136        	entry	a1, 32
        return ESP_ERR_INVALID_ARG;
42003aef:	02a1a2        	movi	a10, 0x102
    if (enabled == NULL) {
42003af2:	01c316        	beqz	a3, 42003b12 <esp_mprot_get_monitor_en+0x26>
    ESP_MEMPROT_ERR_CHECK(err, esp_mprot_cpuid_valid(core))
42003af5:	20a440        	or	a10, a4, a4
42003af8:	ff88a5        	call8	42003384 <esp_mprot_cpuid_valid>
42003afb:	013a56        	bnez	a10, 42003b12 <esp_mprot_get_monitor_en+0x26>
    switch (mem_type) {
42003afe:	2e2226        	beqi	a2, 2, 42003b30 <esp_mprot_get_monitor_en+0x44>
42003b01:	3d4226        	beqi	a2, 4, 42003b42 <esp_mprot_get_monitor_en+0x56>
42003b04:	4c1266        	bnei	a2, 1, 42003b54 <esp_mprot_get_monitor_en+0x68>
    switch (core) {
42003b07:	d48c      	beqz.n	a4, 42003b18 <esp_mprot_get_monitor_en+0x2c>
42003b09:	1c1426        	beqi	a4, 1, 42003b29 <esp_mprot_get_monitor_en+0x3d>
    switch (core) {
42003b0c:	07a0a2        	movi	a10, 7
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_monitor_en(core, enabled)))
42003b0f:	0088e5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
}
42003b12:	202aa0        	or	a2, a10, a10
42003b15:	000090        	retw
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003b18:	f27921        	l32r	a2, 420004fc <_stext+0x4dc>
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42003b1b:	0020c0        	memw
42003b1e:	0248      	l32i.n	a4, a2, 0
42003b20:	044140        	extui	a4, a4, 1, 1
42003b23:	004342        	s8i	a4, a3, 0
            break;
42003b26:	fff946        	j	42003b0f <esp_mprot_get_monitor_en+0x23>
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN) == 1;
42003b29:	f27521        	l32r	a2, 42000500 <_stext+0x4e0>
42003b2c:	fffac6        	j	42003b1b <esp_mprot_get_monitor_en+0x2f>
42003b2f:	00          	.byte 00
    switch (core) {
42003b30:	848c      	beqz.n	a4, 42003b3c <esp_mprot_get_monitor_en+0x50>
42003b32:	d61466        	bnei	a4, 1, 42003b0c <esp_mprot_get_monitor_en+0x20>
            *enabled = REG_GET_BIT(SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42003b35:	f27421        	l32r	a2, 42000508 <_stext+0x4e8>
42003b38:	fff7c6        	j	42003b1b <esp_mprot_get_monitor_en+0x2f>
42003b3b:	00          	.byte 00
            *enabled = REG_GET_BIT(SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN) > 0;
42003b3c:	f27221        	l32r	a2, 42000504 <_stext+0x4e4>
42003b3f:	fff606        	j	42003b1b <esp_mprot_get_monitor_en+0x2f>
    switch (core) {
42003b42:	748c      	beqz.n	a4, 42003b4d <esp_mprot_get_monitor_en+0x61>
42003b44:	c41466        	bnei	a4, 1, 42003b0c <esp_mprot_get_monitor_en+0x20>
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_1_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_1_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42003b47:	f27221        	l32r	a2, 42000510 <_stext+0x4f0>
42003b4a:	fff346        	j	42003b1b <esp_mprot_get_monitor_en+0x2f>
            *enabled = REG_GET_FIELD(SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG, SENSITIVE_CORE_0_PIF_PMS_MONITOR_VIOLATE_EN) > 0;
42003b4d:	f26f21        	l32r	a2, 4200050c <_stext+0x4ec>
42003b50:	fff1c6        	j	42003b1b <esp_mprot_get_monitor_en+0x2f>
42003b53:	00          	.byte 00
    switch (mem_type) {
42003b54:	f255a1        	l32r	a10, 420004a8 <_stext+0x488>
42003b57:	ffedc6        	j	42003b12 <esp_mprot_get_monitor_en+0x26>
	...

42003b5c <esp_mprot_set_prot>:
}

//////////////////////////////////////////////////////////////////////////////
// convenient "public" APIs
esp_err_t esp_mprot_set_prot(const esp_memp_config_t *memp_config)
{
42003b5c:	00a136        	entry	a1, 80
    RER(reg, dcr);
42003b5f:	f18231        	l32r	a3, 42000168 <_stext+0x148>
42003b62:	406340        	rer	a4, a3
    //debugger connected:
    // 1.check the signal repeatedly to avoid possible glitching attempt
    // 2.leave the Memprot unset to allow debug operations

    if (esp_cpu_dbgr_is_attached()) {
42003b65:	686407        	bbci	a4, 0, 42003bd1 <esp_mprot_set_prot+0x75>
42003b68:	406330        	rer	a3, a3
        ESP_FAULT_ASSERT(esp_cpu_dbgr_is_attached());
42003b6b:	19e307        	bbsi	a3, 0, 42003b88 <esp_mprot_set_prot+0x2c>
42003b6e:	f26a21        	l32r	a2, 42000518 <_stext+0x4f8>
42003b71:	f26a31        	l32r	a3, 4200051c <_stext+0x4fc>
42003b74:	0020c0        	memw
42003b77:	006232        	s32i	a3, a2, 0
42003b7a:	f06d      	ill.n
42003b7c:	f06d      	ill.n
42003b7e:	f06d      	ill.n
42003b80:	f06d      	ill.n
42003b82:	f06d      	ill.n
42003b84:	f06d      	ill.n
42003b86:	f06d      	ill.n
42003b88:	f17821        	l32r	a2, 42000168 <_stext+0x148>
42003b8b:	406230        	rer	a3, a2
42003b8e:	18e307        	bbsi	a3, 0, 42003baa <esp_mprot_set_prot+0x4e>
42003b91:	f26131        	l32r	a3, 42000518 <_stext+0x4f8>
42003b94:	f26241        	l32r	a4, 4200051c <_stext+0x4fc>
42003b97:	0020c0        	memw
42003b9a:	0349      	s32i.n	a4, a3, 0
42003b9c:	f06d      	ill.n
42003b9e:	f06d      	ill.n
42003ba0:	f06d      	ill.n
42003ba2:	f06d      	ill.n
42003ba4:	f06d      	ill.n
42003ba6:	f06d      	ill.n
42003ba8:	f06d      	ill.n
42003baa:	406220        	rer	a2, a2
        return ESP_OK;
42003bad:	030c      	movi.n	a3, 0
        ESP_FAULT_ASSERT(esp_cpu_dbgr_is_attached());
42003baf:	19d237        	bbs	a2, a3, 42003bcc <esp_mprot_set_prot+0x70>
42003bb2:	f25921        	l32r	a2, 42000518 <_stext+0x4f8>
42003bb5:	f25941        	l32r	a4, 4200051c <_stext+0x4fc>
42003bb8:	0020c0        	memw
42003bbb:	006242        	s32i	a4, a2, 0
42003bbe:	f06d      	ill.n
42003bc0:	f06d      	ill.n
42003bc2:	f06d      	ill.n
42003bc4:	f06d      	ill.n
42003bc6:	f06d      	ill.n
42003bc8:	f06d      	ill.n
42003bca:	f06d      	ill.n
    if (ret == ESP_OK) {
        s_memp_cfg = *memp_config;
    }

    return ret;
}
42003bcc:	032d      	mov.n	a2, a3
42003bce:	f01d      	retw.n
42003bd0:	00          	.byte 00
    if (memp_config == NULL) {
42003bd1:	12cc      	bnez.n	a2, 42003bd6 <esp_mprot_set_prot+0x7a>
42003bd3:	01eb46        	j	42004384 <esp_mprot_set_prot+0x828>
    if (memp_config->mem_type_mask == MEMPROT_TYPE_NONE) {
42003bd6:	2268      	l32i.n	a6, a2, 8
42003bd8:	16cc      	bnez.n	a6, 42003bdd <esp_mprot_set_prot+0x81>
42003bda:	01eb86        	j	4200438c <esp_mprot_set_prot+0x830>
    if (memp_config->target_cpu_count < 1 || memp_config->target_cpu_count > portNUM_PROCESSORS) {
42003bdd:	3248      	l32i.n	a4, a2, 12
42003bdf:	340b      	addi.n	a3, a4, -1
42003be1:	0223b6        	bltui	a3, 2, 42003be7 <esp_mprot_set_prot+0x8b>
42003be4:	01eb06        	j	42004394 <esp_mprot_set_prot+0x838>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_cpuid_valid(memp_config->target_cpu[x]))
42003be7:	42a8      	l32i.n	a10, a2, 16
42003be9:	ff79a5        	call8	42003384 <esp_mprot_cpuid_valid>
42003bec:	0a3d      	mov.n	a3, a10
42003bee:	fdaa56        	bnez	a10, 42003bcc <esp_mprot_set_prot+0x70>
    for (size_t x = 0; x < core_count; x++) {
42003bf1:	072466        	bnei	a4, 2, 42003bfc <esp_mprot_set_prot+0xa0>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_cpuid_valid(memp_config->target_cpu[x]))
42003bf4:	52a8      	l32i.n	a10, a2, 20
42003bf6:	ff78e5        	call8	42003384 <esp_mprot_cpuid_valid>
42003bf9:	1f3a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
    bool use_dram0 = memp_config->mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM;
42003bfc:	250c      	movi.n	a5, 2
    bool use_iram0 = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_SRAM;
42003bfe:	047060        	extui	a7, a6, 0, 1
    bool use_dram0 = memp_config->mem_type_mask & MEMPROT_TYPE_DRAM0_SRAM;
42003c01:	105650        	and	a5, a6, a5
    if (use_iram0) {
42003c04:	37ac      	beqz.n	a7, 42003c2b <esp_mprot_set_prot+0xcf>
42003c06:	028d      	mov.n	a8, a2
42003c08:	a09420        	addx4	a9, a4, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, false, memp_config->target_cpu[x]))
42003c0b:	00a0d2        	movi	a13, 0
42003c0e:	48c8      	l32i.n	a12, a8, 16
42003c10:	0dbd      	mov.n	a11, a13
42003c12:	1a0c      	movi.n	a10, 1
42003c14:	9189      	s32i.n	a8, a1, 36
42003c16:	8199      	s32i.n	a9, a1, 32
42003c18:	71d9      	s32i.n	a13, a1, 28
42003c1a:	ffe2a5        	call8	42003a44 <esp_mprot_set_monitor_en>
42003c1d:	9188      	l32i.n	a8, a1, 36
42003c1f:	8198      	l32i.n	a9, a1, 32
42003c21:	71d8      	l32i.n	a13, a1, 28
42003c23:	1c9a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003c26:	884b      	addi.n	a8, a8, 4
42003c28:	e29987        	bne	a9, a8, 42003c0e <esp_mprot_set_prot+0xb2>
    if (use_dram0) {
42003c2b:	55ac      	beqz.n	a5, 42003c54 <esp_mprot_set_prot+0xf8>
42003c2d:	028d      	mov.n	a8, a2
42003c2f:	a09420        	addx4	a9, a4, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, false, memp_config->target_cpu[x]))
42003c32:	0d0c      	movi.n	a13, 0
42003c34:	0428c2        	l32i	a12, a8, 16
42003c37:	20bdd0        	or	a11, a13, a13
42003c3a:	02a0a2        	movi	a10, 2
42003c3d:	9189      	s32i.n	a8, a1, 36
42003c3f:	8199      	s32i.n	a9, a1, 32
42003c41:	71d9      	s32i.n	a13, a1, 28
42003c43:	ffe025        	call8	42003a44 <esp_mprot_set_monitor_en>
42003c46:	9188      	l32i.n	a8, a1, 36
42003c48:	8198      	l32i.n	a9, a1, 32
42003c4a:	71d8      	l32i.n	a13, a1, 28
42003c4c:	1a0a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003c4f:	884b      	addi.n	a8, a8, 4
42003c51:	df9897        	bne	a8, a9, 42003c34 <esp_mprot_set_prot+0xd8>
    bool use_rtcfast = memp_config->mem_type_mask & MEMPROT_TYPE_IRAM0_RTCFAST;
42003c54:	480c      	movi.n	a8, 4
42003c56:	108680        	and	a8, a6, a8
42003c59:	6189      	s32i.n	a8, a1, 24
    if (use_rtcfast) {
42003c5b:	58ac      	beqz.n	a8, 42003c84 <esp_mprot_set_prot+0x128>
42003c5d:	028d      	mov.n	a8, a2
42003c5f:	a09420        	addx4	a9, a4, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, false, memp_config->target_cpu[x]))
42003c62:	0d0c      	movi.n	a13, 0
42003c64:	0428c2        	l32i	a12, a8, 16
42003c67:	20bdd0        	or	a11, a13, a13
42003c6a:	04a0a2        	movi	a10, 4
42003c6d:	9189      	s32i.n	a8, a1, 36
42003c6f:	8199      	s32i.n	a9, a1, 32
42003c71:	71d9      	s32i.n	a13, a1, 28
42003c73:	ffdd25        	call8	42003a44 <esp_mprot_set_monitor_en>
42003c76:	9188      	l32i.n	a8, a1, 36
42003c78:	8198      	l32i.n	a9, a1, 32
42003c7a:	71d8      	l32i.n	a13, a1, 28
42003c7c:	170a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003c7f:	884b      	addi.n	a8, a8, 4
42003c81:	df9897        	bne	a8, a9, 42003c64 <esp_mprot_set_prot+0x108>
    if (memp_config->invoke_panic_handler) {
42003c84:	000282        	l8ui	a8, a2, 0
42003c87:	104816        	beqz	a8, 42003d8f <esp_mprot_set_prot+0x233>
        if (use_iram0) {
42003c8a:	052716        	beqz	a7, 42003ce0 <esp_mprot_set_prot+0x184>
42003c8d:	a08420        	addx4	a8, a4, a2
42003c90:	4129      	s32i.n	a2, a1, 16
42003c92:	5189      	s32i.n	a8, a1, 20
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42003c94:	042192        	l32i	a9, a1, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003c97:	9a1c      	movi.n	a10, 25
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42003c99:	4988      	l32i.n	a8, a9, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003c9b:	9189      	s32i.n	a8, a1, 36
42003c9d:	feb025        	call8	420027a0 <esp_intr_disable_source>
    switch (core) {
42003ca0:	9188      	l32i.n	a8, a1, 36
    return MEMP_HAL_OK;
42003ca2:	0a0c      	movi.n	a10, 0
            *src_num = ETS_CORE0_IRAM0_PMS_INTR_SOURCE;
42003ca4:	5b5c      	movi.n	a11, 85
    switch (core) {
42003ca6:	0e18a7        	beq	a8, a10, 42003cb8 <esp_mprot_set_prot+0x15c>
42003ca9:	980b      	addi.n	a9, a8, -1
42003cab:	63a0a2        	movi	a10, 99
42003cae:	9b5c      	movi.n	a11, 89
42003cb0:	93ba90        	movnez	a11, a10, a9
42003cb3:	fa7c      	movi.n	a10, -1
42003cb5:	83a390        	moveqz	a10, a3, a9
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_iram0_get_intr_source_num(core, &intr_src_num)))
42003cb8:	9189      	s32i.n	a8, a1, 36
42003cba:	71b9      	s32i.n	a11, a1, 28
42003cbc:	006de5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
42003cbf:	9188      	l32i.n	a8, a1, 36
42003cc1:	71b8      	l32i.n	a11, a1, 28
42003cc3:	129a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42003cc6:	08ad      	mov.n	a10, a8
42003cc8:	9c1c      	movi.n	a12, 25
42003cca:	f0e081        	l32r	a8, 4200004c <_stext+0x2c>
42003ccd:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
42003cd0:	9a1c      	movi.n	a10, 25
42003cd2:	feaba5        	call8	4200278c <esp_intr_enable_source>
            for (size_t x = 0; x < core_count; x++) {
42003cd5:	4188      	l32i.n	a8, a1, 16
42003cd7:	5198      	l32i.n	a9, a1, 20
42003cd9:	884b      	addi.n	a8, a8, 4
42003cdb:	4189      	s32i.n	a8, a1, 16
42003cdd:	b39987        	bne	a9, a8, 42003c94 <esp_mprot_set_prot+0x138>
        if (use_dram0) {
42003ce0:	054516        	beqz	a5, 42003d38 <esp_mprot_set_prot+0x1dc>
42003ce3:	a08420        	addx4	a8, a4, a2
42003ce6:	4129      	s32i.n	a2, a1, 16
42003ce8:	5189      	s32i.n	a8, a1, 20
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42003cea:	042192        	l32i	a9, a1, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003ced:	9a1c      	movi.n	a10, 25
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42003cef:	4988      	l32i.n	a8, a9, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003cf1:	9189      	s32i.n	a8, a1, 36
42003cf3:	feaae5        	call8	420027a0 <esp_intr_disable_source>
    switch (core) {
42003cf6:	9188      	l32i.n	a8, a1, 36
    return MEMP_HAL_OK;
42003cf8:	0a0c      	movi.n	a10, 0
            *src_num = ETS_CORE0_DRAM0_PMS_INTR_SOURCE;
42003cfa:	6b5c      	movi.n	a11, 86
    switch (core) {
42003cfc:	0e18a7        	beq	a8, a10, 42003d0e <esp_mprot_set_prot+0x1b2>
42003cff:	980b      	addi.n	a9, a8, -1
42003d01:	63a0a2        	movi	a10, 99
42003d04:	ab5c      	movi.n	a11, 90
42003d06:	93ba90        	movnez	a11, a10, a9
42003d09:	7a0c      	movi.n	a10, 7
42003d0b:	83a390        	moveqz	a10, a3, a9
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_dram0_get_intr_source_num(core, &intr_src_num)))
42003d0e:	9189      	s32i.n	a8, a1, 36
42003d10:	71b9      	s32i.n	a11, a1, 28
42003d12:	0068a5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
42003d15:	9188      	l32i.n	a8, a1, 36
42003d17:	71b8      	l32i.n	a11, a1, 28
42003d19:	0d3a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42003d1c:	20a880        	or	a10, a8, a8
42003d1f:	9c1c      	movi.n	a12, 25
42003d21:	f0ca81        	l32r	a8, 4200004c <_stext+0x2c>
42003d24:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
42003d27:	9a1c      	movi.n	a10, 25
42003d29:	fea625        	call8	4200278c <esp_intr_enable_source>
            for (size_t x = 0; x < core_count; x++) {
42003d2c:	4188      	l32i.n	a8, a1, 16
42003d2e:	5198      	l32i.n	a9, a1, 20
42003d30:	04c882        	addi	a8, a8, 4
42003d33:	4189      	s32i.n	a8, a1, 16
42003d35:	b19987        	bne	a9, a8, 42003cea <esp_mprot_set_prot+0x18e>
        if (use_rtcfast) {
42003d38:	6188      	l32i.n	a8, a1, 24
42003d3a:	051816        	beqz	a8, 42003d8f <esp_mprot_set_prot+0x233>
42003d3d:	a09420        	addx4	a9, a4, a2
42003d40:	4129      	s32i.n	a2, a1, 16
42003d42:	5199      	s32i.n	a9, a1, 20
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42003d44:	4198      	l32i.n	a9, a1, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003d46:	9a1c      	movi.n	a10, 25
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_intr_matrix(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42003d48:	4988      	l32i.n	a8, a9, 16
    ESP_INTR_DISABLE(ETS_MEMACCESS_ERR_INUM);
42003d4a:	9189      	s32i.n	a8, a1, 36
42003d4c:	fea525        	call8	420027a0 <esp_intr_disable_source>
    switch (core) {
42003d4f:	9188      	l32i.n	a8, a1, 36
    return MEMP_HAL_OK;
42003d51:	0a0c      	movi.n	a10, 0
            *src_num = ETS_CORE0_PIF_PMS_INTR_SOURCE;
42003d53:	7b5c      	movi.n	a11, 87
    switch (core) {
42003d55:	0e18a7        	beq	a8, a10, 42003d67 <esp_mprot_set_prot+0x20b>
42003d58:	980b      	addi.n	a9, a8, -1
42003d5a:	63a0a2        	movi	a10, 99
42003d5d:	bb5c      	movi.n	a11, 91
42003d5f:	93ba90        	movnez	a11, a10, a9
42003d62:	7a0c      	movi.n	a10, 7
42003d64:	83a390        	moveqz	a10, a3, a9
        ESP_MEMPROT_ERR_CHECK(err, esp_mprot_ll_err_to_esp_err(memprot_ll_rtcfast_get_intr_source_num(core, &intr_src_num)))
42003d67:	9189      	s32i.n	a8, a1, 36
42003d69:	71b9      	s32i.n	a11, a1, 28
42003d6b:	006325        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
42003d6e:	9188      	l32i.n	a8, a1, 36
42003d70:	71b8      	l32i.n	a11, a1, 28
42003d72:	07aa56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        esp_rom_route_intr_matrix(core, intr_src_num, ETS_MEMACCESS_ERR_INUM);
42003d75:	08ad      	mov.n	a10, a8
42003d77:	9c1c      	movi.n	a12, 25
42003d79:	f0b481        	l32r	a8, 4200004c <_stext+0x2c>
42003d7c:	0008e0        	callx8	a8
    ESP_INTR_ENABLE(ETS_MEMACCESS_ERR_INUM);
42003d7f:	9a1c      	movi.n	a10, 25
42003d81:	fea0a5        	call8	4200278c <esp_intr_enable_source>
            for (size_t x = 0; x < core_count; x++) {
42003d84:	4188      	l32i.n	a8, a1, 16
42003d86:	5198      	l32i.n	a9, a1, 20
42003d88:	884b      	addi.n	a8, a8, 4
42003d8a:	4189      	s32i.n	a8, a1, 16
42003d8c:	b49897        	bne	a8, a9, 42003d44 <esp_mprot_set_prot+0x1e8>
    if (use_iram0 || use_dram0) {
42003d8f:	146060        	extui	a6, a6, 0, 2
42003d92:	4169      	s32i.n	a6, a1, 16
42003d94:	05e616        	beqz	a6, 42003df6 <esp_mprot_set_prot+0x29a>
        line_addr = memp_config->split_addr;
42003d97:	1268      	l32i.n	a6, a2, 4
        if (line_addr == NULL) {
42003d99:	002656        	bnez	a6, 42003d9f <esp_mprot_set_prot+0x243>
        *def_split_addr = esp_memprot_iram0_get_def_split_addr();
42003d9c:	f1de61        	l32r	a6, 42000514 <_stext+0x4f4>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
42003d9f:	f1c5b1        	l32r	a11, 420004b4 <_stext+0x494>
42003da2:	06ad      	mov.n	a10, a6
42003da4:	ff4d25        	call8	42003278 <memprot_ll_set_iram0_split_line>
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_1(line_addr));
42003da7:	005f65        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_1, line_addr, DEFAULT_CPU_NUM))
42003daa:	042a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
42003dad:	f1c0b1        	l32r	a11, 420004b0 <_stext+0x490>
42003db0:	06ad      	mov.n	a10, a6
42003db2:	ff4c65        	call8	42003278 <memprot_ll_set_iram0_split_line>
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_I_0(line_addr));
42003db5:	005e65        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_LINE_0, line_addr, DEFAULT_CPU_NUM))
42003db8:	034a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
    return memprot_ll_set_iram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
42003dbb:	f1bcb1        	l32r	a11, 420004ac <_stext+0x48c>
42003dbe:	06ad      	mov.n	a10, a6
42003dc0:	ff4b65        	call8	42003278 <memprot_ll_set_iram0_split_line>
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_iram0_split_line_main_I_D(line_addr));
42003dc3:	005da5        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_SRAM, MEMPROT_SPLIT_ADDR_IRAM0_DRAM0, line_addr, DEFAULT_CPU_NUM))
42003dc6:	6aec      	bnez.n	a10, 42003df0 <esp_mprot_set_prot+0x294>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
42003dc8:	91afa2        	movi	a10, -111
42003dcb:	11aa00        	slli	a10, a10, 16
42003dce:	86aa      	add.n	a8, a6, a10
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42003dd0:	f1bab1        	l32r	a11, 420004b8 <_stext+0x498>
42003dd3:	08ad      	mov.n	a10, a8
42003dd5:	9189      	s32i.n	a8, a1, 36
42003dd7:	ff57e5        	call8	42003354 <memprot_ll_set_dram0_split_line>
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_0(line_addr));
42003dda:	005c25        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_0, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
42003ddd:	9188      	l32i.n	a8, a1, 36
42003ddf:	00da56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
    return memprot_ll_set_dram0_split_line(line_addr, SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42003de2:	f1b6b1        	l32r	a11, 420004bc <_stext+0x49c>
42003de5:	20a880        	or	a10, a8, a8
42003de8:	ff56a5        	call8	42003354 <memprot_ll_set_dram0_split_line>
            return esp_mprot_ll_err_to_esp_err(memprot_ll_set_dram0_split_line_D_1(line_addr));
42003deb:	005b25        	call8	4200439c <esp_mprot_ll_err_to_esp_err>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_DRAM0_SRAM, MEMPROT_SPLIT_ADDR_DRAM0_DMA_LINE_1, (void *)(MAP_IRAM_TO_DRAM((uint32_t)line_addr)), DEFAULT_CPU_NUM))
42003dee:	7a8c      	beqz.n	a10, 42003df9 <esp_mprot_set_prot+0x29d>
42003df0:	0a3d      	mov.n	a3, a10
42003df2:	ff7586        	j	42003bcc <esp_mprot_set_prot+0x70>
42003df5:	00          	.byte 00
    void *line_addr __attribute__((unused)) = NULL;
42003df6:	042162        	l32i	a6, a1, 16
    if (use_iram0) {
42003df9:	0ec716        	beqz	a7, 42003ee9 <esp_mprot_set_prot+0x38d>
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0, memprot_ll_icache_set_permissions(r, w, x));
42003dfc:	f1b581        	l32r	a8, 420004d0 <_stext+0x4b0>
42003dff:	0c0c      	movi.n	a12, 0
42003e01:	0020c0        	memw
42003e04:	0898      	l32i.n	a9, a8, 0
42003e06:	0cbd      	mov.n	a11, a12
42003e08:	0cad      	mov.n	a10, a12
42003e0a:	9189      	s32i.n	a8, a1, 36
42003e0c:	8199      	s32i.n	a9, a1, 32
42003e0e:	140f25        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003e11:	7b0c      	movi.n	a11, 7
42003e13:	11bb40        	slli	a11, a11, 12
42003e16:	11aa40        	slli	a10, a10, 12
42003e19:	8198      	l32i.n	a9, a1, 32
42003e1b:	10aab0        	and	a10, a10, a11
42003e1e:	f1afb1        	l32r	a11, 420004dc <_stext+0x4bc>
42003e21:	9188      	l32i.n	a8, a1, 36
42003e23:	1099b0        	and	a9, a9, a11
42003e26:	20aa90        	or	a10, a10, a9
42003e29:	0020c0        	memw
42003e2c:	08a9      	s32i.n	a10, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1, memprot_ll_icache_set_permissions(r, w, x));
42003e2e:	0020c0        	memw
42003e31:	0898      	l32i.n	a9, a8, 0
42003e33:	1c0c      	movi.n	a12, 1
42003e35:	0b0c      	movi.n	a11, 0
42003e37:	0cad      	mov.n	a10, a12
42003e39:	9189      	s32i.n	a8, a1, 36
42003e3b:	8199      	s32i.n	a9, a1, 32
42003e3d:	140c25        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003e40:	7b0c      	movi.n	a11, 7
42003e42:	11bb10        	slli	a11, a11, 15
42003e45:	11aa10        	slli	a10, a10, 15
42003e48:	8198      	l32i.n	a9, a1, 32
42003e4a:	10aab0        	and	a10, a10, a11
42003e4d:	f1a4b1        	l32r	a11, 420004e0 <_stext+0x4c0>
42003e50:	9188      	l32i.n	a8, a1, 36
42003e52:	1099b0        	and	a9, a9, a11
42003e55:	20aa90        	or	a10, a10, a9
42003e58:	0020c0        	memw
42003e5b:	08a9      	s32i.n	a10, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_iram0_set_permissions(r, w, x));
42003e5d:	0020c0        	memw
42003e60:	0898      	l32i.n	a9, a8, 0
42003e62:	1c0c      	movi.n	a12, 1
42003e64:	0b0c      	movi.n	a11, 0
42003e66:	0cad      	mov.n	a10, a12
42003e68:	9189      	s32i.n	a8, a1, 36
42003e6a:	8199      	s32i.n	a9, a1, 32
42003e6c:	140925        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003e6f:	8198      	l32i.n	a9, a1, 32
42003e71:	8b7c      	movi.n	a11, -8
42003e73:	9188      	l32i.n	a8, a1, 36
42003e75:	1099b0        	and	a9, a9, a11
42003e78:	24b0a0        	extui	a11, a10, 0, 3
42003e7b:	2099b0        	or	a9, a9, a11
42003e7e:	0020c0        	memw
42003e81:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_iram0_set_permissions(r, w, x));
42003e83:	0020c0        	memw
42003e86:	08b8      	l32i.n	a11, a8, 0
42003e88:	119ad0        	slli	a9, a10, 3
42003e8b:	8c3c      	movi.n	a12, 56
42003e8d:	1099c0        	and	a9, a9, a12
42003e90:	c7afc2        	movi	a12, -57
42003e93:	10bbc0        	and	a11, a11, a12
42003e96:	2099b0        	or	a9, a9, a11
42003e99:	0020c0        	memw
42003e9c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_iram0_set_permissions(r, w, x));
42003e9e:	0020c0        	memw
42003ea1:	0898      	l32i.n	a9, a8, 0
42003ea3:	c0a1b2        	movi	a11, 0x1c0
42003ea6:	11aaa0        	slli	a10, a10, 6
42003ea9:	10aab0        	and	a10, a10, a11
42003eac:	3faeb2        	movi	a11, 0xfffffe3f
42003eaf:	1099b0        	and	a9, a9, a11
42003eb2:	20aa90        	or	a10, a10, a9
42003eb5:	0020c0        	memw
42003eb8:	08a9      	s32i.n	a10, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG, SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_iram0_set_permissions(r, w, x));
42003eba:	0020c0        	memw
42003ebd:	0898      	l32i.n	a9, a8, 0
42003ebf:	0c0c      	movi.n	a12, 0
42003ec1:	0cbd      	mov.n	a11, a12
42003ec3:	0cad      	mov.n	a10, a12
42003ec5:	9189      	s32i.n	a8, a1, 36
42003ec7:	8199      	s32i.n	a9, a1, 32
42003ec9:	140365        	call8	42017f00 <memprot_ll_icache_set_permissions>
42003ecc:	7b0c      	movi.n	a11, 7
42003ece:	11bb70        	slli	a11, a11, 9
42003ed1:	11aa70        	slli	a10, a10, 9
42003ed4:	8198      	l32i.n	a9, a1, 32
42003ed6:	10aab0        	and	a10, a10, a11
42003ed9:	f17eb1        	l32r	a11, 420004d4 <_stext+0x4b4>
42003edc:	9188      	l32i.n	a8, a1, 36
42003ede:	1099b0        	and	a9, a9, a11
42003ee1:	20aa90        	or	a10, a10, a9
42003ee4:	0020c0        	memw
42003ee7:	08a9      	s32i.n	a10, a8, 0
    if (use_dram0) {
42003ee9:	045516        	beqz	a5, 42003f32 <esp_mprot_set_prot+0x3d6>
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0, memprot_ll_dram0_set_permissions(r, w));
42003eec:	f17b81        	l32r	a8, 420004d8 <_stext+0x4b8>
42003eef:	ca7c      	movi.n	a10, -4
42003ef1:	0020c0        	memw
42003ef4:	0898      	l32i.n	a9, a8, 0
42003ef6:	1099a0        	and	a9, a9, a10
42003ef9:	1a0c      	movi.n	a10, 1
42003efb:	2099a0        	or	a9, a9, a10
42003efe:	0020c0        	memw
42003f01:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1, memprot_ll_dram0_set_permissions(r, w));
42003f03:	0020c0        	memw
42003f06:	0898      	l32i.n	a9, a8, 0
42003f08:	ca0c      	movi.n	a10, 12
42003f0a:	2099a0        	or	a9, a9, a10
42003f0d:	0020c0        	memw
42003f10:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2, memprot_ll_dram0_set_permissions(r, w));
42003f12:	0020c0        	memw
42003f15:	0898      	l32i.n	a9, a8, 0
42003f17:	0a3c      	movi.n	a10, 48
42003f19:	2099a0        	or	a9, a9, a10
42003f1c:	0020c0        	memw
42003f1f:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG, SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3, memprot_ll_dram0_set_permissions(r, w));
42003f21:	0020c0        	memw
42003f24:	0898      	l32i.n	a9, a8, 0
42003f26:	c0a0a2        	movi	a10, 192
42003f29:	2099a0        	or	a9, a9, a10
42003f2c:	0020c0        	memw
42003f2f:	006892        	s32i	a9, a8, 0
    if (use_rtcfast) {
42003f32:	6188      	l32i.n	a8, a1, 24
42003f34:	041816        	beqz	a8, 42003f79 <esp_mprot_set_prot+0x41d>
42003f37:	a09420        	addx4	a9, a4, a2
42003f3a:	028d      	mov.n	a8, a2
42003f3c:	5199      	s32i.n	a9, a1, 20
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_split_addr(MEMPROT_TYPE_IRAM0_RTCFAST, MEMPROT_SPLIT_ADDR_MAIN, rtc_fast_line, memp_config->target_cpu[x]))
42003f3e:	0428d2        	l32i	a13, a8, 16
42003f41:	f177c1        	l32r	a12, 42000520 <_stext+0x500>
42003f44:	1b0c      	movi.n	a11, 1
42003f46:	04a0a2        	movi	a10, 4
42003f49:	9189      	s32i.n	a8, a1, 36
42003f4b:	ff4ce5        	call8	42003418 <esp_mprot_set_split_addr>
42003f4e:	9188      	l32i.n	a8, a1, 36
42003f50:	e9ca56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_LO, MEMPROT_OP_READ | MEMPROT_OP_EXEC, memp_config->target_cpu[x]))
42003f53:	48c8      	l32i.n	a12, a8, 16
42003f55:	5b0c      	movi.n	a11, 5
42003f57:	00a1a2        	movi	a10, 0x100
42003f5a:	ff5b25        	call8	4200350c <esp_mprot_set_pms_area>
42003f5d:	9188      	l32i.n	a8, a1, 36
42003f5f:	e8da56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_area(MEMPROT_PMS_AREA_IRAM0_RTCFAST_HI, MEMPROT_OP_READ | MEMPROT_OP_WRITE, memp_config->target_cpu[x]))
42003f62:	48c8      	l32i.n	a12, a8, 16
42003f64:	03a0b2        	movi	a11, 3
42003f67:	00a2a2        	movi	a10, 0x200
42003f6a:	ff5a25        	call8	4200350c <esp_mprot_set_pms_area>
42003f6d:	9188      	l32i.n	a8, a1, 36
42003f6f:	e7da56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003f72:	5198      	l32i.n	a9, a1, 20
42003f74:	884b      	addi.n	a8, a8, 4
42003f76:	c49987        	bne	a9, a8, 42003f3e <esp_mprot_set_prot+0x3e2>
    if (use_iram0) {
42003f79:	47bc      	beqz.n	a7, 42003fb1 <esp_mprot_set_prot+0x455>
42003f7b:	a09420        	addx4	a9, a4, a2
42003f7e:	5199      	s32i.n	a9, a1, 20
42003f80:	028d      	mov.n	a8, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42003f82:	190c      	movi.n	a9, 1
42003f84:	48b8      	l32i.n	a11, a8, 16
42003f86:	09ad      	mov.n	a10, a9
42003f88:	9189      	s32i.n	a8, a1, 36
42003f8a:	8199      	s32i.n	a9, a1, 32
42003f8c:	f17c81        	l32r	a8, 4200057c <_stext+0x55c>
42003f8f:	0008e0        	callx8	a8
42003f92:	9188      	l32i.n	a8, a1, 36
42003f94:	8198      	l32i.n	a9, a1, 32
42003f96:	e56a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, true, memp_config->target_cpu[x]))
42003f99:	48c8      	l32i.n	a12, a8, 16
42003f9b:	09bd      	mov.n	a11, a9
42003f9d:	09ad      	mov.n	a10, a9
42003f9f:	ffaa65        	call8	42003a44 <esp_mprot_set_monitor_en>
42003fa2:	9188      	l32i.n	a8, a1, 36
42003fa4:	8198      	l32i.n	a9, a1, 32
42003fa6:	e46a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003fa9:	51a8      	l32i.n	a10, a1, 20
42003fab:	04c882        	addi	a8, a8, 4
42003fae:	d29a87        	bne	a10, a8, 42003f84 <esp_mprot_set_prot+0x428>
    if (use_dram0) {
42003fb1:	45bc      	beqz.n	a5, 42003fe9 <esp_mprot_set_prot+0x48d>
42003fb3:	a09420        	addx4	a9, a4, a2
42003fb6:	5199      	s32i.n	a9, a1, 20
42003fb8:	028d      	mov.n	a8, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42003fba:	290c      	movi.n	a9, 2
42003fbc:	48b8      	l32i.n	a11, a8, 16
42003fbe:	09ad      	mov.n	a10, a9
42003fc0:	9189      	s32i.n	a8, a1, 36
42003fc2:	8199      	s32i.n	a9, a1, 32
42003fc4:	f16e81        	l32r	a8, 4200057c <_stext+0x55c>
42003fc7:	0008e0        	callx8	a8
42003fca:	9188      	l32i.n	a8, a1, 36
42003fcc:	8198      	l32i.n	a9, a1, 32
42003fce:	e1ea56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, true, memp_config->target_cpu[x]))
42003fd1:	48c8      	l32i.n	a12, a8, 16
42003fd3:	09ad      	mov.n	a10, a9
42003fd5:	1b0c      	movi.n	a11, 1
42003fd7:	ffa6e5        	call8	42003a44 <esp_mprot_set_monitor_en>
42003fda:	9188      	l32i.n	a8, a1, 36
42003fdc:	8198      	l32i.n	a9, a1, 32
42003fde:	e0ea56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
42003fe1:	51a8      	l32i.n	a10, a1, 20
42003fe3:	04c882        	addi	a8, a8, 4
42003fe6:	d298a7        	bne	a8, a10, 42003fbc <esp_mprot_set_prot+0x460>
    if (use_rtcfast) {
42003fe9:	6188      	l32i.n	a8, a1, 24
42003feb:	38bc      	beqz.n	a8, 42004022 <esp_mprot_set_prot+0x4c6>
42003fed:	a09420        	addx4	a9, a4, a2
42003ff0:	5199      	s32i.n	a9, a1, 20
42003ff2:	028d      	mov.n	a8, a2
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_monitor_clear_intr(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
42003ff4:	490c      	movi.n	a9, 4
42003ff6:	48b8      	l32i.n	a11, a8, 16
42003ff8:	09ad      	mov.n	a10, a9
42003ffa:	9189      	s32i.n	a8, a1, 36
42003ffc:	8199      	s32i.n	a9, a1, 32
42003ffe:	f15f81        	l32r	a8, 4200057c <_stext+0x55c>
42004001:	0008e0        	callx8	a8
42004004:	9188      	l32i.n	a8, a1, 36
42004006:	8198      	l32i.n	a9, a1, 32
42004008:	de4a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_en(MEMPROT_TYPE_IRAM0_RTCFAST, true, memp_config->target_cpu[x]))
4200400b:	48c8      	l32i.n	a12, a8, 16
4200400d:	09ad      	mov.n	a10, a9
4200400f:	1b0c      	movi.n	a11, 1
42004011:	ffa325        	call8	42003a44 <esp_mprot_set_monitor_en>
42004014:	9188      	l32i.n	a8, a1, 36
42004016:	8198      	l32i.n	a9, a1, 32
42004018:	dd4a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        for (size_t x = 0; x < core_count; x++) {
4200401b:	51a8      	l32i.n	a10, a1, 20
4200401d:	884b      	addi.n	a8, a8, 4
4200401f:	d39a87        	bne	a10, a8, 42003ff6 <esp_mprot_set_prot+0x49a>
    if (memp_config->lock_feature) {
42004022:	010282        	l8ui	a8, a2, 1
42004025:	093816        	beqz	a8, 420040bc <esp_mprot_set_prot+0x560>
        if (use_iram0) {
42004028:	b7ac      	beqz.n	a7, 42004057 <esp_mprot_set_prot+0x4fb>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG, 1);
4200402a:	f13e91        	l32r	a9, 42000524 <_stext+0x504>
4200402d:	180c      	movi.n	a8, 1
4200402f:	0020c0        	memw
42004032:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG, 1);
42004034:	f12391        	l32r	a9, 420004c0 <_stext+0x4a0>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
42004037:	42b8      	l32i.n	a11, a2, 16
42004039:	0020c0        	memw
4200403c:	0989      	s32i.n	a8, a9, 0
4200403e:	08ad      	mov.n	a10, a8
42004040:	9189      	s32i.n	a8, a1, 36
42004042:	ff90e5        	call8	42003950 <esp_mprot_set_monitor_lock>
42004045:	9188      	l32i.n	a8, a1, 36
42004047:	da5a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            for (size_t x = 0; x < core_count; x++) {
4200404a:	092466        	bnei	a4, 2, 42004057 <esp_mprot_set_prot+0x4fb>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, memp_config->target_cpu[x]))
4200404d:	52b8      	l32i.n	a11, a2, 20
4200404f:	08ad      	mov.n	a10, a8
42004051:	ff8fe5        	call8	42003950 <esp_mprot_set_monitor_lock>
42004054:	d98a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (use_dram0) {
42004057:	95ac      	beqz.n	a5, 42004084 <esp_mprot_set_prot+0x528>
    REG_WRITE(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG, 1);
42004059:	f13291        	l32r	a9, 42000524 <_stext+0x504>
4200405c:	180c      	movi.n	a8, 1
4200405e:	0020c0        	memw
42004061:	0989      	s32i.n	a8, a9, 0
    REG_WRITE(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG, 1);
42004063:	f11891        	l32r	a9, 420004c4 <_stext+0x4a4>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
42004066:	42b8      	l32i.n	a11, a2, 16
42004068:	0020c0        	memw
4200406b:	006982        	s32i	a8, a9, 0
4200406e:	02a0a2        	movi	a10, 2
42004071:	ff8de5        	call8	42003950 <esp_mprot_set_monitor_lock>
42004074:	d78a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            for (size_t x = 0; x < core_count; x++) {
42004077:	092466        	bnei	a4, 2, 42004084 <esp_mprot_set_prot+0x528>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, memp_config->target_cpu[x]))
4200407a:	52b8      	l32i.n	a11, a2, 20
4200407c:	04ad      	mov.n	a10, a4
4200407e:	ff8d25        	call8	42003950 <esp_mprot_set_monitor_lock>
42004081:	d6ba56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (use_rtcfast) {
42004084:	6188      	l32i.n	a8, a1, 24
42004086:	28bc      	beqz.n	a8, 420040bc <esp_mprot_set_prot+0x560>
42004088:	a09420        	addx4	a9, a4, a2
4200408b:	6199      	s32i.n	a9, a1, 24
4200408d:	028d      	mov.n	a8, a2
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_pms_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
4200408f:	04a092        	movi	a9, 4
42004092:	0428b2        	l32i	a11, a8, 16
42004095:	09ad      	mov.n	a10, a9
42004097:	9189      	s32i.n	a8, a1, 36
42004099:	086192        	s32i	a9, a1, 32
4200409c:	ff4325        	call8	420034d0 <esp_mprot_set_pms_lock>
4200409f:	9188      	l32i.n	a8, a1, 36
420040a1:	8198      	l32i.n	a9, a1, 32
420040a3:	d49a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_set_monitor_lock(MEMPROT_TYPE_IRAM0_RTCFAST, memp_config->target_cpu[x]))
420040a6:	48b8      	l32i.n	a11, a8, 16
420040a8:	09ad      	mov.n	a10, a9
420040aa:	ff8a65        	call8	42003950 <esp_mprot_set_monitor_lock>
420040ad:	9188      	l32i.n	a8, a1, 36
420040af:	8198      	l32i.n	a9, a1, 32
420040b1:	d3ba56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
            for (size_t x = 0; x < core_count; x++) {
420040b4:	61a8      	l32i.n	a10, a1, 24
420040b6:	04c882        	addi	a8, a8, 4
420040b9:	d598a7        	bne	a8, a10, 42004092 <esp_mprot_set_prot+0x536>
    if (use_iram0 || use_dram0) {
420040bc:	4188      	l32i.n	a8, a1, 16
420040be:	2b2816        	beqz	a8, 42004374 <esp_mprot_set_prot+0x818>
        memprot_ll_prepare_iram0_split_line_regval((const uint32_t) line_addr, &check_val);
420040c1:	01bd      	mov.n	a11, a1
420040c3:	06ad      	mov.n	a10, a6
420040c5:	ff10e5        	call8	420031d4 <memprot_ll_prepare_iram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG);
420040c8:	f0f981        	l32r	a8, 420004ac <_stext+0x48c>
        if (memprot_ll_get_iram0_split_line_main_I_D_regval() != check_val) {
420040cb:	01b8      	l32i.n	a11, a1, 0
420040cd:	0020c0        	memw
420040d0:	0898      	l32i.n	a9, a8, 0
420040d2:	131b97        	beq	a11, a9, 420040e9 <esp_mprot_set_prot+0x58d>
420040d5:	0020c0        	memw
420040d8:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420040da:	f113a1        	l32r	a10, 42000528 <_stext+0x508>
            esp_rom_printf(
420040dd:	f12881        	l32r	a8, 42000580 <_stext+0x560>
420040e0:	0008e0        	callx8	a8
            abort();
420040e3:	f00e81        	l32r	a8, 4200011c <_stext+0xfc>
420040e6:	0008e0        	callx8	a8
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG);
420040e9:	f0f181        	l32r	a8, 420004b0 <_stext+0x490>
420040ec:	0020c0        	memw
420040ef:	0898      	l32i.n	a9, a8, 0
        if (memprot_ll_get_iram0_split_line_main_I_0_regval() != check_val) {
420040f1:	0b1b97        	beq	a11, a9, 42004100 <esp_mprot_set_prot+0x5a4>
420040f4:	0020c0        	memw
420040f7:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
420040f9:	f10ca1        	l32r	a10, 4200052c <_stext+0x50c>
420040fc:	fff746        	j	420040dd <esp_mprot_set_prot+0x581>
420040ff:	00          	.byte 00
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG);
42004100:	f0ed81        	l32r	a8, 420004b4 <_stext+0x494>
42004103:	0020c0        	memw
42004106:	0898      	l32i.n	a9, a8, 0
        if (memprot_ll_get_iram0_split_line_main_I_1_regval() != check_val) {
42004108:	0c1b97        	beq	a11, a9, 42004118 <esp_mprot_set_prot+0x5bc>
4200410b:	0020c0        	memw
4200410e:	08c8      	l32i.n	a12, a8, 0
            esp_rom_printf(
42004110:	f108a1        	l32r	a10, 42000530 <_stext+0x510>
42004113:	fff186        	j	420040dd <esp_mprot_set_prot+0x581>
42004116:	00          	.byte 00
42004117:	00          	.byte 00
        memprot_ll_prepare_dram0_split_line_regval(MAP_IRAM_TO_DRAM((const uint32_t) line_addr), &check_val);
42004118:	91afa2        	movi	a10, -111
4200411b:	11aa00        	slli	a10, a10, 16
4200411e:	20b110        	or	a11, a1, a1
42004121:	80a6a0        	add	a10, a6, a10
42004124:	ff1825        	call8	420032a8 <memprot_ll_prepare_dram0_split_line_regval>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG);
42004127:	f0e461        	l32r	a6, 420004b8 <_stext+0x498>
        if (memprot_ll_get_dram0_split_line_main_D_0_regval() != check_val) {
4200412a:	0021b2        	l32i	a11, a1, 0
4200412d:	0020c0        	memw
42004130:	0688      	l32i.n	a8, a6, 0
42004132:	0a1b87        	beq	a11, a8, 42004140 <esp_mprot_set_prot+0x5e4>
42004135:	0020c0        	memw
42004138:	06c8      	l32i.n	a12, a6, 0
            esp_rom_printf(
4200413a:	f0fea1        	l32r	a10, 42000534 <_stext+0x514>
4200413d:	ffe706        	j	420040dd <esp_mprot_set_prot+0x581>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG);
42004140:	f0df61        	l32r	a6, 420004bc <_stext+0x49c>
42004143:	0020c0        	memw
42004146:	0688      	l32i.n	a8, a6, 0
        if (memprot_ll_get_dram0_split_line_main_D_1_regval() != check_val) {
42004148:	0a1b87        	beq	a11, a8, 42004156 <esp_mprot_set_prot+0x5fa>
4200414b:	0020c0        	memw
4200414e:	06c8      	l32i.n	a12, a6, 0
            esp_rom_printf(
42004150:	f0faa1        	l32r	a10, 42000538 <_stext+0x518>
42004153:	ffe186        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_0, &check_val, DEFAULT_CPU_NUM))
42004156:	fc7c      	movi.n	a12, -1
42004158:	20b110        	or	a11, a1, a1
4200415b:	01a0a2        	movi	a10, 1
4200415e:	ff63e5        	call8	4200379c <esp_mprot_get_pms_area>
42004161:	c8ba56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42004164:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_0 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
42004166:	f0f5a1        	l32r	a10, 4200053c <_stext+0x51c>
42004169:	5b0c      	movi.n	a11, 5
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
4200416b:	025c26        	beqi	a12, 5, 42004171 <esp_mprot_set_prot+0x615>
4200416e:	ffdac6        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_1, &check_val, DEFAULT_CPU_NUM))
42004171:	fc7c      	movi.n	a12, -1
42004173:	01bd      	mov.n	a11, a1
42004175:	2a0c      	movi.n	a10, 2
42004177:	ff6265        	call8	4200379c <esp_mprot_get_pms_area>
4200417a:	c72a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
4200417d:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_1 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
4200417f:	f0f0a1        	l32r	a10, 42000540 <_stext+0x520>
42004182:	5b0c      	movi.n	a11, 5
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42004184:	025c26        	beqi	a12, 5, 4200418a <esp_mprot_set_prot+0x62e>
42004187:	ffd486        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_2, &check_val, DEFAULT_CPU_NUM))
4200418a:	fc7c      	movi.n	a12, -1
4200418c:	01bd      	mov.n	a11, a1
4200418e:	4a0c      	movi.n	a10, 4
42004190:	ff60a5        	call8	4200379c <esp_mprot_get_pms_area>
42004193:	c59a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
42004196:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_2 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
42004198:	f0eba1        	l32r	a10, 42000544 <_stext+0x524>
4200419b:	5b0c      	movi.n	a11, 5
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_EXEC)) {
4200419d:	025c26        	beqi	a12, 5, 420041a3 <esp_mprot_set_prot+0x647>
420041a0:	ffce46        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_IRAM0_3, &check_val, DEFAULT_CPU_NUM))
420041a3:	fc7c      	movi.n	a12, -1
420041a5:	01bd      	mov.n	a11, a1
420041a7:	8a0c      	movi.n	a10, 8
420041a9:	ff5f25        	call8	4200379c <esp_mprot_get_pms_area>
420041ac:	c40a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != MEMPROT_OP_NONE) {
420041af:	0168      	l32i.n	a6, a1, 0
420041b1:	868c      	beqz.n	a6, 420041bd <esp_mprot_set_prot+0x661>
            esp_rom_printf("Fatal error: IRAM0 PMS AREA_3 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
420041b3:	0abd      	mov.n	a11, a10
420041b5:	06cd      	mov.n	a12, a6
420041b7:	f0e4a1        	l32r	a10, 42000548 <_stext+0x528>
420041ba:	ffc7c6        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_0, &check_val, DEFAULT_CPU_NUM))
420041bd:	ffafc2        	movi	a12, -1
420041c0:	20b110        	or	a11, a1, a1
420041c3:	10a0a2        	movi	a10, 16
420041c6:	ff5d65        	call8	4200379c <esp_mprot_get_pms_area>
420041c9:	c23a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != MEMPROT_OP_READ) {
420041cc:	0198      	l32i.n	a9, a1, 0
420041ce:	6199      	s32i.n	a9, a1, 24
420041d0:	091926        	beqi	a9, 1, 420041dd <esp_mprot_set_prot+0x681>
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_0 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
420041d3:	f0dea1        	l32r	a10, 4200054c <_stext+0x52c>
420041d6:	09cd      	mov.n	a12, a9
420041d8:	1b0c      	movi.n	a11, 1
420041da:	ffbfc6        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_1, &check_val, DEFAULT_CPU_NUM))
420041dd:	ffafc2        	movi	a12, -1
420041e0:	01bd      	mov.n	a11, a1
420041e2:	0a2c      	movi.n	a10, 32
420041e4:	ff5b65        	call8	4200379c <esp_mprot_get_pms_area>
420041e7:	c05a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
420041ea:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_1 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
420041ec:	f0d9a1        	l32r	a10, 42000550 <_stext+0x530>
420041ef:	3b0c      	movi.n	a11, 3
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
420041f1:	023c26        	beqi	a12, 3, 420041f7 <esp_mprot_set_prot+0x69b>
420041f4:	ffb946        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_2, &check_val, DEFAULT_CPU_NUM))
420041f7:	fc7c      	movi.n	a12, -1
420041f9:	01bd      	mov.n	a11, a1
420041fb:	0a4c      	movi.n	a10, 64
420041fd:	ff59e5        	call8	4200379c <esp_mprot_get_pms_area>
42004200:	beca56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42004203:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_2 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
42004205:	f0d3a1        	l32r	a10, 42000554 <_stext+0x534>
42004208:	3b0c      	movi.n	a11, 3
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
4200420a:	023c26        	beqi	a12, 3, 42004210 <esp_mprot_set_prot+0x6b4>
4200420d:	ffb306        	j	420040dd <esp_mprot_set_prot+0x581>
        ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_pms_area(MEMPROT_PMS_AREA_DRAM0_3, &check_val, DEFAULT_CPU_NUM))
42004210:	ffafc2        	movi	a12, -1
42004213:	20b110        	or	a11, a1, a1
42004216:	80a0a2        	movi	a10, 128
42004219:	ff5825        	call8	4200379c <esp_mprot_get_pms_area>
4200421c:	bd0a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
4200421f:	01c8      	l32i.n	a12, a1, 0
            esp_rom_printf("Fatal error: DRAM0 PMS AREA_3 configuration corrupted (expected 0x%08X, stored 0x%08X)\n",
42004221:	f0cda1        	l32r	a10, 42000558 <_stext+0x538>
42004224:	3b0c      	movi.n	a11, 3
        if (check_val != (MEMPROT_OP_READ | MEMPROT_OP_WRITE)) {
42004226:	023c26        	beqi	a12, 3, 4200422c <esp_mprot_set_prot+0x6d0>
42004229:	ffac06        	j	420040dd <esp_mprot_set_prot+0x581>
        if (use_iram0) {
4200422c:	10c292        	addi	a9, a2, 16
            for (size_t x = 0; x < core_count; x++) {
4200422f:	068d      	mov.n	a8, a6
        if (use_iram0) {
42004231:	073756        	bnez	a7, 420042a8 <esp_mprot_set_prot+0x74c>
        if (use_dram0) {
42004234:	10c292        	addi	a9, a2, 16
            for (size_t x = 0; x < core_count; x++) {
42004237:	068d      	mov.n	a8, a6
        if (use_dram0) {
42004239:	0a3556        	bnez	a5, 420042e0 <esp_mprot_set_prot+0x784>
        if (memp_config->lock_feature) {
4200423c:	010282        	l8ui	a8, a2, 1
4200423f:	131816        	beqz	a8, 42004374 <esp_mprot_set_prot+0x818>
            if (use_iram0) {
42004242:	0ce716        	beqz	a7, 42004314 <esp_mprot_set_prot+0x7b8>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
42004245:	f0b771        	l32r	a7, 42000524 <_stext+0x504>
                    esp_rom_printf(
42004248:	f0c7a1        	l32r	a10, 42000564 <_stext+0x544>
4200424b:	0020c0        	memw
4200424e:	002772        	l32i	a7, a7, 0
                if (!locked) {
42004251:	021726        	beqi	a7, 1, 42004257 <esp_mprot_set_prot+0x6fb>
42004254:	003a06        	j	42004340 <esp_mprot_set_prot+0x7e4>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004257:	f09a81        	l32r	a8, 420004c0 <_stext+0x4a0>
4200425a:	00a092        	movi	a9, 0
4200425d:	0020c0        	memw
42004260:	002882        	l32i	a8, a8, 0
42004263:	a80b      	addi.n	a10, a8, -1
42004265:	9379a0        	movnez	a7, a9, a10
42004268:	044172        	s8i	a7, a1, 4
                    esp_rom_printf(
4200426b:	f0bfa1        	l32r	a10, 42000568 <_stext+0x548>
4200426e:	10c292        	addi	a9, a2, 16
                for (size_t x = 0; x < core_count; x++) {
42004271:	067d      	mov.n	a7, a6
                if (!locked) {
42004273:	021826        	beqi	a8, 1, 42004279 <esp_mprot_set_prot+0x71d>
42004276:	003186        	j	42004340 <esp_mprot_set_prot+0x7e4>
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_IRAM0_SRAM, &locked,
42004279:	09c8      	l32i.n	a12, a9, 0
4200427b:	b14b      	addi.n	a11, a1, 4
4200427d:	1a0c      	movi.n	a10, 1
4200427f:	9189      	s32i.n	a8, a1, 36
42004281:	8199      	s32i.n	a9, a1, 32
42004283:	ff7365        	call8	420039b8 <esp_mprot_get_monitor_lock>
42004286:	9188      	l32i.n	a8, a1, 36
42004288:	8198      	l32i.n	a9, a1, 32
4200428a:	b62a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
                    if (!locked) {
4200428d:	0401a2        	l8ui	a10, a1, 4
42004290:	079a56        	bnez	a10, 4200430d <esp_mprot_set_prot+0x7b1>
                            memp_config->target_cpu[x]);
42004293:	a07720        	addx4	a7, a7, a2
                        esp_rom_printf(
42004296:	47b8      	l32i.n	a11, a7, 16
42004298:	f0b5a1        	l32r	a10, 4200056c <_stext+0x54c>
4200429b:	000ac6        	j	420042ca <esp_mprot_set_prot+0x76e>
            for (size_t x = 0; x < core_count; x++) {
4200429e:	881b      	addi.n	a8, a8, 1
420042a0:	994b      	addi.n	a9, a9, 4
420042a2:	8eb847        	bgeu	a8, a4, 42004234 <esp_mprot_set_prot+0x6d8>
420042a5:	208770        	or	a8, a7, a7
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_IRAM0_SRAM, &enabled,
420042a8:	09c8      	l32i.n	a12, a9, 0
420042aa:	b15b      	addi.n	a11, a1, 5
420042ac:	1a0c      	movi.n	a10, 1
420042ae:	9189      	s32i.n	a8, a1, 36
420042b0:	8199      	s32i.n	a9, a1, 32
420042b2:	ff83a5        	call8	42003aec <esp_mprot_get_monitor_en>
420042b5:	9188      	l32i.n	a8, a1, 36
420042b7:	8198      	l32i.n	a9, a1, 32
420042b9:	b33a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
                if (!enabled) {
420042bc:	0501a2        	l8ui	a10, a1, 5
420042bf:	fdba56        	bnez	a10, 4200429e <esp_mprot_set_prot+0x742>
                        memp_config->target_cpu[x]);
420042c2:	a08820        	addx4	a8, a8, a2
                    esp_rom_printf(
420042c5:	48b8      	l32i.n	a11, a8, 16
420042c7:	f0a5a1        	l32r	a10, 4200055c <_stext+0x53c>
                        esp_rom_printf(
420042ca:	f0ad81        	l32r	a8, 42000580 <_stext+0x560>
420042cd:	0008e0        	callx8	a8
                        abort();
420042d0:	ff83c6        	j	420040e3 <esp_mprot_set_prot+0x587>
420042d3:	00          	.byte 00
            for (size_t x = 0; x < core_count; x++) {
420042d4:	881b      	addi.n	a8, a8, 1
420042d6:	994b      	addi.n	a9, a9, 4
420042d8:	023847        	bltu	a8, a4, 420042de <esp_mprot_set_prot+0x782>
420042db:	ffd746        	j	4200423c <esp_mprot_set_prot+0x6e0>
420042de:	6188      	l32i.n	a8, a1, 24
                ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_en(MEMPROT_TYPE_DRAM0_SRAM, &enabled,
420042e0:	0029c2        	l32i	a12, a9, 0
420042e3:	05c1b2        	addi	a11, a1, 5
420042e6:	02a0a2        	movi	a10, 2
420042e9:	9189      	s32i.n	a8, a1, 36
420042eb:	8199      	s32i.n	a9, a1, 32
420042ed:	ff7fe5        	call8	42003aec <esp_mprot_get_monitor_en>
420042f0:	9188      	l32i.n	a8, a1, 36
420042f2:	8198      	l32i.n	a9, a1, 32
420042f4:	af8a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
                if (!enabled) {
420042f7:	0501a2        	l8ui	a10, a1, 5
420042fa:	fd6a56        	bnez	a10, 420042d4 <esp_mprot_set_prot+0x778>
                        memp_config->target_cpu[x]);
420042fd:	a08820        	addx4	a8, a8, a2
                    esp_rom_printf(
42004300:	48b8      	l32i.n	a11, a8, 16
42004302:	f097a1        	l32r	a10, 42000560 <_stext+0x540>
42004305:	fff046        	j	420042ca <esp_mprot_set_prot+0x76e>
42004308:	087d      	mov.n	a7, a8
4200430a:	ffdac6        	j	42004279 <esp_mprot_set_prot+0x71d>
                for (size_t x = 0; x < core_count; x++) {
4200430d:	771b      	addi.n	a7, a7, 1
4200430f:	994b      	addi.n	a9, a9, 4
42004311:	f33747        	bltu	a7, a4, 42004308 <esp_mprot_set_prot+0x7ac>
            if (use_dram0) {
42004314:	05c516        	beqz	a5, 42004374 <esp_mprot_set_prot+0x818>
    return REG_READ(SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG) == 1;
42004317:	f08351        	l32r	a5, 42000524 <_stext+0x504>
                    esp_rom_printf(
4200431a:	f095a1        	l32r	a10, 42000570 <_stext+0x550>
4200431d:	0020c0        	memw
42004320:	0558      	l32i.n	a5, a5, 0
                if (!locked) {
42004322:	1a1566        	bnei	a5, 1, 42004340 <esp_mprot_set_prot+0x7e4>
    return REG_READ(SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG) == 1;
42004325:	f06771        	l32r	a7, 420004c4 <_stext+0x4a4>
42004328:	080c      	movi.n	a8, 0
4200432a:	0020c0        	memw
4200432d:	0778      	l32i.n	a7, a7, 0
4200432f:	970b      	addi.n	a9, a7, -1
42004331:	935890        	movnez	a5, a8, a9
42004334:	044152        	s8i	a5, a1, 4
                if (!locked) {
42004337:	10c252        	addi	a5, a2, 16
4200433a:	0e1726        	beqi	a7, 1, 4200434c <esp_mprot_set_prot+0x7f0>
                    esp_rom_printf(
4200433d:	f08da1        	l32r	a10, 42000574 <_stext+0x554>
42004340:	f09081        	l32r	a8, 42000580 <_stext+0x560>
42004343:	0008e0        	callx8	a8
                    abort();
42004346:	ff6646        	j	420040e3 <esp_mprot_set_prot+0x587>
42004349:	00          	.byte 00
4200434a:	076d      	mov.n	a6, a7
                    ESP_MEMPROT_ERR_CHECK(ret, esp_mprot_get_monitor_lock(MEMPROT_TYPE_DRAM0_SRAM, &locked,
4200434c:	0025c2        	l32i	a12, a5, 0
4200434f:	04c1b2        	addi	a11, a1, 4
42004352:	02a0a2        	movi	a10, 2
42004355:	ff6625        	call8	420039b8 <esp_mprot_get_monitor_lock>
42004358:	a94a56        	bnez	a10, 42003df0 <esp_mprot_set_prot+0x294>
                    if (!locked) {
4200435b:	040182        	l8ui	a8, a1, 4
4200435e:	b8cc      	bnez.n	a8, 4200436d <esp_mprot_set_prot+0x811>
                            memp_config->target_cpu[x]);
42004360:	a06620        	addx4	a6, a6, a2
                        esp_rom_printf(
42004363:	46b8      	l32i.n	a11, a6, 16
42004365:	f084a1        	l32r	a10, 42000578 <_stext+0x558>
42004368:	ffd786        	j	420042ca <esp_mprot_set_prot+0x76e>
4200436b:	00          	.byte 00
4200436c:	00          	.byte 00
                for (size_t x = 0; x < core_count; x++) {
4200436d:	661b      	addi.n	a6, a6, 1
4200436f:	554b      	addi.n	a5, a5, 4
42004371:	d53647        	bltu	a6, a4, 4200434a <esp_mprot_set_prot+0x7ee>
        s_memp_cfg = *memp_config;
42004374:	f047a1        	l32r	a10, 42000490 <_stext+0x470>
42004377:	8c1c      	movi.n	a12, 24
42004379:	02bd      	mov.n	a11, a2
4200437b:	ef9481        	l32r	a8, 420001cc <_stext+0x1ac>
4200437e:	0008e0        	callx8	a8
    return ret;
42004381:	fe11c6        	j	42003bcc <esp_mprot_set_prot+0x70>
        return ESP_ERR_INVALID_ARG;
42004384:	02a132        	movi	a3, 0x102
42004387:	fe1046        	j	42003bcc <esp_mprot_set_prot+0x70>
4200438a:	00          	.byte 00
4200438b:	00          	.byte 00
        return ESP_ERR_NO_MEM;
4200438c:	01a132        	movi	a3, 0x101
4200438f:	fe0e46        	j	42003bcc <esp_mprot_set_prot+0x70>
42004392:	00          	.byte 00
42004393:	00          	.byte 00
        return ESP_ERR_MEMPROT_CPUID_INVALID;
42004394:	f03e31        	l32r	a3, 4200048c <_stext+0x46c>
42004397:	fe0c46        	j	42003bcc <esp_mprot_set_prot+0x70>
	...

4200439c <esp_mprot_ll_err_to_esp_err>:
#include "esp_memprot_err.h"
#include "hal/memprot_types.h"
#include "esp_memprot_types.h"

esp_err_t esp_mprot_ll_err_to_esp_err(const memprot_hal_err_t err)
{
4200439c:	004136        	entry	a1, 32
    switch (err) {
    case MEMP_HAL_OK: return ESP_OK;
    case MEMP_HAL_ERR_SPLIT_ADDR_OUT_OF_RANGE: return ESP_ERR_MEMPROT_SPLIT_ADDR_OUT_OF_RANGE;
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
    case MEMP_HAL_ERR_UNI_BLOCK_INVALID: return ESP_ERR_MEMPROT_UNIMGMT_BLOCK_INVALID;
4200439f:	f07b81        	l32r	a8, 4200058c <_stext+0x56c>
    switch (err) {
420043a2:	184226        	beqi	a2, 4, 420043be <esp_mprot_ll_err_to_esp_err+0x22>
420043a5:	1b52e6        	bgei	a2, 5, 420043c4 <esp_mprot_ll_err_to_esp_err+0x28>
420043a8:	f07781        	l32r	a8, 42000584 <_stext+0x564>
420043ab:	0f2226        	beqi	a2, 2, 420043be <esp_mprot_ll_err_to_esp_err+0x22>
    case MEMP_HAL_ERR_SPLIT_ADDR_UNALIGNED: return ESP_ERR_MEMPROT_SPLIT_ADDR_UNALIGNED;
420043ae:	f07681        	l32r	a8, 42000588 <_stext+0x568>
    switch (err) {
420043b1:	093226        	beqi	a2, 3, 420043be <esp_mprot_ll_err_to_esp_err+0x22>
420043b4:	180c      	movi.n	a8, 1
420043b6:	090c      	movi.n	a9, 0
420043b8:	838920        	moveqz	a8, a9, a2
420043bb:	608080        	neg	a8, a8
    case MEMP_HAL_ERR_WORLD_INVALID: return ESP_ERR_MEMPROT_WORLD_INVALID;
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
    default:
        return ESP_FAIL;
    }
}
420043be:	082d      	mov.n	a2, a8
420043c0:	f01d      	retw.n
420043c2:	00          	.byte 00
420043c3:	00          	.byte 00
    case MEMP_HAL_ERR_AREA_INVALID: return ESP_ERR_MEMPROT_AREA_INVALID;
420043c4:	f07481        	l32r	a8, 42000594 <_stext+0x574>
    switch (err) {
420043c7:	f35226        	beqi	a2, 5, 420043be <esp_mprot_ll_err_to_esp_err+0x22>
        return ESP_FAIL;
420043ca:	f87c      	movi.n	a8, -1
    switch (err) {
420043cc:	ee6266        	bnei	a2, 6, 420043be <esp_mprot_ll_err_to_esp_err+0x22>
    case MEMP_HAL_ERR_WORLD_INVALID: return ESP_ERR_MEMPROT_WORLD_INVALID;
420043cf:	f07081        	l32r	a8, 42000590 <_stext+0x570>
420043d2:	fffa06        	j	420043be <esp_mprot_ll_err_to_esp_err+0x22>
420043d5:	000000        	ill

420043d8 <esp_newlib_locks_init>:
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___tz_mutex;
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___dd_hash_mutex;
extern StaticSemaphore_t __attribute__((alias("s_common_mutex"))) __lock___arc4random_mutex;

void esp_newlib_locks_init(void)
{
420043d8:	006136        	entry	a1, 48
    /* Initialize the two mutexes used for the locks above.
     * Asserts below check our assumption that SemaphoreHandle_t will always
     * point to the corresponding StaticSemaphore_t structure.
     */
    SemaphoreHandle_t handle;
    handle = xSemaphoreCreateMutexStatic(&s_common_mutex);
420043db:	f06f21        	l32r	a2, 42000598 <_stext+0x578>
420043de:	1a0c      	movi.n	a10, 1
420043e0:	02bd      	mov.n	a11, a2
420043e2:	f07481        	l32r	a8, 420005b4 <_stext+0x594>
420043e5:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_mutex);
420043e8:	1112a7        	beq	a2, a10, 420043fd <esp_newlib_locks_init+0x25>
420043eb:	f06cd1        	l32r	a13, 4200059c <_stext+0x57c>
420043ee:	f06cc1        	l32r	a12, 420005a0 <_stext+0x580>
420043f1:	6ba1b2        	movi	a11, 0x16b
    handle = xSemaphoreCreateRecursiveMutexStatic(&s_common_recursive_mutex);
    assert(handle == (SemaphoreHandle_t) &s_common_recursive_mutex);
420043f4:	f06ca1        	l32r	a10, 420005a4 <_stext+0x584>
420043f7:	ef2381        	l32r	a8, 42000084 <_stext+0x64>
420043fa:	0008e0        	callx8	a8
    handle = xSemaphoreCreateRecursiveMutexStatic(&s_common_recursive_mutex);
420043fd:	f06a21        	l32r	a2, 420005a8 <_stext+0x588>
42004400:	04a0a2        	movi	a10, 4
42004403:	20b220        	or	a11, a2, a2
42004406:	f06b81        	l32r	a8, 420005b4 <_stext+0x594>
42004409:	0008e0        	callx8	a8
    assert(handle == (SemaphoreHandle_t) &s_common_recursive_mutex);
4200440c:	0d12a7        	beq	a2, a10, 4200441d <esp_newlib_locks_init+0x45>
4200440f:	f067d1        	l32r	a13, 420005ac <_stext+0x58c>
42004412:	f063c1        	l32r	a12, 420005a0 <_stext+0x580>
42004415:	6da1b2        	movi	a11, 0x16d
42004418:	fff606        	j	420043f4 <esp_newlib_locks_init+0x1c>
4200441b:	00          	.byte 00
4200441c:	00          	.byte 00
     * No access to lock variables for the purpose of ECO forward compatibility,
     * however we have an API to initialize lock variables used in the ROM.
     */
    extern void esp_rom_newlib_init_common_mutexes(_LOCK_T, _LOCK_T);
    /* See notes about ROM_NEEDS_MUTEX_OVERRIDE above */
    int magic_val = ROM_MUTEX_MAGIC;
4200441d:	f06421        	l32r	a2, 420005b0 <_stext+0x590>
    _LOCK_T magic_mutex = (_LOCK_T) &magic_val;
    esp_rom_newlib_init_common_mutexes(magic_mutex, magic_mutex);
42004420:	01bd      	mov.n	a11, a1
42004422:	01ad      	mov.n	a10, a1
    int magic_val = ROM_MUTEX_MAGIC;
42004424:	0129      	s32i.n	a2, a1, 0
    esp_rom_newlib_init_common_mutexes(magic_mutex, magic_mutex);
42004426:	f06481        	l32r	a8, 420005b8 <_stext+0x598>
42004429:	0008e0        	callx8	a8
#else // other target
#error Unsupported target
#endif
}
4200442c:	f01d      	retw.n
	...

42004430 <raise_r_stub>:
              void *pdata,
              FILE *fp,
              va_list *ap);

static void raise_r_stub(struct _reent *rptr)
{
42004430:	004136        	entry	a1, 32
    _raise_r(rptr, 0);
42004433:	00a0b2        	movi	a11, 0
42004436:	20a220        	or	a10, a2, a2
42004439:	0003e5        	call8	42004478 <_exit>
}
4200443c:	000090        	retw
	...

42004440 <esp_newlib_init>:
    ._cleanup_r = &_cleanup_r,
#endif
};

void esp_newlib_init(void)
{
42004440:	004136        	entry	a1, 32
#if CONFIG_IDF_TARGET_ESP32
    syscall_table_ptr_pro = syscall_table_ptr_app = &s_stub_table;
#elif CONFIG_IDF_TARGET_ESP32S2
    syscall_table_ptr_pro = &s_stub_table;
#elif CONFIG_IDF_TARGET_ESP32S3 || CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
    syscall_table_ptr = &s_stub_table;
42004443:	f05e81        	l32r	a8, 420005bc <_stext+0x59c>
42004446:	f05e91        	l32r	a9, 420005c0 <_stext+0x5a0>
#endif

    _GLOBAL_REENT = &s_reent;

    environ = malloc(sizeof(char*));
42004449:	4a0c      	movi.n	a10, 4
    syscall_table_ptr = &s_stub_table;
4200444b:	006892        	s32i	a9, a8, 0
    _GLOBAL_REENT = &s_reent;
4200444e:	ef3781        	l32r	a8, 4200012c <_stext+0x10c>
42004451:	f05c91        	l32r	a9, 420005c4 <_stext+0x5a4>
42004454:	006892        	s32i	a9, a8, 0
    environ = malloc(sizeof(char*));
42004457:	eefc81        	l32r	a8, 42000048 <_stext+0x28>
4200445a:	0008e0        	callx8	a8
4200445d:	f05a81        	l32r	a8, 420005c8 <_stext+0x5a8>
42004460:	08a9      	s32i.n	a10, a8, 0
    if (environ == 0) {
42004462:	4acc      	bnez.n	a10, 4200446a <esp_newlib_init+0x2a>
        // if allocation fails this early in startup process, there's nothing else other than to panic.
        abort();
42004464:	ef2e81        	l32r	a8, 4200011c <_stext+0xfc>
42004467:	0008e0        	callx8	a8
    }
    environ[0] = NULL;
4200446a:	00a082        	movi	a8, 0
4200446d:	006a82        	s32i	a8, a10, 0

    esp_newlib_locks_init();
42004470:	fff665        	call8	420043d8 <esp_newlib_locks_init>
}
42004473:	000090        	retw
	...

42004478 <_exit>:
    __errno_r(r) = ENOSYS;
    return -1;
}

static int syscall_not_implemented_aborts(void)
{
42004478:	004136        	entry	a1, 32
    abort();
4200447b:	ef2881        	l32r	a8, 4200011c <_stext+0xfc>
4200447e:	0008e0        	callx8	a8
42004481:	000000        	ill

42004484 <adjust_boot_time>:
{
42004484:	004136        	entry	a1, 32
    uint64_t boot_time = esp_time_impl_get_boot_time();
42004487:	201110        	or	a1, a1, a1
4200448a:	001d25        	call8	4200465c <esp_time_impl_get_boot_time>
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
4200448d:	205ab0        	or	a5, a10, a11
42004490:	f04f41        	l32r	a4, 420005cc <_stext+0x5ac>
    uint64_t boot_time = esp_time_impl_get_boot_time();
42004493:	0a2d      	mov.n	a2, a10
42004495:	0b3d      	mov.n	a3, a11
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
42004497:	00a556        	bnez	a5, 420044a5 <adjust_boot_time+0x21>
        s_adjtime_start_us = 0;
4200449a:	080c      	movi.n	a8, 0
4200449c:	0489      	s32i.n	a8, a4, 0
4200449e:	1489      	s32i.n	a8, a4, 4
}
420044a0:	f01d      	retw.n
420044a2:	00          	.byte 00
420044a3:	00          	.byte 00
420044a4:	00          	.byte 00
    if ((boot_time == 0) || (esp_time_impl_get_time_since_boot() < s_adjtime_start_us)) {
420044a5:	0016e5        	call8	42004614 <esp_time_impl_get_time_since_boot>
420044a8:	1468      	l32i.n	a6, a4, 4
420044aa:	0458      	l32i.n	a5, a4, 0
420044ac:	ea3b67        	bltu	a11, a6, 4200449a <adjust_boot_time+0x16>
420044af:	0296b7        	bne	a6, a11, 420044b5 <adjust_boot_time+0x31>
420044b2:	e43a57        	bltu	a10, a5, 4200449a <adjust_boot_time+0x16>
    if (s_adjtime_start_us > 0) {
420044b5:	205560        	or	a5, a5, a6
420044b8:	fe4516        	beqz	a5, 420044a0 <adjust_boot_time+0x1c>
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
420044bb:	0015a5        	call8	42004614 <esp_time_impl_get_time_since_boot>
        int64_t correction = (since_boot >> ADJTIME_CORRECTION_FACTOR) - (s_adjtime_start_us >> ADJTIME_CORRECTION_FACTOR);
420044be:	14e8      	l32i.n	a14, a4, 4
420044c0:	04f8      	l32i.n	a15, a4, 0
420044c2:	016e60        	slli	a6, a14, 26
420044c5:	015b60        	slli	a5, a11, 26
420044c8:	41d6a0        	srli	a13, a10, 6
420044cb:	41f6f0        	srli	a15, a15, 6
420044ce:	20d5d0        	or	a13, a5, a13
420044d1:	20f6f0        	or	a15, a6, a15
420044d4:	c09df0        	sub	a9, a13, a15
420044d7:	4156b0        	srli	a5, a11, 6
420044da:	41e6e0        	srli	a14, a14, 6
420044dd:	160c      	movi.n	a6, 1
420044df:	023d97        	bltu	a13, a9, 420044e5 <adjust_boot_time+0x61>
420044e2:	00a062        	movi	a6, 0
420044e5:	c0c5e0        	sub	a12, a5, a14
420044e8:	c0cc60        	sub	a12, a12, a6
        if (correction > 0) {
420044eb:	051ce6        	bgei	a12, 1, 420044f4 <adjust_boot_time+0x70>
420044ee:	faec56        	bnez	a12, 420044a0 <adjust_boot_time+0x1c>
420044f1:	fab916        	beqz	a9, 420044a0 <adjust_boot_time+0x1c>
            s_adjtime_start_us = since_boot;
420044f4:	14b9      	s32i.n	a11, a4, 4
            if (s_adjtime_total_correction_us < 0) {
420044f6:	f036b1        	l32r	a11, 420005d0 <_stext+0x5b0>
            s_adjtime_start_us = since_boot;
420044f9:	04a9      	s32i.n	a10, a4, 0
            if (s_adjtime_total_correction_us < 0) {
420044fb:	1ba8      	l32i.n	a10, a11, 4
420044fd:	0b88      	l32i.n	a8, a11, 0
420044ff:	05aad6        	bgez	a10, 4200455d <adjust_boot_time+0xd9>
                if ((s_adjtime_total_correction_us + correction) >= 0) {
42004502:	989a      	add.n	a9, a8, a9
42004504:	01a062        	movi	a6, 1
42004507:	023987        	bltu	a9, a8, 4200450d <adjust_boot_time+0x89>
4200450a:	00a062        	movi	a6, 0
4200450d:	caca      	add.n	a12, a10, a12
4200450f:	c6ca      	add.n	a12, a6, a12
42004511:	017c96        	bltz	a12, 4200452c <adjust_boot_time+0xa8>
                    boot_time = boot_time + s_adjtime_total_correction_us;
42004514:	828a      	add.n	a8, a2, a8
42004516:	150c      	movi.n	a5, 1
42004518:	013827        	bltu	a8, a2, 4200451d <adjust_boot_time+0x99>
4200451b:	050c      	movi.n	a5, 0
4200451d:	a3aa      	add.n	a10, a3, a10
4200451f:	082d      	mov.n	a2, a8
                    s_adjtime_start_us = 0;
42004521:	080c      	movi.n	a8, 0
                    boot_time = boot_time + s_adjtime_total_correction_us;
42004523:	35aa      	add.n	a3, a5, a10
                    s_adjtime_start_us = 0;
42004525:	0489      	s32i.n	a8, a4, 0
42004527:	1489      	s32i.n	a8, a4, 4
42004529:	0008c6        	j	42004550 <adjust_boot_time+0xcc>
                    s_adjtime_total_correction_us += correction;
4200452c:	0b99      	s32i.n	a9, a11, 0
4200452e:	1bc9      	s32i.n	a12, a11, 4
                    boot_time -= correction;
42004530:	2f2a      	add.n	a2, a15, a2
42004532:	140c      	movi.n	a4, 1
42004534:	0232f7        	bltu	a2, a15, 4200453a <adjust_boot_time+0xb6>
42004537:	00a042        	movi	a4, 0
4200453a:	ee3a      	add.n	a14, a14, a3
4200453c:	c0d2d0        	sub	a13, a2, a13
4200453f:	44ea      	add.n	a4, a4, a14
42004541:	130c      	movi.n	a3, 1
42004543:	0132d7        	bltu	a2, a13, 42004548 <adjust_boot_time+0xc4>
42004546:	030c      	movi.n	a3, 0
42004548:	c04450        	sub	a4, a4, a5
4200454b:	0d2d      	mov.n	a2, a13
4200454d:	c03430        	sub	a3, a4, a3
            esp_time_impl_set_boot_time(boot_time);
42004550:	02ad      	mov.n	a10, a2
42004552:	20b330        	or	a11, a3, a3
42004555:	000de5        	call8	42004634 <esp_time_impl_set_boot_time>
    return boot_time;
42004558:	ffd106        	j	420044a0 <adjust_boot_time+0x1c>
4200455b:	00          	.byte 00
4200455c:	00          	.byte 00
                if ((s_adjtime_total_correction_us - correction) <= 0) {
4200455d:	c06890        	sub	a6, a8, a9
42004560:	1d0c      	movi.n	a13, 1
42004562:	023867        	bltu	a8, a6, 42004568 <adjust_boot_time+0xe4>
42004565:	00a0d2        	movi	a13, 0
42004568:	c05ac0        	sub	a5, a10, a12
4200456b:	c055d0        	sub	a5, a5, a13
4200456e:	0515e6        	bgei	a5, 1, 42004577 <adjust_boot_time+0xf3>
42004571:	f9f556        	bnez	a5, 42004514 <adjust_boot_time+0x90>
42004574:	f9c616        	beqz	a6, 42004514 <adjust_boot_time+0x90>
                    s_adjtime_total_correction_us -= correction;
42004577:	0b69      	s32i.n	a6, a11, 0
42004579:	1b59      	s32i.n	a5, a11, 4
                    boot_time += correction;
4200457b:	929a      	add.n	a9, a2, a9
4200457d:	140c      	movi.n	a4, 1
4200457f:	013927        	bltu	a9, a2, 42004584 <adjust_boot_time+0x100>
42004582:	040c      	movi.n	a4, 0
42004584:	c3ca      	add.n	a12, a3, a12
42004586:	092d      	mov.n	a2, a9
42004588:	34ca      	add.n	a3, a4, a12
4200458a:	fff086        	j	42004550 <adjust_boot_time+0xcc>
4200458d:	000000        	ill

42004590 <settimeofday$part$0>:

#if __BSD_VISIBLE
int adjtime (const struct timeval *, struct timeval *);
int futimes (int, const struct timeval *);
int lutimes (const char *, const struct timeval *);
int settimeofday (const struct timeval *, const struct timezone *);
42004590:	004136        	entry	a1, 32
    _lock_acquire(&s_time_lock);
42004593:	f01041        	l32r	a4, 420005d4 <_stext+0x5b4>
42004596:	20a440        	or	a10, a4, a4
42004599:	f01081        	l32r	a8, 420005dc <_stext+0x5bc>
4200459c:	0008e0        	callx8	a8
    if (s_adjtime_start_us != 0){
4200459f:	f00b31        	l32r	a3, 420005cc <_stext+0x5ac>
420045a2:	002382        	l32i	a8, a3, 0
420045a5:	012392        	l32i	a9, a3, 4
420045a8:	208890        	or	a8, a8, a9
420045ab:	788c      	beqz.n	a8, 420045b6 <settimeofday$part$0+0x26>
        adjust_boot_time();
420045ad:	ffed65        	call8	42004484 <adjust_boot_time>
        s_adjtime_start_us = 0;
420045b0:	080c      	movi.n	a8, 0
420045b2:	0389      	s32i.n	a8, a3, 0
420045b4:	1389      	s32i.n	a8, a3, 4
    _lock_release(&s_time_lock);
420045b6:	04ad      	mov.n	a10, a4
420045b8:	f00a81        	l32r	a8, 420005e0 <_stext+0x5c0>
420045bb:	0008e0        	callx8	a8
{
    (void) tz;
#if IMPL_NEWLIB_TIME_FUNCS
    if (tv) {
        adjtime_corr_stop();
        uint64_t now = ((uint64_t) tv->tv_sec) * 1000000LL + tv->tv_usec;
420045be:	f00691        	l32r	a9, 420005d8 <_stext+0x5b8>
420045c1:	0288      	l32i.n	a8, a2, 0
420045c3:	1238      	l32i.n	a3, a2, 4
420045c5:	82a890        	mull	a10, a8, a9
420045c8:	823390        	mull	a3, a3, a9
420045cb:	a28890        	muluh	a8, a8, a9
420045ce:	1b0c      	movi.n	a11, 1
420045d0:	838a      	add.n	a8, a3, a8
420045d2:	2238      	l32i.n	a3, a2, 8
420045d4:	312f30        	srai	a2, a3, 31
420045d7:	3a3a      	add.n	a3, a10, a3
420045d9:	0133a7        	bltu	a3, a10, 420045de <settimeofday$part$0+0x4e>
420045dc:	0b0c      	movi.n	a11, 0
420045de:	882a      	add.n	a8, a8, a2
420045e0:	2b8a      	add.n	a2, a11, a8
        uint64_t since_boot = esp_time_impl_get_time_since_boot();
420045e2:	000325        	call8	42004614 <esp_time_impl_get_time_since_boot>
        esp_time_impl_set_boot_time(now - since_boot);
420045e5:	c0a3a0        	sub	a10, a3, a10
420045e8:	180c      	movi.n	a8, 1
420045ea:	0233a7        	bltu	a3, a10, 420045f0 <settimeofday$part$0+0x60>
420045ed:	00a082        	movi	a8, 0
420045f0:	c0b2b0        	sub	a11, a2, a11
420045f3:	c0bb80        	sub	a11, a11, a8
420045f6:	0003e5        	call8	42004634 <esp_time_impl_set_boot_time>
    return 0;
#else
    errno = ENOSYS;
    return -1;
#endif
}
420045f9:	f01d      	retw.n
	...

420045fc <settimeofday>:
{
420045fc:	004136        	entry	a1, 32
420045ff:	02ad      	mov.n	a10, a2
    if (tv) {
42004601:	128c      	beqz.n	a2, 42004606 <settimeofday+0xa>
42004603:	fff8e5        	call8	42004590 <settimeofday$part$0>
}
42004606:	020c      	movi.n	a2, 0
42004608:	f01d      	retw.n
	...

4200460c <esp_newlib_time_init>:
    return -1;
#endif
}

void esp_newlib_time_init(void)
{
4200460c:	004136        	entry	a1, 32
    esp_time_impl_init();
4200460f:	001065        	call8	42004714 <esp_time_impl_init>
}
42004612:	f01d      	retw.n

42004614 <esp_time_impl_get_time_since_boot>:

static _lock_t s_boot_time_lock;

#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
uint64_t esp_time_impl_get_time_since_boot(void)
{
42004614:	004136        	entry	a1, 32
    uint64_t microseconds = 0;

#ifdef CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    microseconds = s_microseconds_offset + esp_system_get_time();
42004617:	eff481        	l32r	a8, 420005e8 <_stext+0x5c8>
4200461a:	0008e0        	callx8	a8
4200461d:	eff131        	l32r	a3, 420005e4 <_stext+0x5c4>
42004620:	0328      	l32i.n	a2, a3, 0
42004622:	1388      	l32i.n	a8, a3, 4
42004624:	2a2a      	add.n	a2, a10, a2
42004626:	130c      	movi.n	a3, 1
42004628:	0132a7        	bltu	a2, a10, 4200462d <esp_time_impl_get_time_since_boot+0x19>
4200462b:	030c      	movi.n	a3, 0
4200462d:	bb8a      	add.n	a11, a11, a8
#endif // CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
#elif defined(CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER)
    microseconds = esp_rtc_get_time_us();
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    return microseconds;
}
4200462f:	33ba      	add.n	a3, a3, a11
42004631:	f01d      	retw.n
	...

42004634 <esp_time_impl_set_boot_time>:

#endif // defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) || defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )


void esp_time_impl_set_boot_time(uint64_t time_us)
{
42004634:	004136        	entry	a1, 32
    _lock_acquire(&s_boot_time_lock);
42004637:	efed41        	l32r	a4, 420005ec <_stext+0x5cc>
4200463a:	04ad      	mov.n	a10, a4
4200463c:	efe881        	l32r	a8, 420005dc <_stext+0x5bc>
4200463f:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    REG_WRITE(RTC_BOOT_TIME_LOW_REG, (uint32_t) (time_us & 0xffffffff));
42004642:	efeb81        	l32r	a8, 420005f0 <_stext+0x5d0>
    REG_WRITE(RTC_BOOT_TIME_HIGH_REG, (uint32_t) (time_us >> 32));
#else
    s_boot_time = time_us;
#endif
    _lock_release(&s_boot_time_lock);
42004645:	04ad      	mov.n	a10, a4
    REG_WRITE(RTC_BOOT_TIME_LOW_REG, (uint32_t) (time_us & 0xffffffff));
42004647:	0020c0        	memw
4200464a:	0829      	s32i.n	a2, a8, 0
    REG_WRITE(RTC_BOOT_TIME_HIGH_REG, (uint32_t) (time_us >> 32));
4200464c:	efea81        	l32r	a8, 420005f4 <_stext+0x5d4>
4200464f:	0020c0        	memw
42004652:	0839      	s32i.n	a3, a8, 0
    _lock_release(&s_boot_time_lock);
42004654:	efe381        	l32r	a8, 420005e0 <_stext+0x5c0>
42004657:	0008e0        	callx8	a8
}
4200465a:	f01d      	retw.n

4200465c <esp_time_impl_get_boot_time>:

uint64_t esp_time_impl_get_boot_time(void)
{
4200465c:	004136        	entry	a1, 32
    uint64_t result;
    _lock_acquire(&s_boot_time_lock);
4200465f:	efe341        	l32r	a4, 420005ec <_stext+0x5cc>
42004662:	04ad      	mov.n	a10, a4
42004664:	efde81        	l32r	a8, 420005dc <_stext+0x5bc>
42004667:	0008e0        	callx8	a8
#ifdef CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
    result = ((uint64_t) REG_READ(RTC_BOOT_TIME_LOW_REG)) + (((uint64_t) REG_READ(RTC_BOOT_TIME_HIGH_REG)) << 32);
4200466a:	efe121        	l32r	a2, 420005f0 <_stext+0x5d0>
4200466d:	efe131        	l32r	a3, 420005f4 <_stext+0x5d4>
#else
    result = s_boot_time;
#endif
    _lock_release(&s_boot_time_lock);
42004670:	04ad      	mov.n	a10, a4
    result = ((uint64_t) REG_READ(RTC_BOOT_TIME_LOW_REG)) + (((uint64_t) REG_READ(RTC_BOOT_TIME_HIGH_REG)) << 32);
42004672:	0020c0        	memw
42004675:	0228      	l32i.n	a2, a2, 0
42004677:	0020c0        	memw
4200467a:	0338      	l32i.n	a3, a3, 0
    _lock_release(&s_boot_time_lock);
4200467c:	efd981        	l32r	a8, 420005e0 <_stext+0x5c0>
4200467f:	0008e0        	callx8	a8
    return result;
}
42004682:	f01d      	retw.n

42004684 <esp_set_time_from_rtc>:

void esp_set_time_from_rtc(void)
{
42004684:	004136        	entry	a1, 32
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    // initialize time from RTC clock
    s_microseconds_offset = esp_rtc_get_time_us() - esp_system_get_time();
42004687:	fdede5        	call8	42002564 <esp_rtc_get_time_us>
4200468a:	0a3d      	mov.n	a3, a10
4200468c:	0b2d      	mov.n	a2, a11
4200468e:	efd681        	l32r	a8, 420005e8 <_stext+0x5c8>
42004691:	0008e0        	callx8	a8
42004694:	c0a3a0        	sub	a10, a3, a10
42004697:	efd381        	l32r	a8, 420005e4 <_stext+0x5c4>
4200469a:	190c      	movi.n	a9, 1
4200469c:	0133a7        	bltu	a3, a10, 420046a1 <esp_set_time_from_rtc+0x1d>
4200469f:	090c      	movi.n	a9, 0
420046a1:	c022b0        	sub	a2, a2, a11
420046a4:	c02290        	sub	a2, a2, a9
420046a7:	08a9      	s32i.n	a10, a8, 0
420046a9:	1829      	s32i.n	a2, a8, 4
#endif // CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER && CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER
}
420046ab:	f01d      	retw.n
420046ad:	000000        	ill

420046b0 <esp_sync_timekeeping_timers>:

void esp_sync_timekeeping_timers(void)
{
420046b0:	006136        	entry	a1, 48
#if defined( CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER ) && defined( CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER )
    struct timeval tv;
    gettimeofday(&tv, NULL);
420046b3:	0b0c      	movi.n	a11, 0
420046b5:	20a110        	or	a10, a1, a1
420046b8:	095e65        	call8	4200dca0 <gettimeofday>
    settimeofday(&tv, NULL);
420046bb:	0b0c      	movi.n	a11, 0
420046bd:	01ad      	mov.n	a10, a1
420046bf:	fff3e5        	call8	420045fc <settimeofday>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
420046c2:	fdea25        	call8	42002564 <esp_rtc_get_time_us>
420046c5:	204aa0        	or	a4, a10, a10
420046c8:	203bb0        	or	a3, a11, a11
420046cb:	efc781        	l32r	a8, 420005e8 <_stext+0x5c8>
420046ce:	0008e0        	callx8	a8
420046d1:	0a2d      	mov.n	a2, a10
420046d3:	0b5d      	mov.n	a5, a11
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
420046d5:	fff865        	call8	4200465c <esp_time_impl_get_boot_time>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
420046d8:	c08420        	sub	a8, a4, a2
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
420046db:	efc2d1        	l32r	a13, 420005e4 <_stext+0x5c4>
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
420046de:	120c      	movi.n	a2, 1
420046e0:	013487        	bltu	a4, a8, 420046e5 <esp_sync_timekeeping_timers+0x35>
420046e3:	020c      	movi.n	a2, 0
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
420046e5:	0dc8      	l32i.n	a12, a13, 0
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
420046e7:	c09350        	sub	a9, a3, a5
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
420046ea:	c08c80        	sub	a8, a12, a8
    int64_t s_microseconds_offset_cur = esp_rtc_get_time_us() - esp_system_get_time();
420046ed:	c09920        	sub	a9, a9, a2
    esp_time_impl_set_boot_time(esp_time_impl_get_boot_time() + ((int64_t)s_microseconds_offset - s_microseconds_offset_cur));
420046f0:	130c      	movi.n	a3, 1
420046f2:	1d28      	l32i.n	a2, a13, 4
420046f4:	013c87        	bltu	a12, a8, 420046f9 <esp_sync_timekeeping_timers+0x49>
420046f7:	030c      	movi.n	a3, 0
420046f9:	c02290        	sub	a2, a2, a9
420046fc:	a8aa      	add.n	a10, a8, a10
420046fe:	c02230        	sub	a2, a2, a3
42004701:	130c      	movi.n	a3, 1
42004703:	013a87        	bltu	a10, a8, 42004708 <esp_sync_timekeeping_timers+0x58>
42004706:	030c      	movi.n	a3, 0
42004708:	80b2b0        	add	a11, a2, a11
4200470b:	80b3b0        	add	a11, a3, a11
4200470e:	fff265        	call8	42004634 <esp_time_impl_set_boot_time>
#endif
}
42004711:	000090        	retw

42004714 <esp_time_impl_init>:

void esp_time_impl_init(void)
{
42004714:	004136        	entry	a1, 32
    esp_set_time_from_rtc();
42004717:	fff6e5        	call8	42004684 <esp_set_time_from_rtc>
}
4200471a:	f01d      	retw.n

4200471c <esp_err_to_name>:
#else
    "UNKNOWN ERROR";
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

const char *esp_err_to_name(esp_err_t code)
{
4200471c:	004136        	entry	a1, 32
#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP
    size_t i;

    for (i = 0; i < sizeof(esp_err_msg_table)/sizeof(esp_err_msg_table[0]); ++i) {
4200471f:	efb791        	l32r	a9, 420005fc <_stext+0x5dc>
42004722:	080c      	movi.n	a8, 0
42004724:	09bd      	mov.n	a11, a9
42004726:	d0a0a2        	movi	a10, 208
42004729:	0f8a76        	loop	a10, 4200473c <esp_err_to_name+0x20>
        if (esp_err_msg_table[i].code == code) {
4200472c:	09c8      	l32i.n	a12, a9, 0
4200472e:	069c27        	bne	a12, a2, 42004738 <esp_err_to_name+0x1c>
            return esp_err_msg_table[i].msg;
42004731:	b088b0        	addx8	a8, a8, a11
42004734:	1828      	l32i.n	a2, a8, 4
        }
    }
#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP

    return esp_unknown_msg;
}
42004736:	f01d      	retw.n
    for (i = 0; i < sizeof(esp_err_msg_table)/sizeof(esp_err_msg_table[0]); ++i) {
42004738:	881b      	addi.n	a8, a8, 1
4200473a:	998b      	addi.n	a9, a9, 8
    return esp_unknown_msg;
4200473c:	efaf21        	l32r	a2, 420005f8 <_stext+0x5d8>
4200473f:	fffcc6        	j	42004736 <esp_err_to_name+0x1a>
	...

42004744 <timer_task>:
{
42004744:	006136        	entry	a1, 48
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
42004747:	060c      	movi.n	a6, 0
42004749:	fc7c      	movi.n	a12, -1
4200474b:	1b0c      	movi.n	a11, 1
4200474d:	06ad      	mov.n	a10, a6
4200474f:	efaf81        	l32r	a8, 4200060c <_stext+0x5ec>
42004752:	0008e0        	callx8	a8
    timer_list_lock(dispatch_method);
42004755:	06ad      	mov.n	a10, a6
42004757:	efae81        	l32r	a8, 42000610 <_stext+0x5f0>
4200475a:	0008e0        	callx8	a8
    bool processed = false;
4200475d:	067d      	mov.n	a7, a6
        it = LIST_FIRST(&s_timers[dispatch_method]);
4200475f:	efa831        	l32r	a3, 42000600 <_stext+0x5e0>
42004762:	0328      	l32i.n	a2, a3, 0
        int64_t now = esp_timer_impl_get_time();
42004764:	efac81        	l32r	a8, 42000614 <_stext+0x5f4>
42004767:	0008e0        	callx8	a8
4200476a:	0a3d      	mov.n	a3, a10
4200476c:	0b8d      	mov.n	a8, a11
        if (it == NULL || it->alarm > now) {
4200476e:	0c8216        	beqz	a2, 4200483a <timer_task+0xf6>
42004771:	1298      	l32i.n	a9, a2, 4
42004773:	02e8      	l32i.n	a14, a2, 0
42004775:	02bb97        	bgeu	a11, a9, 4200477b <timer_task+0x37>
42004778:	003606        	j	42004854 <timer_task+0x110>
4200477b:	0599b7        	bne	a9, a11, 42004784 <timer_task+0x40>
4200477e:	02bae7        	bgeu	a10, a14, 42004784 <timer_task+0x40>
42004781:	0033c6        	j	42004854 <timer_task+0x110>
        LIST_REMOVE(it, list_entry);
42004784:	6278      	l32i.n	a7, a2, 24
42004786:	278c      	beqz.n	a7, 4200478c <timer_task+0x48>
42004788:	72a8      	l32i.n	a10, a2, 28
4200478a:	77a9      	s32i.n	a10, a7, 28
4200478c:	72a8      	l32i.n	a10, a2, 28
4200478e:	0a79      	s32i.n	a7, a10, 0
        if (it->event_id == EVENT_ID_DELETE_TIMER) {
42004790:	ef9d71        	l32r	a7, 42000604 <_stext+0x5e4>
42004793:	42a8      	l32i.n	a10, a2, 16
42004795:	0c9a77        	bne	a10, a7, 420047a5 <timer_task+0x61>
            free(it);
42004798:	02ad      	mov.n	a10, a2
4200479a:	ee2281        	l32r	a8, 42000024 <_stext+0x4>
4200479d:	0008e0        	callx8	a8
{
420047a0:	170c      	movi.n	a7, 1
420047a2:	ffee46        	j	4200475f <timer_task+0x1b>
            if (it->period > 0) {
420047a5:	ef98a1        	l32r	a10, 42000608 <_stext+0x5e8>
420047a8:	3278      	l32i.n	a7, a2, 12
420047aa:	22f8      	l32i.n	a15, a2, 8
420047ac:	1077a0        	and	a7, a7, a10
420047af:	20af70        	or	a10, a15, a7
420047b2:	07aa16        	beqz	a10, 42004830 <timer_task+0xec>
                if ((it->flags & FL_SKIP_UNHANDLED_EVENTS) && (skipped > 1)) {
420047b5:	0f02a2        	l8ui	a10, a2, 15
420047b8:	646a17        	bbci	a10, 1, 42004820 <timer_task+0xdc>
                int skipped = (now - it->alarm) / it->period;
420047bb:	c0a3e0        	sub	a10, a3, a14
420047be:	140c      	movi.n	a4, 1
420047c0:	0133a7        	bltu	a3, a10, 420047c5 <timer_task+0x81>
420047c3:	064d      	mov.n	a4, a6
420047c5:	c0b890        	sub	a11, a8, a9
420047c8:	0fcd      	mov.n	a12, a15
420047ca:	07dd      	mov.n	a13, a7
420047cc:	c0bb40        	sub	a11, a11, a4
420047cf:	0189      	s32i.n	a8, a1, 0
420047d1:	2199      	s32i.n	a9, a1, 8
420047d3:	11e9      	s32i.n	a14, a1, 4
420047d5:	0361f2        	s32i	a15, a1, 12
420047d8:	ee3281        	l32r	a8, 420000a0 <_stext+0x80>
420047db:	0008e0        	callx8	a8
                if ((it->flags & FL_SKIP_UNHANDLED_EVENTS) && (skipped > 1)) {
420047de:	0188      	l32i.n	a8, a1, 0
420047e0:	2198      	l32i.n	a9, a1, 8
420047e2:	11e8      	l32i.n	a14, a1, 4
420047e4:	31f8      	l32i.n	a15, a1, 12
420047e6:	362aa6        	blti	a10, 2, 42004820 <timer_task+0xdc>
                    it->alarm = now + it->period;
420047e9:	3f3a      	add.n	a3, a15, a3
420047eb:	190c      	movi.n	a9, 1
420047ed:	0133f7        	bltu	a3, a15, 420047f2 <timer_task+0xae>
420047f0:	069d      	mov.n	a9, a6
420047f2:	878a      	add.n	a8, a7, a8
420047f4:	798a      	add.n	a7, a9, a8
420047f6:	0239      	s32i.n	a3, a2, 0
420047f8:	1279      	s32i.n	a7, a2, 4
                timer_insert(it, true);
420047fa:	1b0c      	movi.n	a11, 1
420047fc:	02ad      	mov.n	a10, a2
420047fe:	ef8681        	l32r	a8, 42000618 <_stext+0x5f8>
42004801:	0008e0        	callx8	a8
            esp_timer_cb_t callback = it->callback;
42004804:	4238      	l32i.n	a3, a2, 16
            timer_list_unlock(dispatch_method);
42004806:	06ad      	mov.n	a10, a6
            void* arg = it->arg;
42004808:	5228      	l32i.n	a2, a2, 20
            timer_list_unlock(dispatch_method);
4200480a:	ef8481        	l32r	a8, 4200061c <_stext+0x5fc>
4200480d:	0008e0        	callx8	a8
            (*callback)(arg);
42004810:	02ad      	mov.n	a10, a2
42004812:	0003e0        	callx8	a3
            timer_list_lock(dispatch_method);
42004815:	06ad      	mov.n	a10, a6
42004817:	ef7e81        	l32r	a8, 42000610 <_stext+0x5f0>
4200481a:	0008e0        	callx8	a8
4200481d:	ffdfc6        	j	420047a0 <timer_task+0x5c>
                    it->alarm += it->period;
42004820:	3efa      	add.n	a3, a14, a15
42004822:	180c      	movi.n	a8, 1
42004824:	0133e7        	bltu	a3, a14, 42004829 <timer_task+0xe5>
42004827:	068d      	mov.n	a8, a6
42004829:	797a      	add.n	a7, a9, a7
4200482b:	787a      	add.n	a7, a8, a7
4200482d:	fff146        	j	420047f6 <timer_task+0xb2>
                it->alarm = 0;
42004830:	040c      	movi.n	a4, 0
42004832:	0249      	s32i.n	a4, a2, 0
42004834:	1249      	s32i.n	a4, a2, 4
42004836:	fff286        	j	42004804 <timer_task+0xc0>
42004839:	00          	.byte 00
        if (processed) {
4200483a:	a78c      	beqz.n	a7, 42004848 <timer_task+0x104>
            esp_timer_impl_set_alarm_id(UINT64_MAX, dispatch_method);
4200483c:	fa7c      	movi.n	a10, -1
4200483e:	06cd      	mov.n	a12, a6
42004840:	0abd      	mov.n	a11, a10
42004842:	ef7781        	l32r	a8, 42000620 <_stext+0x600>
42004845:	0008e0        	callx8	a8
    timer_list_unlock(dispatch_method);
42004848:	06ad      	mov.n	a10, a6
4200484a:	ef7481        	l32r	a8, 4200061c <_stext+0x5fc>
4200484d:	0008e0        	callx8	a8
    return processed;
42004850:	ffbd46        	j	42004749 <timer_task+0x5>
42004853:	00          	.byte 00
            esp_timer_impl_set_alarm_id(it->alarm, dispatch_method);
42004854:	06cd      	mov.n	a12, a6
42004856:	0ead      	mov.n	a10, a14
42004858:	09bd      	mov.n	a11, a9
4200485a:	fff906        	j	42004842 <timer_task+0xfe>
4200485d:	000000        	ill

42004860 <esp_timer_early_init>:
{
    return s_timer_task != NULL;
}

esp_err_t esp_timer_early_init(void)
{
42004860:	004136        	entry	a1, 32
    esp_timer_impl_early_init();
42004863:	000b65        	call8	42004918 <esp_timer_impl_early_init>
#if CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER
    esp_timer_impl_init_system_time();
42004866:	0006a5        	call8	420048d0 <esp_timer_impl_init_system_time>
#endif
    return ESP_OK;
}
42004869:	00a022        	movi	a2, 0
4200486c:	000090        	retw
	...

42004870 <esp_timer_init>:

esp_err_t esp_timer_init(void)
{
42004870:	006136        	entry	a1, 48
    return s_timer_task != NULL;
42004873:	ef6c21        	l32r	a2, 42000624 <_stext+0x604>
    esp_err_t err;
    if (is_initialized()) {
        return ESP_ERR_INVALID_STATE;
42004876:	03a1a2        	movi	a10, 0x103
    if (is_initialized()) {
42004879:	02d8      	l32i.n	a13, a2, 0
4200487b:	edec      	bnez.n	a13, 420048ad <esp_timer_init+0x3d>
    }

    int ret = xTaskCreatePinnedToCore(&timer_task, "esp_timer",
4200487d:	1c0c      	movi.n	a12, 1
4200487f:	ef6ab1        	l32r	a11, 42000628 <_stext+0x608>
42004882:	ef6aa1        	l32r	a10, 4200062c <_stext+0x60c>
42004885:	01d9      	s32i.n	a13, a1, 0
42004887:	02fd      	mov.n	a15, a2
42004889:	16a0e2        	movi	a14, 22
4200488c:	11cc40        	slli	a12, a12, 12
4200488f:	ef6981        	l32r	a8, 42000634 <_stext+0x614>
42004892:	0008e0        	callx8	a8
            ESP_TASK_TIMER_STACK, NULL, ESP_TASK_TIMER_PRIO, &s_timer_task, PRO_CPU_NUM);
    if (ret != pdPASS) {
42004895:	0b1a26        	beqi	a10, 1, 420048a4 <esp_timer_init+0x34>
    }

    return ESP_OK;

out:
    if (s_timer_task) {
42004898:	02a8      	l32i.n	a10, a2, 0
4200489a:	6adc      	bnez.n	a10, 420048b4 <esp_timer_init+0x44>
        vTaskDelete(s_timer_task);
        s_timer_task = NULL;
4200489c:	01a1a2        	movi	a10, 0x101
4200489f:	000286        	j	420048ad <esp_timer_init+0x3d>
420048a2:	00          	.byte 00
420048a3:	00          	.byte 00
    err = esp_timer_impl_init(&timer_alarm_handler);
420048a4:	ef63a1        	l32r	a10, 42000630 <_stext+0x610>
420048a7:	000c25        	call8	42004968 <esp_timer_impl_init>
    if (err != ESP_OK) {
420048aa:	feaa56        	bnez	a10, 42004898 <esp_timer_init+0x28>
    }

    return ESP_ERR_NO_MEM;
}
420048ad:	0a2d      	mov.n	a2, a10
420048af:	f01d      	retw.n
420048b1:	00          	.byte 00
420048b2:	00          	.byte 00
420048b3:	00          	.byte 00
        vTaskDelete(s_timer_task);
420048b4:	ef6181        	l32r	a8, 42000638 <_stext+0x618>
420048b7:	0008e0        	callx8	a8
        s_timer_task = NULL;
420048ba:	080c      	movi.n	a8, 0
420048bc:	0289      	s32i.n	a8, a2, 0
420048be:	fff686        	j	4200489c <esp_timer_init+0x2c>
420048c1:	000000        	ill

420048c4 <__esp_system_init_fn_esp_timer_startup_init>:

ESP_SYSTEM_INIT_FN(esp_timer_startup_init, BIT(0), 100)
{
420048c4:	004136        	entry	a1, 32
    return esp_timer_init();
420048c7:	fffaa5        	call8	42004870 <esp_timer_init>
}
420048ca:	0a2d      	mov.n	a2, a10
420048cc:	f01d      	retw.n
	...

420048d0 <esp_timer_impl_init_system_time>:
{
420048d0:	004136        	entry	a1, 32
    s_correction_us = esp_rtc_get_time_us() - g_startup_time - esp_timer_impl_get_time();
420048d3:	fdc925        	call8	42002564 <esp_rtc_get_time_us>
420048d6:	ef5921        	l32r	a2, 4200063c <_stext+0x61c>
420048d9:	0238      	l32i.n	a3, a2, 0
420048db:	1288      	l32i.n	a8, a2, 4
420048dd:	c03a30        	sub	a3, a10, a3
420048e0:	120c      	movi.n	a2, 1
420048e2:	023a37        	bltu	a10, a3, 420048e8 <esp_timer_impl_init_system_time+0x18>
420048e5:	00a022        	movi	a2, 0
420048e8:	c0bb80        	sub	a11, a11, a8
420048eb:	c02b20        	sub	a2, a11, a2
420048ee:	ef4981        	l32r	a8, 42000614 <_stext+0x5f4>
420048f1:	0008e0        	callx8	a8
420048f4:	c0a3a0        	sub	a10, a3, a10
420048f7:	ef5281        	l32r	a8, 42000640 <_stext+0x620>
420048fa:	190c      	movi.n	a9, 1
420048fc:	0133a7        	bltu	a3, a10, 42004901 <esp_timer_impl_init_system_time+0x31>
420048ff:	090c      	movi.n	a9, 0
42004901:	c022b0        	sub	a2, a2, a11
42004904:	0068a2        	s32i	a10, a8, 0
    esp_err_t err = esp_register_shutdown_handler(esp_sync_timekeeping_timers);
42004907:	ef4fa1        	l32r	a10, 42000644 <_stext+0x624>
    s_correction_us = esp_rtc_get_time_us() - g_startup_time - esp_timer_impl_get_time();
4200490a:	c02290        	sub	a2, a2, a9
4200490d:	016822        	s32i	a2, a8, 4
    esp_err_t err = esp_register_shutdown_handler(esp_sync_timekeeping_timers);
42004910:	1426e5        	call8	42018b80 <esp_register_shutdown_handler>
}
42004913:	000090        	retw
	...

42004918 <esp_timer_impl_early_init>:
    systimer_hal_counter_value_advance(&systimer_hal, SYSTIMER_LL_COUNTER_CLOCK, time_diff_us);
    portEXIT_CRITICAL_SAFE(&s_time_update_lock);
}

esp_err_t esp_timer_impl_early_init(void)
{
42004918:	006136        	entry	a1, 48
    periph_module_enable(PERIPH_SYSTIMER_MODULE);
4200491b:	4a2c      	movi.n	a10, 36
4200491d:	fe5ea5        	call8	42002f08 <periph_module_enable>
    systimer_hal_tick_rate_ops_t ops = {
42004920:	ef4a21        	l32r	a2, 42000648 <_stext+0x628>
42004923:	0288      	l32i.n	a8, a2, 0
42004925:	1228      	l32i.n	a2, a2, 4
42004927:	0189      	s32i.n	a8, a1, 0
42004929:	1129      	s32i.n	a2, a1, 4
        .ticks_to_us = systimer_ticks_to_us,
        .us_to_ticks = systimer_us_to_ticks,
    };
    systimer_hal_init(&systimer_hal);
4200492b:	ef4821        	l32r	a2, 4200064c <_stext+0x62c>
4200492e:	02ad      	mov.n	a10, a2
42004930:	ef4881        	l32r	a8, 42000650 <_stext+0x630>
42004933:	0008e0        	callx8	a8
    systimer_hal_set_tick_rate_ops(&systimer_hal, &ops);
42004936:	01bd      	mov.n	a11, a1
42004938:	02ad      	mov.n	a10, a2
4200493a:	ef4681        	l32r	a8, 42000654 <_stext+0x634>
4200493d:	0008e0        	callx8	a8
           "update the step for xtal to support other XTAL:APB frequency ratios");
    systimer_hal_set_steps_per_tick(&systimer_hal, 0, 2); // for xtal
    systimer_hal_set_steps_per_tick(&systimer_hal, 1, 1); // for pll
#endif

    systimer_hal_enable_counter(&systimer_hal, SYSTIMER_LL_COUNTER_CLOCK);
42004940:	02ad      	mov.n	a10, a2
42004942:	0b0c      	movi.n	a11, 0
42004944:	ef4581        	l32r	a8, 42000658 <_stext+0x638>
42004947:	0008e0        	callx8	a8
    systimer_hal_select_alarm_mode(&systimer_hal, SYSTIMER_LL_ALARM_CLOCK, SYSTIMER_ALARM_MODE_ONESHOT);
4200494a:	02ad      	mov.n	a10, a2
4200494c:	0c0c      	movi.n	a12, 0
4200494e:	2b0c      	movi.n	a11, 2
42004950:	ef4381        	l32r	a8, 4200065c <_stext+0x63c>
42004953:	0008e0        	callx8	a8
    systimer_hal_connect_alarm_counter(&systimer_hal, SYSTIMER_LL_ALARM_CLOCK, SYSTIMER_LL_COUNTER_CLOCK);
42004956:	02ad      	mov.n	a10, a2
42004958:	0c0c      	movi.n	a12, 0
4200495a:	2b0c      	movi.n	a11, 2
4200495c:	ef4181        	l32r	a8, 42000660 <_stext+0x640>
4200495f:	0008e0        	callx8	a8

    return ESP_OK;
}
42004962:	020c      	movi.n	a2, 0
42004964:	f01d      	retw.n
	...

42004968 <esp_timer_impl_init>:

esp_err_t esp_timer_impl_init(intr_handler_t alarm_handler)
{
42004968:	004136        	entry	a1, 32
#if SOC_SYSTIMER_INT_LEVEL
    int int_type = 0;
#else
    int int_type = ESP_INTR_FLAG_EDGE;
#endif // SOC_SYSTIMER_INT_LEVEL
    esp_err_t err = esp_intr_alloc(ETS_SYSTIMER_TARGET2_EDGE_INTR_SOURCE,
4200496b:	ef3f31        	l32r	a3, 42000668 <_stext+0x648>
    s_alarm_handler = alarm_handler;
4200496e:	ef3d41        	l32r	a4, 42000664 <_stext+0x644>
    esp_err_t err = esp_intr_alloc(ETS_SYSTIMER_TARGET2_EDGE_INTR_SOURCE,
42004971:	ef3ec1        	l32r	a12, 4200066c <_stext+0x64c>
42004974:	01a6b2        	movi	a11, 0x601
42004977:	03ed      	mov.n	a14, a3
42004979:	0d0c      	movi.n	a13, 0
4200497b:	bbba      	add.n	a11, a11, a11
4200497d:	ba3c      	movi.n	a10, 59
    s_alarm_handler = alarm_handler;
4200497f:	006422        	s32i	a2, a4, 0
    esp_err_t err = esp_intr_alloc(ETS_SYSTIMER_TARGET2_EDGE_INTR_SOURCE,
42004982:	fe20e5        	call8	42002b90 <esp_intr_alloc>
42004985:	0a2d      	mov.n	a2, a10
                                   ESP_INTR_FLAG_INTRDISABLED | ESP_INTR_FLAG_IRAM | int_type | interrupt_lvl,
                                   &timer_alarm_isr, NULL, &s_timer_interrupt_handle);

    if (err != ESP_OK) {
42004987:	041a56        	bnez	a10, 420049cc <esp_timer_impl_init+0x64>

    /* TODO: if SYSTIMER is used for anything else, access to SYSTIMER_INT_ENA_REG has to be
    * protected by a shared spinlock. Since this code runs as part of early startup, this
    * is practically not an issue.
    */
    systimer_hal_enable_alarm_int(&systimer_hal, SYSTIMER_LL_ALARM_CLOCK);
4200498a:	ef3051        	l32r	a5, 4200064c <_stext+0x62c>
4200498d:	2b0c      	movi.n	a11, 2
4200498f:	20a550        	or	a10, a5, a5
42004992:	ef3881        	l32r	a8, 42000674 <_stext+0x654>
42004995:	0008e0        	callx8	a8

    err = esp_intr_enable(s_timer_interrupt_handle);
42004998:	03a8      	l32i.n	a10, a3, 0
4200499a:	ef3781        	l32r	a8, 42000678 <_stext+0x658>
4200499d:	0008e0        	callx8	a8
420049a0:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
420049a2:	aaac      	beqz.n	a10, 420049d0 <esp_timer_impl_init+0x68>
        goto err_intr_en;
    }
    return ESP_OK;

err_intr_en:
    systimer_ll_enable_alarm(systimer_hal.dev, SYSTIMER_LL_ALARM_CLOCK, false);
420049a4:	0588      	l32i.n	a8, a5, 0
        dev->conf.val &= ~(1 << (24 - alarm_id));
420049a6:	ef3251        	l32r	a5, 42000670 <_stext+0x650>
420049a9:	0020c0        	memw
420049ac:	0898      	l32i.n	a9, a8, 0
    /* TODO: may need a spinlock, see the note related to SYSTIMER_INT_ENA_REG in systimer_hal_init */
    systimer_ll_enable_alarm_int(systimer_hal.dev, SYSTIMER_LL_ALARM_CLOCK, false);
    esp_intr_free(s_timer_interrupt_handle);
420049ae:	03a8      	l32i.n	a10, a3, 0
420049b0:	109950        	and	a9, a9, a5
420049b3:	0020c0        	memw
420049b6:	0899      	s32i.n	a9, a8, 0
        dev->int_ena.val &= ~(1 << alarm_id);
420049b8:	0020c0        	memw
420049bb:	192892        	l32i	a9, a8, 100
420049be:	b57c      	movi.n	a5, -5
420049c0:	109950        	and	a9, a9, a5
420049c3:	0020c0        	memw
420049c6:	196892        	s32i	a9, a8, 100
420049c9:	fe1de5        	call8	42002ba8 <esp_intr_free>
err_intr_alloc:
    s_alarm_handler = NULL;
420049cc:	030c      	movi.n	a3, 0
420049ce:	0439      	s32i.n	a3, a4, 0
    return err;
}
420049d0:	f01d      	retw.n
	...

420049d4 <get_local_fd>:
    }
    return vfs;
}

static inline int get_local_fd(const vfs_entry_t *vfs, int fd)
{
420049d4:	004136        	entry	a1, 32
    int local_fd = -1;
420049d7:	f87c      	movi.n	a8, -1

    if (vfs && fd_valid(fd)) {
420049d9:	f28c      	beqz.n	a2, 420049ec <get_local_fd+0x18>
420049db:	f93c      	movi.n	a9, 63
420049dd:	0b3937        	bltu	a9, a3, 420049ec <get_local_fd+0x18>
        local_fd = s_fd_table[fd].local_fd; // single read -> no locking is required
420049e0:	ef2781        	l32r	a8, 4200067c <_stext+0x65c>
420049e3:	903330        	addx2	a3, a3, a3
420049e6:	803830        	add	a3, a8, a3
420049e9:	020382        	l8ui	a8, a3, 2
    }

    return local_fd;
}
420049ec:	082d      	mov.n	a2, a8
420049ee:	f01d      	retw.n

420049f0 <translate_path>:

static const char* translate_path(const vfs_entry_t* vfs, const char* src_path)
{
420049f0:	004136        	entry	a1, 32
    assert(strncmp(src_path, vfs->path_prefix, vfs->path_prefix_len) == 0);
420049f3:	2d2242        	l32i	a4, a2, 180
420049f6:	a4a0b2        	movi	a11, 164
420049f9:	04cd      	mov.n	a12, a4
420049fb:	b2ba      	add.n	a11, a2, a11
420049fd:	03ad      	mov.n	a10, a3
420049ff:	ef2481        	l32r	a8, 42000690 <_stext+0x670>
42004a02:	0008e0        	callx8	a8
42004a05:	0a9c      	beqz.n	a10, 42004a19 <translate_path+0x29>
42004a07:	ef1fd1        	l32r	a13, 42000684 <_stext+0x664>
42004a0a:	ef1fc1        	l32r	a12, 42000688 <_stext+0x668>
42004a0d:	ef1fa1        	l32r	a10, 4200068c <_stext+0x66c>
42004a10:	2da1b2        	movi	a11, 0x12d
42004a13:	ed9c81        	l32r	a8, 42000084 <_stext+0x64>
42004a16:	0008e0        	callx8	a8
    if (strlen(src_path) == vfs->path_prefix_len) {
42004a19:	03ad      	mov.n	a10, a3
42004a1b:	ef1e81        	l32r	a8, 42000694 <_stext+0x674>
42004a1e:	0008e0        	callx8	a8
        // special case when src_path matches the path prefix exactly
        return "/";
42004a21:	ef1721        	l32r	a2, 42000680 <_stext+0x660>
    if (strlen(src_path) == vfs->path_prefix_len) {
42004a24:	0114a7        	beq	a4, a10, 42004a29 <translate_path+0x39>
    }
    return src_path + vfs->path_prefix_len;
42004a27:	234a      	add.n	a2, a3, a4
}
42004a29:	f01d      	retw.n
	...

42004a2c <esp_vfs_register_common>:
{
42004a2c:	006136        	entry	a1, 48
42004a2f:	02bd      	mov.n	a11, a2
42004a31:	032d      	mov.n	a2, a3
    if (len != LEN_PATH_PREFIX_IGNORED) {
42004a33:	260326        	beqi	a3, -1, 42004a5d <esp_vfs_register_common+0x31>
        if ((len == 1) || (len > ESP_VFS_PATH_MAX)) {
42004a36:	021366        	bnei	a3, 1, 42004a3c <esp_vfs_register_common+0x10>
42004a39:	002ac6        	j	42004ae8 <esp_vfs_register_common+0xbc>
42004a3c:	f30c      	movi.n	a3, 15
42004a3e:	02b327        	bgeu	a3, a2, 42004a44 <esp_vfs_register_common+0x18>
42004a41:	0028c6        	j	42004ae8 <esp_vfs_register_common+0xbc>
        if (len >= 2 && ((base_path[0] != '/') || (base_path[len - 1] == '/'))) {
42004a44:	1522b6        	bltui	a2, 2, 42004a5d <esp_vfs_register_common+0x31>
42004a47:	000b72        	l8ui	a7, a11, 0
42004a4a:	f32c      	movi.n	a3, 47
            return ESP_ERR_INVALID_ARG;
42004a4c:	02a182        	movi	a8, 0x102
        if (len >= 2 && ((base_path[0] != '/') || (base_path[len - 1] == '/'))) {
42004a4f:	3d9737        	bne	a7, a3, 42004a90 <esp_vfs_register_common+0x64>
42004a52:	3b2a      	add.n	a3, a11, a2
42004a54:	ffc332        	addi	a3, a3, -1
42004a57:	000332        	l8ui	a3, a3, 0
42004a5a:	321377        	beq	a3, a7, 42004a90 <esp_vfs_register_common+0x64>
    vfs_entry_t *entry = (vfs_entry_t*) malloc(sizeof(vfs_entry_t));
42004a5d:	c0a0a2        	movi	a10, 192
42004a60:	0061b2        	s32i	a11, a1, 0
42004a63:	ed7981        	l32r	a8, 42000048 <_stext+0x28>
42004a66:	0008e0        	callx8	a8
    if (entry == NULL) {
42004a69:	01b8      	l32i.n	a11, a1, 0
    vfs_entry_t *entry = (vfs_entry_t*) malloc(sizeof(vfs_entry_t));
42004a6b:	0a7d      	mov.n	a7, a10
        return ESP_ERR_NO_MEM;
42004a6d:	01a182        	movi	a8, 0x101
    if (entry == NULL) {
42004a70:	ca9c      	beqz.n	a10, 42004a90 <esp_vfs_register_common+0x64>
    for (index = 0; index < s_vfs_count; ++index) {
42004a72:	ef09a1        	l32r	a10, 42000698 <_stext+0x678>
42004a75:	ef0981        	l32r	a8, 4200069c <_stext+0x67c>
42004a78:	0ac8      	l32i.n	a12, a10, 0
42004a7a:	030c      	movi.n	a3, 0
42004a7c:	089d      	mov.n	a9, a8
42004a7e:	129c37        	bne	a12, a3, 42004a94 <esp_vfs_register_common+0x68>
        if (s_vfs_count >= VFS_MAX_COUNT) {
42004a81:	1d8c66        	bnei	a12, 8, 42004aa2 <esp_vfs_register_common+0x76>
            free(entry);
42004a84:	20a770        	or	a10, a7, a7
42004a87:	ed6781        	l32r	a8, 42000024 <_stext+0x4>
42004a8a:	0008e0        	callx8	a8
            return ESP_ERR_NO_MEM;
42004a8d:	01a182        	movi	a8, 0x101
}
42004a90:	082d      	mov.n	a2, a8
42004a92:	f01d      	retw.n
        if (s_vfs[index] == NULL) {
42004a94:	884b      	addi.n	a8, a8, 4
42004a96:	fcc8d2        	addi	a13, a8, -4
42004a99:	0dd8      	l32i.n	a13, a13, 0
42004a9b:	7d8c      	beqz.n	a13, 42004aa6 <esp_vfs_register_common+0x7a>
    for (index = 0; index < s_vfs_count; ++index) {
42004a9d:	331b      	addi.n	a3, a3, 1
42004a9f:	fff6c6        	j	42004a7e <esp_vfs_register_common+0x52>
        ++s_vfs_count;
42004aa2:	831b      	addi.n	a8, a3, 1
42004aa4:	0a89      	s32i.n	a8, a10, 0
    s_vfs[index] = entry;
42004aa6:	a08390        	addx4	a8, a3, a9
        strcpy(entry->path_prefix, base_path); // we have already verified argument length
42004aa9:	a4a0a2        	movi	a10, 164
    s_vfs[index] = entry;
42004aac:	0879      	s32i.n	a7, a8, 0
        strcpy(entry->path_prefix, base_path); // we have already verified argument length
42004aae:	a7aa      	add.n	a10, a7, a10
    if (len != LEN_PATH_PREFIX_IGNORED) {
42004ab0:	260226        	beqi	a2, -1, 42004ada <esp_vfs_register_common+0xae>
        strcpy(entry->path_prefix, base_path); // we have already verified argument length
42004ab3:	eefb81        	l32r	a8, 420006a0 <_stext+0x680>
42004ab6:	0008e0        	callx8	a8
    memcpy(&entry->vfs, vfs, sizeof(esp_vfs_t));
42004ab9:	a4a0c2        	movi	a12, 164
42004abc:	04bd      	mov.n	a11, a4
42004abe:	07ad      	mov.n	a10, a7
42004ac0:	edc381        	l32r	a8, 420001cc <_stext+0x1ac>
42004ac3:	0008e0        	callx8	a8
    return ESP_OK;
42004ac6:	080c      	movi.n	a8, 0
    entry->path_prefix_len = len;
42004ac8:	2d6722        	s32i	a2, a7, 180
    entry->ctx = ctx;
42004acb:	2e6752        	s32i	a5, a7, 184
    entry->offset = index;
42004ace:	2f6732        	s32i	a3, a7, 188
    if (vfs_index) {
42004ad1:	bb1687        	beq	a6, a8, 42004a90 <esp_vfs_register_common+0x64>
        *vfs_index = index;
42004ad4:	0639      	s32i.n	a3, a6, 0
42004ad6:	ffed86        	j	42004a90 <esp_vfs_register_common+0x64>
42004ad9:	00          	.byte 00
        bzero(entry->path_prefix, sizeof(entry->path_prefix));
42004ada:	fc0c      	movi.n	a12, 15
42004adc:	0b0c      	movi.n	a11, 0
42004ade:	edae81        	l32r	a8, 42000198 <_stext+0x178>
42004ae1:	0008e0        	callx8	a8
42004ae4:	fff446        	j	42004ab9 <esp_vfs_register_common+0x8d>
42004ae7:	00          	.byte 00
            return ESP_ERR_INVALID_ARG;
42004ae8:	02a182        	movi	a8, 0x102
42004aeb:	ffe846        	j	42004a90 <esp_vfs_register_common+0x64>
	...

42004af0 <esp_vfs_register>:
{
42004af0:	004136        	entry	a1, 32
    return esp_vfs_register_common(base_path, strlen(base_path), vfs, ctx, NULL);
42004af3:	02ad      	mov.n	a10, a2
42004af5:	eee781        	l32r	a8, 42000694 <_stext+0x674>
42004af8:	0008e0        	callx8	a8
42004afb:	0abd      	mov.n	a11, a10
42004afd:	0e0c      	movi.n	a14, 0
42004aff:	04dd      	mov.n	a13, a4
42004b01:	03cd      	mov.n	a12, a3
42004b03:	02ad      	mov.n	a10, a2
42004b05:	fff265        	call8	42004a2c <esp_vfs_register_common>
}
42004b08:	0a2d      	mov.n	a2, a10
42004b0a:	f01d      	retw.n

42004b0c <get_vfs_for_index>:
{
42004b0c:	004136        	entry	a1, 32
42004b0f:	028d      	mov.n	a8, a2
        return NULL;
42004b11:	020c      	movi.n	a2, 0
    if (index < 0 || index >= s_vfs_count) {
42004b13:	112827        	blt	a8, a2, 42004b28 <get_vfs_for_index+0x1c>
42004b16:	eee021        	l32r	a2, 42000698 <_stext+0x678>
42004b19:	0298      	l32i.n	a9, a2, 0
        return NULL;
42004b1b:	020c      	movi.n	a2, 0
    if (index < 0 || index >= s_vfs_count) {
42004b1d:	07b897        	bgeu	a8, a9, 42004b28 <get_vfs_for_index+0x1c>
        return s_vfs[index];
42004b20:	eedf21        	l32r	a2, 4200069c <_stext+0x67c>
42004b23:	a08820        	addx4	a8, a8, a2
42004b26:	0828      	l32i.n	a2, a8, 0
}
42004b28:	f01d      	retw.n
	...

42004b2c <get_vfs_for_fd>:
{
42004b2c:	004136        	entry	a1, 32
    if (fd_valid(fd)) {
42004b2f:	3fa082        	movi	a8, 63
    const vfs_entry_t *vfs = NULL;
42004b32:	00a0a2        	movi	a10, 0
    if (fd_valid(fd)) {
42004b35:	113827        	bltu	a8, a2, 42004b4a <get_vfs_for_fd+0x1e>
        const int index = s_fd_table[fd].vfs_index; // single read -> no locking is required
42004b38:	eed181        	l32r	a8, 4200067c <_stext+0x65c>
42004b3b:	902220        	addx2	a2, a2, a2
42004b3e:	802820        	add	a2, a8, a2
42004b41:	0102a2        	l8ui	a10, a2, 1
        vfs = get_vfs_for_index(index);
42004b44:	23aa00        	sext	a10, a10, 7
42004b47:	fffc65        	call8	42004b0c <get_vfs_for_index>
}
42004b4a:	0a2d      	mov.n	a2, a10
42004b4c:	f01d      	retw.n
	...

42004b50 <get_vfs_for_path>:

const vfs_entry_t* get_vfs_for_path(const char* path)
{
42004b50:	008136        	entry	a1, 64
    const vfs_entry_t* best_match = NULL;
    ssize_t best_match_prefix_len = -1;
    size_t len = strlen(path);
42004b53:	20a220        	or	a10, a2, a2
42004b56:	eecf81        	l32r	a8, 42000694 <_stext+0x674>
42004b59:	0008e0        	callx8	a8
{
42004b5c:	026d      	mov.n	a6, a2
    for (size_t i = 0; i < s_vfs_count; ++i) {
42004b5e:	eece21        	l32r	a2, 42000698 <_stext+0x678>
42004b61:	eece41        	l32r	a4, 4200069c <_stext+0x67c>
42004b64:	0228      	l32i.n	a2, a2, 0
    size_t len = strlen(path);
42004b66:	0a8d      	mov.n	a8, a10
    for (size_t i = 0; i < s_vfs_count; ++i) {
42004b68:	a02240        	addx4	a2, a2, a4
42004b6b:	0129      	s32i.n	a2, a1, 0
    const vfs_entry_t* best_match = NULL;
42004b6d:	020c      	movi.n	a2, 0
    ssize_t best_match_prefix_len = -1;
42004b6f:	f77c      	movi.n	a7, -1
42004b71:	029d      	mov.n	a9, a2
        const vfs_entry_t* vfs = s_vfs[i];
        if (!vfs || vfs->path_prefix_len == LEN_PATH_PREFIX_IGNORED) {
42004b73:	1d0c      	movi.n	a13, 1
            continue;
        }
        // match path prefix
        if (len < vfs->path_prefix_len ||
            memcmp(path, vfs->path_prefix, vfs->path_prefix_len) != 0) {
42004b75:	a4a0e2        	movi	a14, 164
            best_match = vfs;
            continue;
        }
        // if path is not equal to the prefix, expect to see a path separator
        // i.e. don't match "/data" prefix for "/data1/foo.txt" path
        if (len > vfs->path_prefix_len &&
42004b78:	ff2c      	movi.n	a15, 47
    for (size_t i = 0; i < s_vfs_count; ++i) {
42004b7a:	0138      	l32i.n	a3, a1, 0
42004b7c:	029437        	bne	a4, a3, 42004b82 <get_vfs_for_path+0x32>
            best_match_prefix_len = (ssize_t) vfs->path_prefix_len;
            best_match = vfs;
        }
    }
    return best_match;
}
42004b7f:	f01d      	retw.n
42004b81:	00          	.byte 00
        const vfs_entry_t* vfs = s_vfs[i];
42004b82:	0458      	l32i.n	a5, a4, 0
        if (!vfs || vfs->path_prefix_len == LEN_PATH_PREFIX_IGNORED) {
42004b84:	048516        	beqz	a5, 42004bd0 <get_vfs_for_path+0x80>
42004b87:	2d2532        	l32i	a3, a5, 180
        if (len < vfs->path_prefix_len ||
42004b8a:	423837        	bltu	a8, a3, 42004bd0 <get_vfs_for_path+0x80>
        if (!vfs || vfs->path_prefix_len == LEN_PATH_PREFIX_IGNORED) {
42004b8d:	b31b      	addi.n	a11, a3, 1
42004b8f:	09ad      	mov.n	a10, a9
42004b91:	83adb0        	moveqz	a10, a13, a11
        if (len < vfs->path_prefix_len ||
42004b94:	8afc      	bnez.n	a10, 42004bd0 <get_vfs_for_path+0x80>
            memcmp(path, vfs->path_prefix, vfs->path_prefix_len) != 0) {
42004b96:	b5ea      	add.n	a11, a5, a14
42004b98:	03cd      	mov.n	a12, a3
42004b9a:	06ad      	mov.n	a10, a6
42004b9c:	1189      	s32i.n	a8, a1, 4
42004b9e:	2199      	s32i.n	a9, a1, 8
42004ba0:	31d9      	s32i.n	a13, a1, 12
42004ba2:	41e9      	s32i.n	a14, a1, 16
42004ba4:	51f9      	s32i.n	a15, a1, 20
42004ba6:	eebf81        	l32r	a8, 420006a4 <_stext+0x684>
42004ba9:	0008e0        	callx8	a8
        if (len < vfs->path_prefix_len ||
42004bac:	1188      	l32i.n	a8, a1, 4
42004bae:	2198      	l32i.n	a9, a1, 8
42004bb0:	31d8      	l32i.n	a13, a1, 12
42004bb2:	41e8      	l32i.n	a14, a1, 16
42004bb4:	51f8      	l32i.n	a15, a1, 20
42004bb6:	6adc      	bnez.n	a10, 42004bd0 <get_vfs_for_path+0x80>
        if (vfs->path_prefix_len == 0 && !best_match) {
42004bb8:	20a230        	or	a10, a2, a3
42004bbb:	fa8c      	beqz.n	a10, 42004bce <get_vfs_for_path+0x7e>
        if (len > vfs->path_prefix_len &&
42004bbd:	08b387        	bgeu	a3, a8, 42004bc9 <get_vfs_for_path+0x79>
                path[vfs->path_prefix_len] != '/') {
42004bc0:	80a630        	add	a10, a6, a3
        if (len > vfs->path_prefix_len &&
42004bc3:	000aa2        	l8ui	a10, a10, 0
42004bc6:	069af7        	bne	a10, a15, 42004bd0 <get_vfs_for_path+0x80>
        if (best_match_prefix_len < (ssize_t) vfs->path_prefix_len) {
42004bc9:	03a737        	bge	a7, a3, 42004bd0 <get_vfs_for_path+0x80>
42004bcc:	037d      	mov.n	a7, a3
42004bce:	052d      	mov.n	a2, a5
    for (size_t i = 0; i < s_vfs_count; ++i) {
42004bd0:	444b      	addi.n	a4, a4, 4
42004bd2:	ffe906        	j	42004b7a <get_vfs_for_path+0x2a>
42004bd5:	000000        	ill

42004bd8 <_open_r>:
    } else { \
        ret = (*pvfs->vfs.func)(__VA_ARGS__);\
    }

int esp_vfs_open(struct _reent *r, const char * path, int flags, int mode)
{
42004bd8:	004136        	entry	a1, 32
    const vfs_entry_t *vfs = get_vfs_for_path(path);
42004bdb:	20a330        	or	a10, a3, a3
42004bde:	fff725        	call8	42004b50 <get_vfs_for_path>
{
42004be1:	207220        	or	a7, a2, a2
    const vfs_entry_t *vfs = get_vfs_for_path(path);
42004be4:	206aa0        	or	a6, a10, a10
    if (vfs == NULL) {
        __errno_r(r) = ENOENT;
42004be7:	220c      	movi.n	a2, 2
    if (vfs == NULL) {
42004be9:	9a8c      	beqz.n	a10, 42004bf6 <_open_r+0x1e>
        return -1;
    }
    const char *path_within_vfs = translate_path(vfs, path);
42004beb:	03bd      	mov.n	a11, a3
42004bed:	ffe025        	call8	420049f0 <translate_path>
    int fd_within_vfs;
    CHECK_AND_CALL(fd_within_vfs, r, vfs, open, path_within_vfs, flags, mode);
42004bf0:	6628      	l32i.n	a2, a6, 24
42004bf2:	72cc      	bnez.n	a2, 42004bfd <_open_r+0x25>
42004bf4:	825c      	movi.n	a2, 88
        CHECK_AND_CALL(ret, r, vfs, close, fd_within_vfs);
        (void) ret; // remove "set but not used" warning
        __errno_r(r) = ENOMEM;
        return -1;
    }
    __errno_r(r) = errno;
42004bf6:	0729      	s32i.n	a2, a7, 0
    return -1;
42004bf8:	f27c      	movi.n	a2, -1
42004bfa:	001606        	j	42004c56 <_open_r+0x7e>
    CHECK_AND_CALL(fd_within_vfs, r, vfs, open, path_within_vfs, flags, mode);
42004bfd:	0638      	l32i.n	a3, a6, 0
42004bff:	566307        	bbci	a3, 0, 42004c59 <_open_r+0x81>
42004c02:	0abd      	mov.n	a11, a10
42004c04:	2e26a2        	l32i	a10, a6, 184
42004c07:	05dd      	mov.n	a13, a5
42004c09:	04cd      	mov.n	a12, a4
42004c0b:	0002e0        	callx8	a2
42004c0e:	0a3d      	mov.n	a3, a10
    if (fd_within_vfs >= 0) {
42004c10:	07ca96        	bltz	a10, 42004c90 <_open_r+0xb8>
        _lock_acquire(&s_fd_table_lock);
42004c13:	eea541        	l32r	a4, 420006a8 <_stext+0x688>
        for (int i = 0; i < MAX_FDS; ++i) {
42004c16:	020c      	movi.n	a2, 0
        _lock_acquire(&s_fd_table_lock);
42004c18:	04ad      	mov.n	a10, a4
42004c1a:	ee7081        	l32r	a8, 420005dc <_stext+0x5bc>
42004c1d:	0008e0        	callx8	a8
        for (int i = 0; i < MAX_FDS; ++i) {
42004c20:	ee9791        	l32r	a9, 4200067c <_stext+0x65c>
42004c23:	40a0a2        	movi	a10, 64
42004c26:	208990        	or	a8, a9, a9
42004c29:	3b8a76        	loop	a10, 42004c68 <_open_r+0x90>
            if (s_fd_table[i].vfs_index == -1) {
42004c2c:	0109b2        	l8ui	a11, a9, 1
42004c2f:	23bb00        	sext	a11, a11, 7
42004c32:	2e0b66        	bnei	a11, -1, 42004c64 <_open_r+0x8c>
                s_fd_table[i].permanent = false;
42004c35:	905220        	addx2	a5, a2, a2
42004c38:	885a      	add.n	a8, a8, a5
42004c3a:	000872        	l8ui	a7, a8, 0
42004c3d:	e57c      	movi.n	a5, -2
42004c3f:	107750        	and	a7, a7, a5
                s_fd_table[i].vfs_index = vfs->offset;
42004c42:	2f2652        	l32i	a5, a6, 188
                s_fd_table[i].permanent = false;
42004c45:	004872        	s8i	a7, a8, 0
                s_fd_table[i].vfs_index = vfs->offset;
42004c48:	014852        	s8i	a5, a8, 1
                s_fd_table[i].local_fd = fd_within_vfs;
42004c4b:	024832        	s8i	a3, a8, 2
                _lock_release(&s_fd_table_lock);
42004c4e:	04ad      	mov.n	a10, a4
42004c50:	ee6481        	l32r	a8, 420005e0 <_stext+0x5c0>
42004c53:	0008e0        	callx8	a8
}
42004c56:	f01d      	retw.n
42004c58:	00          	.byte 00
    CHECK_AND_CALL(fd_within_vfs, r, vfs, open, path_within_vfs, flags, mode);
42004c59:	05cd      	mov.n	a12, a5
42004c5b:	04bd      	mov.n	a11, a4
42004c5d:	0002e0        	callx8	a2
42004c60:	ffea86        	j	42004c0e <_open_r+0x36>
42004c63:	00          	.byte 00
        for (int i = 0; i < MAX_FDS; ++i) {
42004c64:	221b      	addi.n	a2, a2, 1
42004c66:	993b      	addi.n	a9, a9, 3
        _lock_release(&s_fd_table_lock);
42004c68:	04ad      	mov.n	a10, a4
42004c6a:	ee5d81        	l32r	a8, 420005e0 <_stext+0x5c0>
42004c6d:	0008e0        	callx8	a8
        CHECK_AND_CALL(ret, r, vfs, close, fd_within_vfs);
42004c70:	7628      	l32i.n	a2, a6, 28
42004c72:	f7e216        	beqz	a2, 42004bf4 <_open_r+0x1c>
42004c75:	0648      	l32i.n	a4, a6, 0
42004c77:	0d6407        	bbci	a4, 0, 42004c88 <_open_r+0xb0>
42004c7a:	2e26a2        	l32i	a10, a6, 184
42004c7d:	03bd      	mov.n	a11, a3
42004c7f:	0002e0        	callx8	a2
        __errno_r(r) = ENOMEM;
42004c82:	c20c      	movi.n	a2, 12
42004c84:	ffdb86        	j	42004bf6 <_open_r+0x1e>
42004c87:	00          	.byte 00
        CHECK_AND_CALL(ret, r, vfs, close, fd_within_vfs);
42004c88:	03ad      	mov.n	a10, a3
42004c8a:	0002e0        	callx8	a2
42004c8d:	fffc46        	j	42004c82 <_open_r+0xaa>
    __errno_r(r) = errno;
42004c90:	04c065        	call8	42009898 <__errno>
42004c93:	0a28      	l32i.n	a2, a10, 0
42004c95:	ffd746        	j	42004bf6 <_open_r+0x1e>

42004c98 <_write_r>:

ssize_t esp_vfs_write(struct _reent *r, int fd, const void * data, size_t size)
{
42004c98:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42004c9b:	03ad      	mov.n	a10, a3
42004c9d:	ffe8e5        	call8	42004b2c <get_vfs_for_fd>
42004ca0:	0a6d      	mov.n	a6, a10
    const int local_fd = get_local_fd(vfs, fd);
42004ca2:	20b330        	or	a11, a3, a3
42004ca5:	ffd2e5        	call8	420049d4 <get_local_fd>
    if (vfs == NULL || local_fd < 0) {
42004ca8:	168c      	beqz.n	a6, 42004cad <_write_r+0x15>
42004caa:	00aad6        	bgez	a10, 42004cb8 <_write_r+0x20>
        __errno_r(r) = EBADF;
42004cad:	930c      	movi.n	a3, 9
        return -1;
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, write, local_fd, data, size);
42004caf:	0239      	s32i.n	a3, a2, 0
42004cb1:	fa7c      	movi.n	a10, -1
    return ret;
}
42004cb3:	0a2d      	mov.n	a2, a10
42004cb5:	f01d      	retw.n
42004cb7:	00          	.byte 00
    CHECK_AND_CALL(ret, r, vfs, write, local_fd, data, size);
42004cb8:	1688      	l32i.n	a8, a6, 4
42004cba:	38cc      	bnez.n	a8, 42004cc1 <_write_r+0x29>
42004cbc:	835c      	movi.n	a3, 88
42004cbe:	fffb46        	j	42004caf <_write_r+0x17>
42004cc1:	0628      	l32i.n	a2, a6, 0
42004cc3:	126207        	bbci	a2, 0, 42004cd9 <_write_r+0x41>
42004cc6:	0abd      	mov.n	a11, a10
42004cc8:	2e26a2        	l32i	a10, a6, 184
42004ccb:	20d550        	or	a13, a5, a5
42004cce:	20c440        	or	a12, a4, a4
42004cd1:	0008e0        	callx8	a8
42004cd4:	fff6c6        	j	42004cb3 <_write_r+0x1b>
42004cd7:	00          	.byte 00
42004cd8:	00          	.byte 00
42004cd9:	05cd      	mov.n	a12, a5
42004cdb:	04bd      	mov.n	a11, a4
42004cdd:	0008e0        	callx8	a8
42004ce0:	fff3c6        	j	42004cb3 <_write_r+0x1b>
	...

42004ce4 <_lseek_r>:

off_t esp_vfs_lseek(struct _reent *r, int fd, off_t size, int mode)
{
42004ce4:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42004ce7:	03ad      	mov.n	a10, a3
42004ce9:	ffe425        	call8	42004b2c <get_vfs_for_fd>
42004cec:	0a6d      	mov.n	a6, a10
    const int local_fd = get_local_fd(vfs, fd);
42004cee:	20b330        	or	a11, a3, a3
42004cf1:	ffce25        	call8	420049d4 <get_local_fd>
    if (vfs == NULL || local_fd < 0) {
42004cf4:	168c      	beqz.n	a6, 42004cf9 <_lseek_r+0x15>
42004cf6:	00aad6        	bgez	a10, 42004d04 <_lseek_r+0x20>
        __errno_r(r) = EBADF;
42004cf9:	930c      	movi.n	a3, 9
        return -1;
    }
    off_t ret;
    CHECK_AND_CALL(ret, r, vfs, lseek, local_fd, size, mode);
42004cfb:	0239      	s32i.n	a3, a2, 0
42004cfd:	fa7c      	movi.n	a10, -1
    return ret;
}
42004cff:	0a2d      	mov.n	a2, a10
42004d01:	f01d      	retw.n
42004d03:	00          	.byte 00
    CHECK_AND_CALL(ret, r, vfs, lseek, local_fd, size, mode);
42004d04:	2688      	l32i.n	a8, a6, 8
42004d06:	38cc      	bnez.n	a8, 42004d0d <_lseek_r+0x29>
42004d08:	835c      	movi.n	a3, 88
42004d0a:	fffb46        	j	42004cfb <_lseek_r+0x17>
42004d0d:	0628      	l32i.n	a2, a6, 0
42004d0f:	126207        	bbci	a2, 0, 42004d25 <_lseek_r+0x41>
42004d12:	0abd      	mov.n	a11, a10
42004d14:	2e26a2        	l32i	a10, a6, 184
42004d17:	20d550        	or	a13, a5, a5
42004d1a:	20c440        	or	a12, a4, a4
42004d1d:	0008e0        	callx8	a8
42004d20:	fff6c6        	j	42004cff <_lseek_r+0x1b>
42004d23:	00          	.byte 00
42004d24:	00          	.byte 00
42004d25:	05cd      	mov.n	a12, a5
42004d27:	04bd      	mov.n	a11, a4
42004d29:	0008e0        	callx8	a8
42004d2c:	fff3c6        	j	42004cff <_lseek_r+0x1b>
	...

42004d30 <_read_r>:

ssize_t esp_vfs_read(struct _reent *r, int fd, void * dst, size_t size)
{
42004d30:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42004d33:	03ad      	mov.n	a10, a3
42004d35:	ffdf65        	call8	42004b2c <get_vfs_for_fd>
42004d38:	0a6d      	mov.n	a6, a10
    const int local_fd = get_local_fd(vfs, fd);
42004d3a:	20b330        	or	a11, a3, a3
42004d3d:	ffc965        	call8	420049d4 <get_local_fd>
    if (vfs == NULL || local_fd < 0) {
42004d40:	168c      	beqz.n	a6, 42004d45 <_read_r+0x15>
42004d42:	00aad6        	bgez	a10, 42004d50 <_read_r+0x20>
        __errno_r(r) = EBADF;
42004d45:	930c      	movi.n	a3, 9
        return -1;
    }
    ssize_t ret;
    CHECK_AND_CALL(ret, r, vfs, read, local_fd, dst, size);
42004d47:	0239      	s32i.n	a3, a2, 0
42004d49:	fa7c      	movi.n	a10, -1
    return ret;
}
42004d4b:	0a2d      	mov.n	a2, a10
42004d4d:	f01d      	retw.n
42004d4f:	00          	.byte 00
    CHECK_AND_CALL(ret, r, vfs, read, local_fd, dst, size);
42004d50:	3688      	l32i.n	a8, a6, 12
42004d52:	38cc      	bnez.n	a8, 42004d59 <_read_r+0x29>
42004d54:	835c      	movi.n	a3, 88
42004d56:	fffb46        	j	42004d47 <_read_r+0x17>
42004d59:	0628      	l32i.n	a2, a6, 0
42004d5b:	126207        	bbci	a2, 0, 42004d71 <_read_r+0x41>
42004d5e:	0abd      	mov.n	a11, a10
42004d60:	2e26a2        	l32i	a10, a6, 184
42004d63:	20d550        	or	a13, a5, a5
42004d66:	20c440        	or	a12, a4, a4
42004d69:	0008e0        	callx8	a8
42004d6c:	fff6c6        	j	42004d4b <_read_r+0x1b>
42004d6f:	00          	.byte 00
42004d70:	00          	.byte 00
42004d71:	05cd      	mov.n	a12, a5
42004d73:	04bd      	mov.n	a11, a4
42004d75:	0008e0        	callx8	a8
42004d78:	fff3c6        	j	42004d4b <_read_r+0x1b>
	...

42004d7c <_close_r>:
    CHECK_AND_CALL(ret, r, vfs, pwrite, local_fd, src, size, offset);
    return ret;
}

int esp_vfs_close(struct _reent *r, int fd)
{
42004d7c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42004d7f:	03ad      	mov.n	a10, a3
42004d81:	ffdaa5        	call8	42004b2c <get_vfs_for_fd>
42004d84:	0a4d      	mov.n	a4, a10
    const int local_fd = get_local_fd(vfs, fd);
42004d86:	20b330        	or	a11, a3, a3
42004d89:	ffc4a5        	call8	420049d4 <get_local_fd>
    if (vfs == NULL || local_fd < 0) {
42004d8c:	148c      	beqz.n	a4, 42004d91 <_close_r+0x15>
42004d8e:	007ad6        	bgez	a10, 42004d99 <_close_r+0x1d>
        __errno_r(r) = EBADF;
42004d91:	930c      	movi.n	a3, 9
        return -1;
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
42004d93:	0239      	s32i.n	a3, a2, 0
42004d95:	f27c      	movi.n	a2, -1
            s_fd_table[fd] = FD_TABLE_ENTRY_UNUSED;
        }
    }
    _lock_release(&s_fd_table_lock);
    return ret;
}
42004d97:	f01d      	retw.n
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
42004d99:	7488      	l32i.n	a8, a4, 28
42004d9b:	38cc      	bnez.n	a8, 42004da2 <_close_r+0x26>
42004d9d:	835c      	movi.n	a3, 88
42004d9f:	fffc06        	j	42004d93 <_close_r+0x17>
42004da2:	0428      	l32i.n	a2, a4, 0
42004da4:	3d6207        	bbci	a2, 0, 42004de5 <_close_r+0x69>
42004da7:	20baa0        	or	a11, a10, a10
42004daa:	2e24a2        	l32i	a10, a4, 184
42004dad:	0008e0        	callx8	a8
    _lock_acquire(&s_fd_table_lock);
42004db0:	ee3e41        	l32r	a4, 420006a8 <_stext+0x688>
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
42004db3:	0a2d      	mov.n	a2, a10
    _lock_acquire(&s_fd_table_lock);
42004db5:	04ad      	mov.n	a10, a4
42004db7:	ee0981        	l32r	a8, 420005dc <_stext+0x5bc>
42004dba:	0008e0        	callx8	a8
    if (!s_fd_table[fd].permanent) {
42004dbd:	908330        	addx2	a8, a3, a3
42004dc0:	ee2f31        	l32r	a3, 4200067c <_stext+0x65c>
42004dc3:	338a      	add.n	a3, a3, a8
42004dc5:	000382        	l8ui	a8, a3, 0
42004dc8:	0ce807        	bbsi	a8, 0, 42004dd8 <_close_r+0x5c>
        if (s_fd_table[fd].has_pending_select) {
42004dcb:	04b280        	extui	a11, a8, 2, 1
42004dce:	ab9c      	beqz.n	a11, 42004dec <_close_r+0x70>
            s_fd_table[fd].has_pending_close = true;
42004dd0:	290c      	movi.n	a9, 2
42004dd2:	208890        	or	a8, a8, a9
42004dd5:	004382        	s8i	a8, a3, 0
    _lock_release(&s_fd_table_lock);
42004dd8:	04ad      	mov.n	a10, a4
42004dda:	ee0181        	l32r	a8, 420005e0 <_stext+0x5c0>
42004ddd:	0008e0        	callx8	a8
    return ret;
42004de0:	ffecc6        	j	42004d97 <_close_r+0x1b>
42004de3:	00          	.byte 00
42004de4:	00          	.byte 00
    CHECK_AND_CALL(ret, r, vfs, close, local_fd);
42004de5:	0008e0        	callx8	a8
42004de8:	fff106        	j	42004db0 <_close_r+0x34>
42004deb:	00          	.byte 00
            s_fd_table[fd] = FD_TABLE_ENTRY_UNUSED;
42004dec:	3c0c      	movi.n	a12, 3
42004dee:	03ad      	mov.n	a10, a3
42004df0:	ecea81        	l32r	a8, 42000198 <_stext+0x178>
42004df3:	0008e0        	callx8	a8
42004df6:	f87c      	movi.n	a8, -1
42004df8:	014382        	s8i	a8, a3, 1
42004dfb:	024382        	s8i	a8, a3, 2
42004dfe:	fff586        	j	42004dd8 <_close_r+0x5c>
42004e01:	000000        	ill

42004e04 <_fstat_r>:

int esp_vfs_fstat(struct _reent *r, int fd, struct stat * st)
{
42004e04:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_fd(fd);
42004e07:	03ad      	mov.n	a10, a3
42004e09:	ffd225        	call8	42004b2c <get_vfs_for_fd>
42004e0c:	0a5d      	mov.n	a5, a10
    const int local_fd = get_local_fd(vfs, fd);
42004e0e:	20b330        	or	a11, a3, a3
42004e11:	ffbc25        	call8	420049d4 <get_local_fd>
    if (vfs == NULL || local_fd < 0) {
42004e14:	158c      	beqz.n	a5, 42004e19 <_fstat_r+0x15>
42004e16:	00aad6        	bgez	a10, 42004e24 <_fstat_r+0x20>
        __errno_r(r) = EBADF;
42004e19:	930c      	movi.n	a3, 9
        return -1;
    }
    int ret;
    CHECK_AND_CALL(ret, r, vfs, fstat, local_fd, st);
42004e1b:	0239      	s32i.n	a3, a2, 0
42004e1d:	fa7c      	movi.n	a10, -1
    return ret;
}
42004e1f:	0a2d      	mov.n	a2, a10
42004e21:	f01d      	retw.n
42004e23:	00          	.byte 00
    CHECK_AND_CALL(ret, r, vfs, fstat, local_fd, st);
42004e24:	8588      	l32i.n	a8, a5, 32
42004e26:	38cc      	bnez.n	a8, 42004e2d <_fstat_r+0x29>
42004e28:	835c      	movi.n	a3, 88
42004e2a:	fffb46        	j	42004e1b <_fstat_r+0x17>
42004e2d:	0528      	l32i.n	a2, a5, 0
42004e2f:	0c6207        	bbci	a2, 0, 42004e3f <_fstat_r+0x3b>
42004e32:	0abd      	mov.n	a11, a10
42004e34:	2e25a2        	l32i	a10, a5, 184
42004e37:	04cd      	mov.n	a12, a4
42004e39:	0008e0        	callx8	a8
42004e3c:	fff7c6        	j	42004e1f <_fstat_r+0x1b>
42004e3f:	04bd      	mov.n	a11, a4
42004e41:	0008e0        	callx8	a8
42004e44:	fff5c6        	j	42004e1f <_fstat_r+0x1b>
	...

42004e48 <_stat_r>:
}

#ifdef CONFIG_VFS_SUPPORT_DIR

int esp_vfs_stat(struct _reent *r, const char * path, struct stat * st)
{
42004e48:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
42004e4b:	03ad      	mov.n	a10, a3
42004e4d:	ffd025        	call8	42004b50 <get_vfs_for_path>
42004e50:	0a5d      	mov.n	a5, a10
    if (vfs == NULL) {
42004e52:	8acc      	bnez.n	a10, 42004e5e <_stat_r+0x16>
        __errno_r(r) = ENOENT;
42004e54:	230c      	movi.n	a3, 2
        return -1;
    }
    const char* path_within_vfs = translate_path(vfs, path);
    int ret;
    CHECK_AND_CALL(ret, r, vfs, stat, path_within_vfs, st);
42004e56:	0239      	s32i.n	a3, a2, 0
42004e58:	fa7c      	movi.n	a10, -1
    return ret;
}
42004e5a:	0a2d      	mov.n	a2, a10
42004e5c:	f01d      	retw.n
    const char* path_within_vfs = translate_path(vfs, path);
42004e5e:	20b330        	or	a11, a3, a3
42004e61:	ffb8e5        	call8	420049f0 <translate_path>
    CHECK_AND_CALL(ret, r, vfs, stat, path_within_vfs, st);
42004e64:	092582        	l32i	a8, a5, 36
42004e67:	006856        	bnez	a8, 42004e71 <_stat_r+0x29>
42004e6a:	835c      	movi.n	a3, 88
42004e6c:	fff986        	j	42004e56 <_stat_r+0xe>
42004e6f:	00          	.byte 00
42004e70:	00          	.byte 00
42004e71:	0528      	l32i.n	a2, a5, 0
42004e73:	0d6207        	bbci	a2, 0, 42004e84 <_stat_r+0x3c>
42004e76:	0abd      	mov.n	a11, a10
42004e78:	2e25a2        	l32i	a10, a5, 184
42004e7b:	04cd      	mov.n	a12, a4
42004e7d:	0008e0        	callx8	a8
42004e80:	fff586        	j	42004e5a <_stat_r+0x12>
42004e83:	00          	.byte 00
42004e84:	04bd      	mov.n	a11, a4
42004e86:	0008e0        	callx8	a8
42004e89:	fff346        	j	42004e5a <_stat_r+0x12>

42004e8c <_link_r>:
    CHECK_AND_CALL(ret, r, vfs, utime, path_within_vfs, times);
    return ret;
}

int esp_vfs_link(struct _reent *r, const char* n1, const char* n2)
{
42004e8c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(n1);
42004e8f:	03ad      	mov.n	a10, a3
42004e91:	ffcbe5        	call8	42004b50 <get_vfs_for_path>
42004e94:	0a5d      	mov.n	a5, a10
    if (vfs == NULL) {
42004e96:	8acc      	bnez.n	a10, 42004ea2 <_link_r+0x16>
        __errno_r(r) = ENOENT;
42004e98:	230c      	movi.n	a3, 2
        return -1;
    }
    const char* path1_within_vfs = translate_path(vfs, n1);
    const char* path2_within_vfs = translate_path(vfs, n2);
    int ret;
    CHECK_AND_CALL(ret, r, vfs, link, path1_within_vfs, path2_within_vfs);
42004e9a:	0239      	s32i.n	a3, a2, 0
42004e9c:	fa7c      	movi.n	a10, -1
    return ret;
}
42004e9e:	0a2d      	mov.n	a2, a10
42004ea0:	f01d      	retw.n
    const vfs_entry_t* vfs2 = get_vfs_for_path(n2);
42004ea2:	04ad      	mov.n	a10, a4
42004ea4:	ffcaa5        	call8	42004b50 <get_vfs_for_path>
    if (vfs != vfs2) {
42004ea7:	0715a7        	beq	a5, a10, 42004eb2 <_link_r+0x26>
        __errno_r(r) = EXDEV;
42004eaa:	231c      	movi.n	a3, 18
42004eac:	fffa86        	j	42004e9a <_link_r+0xe>
42004eaf:	00          	.byte 00
42004eb0:	00          	.byte 00
42004eb1:	00          	.byte 00
    const char* path1_within_vfs = translate_path(vfs, n1);
42004eb2:	20b330        	or	a11, a3, a3
42004eb5:	20a550        	or	a10, a5, a5
42004eb8:	ffb365        	call8	420049f0 <translate_path>
42004ebb:	0a3d      	mov.n	a3, a10
    const char* path2_within_vfs = translate_path(vfs, n2);
42004ebd:	04bd      	mov.n	a11, a4
42004ebf:	05ad      	mov.n	a10, a5
42004ec1:	ffb2e5        	call8	420049f0 <translate_path>
    CHECK_AND_CALL(ret, r, vfs, link, path1_within_vfs, path2_within_vfs);
42004ec4:	a588      	l32i.n	a8, a5, 40
42004ec6:	38cc      	bnez.n	a8, 42004ecd <_link_r+0x41>
42004ec8:	835c      	movi.n	a3, 88
42004eca:	fff306        	j	42004e9a <_link_r+0xe>
42004ecd:	0528      	l32i.n	a2, a5, 0
42004ecf:	0e6207        	bbci	a2, 0, 42004ee1 <_link_r+0x55>
42004ed2:	0acd      	mov.n	a12, a10
42004ed4:	2e25a2        	l32i	a10, a5, 184
42004ed7:	03bd      	mov.n	a11, a3
42004ed9:	0008e0        	callx8	a8
42004edc:	ffef86        	j	42004e9e <_link_r+0x12>
42004edf:	00          	.byte 00
42004ee0:	00          	.byte 00
42004ee1:	0abd      	mov.n	a11, a10
42004ee3:	03ad      	mov.n	a10, a3
42004ee5:	0008e0        	callx8	a8
42004ee8:	ffec86        	j	42004e9e <_link_r+0x12>
	...

42004eec <_unlink_r>:

int esp_vfs_unlink(struct _reent *r, const char *path)
{
42004eec:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(path);
42004eef:	03ad      	mov.n	a10, a3
42004ef1:	ffc5e5        	call8	42004b50 <get_vfs_for_path>
42004ef4:	0a4d      	mov.n	a4, a10
    if (vfs == NULL) {
42004ef6:	8acc      	bnez.n	a10, 42004f02 <_unlink_r+0x16>
        __errno_r(r) = ENOENT;
42004ef8:	230c      	movi.n	a3, 2
        return -1;
    }
    const char* path_within_vfs = translate_path(vfs, path);
    int ret;
    CHECK_AND_CALL(ret, r, vfs, unlink, path_within_vfs);
42004efa:	0239      	s32i.n	a3, a2, 0
42004efc:	fa7c      	movi.n	a10, -1
    return ret;
}
42004efe:	0a2d      	mov.n	a2, a10
42004f00:	f01d      	retw.n
    const char* path_within_vfs = translate_path(vfs, path);
42004f02:	20b330        	or	a11, a3, a3
42004f05:	ffaea5        	call8	420049f0 <translate_path>
    CHECK_AND_CALL(ret, r, vfs, unlink, path_within_vfs);
42004f08:	0b2482        	l32i	a8, a4, 44
42004f0b:	005856        	bnez	a8, 42004f14 <_unlink_r+0x28>
42004f0e:	835c      	movi.n	a3, 88
42004f10:	fff986        	j	42004efa <_unlink_r+0xe>
42004f13:	00          	.byte 00
42004f14:	0428      	l32i.n	a2, a4, 0
42004f16:	0b6207        	bbci	a2, 0, 42004f25 <_unlink_r+0x39>
42004f19:	0abd      	mov.n	a11, a10
42004f1b:	2e24a2        	l32i	a10, a4, 184
42004f1e:	0008e0        	callx8	a8
42004f21:	fff646        	j	42004efe <_unlink_r+0x12>
42004f24:	00          	.byte 00
42004f25:	0008e0        	callx8	a8
42004f28:	fff486        	j	42004efe <_unlink_r+0x12>
	...

42004f2c <_rename_r>:

int esp_vfs_rename(struct _reent *r, const char *src, const char *dst)
{
42004f2c:	004136        	entry	a1, 32
    const vfs_entry_t* vfs = get_vfs_for_path(src);
42004f2f:	03ad      	mov.n	a10, a3
42004f31:	ffc1e5        	call8	42004b50 <get_vfs_for_path>
42004f34:	0a5d      	mov.n	a5, a10
    if (vfs == NULL) {
42004f36:	8acc      	bnez.n	a10, 42004f42 <_rename_r+0x16>
        __errno_r(r) = ENOENT;
42004f38:	230c      	movi.n	a3, 2
        return -1;
    }
    const char* src_within_vfs = translate_path(vfs, src);
    const char* dst_within_vfs = translate_path(vfs, dst);
    int ret;
    CHECK_AND_CALL(ret, r, vfs, rename, src_within_vfs, dst_within_vfs);
42004f3a:	0239      	s32i.n	a3, a2, 0
42004f3c:	fa7c      	movi.n	a10, -1
    return ret;
}
42004f3e:	0a2d      	mov.n	a2, a10
42004f40:	f01d      	retw.n
    const vfs_entry_t* vfs_dst = get_vfs_for_path(dst);
42004f42:	04ad      	mov.n	a10, a4
42004f44:	ffc0a5        	call8	42004b50 <get_vfs_for_path>
    if (vfs != vfs_dst) {
42004f47:	0715a7        	beq	a5, a10, 42004f52 <_rename_r+0x26>
        __errno_r(r) = EXDEV;
42004f4a:	231c      	movi.n	a3, 18
42004f4c:	fffa86        	j	42004f3a <_rename_r+0xe>
42004f4f:	00          	.byte 00
42004f50:	00          	.byte 00
42004f51:	00          	.byte 00
    const char* src_within_vfs = translate_path(vfs, src);
42004f52:	20b330        	or	a11, a3, a3
42004f55:	20a550        	or	a10, a5, a5
42004f58:	ffa965        	call8	420049f0 <translate_path>
42004f5b:	0a3d      	mov.n	a3, a10
    const char* dst_within_vfs = translate_path(vfs, dst);
42004f5d:	04bd      	mov.n	a11, a4
42004f5f:	05ad      	mov.n	a10, a5
42004f61:	ffa8e5        	call8	420049f0 <translate_path>
    CHECK_AND_CALL(ret, r, vfs, rename, src_within_vfs, dst_within_vfs);
42004f64:	c588      	l32i.n	a8, a5, 48
42004f66:	38cc      	bnez.n	a8, 42004f6d <_rename_r+0x41>
42004f68:	835c      	movi.n	a3, 88
42004f6a:	fff306        	j	42004f3a <_rename_r+0xe>
42004f6d:	0528      	l32i.n	a2, a5, 0
42004f6f:	0e6207        	bbci	a2, 0, 42004f81 <_rename_r+0x55>
42004f72:	0acd      	mov.n	a12, a10
42004f74:	2e25a2        	l32i	a10, a5, 184
42004f77:	03bd      	mov.n	a11, a3
42004f79:	0008e0        	callx8	a8
42004f7c:	ffef86        	j	42004f3e <_rename_r+0x12>
42004f7f:	00          	.byte 00
42004f80:	00          	.byte 00
42004f81:	0abd      	mov.n	a11, a10
42004f83:	03ad      	mov.n	a10, a3
42004f85:	0008e0        	callx8	a8
42004f88:	ffec86        	j	42004f3e <_rename_r+0x12>
	...

42004f8c <esp_vfs_select_triggered>:
    esp_vfs_log_fd_set("errorfds", errorfds);
    return ret;
}

void esp_vfs_select_triggered(esp_vfs_select_sem_t sem)
{
42004f8c:	006136        	entry	a1, 48
42004f8f:	0129      	s32i.n	a2, a1, 0
42004f91:	1139      	s32i.n	a3, a1, 4
    if (sem.is_sem_local) {
42004f93:	742020        	extui	a2, a2, 0, 8
{
42004f96:	03ad      	mov.n	a10, a3
    if (sem.is_sem_local) {
42004f98:	82dc      	bnez.n	a2, 42004fb4 <esp_vfs_select_triggered+0x28>
        xSemaphoreGive(sem.sem);
    } else {
        // Another way would be to go through s_fd_table and find the VFS
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
42004f9a:	edbf91        	l32r	a9, 42000698 <_stext+0x678>
42004f9d:	edbf81        	l32r	a8, 4200069c <_stext+0x67c>
42004fa0:	09b8      	l32i.n	a11, a9, 0
42004fa2:	1a12b7        	beq	a2, a11, 42004fc0 <esp_vfs_select_triggered+0x34>
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
42004fa5:	0898      	l32i.n	a9, a8, 0
            if (vfs != NULL && vfs->vfs.stop_socket_select != NULL) {
42004fa7:	799c      	beqz.n	a9, 42004fc2 <esp_vfs_select_triggered+0x36>
42004fa9:	252992        	l32i	a9, a9, 148
42004fac:	299c      	beqz.n	a9, 42004fc2 <esp_vfs_select_triggered+0x36>
                vfs->vfs.stop_socket_select(sem.sem);
42004fae:	0009e0        	callx8	a9
                break;
42004fb1:	0002c6        	j	42004fc0 <esp_vfs_select_triggered+0x34>
        xSemaphoreGive(sem.sem);
42004fb4:	0d0c      	movi.n	a13, 0
42004fb6:	0dcd      	mov.n	a12, a13
42004fb8:	0dbd      	mov.n	a11, a13
42004fba:	edbc81        	l32r	a8, 420006ac <_stext+0x68c>
42004fbd:	0008e0        	callx8	a8
            }
        }
    }
}
42004fc0:	f01d      	retw.n
        for (int i = 0; i < s_vfs_count; ++i) {
42004fc2:	221b      	addi.n	a2, a2, 1
42004fc4:	884b      	addi.n	a8, a8, 4
42004fc6:	fff606        	j	42004fa2 <esp_vfs_select_triggered+0x16>
42004fc9:	000000        	ill

42004fcc <esp_vfs_select_triggered_isr>:

void esp_vfs_select_triggered_isr(esp_vfs_select_sem_t sem, BaseType_t *woken)
{
42004fcc:	006136        	entry	a1, 48
42004fcf:	0129      	s32i.n	a2, a1, 0
42004fd1:	1139      	s32i.n	a3, a1, 4
    if (sem.is_sem_local) {
42004fd3:	742020        	extui	a2, a2, 0, 8
{
42004fd6:	03ad      	mov.n	a10, a3
42004fd8:	04bd      	mov.n	a11, a4
    if (sem.is_sem_local) {
42004fda:	a2dc      	bnez.n	a2, 42004ff8 <esp_vfs_select_triggered_isr+0x2c>
        xSemaphoreGiveFromISR(sem.sem, woken);
    } else {
        // Another way would be to go through s_fd_table and find the VFS
        // which has a permanent FD. But in order to avoid to lock
        // s_fd_table_lock we go through the VFS table.
        for (int i = 0; i < s_vfs_count; ++i) {
42004fdc:	edaf91        	l32r	a9, 42000698 <_stext+0x678>
42004fdf:	edaf81        	l32r	a8, 4200069c <_stext+0x67c>
42004fe2:	09c8      	l32i.n	a12, a9, 0
42004fe4:	1612c7        	beq	a2, a12, 42004ffe <esp_vfs_select_triggered_isr+0x32>
            // Note: s_vfs_count could have changed since the start of vfs_select() call. However, that change doesn't
            // matter here stop_socket_select() will be called for only valid VFS drivers.
            const vfs_entry_t *vfs = s_vfs[i];
42004fe7:	0898      	l32i.n	a9, a8, 0
            if (vfs != NULL && vfs->vfs.stop_socket_select_isr != NULL) {
42004fe9:	399c      	beqz.n	a9, 42005000 <esp_vfs_select_triggered_isr+0x34>
42004feb:	262992        	l32i	a9, a9, 152
42004fee:	00e916        	beqz	a9, 42005000 <esp_vfs_select_triggered_isr+0x34>
                vfs->vfs.stop_socket_select_isr(sem.sem, woken);
42004ff1:	0009e0        	callx8	a9
                break;
42004ff4:	000186        	j	42004ffe <esp_vfs_select_triggered_isr+0x32>
42004ff7:	00          	.byte 00
        xSemaphoreGiveFromISR(sem.sem, woken);
42004ff8:	edae81        	l32r	a8, 420006b0 <_stext+0x690>
42004ffb:	0008e0        	callx8	a8
            }
        }
    }
}
42004ffe:	f01d      	retw.n
        for (int i = 0; i < s_vfs_count; ++i) {
42005000:	221b      	addi.n	a2, a2, 1
42005002:	884b      	addi.n	a8, a8, 4
42005004:	fff706        	j	42004fe4 <esp_vfs_select_triggered_isr+0x18>
	...

42005008 <console_open>:
static int primary_vfs_index;

static vfs_console_context_t vfs_console= {0};

int console_open(const char * path, int flags, int mode)
{
42005008:	004136        	entry	a1, 32
// Primary port open
#if CONFIG_ESP_CONSOLE_UART
    vfs_console.fd_primary = get_vfs_for_path(primary_path)->vfs.open("/"STRINGIFY(CONFIG_ESP_CONSOLE_UART_NUM), flags, mode);
4200500b:	edaaa1        	l32r	a10, 420006b4 <_stext+0x694>
4200500e:	ffb425        	call8	42004b50 <get_vfs_for_path>
42005011:	062a22        	l32i	a2, a10, 24
42005014:	eda9a1        	l32r	a10, 420006b8 <_stext+0x698>
42005017:	20c440        	or	a12, a4, a4
4200501a:	03bd      	mov.n	a11, a3
4200501c:	0002e0        	callx8	a2
4200501f:	eda721        	l32r	a2, 420006bc <_stext+0x69c>
42005022:	02a9      	s32i.n	a10, a2, 0
    vfs_console.fd_primary = esp_vfs_cdcacm_get_vfs()->open("/", flags, mode);
#endif

// Secondary port open
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    vfs_console.fd_secondary = get_vfs_for_path(secondary_path)->vfs.open("/", flags, mode);
42005024:	eda7a1        	l32r	a10, 420006c0 <_stext+0x6a0>
42005027:	ffb2a5        	call8	42004b50 <get_vfs_for_path>
4200502a:	6a88      	l32i.n	a8, a10, 24
4200502c:	eda6a1        	l32r	a10, 420006c4 <_stext+0x6a4>
4200502f:	04cd      	mov.n	a12, a4
42005031:	03bd      	mov.n	a11, a3
42005033:	0008e0        	callx8	a8
42005036:	12a9      	s32i.n	a10, a2, 4
#endif
    return 0;
}
42005038:	020c      	movi.n	a2, 0
4200503a:	f01d      	retw.n

4200503c <console_write>:

ssize_t console_write(int fd, const void *data, size_t size)
{
4200503c:	004136        	entry	a1, 32
4200503f:	042d      	mov.n	a2, a4
    // All function calls are to primary, except from write and close, which will be forwarded to both primary and secondary.
    get_vfs_for_index(primary_vfs_index)->vfs.write(vfs_console.fd_primary, data, size);
42005041:	eda141        	l32r	a4, 420006c8 <_stext+0x6a8>
42005044:	04a8      	l32i.n	a10, a4, 0
42005046:	ffac65        	call8	42004b0c <get_vfs_for_index>
42005049:	ed9c41        	l32r	a4, 420006bc <_stext+0x69c>
4200504c:	1a88      	l32i.n	a8, a10, 4
4200504e:	04a8      	l32i.n	a10, a4, 0
42005050:	02cd      	mov.n	a12, a2
42005052:	20b330        	or	a11, a3, a3
42005055:	0008e0        	callx8	a8
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    get_vfs_for_index(secondary_vfs_index)->vfs.write(vfs_console.fd_secondary, data, size);
42005058:	ed9d81        	l32r	a8, 420006cc <_stext+0x6ac>
4200505b:	0028a2        	l32i	a10, a8, 0
4200505e:	ffaae5        	call8	42004b0c <get_vfs_for_index>
42005061:	1a88      	l32i.n	a8, a10, 4
42005063:	14a8      	l32i.n	a10, a4, 4
42005065:	02cd      	mov.n	a12, a2
42005067:	03bd      	mov.n	a11, a3
42005069:	0008e0        	callx8	a8
#endif
    return size;
}
4200506c:	f01d      	retw.n
	...

42005070 <console_fstat>:

int console_fstat(int fd, struct stat * st)
{
42005070:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.fstat(fd, st);
42005073:	ed9581        	l32r	a8, 420006c8 <_stext+0x6a8>
42005076:	08a8      	l32i.n	a10, a8, 0
42005078:	ffa925        	call8	42004b0c <get_vfs_for_index>
4200507b:	8a88      	l32i.n	a8, a10, 32
4200507d:	03bd      	mov.n	a11, a3
4200507f:	02ad      	mov.n	a10, a2
42005081:	0008e0        	callx8	a8
}
42005084:	0a2d      	mov.n	a2, a10
42005086:	f01d      	retw.n

42005088 <console_close>:

int console_close(int fd)
{
42005088:	004136        	entry	a1, 32
    // All function calls are to primary, except from write and close, which will be forwarded to both primary and secondary.
    get_vfs_for_index(primary_vfs_index)->vfs.close(vfs_console.fd_primary);
4200508b:	ed8f21        	l32r	a2, 420006c8 <_stext+0x6a8>
4200508e:	0022a2        	l32i	a10, a2, 0
42005091:	ffa7a5        	call8	42004b0c <get_vfs_for_index>
42005094:	ed8a21        	l32r	a2, 420006bc <_stext+0x69c>
42005097:	072a82        	l32i	a8, a10, 28
4200509a:	0022a2        	l32i	a10, a2, 0
4200509d:	0008e0        	callx8	a8
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    get_vfs_for_index(secondary_vfs_index)->vfs.close(vfs_console.fd_secondary);
420050a0:	ed8b81        	l32r	a8, 420006cc <_stext+0x6ac>
420050a3:	08a8      	l32i.n	a10, a8, 0
420050a5:	ffa665        	call8	42004b0c <get_vfs_for_index>
420050a8:	7a88      	l32i.n	a8, a10, 28
420050aa:	12a8      	l32i.n	a10, a2, 4
#endif
    return 0;
}
420050ac:	020c      	movi.n	a2, 0
    get_vfs_for_index(secondary_vfs_index)->vfs.close(vfs_console.fd_secondary);
420050ae:	0008e0        	callx8	a8
}
420050b1:	f01d      	retw.n
	...

420050b4 <console_read>:

ssize_t console_read(int fd, void * dst, size_t size)
{
420050b4:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.read(vfs_console.fd_primary, dst, size);
420050b7:	ed8481        	l32r	a8, 420006c8 <_stext+0x6a8>
420050ba:	0028a2        	l32i	a10, a8, 0
420050bd:	ffa4e5        	call8	42004b0c <get_vfs_for_index>
420050c0:	ed7f91        	l32r	a9, 420006bc <_stext+0x69c>
420050c3:	032a82        	l32i	a8, a10, 12
420050c6:	0029a2        	l32i	a10, a9, 0
420050c9:	04cd      	mov.n	a12, a4
420050cb:	03bd      	mov.n	a11, a3
420050cd:	0008e0        	callx8	a8
}
420050d0:	0a2d      	mov.n	a2, a10
420050d2:	f01d      	retw.n

420050d4 <console_fcntl>:

int console_fcntl(int fd, int cmd, int arg)
{
420050d4:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.fcntl(vfs_console.fd_primary, cmd, arg);
420050d7:	ed7c81        	l32r	a8, 420006c8 <_stext+0x6a8>
420050da:	0028a2        	l32i	a10, a8, 0
420050dd:	ffa2e5        	call8	42004b0c <get_vfs_for_index>
420050e0:	ed7791        	l32r	a9, 420006bc <_stext+0x69c>
420050e3:	152a82        	l32i	a8, a10, 84
420050e6:	0029a2        	l32i	a10, a9, 0
420050e9:	20c440        	or	a12, a4, a4
420050ec:	03bd      	mov.n	a11, a3
420050ee:	0008e0        	callx8	a8
}
420050f1:	0a2d      	mov.n	a2, a10
420050f3:	f01d      	retw.n
420050f5:	000000        	ill

420050f8 <console_fsync>:

int console_fsync(int fd)
{
420050f8:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.fsync(vfs_console.fd_primary);
420050fb:	ed7381        	l32r	a8, 420006c8 <_stext+0x6a8>
420050fe:	0028a2        	l32i	a10, a8, 0
42005101:	ffa0a5        	call8	42004b0c <get_vfs_for_index>
42005104:	ed6e91        	l32r	a9, 420006bc <_stext+0x69c>
42005107:	172a82        	l32i	a8, a10, 92
4200510a:	0029a2        	l32i	a10, a9, 0
4200510d:	0008e0        	callx8	a8
}
42005110:	202aa0        	or	a2, a10, a10
42005113:	f01d      	retw.n
42005115:	000000        	ill

42005118 <console_access>:

#ifdef CONFIG_VFS_SUPPORT_DIR
int console_access(const char *path, int amode)
{
42005118:	004136        	entry	a1, 32
    // currently only UART support DIR.
    return get_vfs_for_index(primary_vfs_index)->vfs.access("/"STRINGIFY(CONFIG_ESP_CONSOLE_UART_NUM), amode);
4200511b:	ed6b81        	l32r	a8, 420006c8 <_stext+0x6a8>
4200511e:	0028a2        	l32i	a10, a8, 0
42005121:	ff9ea5        	call8	42004b0c <get_vfs_for_index>
42005124:	182a82        	l32i	a8, a10, 96
42005127:	ed64a1        	l32r	a10, 420006b8 <_stext+0x698>
4200512a:	20b330        	or	a11, a3, a3
4200512d:	0008e0        	callx8	a8
}
42005130:	202aa0        	or	a2, a10, a10
42005133:	f01d      	retw.n
42005135:	000000        	ill

42005138 <console_end_select>:
{
    return get_vfs_for_index(primary_vfs_index)->vfs.start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
}

esp_err_t console_end_select(void *end_select_args)
{
42005138:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.end_select(end_select_args);
4200513b:	ed6381        	l32r	a8, 420006c8 <_stext+0x6a8>
4200513e:	0028a2        	l32i	a10, a8, 0
42005141:	ff9ca5        	call8	42004b0c <get_vfs_for_index>
42005144:	282a82        	l32i	a8, a10, 160
42005147:	20a220        	or	a10, a2, a2
4200514a:	0008e0        	callx8	a8
}
4200514d:	202aa0        	or	a2, a10, a10
42005150:	f01d      	retw.n
	...

42005154 <console_tcsetattr>:
#endif // CONFIG_VFS_SUPPORT_SELECT

#ifdef CONFIG_VFS_SUPPORT_TERMIOS

int console_tcsetattr(int fd, int optional_actions, const struct termios *p)
{
42005154:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.tcsetattr(vfs_console.fd_primary, optional_actions, p);
42005157:	ed5c81        	l32r	a8, 420006c8 <_stext+0x6a8>
4200515a:	0028a2        	l32i	a10, a8, 0
4200515d:	ff9ae5        	call8	42004b0c <get_vfs_for_index>
42005160:	ed5791        	l32r	a9, 420006bc <_stext+0x69c>
42005163:	1c2a82        	l32i	a8, a10, 112
42005166:	0029a2        	l32i	a10, a9, 0
42005169:	20c440        	or	a12, a4, a4
4200516c:	03bd      	mov.n	a11, a3
4200516e:	0008e0        	callx8	a8
}
42005171:	0a2d      	mov.n	a2, a10
42005173:	f01d      	retw.n
42005175:	000000        	ill

42005178 <console_tcgetattr>:

int console_tcgetattr(int fd, struct termios *p)
{
42005178:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.tcgetattr(vfs_console.fd_primary, p);
4200517b:	ed5381        	l32r	a8, 420006c8 <_stext+0x6a8>
4200517e:	08a8      	l32i.n	a10, a8, 0
42005180:	ff98a5        	call8	42004b0c <get_vfs_for_index>
42005183:	ed4e91        	l32r	a9, 420006bc <_stext+0x69c>
42005186:	1d2a82        	l32i	a8, a10, 116
42005189:	09a8      	l32i.n	a10, a9, 0
4200518b:	03bd      	mov.n	a11, a3
4200518d:	0008e0        	callx8	a8
}
42005190:	0a2d      	mov.n	a2, a10
42005192:	f01d      	retw.n

42005194 <console_tcdrain>:

int console_tcdrain(int fd)
{
42005194:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.tcdrain(vfs_console.fd_primary);
42005197:	ed4c81        	l32r	a8, 420006c8 <_stext+0x6a8>
4200519a:	0028a2        	l32i	a10, a8, 0
4200519d:	ff96e5        	call8	42004b0c <get_vfs_for_index>
420051a0:	ed4791        	l32r	a9, 420006bc <_stext+0x69c>
420051a3:	1e2a82        	l32i	a8, a10, 120
420051a6:	0029a2        	l32i	a10, a9, 0
420051a9:	0008e0        	callx8	a8
}
420051ac:	202aa0        	or	a2, a10, a10
420051af:	f01d      	retw.n
420051b1:	000000        	ill

420051b4 <console_tcflush>:

int console_tcflush(int fd, int select)
{
420051b4:	004136        	entry	a1, 32
    return get_vfs_for_index(primary_vfs_index)->vfs.tcflush(vfs_console.fd_primary, select);
420051b7:	ed4481        	l32r	a8, 420006c8 <_stext+0x6a8>
420051ba:	08a8      	l32i.n	a10, a8, 0
420051bc:	ff94e5        	call8	42004b0c <get_vfs_for_index>
420051bf:	ed3f91        	l32r	a9, 420006bc <_stext+0x69c>
420051c2:	1f2a82        	l32i	a8, a10, 124
420051c5:	09a8      	l32i.n	a10, a9, 0
420051c7:	03bd      	mov.n	a11, a3
420051c9:	0008e0        	callx8	a8
}
420051cc:	0a2d      	mov.n	a2, a10
420051ce:	f01d      	retw.n

420051d0 <console_start_select>:
{
420051d0:	008136        	entry	a1, 64
    return get_vfs_for_index(primary_vfs_index)->vfs.start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
420051d3:	ed3d81        	l32r	a8, 420006c8 <_stext+0x6a8>
{
420051d6:	4169      	s32i.n	a6, a1, 16
    return get_vfs_for_index(primary_vfs_index)->vfs.start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
420051d8:	08a8      	l32i.n	a10, a8, 0
{
420051da:	056172        	s32i	a7, a1, 20
    return get_vfs_for_index(primary_vfs_index)->vfs.start_select(nfds, readfds, writefds, exceptfds, select_sem, end_select_args);
420051dd:	ff92e5        	call8	42004b0c <get_vfs_for_index>
420051e0:	102182        	l32i	a8, a1, 64
420051e3:	41e8      	l32i.n	a14, a1, 16
420051e5:	0189      	s32i.n	a8, a1, 0
420051e7:	232a82        	l32i	a8, a10, 140
420051ea:	51f8      	l32i.n	a15, a1, 20
420051ec:	05dd      	mov.n	a13, a5
420051ee:	04cd      	mov.n	a12, a4
420051f0:	03bd      	mov.n	a11, a3
420051f2:	20a220        	or	a10, a2, a2
420051f5:	0008e0        	callx8	a8
}
420051f8:	0a2d      	mov.n	a2, a10
420051fa:	f01d      	retw.n

420051fc <esp_vfs_dev_console_register>:
    .tcflush = &console_tcflush,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

esp_err_t esp_vfs_dev_console_register(void)
{
420051fc:	004136        	entry	a1, 32
    return esp_vfs_register("/dev/console", &vfs, NULL);
420051ff:	ed34b1        	l32r	a11, 420006d0 <_stext+0x6b0>
42005202:	ed34a1        	l32r	a10, 420006d4 <_stext+0x6b4>
42005205:	00a0c2        	movi	a12, 0
42005208:	ff8e65        	call8	42004af0 <esp_vfs_register>
}
4200520b:	202aa0        	or	a2, a10, a10
4200520e:	000090        	retw
42005211:	000000        	ill

42005214 <esp_vfs_console_register>:

esp_err_t esp_vfs_console_register(void)
{
42005214:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
// Primary register part.
#ifdef CONFIG_ESP_CONSOLE_UART
    const esp_vfs_t *uart_vfs = esp_vfs_uart_get_vfs();
42005217:	00f125        	call8	42006128 <esp_vfs_uart_get_vfs>
    err = esp_vfs_register_common(primary_path, strlen(primary_path), uart_vfs, NULL, &primary_vfs_index);
4200521a:	0acd      	mov.n	a12, a10
4200521c:	ed2be1        	l32r	a14, 420006c8 <_stext+0x6a8>
4200521f:	ed25a1        	l32r	a10, 420006b4 <_stext+0x694>
42005222:	0d0c      	movi.n	a13, 0
42005224:	9b0c      	movi.n	a11, 9
42005226:	ff8065        	call8	42004a2c <esp_vfs_register_common>
42005229:	0a2d      	mov.n	a2, a10
    err = esp_vfs_register_common(primary_path, strlen(primary_path), cdcacm_vfs, NULL, &primary_vfs_index);
#elif CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
    const esp_vfs_t *usb_serial_jtag_vfs = esp_vfs_usb_serial_jtag_get_vfs();
    err = esp_vfs_register_common(primary_path, strlen(primary_path), usb_serial_jtag_vfs, NULL, &primary_vfs_index);
#endif // CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG
    if (err != ESP_OK) {
4200522b:	9adc      	bnez.n	a10, 42005248 <esp_vfs_console_register+0x34>
        return err;
    }

// Secondary register part.
#if CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG
    const esp_vfs_t *usb_serial_jtag_vfs = esp_vfs_usb_serial_jtag_get_vfs();
4200522d:	003425        	call8	42005570 <esp_vfs_usb_serial_jtag_get_vfs>
    err = esp_vfs_register_common(secondary_path, strlen(secondary_path), usb_serial_jtag_vfs, NULL, &secondary_vfs_index);
42005230:	0acd      	mov.n	a12, a10
42005232:	ed26e1        	l32r	a14, 420006cc <_stext+0x6ac>
42005235:	ed22a1        	l32r	a10, 420006c0 <_stext+0x6a0>
42005238:	02dd      	mov.n	a13, a2
4200523a:	eb0c      	movi.n	a11, 14
4200523c:	ff7ee5        	call8	42004a2c <esp_vfs_register_common>
4200523f:	0a2d      	mov.n	a2, a10
    if(err != ESP_OK) {
42005241:	3acc      	bnez.n	a10, 42005248 <esp_vfs_console_register+0x34>
        return err;
    }
#endif
    err = esp_vfs_dev_console_register();
42005243:	fffba5        	call8	420051fc <esp_vfs_dev_console_register>
42005246:	0a2d      	mov.n	a2, a10
    return err;
}
42005248:	f01d      	retw.n
	...

4200524c <usb_serial_jtag_open>:
    .tx_func = usb_serial_jtag_tx_char,
    .rx_func = usb_serial_jtag_rx_char
};

static int usb_serial_jtag_open(const char * path, int flags, int mode)
{
4200524c:	004136        	entry	a1, 32
    s_ctx.non_blocking = ((flags & O_NONBLOCK) == O_NONBLOCK);
4200524f:	ed2281        	l32r	a8, 420006d8 <_stext+0x6b8>
42005252:	043e30        	extui	a3, a3, 14, 1
42005255:	0c4832        	s8i	a3, a8, 12
    return 0;
}
42005258:	020c      	movi.n	a2, 0
4200525a:	f01d      	retw.n

4200525c <usb_serial_jtag_tcflush>:
    usb_serial_jtag_fsync(fd);
    return 0;
}

static int usb_serial_jtag_tcflush(int fd, int select)
{
4200525c:	004136        	entry	a1, 32
    //Flushing is not supported.
    errno = EINVAL;
4200525f:	0463a5        	call8	42009898 <__errno>
42005262:	16a082        	movi	a8, 22
42005265:	006a82        	s32i	a8, a10, 0
    return -1;
}
42005268:	ffaf22        	movi	a2, -1
4200526b:	f01d      	retw.n
4200526d:	000000        	ill

42005270 <usb_serial_jtag_fstat>:
{
42005270:	004136        	entry	a1, 32
    memset(st, 0, sizeof(*st));
42005273:	8c5c      	movi.n	a12, 88
42005275:	0b0c      	movi.n	a11, 0
42005277:	20a330        	or	a10, a3, a3
4200527a:	ebc781        	l32r	a8, 42000198 <_stext+0x178>
4200527d:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR;
42005280:	ed1781        	l32r	a8, 420006dc <_stext+0x6bc>
}
42005283:	020c      	movi.n	a2, 0
    st->st_mode = S_IFCHR;
42005285:	1389      	s32i.n	a8, a3, 4
}
42005287:	f01d      	retw.n
42005289:	000000        	ill

4200528c <usb_serial_jtag_fsync>:
{
4200528c:	004136        	entry	a1, 32
    _lock_acquire_recursive(&s_ctx.write_lock);
4200528f:	ed1431        	l32r	a3, 420006e0 <_stext+0x6c0>
42005292:	03ad      	mov.n	a10, a3
42005294:	ed1581        	l32r	a8, 420006e8 <_stext+0x6c8>
42005297:	0008e0        	callx8	a8
 *
 * @return na
 */
static inline void usb_serial_jtag_ll_txfifo_flush(void)
{
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
4200529a:	ec0d41        	l32r	a4, 420002d0 <_stext+0x2b0>
4200529d:	180c      	movi.n	a8, 1
4200529f:	0020c0        	memw
420052a2:	012422        	l32i	a2, a4, 4
420052a5:	202280        	or	a2, a2, a8
420052a8:	0020c0        	memw
420052ab:	1429      	s32i.n	a2, a4, 4
    while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US) {
420052ad:	ed0a21        	l32r	a2, 420006d8 <_stext+0x6b8>
420052b0:	ecd981        	l32r	a8, 42000614 <_stext+0x5f4>
420052b3:	0008e0        	callx8	a8
420052b6:	8288      	l32i.n	a8, a2, 32
420052b8:	92c8      	l32i.n	a12, a2, 36
420052ba:	c08a80        	sub	a8, a10, a8
420052bd:	190c      	movi.n	a9, 1
420052bf:	013a87        	bltu	a10, a8, 420052c4 <usb_serial_jtag_fsync+0x38>
420052c2:	090c      	movi.n	a9, 0
420052c4:	c0bbc0        	sub	a11, a11, a12
420052c7:	c0bb90        	sub	a11, a11, a9
420052ca:	1a1be6        	bgei	a11, 1, 420052e8 <usb_serial_jtag_fsync+0x5c>
420052cd:	4bcc      	bnez.n	a11, 420052d5 <usb_serial_jtag_fsync+0x49>
420052cf:	ed0591        	l32r	a9, 420006e4 <_stext+0x6c4>
420052d2:	123987        	bltu	a9, a8, 420052e8 <usb_serial_jtag_fsync+0x5c>
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
420052d5:	0020c0        	memw
420052d8:	012482        	l32i	a8, a4, 4
        if (usb_serial_jtag_ll_txfifo_writable()) {
420052db:	d16817        	bbci	a8, 1, 420052b0 <usb_serial_jtag_fsync+0x24>
            s_ctx.last_tx_ts = esp_timer_get_time();
420052de:	eccd81        	l32r	a8, 42000614 <_stext+0x5f4>
420052e1:	0008e0        	callx8	a8
420052e4:	82a9      	s32i.n	a10, a2, 32
420052e6:	92b9      	s32i.n	a11, a2, 36
    _lock_release_recursive(&s_ctx.write_lock);
420052e8:	03ad      	mov.n	a10, a3
420052ea:	ed0081        	l32r	a8, 420006ec <_stext+0x6cc>
420052ed:	0008e0        	callx8	a8
}
420052f0:	020c      	movi.n	a2, 0
420052f2:	f01d      	retw.n

420052f4 <usb_serial_jtag_tcdrain>:
{
420052f4:	004136        	entry	a1, 32
    usb_serial_jtag_fsync(fd);
420052f7:	02ad      	mov.n	a10, a2
420052f9:	fff925        	call8	4200528c <usb_serial_jtag_fsync>
}
420052fc:	020c      	movi.n	a2, 0
420052fe:	f01d      	retw.n

42005300 <usb_serial_jtag_write>:
{
42005300:	004136        	entry	a1, 32
    _lock_acquire_recursive(&s_ctx.write_lock);
42005303:	ecf7a1        	l32r	a10, 420006e0 <_stext+0x6c0>
42005306:	734a      	add.n	a7, a3, a4
42005308:	ecf881        	l32r	a8, 420006e8 <_stext+0x6c8>
4200530b:	0008e0        	callx8	a8
            s_ctx.tx_func(fd, '\r');
4200530e:	ecf251        	l32r	a5, 420006d8 <_stext+0x6b8>
    for (size_t i = 0; i < size; i++) {
42005311:	0f9377        	bne	a3, a7, 42005324 <usb_serial_jtag_write+0x24>
    _lock_release_recursive(&s_ctx.write_lock);
42005314:	ecf3a1        	l32r	a10, 420006e0 <_stext+0x6c0>
}
42005317:	202440        	or	a2, a4, a4
    _lock_release_recursive(&s_ctx.write_lock);
4200531a:	ecf481        	l32r	a8, 420006ec <_stext+0x6cc>
4200531d:	0008e0        	callx8	a8
}
42005320:	f01d      	retw.n
42005322:	00          	.byte 00
42005323:	00          	.byte 00
        int c = data_c[i];
42005324:	000362        	l8ui	a6, a3, 0
            s_ctx.tx_func(fd, '\r');
42005327:	6598      	l32i.n	a9, a5, 24
        if (c == '\n' && s_ctx.tx_mode != ESP_LINE_ENDINGS_LF) {
42005329:	209626        	beqi	a6, 10, 4200534d <usb_serial_jtag_write+0x4d>
        s_ctx.tx_func(fd, c);
4200532c:	6598      	l32i.n	a9, a5, 24
4200532e:	06bd      	mov.n	a11, a6
42005330:	02ad      	mov.n	a10, a2
42005332:	0009e0        	callx8	a9
        if (c == '\n') {
42005335:	259666        	bnei	a6, 10, 4200535e <usb_serial_jtag_write+0x5e>
    USB_SERIAL_JTAG.ep1_conf.wr_done=1;
42005338:	ebe691        	l32r	a9, 420002d0 <_stext+0x2b0>
4200533b:	1a0c      	movi.n	a10, 1
4200533d:	0020c0        	memw
42005340:	1988      	l32i.n	a8, a9, 4
42005342:	2088a0        	or	a8, a8, a10
42005345:	0020c0        	memw
42005348:	1989      	s32i.n	a8, a9, 4
}
4200534a:	000406        	j	4200535e <usb_serial_jtag_write+0x5e>
        if (c == '\n' && s_ctx.tx_mode != ESP_LINE_ENDINGS_LF) {
4200534d:	45a8      	l32i.n	a10, a5, 16
4200534f:	d92a26        	beqi	a10, 2, 4200532c <usb_serial_jtag_write+0x2c>
            s_ctx.tx_func(fd, '\r');
42005352:	db0c      	movi.n	a11, 13
42005354:	02ad      	mov.n	a10, a2
42005356:	0009e0        	callx8	a9
            if (s_ctx.tx_mode == ESP_LINE_ENDINGS_CR) {
42005359:	4598      	l32i.n	a9, a5, 16
4200535b:	cd1966        	bnei	a9, 1, 4200532c <usb_serial_jtag_write+0x2c>
    for (size_t i = 0; i < size; i++) {
4200535e:	331b      	addi.n	a3, a3, 1
42005360:	ffeb46        	j	42005311 <usb_serial_jtag_write+0x11>
	...

42005364 <usb_serial_jtag_read_char>:
{
42005364:	004136        	entry	a1, 32
    if (s_ctx.peek_char != NONE) {
42005367:	ecdc91        	l32r	a9, 420006d8 <_stext+0x6b8>
{
4200536a:	02ad      	mov.n	a10, a2
    if (s_ctx.peek_char != NONE) {
4200536c:	0928      	l32i.n	a2, a9, 0
4200536e:	060226        	beqi	a2, -1, 42005378 <usb_serial_jtag_read_char+0x14>
        s_ctx.peek_char = NONE;
42005371:	fa7c      	movi.n	a10, -1
42005373:	09a9      	s32i.n	a10, a9, 0
}
42005375:	f01d      	retw.n
42005377:	00          	.byte 00
    return s_ctx.rx_func(fd);
42005378:	7988      	l32i.n	a8, a9, 28
4200537a:	0008e0        	callx8	a8
4200537d:	0a2d      	mov.n	a2, a10
4200537f:	fffc86        	j	42005375 <usb_serial_jtag_read_char+0x11>
	...

42005384 <usb_serial_jtag_fcntl>:
{
42005384:	004136        	entry	a1, 32
    if (cmd == F_GETFL) {
42005387:	113366        	bnei	a3, 3, 4200539c <usb_serial_jtag_fcntl+0x18>
        if (s_ctx.non_blocking) {
4200538a:	ecd321        	l32r	a2, 420006d8 <_stext+0x6b8>
4200538d:	0c0232        	l8ui	a3, a2, 12
        result |= O_RDWR;
42005390:	220c      	movi.n	a2, 2
        if (s_ctx.non_blocking) {
42005392:	002316        	beqz	a3, 42005398 <usb_serial_jtag_fcntl+0x14>
            result |= O_NONBLOCK;
42005395:	ecd621        	l32r	a2, 420006f0 <_stext+0x6d0>
}
42005398:	f01d      	retw.n
4200539a:	00          	.byte 00
4200539b:	00          	.byte 00
    } else if (cmd == F_SETFL) {
4200539c:	0d4366        	bnei	a3, 4, 420053ad <usb_serial_jtag_fcntl+0x29>
        s_ctx.non_blocking = (arg & O_NONBLOCK) != 0;
4200539f:	ecce21        	l32r	a2, 420006d8 <_stext+0x6b8>
420053a2:	044e40        	extui	a4, a4, 14, 1
420053a5:	0c4242        	s8i	a4, a2, 12
    int result = 0;
420053a8:	020c      	movi.n	a2, 0
420053aa:	fffa86        	j	42005398 <usb_serial_jtag_fcntl+0x14>
        errno = ENOSYS;
420053ad:	58a022        	movi	a2, 88
420053b0:	044e65        	call8	42009898 <__errno>
420053b3:	006a22        	s32i	a2, a10, 0
420053b6:	ffaf22        	movi	a2, -1
420053b9:	fff6c6        	j	42005398 <usb_serial_jtag_fcntl+0x14>

420053bc <usb_serial_jtag_tcgetattr>:
{
420053bc:	004136        	entry	a1, 32
    if (p == NULL) {
420053bf:	00d356        	bnez	a3, 420053d0 <usb_serial_jtag_tcgetattr+0x14>
        errno = EINVAL;
420053c2:	16a022        	movi	a2, 22
420053c5:	044d25        	call8	42009898 <__errno>
420053c8:	006a22        	s32i	a2, a10, 0
420053cb:	f27c      	movi.n	a2, -1
}
420053cd:	f01d      	retw.n
420053cf:	00          	.byte 00
    memset(p, 0, sizeof(struct termios));
420053d0:	cc1c      	movi.n	a12, 28
420053d2:	0b0c      	movi.n	a11, 0
420053d4:	03ad      	mov.n	a10, a3
420053d6:	eb7081        	l32r	a8, 42000198 <_stext+0x178>
420053d9:	0008e0        	callx8	a8
    if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
420053dc:	ecbf21        	l32r	a2, 420006d8 <_stext+0x6b8>
420053df:	5228      	l32i.n	a2, a2, 20
420053e1:	42dc      	bnez.n	a2, 420053f9 <usb_serial_jtag_tcgetattr+0x3d>
        p->c_iflag |= IGNCR;
420053e3:	820c      	movi.n	a2, 8
        p->c_iflag |= ICRNL;
420053e5:	005322        	s16i	a2, a3, 0
    p->c_cflag |= CS8;
420053e8:	320c      	movi.n	a2, 3
420053ea:	025322        	s16i	a2, a3, 4
    p->c_ispeed = p->c_ospeed = 1000000;
420053ed:	ec7a21        	l32r	a2, 420005d8 <_stext+0x5b8>
420053f0:	6329      	s32i.n	a2, a3, 24
420053f2:	5329      	s32i.n	a2, a3, 20
    return 0;
420053f4:	020c      	movi.n	a2, 0
420053f6:	fff4c6        	j	420053cd <usb_serial_jtag_tcgetattr+0x11>
    } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
420053f9:	eb1266        	bnei	a2, 1, 420053e8 <usb_serial_jtag_tcgetattr+0x2c>
        p->c_iflag |= ICRNL;
420053fc:	220c      	movi.n	a2, 2
420053fe:	fff8c6        	j	420053e5 <usb_serial_jtag_tcgetattr+0x29>
42005401:	000000        	ill

42005404 <usb_serial_jtag_return_char$part$0>:
static void usb_serial_jtag_return_char(int fd, int c)
42005404:	004136        	entry	a1, 32
    assert(s_ctx.peek_char == NONE);
42005407:	ecbbd1        	l32r	a13, 420006f4 <_stext+0x6d4>
4200540a:	ecbbc1        	l32r	a12, 420006f8 <_stext+0x6d8>
4200540d:	ecbba1        	l32r	a10, 420006fc <_stext+0x6dc>
42005410:	b9a0b2        	movi	a11, 185
42005413:	eb1c81        	l32r	a8, 42000084 <_stext+0x64>
42005416:	0008e0        	callx8	a8
42005419:	000000        	ill

4200541c <usb_serial_jtag_rx_char>:
{
4200541c:	004136        	entry	a1, 32
        if (!USB_SERIAL_JTAG.ep1_conf.serial_out_ep_data_avail) break;
4200541f:	ebac81        	l32r	a8, 420002d0 <_stext+0x2b0>
        return NONE;
42005422:	f27c      	movi.n	a2, -1
42005424:	0020c0        	memw
42005427:	1898      	l32i.n	a9, a8, 4
42005429:	076927        	bbci	a9, 2, 42005434 <usb_serial_jtag_rx_char+0x18>
        buf[i] = USB_SERIAL_JTAG.ep1.rdwr_byte;
4200542c:	0020c0        	memw
4200542f:	0828      	l32i.n	a2, a8, 0
    return c;
42005431:	742020        	extui	a2, a2, 0, 8
}
42005434:	f01d      	retw.n
	...

42005438 <usb_serial_jtag_tx_char>:
{
42005438:	004136        	entry	a1, 32
    return USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free;
4200543b:	eba551        	l32r	a5, 420002d0 <_stext+0x2b0>
4200543e:	0020c0        	memw
42005441:	1528      	l32i.n	a2, a5, 4
42005443:	eca541        	l32r	a4, 420006d8 <_stext+0x6b8>
42005446:	042120        	extui	a2, a2, 1, 1
        if (usb_serial_jtag_ll_txfifo_writable()) {
42005449:	b29c      	beqz.n	a2, 42005468 <usb_serial_jtag_tx_char+0x30>
        if (!USB_SERIAL_JTAG.ep1_conf.serial_in_ep_data_free) break;
4200544b:	0020c0        	memw
4200544e:	012522        	l32i	a2, a5, 4
42005451:	076217        	bbci	a2, 1, 4200545c <usb_serial_jtag_tx_char+0x24>
        USB_SERIAL_JTAG.ep1.rdwr_byte = buf[i];
42005454:	743030        	extui	a3, a3, 0, 8
42005457:	0020c0        	memw
4200545a:	0539      	s32i.n	a3, a5, 0
            s_ctx.last_tx_ts = esp_timer_get_time();
4200545c:	ec6e81        	l32r	a8, 42000614 <_stext+0x5f4>
4200545f:	0008e0        	callx8	a8
42005462:	84a9      	s32i.n	a10, a4, 32
42005464:	94b9      	s32i.n	a11, a4, 36
}
42005466:	f01d      	retw.n
    } while ((esp_timer_get_time() - s_ctx.last_tx_ts) < TX_FLUSH_TIMEOUT_US);
42005468:	ec6b81        	l32r	a8, 42000614 <_stext+0x5f4>
4200546b:	0008e0        	callx8	a8
4200546e:	8488      	l32i.n	a8, a4, 32
42005470:	9498      	l32i.n	a9, a4, 36
42005472:	c08a80        	sub	a8, a10, a8
42005475:	140c      	movi.n	a4, 1
42005477:	013a87        	bltu	a10, a8, 4200547c <usb_serial_jtag_tx_char+0x44>
4200547a:	024d      	mov.n	a4, a2
4200547c:	c0bb90        	sub	a11, a11, a9
4200547f:	c0bb40        	sub	a11, a11, a4
42005482:	e01be6        	bgei	a11, 1, 42005466 <usb_serial_jtag_tx_char+0x2e>
42005485:	fb5b56        	bnez	a11, 4200543e <usb_serial_jtag_tx_char+0x6>
42005488:	ec9721        	l32r	a2, 420006e4 <_stext+0x6c4>
4200548b:	afb287        	bgeu	a2, a8, 4200543e <usb_serial_jtag_tx_char+0x6>
4200548e:	fff506        	j	42005466 <usb_serial_jtag_tx_char+0x2e>
42005491:	000000        	ill

42005494 <usb_serial_jtag_tcsetattr>:
{
42005494:	004136        	entry	a1, 32
    if (p == NULL) {
42005497:	d4cc      	bnez.n	a4, 420054a8 <usb_serial_jtag_tcsetattr+0x14>
            errno = EINVAL;
42005499:	16a022        	movi	a2, 22
4200549c:	043fa5        	call8	42009898 <__errno>
4200549f:	006a22        	s32i	a2, a10, 0
            return -1;
420054a2:	ffaf22        	movi	a2, -1
}
420054a5:	f01d      	retw.n
420054a7:	00          	.byte 00
    switch (optional_actions) {
420054a8:	181326        	beqi	a3, 1, 420054c4 <usb_serial_jtag_tcsetattr+0x30>
420054ab:	d27c      	movi.n	a2, -3
420054ad:	e88327        	bany	a3, a2, 42005499 <usb_serial_jtag_tcsetattr+0x5>
420054b0:	001422        	l16ui	a2, a4, 0
    if (p->c_iflag & IGNCR) {
420054b3:	880c      	movi.n	a8, 8
420054b5:	108280        	and	a8, a2, a8
420054b8:	ec8891        	l32r	a9, 420006d8 <_stext+0x6b8>
420054bb:	d88c      	beqz.n	a8, 420054cc <usb_serial_jtag_tcsetattr+0x38>
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CRLF;
420054bd:	020c      	movi.n	a2, 0
420054bf:	5929      	s32i.n	a2, a9, 20
420054c1:	fff806        	j	420054a5 <usb_serial_jtag_tcsetattr+0x11>
            usb_serial_jtag_fsync(fd);
420054c4:	02ad      	mov.n	a10, a2
420054c6:	ffdc65        	call8	4200528c <usb_serial_jtag_fsync>
            break;
420054c9:	fff8c6        	j	420054b0 <usb_serial_jtag_tcsetattr+0x1c>
    } else if (p->c_iflag & ICRNL) {
420054cc:	230c      	movi.n	a3, 2
420054ce:	102230        	and	a2, a2, a3
420054d1:	728c      	beqz.n	a2, 420054dc <usb_serial_jtag_tcsetattr+0x48>
        s_ctx.rx_mode = ESP_LINE_ENDINGS_CR;
420054d3:	120c      	movi.n	a2, 1
420054d5:	5929      	s32i.n	a2, a9, 20
420054d7:	082d      	mov.n	a2, a8
420054d9:	fff206        	j	420054a5 <usb_serial_jtag_tcsetattr+0x11>
        s_ctx.rx_mode = ESP_LINE_ENDINGS_LF;
420054dc:	230c      	movi.n	a3, 2
420054de:	5939      	s32i.n	a3, a9, 20
420054e0:	fff046        	j	420054a5 <usb_serial_jtag_tcsetattr+0x11>
	...

420054e4 <usb_serial_jtag_read>:
{
420054e4:	006136        	entry	a1, 48
    _lock_acquire_recursive(&s_ctx.read_lock);
420054e7:	ec8661        	l32r	a6, 42000700 <_stext+0x6e0>
    size_t received = 0;
420054ea:	00a052        	movi	a5, 0
    _lock_acquire_recursive(&s_ctx.read_lock);
420054ed:	20a660        	or	a10, a6, a6
420054f0:	ec7e81        	l32r	a8, 420006e8 <_stext+0x6c8>
420054f3:	0008e0        	callx8	a8
        if (c == '\r') {
420054f6:	0da072        	movi	a7, 13
    while (received < size) {
420054f9:	441547        	beq	a5, a4, 42005541 <usb_serial_jtag_read+0x5d>
        int c = usb_serial_jtag_read_char(fd);
420054fc:	02ad      	mov.n	a10, a2
420054fe:	ffe665        	call8	42005364 <usb_serial_jtag_read_char>
42005501:	0a8d      	mov.n	a8, a10
        if (c == '\r') {
42005503:	629a77        	bne	a10, a7, 42005569 <usb_serial_jtag_read+0x85>
            if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CR) {
42005506:	ec7491        	l32r	a9, 420006d8 <_stext+0x6b8>
42005509:	59a8      	l32i.n	a10, a9, 20
4200550b:	0e1a66        	bnei	a10, 1, 4200551d <usb_serial_jtag_read+0x39>
                c = '\n';
4200550e:	a80c      	movi.n	a8, 10
        data_c[received] = (char) c;
42005510:	935a      	add.n	a9, a3, a5
42005512:	004982        	s8i	a8, a9, 0
        ++received;
42005515:	551b      	addi.n	a5, a5, 1
        if (c == '\n') {
42005517:	de9866        	bnei	a8, 10, 420054f9 <usb_serial_jtag_read+0x15>
4200551a:	0008c6        	j	42005541 <usb_serial_jtag_read+0x5d>
            } else if (s_ctx.rx_mode == ESP_LINE_ENDINGS_CRLF) {
4200551d:	fefa56        	bnez	a10, 42005510 <usb_serial_jtag_read+0x2c>
                int c2 = usb_serial_jtag_read_char(fd);
42005520:	20a220        	or	a10, a2, a2
42005523:	006182        	s32i	a8, a1, 0
42005526:	016192        	s32i	a9, a1, 4
42005529:	ffe3a5        	call8	42005364 <usb_serial_jtag_read_char>
                if (c2 == NONE) {
4200552c:	0188      	l32i.n	a8, a1, 0
4200552e:	1198      	l32i.n	a9, a1, 4
42005530:	280a66        	bnei	a10, -1, 4200555c <usb_serial_jtag_read+0x78>
    assert(s_ctx.peek_char == NONE);
42005533:	0928      	l32i.n	a2, a9, 0
42005535:	050226        	beqi	a2, -1, 4200553e <usb_serial_jtag_read+0x5a>
42005538:	201110        	or	a1, a1, a1
4200553b:	ffeca5        	call8	42005404 <usb_serial_jtag_return_char$part$0>
    s_ctx.peek_char = c;
4200553e:	006972        	s32i	a7, a9, 0
    _lock_release_recursive(&s_ctx.read_lock);
42005541:	20a660        	or	a10, a6, a6
42005544:	ec6a81        	l32r	a8, 420006ec <_stext+0x6cc>
42005547:	0008e0        	callx8	a8
        return received;
4200554a:	202550        	or	a2, a5, a5
    if (received > 0) {
4200554d:	75cc      	bnez.n	a5, 42005558 <usb_serial_jtag_read+0x74>
    errno = EWOULDBLOCK;
4200554f:	b20c      	movi.n	a2, 11
42005551:	043465        	call8	42009898 <__errno>
42005554:	0a29      	s32i.n	a2, a10, 0
    return -1;
42005556:	f27c      	movi.n	a2, -1
}
42005558:	f01d      	retw.n
4200555a:	00          	.byte 00
4200555b:	00          	.byte 00
                if (c2 == '\n') {
4200555c:	ae9a26        	beqi	a10, 10, 4200550e <usb_serial_jtag_read+0x2a>
    assert(s_ctx.peek_char == NONE);
4200555f:	09b8      	l32i.n	a11, a9, 0
42005561:	d30b66        	bnei	a11, -1, 42005538 <usb_serial_jtag_read+0x54>
    s_ctx.peek_char = c;
42005564:	09a9      	s32i.n	a10, a9, 0
}
42005566:	ffe986        	j	42005510 <usb_serial_jtag_read+0x2c>
        } else if (c == NONE) {
42005569:	a30a66        	bnei	a10, -1, 42005510 <usb_serial_jtag_read+0x2c>
4200556c:	fff446        	j	42005541 <usb_serial_jtag_read+0x5d>
	...

42005570 <esp_vfs_usb_serial_jtag_get_vfs>:
    .tcflush = &usb_serial_jtag_tcflush,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

const esp_vfs_t* esp_vfs_usb_serial_jtag_get_vfs(void)
{
42005570:	004136        	entry	a1, 32
    return &vfs;
}
42005573:	ec6421        	l32r	a2, 42000704 <_stext+0x6e4>
42005576:	f01d      	retw.n

42005578 <uart_tx_char>:

    return fd;
}

static void uart_tx_char(int fd, int c)
{
42005578:	004136        	entry	a1, 32
    uart_dev_t* uart = s_ctx[fd]->uart;
4200557b:	ec6381        	l32r	a8, 42000708 <_stext+0x6e8>
    return UART_LL_FIFO_DEF_LEN - hw->status.txfifo_cnt;
4200557e:	80a092        	movi	a9, 128
42005581:	a02280        	addx4	a2, a2, a8
42005584:	0228      	l32i.n	a2, a2, 0
42005586:	0228      	l32i.n	a2, a2, 0
42005588:	0020c0        	memw
4200558b:	7288      	l32i.n	a8, a2, 28
4200558d:	958080        	extui	a8, a8, 16, 10
42005590:	c08980        	sub	a8, a9, a8
    const uint8_t ch = (uint8_t) c;

    while (uart_ll_get_txfifo_len(uart) < 2) {
42005593:	f128b6        	bltui	a8, 2, 42005588 <uart_tx_char+0x10>
        hw->fifo.rxfifo_rd_byte = buf[i];
42005596:	743030        	extui	a3, a3, 0, 8
42005599:	0020c0        	memw
4200559c:	0239      	s32i.n	a3, a2, 0
        ;
    }

    uart_ll_write_txfifo(uart, &ch, 1);
}
4200559e:	f01d      	retw.n

420055a0 <uart_rx_char>:
    char ch = (char) c;
    uart_write_bytes(fd, &ch, 1);
}

static int uart_rx_char(int fd)
{
420055a0:	004136        	entry	a1, 32
    uart_dev_t* uart = s_ctx[fd]->uart;
420055a3:	ec5981        	l32r	a8, 42000708 <_stext+0x6e8>
420055a6:	a02280        	addx4	a2, a2, a8
420055a9:	0228      	l32i.n	a2, a2, 0
420055ab:	0298      	l32i.n	a9, a2, 0
    uint8_t ch;
    if (uart_ll_get_rxfifo_len(uart) == 0) {
        return NONE;
420055ad:	f27c      	movi.n	a2, -1
    return hw->status.rxfifo_cnt;
420055af:	0020c0        	memw
420055b2:	7988      	l32i.n	a8, a9, 28
420055b4:	948080        	extui	a8, a8, 0, 10
    if (uart_ll_get_rxfifo_len(uart) == 0) {
420055b7:	688c      	beqz.n	a8, 420055c1 <uart_rx_char+0x21>
        buf[i] = hw->fifo.rxfifo_rd_byte;
420055b9:	0020c0        	memw
420055bc:	0928      	l32i.n	a2, a9, 0
    }
    uart_ll_read_rxfifo(uart, &ch, 1);

    return ch;
420055be:	742020        	extui	a2, a2, 0, 8
}
420055c1:	f01d      	retw.n
	...

420055c4 <uart_read_char>:
/* Helper function which returns a previous character or reads a new one from
 * UART. Previous character can be returned ("pushed back") using
 * uart_return_char function.
 */
static int uart_read_char(int fd)
{
420055c4:	004136        	entry	a1, 32
    /* return character from peek buffer, if it is there */
    if (s_ctx[fd]->peek_char != NONE) {
420055c7:	ec5081        	l32r	a8, 42000708 <_stext+0x6e8>
{
420055ca:	02ad      	mov.n	a10, a2
    if (s_ctx[fd]->peek_char != NONE) {
420055cc:	a08280        	addx4	a8, a2, a8
420055cf:	0898      	l32i.n	a9, a8, 0
420055d1:	1928      	l32i.n	a2, a9, 4
420055d3:	050226        	beqi	a2, -1, 420055dc <uart_read_char+0x18>
        int c = s_ctx[fd]->peek_char;
        s_ctx[fd]->peek_char = NONE;
420055d6:	fa7c      	movi.n	a10, -1
420055d8:	19a9      	s32i.n	a10, a9, 4
        return c;
    }
    return s_ctx[fd]->rx_func(fd);
}
420055da:	f01d      	retw.n
    return s_ctx[fd]->rx_func(fd);
420055dc:	8988      	l32i.n	a8, a9, 32
420055de:	0008e0        	callx8	a8
420055e1:	0a2d      	mov.n	a2, a10
420055e3:	fffcc6        	j	420055da <uart_read_char+0x16>
	...

420055e8 <uart_end_select>:
    *end_select_args = args;
    return ESP_OK;
}

static esp_err_t uart_end_select(void *end_select_args)
{
420055e8:	004136        	entry	a1, 32
    uart_select_args_t *args = end_select_args;

    portENTER_CRITICAL(uart_get_selectlock());
420055eb:	02fd25        	call8	420085bc <uart_get_selectlock>
{
420055ee:	204220        	or	a4, a2, a2
420055f1:	ffafb2        	movi	a11, -1
    esp_err_t ret = ESP_OK;
420055f4:	00a022        	movi	a2, 0
420055f7:	ea9281        	l32r	a8, 42000040 <_stext+0x20>
420055fa:	0008e0        	callx8	a8
    if (args) {
420055fd:	4d1427        	beq	a4, a2, 4200564e <uart_end_select+0x66>
42005600:	ec4351        	l32r	a5, 4200070c <_stext+0x6ec>
42005603:	fb7c      	movi.n	a11, -1
42005605:	05ad      	mov.n	a10, a5
42005607:	ea8e81        	l32r	a8, 42000040 <_stext+0x20>
4200560a:	0008e0        	callx8	a8
            if (s_registered_selects[i] == args) {
4200560d:	ec4171        	l32r	a7, 42000714 <_stext+0x6f4>
        for (int i = 0; i < s_registered_select_num; ++i) {
42005610:	ec4061        	l32r	a6, 42000710 <_stext+0x6f0>
            if (s_registered_selects[i] == args) {
42005613:	07a8      	l32i.n	a10, a7, 0
        for (int i = 0; i < s_registered_select_num; ++i) {
42005615:	0638      	l32i.n	a3, a6, 0
42005617:	0a8d      	mov.n	a8, a10
42005619:	052237        	blt	a2, a3, 42005622 <uart_end_select+0x3a>
        ret = ESP_ERR_INVALID_STATE;
4200561c:	03a122        	movi	a2, 0x103
4200561f:	0008c6        	j	42005646 <uart_end_select+0x5e>
            if (s_registered_selects[i] == args) {
42005622:	089d      	mov.n	a9, a8
42005624:	884b      	addi.n	a8, a8, 4
42005626:	fcc8b2        	addi	a11, a8, -4
42005629:	0bb8      	l32i.n	a11, a11, 0
4200562b:	4994b7        	bne	a4, a11, 42005678 <uart_end_select+0x90>
                const int new_size = s_registered_select_num - 1;
4200562e:	330b      	addi.n	a3, a3, -1
                s_registered_selects[i] = s_registered_selects[new_size];
42005630:	a023a0        	addx4	a2, a3, a10
42005633:	0228      	l32i.n	a2, a2, 0
                s_registered_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *));
42005635:	11b3e0        	slli	a11, a3, 2
                s_registered_selects[i] = s_registered_selects[new_size];
42005638:	0929      	s32i.n	a2, a9, 0
                s_registered_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *));
4200563a:	ec3781        	l32r	a8, 42000718 <_stext+0x6f8>
4200563d:	0008e0        	callx8	a8
42005640:	07a9      	s32i.n	a10, a7, 0
                s_registered_select_num = new_size;
42005642:	0639      	s32i.n	a3, a6, 0
                ret = ESP_OK;
42005644:	020c      	movi.n	a2, 0
        portEXIT_CRITICAL(&s_registered_select_lock);
42005646:	05ad      	mov.n	a10, a5
42005648:	ea7f81        	l32r	a8, 42000044 <_stext+0x24>
4200564b:	0008e0        	callx8	a8
    esp_err_t ret = unregister_select(args);
    for (int i = 0; i < UART_NUM; ++i) {
        uart_set_select_notif_callback(i, NULL);
4200564e:	0b0c      	movi.n	a11, 0
42005650:	0bad      	mov.n	a10, a11
42005652:	02f525        	call8	420085a4 <uart_set_select_notif_callback>
42005655:	0b0c      	movi.n	a11, 0
42005657:	1a0c      	movi.n	a10, 1
42005659:	02f4a5        	call8	420085a4 <uart_set_select_notif_callback>
4200565c:	0b0c      	movi.n	a11, 0
4200565e:	2a0c      	movi.n	a10, 2
42005660:	02f425        	call8	420085a4 <uart_set_select_notif_callback>
    }
    portEXIT_CRITICAL(uart_get_selectlock());
42005663:	02f5a5        	call8	420085bc <uart_get_selectlock>
42005666:	ea7781        	l32r	a8, 42000044 <_stext+0x24>
42005669:	0008e0        	callx8	a8

    if (args) {
4200566c:	648c      	beqz.n	a4, 42005676 <uart_end_select+0x8e>
        free(args);
4200566e:	04ad      	mov.n	a10, a4
42005670:	ea6d81        	l32r	a8, 42000024 <_stext+0x4>
42005673:	0008e0        	callx8	a8
    }

    return ret;
}
42005676:	f01d      	retw.n
        for (int i = 0; i < s_registered_select_num; ++i) {
42005678:	221b      	addi.n	a2, a2, 1
4200567a:	ffe6c6        	j	42005619 <uart_end_select+0x31>
4200567d:	000000        	ill

42005680 <uart_start_select>:
{
42005680:	008136        	entry	a1, 64
    *end_select_args = NULL;
42005683:	102182        	l32i	a8, a1, 64
{
42005686:	4169      	s32i.n	a6, a1, 16
    const int max_fds = MIN(nfds, UART_NUM);
42005688:	360c      	movi.n	a6, 3
4200568a:	432260        	min	a2, a2, a6
    *end_select_args = NULL;
4200568d:	060c      	movi.n	a6, 0
4200568f:	0869      	s32i.n	a6, a8, 0
{
42005691:	5179      	s32i.n	a7, a1, 20
        if (FD_ISSET(i, readfds) || FD_ISSET(i, writefds) || FD_ISSET(i, exceptfds)) {
42005693:	180c      	movi.n	a8, 1
    for (int i = 0; i < max_fds; ++i) {
42005695:	02a627        	bge	a6, a2, 4200569b <uart_start_select+0x1b>
42005698:	002e06        	j	42005754 <uart_start_select+0xd4>
    uart_select_args_t *args = malloc(sizeof(uart_select_args_t));
4200569b:	ca2c      	movi.n	a10, 44
4200569d:	ea6a81        	l32r	a8, 42000048 <_stext+0x28>
420056a0:	0008e0        	callx8	a8
420056a3:	0a6d      	mov.n	a6, a10
        return ESP_ERR_NO_MEM;
420056a5:	01a172        	movi	a7, 0x101
    if (args == NULL) {
420056a8:	0d4a16        	beqz	a10, 42005780 <uart_start_select+0x100>
    args->select_sem = select_sem;
420056ab:	4178      	l32i.n	a7, a1, 16
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
420056ad:	0388      	l32i.n	a8, a3, 0
    args->select_sem = select_sem;
420056af:	0a79      	s32i.n	a7, a10, 0
420056b1:	5178      	l32i.n	a7, a1, 20
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
420056b3:	5a89      	s32i.n	a8, a10, 20
    args->select_sem = select_sem;
420056b5:	1a79      	s32i.n	a7, a10, 4
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
420056b7:	1378      	l32i.n	a7, a3, 4
    args->writefds_orig = *writefds;
420056b9:	0488      	l32i.n	a8, a4, 0
    args->readfds_orig = *readfds; // store the original values because they will be set to zero
420056bb:	6a79      	s32i.n	a7, a10, 24
    args->writefds_orig = *writefds;
420056bd:	1478      	l32i.n	a7, a4, 4
420056bf:	7a89      	s32i.n	a8, a10, 28
420056c1:	8a79      	s32i.n	a7, a10, 32
    args->errorfds_orig = *exceptfds;
420056c3:	1578      	l32i.n	a7, a5, 4
420056c5:	0588      	l32i.n	a8, a5, 0
420056c7:	aa79      	s32i.n	a7, a10, 40
    FD_ZERO(readfds);
420056c9:	070c      	movi.n	a7, 0
420056cb:	1379      	s32i.n	a7, a3, 4
420056cd:	0379      	s32i.n	a7, a3, 0
    FD_ZERO(writefds);
420056cf:	1479      	s32i.n	a7, a4, 4
420056d1:	0479      	s32i.n	a7, a4, 0
    args->errorfds = exceptfds;
420056d3:	4a59      	s32i.n	a5, a10, 16
    args->errorfds_orig = *exceptfds;
420056d5:	9a89      	s32i.n	a8, a10, 36
    FD_ZERO(exceptfds);
420056d7:	1579      	s32i.n	a7, a5, 4
420056d9:	0579      	s32i.n	a7, a5, 0
    args->readfds = readfds;
420056db:	2a39      	s32i.n	a3, a10, 8
    args->writefds = writefds;
420056dd:	3a49      	s32i.n	a4, a10, 12
    portENTER_CRITICAL(uart_get_selectlock());
420056df:	02ede5        	call8	420085bc <uart_get_selectlock>
420056e2:	fb7c      	movi.n	a11, -1
420056e4:	ea5781        	l32r	a8, 42000040 <_stext+0x20>
420056e7:	0008e0        	callx8	a8
        if (FD_ISSET(i, &args->readfds_orig) || FD_ISSET(i, &args->writefds_orig) || FD_ISSET(i, &args->errorfds_orig)) {
420056ea:	150c      	movi.n	a5, 1
    for (int i = 0; i < max_fds; ++i) {
420056ec:	02a727        	bge	a7, a2, 420056f2 <uart_start_select+0x72>
420056ef:	002446        	j	42005784 <uart_start_select+0x104>
    for (int i = 0; i < max_fds; ++i) {
420056f2:	040c      	movi.n	a4, 0
        if (FD_ISSET(i, &args->readfds_orig)) {
420056f4:	150c      	movi.n	a5, 1
    for (int i = 0; i < max_fds; ++i) {
420056f6:	02a427        	bge	a4, a2, 420056fc <uart_start_select+0x7c>
420056f9:	002b06        	j	420057a9 <uart_start_select+0x129>
420056fc:	ec0441        	l32r	a4, 4200070c <_stext+0x6ec>
420056ff:	fb7c      	movi.n	a11, -1
42005701:	04ad      	mov.n	a10, a4
42005703:	ea4f81        	l32r	a8, 42000040 <_stext+0x20>
42005706:	0008e0        	callx8	a8
        const int new_size = s_registered_select_num + 1;
42005709:	ec0151        	l32r	a5, 42000710 <_stext+0x6f0>
        if ((new_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *))) == NULL) {
4200570c:	ec0281        	l32r	a8, 42000714 <_stext+0x6f4>
        const int new_size = s_registered_select_num + 1;
4200570f:	0528      	l32i.n	a2, a5, 0
        if ((new_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *))) == NULL) {
42005711:	08a8      	l32i.n	a10, a8, 0
        const int new_size = s_registered_select_num + 1;
42005713:	221b      	addi.n	a2, a2, 1
        if ((new_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *))) == NULL) {
42005715:	1132e0        	slli	a3, a2, 2
42005718:	03bd      	mov.n	a11, a3
4200571a:	ebff81        	l32r	a8, 42000718 <_stext+0x6f8>
4200571d:	0008e0        	callx8	a8
            ret = ESP_ERR_NO_MEM;
42005720:	01a172        	movi	a7, 0x101
        if ((new_selects = realloc(s_registered_selects, new_size * sizeof(uart_select_args_t *))) == NULL) {
42005723:	ea8c      	beqz.n	a10, 42005735 <uart_start_select+0xb5>
            s_registered_selects = new_selects;
42005725:	ebfb81        	l32r	a8, 42000714 <_stext+0x6f4>
            s_registered_select_num = new_size;
42005728:	0529      	s32i.n	a2, a5, 0
            s_registered_selects = new_selects;
4200572a:	08a9      	s32i.n	a10, a8, 0
            s_registered_selects[s_registered_select_num] = args;
4200572c:	aa3a      	add.n	a10, a10, a3
4200572e:	fccaa2        	addi	a10, a10, -4
42005731:	0a69      	s32i.n	a6, a10, 0
            ret = ESP_OK;
42005733:	070c      	movi.n	a7, 0
        portEXIT_CRITICAL(&s_registered_select_lock);
42005735:	04ad      	mov.n	a10, a4
42005737:	ea4381        	l32r	a8, 42000044 <_stext+0x24>
4200573a:	0008e0        	callx8	a8
    if (ret != ESP_OK) {
4200573d:	097716        	beqz	a7, 420057d8 <uart_start_select+0x158>
        portEXIT_CRITICAL(uart_get_selectlock());
42005740:	02e7a5        	call8	420085bc <uart_get_selectlock>
42005743:	ea4081        	l32r	a8, 42000044 <_stext+0x24>
42005746:	0008e0        	callx8	a8
        free(args);
42005749:	06ad      	mov.n	a10, a6
4200574b:	ea3681        	l32r	a8, 42000024 <_stext+0x4>
4200574e:	0008e0        	callx8	a8
        return ret;
42005751:	000ac6        	j	42005780 <uart_start_select+0x100>
        if (FD_ISSET(i, readfds) || FD_ISSET(i, writefds) || FD_ISSET(i, exceptfds)) {
42005754:	0398      	l32i.n	a9, a3, 0
42005756:	401600        	ssl	a6
42005759:	a17800        	sll	a7, a8
4200575c:	0e8797        	bany	a7, a9, 4200576e <uart_start_select+0xee>
4200575f:	0498      	l32i.n	a9, a4, 0
42005761:	098797        	bany	a7, a9, 4200576e <uart_start_select+0xee>
42005764:	0598      	l32i.n	a9, a5, 0
42005766:	048797        	bany	a7, a9, 4200576e <uart_start_select+0xee>
    for (int i = 0; i < max_fds; ++i) {
42005769:	661b      	addi.n	a6, a6, 1
4200576b:	ffc986        	j	42005695 <uart_start_select+0x15>
            if (!uart_is_driver_installed(i)) {
4200576e:	20a660        	or	a10, a6, a6
42005771:	066182        	s32i	a8, a1, 24
42005774:	02e125        	call8	42008588 <uart_is_driver_installed>
42005777:	062182        	l32i	a8, a1, 24
4200577a:	feba56        	bnez	a10, 42005769 <uart_start_select+0xe9>
                return ESP_ERR_INVALID_STATE;
4200577d:	03a172        	movi	a7, 0x103
}
42005780:	072d      	mov.n	a2, a7
42005782:	f01d      	retw.n
        if (FD_ISSET(i, &args->readfds_orig) || FD_ISSET(i, &args->writefds_orig) || FD_ISSET(i, &args->errorfds_orig)) {
42005784:	5688      	l32i.n	a8, a6, 20
42005786:	401700        	ssl	a7
42005789:	a14500        	sll	a4, a5
4200578c:	098487        	bany	a4, a8, 42005799 <uart_start_select+0x119>
4200578f:	7688      	l32i.n	a8, a6, 28
42005791:	048487        	bany	a4, a8, 42005799 <uart_start_select+0x119>
42005794:	9688      	l32i.n	a8, a6, 36
42005796:	070487        	bnone	a4, a8, 420057a1 <uart_start_select+0x121>
            uart_set_select_notif_callback(i, select_notif_callback_isr);
42005799:	ebe0b1        	l32r	a11, 4200071c <_stext+0x6fc>
4200579c:	07ad      	mov.n	a10, a7
4200579e:	02e065        	call8	420085a4 <uart_set_select_notif_callback>
    for (int i = 0; i < max_fds; ++i) {
420057a1:	771b      	addi.n	a7, a7, 1
420057a3:	ffd146        	j	420056ec <uart_start_select+0x6c>
420057a6:	00          	.byte 00
420057a7:	00          	.byte 00
420057a8:	00          	.byte 00
        if (FD_ISSET(i, &args->readfds_orig)) {
420057a9:	052682        	l32i	a8, a6, 20
420057ac:	401400        	ssl	a4
420057af:	a17500        	sll	a7, a5
420057b2:	1b0787        	bnone	a7, a8, 420057d1 <uart_start_select+0x151>
            if (uart_get_buffered_data_len(i, &buffered_size) == ESP_OK && buffered_size > 0) {
420057b5:	20b110        	or	a11, a1, a1
420057b8:	04ad      	mov.n	a10, a4
420057ba:	029665        	call8	42008120 <uart_get_buffered_data_len>
420057bd:	0adc      	bnez.n	a10, 420057d1 <uart_start_select+0x151>
420057bf:	0188      	l32i.n	a8, a1, 0
420057c1:	c88c      	beqz.n	a8, 420057d1 <uart_start_select+0x151>
                FD_SET(i, readfds);
420057c3:	0388      	l32i.n	a8, a3, 0
                esp_vfs_select_triggered(args->select_sem);
420057c5:	06a8      	l32i.n	a10, a6, 0
                FD_SET(i, readfds);
420057c7:	207870        	or	a7, a8, a7
                esp_vfs_select_triggered(args->select_sem);
420057ca:	16b8      	l32i.n	a11, a6, 4
                FD_SET(i, readfds);
420057cc:	0379      	s32i.n	a7, a3, 0
                esp_vfs_select_triggered(args->select_sem);
420057ce:	ff7be5        	call8	42004f8c <esp_vfs_select_triggered>
    for (int i = 0; i < max_fds; ++i) {
420057d1:	441b      	addi.n	a4, a4, 1
420057d3:	ffc7c6        	j	420056f6 <uart_start_select+0x76>
420057d6:	00          	.byte 00
420057d7:	00          	.byte 00
    portEXIT_CRITICAL(uart_get_selectlock());
420057d8:	02de25        	call8	420085bc <uart_get_selectlock>
420057db:	ea1a81        	l32r	a8, 42000044 <_stext+0x24>
420057de:	0008e0        	callx8	a8
    *end_select_args = args;
420057e1:	102182        	l32i	a8, a1, 64
420057e4:	0869      	s32i.n	a6, a8, 0
    return ESP_OK;
420057e6:	ffe586        	j	42005780 <uart_start_select+0x100>
420057e9:	000000        	ill

420057ec <select_notif_callback_isr>:
{
420057ec:	006136        	entry	a1, 48
420057ef:	ebc7a1        	l32r	a10, 4200070c <_stext+0x6ec>
420057f2:	fb7c      	movi.n	a11, -1
420057f4:	ea1381        	l32r	a8, 42000040 <_stext+0x20>
420057f7:	0008e0        	callx8	a8
    for (int i = 0; i < s_registered_select_num; ++i) {
420057fa:	060c      	movi.n	a6, 0
                    if (FD_ISSET(uart_num, &args->errorfds_orig)) {
420057fc:	217520        	srai	a7, a2, 5
420057ff:	190c      	movi.n	a9, 1
    for (int i = 0; i < s_registered_select_num; ++i) {
42005801:	0169      	s32i.n	a6, a1, 0
                    if (FD_ISSET(uart_num, &args->writefds_orig)) {
42005803:	674b      	addi.n	a6, a7, 4
                    if (FD_ISSET(uart_num, &args->errorfds_orig)) {
42005805:	401200        	ssl	a2
42005808:	a15900        	sll	a5, a9
                    if (FD_ISSET(uart_num, &args->writefds_orig)) {
4200580b:	1166e0        	slli	a6, a6, 2
    for (int i = 0; i < s_registered_select_num; ++i) {
4200580e:	ebc091        	l32r	a9, 42000710 <_stext+0x6f0>
42005811:	0988      	l32i.n	a8, a9, 0
42005813:	0198      	l32i.n	a9, a1, 0
42005815:	0b2987        	blt	a9, a8, 42005824 <select_notif_callback_isr+0x38>
    portEXIT_CRITICAL_ISR(&s_registered_select_lock);
42005818:	ebbda1        	l32r	a10, 4200070c <_stext+0x6ec>
4200581b:	ea0a81        	l32r	a8, 42000044 <_stext+0x24>
4200581e:	0008e0        	callx8	a8
}
42005821:	f01d      	retw.n
42005823:	00          	.byte 00
        uart_select_args_t *args = s_registered_selects[i];
42005824:	ebbc91        	l32r	a9, 42000714 <_stext+0x6f4>
42005827:	002982        	l32i	a8, a9, 0
4200582a:	002192        	l32i	a9, a1, 0
4200582d:	a08980        	addx4	a8, a9, a8
42005830:	002882        	l32i	a8, a8, 0
        if (args) {
42005833:	78ac      	beqz.n	a8, 4200585e <select_notif_callback_isr+0x72>
            switch (uart_select_notif) {
42005835:	2f1326        	beqi	a3, 1, 42005868 <select_notif_callback_isr+0x7c>
42005838:	3d2326        	beqi	a3, 2, 42005879 <select_notif_callback_isr+0x8d>
4200583b:	f3dc      	bnez.n	a3, 4200585e <select_notif_callback_isr+0x72>
                    if (FD_ISSET(uart_num, &args->readfds_orig)) {
4200583d:	fa3c      	movi.n	a10, 63
4200583f:	1b3a27        	bltu	a10, a2, 4200585e <select_notif_callback_isr+0x72>
42005842:	a86a      	add.n	a10, a8, a6
42005844:	1aa8      	l32i.n	a10, a10, 4
42005846:	1405a7        	bnone	a5, a10, 4200585e <select_notif_callback_isr+0x72>
                        FD_SET(uart_num, args->readfds);
42005849:	28a8      	l32i.n	a10, a8, 8
4200584b:	a0a7a0        	addx4	a10, a7, a10
                        FD_SET(uart_num, args->errorfds);
4200584e:	0ab8      	l32i.n	a11, a10, 0
                        esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42005850:	04cd      	mov.n	a12, a4
                        FD_SET(uart_num, args->errorfds);
42005852:	20bb50        	or	a11, a11, a5
42005855:	0ab9      	s32i.n	a11, a10, 0
                        esp_vfs_select_triggered_isr(args->select_sem, task_woken);
42005857:	08a8      	l32i.n	a10, a8, 0
42005859:	18b8      	l32i.n	a11, a8, 4
4200585b:	ff7725        	call8	42004fcc <esp_vfs_select_triggered_isr>
    for (int i = 0; i < s_registered_select_num; ++i) {
4200585e:	0188      	l32i.n	a8, a1, 0
42005860:	881b      	addi.n	a8, a8, 1
42005862:	0189      	s32i.n	a8, a1, 0
42005864:	ffe986        	j	4200580e <select_notif_callback_isr+0x22>
42005867:	00          	.byte 00
                    if (FD_ISSET(uart_num, &args->writefds_orig)) {
42005868:	fa3c      	movi.n	a10, 63
4200586a:	f03a27        	bltu	a10, a2, 4200585e <select_notif_callback_isr+0x72>
4200586d:	a86a      	add.n	a10, a8, a6
4200586f:	3aa8      	l32i.n	a10, a10, 12
42005871:	e905a7        	bnone	a5, a10, 4200585e <select_notif_callback_isr+0x72>
                        FD_SET(uart_num, args->writefds);
42005874:	38a8      	l32i.n	a10, a8, 12
42005876:	fff446        	j	4200584b <select_notif_callback_isr+0x5f>
                    if (FD_ISSET(uart_num, &args->errorfds_orig)) {
42005879:	fa3c      	movi.n	a10, 63
4200587b:	df3a27        	bltu	a10, a2, 4200585e <select_notif_callback_isr+0x72>
4200587e:	a0a780        	addx4	a10, a7, a8
42005881:	9aa8      	l32i.n	a10, a10, 36
42005883:	d705a7        	bnone	a5, a10, 4200585e <select_notif_callback_isr+0x72>
                        FD_SET(uart_num, args->errorfds);
42005886:	48a8      	l32i.n	a10, a8, 16
42005888:	ffefc6        	j	4200584b <select_notif_callback_isr+0x5f>
	...

4200588c <uart_tcgetattr>:

    return 0;
}

static int uart_tcgetattr(int fd, struct termios *p)
{
4200588c:	006136        	entry	a1, 48
    if (fd < 0 || fd >= UART_NUM) {
4200588f:	0f32b6        	bltui	a2, 3, 420058a2 <uart_tcgetattr+0x16>
        errno = EBADF;
42005892:	040065        	call8	42009898 <__errno>
42005895:	09a022        	movi	a2, 9
    }

    {
        uint32_t baudrate;
        if (uart_get_baudrate(fd, &baudrate) != ESP_OK) {
            errno = EINVAL;
42005898:	006a22        	s32i	a2, a10, 0
            return -1;
4200589b:	ffafa2        	movi	a10, -1

        p->c_ispeed = p->c_ospeed = sp;
    }

    return 0;
}
4200589e:	0a2d      	mov.n	a2, a10
420058a0:	f01d      	retw.n
    if (p == NULL) {
420058a2:	63cc      	bnez.n	a3, 420058ac <uart_tcgetattr+0x20>
            errno = EINVAL;
420058a4:	03ff25        	call8	42009898 <__errno>
420058a7:	621c      	movi.n	a2, 22
420058a9:	fffac6        	j	42005898 <uart_tcgetattr+0xc>
    memset(p, 0, sizeof(struct termios));
420058ac:	cc1c      	movi.n	a12, 28
420058ae:	0b0c      	movi.n	a11, 0
420058b0:	03ad      	mov.n	a10, a3
420058b2:	ea3981        	l32r	a8, 42000198 <_stext+0x178>
420058b5:	0008e0        	callx8	a8
    if (s_ctx[fd]->rx_mode == ESP_LINE_ENDINGS_CRLF) {
420058b8:	eb9481        	l32r	a8, 42000708 <_stext+0x6e8>
420058bb:	a08280        	addx4	a8, a2, a8
420058be:	0888      	l32i.n	a8, a8, 0
420058c0:	6888      	l32i.n	a8, a8, 24
420058c2:	0ce856        	bnez	a8, 42005994 <uart_tcgetattr+0x108>
        p->c_iflag |= IGNCR;
420058c5:	880c      	movi.n	a8, 8
        p->c_iflag |= ICRNL;
420058c7:	005382        	s16i	a8, a3, 0
        if (uart_get_word_length(fd, &data_bits) != ESP_OK) {
420058ca:	01bd      	mov.n	a11, a1
420058cc:	02ad      	mov.n	a10, a2
420058ce:	01dfa5        	call8	420076c8 <uart_get_word_length>
420058d1:	fcfa56        	bnez	a10, 420058a4 <uart_tcgetattr+0x18>
        p->c_cflag &= (~CSIZE);
420058d4:	021382        	l16ui	a8, a3, 4
420058d7:	c97c      	movi.n	a9, -4
420058d9:	108890        	and	a8, a8, a9
        switch (data_bits) {
420058dc:	0198      	l32i.n	a9, a1, 0
        p->c_cflag &= (~CSIZE);
420058de:	025382        	s16i	a8, a3, 4
        switch (data_bits) {
420058e1:	022966        	bnei	a9, 2, 420058e7 <uart_tcgetattr+0x5b>
420058e4:	003246        	j	420059b1 <uart_tcgetattr+0x125>
420058e7:	0239b6        	bltui	a9, 3, 420058ed <uart_tcgetattr+0x61>
420058ea:	002cc6        	j	420059a1 <uart_tcgetattr+0x115>
420058ed:	0be956        	bnez	a9, 420059af <uart_tcgetattr+0x123>
        if (uart_get_stop_bits(fd, &stop_bits) != ESP_OK) {
420058f0:	01bd      	mov.n	a11, a1
420058f2:	02ad      	mov.n	a10, a2
420058f4:	01e2a5        	call8	42007720 <uart_get_stop_bits>
420058f7:	fa9a56        	bnez	a10, 420058a4 <uart_tcgetattr+0x18>
        switch (stop_bits) {
420058fa:	0188      	l32i.n	a8, a1, 0
420058fc:	101826        	beqi	a8, 1, 42005910 <uart_tcgetattr+0x84>
420058ff:	023826        	beqi	a8, 3, 42005905 <uart_tcgetattr+0x79>
42005902:	002786        	j	420059a4 <uart_tcgetattr+0x118>
                p->c_cflag |= CSTOPB;
42005905:	021382        	l16ui	a8, a3, 4
42005908:	490c      	movi.n	a9, 4
4200590a:	208890        	or	a8, a8, a9
4200590d:	025382        	s16i	a8, a3, 4
        if (uart_get_parity(fd, &parity_mode) != ESP_OK) {
42005910:	01bd      	mov.n	a11, a1
42005912:	20a220        	or	a10, a2, a2
42005915:	01e725        	call8	42007788 <uart_get_parity>
42005918:	f88a56        	bnez	a10, 420058a4 <uart_tcgetattr+0x18>
        switch (parity_mode) {
4200591b:	0188      	l32i.n	a8, a1, 0
4200591d:	022866        	bnei	a8, 2, 42005923 <uart_tcgetattr+0x97>
42005920:	002606        	j	420059bc <uart_tcgetattr+0x130>
42005923:	023866        	bnei	a8, 3, 42005929 <uart_tcgetattr+0x9d>
42005926:	002886        	j	420059cc <uart_tcgetattr+0x140>
42005929:	077856        	bnez	a8, 420059a4 <uart_tcgetattr+0x118>
        if (uart_get_baudrate(fd, &baudrate) != ESP_OK) {
4200592c:	01bd      	mov.n	a11, a1
4200592e:	20a220        	or	a10, a2, a2
42005931:	01ed25        	call8	42007804 <uart_get_baudrate>
42005934:	f6ca56        	bnez	a10, 420058a4 <uart_tcgetattr+0x18>
        p->c_cflag |= (CBAUD | CBAUDEX);
42005937:	0213b2        	l16ui	a11, a3, 4
4200593a:	00a322        	movi	a2, 0x300
4200593d:	202b20        	or	a2, a11, a2
42005940:	025322        	s16i	a2, a3, 4
        switch (baudrate) {
42005943:	0188      	l32i.n	a8, a1, 0
42005945:	b24c      	movi.n	a2, 75
42005947:	112270        	slli	a2, a2, 9
4200594a:	029827        	bne	a8, a2, 42005950 <uart_tcgetattr+0xc4>
4200594d:	0068c6        	j	42005af4 <uart_tcgetattr+0x268>
42005950:	02b287        	bgeu	a2, a8, 42005956 <uart_tcgetattr+0xca>
42005953:	003a86        	j	42005a41 <uart_tcgetattr+0x1b5>
42005956:	2ca122        	movi	a2, 0x12c
42005959:	029827        	bne	a8, a2, 4200595f <uart_tcgetattr+0xd3>
4200595c:	006646        	j	42005af9 <uart_tcgetattr+0x26d>
4200595f:	02b287        	bgeu	a2, a8, 42005965 <uart_tcgetattr+0xd9>
42005962:	0022c6        	j	420059f1 <uart_tcgetattr+0x165>
42005965:	6ea022        	movi	a2, 110
42005968:	029827        	bne	a8, a2, 4200596e <uart_tcgetattr+0xe2>
4200596b:	0063c6        	j	42005afe <uart_tcgetattr+0x272>
4200596e:	623287        	bltu	a2, a8, 420059d4 <uart_tcgetattr+0x148>
42005971:	223c      	movi.n	a2, 50
42005973:	029827        	bne	a8, a2, 42005979 <uart_tcgetattr+0xed>
42005976:	006286        	j	42005b04 <uart_tcgetattr+0x278>
42005979:	b24c      	movi.n	a2, 75
4200597b:	029827        	bne	a8, a2, 42005981 <uart_tcgetattr+0xf5>
4200597e:	0061c6        	j	42005b09 <uart_tcgetattr+0x27d>
42005981:	008816        	beqz	a8, 4200598d <uart_tcgetattr+0x101>
                p->c_cflag |= BOTHER;
42005984:	00a722        	movi	a2, 0x700
42005987:	20bb20        	or	a11, a11, a2
4200598a:	0253b2        	s16i	a11, a3, 4
        p->c_ispeed = p->c_ospeed = sp;
4200598d:	6389      	s32i.n	a8, a3, 24
4200598f:	5389      	s32i.n	a8, a3, 20
    return 0;
42005991:	ffc246        	j	4200589e <uart_tcgetattr+0x12>
    } else if (s_ctx[fd]->rx_mode == ESP_LINE_ENDINGS_CR) {
42005994:	021826        	beqi	a8, 1, 4200599a <uart_tcgetattr+0x10e>
42005997:	ffcbc6        	j	420058ca <uart_tcgetattr+0x3e>
        p->c_iflag |= ICRNL;
4200599a:	280c      	movi.n	a8, 2
4200599c:	ffc9c6        	j	420058c7 <uart_tcgetattr+0x3b>
4200599f:	00          	.byte 00
420059a0:	00          	.byte 00
        switch (data_bits) {
420059a1:	0c3926        	beqi	a9, 3, 420059b1 <uart_tcgetattr+0x125>
                errno = ENOSYS;
420059a4:	03ef25        	call8	42009898 <__errno>
420059a7:	825c      	movi.n	a2, 88
420059a9:	ffbac6        	j	42005898 <uart_tcgetattr+0xc>
420059ac:	00          	.byte 00
420059ad:	00          	.byte 00
420059ae:	00          	.byte 00
                p->c_cflag |= CS6;
420059af:	190c      	movi.n	a9, 1
                p->c_cflag |= CS8;
420059b1:	208890        	or	a8, a8, a9
420059b4:	025382        	s16i	a8, a3, 4
                break;
420059b7:	ffcd46        	j	420058f0 <uart_tcgetattr+0x64>
420059ba:	00          	.byte 00
420059bb:	00          	.byte 00
                p->c_cflag |= PARENB;
420059bc:	021382        	l16ui	a8, a3, 4
420059bf:	091c      	movi.n	a9, 16
                p->c_cflag |= (PARENB | PARODD);
420059c1:	208890        	or	a8, a8, a9
420059c4:	025382        	s16i	a8, a3, 4
                break;
420059c7:	ffd846        	j	4200592c <uart_tcgetattr+0xa0>
420059ca:	00          	.byte 00
420059cb:	00          	.byte 00
                p->c_cflag |= (PARENB | PARODD);
420059cc:	021382        	l16ui	a8, a3, 4
420059cf:	093c      	movi.n	a9, 48
420059d1:	fffb06        	j	420059c1 <uart_tcgetattr+0x135>
        switch (baudrate) {
420059d4:	96a022        	movi	a2, 150
420059d7:	029827        	bne	a8, a2, 420059dd <uart_tcgetattr+0x151>
420059da:	004c06        	j	42005b0e <uart_tcgetattr+0x282>
420059dd:	c8a022        	movi	a2, 200
420059e0:	029827        	bne	a8, a2, 420059e6 <uart_tcgetattr+0x15a>
420059e3:	004b46        	j	42005b14 <uart_tcgetattr+0x288>
420059e6:	86a022        	movi	a2, 134
420059e9:	979827        	bne	a8, a2, 42005984 <uart_tcgetattr+0xf8>
                sp = B134;
420059ec:	480c      	movi.n	a8, 4
420059ee:	ffe6c6        	j	4200598d <uart_tcgetattr+0x101>
        switch (baudrate) {
420059f1:	b94c      	movi.n	a9, 75
420059f3:	1199b0        	slli	a9, a9, 5
420059f6:	b24c      	movi.n	a2, 75
420059f8:	029897        	bne	a8, a9, 420059fe <uart_tcgetattr+0x172>
420059fb:	004686        	j	42005b19 <uart_tcgetattr+0x28d>
420059fe:	1f3987        	bltu	a9, a8, 42005a21 <uart_tcgetattr+0x195>
42005a01:	b0a422        	movi	a2, 0x4b0
42005a04:	029827        	bne	a8, a2, 42005a0a <uart_tcgetattr+0x17e>
42005a07:	0044c6        	j	42005b1e <uart_tcgetattr+0x292>
42005a0a:	08a722        	movi	a2, 0x708
42005a0d:	029827        	bne	a8, a2, 42005a13 <uart_tcgetattr+0x187>
42005a10:	004406        	j	42005b24 <uart_tcgetattr+0x298>
42005a13:	58a222        	movi	a2, 0x258
42005a16:	021827        	beq	a8, a2, 42005a1c <uart_tcgetattr+0x190>
42005a19:	ffd9c6        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B600;
42005a1c:	880c      	movi.n	a8, 8
42005a1e:	ffdac6        	j	4200598d <uart_tcgetattr+0x101>
        switch (baudrate) {
42005a21:	119290        	slli	a9, a2, 7
42005a24:	029897        	bne	a8, a9, 42005a2a <uart_tcgetattr+0x19e>
42005a27:	003f86        	j	42005b29 <uart_tcgetattr+0x29d>
42005a2a:	119280        	slli	a9, a2, 8
42005a2d:	029897        	bne	a8, a9, 42005a33 <uart_tcgetattr+0x1a7>
42005a30:	003e86        	j	42005b2e <uart_tcgetattr+0x2a2>
42005a33:	1122a0        	slli	a2, a2, 6
42005a36:	021827        	beq	a8, a2, 42005a3c <uart_tcgetattr+0x1b0>
42005a39:	ffd1c6        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B4800;
42005a3c:	c80c      	movi.n	a8, 12
42005a3e:	ffd2c6        	j	4200598d <uart_tcgetattr+0x101>
        switch (baudrate) {
42005a41:	eae521        	l32r	a2, 420005d8 <_stext+0x5b8>
42005a44:	029827        	bne	a8, a2, 42005a4a <uart_tcgetattr+0x1be>
42005a47:	003a06        	j	42005b33 <uart_tcgetattr+0x2a7>
42005a4a:	563287        	bltu	a2, a8, 42005aa4 <uart_tcgetattr+0x218>
42005a4d:	e1a022        	movi	a2, 225
42005a50:	112250        	slli	a2, a2, 11
42005a53:	e1a092        	movi	a9, 225
42005a56:	029827        	bne	a8, a2, 42005a5c <uart_tcgetattr+0x1d0>
42005a59:	0036c6        	j	42005b38 <uart_tcgetattr+0x2ac>
42005a5c:	203287        	bltu	a2, a8, 42005a80 <uart_tcgetattr+0x1f4>
42005a5f:	112970        	slli	a2, a9, 9
42005a62:	029827        	bne	a8, a2, 42005a68 <uart_tcgetattr+0x1dc>
42005a65:	003506        	j	42005b3d <uart_tcgetattr+0x2b1>
42005a68:	112960        	slli	a2, a9, 10
42005a6b:	029827        	bne	a8, a2, 42005a71 <uart_tcgetattr+0x1e5>
42005a6e:	003406        	j	42005b42 <uart_tcgetattr+0x2b6>
42005a71:	119980        	slli	a9, a9, 8
42005a74:	021897        	beq	a8, a9, 42005a7a <uart_tcgetattr+0x1ee>
42005a77:	ffc246        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B57600;
42005a7a:	081c      	movi.n	a8, 16
42005a7c:	ffc346        	j	4200598d <uart_tcgetattr+0x101>
42005a7f:	00          	.byte 00
        switch (baudrate) {
42005a80:	65a422        	movi	a2, 0x465
42005a83:	112270        	slli	a2, a2, 9
42005a86:	029827        	bne	a8, a2, 42005a8c <uart_tcgetattr+0x200>
42005a89:	002ec6        	j	42005b48 <uart_tcgetattr+0x2bc>
42005a8c:	119940        	slli	a9, a9, 12
42005a8f:	029897        	bne	a8, a9, 42005a95 <uart_tcgetattr+0x209>
42005a92:	002dc6        	j	42005b4d <uart_tcgetattr+0x2c1>
42005a95:	eb2221        	l32r	a2, 42000720 <_stext+0x700>
42005a98:	021827        	beq	a8, a2, 42005a9e <uart_tcgetattr+0x212>
42005a9b:	ffb946        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B500000;
42005a9e:	481c      	movi.n	a8, 20
42005aa0:	ffba46        	j	4200598d <uart_tcgetattr+0x101>
42005aa3:	00          	.byte 00
        switch (baudrate) {
42005aa4:	eb2021        	l32r	a2, 42000724 <_stext+0x704>
42005aa7:	029827        	bne	a8, a2, 42005aad <uart_tcgetattr+0x221>
42005aaa:	002906        	j	42005b52 <uart_tcgetattr+0x2c6>
42005aad:	233287        	bltu	a2, a8, 42005ad4 <uart_tcgetattr+0x248>
42005ab0:	eb1e21        	l32r	a2, 42000728 <_stext+0x708>
42005ab3:	029827        	bne	a8, a2, 42005ab9 <uart_tcgetattr+0x22d>
42005ab6:	002786        	j	42005b58 <uart_tcgetattr+0x2cc>
42005ab9:	eb1c21        	l32r	a2, 4200072c <_stext+0x70c>
42005abc:	029827        	bne	a8, a2, 42005ac2 <uart_tcgetattr+0x236>
42005abf:	002686        	j	42005b5d <uart_tcgetattr+0x2d1>
42005ac2:	65a422        	movi	a2, 0x465
42005ac5:	112260        	slli	a2, a2, 10
42005ac8:	021827        	beq	a8, a2, 42005ace <uart_tcgetattr+0x242>
42005acb:	ffad46        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B1152000;
42005ace:	881c      	movi.n	a8, 24
42005ad0:	ffae46        	j	4200598d <uart_tcgetattr+0x101>
42005ad3:	00          	.byte 00
        switch (baudrate) {
42005ad4:	eb1721        	l32r	a2, 42000730 <_stext+0x710>
42005ad7:	029827        	bne	a8, a2, 42005add <uart_tcgetattr+0x251>
42005ada:	002106        	j	42005b62 <uart_tcgetattr+0x2d6>
42005add:	eb1521        	l32r	a2, 42000734 <_stext+0x714>
42005ae0:	029827        	bne	a8, a2, 42005ae6 <uart_tcgetattr+0x25a>
42005ae3:	002046        	j	42005b68 <uart_tcgetattr+0x2dc>
42005ae6:	eb1421        	l32r	a2, 42000738 <_stext+0x718>
42005ae9:	021827        	beq	a8, a2, 42005aef <uart_tcgetattr+0x263>
42005aec:	ffa506        	j	42005984 <uart_tcgetattr+0xf8>
                sp = B3000000;
42005aef:	c81c      	movi.n	a8, 28
42005af1:	ffa606        	j	4200598d <uart_tcgetattr+0x101>
                sp = B38400;
42005af4:	f80c      	movi.n	a8, 15
42005af6:	ffa4c6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B300;
42005af9:	780c      	movi.n	a8, 7
42005afb:	ffa386        	j	4200598d <uart_tcgetattr+0x101>
                sp = B110;
42005afe:	380c      	movi.n	a8, 3
42005b00:	ffa246        	j	4200598d <uart_tcgetattr+0x101>
42005b03:	00          	.byte 00
                sp = B50;
42005b04:	180c      	movi.n	a8, 1
42005b06:	ffa0c6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B75;
42005b09:	280c      	movi.n	a8, 2
42005b0b:	ff9f86        	j	4200598d <uart_tcgetattr+0x101>
                sp = B150;
42005b0e:	580c      	movi.n	a8, 5
42005b10:	ff9e46        	j	4200598d <uart_tcgetattr+0x101>
42005b13:	00          	.byte 00
                sp = B200;
42005b14:	680c      	movi.n	a8, 6
42005b16:	ff9cc6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B2400;
42005b19:	b80c      	movi.n	a8, 11
42005b1b:	ff9b86        	j	4200598d <uart_tcgetattr+0x101>
                sp = B1200;
42005b1e:	980c      	movi.n	a8, 9
42005b20:	ff9a46        	j	4200598d <uart_tcgetattr+0x101>
42005b23:	00          	.byte 00
                sp = B1800;
42005b24:	a80c      	movi.n	a8, 10
42005b26:	ff98c6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B9600;
42005b29:	d80c      	movi.n	a8, 13
42005b2b:	ff9786        	j	4200598d <uart_tcgetattr+0x101>
                sp = B19200;
42005b2e:	e80c      	movi.n	a8, 14
42005b30:	ff9646        	j	4200598d <uart_tcgetattr+0x101>
                sp = B1000000;
42005b33:	781c      	movi.n	a8, 23
42005b35:	ff9506        	j	4200598d <uart_tcgetattr+0x101>
                sp = B460800;
42005b38:	381c      	movi.n	a8, 19
42005b3a:	ff93c6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B115200;
42005b3d:	181c      	movi.n	a8, 17
42005b3f:	ff9286        	j	4200598d <uart_tcgetattr+0x101>
                sp = B230400;
42005b42:	281c      	movi.n	a8, 18
42005b44:	ff9146        	j	4200598d <uart_tcgetattr+0x101>
42005b47:	00          	.byte 00
                sp = B576000;
42005b48:	581c      	movi.n	a8, 21
42005b4a:	ff8fc6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B921600;
42005b4d:	681c      	movi.n	a8, 22
42005b4f:	ff8e86        	j	4200598d <uart_tcgetattr+0x101>
                sp = B2500000;
42005b52:	b81c      	movi.n	a8, 27
42005b54:	ff8d46        	j	4200598d <uart_tcgetattr+0x101>
42005b57:	00          	.byte 00
                sp = B1500000;
42005b58:	981c      	movi.n	a8, 25
42005b5a:	ff8bc6        	j	4200598d <uart_tcgetattr+0x101>
                sp = B2000000;
42005b5d:	a81c      	movi.n	a8, 26
42005b5f:	ff8a86        	j	4200598d <uart_tcgetattr+0x101>
                sp = B3500000;
42005b62:	d81c      	movi.n	a8, 29
42005b64:	ff8946        	j	4200598d <uart_tcgetattr+0x101>
42005b67:	00          	.byte 00
                sp = B4000000;
42005b68:	e81c      	movi.n	a8, 30
42005b6a:	ff87c6        	j	4200598d <uart_tcgetattr+0x101>
42005b6d:	000000        	ill

42005b70 <uart_tcsetattr>:
{
42005b70:	004136        	entry	a1, 32
42005b73:	205220        	or	a5, a2, a2
    if (fd < 0 || fd >= UART_NUM) {
42005b76:	1032b6        	bltui	a2, 3, 42005b8a <uart_tcsetattr+0x1a>
        errno = EBADF;
42005b79:	03d1e5        	call8	42009898 <__errno>
42005b7c:	09a022        	movi	a2, 9
                errno = EINVAL;
42005b7f:	006a22        	s32i	a2, a10, 0
                return -1;
42005b82:	f27c      	movi.n	a2, -1
42005b84:	003606        	j	42005c60 <uart_tcsetattr+0xf0>
42005b87:	00          	.byte 00
42005b88:	00          	.byte 00
42005b89:	00          	.byte 00
    if (p == NULL) {
42005b8a:	74cc      	bnez.n	a4, 42005b95 <uart_tcsetattr+0x25>
                errno = EINVAL;
42005b8c:	03d0a5        	call8	42009898 <__errno>
42005b8f:	621c      	movi.n	a2, 22
42005b91:	fffa86        	j	42005b7f <uart_tcsetattr+0xf>
42005b94:	00          	.byte 00
    switch (optional_actions) {
42005b95:	021366        	bnei	a3, 1, 42005b9b <uart_tcsetattr+0x2b>
42005b98:	003186        	j	42005c62 <uart_tcsetattr+0xf2>
42005b9b:	022366        	bnei	a3, 2, 42005ba1 <uart_tcsetattr+0x31>
42005b9e:	003286        	j	42005c6c <uart_tcsetattr+0xfc>
42005ba1:	fe7356        	bnez	a3, 42005b8c <uart_tcsetattr+0x1c>
        s_ctx[fd]->rx_mode = ESP_LINE_ENDINGS_CRLF;
42005ba4:	ead921        	l32r	a2, 42000708 <_stext+0x6e8>
    if (p->c_iflag & IGNCR) {
42005ba7:	001482        	l16ui	a8, a4, 0
        s_ctx[fd]->rx_mode = ESP_LINE_ENDINGS_CRLF;
42005baa:	a02520        	addx4	a2, a5, a2
42005bad:	0238      	l32i.n	a3, a2, 0
42005baf:	020c      	movi.n	a2, 0
    if (p->c_iflag & IGNCR) {
42005bb1:	09e837        	bbsi	a8, 3, 42005bbe <uart_tcsetattr+0x4e>
    } else if (p->c_iflag & ICRNL) {
42005bb4:	048180        	extui	a8, a8, 1, 1
42005bb7:	220c      	movi.n	a2, 2
42005bb9:	190c      	movi.n	a9, 1
42005bbb:	932980        	movnez	a2, a9, a8
        s_ctx[fd]->rx_mode = ESP_LINE_ENDINGS_CRLF;
42005bbe:	6329      	s32i.n	a2, a3, 24
        const tcflag_t csize_bits = p->c_cflag & CSIZE;
42005bc0:	021422        	l16ui	a2, a4, 4
                data_bits = UART_DATA_7_BITS;
42005bc3:	2b0c      	movi.n	a11, 2
        const tcflag_t csize_bits = p->c_cflag & CSIZE;
42005bc5:	142020        	extui	a2, a2, 0, 2
        switch (csize_bits) {
42005bc8:	0d12b7        	beq	a2, a11, 42005bd9 <uart_tcsetattr+0x69>
                data_bits = UART_DATA_8_BITS;
42005bcb:	3b0c      	movi.n	a11, 3
        switch (csize_bits) {
42005bcd:	0812b7        	beq	a2, a11, 42005bd9 <uart_tcsetattr+0x69>
42005bd0:	220b      	addi.n	a2, a2, -1
42005bd2:	1b0c      	movi.n	a11, 1
42005bd4:	030c      	movi.n	a3, 0
42005bd6:	93b320        	movnez	a11, a3, a2
        if (uart_set_word_length(fd, data_bits) != ESP_OK) {
42005bd9:	05ad      	mov.n	a10, a5
42005bdb:	01ab65        	call8	42007690 <uart_set_word_length>
42005bde:	faaa56        	bnez	a10, 42005b8c <uart_tcsetattr+0x1c>
    if (uart_set_stop_bits(fd, (p->c_cflag & CSTOPB) ? UART_STOP_BITS_2 : UART_STOP_BITS_1) != ESP_OK) {
42005be1:	021422        	l16ui	a2, a4, 4
42005be4:	330c      	movi.n	a3, 3
42005be6:	042220        	extui	a2, a2, 2, 1
42005be9:	1b0c      	movi.n	a11, 1
42005beb:	93b320        	movnez	a11, a3, a2
42005bee:	05ad      	mov.n	a10, a5
42005bf0:	01af65        	call8	420076e8 <uart_set_stop_bits>
42005bf3:	f95a56        	bnez	a10, 42005b8c <uart_tcsetattr+0x1c>
    if (uart_set_parity(fd, (p->c_cflag & PARENB) ?
42005bf6:	021422        	l16ui	a2, a4, 4
42005bf9:	0abd      	mov.n	a11, a10
42005bfb:	076247        	bbci	a2, 4, 42005c06 <uart_tcsetattr+0x96>
                :
42005bfe:	042520        	extui	a2, a2, 5, 1
42005c01:	2b0c      	movi.n	a11, 2
42005c03:	93b320        	movnez	a11, a3, a2
    if (uart_set_parity(fd, (p->c_cflag & PARENB) ?
42005c06:	20a550        	or	a10, a5, a5
42005c09:	01b4a5        	call8	42007754 <uart_set_parity>
42005c0c:	202aa0        	or	a2, a10, a10
42005c0f:	f79a56        	bnez	a10, 42005b8c <uart_tcsetattr+0x1c>
    if (p->c_cflag & (CBAUD | CBAUDEX)) {
42005c12:	021432        	l16ui	a3, a4, 4
42005c15:	00a382        	movi	a8, 0x300
42005c18:	440387        	bnone	a3, a8, 42005c60 <uart_tcsetattr+0xf0>
        if (p->c_ispeed != p->c_ospeed) {
42005c1b:	54b8      	l32i.n	a11, a4, 20
42005c1d:	6448      	l32i.n	a4, a4, 24
42005c1f:	021b47        	beq	a11, a4, 42005c25 <uart_tcsetattr+0xb5>
42005c22:	ffd986        	j	42005b8c <uart_tcsetattr+0x1c>
            if (p->c_cflag & BOTHER) {
42005c25:	2ee3a7        	bbsi	a3, 10, 42005c57 <uart_tcsetattr+0xe7>
                switch (p->c_ispeed) {
42005c28:	f30c      	movi.n	a3, 15
42005c2a:	029b37        	bne	a11, a3, 42005c30 <uart_tcsetattr+0xc0>
42005c2d:	004e86        	j	42005d6b <uart_tcsetattr+0x1fb>
42005c30:	02b3b7        	bgeu	a3, a11, 42005c36 <uart_tcsetattr+0xc6>
42005c33:	002746        	j	42005cd4 <uart_tcsetattr+0x164>
42005c36:	027b66        	bnei	a11, 7, 42005c3c <uart_tcsetattr+0xcc>
42005c39:	004dc6        	j	42005d74 <uart_tcsetattr+0x204>
42005c3c:	508bf6        	bgeui	a11, 8, 42005c90 <uart_tcsetattr+0x120>
42005c3f:	023b66        	bnei	a11, 3, 42005c45 <uart_tcsetattr+0xd5>
42005c42:	004d86        	j	42005d7c <uart_tcsetattr+0x20c>
42005c45:	2f4bf6        	bgeui	a11, 4, 42005c78 <uart_tcsetattr+0x108>
42005c48:	021b66        	bnei	a11, 1, 42005c4e <uart_tcsetattr+0xde>
42005c4b:	004cc6        	j	42005d82 <uart_tcsetattr+0x212>
42005c4e:	022b66        	bnei	a11, 2, 42005c54 <uart_tcsetattr+0xe4>
42005c51:	004cc6        	j	42005d88 <uart_tcsetattr+0x218>
42005c54:	f34b56        	bnez	a11, 42005b8c <uart_tcsetattr+0x1c>
            if (uart_set_baudrate(fd, b) != ESP_OK) {
42005c57:	20a550        	or	a10, a5, a5
42005c5a:	01b625        	call8	420077bc <uart_set_baudrate>
42005c5d:	f2ba56        	bnez	a10, 42005b8c <uart_tcsetattr+0x1c>
}
42005c60:	f01d      	retw.n
            if (uart_wait_tx_done(fd, portMAX_DELAY) != ESP_OK) {
42005c62:	fb7c      	movi.n	a11, -1
42005c64:	02ad      	mov.n	a10, a2
42005c66:	022065        	call8	42007e6c <uart_wait_tx_done>
42005c69:	f1fa56        	bnez	a10, 42005b8c <uart_tcsetattr+0x1c>
            if (uart_flush_input(fd) != ESP_OK) {
42005c6c:	05ad      	mov.n	a10, a5
42005c6e:	024ee5        	call8	4200815c <uart_flush>
42005c71:	f2fa16        	beqz	a10, 42005ba4 <uart_tcsetattr+0x34>
42005c74:	ffc506        	j	42005b8c <uart_tcsetattr+0x1c>
42005c77:	00          	.byte 00
                switch (p->c_ispeed) {
42005c78:	025b66        	bnei	a11, 5, 42005c7e <uart_tcsetattr+0x10e>
42005c7b:	004386        	j	42005d8d <uart_tcsetattr+0x21d>
42005c7e:	026b66        	bnei	a11, 6, 42005c84 <uart_tcsetattr+0x114>
42005c81:	0043c6        	j	42005d94 <uart_tcsetattr+0x224>
42005c84:	024b26        	beqi	a11, 4, 42005c8a <uart_tcsetattr+0x11a>
42005c87:	ffc046        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 134;
42005c8a:	86a0b2        	movi	a11, 134
42005c8d:	fff186        	j	42005c57 <uart_tcsetattr+0xe7>
                switch (p->c_ispeed) {
42005c90:	b30c      	movi.n	a3, 11
42005c92:	029b37        	bne	a11, a3, 42005c98 <uart_tcsetattr+0x128>
42005c95:	004046        	j	42005d9a <uart_tcsetattr+0x22a>
42005c98:	1933b7        	bltu	a3, a11, 42005cb5 <uart_tcsetattr+0x145>
42005c9b:	930c      	movi.n	a3, 9
42005c9d:	029b37        	bne	a11, a3, 42005ca3 <uart_tcsetattr+0x133>
42005ca0:	004006        	j	42005da4 <uart_tcsetattr+0x234>
42005ca3:	029b66        	bnei	a11, 10, 42005ca9 <uart_tcsetattr+0x139>
42005ca6:	004086        	j	42005dac <uart_tcsetattr+0x23c>
42005ca9:	028b26        	beqi	a11, 8, 42005caf <uart_tcsetattr+0x13f>
42005cac:	ffb706        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 600;
42005caf:	58a2b2        	movi	a11, 0x258
42005cb2:	ffe846        	j	42005c57 <uart_tcsetattr+0xe7>
                switch (p->c_ispeed) {
42005cb5:	d30c      	movi.n	a3, 13
42005cb7:	029b37        	bne	a11, a3, 42005cbd <uart_tcsetattr+0x14d>
42005cba:	003d06        	j	42005db2 <uart_tcsetattr+0x242>
42005cbd:	e30c      	movi.n	a3, 14
42005cbf:	029b37        	bne	a11, a3, 42005cc5 <uart_tcsetattr+0x155>
42005cc2:	003d06        	j	42005dba <uart_tcsetattr+0x24a>
42005cc5:	02ab26        	beqi	a11, 12, 42005ccb <uart_tcsetattr+0x15b>
42005cc8:	ffb006        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 4800;
42005ccb:	bb4c      	movi.n	a11, 75
42005ccd:	11bba0        	slli	a11, a11, 6
42005cd0:	ffe0c6        	j	42005c57 <uart_tcsetattr+0xe7>
42005cd3:	00          	.byte 00
                switch (p->c_ispeed) {
42005cd4:	731c      	movi.n	a3, 23
42005cd6:	029b37        	bne	a11, a3, 42005cdc <uart_tcsetattr+0x16c>
42005cd9:	0039c6        	j	42005dc4 <uart_tcsetattr+0x254>
42005cdc:	4433b7        	bltu	a3, a11, 42005d24 <uart_tcsetattr+0x1b4>
42005cdf:	331c      	movi.n	a3, 19
42005ce1:	029b37        	bne	a11, a3, 42005ce7 <uart_tcsetattr+0x177>
42005ce4:	003906        	j	42005dcc <uart_tcsetattr+0x25c>
42005ce7:	1b33b7        	bltu	a3, a11, 42005d06 <uart_tcsetattr+0x196>
42005cea:	131c      	movi.n	a3, 17
42005cec:	029b37        	bne	a11, a3, 42005cf2 <uart_tcsetattr+0x182>
42005cef:	003886        	j	42005dd5 <uart_tcsetattr+0x265>
42005cf2:	231c      	movi.n	a3, 18
42005cf4:	029b37        	bne	a11, a3, 42005cfa <uart_tcsetattr+0x18a>
42005cf7:	003846        	j	42005ddc <uart_tcsetattr+0x26c>
42005cfa:	02bb26        	beqi	a11, 16, 42005d00 <uart_tcsetattr+0x190>
42005cfd:	ffa2c6        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 57600;
42005d00:	e1a0b2        	movi	a11, 225
42005d03:	002d46        	j	42005dbc <uart_tcsetattr+0x24c>
                switch (p->c_ispeed) {
42005d06:	531c      	movi.n	a3, 21
42005d08:	029b37        	bne	a11, a3, 42005d0e <uart_tcsetattr+0x19e>
42005d0b:	003586        	j	42005de5 <uart_tcsetattr+0x275>
42005d0e:	631c      	movi.n	a3, 22
42005d10:	029b37        	bne	a11, a3, 42005d16 <uart_tcsetattr+0x1a6>
42005d13:	003546        	j	42005dec <uart_tcsetattr+0x27c>
42005d16:	431c      	movi.n	a3, 20
42005d18:	021b37        	beq	a11, a3, 42005d1e <uart_tcsetattr+0x1ae>
42005d1b:	ff9b46        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 500000;
42005d1e:	ea80b1        	l32r	a11, 42000720 <_stext+0x700>
42005d21:	ffcc86        	j	42005c57 <uart_tcsetattr+0xe7>
                switch (p->c_ispeed) {
42005d24:	b31c      	movi.n	a3, 27
42005d26:	029b37        	bne	a11, a3, 42005d2c <uart_tcsetattr+0x1bc>
42005d29:	003206        	j	42005df5 <uart_tcsetattr+0x285>
42005d2c:	1d33b7        	bltu	a3, a11, 42005d4d <uart_tcsetattr+0x1dd>
42005d2f:	931c      	movi.n	a3, 25
42005d31:	029b37        	bne	a11, a3, 42005d37 <uart_tcsetattr+0x1c7>
42005d34:	003106        	j	42005dfc <uart_tcsetattr+0x28c>
42005d37:	a31c      	movi.n	a3, 26
42005d39:	029b37        	bne	a11, a3, 42005d3f <uart_tcsetattr+0x1cf>
42005d3c:	003106        	j	42005e04 <uart_tcsetattr+0x294>
42005d3f:	831c      	movi.n	a3, 24
42005d41:	021b37        	beq	a11, a3, 42005d47 <uart_tcsetattr+0x1d7>
42005d44:	ff9106        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 1152000;
42005d47:	65a4b2        	movi	a11, 0x465
42005d4a:	002446        	j	42005ddf <uart_tcsetattr+0x26f>
                switch (p->c_ispeed) {
42005d4d:	d31c      	movi.n	a3, 29
42005d4f:	029b37        	bne	a11, a3, 42005d55 <uart_tcsetattr+0x1e5>
42005d52:	002d86        	j	42005e0c <uart_tcsetattr+0x29c>
42005d55:	e31c      	movi.n	a3, 30
42005d57:	029b37        	bne	a11, a3, 42005d5d <uart_tcsetattr+0x1ed>
42005d5a:	002d06        	j	42005e12 <uart_tcsetattr+0x2a2>
42005d5d:	c31c      	movi.n	a3, 28
42005d5f:	021b37        	beq	a11, a3, 42005d65 <uart_tcsetattr+0x1f5>
42005d62:	ff8986        	j	42005b8c <uart_tcsetattr+0x1c>
                        b = 3000000;
42005d65:	ea74b1        	l32r	a11, 42000738 <_stext+0x718>
42005d68:	ffbac6        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 38400;
42005d6b:	bb4c      	movi.n	a11, 75
                        b = 115200;
42005d6d:	11bb70        	slli	a11, a11, 9
42005d70:	ffb8c6        	j	42005c57 <uart_tcsetattr+0xe7>
42005d73:	00          	.byte 00
                        b = 300;
42005d74:	2ca1b2        	movi	a11, 0x12c
42005d77:	ffb706        	j	42005c57 <uart_tcsetattr+0xe7>
42005d7a:	00          	.byte 00
42005d7b:	00          	.byte 00
                        b = 110;
42005d7c:	6ea0b2        	movi	a11, 110
42005d7f:	ffb506        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 50;
42005d82:	2b3c      	movi.n	a11, 50
42005d84:	ffb3c6        	j	42005c57 <uart_tcsetattr+0xe7>
42005d87:	00          	.byte 00
                switch (p->c_ispeed) {
42005d88:	bb4c      	movi.n	a11, 75
42005d8a:	ffb246        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 150;
42005d8d:	96a0b2        	movi	a11, 150
42005d90:	ffb0c6        	j	42005c57 <uart_tcsetattr+0xe7>
42005d93:	00          	.byte 00
                        b = 200;
42005d94:	c8a0b2        	movi	a11, 200
42005d97:	ffaf06        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 2400;
42005d9a:	bb4c      	movi.n	a11, 75
42005d9c:	11bbb0        	slli	a11, a11, 5
42005d9f:	ffad06        	j	42005c57 <uart_tcsetattr+0xe7>
42005da2:	00          	.byte 00
42005da3:	00          	.byte 00
                        b = 1200;
42005da4:	b0a4b2        	movi	a11, 0x4b0
42005da7:	ffab06        	j	42005c57 <uart_tcsetattr+0xe7>
42005daa:	00          	.byte 00
42005dab:	00          	.byte 00
                        b = 1800;
42005dac:	08a7b2        	movi	a11, 0x708
42005daf:	ffa906        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 9600;
42005db2:	bb4c      	movi.n	a11, 75
42005db4:	11bb90        	slli	a11, a11, 7
42005db7:	ffa706        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 19200;
42005dba:	bb4c      	movi.n	a11, 75
                        b = 57600;
42005dbc:	11bb80        	slli	a11, a11, 8
42005dbf:	ffa506        	j	42005c57 <uart_tcsetattr+0xe7>
42005dc2:	00          	.byte 00
42005dc3:	00          	.byte 00
                        b = 1000000;
42005dc4:	ea05b1        	l32r	a11, 420005d8 <_stext+0x5b8>
42005dc7:	ffa306        	j	42005c57 <uart_tcsetattr+0xe7>
42005dca:	00          	.byte 00
42005dcb:	00          	.byte 00
                        b = 460800;
42005dcc:	e1a0b2        	movi	a11, 225
42005dcf:	11bb50        	slli	a11, a11, 11
42005dd2:	ffa046        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 115200;
42005dd5:	e1a0b2        	movi	a11, 225
42005dd8:	ffe446        	j	42005d6d <uart_tcsetattr+0x1fd>
42005ddb:	00          	.byte 00
                        b = 230400;
42005ddc:	e1a0b2        	movi	a11, 225
                        b = 1152000;
42005ddf:	11bb60        	slli	a11, a11, 10
42005de2:	ff9c46        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 576000;
42005de5:	65a4b2        	movi	a11, 0x465
42005de8:	ffe046        	j	42005d6d <uart_tcsetattr+0x1fd>
42005deb:	00          	.byte 00
                        b = 921600;
42005dec:	e1a0b2        	movi	a11, 225
42005def:	11bb40        	slli	a11, a11, 12
42005df2:	ff9846        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 2500000;
42005df5:	ea4bb1        	l32r	a11, 42000724 <_stext+0x704>
42005df8:	ff96c6        	j	42005c57 <uart_tcsetattr+0xe7>
42005dfb:	00          	.byte 00
                        b = 1500000;
42005dfc:	ea4bb1        	l32r	a11, 42000728 <_stext+0x708>
42005dff:	ff9506        	j	42005c57 <uart_tcsetattr+0xe7>
42005e02:	00          	.byte 00
42005e03:	00          	.byte 00
                        b = 2000000;
42005e04:	ea4ab1        	l32r	a11, 4200072c <_stext+0x70c>
42005e07:	ff9306        	j	42005c57 <uart_tcsetattr+0xe7>
42005e0a:	00          	.byte 00
42005e0b:	00          	.byte 00
                        b = 3500000;
42005e0c:	ea49b1        	l32r	a11, 42000730 <_stext+0x710>
42005e0f:	ff9106        	j	42005c57 <uart_tcsetattr+0xe7>
                        b = 4000000;
42005e12:	ea48b1        	l32r	a11, 42000734 <_stext+0x714>
42005e15:	ff8f86        	j	42005c57 <uart_tcsetattr+0xe7>

42005e18 <uart_access>:
{
42005e18:	004136        	entry	a1, 32
    if (strcmp(path, "/0") == 0 || strcmp(path, "/1") == 0 || strcmp(path, "/2") == 0) {
42005e1b:	ea48b1        	l32r	a11, 4200073c <_stext+0x71c>
42005e1e:	02ad      	mov.n	a10, a2
42005e20:	ea4a81        	l32r	a8, 42000748 <_stext+0x728>
42005e23:	0008e0        	callx8	a8
42005e26:	01aa16        	beqz	a10, 42005e44 <uart_access+0x2c>
42005e29:	ea45b1        	l32r	a11, 42000740 <_stext+0x720>
42005e2c:	20a220        	or	a10, a2, a2
42005e2f:	ea4681        	l32r	a8, 42000748 <_stext+0x728>
42005e32:	0008e0        	callx8	a8
42005e35:	ba8c      	beqz.n	a10, 42005e44 <uart_access+0x2c>
42005e37:	ea43b1        	l32r	a11, 42000744 <_stext+0x724>
42005e3a:	02ad      	mov.n	a10, a2
42005e3c:	ea4381        	l32r	a8, 42000748 <_stext+0x728>
42005e3f:	0008e0        	callx8	a8
42005e42:	aadc      	bnez.n	a10, 42005e60 <uart_access+0x48>
        if (F_OK == amode) {
42005e44:	439c      	beqz.n	a3, 42005e5c <uart_access+0x44>
            if ((((amode & R_OK) == R_OK) || ((amode & W_OK) == W_OK)) && ((amode & X_OK) != X_OK)) {
42005e46:	620c      	movi.n	a2, 6
42005e48:	040327        	bnone	a3, a2, 42005e50 <uart_access+0x38>
42005e4b:	043030        	extui	a3, a3, 0, 1
42005e4e:	a38c      	beqz.n	a3, 42005e5c <uart_access+0x44>
                errno = EACCES;
42005e50:	03a465        	call8	42009898 <__errno>
42005e53:	0da022        	movi	a2, 13
        errno = ENOENT;
42005e56:	006a22        	s32i	a2, a10, 0
    int ret = -1;
42005e59:	ffaf32        	movi	a3, -1
}
42005e5c:	032d      	mov.n	a2, a3
42005e5e:	f01d      	retw.n
        errno = ENOENT;
42005e60:	03a365        	call8	42009898 <__errno>
42005e63:	220c      	movi.n	a2, 2
42005e65:	fffb46        	j	42005e56 <uart_access+0x3e>

42005e68 <uart_open>:
{
42005e68:	004136        	entry	a1, 32
    if (strcmp(path, "/0") == 0) {
42005e6b:	ea34b1        	l32r	a11, 4200073c <_stext+0x71c>
42005e6e:	02ad      	mov.n	a10, a2
42005e70:	ea3681        	l32r	a8, 42000748 <_stext+0x728>
42005e73:	0008e0        	callx8	a8
{
42005e76:	024d      	mov.n	a4, a2
    if (strcmp(path, "/0") == 0) {
42005e78:	0a2d      	mov.n	a2, a10
42005e7a:	6aac      	beqz.n	a10, 42005ea4 <uart_open+0x3c>
    } else if (strcmp(path, "/1") == 0) {
42005e7c:	ea31b1        	l32r	a11, 42000740 <_stext+0x720>
42005e7f:	20a440        	or	a10, a4, a4
42005e82:	ea3181        	l32r	a8, 42000748 <_stext+0x728>
42005e85:	0008e0        	callx8	a8
42005e88:	6a9c      	beqz.n	a10, 42005ea2 <uart_open+0x3a>
    } else if (strcmp(path, "/2") == 0) {
42005e8a:	ea2eb1        	l32r	a11, 42000744 <_stext+0x724>
42005e8d:	04ad      	mov.n	a10, a4
42005e8f:	ea2e81        	l32r	a8, 42000748 <_stext+0x728>
42005e92:	0008e0        	callx8	a8
42005e95:	220c      	movi.n	a2, 2
42005e97:	9a8c      	beqz.n	a10, 42005ea4 <uart_open+0x3c>
        errno = ENOENT;
42005e99:	039fe5        	call8	42009898 <__errno>
42005e9c:	0a29      	s32i.n	a2, a10, 0
        return fd;
42005e9e:	f27c      	movi.n	a2, -1
}
42005ea0:	f01d      	retw.n
        fd = 1;
42005ea2:	120c      	movi.n	a2, 1
    s_ctx[fd]->non_blocking = ((flags & O_NONBLOCK) == O_NONBLOCK);
42005ea4:	ea1981        	l32r	a8, 42000708 <_stext+0x6e8>
42005ea7:	043e30        	extui	a3, a3, 14, 1
42005eaa:	a08280        	addx4	a8, a2, a8
42005ead:	0848      	l32i.n	a4, a8, 0
42005eaf:	104432        	s8i	a3, a4, 16
    return fd;
42005eb2:	fffa86        	j	42005ea0 <uart_open+0x38>
42005eb5:	000000        	ill

42005eb8 <uart_tcflush>:

    return 0;
}

static int uart_tcflush(int fd, int select)
{
42005eb8:	004136        	entry	a1, 32
42005ebb:	20a220        	or	a10, a2, a2
    if (fd < 0 || fd >= UART_NUM) {
42005ebe:	0f32b6        	bltui	a2, 3, 42005ed1 <uart_tcflush+0x19>
        errno = EBADF;
42005ec1:	039d65        	call8	42009898 <__errno>
42005ec4:	09a032        	movi	a3, 9
42005ec7:	006a32        	s32i	a3, a10, 0
            return -1;
        }
    } else {
        // output flushing is not supported
        errno = EINVAL;
        return -1;
42005eca:	fa7c      	movi.n	a10, -1
    }

    return 0;
}
42005ecc:	0a2d      	mov.n	a2, a10
42005ece:	f01d      	retw.n
42005ed0:	00          	.byte 00
    if (select == TCIFLUSH) {
42005ed1:	43cc      	bnez.n	a3, 42005ed9 <uart_tcflush+0x21>
        if (uart_flush_input(fd) != ESP_OK) {
42005ed3:	0228a5        	call8	4200815c <uart_flush>
42005ed6:	ff2a16        	beqz	a10, 42005ecc <uart_tcflush+0x14>
        errno = EINVAL;
42005ed9:	039be5        	call8	42009898 <__errno>
42005edc:	681c      	movi.n	a8, 22
42005ede:	0a89      	s32i.n	a8, a10, 0
42005ee0:	fff986        	j	42005eca <uart_tcflush+0x12>
	...

42005ee4 <uart_fcntl>:
{
42005ee4:	004136        	entry	a1, 32
    assert(fd >=0 && fd < 3);
42005ee7:	1132b6        	bltui	a2, 3, 42005efc <uart_fcntl+0x18>
42005eea:	ea18d1        	l32r	a13, 4200074c <_stext+0x72c>
42005eed:	ea18c1        	l32r	a12, 42000750 <_stext+0x730>
42005ef0:	ea19a1        	l32r	a10, 42000754 <_stext+0x734>
42005ef3:	2ba1b2        	movi	a11, 0x12b
42005ef6:	e86381        	l32r	a8, 42000084 <_stext+0x64>
42005ef9:	0008e0        	callx8	a8
    if (cmd == F_GETFL) {
42005efc:	143366        	bnei	a3, 3, 42005f14 <uart_fcntl+0x30>
        if (s_ctx[fd]->non_blocking) {
42005eff:	ea0231        	l32r	a3, 42000708 <_stext+0x6e8>
42005f02:	a02230        	addx4	a2, a2, a3
42005f05:	0228      	l32i.n	a2, a2, 0
42005f07:	100232        	l8ui	a3, a2, 16
        result |= O_RDWR;
42005f0a:	220c      	movi.n	a2, 2
        if (s_ctx[fd]->non_blocking) {
42005f0c:	138c      	beqz.n	a3, 42005f11 <uart_fcntl+0x2d>
            result |= O_NONBLOCK;
42005f0e:	e9f821        	l32r	a2, 420006f0 <_stext+0x6d0>
}
42005f11:	f01d      	retw.n
42005f13:	00          	.byte 00
    } else if (cmd == F_SETFL) {
42005f14:	124366        	bnei	a3, 4, 42005f2a <uart_fcntl+0x46>
        s_ctx[fd]->non_blocking = (arg & O_NONBLOCK) != 0;
42005f17:	e9fc31        	l32r	a3, 42000708 <_stext+0x6e8>
42005f1a:	044e40        	extui	a4, a4, 14, 1
42005f1d:	a02230        	addx4	a2, a2, a3
42005f20:	0228      	l32i.n	a2, a2, 0
42005f22:	104242        	s8i	a4, a2, 16
    int result = 0;
42005f25:	020c      	movi.n	a2, 0
42005f27:	fff986        	j	42005f11 <uart_fcntl+0x2d>
        errno = ENOSYS;
42005f2a:	58a022        	movi	a2, 88
42005f2d:	0396a5        	call8	42009898 <__errno>
42005f30:	006a22        	s32i	a2, a10, 0
42005f33:	ffaf22        	movi	a2, -1
42005f36:	fff5c6        	j	42005f11 <uart_fcntl+0x2d>
42005f39:	000000        	ill

42005f3c <uart_fstat>:
{
42005f3c:	004136        	entry	a1, 32
    assert(fd >=0 && fd < 3);
42005f3f:	1132b6        	bltui	a2, 3, 42005f54 <uart_fstat+0x18>
42005f42:	ea02d1        	l32r	a13, 4200074c <_stext+0x72c>
42005f45:	ea04c1        	l32r	a12, 42000758 <_stext+0x738>
42005f48:	ea03a1        	l32r	a10, 42000754 <_stext+0x734>
42005f4b:	1da1b2        	movi	a11, 0x11d
42005f4e:	e84d81        	l32r	a8, 42000084 <_stext+0x64>
42005f51:	0008e0        	callx8	a8
    memset(st, 0, sizeof(*st));
42005f54:	8c5c      	movi.n	a12, 88
42005f56:	0b0c      	movi.n	a11, 0
42005f58:	03ad      	mov.n	a10, a3
42005f5a:	e88f81        	l32r	a8, 42000198 <_stext+0x178>
42005f5d:	0008e0        	callx8	a8
    st->st_mode = S_IFCHR;
42005f60:	e9df81        	l32r	a8, 420006dc <_stext+0x6bc>
}
42005f63:	020c      	movi.n	a2, 0
    st->st_mode = S_IFCHR;
42005f65:	1389      	s32i.n	a8, a3, 4
}
42005f67:	f01d      	retw.n
42005f69:	000000        	ill

42005f6c <uart_close>:
{
42005f6c:	004136        	entry	a1, 32
    assert(fd >=0 && fd < 3);
42005f6f:	1132b6        	bltui	a2, 3, 42005f84 <uart_close+0x18>
42005f72:	e9f6d1        	l32r	a13, 4200074c <_stext+0x72c>
42005f75:	e9f9c1        	l32r	a12, 4200075c <_stext+0x73c>
42005f78:	e9f7a1        	l32r	a10, 42000754 <_stext+0x734>
42005f7b:	25a1b2        	movi	a11, 0x125
42005f7e:	e84181        	l32r	a8, 42000084 <_stext+0x64>
42005f81:	0008e0        	callx8	a8
}
42005f84:	020c      	movi.n	a2, 0
42005f86:	f01d      	retw.n

42005f88 <uart_return_char>:
{
42005f88:	004136        	entry	a1, 32
    assert(s_ctx[fd]->peek_char == NONE);
42005f8b:	e9df81        	l32r	a8, 42000708 <_stext+0x6e8>
42005f8e:	a02280        	addx4	a2, a2, a8
42005f91:	0228      	l32i.n	a2, a2, 0
42005f93:	1288      	l32i.n	a8, a2, 4
42005f95:	110826        	beqi	a8, -1, 42005faa <uart_return_char+0x22>
42005f98:	e9f2d1        	l32r	a13, 42000760 <_stext+0x740>
42005f9b:	e9f2c1        	l32r	a12, 42000764 <_stext+0x744>
42005f9e:	e9eda1        	l32r	a10, 42000754 <_stext+0x734>
42005fa1:	e9a0b2        	movi	a11, 233
42005fa4:	e83881        	l32r	a8, 42000084 <_stext+0x64>
42005fa7:	0008e0        	callx8	a8
    s_ctx[fd]->peek_char = c;
42005faa:	1239      	s32i.n	a3, a2, 4
}
42005fac:	f01d      	retw.n
	...

42005fb0 <uart_fsync>:
{
42005fb0:	004136        	entry	a1, 32
    assert(fd >= 0 && fd < 3);
42005fb3:	1132b6        	bltui	a2, 3, 42005fc8 <uart_fsync+0x18>
42005fb6:	e9ecd1        	l32r	a13, 42000768 <_stext+0x748>
42005fb9:	e9ecc1        	l32r	a12, 4200076c <_stext+0x74c>
42005fbc:	e9e6a1        	l32r	a10, 42000754 <_stext+0x734>
42005fbf:	57a1b2        	movi	a11, 0x157
42005fc2:	e83081        	l32r	a8, 42000084 <_stext+0x64>
42005fc5:	0008e0        	callx8	a8
    _lock_acquire_recursive(&s_ctx[fd]->write_lock);
42005fc8:	e9d031        	l32r	a3, 42000708 <_stext+0x6e8>
42005fcb:	a03230        	addx4	a3, a2, a3
42005fce:	0338      	l32i.n	a3, a3, 0
42005fd0:	33cb      	addi.n	a3, a3, 12
42005fd2:	03ad      	mov.n	a10, a3
42005fd4:	e9c581        	l32r	a8, 420006e8 <_stext+0x6c8>
42005fd7:	0008e0        	callx8	a8
    esp_rom_uart_tx_wait_idle((uint8_t) fd);
42005fda:	02ad      	mov.n	a10, a2
42005fdc:	e83681        	l32r	a8, 420000b4 <_stext+0x94>
42005fdf:	0008e0        	callx8	a8
    _lock_release_recursive(&s_ctx[fd]->write_lock);
42005fe2:	03ad      	mov.n	a10, a3
42005fe4:	e9c281        	l32r	a8, 420006ec <_stext+0x6cc>
42005fe7:	0008e0        	callx8	a8
}
42005fea:	020c      	movi.n	a2, 0
42005fec:	f01d      	retw.n
	...

42005ff0 <uart_read>:
{
42005ff0:	006136        	entry	a1, 48
42005ff3:	027d      	mov.n	a7, a2
    assert(fd >=0 && fd < 3);
42005ff5:	1132b6        	bltui	a2, 3, 4200600a <uart_read+0x1a>
42005ff8:	e9d5d1        	l32r	a13, 4200074c <_stext+0x72c>
42005ffb:	e9ddc1        	l32r	a12, 42000770 <_stext+0x750>
42005ffe:	e9d5a1        	l32r	a10, 42000754 <_stext+0x734>
42006001:	efa0b2        	movi	a11, 239
42006004:	e82081        	l32r	a8, 42000084 <_stext+0x64>
42006007:	0008e0        	callx8	a8
    _lock_acquire_recursive(&s_ctx[fd]->read_lock);
4200600a:	e9bf21        	l32r	a2, 42000708 <_stext+0x6e8>
    size_t received = 0;
4200600d:	050c      	movi.n	a5, 0
    _lock_acquire_recursive(&s_ctx[fd]->read_lock);
4200600f:	a02720        	addx4	a2, a7, a2
42006012:	0228      	l32i.n	a2, a2, 0
42006014:	628b      	addi.n	a6, a2, 8
42006016:	06ad      	mov.n	a10, a6
42006018:	006122        	s32i	a2, a1, 0
4200601b:	e9b381        	l32r	a8, 420006e8 <_stext+0x6c8>
4200601e:	0008e0        	callx8	a8
    while (received < size) {
42006021:	371457        	beq	a4, a5, 4200605c <uart_read+0x6c>
        int c = uart_read_char(fd);
42006024:	20a770        	or	a10, a7, a7
42006027:	ff59e5        	call8	420055c4 <uart_read_char>
        if (c == '\r') {
4200602a:	0da082        	movi	a8, 13
        int c = uart_read_char(fd);
4200602d:	202aa0        	or	a2, a10, a10
        if (c == '\r') {
42006030:	509a87        	bne	a10, a8, 42006084 <uart_read+0x94>
            if (s_ctx[fd]->rx_mode == ESP_LINE_ENDINGS_CR) {
42006033:	0188      	l32i.n	a8, a1, 0
42006035:	68a8      	l32i.n	a10, a8, 24
42006037:	0e1a66        	bnei	a10, 1, 42006049 <uart_read+0x59>
                c = '\n';
4200603a:	a20c      	movi.n	a2, 10
        data_c[received] = (char) c;
4200603c:	a35a      	add.n	a10, a3, a5
4200603e:	004a22        	s8i	a2, a10, 0
        ++received;
42006041:	551b      	addi.n	a5, a5, 1
        if (c == '\n') {
42006043:	da9266        	bnei	a2, 10, 42006021 <uart_read+0x31>
42006046:	000486        	j	4200605c <uart_read+0x6c>
            } else if (s_ctx[fd]->rx_mode == ESP_LINE_ENDINGS_CRLF) {
42006049:	fefa56        	bnez	a10, 4200603c <uart_read+0x4c>
                int c2 = uart_read_char(fd);
4200604c:	20a770        	or	a10, a7, a7
4200604f:	ff5765        	call8	420055c4 <uart_read_char>
                if (c2 == NONE) {
42006052:	1e0a66        	bnei	a10, -1, 42006074 <uart_read+0x84>
                    uart_return_char(fd, c);
42006055:	db0c      	movi.n	a11, 13
42006057:	07ad      	mov.n	a10, a7
42006059:	fff2e5        	call8	42005f88 <uart_return_char>
    _lock_release_recursive(&s_ctx[fd]->read_lock);
4200605c:	06ad      	mov.n	a10, a6
4200605e:	e9a381        	l32r	a8, 420006ec <_stext+0x6cc>
42006061:	0008e0        	callx8	a8
        return received;
42006064:	052d      	mov.n	a2, a5
    if (received > 0) {
42006066:	75cc      	bnez.n	a5, 42006071 <uart_read+0x81>
    errno = EWOULDBLOCK;
42006068:	b20c      	movi.n	a2, 11
4200606a:	0382e5        	call8	42009898 <__errno>
4200606d:	0a29      	s32i.n	a2, a10, 0
    return -1;
4200606f:	f27c      	movi.n	a2, -1
}
42006071:	f01d      	retw.n
42006073:	00          	.byte 00
                if (c2 == '\n') {
42006074:	c29a26        	beqi	a10, 10, 4200603a <uart_read+0x4a>
                    uart_return_char(fd, c2);
42006077:	0abd      	mov.n	a11, a10
42006079:	07ad      	mov.n	a10, a7
4200607b:	fff0e5        	call8	42005f88 <uart_return_char>
4200607e:	ffee86        	j	4200603c <uart_read+0x4c>
42006081:	00          	.byte 00
42006082:	00          	.byte 00
42006083:	00          	.byte 00
        } else if (c == NONE) {
42006084:	b40a66        	bnei	a10, -1, 4200603c <uart_read+0x4c>
42006087:	fff446        	j	4200605c <uart_read+0x6c>
	...

4200608c <uart_write>:
{
4200608c:	006136        	entry	a1, 48
    assert(fd >=0 && fd < 3);
4200608f:	1132b6        	bltui	a2, 3, 420060a4 <uart_write+0x18>
42006092:	e9aed1        	l32r	a13, 4200074c <_stext+0x72c>
42006095:	e9b7c1        	l32r	a12, 42000774 <_stext+0x754>
42006098:	e9afa1        	l32r	a10, 42000754 <_stext+0x734>
4200609b:	c2a0b2        	movi	a11, 194
4200609e:	e7f981        	l32r	a8, 42000084 <_stext+0x64>
420060a1:	0008e0        	callx8	a8
    _lock_acquire_recursive(&s_ctx[fd]->write_lock);
420060a4:	e99961        	l32r	a6, 42000708 <_stext+0x6e8>
420060a7:	a06260        	addx4	a6, a2, a6
420060aa:	0658      	l32i.n	a5, a6, 0
420060ac:	75cb      	addi.n	a7, a5, 12
420060ae:	07ad      	mov.n	a10, a7
420060b0:	e98e81        	l32r	a8, 420006e8 <_stext+0x6c8>
420060b3:	0008e0        	callx8	a8
static ssize_t uart_write(int fd, const void * data, size_t size)
420060b6:	834a      	add.n	a8, a3, a4
420060b8:	0189      	s32i.n	a8, a1, 0
    for (size_t i = 0; i < size; i++) {
420060ba:	0188      	l32i.n	a8, a1, 0
420060bc:	0c9837        	bne	a8, a3, 420060cc <uart_write+0x40>
    _lock_release_recursive(&s_ctx[fd]->write_lock);
420060bf:	20a770        	or	a10, a7, a7
420060c2:	e98a81        	l32r	a8, 420006ec <_stext+0x6cc>
420060c5:	0008e0        	callx8	a8
}
420060c8:	042d      	mov.n	a2, a4
420060ca:	f01d      	retw.n
        int c = data_c[i];
420060cc:	000392        	l8ui	a9, a3, 0
        if (c == '\n' && s_ctx[fd]->tx_mode != ESP_LINE_ENDINGS_LF) {
420060cf:	0f9926        	beqi	a9, 10, 420060e2 <uart_write+0x56>
        s_ctx[fd]->tx_func(fd, c);
420060d2:	06a8      	l32i.n	a10, a6, 0
420060d4:	09bd      	mov.n	a11, a9
420060d6:	7ac8      	l32i.n	a12, a10, 28
420060d8:	02ad      	mov.n	a10, a2
420060da:	000ce0        	callx8	a12
    for (size_t i = 0; i < size; i++) {
420060dd:	331b      	addi.n	a3, a3, 1
420060df:	fff5c6        	j	420060ba <uart_write+0x2e>
        if (c == '\n' && s_ctx[fd]->tx_mode != ESP_LINE_ENDINGS_LF) {
420060e2:	55a8      	l32i.n	a10, a5, 20
420060e4:	ea2a26        	beqi	a10, 2, 420060d2 <uart_write+0x46>
            s_ctx[fd]->tx_func(fd, '\r');
420060e7:	75c8      	l32i.n	a12, a5, 28
420060e9:	02ad      	mov.n	a10, a2
420060eb:	1199      	s32i.n	a9, a1, 4
420060ed:	db0c      	movi.n	a11, 13
420060ef:	000ce0        	callx8	a12
            if (s_ctx[fd]->tx_mode == ESP_LINE_ENDINGS_CR) {
420060f2:	55a8      	l32i.n	a10, a5, 20
420060f4:	1198      	l32i.n	a9, a1, 4
420060f6:	d81a66        	bnei	a10, 1, 420060d2 <uart_write+0x46>
420060f9:	fff806        	j	420060dd <uart_write+0x51>

420060fc <uart_tcdrain>:
{
420060fc:	004136        	entry	a1, 32
420060ff:	20a220        	or	a10, a2, a2
    if (fd < 0 || fd >= UART_NUM) {
42006102:	0e32b6        	bltui	a2, 3, 42006114 <uart_tcdrain+0x18>
        errno = EBADF;
42006105:	037925        	call8	42009898 <__errno>
42006108:	09a082        	movi	a8, 9
            errno = EINVAL;
4200610b:	006a82        	s32i	a8, a10, 0
4200610e:	fa7c      	movi.n	a10, -1
}
42006110:	0a2d      	mov.n	a2, a10
42006112:	f01d      	retw.n
    if (uart_wait_tx_done(fd, portMAX_DELAY) != ESP_OK) {
42006114:	ffafb2        	movi	a11, -1
42006117:	01d565        	call8	42007e6c <uart_wait_tx_done>
4200611a:	ff2a16        	beqz	a10, 42006110 <uart_tcdrain+0x14>
            errno = EINVAL;
4200611d:	0377a5        	call8	42009898 <__errno>
42006120:	16a082        	movi	a8, 22
42006123:	fff906        	j	4200610b <uart_tcdrain+0xf>
	...

42006128 <esp_vfs_uart_get_vfs>:
    .tcflush = &uart_tcflush,
#endif // CONFIG_VFS_SUPPORT_TERMIOS
};

const esp_vfs_t* esp_vfs_uart_get_vfs(void)
{
42006128:	004136        	entry	a1, 32
    return &vfs;
}
4200612b:	e99321        	l32r	a2, 42000778 <_stext+0x758>
4200612e:	f01d      	retw.n

42006130 <setup_quantization>:
int32_t buffer_int32[96];
int16_t buffer_s16[96];

struct qlayer l1_qparams, l3_qparams;

void setup_quantization() {
42006130:	004136        	entry	a1, 32
    l1_qparams = (struct qlayer) {
42006133:	e99281        	l32r	a8, 4200077c <_stext+0x75c>
42006136:	e997b1        	l32r	a11, 42000794 <_stext+0x774>
42006139:	000823        	lsi	f2, a8, 0
4200613c:	e99181        	l32r	a8, 42000780 <_stext+0x760>
4200613f:	000b33        	lsi	f3, a11, 0
42006142:	0008a2        	l8ui	a10, a8, 0
42006145:	e98f81        	l32r	a8, 42000784 <_stext+0x764>
42006148:	9ab300        	trunc.s	a11, f3, 0
4200614b:	000813        	lsi	f1, a8, 0
4200614e:	e98e81        	l32r	a8, 42000788 <_stext+0x768>
42006151:	000892        	l8ui	a9, a8, 0
42006154:	e98e81        	l32r	a8, 4200078c <_stext+0x76c>
42006157:	000803        	lsi	f0, a8, 0
4200615a:	e98d81        	l32r	a8, 42000790 <_stext+0x770>
4200615d:	0048b2        	s8i	a11, a8, 0
42006160:	014823        	ssi	f2, a8, 4
42006163:	0848a2        	s8i	a10, a8, 8
42006166:	034813        	ssi	f1, a8, 12
42006169:	104892        	s8i	a9, a8, 16
4200616c:	054803        	ssi	f0, a8, 20
            .zero = layer_1_zero,
            .scale = layer_1_scale,
        }
    };

    l3_qparams = (struct qlayer) {
4200616f:	e98a81        	l32r	a8, 42000798 <_stext+0x778>
42006172:	0008b2        	l8ui	a11, a8, 0
42006175:	e98981        	l32r	a8, 4200079c <_stext+0x77c>
42006178:	000823        	lsi	f2, a8, 0
4200617b:	e98981        	l32r	a8, 420007a0 <_stext+0x780>
4200617e:	0008a2        	l8ui	a10, a8, 0
42006181:	e98881        	l32r	a8, 420007a4 <_stext+0x784>
42006184:	000813        	lsi	f1, a8, 0
42006187:	e98881        	l32r	a8, 420007a8 <_stext+0x788>
4200618a:	004892        	s8i	a9, a8, 0
4200618d:	014803        	ssi	f0, a8, 4
42006190:	0848b2        	s8i	a11, a8, 8
42006193:	034823        	ssi	f2, a8, 12
42006196:	1048a2        	s8i	a10, a8, 16
42006199:	054813        	ssi	f1, a8, 20
        .output = {
            .zero = layer_3_zero,
            .scale = layer_3_scale,
        }
    };
}
4200619c:	f01d      	retw.n
	...

420061a0 <setup_uart>:

void setup_uart() {
420061a0:	004136        	entry	a1, 32
    ESP_ERROR_CHECK(uart_param_config(UART_NUM, &uart_config));
420061a3:	e982b1        	l32r	a11, 420007ac <_stext+0x78c>
420061a6:	00a0a2        	movi	a10, 0
420061a9:	01b8e5        	call8	42007d38 <uart_param_config>
420061ac:	011a16        	beqz	a10, 420061c1 <setup_uart+0x21>
420061af:	e980e1        	l32r	a14, 420007b0 <_stext+0x790>
420061b2:	e980d1        	l32r	a13, 420007b4 <_stext+0x794>
420061b5:	45a0c2        	movi	a12, 69
    ESP_ERROR_CHECK(uart_set_pin(UART_NUM, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
420061b8:	e980b1        	l32r	a11, 420007b8 <_stext+0x798>
420061bb:	e98281        	l32r	a8, 420007c4 <_stext+0x7a4>
420061be:	0008e0        	callx8	a8
420061c1:	fe7c      	movi.n	a14, -1
420061c3:	0edd      	mov.n	a13, a14
420061c5:	0ecd      	mov.n	a12, a14
420061c7:	0ebd      	mov.n	a11, a14
420061c9:	0191e5        	call8	42007ae8 <uart_set_pin>
420061cc:	9a8c      	beqz.n	a10, 420061d9 <setup_uart+0x39>
420061ce:	e97be1        	l32r	a14, 420007bc <_stext+0x79c>
420061d1:	e978d1        	l32r	a13, 420007b4 <_stext+0x794>
420061d4:	6c4c      	movi.n	a12, 70
420061d6:	fff786        	j	420061b8 <setup_uart+0x18>
    ESP_ERROR_CHECK(uart_driver_install(UART_NUM, 1024 * 2, 1024 * 2, 0, NULL, 0));
420061d9:	01a0b2        	movi	a11, 1
420061dc:	11bb50        	slli	a11, a11, 11
420061df:	20faa0        	or	a15, a10, a10
420061e2:	20eaa0        	or	a14, a10, a10
420061e5:	0add      	mov.n	a13, a10
420061e7:	0bcd      	mov.n	a12, a11
420061e9:	021b65        	call8	420083a0 <uart_driver_install>
420061ec:	9a8c      	beqz.n	a10, 420061f9 <setup_uart+0x59>
420061ee:	e974e1        	l32r	a14, 420007c0 <_stext+0x7a0>
420061f1:	e970d1        	l32r	a13, 420007b4 <_stext+0x794>
420061f4:	7c4c      	movi.n	a12, 71
420061f6:	ffef86        	j	420061b8 <setup_uart+0x18>
}
420061f9:	f01d      	retw.n
	...

420061fc <run_mlp_s16>:
 * 132 is the input size
 * 96 is the number of neurons in the first hidden layer
 * 15 is the number of neurons in the output layer
 * 
*/
int run_mlp_s16(const float *input) {
420061fc:	004136        	entry	a1, 32
    int output;

    quantize_s16(input, l1_qparams.input.scale, l1_qparams.input.zero, input_quantized_s16, 132);
420061ff:	e96441        	l32r	a4, 42000790 <_stext+0x770>
42006202:	e97151        	l32r	a5, 420007c8 <_stext+0x7a8>
42006205:	0004c2        	l8ui	a12, a4, 0
42006208:	14b8      	l32i.n	a11, a4, 4
4200620a:	20d550        	or	a13, a5, a5
4200620d:	20a220        	or	a10, a2, a2
42006210:	84a0e2        	movi	a14, 132
42006213:	23cc00        	sext	a12, a12, 7
42006216:	001ba5        	call8	420063d0 <quantize_s16>

    mvm_s16(layer_1_weights_s16, input_quantized_s16, buffer_s16, l1_qparams.input.zero, 96, 132);
42006219:	0004d2        	l8ui	a13, a4, 0
4200621c:	e96c31        	l32r	a3, 420007cc <_stext+0x7ac>
4200621f:	e96ca1        	l32r	a10, 420007d0 <_stext+0x7b0>
42006222:	84a0f2        	movi	a15, 132
42006225:	60a0e2        	movi	a14, 96
42006228:	03cd      	mov.n	a12, a3
4200622a:	05bd      	mov.n	a11, a5
4200622c:	23dd00        	sext	a13, a13, 7
4200622f:	0015a5        	call8	42006388 <mvm_s16>
    dequantize_s16(&l1_qparams, buffer_s16, buffer, 96);
42006232:	e96821        	l32r	a2, 420007d4 <_stext+0x7b4>
42006235:	60a0d2        	movi	a13, 96
42006238:	02cd      	mov.n	a12, a2
4200623a:	03bd      	mov.n	a11, a3
4200623c:	04ad      	mov.n	a10, a4
4200623e:	11d465        	call8	42017f84 <dequantize_s16>

    relu(buffer, buffer, 96);
42006241:	02bd      	mov.n	a11, a2
42006243:	20a220        	or	a10, a2, a2
42006246:	60a0c2        	movi	a12, 96
42006249:	001125        	call8	4200635c <relu>
    quantize_s16(buffer, l3_qparams.input.scale, l3_qparams.input.zero, buffer_s16, 96);
4200624c:	e95741        	l32r	a4, 420007a8 <_stext+0x788>
4200624f:	03dd      	mov.n	a13, a3
42006251:	0004c2        	l8ui	a12, a4, 0
42006254:	14b8      	l32i.n	a11, a4, 4
42006256:	02ad      	mov.n	a10, a2
42006258:	60a0e2        	movi	a14, 96
4200625b:	23cc00        	sext	a12, a12, 7
4200625e:	001725        	call8	420063d0 <quantize_s16>

    mvm_s16(layer_3_weights_s16, buffer_s16, buffer_s16, l3_qparams.input.zero, 15, 96);
42006261:	0004d2        	l8ui	a13, a4, 0
42006264:	e95da1        	l32r	a10, 420007d8 <_stext+0x7b8>
42006267:	60a0f2        	movi	a15, 96
4200626a:	fe0c      	movi.n	a14, 15
4200626c:	03cd      	mov.n	a12, a3
4200626e:	03bd      	mov.n	a11, a3
42006270:	23dd00        	sext	a13, a13, 7
42006273:	001165        	call8	42006388 <mvm_s16>
    dequantize_s16(&l3_qparams, buffer_s16, buffer, 15);
42006276:	02cd      	mov.n	a12, a2
42006278:	fd0c      	movi.n	a13, 15
4200627a:	03bd      	mov.n	a11, a3
4200627c:	04ad      	mov.n	a10, a4
4200627e:	11d065        	call8	42017f84 <dequantize_s16>

    output = argmax(buffer, 15);
42006281:	fb0c      	movi.n	a11, 15
42006283:	02ad      	mov.n	a10, a2
42006285:	11cd25        	call8	42017f58 <argmax>

    return output;
}
42006288:	0a2d      	mov.n	a2, a10
4200628a:	f01d      	retw.n

4200628c <app_main>:

void app_main(void)
{
4200628c:	00a136        	entry	a1, 80
    char cmd;
    int recv_bytes;
    int subject_id;
    int time_begin, time_end, time_elapsed;

    char msg_ready[] = "Ready\n";
4200628f:	e953b1        	l32r	a11, 420007dc <_stext+0x7bc>
42006292:	7c0c      	movi.n	a12, 7
42006294:	1ac1a2        	addi	a10, a1, 26
42006297:	e7cd81        	l32r	a8, 420001cc <_stext+0x1ac>
4200629a:	0008e0        	callx8	a8
    char msg_error[] = "Error\n";
4200629d:	e950b1        	l32r	a11, 420007e0 <_stext+0x7c0>
420062a0:	7c0c      	movi.n	a12, 7
420062a2:	13c1a2        	addi	a10, a1, 19
420062a5:	e7c981        	l32r	a8, 420001cc <_stext+0x1ac>
420062a8:	0008e0        	callx8	a8
    char msg_waiting[] = "Waiting for input\n";
420062ab:	e94eb1        	l32r	a11, 420007e4 <_stext+0x7c4>
420062ae:	3c1c      	movi.n	a12, 19
420062b0:	01ad      	mov.n	a10, a1
420062b2:	e7c681        	l32r	a8, 420001cc <_stext+0x1ac>
420062b5:	0008e0        	callx8	a8

    setup_quantization();
420062b8:	ffe765        	call8	42006130 <setup_quantization>
    setup_uart();
420062bb:	ffee65        	call8	420061a0 <setup_uart>

    uart_write_bytes(UART_NUM, msg_ready, strlen(msg_ready));
420062be:	1ac1a2        	addi	a10, a1, 26
420062c1:	e8f481        	l32r	a8, 42000694 <_stext+0x674>
420062c4:	0008e0        	callx8	a8
420062c7:	0acd      	mov.n	a12, a10
420062c9:	1ac1b2        	addi	a11, a1, 26
420062cc:	00a0a2        	movi	a10, 0
420062cf:	01d0e5        	call8	42007fdc <uart_write_bytes>

    while (1) {
        cmd = CMD_NOOP;

        uart_write_bytes(UART_NUM, msg_waiting, strlen(msg_waiting));
420062d2:	020c      	movi.n	a2, 0
        cmd = CMD_NOOP;
420062d4:	030c      	movi.n	a3, 0
        uart_write_bytes(UART_NUM, msg_waiting, strlen(msg_waiting));
420062d6:	01ad      	mov.n	a10, a1
        cmd = CMD_NOOP;
420062d8:	2c4132        	s8i	a3, a1, 44
        uart_write_bytes(UART_NUM, msg_waiting, strlen(msg_waiting));
420062db:	e8ee81        	l32r	a8, 42000694 <_stext+0x674>
420062de:	0008e0        	callx8	a8
420062e1:	0acd      	mov.n	a12, a10
420062e3:	01bd      	mov.n	a11, a1
420062e5:	02ad      	mov.n	a10, a2
420062e7:	01cf65        	call8	42007fdc <uart_write_bytes>

        while (cmd != CMD_INFERENCE_BEGIN)
420062ea:	2c0132        	l8ui	a3, a1, 44
420062ed:	5b1366        	bnei	a3, 1, 4200634c <app_main+0xc0>
            uart_read_bytes(UART_NUM, (char *)&cmd, sizeof(char), 100);

        recv_bytes = uart_read_bytes(UART_NUM, (float *)input, 132*4, 100000);
420062f0:	e93f31        	l32r	a3, 420007ec <_stext+0x7cc>
420062f3:	e93dd1        	l32r	a13, 420007e8 <_stext+0x7c8>
420062f6:	10a2c2        	movi	a12, 0x210
420062f9:	03bd      	mov.n	a11, a3
420062fb:	02ad      	mov.n	a10, a2
420062fd:	01d1a5        	call8	42008018 <uart_read_bytes>
        if (recv_bytes != 132*sizeof(float))
42006300:	10a242        	movi	a4, 0x210
42006303:	121a47        	beq	a10, a4, 42006319 <app_main+0x8d>
            uart_write_bytes(UART_NUM, msg_error, strlen(msg_error));
42006306:	13c1a2        	addi	a10, a1, 19
42006309:	e8e281        	l32r	a8, 42000694 <_stext+0x674>
4200630c:	0008e0        	callx8	a8
4200630f:	0acd      	mov.n	a12, a10
42006311:	13c1b2        	addi	a11, a1, 19
42006314:	02ad      	mov.n	a10, a2
42006316:	01cc65        	call8	42007fdc <uart_write_bytes>

        asm volatile("esync; rsr %0,ccount":"=a" (time_begin));
42006319:	002020        	esync
4200631c:	03ea40        	rsr.ccount	a4
        subject_id = run_mlp_s16(input);
4200631f:	20a330        	or	a10, a3, a3
42006322:	ffeda5        	call8	420061fc <run_mlp_s16>
42006325:	0a61a2        	s32i	a10, a1, 40
        asm volatile("esync; rsr %0,ccount":"=a" (time_end));
42006328:	002020        	esync
4200632b:	03ea30        	rsr.ccount	a3

        uart_write_bytes(UART_NUM, &subject_id, sizeof(int));
4200632e:	4c0c      	movi.n	a12, 4
42006330:	28c1b2        	addi	a11, a1, 40
42006333:	02ad      	mov.n	a10, a2
42006335:	01ca65        	call8	42007fdc <uart_write_bytes>

        time_elapsed = time_end - time_begin;
42006338:	c03340        	sub	a3, a3, a4
        uart_write_bytes(UART_NUM, (int*)&time_elapsed, sizeof(int));
4200633b:	4c0c      	movi.n	a12, 4
4200633d:	24c1b2        	addi	a11, a1, 36
42006340:	02ad      	mov.n	a10, a2
        time_elapsed = time_end - time_begin;
42006342:	096132        	s32i	a3, a1, 36
        uart_write_bytes(UART_NUM, (int*)&time_elapsed, sizeof(int));
42006345:	01c965        	call8	42007fdc <uart_write_bytes>
        cmd = CMD_NOOP;
42006348:	ffe206        	j	420062d4 <app_main+0x48>
4200634b:	00          	.byte 00
            uart_read_bytes(UART_NUM, (char *)&cmd, sizeof(char), 100);
4200634c:	64a0d2        	movi	a13, 100
4200634f:	1c0c      	movi.n	a12, 1
42006351:	2cc1b2        	addi	a11, a1, 44
42006354:	02ad      	mov.n	a10, a2
42006356:	01cc25        	call8	42008018 <uart_read_bytes>
42006359:	ffe346        	j	420062ea <app_main+0x5e>

4200635c <relu>:

    for (int row = 0; row < nrows; row++)
        out[row] = mac(&M[row*ncols], v, ncols);
}

void relu(const float *x, float *out, int size) {
4200635c:	004136        	entry	a1, 32
    int i;
    for (i = 0; i < size; i++)
        out[i] = x[i]>0.0 ? x[i] : 0.0;
4200635f:	e92451        	l32r	a5, 420007f0 <_stext+0x7d0>
    for (i = 0; i < size; i++)
42006362:	080c      	movi.n	a8, 0
        out[i] = x[i]>0.0 ? x[i] : 0.0;
42006364:	fa1550        	wfr	f1, a5
    for (i = 0; i < size; i++)
42006367:	012847        	blt	a8, a4, 4200636c <relu+0x10>
}
4200636a:	f01d      	retw.n
        out[i] = x[i]>0.0 ? x[i] : 0.0;
4200636c:	a0a820        	addx4	a10, a8, a2
4200636f:	000a03        	lsi	f0, a10, 0
42006372:	1198e0        	slli	a9, a8, 2
42006375:	4b0100        	olt.s	b0, f1, f0
42006378:	021076        	bt	b0, 4200637e <relu+0x22>
4200637b:	fa0100        	mov.s	f0, f1
4200637e:	939a      	add.n	a9, a3, a9
42006380:	004903        	ssi	f0, a9, 0
    for (i = 0; i < size; i++)
42006383:	881b      	addi.n	a8, a8, 1
42006385:	fff786        	j	42006367 <relu+0xb>

42006388 <mvm_s16>:
#include <math.h>
#include <qnnops.h>
#include <stdint.h>
#include <esp_dsp.h>

void mvm_s16(const int16_t *M, int16_t *v, int16_t *out, int8_t v_zero, int nrows, int ncols) {
42006388:	006136        	entry	a1, 48
4200638b:	038d      	mov.n	a8, a3
    for (int i = 0; i < ncols; i++)
4200638d:	090c      	movi.n	a9, 0
        v[i] = (v[i] - v_zero);
4200638f:	235500        	sext	a5, a5, 7
    for (int i = 0; i < ncols; i++)
42006392:	0a2977        	blt	a9, a7, 420063a0 <mvm_s16+0x18>
42006395:	877a      	add.n	a8, a7, a7

    for (int row = 0; row < nrows; row++)
42006397:	050c      	movi.n	a5, 0
        dsps_dotprod_s16_ae32(&M[row*ncols], v, &out[row], ncols, 8);
42006399:	890c      	movi.n	a9, 8
    for (int row = 0; row < nrows; row++)
4200639b:	112567        	blt	a5, a6, 420063b0 <mvm_s16+0x28>
}
4200639e:	f01d      	retw.n
        v[i] = (v[i] - v_zero);
420063a0:	0018a2        	l16ui	a10, a8, 0
    for (int i = 0; i < ncols; i++)
420063a3:	991b      	addi.n	a9, a9, 1
        v[i] = (v[i] - v_zero);
420063a5:	c0aa50        	sub	a10, a10, a5
420063a8:	0058a2        	s16i	a10, a8, 0
    for (int i = 0; i < ncols; i++)
420063ab:	882b      	addi.n	a8, a8, 2
420063ad:	fff846        	j	42006392 <mvm_s16+0xa>
        dsps_dotprod_s16_ae32(&M[row*ncols], v, &out[row], ncols, 8);
420063b0:	20e990        	or	a14, a9, a9
420063b3:	90c540        	addx2	a12, a5, a4
420063b6:	20a220        	or	a10, a2, a2
420063b9:	20d770        	or	a13, a7, a7
420063bc:	03bd      	mov.n	a11, a3
420063be:	0189      	s32i.n	a8, a1, 0
420063c0:	1199      	s32i.n	a9, a1, 4
420063c2:	000625        	call8	42006424 <dsps_dotprod_s16_ae32>
    for (int row = 0; row < nrows; row++)
420063c5:	0188      	l32i.n	a8, a1, 0
420063c7:	1198      	l32i.n	a9, a1, 4
420063c9:	551b      	addi.n	a5, a5, 1
420063cb:	228a      	add.n	a2, a2, a8
420063cd:	fff286        	j	4200639b <mvm_s16+0x13>

420063d0 <quantize_s16>:

void quantize_s16(const float *x, float scale, int8_t zero, int16_t *out, int size) {
420063d0:	006136        	entry	a1, 48
    for (int i = 0; i < size; i++)
420063d3:	070c      	movi.n	a7, 0
        out[i] = (int16_t)(round(x[i] / scale) + zero);
420063d5:	234400        	sext	a4, a4, 7
    for (int i = 0; i < size; i++)
420063d8:	012767        	blt	a7, a6, 420063dd <quantize_s16+0xd>
}
420063db:	f01d      	retw.n
        out[i] = (int16_t)(round(x[i] / scale) + zero);
420063dd:	a08720        	addx4	a8, a7, a2
420063e0:	08a8      	l32i.n	a10, a8, 0
420063e2:	20b330        	or	a11, a3, a3
420063e5:	e90381        	l32r	a8, 420007f4 <_stext+0x7d4>
420063e8:	0008e0        	callx8	a8
420063eb:	e90381        	l32r	a8, 420007f8 <_stext+0x7d8>
420063ee:	0008e0        	callx8	a8
420063f1:	033fa5        	call8	420097ec <round>
420063f4:	908750        	addx2	a8, a7, a5
420063f7:	0acd      	mov.n	a12, a10
420063f9:	04ad      	mov.n	a10, a4
420063fb:	2189      	s32i.n	a8, a1, 8
420063fd:	01c9      	s32i.n	a12, a1, 0
420063ff:	0161b2        	s32i	a11, a1, 4
42006402:	e8fe81        	l32r	a8, 420007fc <_stext+0x7dc>
42006405:	0008e0        	callx8	a8
42006408:	01c8      	l32i.n	a12, a1, 0
4200640a:	11d8      	l32i.n	a13, a1, 4
    for (int i = 0; i < size; i++)
4200640c:	771b      	addi.n	a7, a7, 1
        out[i] = (int16_t)(round(x[i] / scale) + zero);
4200640e:	e8fc81        	l32r	a8, 42000800 <_stext+0x7e0>
42006411:	0008e0        	callx8	a8
42006414:	e8fc81        	l32r	a8, 42000804 <_stext+0x7e4>
42006417:	0008e0        	callx8	a8
4200641a:	2188      	l32i.n	a8, a1, 8
4200641c:	0058a2        	s16i	a10, a8, 0
    for (int i = 0; i < size; i++)
4200641f:	ffed46        	j	420063d8 <quantize_s16+0x8>
	...

42006424 <dsps_dotprod_s16_ae32>:
// src2 - a3
// dest - a4
// len  - a5
// shift - a6

	entry	a1, 16
42006424:	002136        	entry	a1, 16

	// Check minimum length
	movi a8, 4
42006427:	480c      	movi.n	a8, 4
	blt a5, a8, dsps_dotprod_s16_ae32_error
42006429:	772587        	blt	a5, a8, 420064a4 <dsps_dotprod_s16_ae32_error>
	
	// Clear accumulator
	movi a8, 0
4200642c:	080c      	movi.n	a8, 0
	wsr a8, acchi
4200642e:	131180        	wsr.acchi	a8
		
	// Prepare and load round value
	movi a8, 0x7fff
42006431:	e8f581        	l32r	a8, 42000808 <_stext+0x7e8>
	ssr a6
42006434:	400600        	ssr	a6
	srl a8, a8
42006437:	918080        	srl	a8, a8
	wsr a8, acclo // initialize acc with shifted round value
4200643a:	131080        	wsr.acclo	a8

	// Compensate for pre-increment 
	// Right shift to 16 bits
	// RS = -shift + 15
	neg  a6, a6 
4200643d:	606060        	neg	a6, a6
	addi a6, a6, 15
42006440:	66fb      	addi.n	a6, a6, 15
	
	/* number of loop iterations (see below):
	 * a7 = count / 4 - 1
	 */
	
	srli a7, a5, 2
42006442:	417250        	srli	a7, a5, 2
	addi a7, a7, -1
42006445:	ffc772        	addi	a7, a7, -1

	movi.n	a10, 0 // load 0 to the a10 to increment second array
42006448:	00a0a2        	movi	a10, 0

	dotprod_s16_ae32_full a2, a3, a7, a5
4200644b:	fcc222        	addi	a2, a2, -4
4200644e:	fcc332        	addi	a3, a3, -4
42006451:	800204        	ldinc	m0, a2
42006454:	802304        	ldinc	m2, a3
42006457:	801204        	ldinc	m1, a2
4200645a:	083304        	mula.dd.ll.ldinc	m3, a3, m0, m2
4200645d:	0b9776        	loopnez	a7, 4200646c <.loop_end>

42006460 <.loop>:
42006460:	0b0204        	mula.dd.hh.ldinc	m0, a2, m0, m2
42006463:	086344        	mula.dd.ll.ldinc	m2, a3, m1, m3
42006466:	0b5244        	mula.dd.hh.ldinc	m1, a2, m1, m3
42006469:	083304        	mula.dd.ll.ldinc	m3, a3, m0, m2

4200646c <.loop_end>:
4200646c:	2b0004        	mula.dd.hh	m0, m2
4200646f:	284044        	mula.dd.ll	m1, m3
42006472:	2b4044        	mula.dd.hh	m1, m3
42006475:	0b6517        	bbci	a5, 1, 42006484 <.mod2chk>
42006478:	800204        	ldinc	m0, a2
4200647b:	802304        	ldinc	m2, a3
4200647e:	2b0004        	mula.dd.hh	m0, m2
42006481:	280004        	mula.dd.ll	m0, m2

42006484 <.mod2chk>:
42006484:	086507        	bbci	a5, 0, 42006490 <.mod1chk>
42006487:	800204        	ldinc	m0, a2
4200648a:	802304        	ldinc	m2, a3
4200648d:	280004        	mula.dd.ll	m0, m2

42006490 <.mod1chk>:

	/* Get accumulator */
	ssr a6
42006490:	400600        	ssr	a6
	rsr a2, acchi
42006493:	031120        	rsr.acchi	a2
	rsr a3, acclo
42006496:	031030        	rsr.acclo	a3
	src a2, a2, a3
42006499:	812230        	src	a2, a2, a3
		
	s16i	a2, a4, 0
4200649c:	005422        	s16i	a2, a4, 0
	movi.n	a2, 0
4200649f:	020c      	movi.n	a2, 0
	retw.n
420064a1:	f01d      	retw.n
	...

420064a4 <dsps_dotprod_s16_ae32_error>:
dsps_dotprod_s16_ae32_error:
	movi.n	a2, ESP_ERR_DSP_INVALID_LENGTH
420064a4:	e8da21        	l32r	a2, 4200080c <_stext+0x7ec>
	retw.n
420064a7:	f01d      	retw.n
420064a9:	000000        	ill

420064ac <xt_int_has_handler>:

//Returns true if handler for interrupt is not the default unhandled interrupt handler
bool xt_int_has_handler(int intr, int cpu)
{
420064ac:	004136        	entry	a1, 32
    return (_xt_interrupt_table[intr*portNUM_PROCESSORS+cpu].handler != xt_unhandled_interrupt);
420064af:	e8d881        	l32r	a8, 42000810 <_stext+0x7f0>
420064b2:	902230        	addx2	a2, a2, a3
420064b5:	b02280        	addx8	a2, a2, a8
420064b8:	0288      	l32i.n	a8, a2, 0
420064ba:	e8d621        	l32r	a2, 42000814 <_stext+0x7f4>
420064bd:	090c      	movi.n	a9, 0
420064bf:	c08820        	sub	a8, a8, a2
420064c2:	120c      	movi.n	a2, 1
420064c4:	832980        	moveqz	a2, a9, a8
}
420064c7:	f01d      	retw.n
420064c9:	000000        	ill

420064cc <xt_set_interrupt_handler>:
  parameter specifies the argument to be passed to the handler when it is
  invoked. The function returns the address of the previous handler.
  On error, it returns 0.
*/
xt_handler xt_set_interrupt_handler(int n, xt_handler f, void * arg)
{
420064cc:	004136        	entry	a1, 32
    xt_handler_table_entry * entry;
    xt_handler               old;

    if( n < 0 || n >= XCHAL_NUM_INTERRUPTS )
420064cf:	f81c      	movi.n	a8, 31
420064d1:	03b827        	bgeu	a8, a2, 420064d8 <xt_set_interrupt_handler+0xc>
        return 0;       /* invalid interrupt number */
420064d4:	020c      	movi.n	a2, 0
        entry->handler = &xt_unhandled_interrupt;
        entry->arg     = (void*)n;
    }

    return ((old == &xt_unhandled_interrupt) ? 0 : old);
}
420064d6:	f01d      	retw.n
    if( Xthal_intlevel[n] > XCHAL_EXCM_LEVEL )
420064d8:	e8d081        	l32r	a8, 42000818 <_stext+0x7f8>
420064db:	882a      	add.n	a8, a8, a2
420064dd:	000882        	l8ui	a8, a8, 0
420064e0:	f048f6        	bgeui	a8, 4, 420064d4 <xt_set_interrupt_handler+0x8>
    n = n * portNUM_PROCESSORS + xPortGetCoreID();
420064e3:	222a      	add.n	a2, a2, a2
    asm volatile (
420064e5:	03eb90        	rsr.prid	a9
420064e8:	049d90        	extui	a9, a9, 13, 1
    entry = _xt_interrupt_table + n;
420064eb:	e8c981        	l32r	a8, 42000810 <_stext+0x7f0>
420064ee:	e8c9a1        	l32r	a10, 42000814 <_stext+0x7f4>
    n = n * portNUM_PROCESSORS + xPortGetCoreID();
420064f1:	992a      	add.n	a9, a9, a2
    entry = _xt_interrupt_table + n;
420064f3:	b08980        	addx8	a8, a9, a8
        entry->arg     = (void*)n;
420064f6:	834930        	moveqz	a4, a9, a3
420064f9:	0a9d      	mov.n	a9, a10
    old   = entry->handler;
420064fb:	0828      	l32i.n	a2, a8, 0
        entry->arg     = (void*)n;
420064fd:	939330        	movnez	a9, a3, a3
        entry->handler = f;
42006500:	0899      	s32i.n	a9, a8, 0
        entry->arg     = arg;
42006502:	1849      	s32i.n	a4, a8, 4
    return ((old == &xt_unhandled_interrupt) ? 0 : old);
42006504:	ce92a7        	bne	a2, a10, 420064d6 <xt_set_interrupt_handler+0xa>
42006507:	fff246        	j	420064d4 <xt_set_interrupt_handler+0x8>
	...

4200650c <esp_efuse_read_field_blob>:

// Public API functions

// read value from EFUSE, writing it into an array
esp_err_t esp_efuse_read_field_blob(const esp_efuse_desc_t* field[], void* dst, size_t dst_size_bits)
{
4200650c:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
    if (field == NULL || dst == NULL || dst_size_bits == 0) {
4200650f:	0a0c      	movi.n	a10, 0
42006511:	180c      	movi.n	a8, 1
42006513:	0a9d      	mov.n	a9, a10
42006515:	839830        	moveqz	a9, a8, a3
42006518:	83a840        	moveqz	a10, a8, a4
4200651b:	2099a0        	or	a9, a9, a10
4200651e:	39fc      	bnez.n	a9, 42006555 <esp_efuse_read_field_blob+0x49>
42006520:	938920        	movnez	a8, a9, a2
42006523:	e8ec      	bnez.n	a8, 42006555 <esp_efuse_read_field_blob+0x49>
        err = ESP_ERR_INVALID_ARG;
    } else {
        do {
            memset((uint8_t *)dst, 0, esp_efuse_utility_get_number_of_items(dst_size_bits, 8));
42006525:	8b0c      	movi.n	a11, 8
42006527:	04ad      	mov.n	a10, a4
42006529:	11aba5        	call8	42017fe4 <esp_efuse_utility_get_number_of_items>
4200652c:	0acd      	mov.n	a12, a10
4200652e:	0b0c      	movi.n	a11, 0
42006530:	03ad      	mov.n	a10, a3
42006532:	e71981        	l32r	a8, 42000198 <_stext+0x178>
42006535:	0008e0        	callx8	a8
            err = esp_efuse_utility_process(field, dst, dst_size_bits, esp_efuse_utility_fill_buff);
42006538:	e8b9d1        	l32r	a13, 4200081c <_stext+0x7fc>
4200653b:	04cd      	mov.n	a12, a4
4200653d:	03bd      	mov.n	a11, a3
4200653f:	02ad      	mov.n	a10, a2
42006541:	000265        	call8	42006568 <esp_efuse_utility_process>
#ifndef BOOTLOADER_BUILD
            if (err == ESP_ERR_DAMAGED_READING) {
42006544:	e8b781        	l32r	a8, 42000820 <_stext+0x800>
42006547:	0d9a87        	bne	a10, a8, 42006558 <esp_efuse_read_field_blob+0x4c>
                vTaskDelay(1);
4200654a:	1a0c      	movi.n	a10, 1
4200654c:	e8b681        	l32r	a8, 42000824 <_stext+0x804>
4200654f:	0008e0        	callx8	a8
            }
#endif // BOOTLOADER_BUILD
        } while (err == ESP_ERR_DAMAGED_READING);
42006552:	fff3c6        	j	42006525 <esp_efuse_read_field_blob+0x19>
        err = ESP_ERR_INVALID_ARG;
42006555:	02a1a2        	movi	a10, 0x102
    }
    return err;
}
42006558:	0a2d      	mov.n	a2, a10
4200655a:	f01d      	retw.n

4200655c <esp_efuse_check_errors>:
    }
    return ESP_OK;
}

esp_err_t esp_efuse_check_errors(void)
{
4200655c:	004136        	entry	a1, 32
    return esp_efuse_utility_check_errors();
4200655f:	11a9e5        	call8	42017ffc <esp_efuse_utility_check_errors>
}
42006562:	0a2d      	mov.n	a2, a10
42006564:	f01d      	retw.n
	...

42006568 <esp_efuse_utility_process>:
static uint32_t set_cnt_in_reg(int bit_start_in_reg, int bit_count_used_in_reg, uint32_t reg_masked, size_t* cnt);
static bool check_range_of_bits(esp_efuse_block_t blk, int offset_in_bits, int size_bits);

// This function processes the field by calling the passed function.
esp_err_t esp_efuse_utility_process(const esp_efuse_desc_t* field[], void* ptr, size_t ptr_size_bits, efuse_func_proc_t func_proc)
{
42006568:	008136        	entry	a1, 64
4200656b:	076132        	s32i	a3, a1, 28
    esp_err_t err = ESP_OK;
    int bits_counter = 0;

    // get and check size.
    int field_len = esp_efuse_get_field_size(field);
4200656e:	20a220        	or	a10, a2, a2
    int bits_counter = 0;
42006571:	00a032        	movi	a3, 0
42006574:	0139      	s32i.n	a3, a1, 0
    int field_len = esp_efuse_get_field_size(field);
42006576:	11a4e5        	call8	42017fc4 <esp_efuse_get_field_size>
42006579:	0a3d      	mov.n	a3, a10
    int req_size = (ptr_size_bits == 0) ? field_len : MIN(ptr_size_bits, field_len);
4200657b:	148c      	beqz.n	a4, 42006580 <esp_efuse_utility_process+0x18>
4200657d:	633a40        	minu	a3, a10, a4

    int i = 0;
    unsigned count_before = s_burn_counter;
42006580:	e8aa41        	l32r	a4, 42000828 <_stext+0x808>
    while (err == ESP_OK && req_size > bits_counter && field[i] != NULL) {
42006583:	170c      	movi.n	a7, 1
    unsigned count_before = s_burn_counter;
42006585:	0020c0        	memw
42006588:	0448      	l32i.n	a4, a4, 0
4200658a:	5149      	s32i.n	a4, a1, 20
    while (err == ESP_OK && req_size > bits_counter && field[i] != NULL) {
4200658c:	024d      	mov.n	a4, a2
    esp_err_t err = ESP_OK;
4200658e:	020c      	movi.n	a2, 0
    while (err == ESP_OK && req_size > bits_counter && field[i] != NULL) {
42006590:	090c      	movi.n	a9, 0
42006592:	096d      	mov.n	a6, a9
42006594:	836720        	moveqz	a6, a7, a2
42006597:	0188      	l32i.n	a8, a1, 0
42006599:	071697        	beq	a6, a9, 420065a4 <esp_efuse_utility_process+0x3c>
4200659c:	04a837        	bge	a8, a3, 420065a4 <esp_efuse_utility_process+0x3c>
4200659f:	0428      	l32i.n	a2, a4, 0
420065a1:	4b9297        	bne	a2, a9, 420065f0 <esp_efuse_utility_process+0x88>
            err = func_proc(num_reg, field[i]->efuse_block, start_bit, num_bits, ptr, &bits_counter);
            ++i_reg;
        }
        i++;
    }
    unsigned count_after = s_burn_counter;
420065a4:	e8a141        	l32r	a4, 42000828 <_stext+0x808>
420065a7:	0020c0        	memw
420065aa:	0498      	l32i.n	a9, a4, 0
    if (err == ESP_OK &&
420065ac:	92ec      	bnez.n	a2, 420065d9 <esp_efuse_utility_process+0x71>
        (func_proc == esp_efuse_utility_fill_buff || func_proc == esp_efuse_utility_count_once) && // these functions are used for read APIs: read_field_blob and read_field_cnt
420065ae:	e89f71        	l32r	a7, 4200082c <_stext+0x80c>
420065b1:	140c      	movi.n	a4, 1
420065b3:	c07570        	sub	a7, a5, a7
420065b6:	026d      	mov.n	a6, a2
420065b8:	836470        	moveqz	a6, a4, a7
420065bb:	746060        	extui	a6, a6, 0, 8
420065be:	c6cc      	bnez.n	a6, 420065ce <esp_efuse_utility_process+0x66>
    if (err == ESP_OK &&
420065c0:	e89761        	l32r	a6, 4200081c <_stext+0x7fc>
420065c3:	c05560        	sub	a5, a5, a6
420065c6:	934250        	movnez	a4, a2, a5
        (func_proc == esp_efuse_utility_fill_buff || func_proc == esp_efuse_utility_count_once) && // these functions are used for read APIs: read_field_blob and read_field_cnt
420065c9:	744040        	extui	a4, a4, 0, 8
420065cc:	948c      	beqz.n	a4, 420065d9 <esp_efuse_utility_process+0x71>
420065ce:	5148      	l32i.n	a4, a1, 20
420065d0:	029497        	bne	a4, a9, 420065d6 <esp_efuse_utility_process+0x6e>
        (count_before != count_after || (count_after & 1) == 1)) {
420065d3:	026407        	bbci	a4, 0, 420065d9 <esp_efuse_utility_process+0x71>
        err = ESP_ERR_DAMAGED_READING;
420065d6:	e89221        	l32r	a2, 42000820 <_stext+0x800>
    }
    assert(bits_counter <= req_size);
420065d9:	022387        	blt	a3, a8, 420065df <esp_efuse_utility_process+0x77>
420065dc:	002d06        	j	42006694 <esp_efuse_utility_process+0x12c>
420065df:	e894d1        	l32r	a13, 42000830 <_stext+0x810>
420065e2:	e894c1        	l32r	a12, 42000834 <_stext+0x814>
420065e5:	e894a1        	l32r	a10, 42000838 <_stext+0x818>
420065e8:	8b5c      	movi.n	a11, 88
420065ea:	e6a681        	l32r	a8, 42000084 <_stext+0x64>
420065ed:	0008e0        	callx8	a8
        if (check_range_of_bits(field[i]->efuse_block, field[i]->bit_start, field[i]->bit_count) == false) {
420065f0:	010262        	l8ui	a6, a2, 1
420065f3:	011222        	l16ui	a2, a2, 2

// check range of bits for any coding scheme.
static bool check_range_of_bits(esp_efuse_block_t blk, int offset_in_bits, int size_bits)
{
    int max_num_bit = offset_in_bits + size_bits;
    if (max_num_bit > 256) {
420065f6:	00a182        	movi	a8, 0x100
    int max_num_bit = offset_in_bits + size_bits;
420065f9:	662a      	add.n	a6, a6, a2
420065fb:	092d      	mov.n	a2, a9
    if (max_num_bit > 256) {
420065fd:	05a867        	bge	a8, a6, 42006606 <esp_efuse_utility_process+0x9e>
            err = ESP_ERR_CODING;
42006600:	81a522        	movi	a2, 0x581
42006603:	1122e0        	slli	a2, a2, 2
    return 0;
42006606:	060c      	movi.n	a6, 0
        while (err == ESP_OK && req_size > bits_counter &&
42006608:	090c      	movi.n	a9, 0
4200660a:	098d      	mov.n	a8, a9
4200660c:	838720        	moveqz	a8, a7, a2
4200660f:	01f8      	l32i.n	a15, a1, 0
42006611:	791897        	beq	a8, a9, 4200668e <esp_efuse_utility_process+0x126>
42006614:	76af37        	bge	a15, a3, 4200668e <esp_efuse_utility_process+0x126>
                (num_reg = get_reg_num(field[i]->bit_start, field[i]->bit_count, i_reg)) != -1) {
42006617:	04b8      	l32i.n	a11, a4, 0
42006619:	010b82        	l8ui	a8, a11, 1
4200661c:	011b22        	l16ui	a2, a11, 2
4200661f:	41b9      	s32i.n	a11, a1, 16
    if (num_reg > (bit_start + bit_count - 1) / 32) {
42006621:	228a      	add.n	a2, a2, a8
42006623:	b20b      	addi.n	a11, a2, -1
42006625:	1ec222        	addi	a2, a2, 30
    int num_reg = i_reg + bit_start / 32;
42006628:	21a580        	srai	a10, a8, 5
    if (num_reg > (bit_start + bit_count - 1) / 32) {
4200662b:	b32bb0        	movgez	a2, a11, a11
    int num_reg = i_reg + bit_start / 32;
4200662e:	aa6a      	add.n	a10, a10, a6
    if (num_reg > (bit_start + bit_count - 1) / 32) {
42006630:	212520        	srai	a2, a2, 5
42006633:	5522a7        	blt	a2, a10, 4200668c <esp_efuse_utility_process+0x124>
    return (i_reg == 0) ? bit_start % 32 : 0;
42006636:	44c080        	extui	a12, a8, 0, 5
42006639:	93c960        	movnez	a12, a9, a6
    int ret_count = 0;
4200663c:	09dd      	mov.n	a13, a9
    for (int num_bit = bit_start; num_bit <= last_used_bit; ++num_bit) {
4200663e:	0009c6        	j	42006669 <esp_efuse_utility_process+0x101>
        if ((((num_bit + 1) % 32) == 0) || (num_bit == last_used_bit)) {
42006641:	281b      	addi.n	a2, a8, 1
42006643:	44e020        	extui	a14, a2, 0, 5
42006646:	6129      	s32i.n	a2, a1, 24
42006648:	020c      	movi.n	a2, 0
4200664a:	8327e0        	moveqz	a2, a7, a14
        ++ret_count;
4200664d:	dd1b      	addi.n	a13, a13, 1
        if ((((num_bit + 1) % 32) == 0) || (num_bit == last_used_bit)) {
4200664f:	74e020        	extui	a14, a2, 0, 8
42006652:	82cc      	bnez.n	a2, 4200665e <esp_efuse_utility_process+0xf6>
42006654:	c088b0        	sub	a8, a8, a11
42006657:	83e780        	moveqz	a14, a7, a8
4200665a:	092d      	mov.n	a2, a9
4200665c:	5e8c      	beqz.n	a14, 42006665 <esp_efuse_utility_process+0xfd>
            if (i_reg == num_reg++) {
4200665e:	291b      	addi.n	a2, a9, 1
42006660:	1d1697        	beq	a6, a9, 42006681 <esp_efuse_utility_process+0x119>
            ret_count = 0;
42006663:	0d0c      	movi.n	a13, 0
        if ((((num_bit + 1) % 32) == 0) || (num_bit == last_used_bit)) {
42006665:	6188      	l32i.n	a8, a1, 24
42006667:	029d      	mov.n	a9, a2
    for (int num_bit = bit_start; num_bit <= last_used_bit; ++num_bit) {
42006669:	d4ab87        	bge	a11, a8, 42006641 <esp_efuse_utility_process+0xd9>
    return 0;
4200666c:	0d0c      	movi.n	a13, 0
            err = func_proc(num_reg, field[i]->efuse_block, start_bit, num_bits, ptr, &bits_counter);
4200666e:	4128      	l32i.n	a2, a1, 16
42006670:	71e8      	l32i.n	a14, a1, 28
42006672:	0002b2        	l8ui	a11, a2, 0
42006675:	01fd      	mov.n	a15, a1
42006677:	0005e0        	callx8	a5
4200667a:	0a2d      	mov.n	a2, a10
            ++i_reg;
4200667c:	661b      	addi.n	a6, a6, 1
4200667e:	ffe186        	j	42006608 <esp_efuse_utility_process+0xa0>
            if ((bits_counter + num_bits) > req_size) { // Limits the length of the field.
42006681:	2fda      	add.n	a2, a15, a13
42006683:	e7a327        	bge	a3, a2, 4200666e <esp_efuse_utility_process+0x106>
                num_bits = req_size - bits_counter;
42006686:	c0d3f0        	sub	a13, a3, a15
42006689:	fff846        	j	4200666e <esp_efuse_utility_process+0x106>
4200668c:	092d      	mov.n	a2, a9
        i++;
4200668e:	444b      	addi.n	a4, a4, 4
42006690:	ffbf06        	j	42006590 <esp_efuse_utility_process+0x28>
42006693:	00          	.byte 00
}
42006694:	f01d      	retw.n
	...

42006698 <esp_efuse_utility_read_reg>:
{
42006698:	004136        	entry	a1, 32
    assert(blk >= 0 && blk < EFUSE_BLK_MAX);
4200669b:	a80c      	movi.n	a8, 10
4200669d:	11b827        	bgeu	a8, a2, 420066b2 <esp_efuse_utility_read_reg+0x1a>
420066a0:	e867d1        	l32r	a13, 4200083c <_stext+0x81c>
420066a3:	e867c1        	l32r	a12, 42000840 <_stext+0x820>
420066a6:	05a1b2        	movi	a11, 0x105
    assert(num_reg <= (range_read_addr_blocks[blk].end - range_read_addr_blocks[blk].start) / sizeof(uint32_t));
420066a9:	e863a1        	l32r	a10, 42000838 <_stext+0x818>
420066ac:	e67681        	l32r	a8, 42000084 <_stext+0x64>
420066af:	0008e0        	callx8	a8
420066b2:	e86481        	l32r	a8, 42000844 <_stext+0x824>
420066b5:	b02280        	addx8	a2, a2, a8
420066b8:	0298      	l32i.n	a9, a2, 0
420066ba:	1288      	l32i.n	a8, a2, 4
420066bc:	c08890        	sub	a8, a8, a9
420066bf:	418280        	srli	a8, a8, 2
420066c2:	0bb837        	bgeu	a8, a3, 420066d1 <esp_efuse_utility_read_reg+0x39>
420066c5:	e860d1        	l32r	a13, 42000848 <_stext+0x828>
420066c8:	e85ec1        	l32r	a12, 42000840 <_stext+0x820>
420066cb:	06a1b2        	movi	a11, 0x106
420066ce:	fff5c6        	j	420066a9 <esp_efuse_utility_read_reg+0x11>
    value = REG_READ(range_read_addr_blocks[blk].start + num_reg * 4);
420066d1:	a03390        	addx4	a3, a3, a9
420066d4:	0020c0        	memw
420066d7:	0328      	l32i.n	a2, a3, 0
}
420066d9:	f01d      	retw.n
	...

420066dc <esp_efuse_utility_fill_buff>:
{
420066dc:	006136        	entry	a1, 48
    uint32_t reg = esp_efuse_utility_read_reg(efuse_block, num_reg);
420066df:	02bd      	mov.n	a11, a2
420066e1:	03ad      	mov.n	a10, a3
420066e3:	fffb65        	call8	42006698 <esp_efuse_utility_read_reg>
    uint64_t reg_of_aligned_bits = (reg >> bit_start) & get_mask(bit_count, 0);
420066e6:	400400        	ssr	a4
420066e9:	9140a0        	srl	a4, a10
        mask = 0xFFFFFFFF;
420066ec:	f27c      	movi.n	a2, -1
    if (bit_count != 32) {
420066ee:	09c526        	beqi	a5, 32, 420066fb <esp_efuse_utility_fill_buff+0x1f>
        mask = (1 << bit_count) - 1;
420066f1:	120c      	movi.n	a2, 1
420066f3:	401500        	ssl	a5
420066f6:	a12200        	sll	a2, a2
420066f9:	220b      	addi.n	a2, a2, -1
    int shift_bit = (*bits_counter) % 8;
420066fb:	0788      	l32i.n	a8, a7, 0
    uint64_t reg_of_aligned_bits = (reg >> bit_start) & get_mask(bit_count, 0);
420066fd:	104420        	and	a4, a4, a2
    int shift_bit = (*bits_counter) % 8;
42006700:	e85321        	l32r	a2, 4200084c <_stext+0x82c>
    uint64_t reg_of_aligned_bits = (reg >> bit_start) & get_mask(bit_count, 0);
42006703:	030c      	movi.n	a3, 0
    int shift_bit = (*bits_counter) % 8;
42006705:	102820        	and	a2, a8, a2
42006708:	08a237        	bge	a2, a3, 42006714 <esp_efuse_utility_fill_buff+0x38>
4200670b:	220b      	addi.n	a2, a2, -1
4200670d:	897c      	movi.n	a9, -8
4200670f:	202290        	or	a2, a2, a9
42006712:	221b      	addi.n	a2, a2, 1
    if (shift_bit != 0) {
42006714:	24c080        	extui	a12, a8, 0, 3
42006717:	2cbc      	beqz.n	a12, 4200674d <esp_efuse_utility_fill_buff+0x71>
        blob[(*bits_counter) / 8] |= (uint8_t)(reg_of_aligned_bits << shift_bit);
42006719:	987b      	addi.n	a9, a8, 7
4200671b:	b39880        	movgez	a9, a8, a8
4200671e:	219390        	srai	a9, a9, 3
42006721:	969a      	add.n	a9, a6, a9
42006723:	04ad      	mov.n	a10, a4
42006725:	0b0c      	movi.n	a11, 0
42006727:	1189      	s32i.n	a8, a1, 4
42006729:	2199      	s32i.n	a9, a1, 8
4200672b:	e84981        	l32r	a8, 42000850 <_stext+0x830>
4200672e:	0008e0        	callx8	a8
42006731:	2198      	l32i.n	a9, a1, 8
42006733:	0009b2        	l8ui	a11, a9, 0
42006736:	20aab0        	or	a10, a10, a11
42006739:	0049a2        	s8i	a10, a9, 0
        shift_bit = ((8 - shift_bit) < bit_count) ? (8 - shift_bit) : bit_count;
4200673c:	890c      	movi.n	a9, 8
        (*bits_counter) += shift_bit;
4200673e:	1188      	l32i.n	a8, a1, 4
        shift_bit = ((8 - shift_bit) < bit_count) ? (8 - shift_bit) : bit_count;
42006740:	c02920        	sub	a2, a9, a2
42006743:	432250        	min	a2, a2, a5
        (*bits_counter) += shift_bit;
42006746:	882a      	add.n	a8, a8, a2
42006748:	0789      	s32i.n	a8, a7, 0
        bit_count -= shift_bit;
4200674a:	c05520        	sub	a5, a5, a2
        mask = 0xFFFFFFFF;
4200674d:	090c      	movi.n	a9, 0
        shift_bit = (bit_count > 8) ? 8 : bit_count;
4200674f:	8d0c      	movi.n	a13, 8
    while (bit_count > 0) {
42006751:	0315e6        	bgei	a5, 1, 42006758 <esp_efuse_utility_fill_buff+0x7c>
}
42006754:	020c      	movi.n	a2, 0
42006756:	f01d      	retw.n
        blob[(*bits_counter) / 8] |= (uint8_t)(reg_of_aligned_bits >> sum_shift);
42006758:	0788      	l32i.n	a8, a7, 0
        sum_shift += shift_bit;
4200675a:	992a      	add.n	a9, a9, a2
        blob[(*bits_counter) / 8] |= (uint8_t)(reg_of_aligned_bits >> sum_shift);
4200675c:	287b      	addi.n	a2, a8, 7
4200675e:	b32880        	movgez	a2, a8, a8
42006761:	09cd      	mov.n	a12, a9
42006763:	212320        	srai	a2, a2, 3
42006766:	04ad      	mov.n	a10, a4
42006768:	03bd      	mov.n	a11, a3
4200676a:	262a      	add.n	a2, a6, a2
4200676c:	1189      	s32i.n	a8, a1, 4
4200676e:	2199      	s32i.n	a9, a1, 8
42006770:	01d9      	s32i.n	a13, a1, 0
42006772:	e83881        	l32r	a8, 42000854 <_stext+0x834>
42006775:	0008e0        	callx8	a8
42006778:	0002b2        	l8ui	a11, a2, 0
4200677b:	20aab0        	or	a10, a10, a11
4200677e:	0042a2        	s8i	a10, a2, 0
        shift_bit = (bit_count > 8) ? 8 : bit_count;
42006781:	01d8      	l32i.n	a13, a1, 0
        (*bits_counter) += shift_bit;
42006783:	1188      	l32i.n	a8, a1, 4
        shift_bit = (bit_count > 8) ? 8 : bit_count;
42006785:	4325d0        	min	a2, a5, a13
        (*bits_counter) += shift_bit;
42006788:	882a      	add.n	a8, a8, a2
        bit_count -= shift_bit;
4200678a:	2198      	l32i.n	a9, a1, 8
        (*bits_counter) += shift_bit;
4200678c:	0789      	s32i.n	a8, a7, 0
        bit_count -= shift_bit;
4200678e:	c05520        	sub	a5, a5, a2
42006791:	ffef06        	j	42006751 <esp_efuse_utility_fill_buff+0x75>

42006794 <esp_efuse_utility_count_once>:
{
42006794:	004136        	entry	a1, 32
    uint32_t reg = esp_efuse_utility_read_reg(efuse_block, num_reg);
42006797:	02bd      	mov.n	a11, a2
42006799:	03ad      	mov.n	a10, a3
4200679b:	ffefe5        	call8	42006698 <esp_efuse_utility_read_reg>
        mask = 0xFFFFFFFF;
4200679e:	f87c      	movi.n	a8, -1
    if (bit_count != 32) {
420067a0:	09c526        	beqi	a5, 32, 420067ad <esp_efuse_utility_count_once+0x19>
        mask = (1 << bit_count) - 1;
420067a3:	180c      	movi.n	a8, 1
420067a5:	401500        	ssl	a5
420067a8:	a18800        	sll	a8, a8
420067ab:	880b      	addi.n	a8, a8, -1
    return mask << shift;
420067ad:	401400        	ssl	a4
420067b0:	a18800        	sll	a8, a8
    *((size_t *)out_cnt) += __builtin_popcount(reg & get_mask(bit_count, bit_start)); // Returns the number of 1-bits in reg.
420067b3:	10a8a0        	and	a10, a8, a10
420067b6:	e82881        	l32r	a8, 42000858 <_stext+0x838>
420067b9:	0008e0        	callx8	a8
420067bc:	0688      	l32i.n	a8, a6, 0
}
420067be:	020c      	movi.n	a2, 0
    *((size_t *)out_cnt) += __builtin_popcount(reg & get_mask(bit_count, bit_start)); // Returns the number of 1-bits in reg.
420067c0:	a8aa      	add.n	a10, a8, a10
420067c2:	06a9      	s32i.n	a10, a6, 0
    *bits_counter += bit_count;
420067c4:	0788      	l32i.n	a8, a7, 0
420067c6:	885a      	add.n	a8, a8, a5
420067c8:	0789      	s32i.n	a8, a7, 0
}
420067ca:	f01d      	retw.n

420067cc <gpio_od_enable$isra$0>:
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
    gpio_hal_od_disable(gpio_context.gpio_hal, gpio_num);
    return ESP_OK;
}

static esp_err_t gpio_od_enable(gpio_num_t gpio_num)
420067cc:	004136        	entry	a1, 32
{
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420067cf:	02d296        	bltz	a2, 42006800 <gpio_od_enable$isra$0+0x34>
420067d2:	e822a1        	l32r	a10, 4200085c <_stext+0x83c>
420067d5:	e822b1        	l32r	a11, 42000860 <_stext+0x840>
420067d8:	20c220        	or	a12, a2, a2
420067db:	e81e81        	l32r	a8, 42000854 <_stext+0x834>
420067de:	0008e0        	callx8	a8
420067e1:	1b6a07        	bbci	a10, 0, 42006800 <gpio_od_enable$isra$0+0x34>
    gpio_hal_od_enable(gpio_context.gpio_hal, gpio_num);
420067e4:	e82081        	l32r	a8, 42000864 <_stext+0x844>
  * @param hw Peripheral GPIO hardware instance address.
  * @param gpio_num GPIO number
  */
static inline void gpio_ll_od_enable(gpio_dev_t *hw, uint32_t gpio_num)
{
    hw->pin[gpio_num].pad_driver = 1;
420067e7:	1cc222        	addi	a2, a2, 28
420067ea:	0888      	l32i.n	a8, a8, 0
420067ec:	490c      	movi.n	a9, 4
420067ee:	0888      	l32i.n	a8, a8, 0
420067f0:	a02280        	addx4	a2, a2, a8
420067f3:	0020c0        	memw
420067f6:	1288      	l32i.n	a8, a2, 4
420067f8:	208890        	or	a8, a8, a9
420067fb:	0020c0        	memw
420067fe:	1289      	s32i.n	a8, a2, 4
    return ESP_OK;
}
42006800:	f01d      	retw.n
	...

42006804 <gpio_od_disable$isra$0>:
static esp_err_t gpio_od_disable(gpio_num_t gpio_num)
42006804:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006807:	02d296        	bltz	a2, 42006838 <gpio_od_disable$isra$0+0x34>
4200680a:	e814a1        	l32r	a10, 4200085c <_stext+0x83c>
4200680d:	e814b1        	l32r	a11, 42000860 <_stext+0x840>
42006810:	20c220        	or	a12, a2, a2
42006813:	e81081        	l32r	a8, 42000854 <_stext+0x834>
42006816:	0008e0        	callx8	a8
42006819:	1b6a07        	bbci	a10, 0, 42006838 <gpio_od_disable$isra$0+0x34>
    gpio_hal_od_disable(gpio_context.gpio_hal, gpio_num);
4200681c:	e81281        	l32r	a8, 42000864 <_stext+0x844>
    hw->pin[gpio_num].pad_driver = 0;
4200681f:	1cc222        	addi	a2, a2, 28
42006822:	0888      	l32i.n	a8, a8, 0
42006824:	b97c      	movi.n	a9, -5
42006826:	0888      	l32i.n	a8, a8, 0
42006828:	a02280        	addx4	a2, a2, a8
4200682b:	0020c0        	memw
4200682e:	1288      	l32i.n	a8, a2, 4
42006830:	108890        	and	a8, a8, a9
42006833:	0020c0        	memw
42006836:	1289      	s32i.n	a8, a2, 4
}
42006838:	f01d      	retw.n
	...

4200683c <gpio_output_enable$isra$0>:
static esp_err_t gpio_output_enable(gpio_num_t gpio_num)
4200683c:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
4200683f:	039296        	bltz	a2, 4200687c <gpio_output_enable$isra$0+0x40>
42006842:	e806a1        	l32r	a10, 4200085c <_stext+0x83c>
42006845:	e806b1        	l32r	a11, 42000860 <_stext+0x840>
42006848:	20c220        	or	a12, a2, a2
4200684b:	e80281        	l32r	a8, 42000854 <_stext+0x834>
4200684e:	0008e0        	callx8	a8
42006851:	276a07        	bbci	a10, 0, 4200687c <gpio_output_enable$isra$0+0x40>
    gpio_hal_output_enable(gpio_context.gpio_hal, gpio_num);
42006854:	e80481        	l32r	a8, 42000864 <_stext+0x844>
    if (gpio_num < 32) {
42006857:	f91c      	movi.n	a9, 31
42006859:	0888      	l32i.n	a8, a8, 0
4200685b:	08a8      	l32i.n	a10, a8, 0
4200685d:	180c      	movi.n	a8, 1
        hw->enable_w1ts = (0x1 << gpio_num);
4200685f:	401200        	ssl	a2
42006862:	a18800        	sll	a8, a8
    if (gpio_num < 32) {
42006865:	172927        	blt	a9, a2, 42006880 <gpio_output_enable$isra$0+0x44>
        hw->enable_w1ts = (0x1 << gpio_num);
42006868:	0020c0        	memw
4200686b:	9a89      	s32i.n	a8, a10, 36
    esp_rom_gpio_connect_out_signal(gpio_num, SIG_GPIO_OUT_IDX, false, false);
4200686d:	0d0c      	movi.n	a13, 0
4200686f:	0dcd      	mov.n	a12, a13
42006871:	00a1b2        	movi	a11, 0x100
42006874:	02ad      	mov.n	a10, a2
42006876:	e7fc81        	l32r	a8, 42000868 <_stext+0x848>
42006879:	0008e0        	callx8	a8
}
4200687c:	f01d      	retw.n
4200687e:	00          	.byte 00
4200687f:	00          	.byte 00
        hw->enable1_w1ts.data = (0x1 << (gpio_num - 32));
42006880:	e6f9b1        	l32r	a11, 42000464 <_stext+0x444>
42006883:	0020c0        	memw
42006886:	ca98      	l32i.n	a9, a10, 48
42006888:	1088b0        	and	a8, a8, a11
4200688b:	fb7c      	movi.n	a11, -1
4200688d:	01bba0        	slli	a11, a11, 22
42006890:	1099b0        	and	a9, a9, a11
42006893:	208980        	or	a8, a9, a8
42006896:	0020c0        	memw
42006899:	ca89      	s32i.n	a8, a10, 48
4200689b:	fff386        	j	4200686d <gpio_output_enable$isra$0+0x31>
	...

420068a0 <gpio_output_disable$isra$0>:
static esp_err_t gpio_output_disable(gpio_num_t gpio_num)
420068a0:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420068a3:	039296        	bltz	a2, 420068e0 <gpio_output_disable$isra$0+0x40>
420068a6:	e7eda1        	l32r	a10, 4200085c <_stext+0x83c>
420068a9:	e7edb1        	l32r	a11, 42000860 <_stext+0x840>
420068ac:	02cd      	mov.n	a12, a2
420068ae:	e7e981        	l32r	a8, 42000854 <_stext+0x834>
420068b1:	0008e0        	callx8	a8
420068b4:	286a07        	bbci	a10, 0, 420068e0 <gpio_output_disable$isra$0+0x40>
    gpio_hal_output_disable(gpio_context.gpio_hal, gpio_num);
420068b7:	e7eb81        	l32r	a8, 42000864 <_stext+0x844>
    if (gpio_num < 32) {
420068ba:	f91c      	movi.n	a9, 31
420068bc:	0888      	l32i.n	a8, a8, 0
420068be:	08a8      	l32i.n	a10, a8, 0
420068c0:	180c      	movi.n	a8, 1
        hw->enable_w1tc = (0x1 << gpio_num);
420068c2:	401200        	ssl	a2
420068c5:	a18800        	sll	a8, a8
    if (gpio_num < 32) {
420068c8:	182927        	blt	a9, a2, 420068e4 <gpio_output_disable$isra$0+0x44>
        hw->enable_w1tc = (0x1 << gpio_num);
420068cb:	0020c0        	memw
420068ce:	aa89      	s32i.n	a8, a10, 40
    REG_WRITE(GPIO_FUNC0_OUT_SEL_CFG_REG + (gpio_num * 4),
420068d0:	e7e781        	l32r	a8, 4200086c <_stext+0x84c>
420068d3:	228a      	add.n	a2, a2, a8
420068d5:	1122e0        	slli	a2, a2, 2
420068d8:	00a182        	movi	a8, 0x100
420068db:	0020c0        	memw
420068de:	0289      	s32i.n	a8, a2, 0
}
420068e0:	f01d      	retw.n
420068e2:	00          	.byte 00
420068e3:	00          	.byte 00
        hw->enable1_w1tc.data = (0x1 << (gpio_num - 32));
420068e4:	e6e0b1        	l32r	a11, 42000464 <_stext+0x444>
420068e7:	0020c0        	memw
420068ea:	da98      	l32i.n	a9, a10, 52
420068ec:	1088b0        	and	a8, a8, a11
420068ef:	fb7c      	movi.n	a11, -1
420068f1:	01bba0        	slli	a11, a11, 22
420068f4:	1099b0        	and	a9, a9, a11
420068f7:	208980        	or	a8, a9, a8
420068fa:	0020c0        	memw
420068fd:	da89      	s32i.n	a8, a10, 52
420068ff:	fff346        	j	420068d0 <gpio_output_disable$isra$0+0x30>
	...

42006904 <gpio_input_enable$isra$0>:
static esp_err_t gpio_input_enable(gpio_num_t gpio_num)
42006904:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006907:	029296        	bltz	a2, 42006934 <gpio_input_enable$isra$0+0x30>
4200690a:	e7d4a1        	l32r	a10, 4200085c <_stext+0x83c>
4200690d:	e7d4b1        	l32r	a11, 42000860 <_stext+0x840>
42006910:	20c220        	or	a12, a2, a2
42006913:	e7d081        	l32r	a8, 42000854 <_stext+0x834>
42006916:	0008e0        	callx8	a8
42006919:	176a07        	bbci	a10, 0, 42006934 <gpio_input_enable$isra$0+0x30>
    PIN_INPUT_ENABLE(GPIO_PIN_MUX_REG[gpio_num]);
4200691c:	e7d581        	l32r	a8, 42000870 <_stext+0x850>
4200691f:	00a292        	movi	a9, 0x200
42006922:	a02280        	addx4	a2, a2, a8
42006925:	0288      	l32i.n	a8, a2, 0
42006927:	0020c0        	memw
4200692a:	0828      	l32i.n	a2, a8, 0
4200692c:	202290        	or	a2, a2, a9
4200692f:	0020c0        	memw
42006932:	0829      	s32i.n	a2, a8, 0
}
42006934:	f01d      	retw.n
	...

42006938 <gpio_input_disable$isra$0>:
static esp_err_t gpio_input_disable(gpio_num_t gpio_num)
42006938:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200693b:	029296        	bltz	a2, 42006968 <gpio_input_disable$isra$0+0x30>
4200693e:	e7c7a1        	l32r	a10, 4200085c <_stext+0x83c>
42006941:	e7c7b1        	l32r	a11, 42000860 <_stext+0x840>
42006944:	20c220        	or	a12, a2, a2
42006947:	e7c381        	l32r	a8, 42000854 <_stext+0x834>
4200694a:	0008e0        	callx8	a8
4200694d:	176a07        	bbci	a10, 0, 42006968 <gpio_input_disable$isra$0+0x30>
    PIN_INPUT_DISABLE(IO_MUX_GPIO0_REG + (gpio_num * 4));
42006950:	e7c981        	l32r	a8, 42000874 <_stext+0x854>
42006953:	ffad92        	movi	a9, 0xfffffdff
42006956:	228a      	add.n	a2, a2, a8
42006958:	1122e0        	slli	a2, a2, 2
4200695b:	0020c0        	memw
4200695e:	0288      	l32i.n	a8, a2, 0
42006960:	108890        	and	a8, a8, a9
42006963:	0020c0        	memw
42006966:	0289      	s32i.n	a8, a2, 0
}
42006968:	f01d      	retw.n
	...

4200696c <gpio_pullup_en>:
{
4200696c:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
4200696f:	02a182        	movi	a8, 0x102
42006972:	048296        	bltz	a2, 420069be <gpio_pullup_en+0x52>
42006975:	e7b9a1        	l32r	a10, 4200085c <_stext+0x83c>
42006978:	e7bab1        	l32r	a11, 42000860 <_stext+0x840>
4200697b:	02cd      	mov.n	a12, a2
4200697d:	e7b581        	l32r	a8, 42000854 <_stext+0x834>
42006980:	0008e0        	callx8	a8
42006983:	02a182        	movi	a8, 0x102
42006986:	346a07        	bbci	a10, 0, 420069be <gpio_pullup_en+0x52>
    if (!rtc_gpio_is_valid_gpio(gpio_num) || SOC_GPIO_SUPPORT_RTC_INDEPENDENT) {
42006989:	02ad      	mov.n	a10, a2
4200698b:	0036e5        	call8	42006cf8 <rtc_gpio_is_valid_gpio>
4200698e:	e7ba31        	l32r	a3, 42000878 <_stext+0x858>
42006991:	ffafb2        	movi	a11, -1
42006994:	03ad      	mov.n	a10, a3
42006996:	e5aa81        	l32r	a8, 42000040 <_stext+0x20>
42006999:	0008e0        	callx8	a8
    REG_SET_BIT(GPIO_PIN_MUX_REG[gpio_num], FUN_PU);
4200699c:	e7b581        	l32r	a8, 42000870 <_stext+0x850>
4200699f:	00a192        	movi	a9, 0x100
420069a2:	a02280        	addx4	a2, a2, a8
420069a5:	0288      	l32i.n	a8, a2, 0
        portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
420069a7:	03ad      	mov.n	a10, a3
420069a9:	0020c0        	memw
420069ac:	0828      	l32i.n	a2, a8, 0
420069ae:	202290        	or	a2, a2, a9
420069b1:	0020c0        	memw
420069b4:	0829      	s32i.n	a2, a8, 0
420069b6:	e5a381        	l32r	a8, 42000044 <_stext+0x24>
420069b9:	0008e0        	callx8	a8
420069bc:	080c      	movi.n	a8, 0
}
420069be:	082d      	mov.n	a2, a8
420069c0:	f01d      	retw.n
	...

420069c4 <gpio_pullup_dis>:
{
420069c4:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
420069c7:	02a182        	movi	a8, 0x102
420069ca:	070296        	bltz	a2, 42006a3e <gpio_pullup_dis+0x7a>
420069cd:	e7a3a1        	l32r	a10, 4200085c <_stext+0x83c>
420069d0:	e7a4b1        	l32r	a11, 42000860 <_stext+0x840>
420069d3:	02cd      	mov.n	a12, a2
420069d5:	e79f81        	l32r	a8, 42000854 <_stext+0x834>
420069d8:	0008e0        	callx8	a8
420069db:	02a182        	movi	a8, 0x102
420069de:	5c6a07        	bbci	a10, 0, 42006a3e <gpio_pullup_dis+0x7a>
    if (!rtc_gpio_is_valid_gpio(gpio_num) || SOC_GPIO_SUPPORT_RTC_INDEPENDENT) {
420069e1:	02ad      	mov.n	a10, a2
420069e3:	003165        	call8	42006cf8 <rtc_gpio_is_valid_gpio>
420069e6:	e7a431        	l32r	a3, 42000878 <_stext+0x858>
420069e9:	fb7c      	movi.n	a11, -1
420069eb:	20a330        	or	a10, a3, a3
420069ee:	e59481        	l32r	a8, 42000040 <_stext+0x20>
420069f1:	0008e0        	callx8	a8
    if (gpio_num == USB_DP_GPIO_NUM) {
420069f4:	481c      	movi.n	a8, 20
420069f6:	229287        	bne	a2, a8, 42006a1c <gpio_pullup_dis+0x58>
        SET_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_PAD_PULL_OVERRIDE);
420069f9:	e7a081        	l32r	a8, 4200087c <_stext+0x85c>
420069fc:	00a1a2        	movi	a10, 0x100
420069ff:	0020c0        	memw
42006a02:	0898      	l32i.n	a9, a8, 0
42006a04:	2099a0        	or	a9, a9, a10
42006a07:	0020c0        	memw
42006a0a:	0899      	s32i.n	a9, a8, 0
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_DP_PULLUP);
42006a0c:	0020c0        	memw
42006a0f:	0898      	l32i.n	a9, a8, 0
42006a11:	ffada2        	movi	a10, 0xfffffdff
42006a14:	1099a0        	and	a9, a9, a10
42006a17:	0020c0        	memw
42006a1a:	0899      	s32i.n	a9, a8, 0
    REG_CLR_BIT(IO_MUX_GPIO0_REG + (gpio_num * 4), FUN_PU);
42006a1c:	e79681        	l32r	a8, 42000874 <_stext+0x854>
42006a1f:	ffae92        	movi	a9, 0xfffffeff
42006a22:	228a      	add.n	a2, a2, a8
42006a24:	1122e0        	slli	a2, a2, 2
42006a27:	0020c0        	memw
42006a2a:	0288      	l32i.n	a8, a2, 0
        portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42006a2c:	03ad      	mov.n	a10, a3
42006a2e:	108890        	and	a8, a8, a9
42006a31:	0020c0        	memw
42006a34:	0289      	s32i.n	a8, a2, 0
42006a36:	e58381        	l32r	a8, 42000044 <_stext+0x24>
42006a39:	0008e0        	callx8	a8
42006a3c:	080c      	movi.n	a8, 0
}
42006a3e:	082d      	mov.n	a2, a8
42006a40:	f01d      	retw.n
	...

42006a44 <gpio_pulldown_en>:
{
42006a44:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006a47:	02a182        	movi	a8, 0x102
42006a4a:	048296        	bltz	a2, 42006a96 <gpio_pulldown_en+0x52>
42006a4d:	e783a1        	l32r	a10, 4200085c <_stext+0x83c>
42006a50:	e784b1        	l32r	a11, 42000860 <_stext+0x840>
42006a53:	02cd      	mov.n	a12, a2
42006a55:	e77f81        	l32r	a8, 42000854 <_stext+0x834>
42006a58:	0008e0        	callx8	a8
42006a5b:	02a182        	movi	a8, 0x102
42006a5e:	346a07        	bbci	a10, 0, 42006a96 <gpio_pulldown_en+0x52>
    if (!rtc_gpio_is_valid_gpio(gpio_num) || SOC_GPIO_SUPPORT_RTC_INDEPENDENT) {
42006a61:	02ad      	mov.n	a10, a2
42006a63:	002965        	call8	42006cf8 <rtc_gpio_is_valid_gpio>
42006a66:	e78431        	l32r	a3, 42000878 <_stext+0x858>
42006a69:	ffafb2        	movi	a11, -1
42006a6c:	03ad      	mov.n	a10, a3
42006a6e:	e57481        	l32r	a8, 42000040 <_stext+0x20>
42006a71:	0008e0        	callx8	a8
    REG_SET_BIT(GPIO_PIN_MUX_REG[gpio_num], FUN_PD);
42006a74:	e77f81        	l32r	a8, 42000870 <_stext+0x850>
42006a77:	80a092        	movi	a9, 128
42006a7a:	a02280        	addx4	a2, a2, a8
42006a7d:	0288      	l32i.n	a8, a2, 0
        portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42006a7f:	03ad      	mov.n	a10, a3
42006a81:	0020c0        	memw
42006a84:	0828      	l32i.n	a2, a8, 0
42006a86:	202290        	or	a2, a2, a9
42006a89:	0020c0        	memw
42006a8c:	0829      	s32i.n	a2, a8, 0
42006a8e:	e56d81        	l32r	a8, 42000044 <_stext+0x24>
42006a91:	0008e0        	callx8	a8
42006a94:	080c      	movi.n	a8, 0
}
42006a96:	082d      	mov.n	a2, a8
42006a98:	f01d      	retw.n
	...

42006a9c <gpio_pulldown_dis>:
{
42006a9c:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006a9f:	02a182        	movi	a8, 0x102
42006aa2:	048296        	bltz	a2, 42006aee <gpio_pulldown_dis+0x52>
42006aa5:	e76da1        	l32r	a10, 4200085c <_stext+0x83c>
42006aa8:	e76eb1        	l32r	a11, 42000860 <_stext+0x840>
42006aab:	02cd      	mov.n	a12, a2
42006aad:	e76981        	l32r	a8, 42000854 <_stext+0x834>
42006ab0:	0008e0        	callx8	a8
42006ab3:	02a182        	movi	a8, 0x102
42006ab6:	346a07        	bbci	a10, 0, 42006aee <gpio_pulldown_dis+0x52>
    if (!rtc_gpio_is_valid_gpio(gpio_num) || SOC_GPIO_SUPPORT_RTC_INDEPENDENT) {
42006ab9:	02ad      	mov.n	a10, a2
42006abb:	0023e5        	call8	42006cf8 <rtc_gpio_is_valid_gpio>
42006abe:	e76e31        	l32r	a3, 42000878 <_stext+0x858>
42006ac1:	ffafb2        	movi	a11, -1
42006ac4:	03ad      	mov.n	a10, a3
42006ac6:	e55e81        	l32r	a8, 42000040 <_stext+0x20>
42006ac9:	0008e0        	callx8	a8
    REG_CLR_BIT(IO_MUX_GPIO0_REG + (gpio_num * 4), FUN_PD);
42006acc:	e76a81        	l32r	a8, 42000874 <_stext+0x854>
42006acf:	7faf92        	movi	a9, -129
42006ad2:	228a      	add.n	a2, a2, a8
42006ad4:	1122e0        	slli	a2, a2, 2
42006ad7:	0020c0        	memw
42006ada:	0288      	l32i.n	a8, a2, 0
        portEXIT_CRITICAL(&gpio_context.gpio_spinlock);
42006adc:	03ad      	mov.n	a10, a3
42006ade:	108890        	and	a8, a8, a9
42006ae1:	0020c0        	memw
42006ae4:	0289      	s32i.n	a8, a2, 0
42006ae6:	e55781        	l32r	a8, 42000044 <_stext+0x24>
42006ae9:	0008e0        	callx8	a8
42006aec:	080c      	movi.n	a8, 0
}
42006aee:	082d      	mov.n	a2, a8
42006af0:	f01d      	retw.n
	...

42006af4 <gpio_set_level>:

esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level)
{
42006af4:	004136        	entry	a1, 32
    GPIO_CHECK(GPIO_IS_VALID_OUTPUT_GPIO(gpio_num), "GPIO output gpio_num error", ESP_ERR_INVALID_ARG);
42006af7:	02a182        	movi	a8, 0x102
42006afa:	032296        	bltz	a2, 42006b30 <gpio_set_level+0x3c>
42006afd:	e757a1        	l32r	a10, 4200085c <_stext+0x83c>
42006b00:	e758b1        	l32r	a11, 42000860 <_stext+0x840>
42006b03:	20c220        	or	a12, a2, a2
42006b06:	e75381        	l32r	a8, 42000854 <_stext+0x834>
42006b09:	0008e0        	callx8	a8
42006b0c:	02a182        	movi	a8, 0x102
42006b0f:	1d6a07        	bbci	a10, 0, 42006b30 <gpio_set_level+0x3c>
    gpio_hal_set_level(gpio_context.gpio_hal, gpio_num, level);
42006b12:	e75481        	l32r	a8, 42000864 <_stext+0x844>
42006b15:	fa1c      	movi.n	a10, 31
42006b17:	0888      	l32i.n	a8, a8, 0
42006b19:	0898      	l32i.n	a9, a8, 0
 * @param  level Output level. 0: low ; 1: high
 */
__attribute__((always_inline))
static inline void gpio_ll_set_level(gpio_dev_t *hw, uint32_t gpio_num, uint32_t level)
{
    if (level) {
42006b1b:	180c      	movi.n	a8, 1
        if (gpio_num < 32) {
            hw->out_w1ts = (1 << gpio_num);
42006b1d:	401200        	ssl	a2
42006b20:	a18800        	sll	a8, a8
    if (level) {
42006b23:	d3ac      	beqz.n	a3, 42006b54 <gpio_set_level+0x60>
        if (gpio_num < 32) {
42006b25:	0b2a27        	blt	a10, a2, 42006b34 <gpio_set_level+0x40>
            hw->out_w1ts = (1 << gpio_num);
42006b28:	0020c0        	memw
42006b2b:	2989      	s32i.n	a8, a9, 8
    return ESP_OK;
42006b2d:	00a082        	movi	a8, 0
}
42006b30:	082d      	mov.n	a2, a8
42006b32:	f01d      	retw.n
        } else {
            hw->out1_w1ts.data = (1 << (gpio_num - 32));
42006b34:	e64c31        	l32r	a3, 42000464 <_stext+0x444>
42006b37:	0020c0        	memw
42006b3a:	5928      	l32i.n	a2, a9, 20
42006b3c:	108830        	and	a8, a8, a3
42006b3f:	f37c      	movi.n	a3, -1
42006b41:	0133a0        	slli	a3, a3, 22
42006b44:	102230        	and	a2, a2, a3
42006b47:	202280        	or	a2, a2, a8
42006b4a:	0020c0        	memw
42006b4d:	5929      	s32i.n	a2, a9, 20
42006b4f:	fff686        	j	42006b2d <gpio_set_level+0x39>
42006b52:	00          	.byte 00
42006b53:	00          	.byte 00
        }
    } else {
        if (gpio_num < 32) {
42006b54:	092a27        	blt	a10, a2, 42006b61 <gpio_set_level+0x6d>
            hw->out_w1tc = (1 << gpio_num);
42006b57:	0020c0        	memw
42006b5a:	3989      	s32i.n	a8, a9, 12
    return ESP_OK;
42006b5c:	038d      	mov.n	a8, a3
42006b5e:	fff386        	j	42006b30 <gpio_set_level+0x3c>
        } else {
            hw->out1_w1tc.data = (1 << (gpio_num - 32));
42006b61:	e640a1        	l32r	a10, 42000464 <_stext+0x444>
42006b64:	0020c0        	memw
42006b67:	6928      	l32i.n	a2, a9, 24
42006b69:	1088a0        	and	a8, a8, a10
42006b6c:	fa7c      	movi.n	a10, -1
42006b6e:	01aaa0        	slli	a10, a10, 22
42006b71:	1022a0        	and	a2, a2, a10
42006b74:	202280        	or	a2, a2, a8
42006b77:	0020c0        	memw
42006b7a:	6929      	s32i.n	a2, a9, 24
42006b7c:	fff706        	j	42006b5c <gpio_set_level+0x68>
	...

42006b80 <gpio_set_pull_mode>:
{
    return gpio_hal_get_level(gpio_context.gpio_hal, gpio_num);
}

esp_err_t gpio_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
42006b80:	004136        	entry	a1, 32
42006b83:	204220        	or	a4, a2, a2
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006b86:	02a122        	movi	a2, 0x102
42006b89:	02f496        	bltz	a4, 42006bbc <gpio_set_pull_mode+0x3c>
42006b8c:	0fa0a2        	movi	a10, 15
42006b8f:	fb7c      	movi.n	a11, -1
42006b91:	04cd      	mov.n	a12, a4
42006b93:	01aaa0        	slli	a10, a10, 22
42006b96:	01bbf0        	slli	a11, a11, 17
42006b99:	e73981        	l32r	a8, 42000880 <_stext+0x860>
42006b9c:	0008e0        	callx8	a8
    GPIO_CHECK(pull <= GPIO_FLOATING, "GPIO pull mode error", ESP_ERR_INVALID_ARG);
42006b9f:	0420a0        	extui	a2, a10, 0, 1
42006ba2:	037256        	bnez	a2, 42006bdd <gpio_set_pull_mode+0x5d>
42006ba5:	3443f6        	bgeui	a3, 4, 42006bdd <gpio_set_pull_mode+0x5d>
    esp_err_t ret = ESP_OK;

    switch (pull) {
        case GPIO_PULLUP_ONLY:
            gpio_pulldown_dis(gpio_num);
42006ba8:	20a440        	or	a10, a4, a4
    switch (pull) {
42006bab:	1e2326        	beqi	a3, 2, 42006bcd <gpio_set_pull_mode+0x4d>
42006bae:	223326        	beqi	a3, 3, 42006bd4 <gpio_set_pull_mode+0x54>
42006bb1:	0b1326        	beqi	a3, 1, 42006bc0 <gpio_set_pull_mode+0x40>
            gpio_pulldown_dis(gpio_num);
42006bb4:	ffee65        	call8	42006a9c <gpio_pulldown_dis>
            gpio_pullup_dis(gpio_num);
            break;

        case GPIO_PULLUP_PULLDOWN:
            gpio_pulldown_en(gpio_num);
            gpio_pullup_en(gpio_num);
42006bb7:	04ad      	mov.n	a10, a4
42006bb9:	ffdb25        	call8	4200696c <gpio_pullup_en>
            ret = ESP_ERR_INVALID_ARG;
            break;
    }

    return ret;
}
42006bbc:	f01d      	retw.n
42006bbe:	00          	.byte 00
42006bbf:	00          	.byte 00
            gpio_pulldown_en(gpio_num);
42006bc0:	ffe825        	call8	42006a44 <gpio_pulldown_en>
            gpio_pullup_dis(gpio_num);
42006bc3:	04ad      	mov.n	a10, a4
42006bc5:	ffdfe5        	call8	420069c4 <gpio_pullup_dis>
            break;
42006bc8:	fffc06        	j	42006bbc <gpio_set_pull_mode+0x3c>
42006bcb:	00          	.byte 00
42006bcc:	00          	.byte 00
            gpio_pulldown_en(gpio_num);
42006bcd:	ffe765        	call8	42006a44 <gpio_pulldown_en>
42006bd0:	fff8c6        	j	42006bb7 <gpio_set_pull_mode+0x37>
42006bd3:	00          	.byte 00
            gpio_pulldown_dis(gpio_num);
42006bd4:	ffec65        	call8	42006a9c <gpio_pulldown_dis>
42006bd7:	fffa06        	j	42006bc3 <gpio_set_pull_mode+0x43>
42006bda:	00          	.byte 00
42006bdb:	00          	.byte 00
42006bdc:	00          	.byte 00
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006bdd:	02a122        	movi	a2, 0x102
42006be0:	fff606        	j	42006bbc <gpio_set_pull_mode+0x3c>
	...

42006be4 <gpio_set_direction>:

esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
42006be4:	004136        	entry	a1, 32
42006be7:	024d      	mov.n	a4, a2
    GPIO_CHECK(GPIO_IS_VALID_GPIO(gpio_num), "GPIO number error", ESP_ERR_INVALID_ARG);
42006be9:	02a122        	movi	a2, 0x102
42006bec:	02e496        	bltz	a4, 42006c1e <gpio_set_direction+0x3a>
42006bef:	e71ba1        	l32r	a10, 4200085c <_stext+0x83c>
42006bf2:	e71bb1        	l32r	a11, 42000860 <_stext+0x840>
42006bf5:	04cd      	mov.n	a12, a4
42006bf7:	e71781        	l32r	a8, 42000854 <_stext+0x834>
42006bfa:	0008e0        	callx8	a8
42006bfd:	1d6a07        	bbci	a10, 0, 42006c1e <gpio_set_direction+0x3a>
    }

    esp_err_t ret = ESP_OK;

    if (mode & GPIO_MODE_DEF_INPUT) {
        gpio_input_enable(gpio_num);
42006c00:	04ad      	mov.n	a10, a4
    if (mode & GPIO_MODE_DEF_INPUT) {
42006c02:	1a6307        	bbci	a3, 0, 42006c20 <gpio_set_direction+0x3c>
        gpio_input_enable(gpio_num);
42006c05:	ffcfe5        	call8	42006904 <gpio_input_enable$isra$0>
    } else {
        gpio_input_disable(gpio_num);
    }

    if (mode & GPIO_MODE_DEF_OUTPUT) {
        gpio_output_enable(gpio_num);
42006c08:	04ad      	mov.n	a10, a4
    if (mode & GPIO_MODE_DEF_OUTPUT) {
42006c0a:	1b6317        	bbci	a3, 1, 42006c29 <gpio_set_direction+0x45>
        gpio_output_enable(gpio_num);
42006c0d:	ffc2e5        	call8	4200683c <gpio_output_enable$isra$0>
    } else {
        gpio_output_disable(gpio_num);
    }

    if (mode & GPIO_MODE_DEF_OD) {
42006c10:	480c      	movi.n	a8, 4
42006c12:	102380        	and	a2, a3, a8
        gpio_od_enable(gpio_num);
42006c15:	04ad      	mov.n	a10, a4
    if (mode & GPIO_MODE_DEF_OD) {
42006c17:	529c      	beqz.n	a2, 42006c30 <gpio_set_direction+0x4c>
        gpio_od_enable(gpio_num);
42006c19:	ffbb25        	call8	420067cc <gpio_od_enable$isra$0>
    } else {
        gpio_od_disable(gpio_num);
    }

    return ret;
42006c1c:	020c      	movi.n	a2, 0
}
42006c1e:	f01d      	retw.n
        gpio_input_disable(gpio_num);
42006c20:	ffd165        	call8	42006938 <gpio_input_disable$isra$0>
42006c23:	fff846        	j	42006c08 <gpio_set_direction+0x24>
42006c26:	00          	.byte 00
42006c27:	00          	.byte 00
42006c28:	00          	.byte 00
        gpio_output_disable(gpio_num);
42006c29:	ffc765        	call8	420068a0 <gpio_output_disable$isra$0>
42006c2c:	fff806        	j	42006c10 <gpio_set_direction+0x2c>
42006c2f:	00          	.byte 00
        gpio_od_disable(gpio_num);
42006c30:	ffbd25        	call8	42006804 <gpio_od_disable$isra$0>
42006c33:	fff9c6        	j	42006c1e <gpio_set_direction+0x3a>
	...

42006c38 <gpio_iomux_in>:
    return ESP_OK;
}
#endif

void gpio_iomux_in(uint32_t gpio, uint32_t signal_idx)
{
42006c38:	004136        	entry	a1, 32
    gpio_hal_iomux_in(gpio_context.gpio_hal, gpio, signal_idx);
42006c3b:	e70a81        	l32r	a8, 42000864 <_stext+0x844>
  * @param gpio_num GPIO number of the pad.
  * @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``.
  */
static inline void gpio_ll_iomux_in(gpio_dev_t *hw, uint32_t gpio, uint32_t signal_idx)
{
    hw->func_in_sel_cfg[signal_idx].sig_in_sel = 0;
42006c3e:	54c332        	addi	a3, a3, 84
42006c41:	0888      	l32i.n	a8, a8, 0
42006c43:	7faf92        	movi	a9, -129
42006c46:	0888      	l32i.n	a8, a8, 0
42006c48:	a03380        	addx4	a3, a3, a8
42006c4b:	0020c0        	memw
42006c4e:	1388      	l32i.n	a8, a3, 4
42006c50:	108890        	and	a8, a8, a9
42006c53:	0020c0        	memw
42006c56:	1389      	s32i.n	a8, a3, 4
    PIN_INPUT_ENABLE(GPIO_PIN_MUX_REG[gpio]);
42006c58:	e70631        	l32r	a3, 42000870 <_stext+0x850>
42006c5b:	00a282        	movi	a8, 0x200
42006c5e:	a02230        	addx4	a2, a2, a3
42006c61:	0228      	l32i.n	a2, a2, 0
42006c63:	0020c0        	memw
42006c66:	0238      	l32i.n	a3, a2, 0
42006c68:	203380        	or	a3, a3, a8
42006c6b:	0020c0        	memw
42006c6e:	0239      	s32i.n	a3, a2, 0
}
42006c70:	f01d      	retw.n
	...

42006c74 <gpio_iomux_out>:

void gpio_iomux_out(uint8_t gpio_num, int func, bool oen_inv)
{
42006c74:	004136        	entry	a1, 32
    gpio_hal_iomux_out(gpio_context.gpio_hal, gpio_num, func, (uint32_t)oen_inv);
42006c77:	e6fb81        	l32r	a8, 42000864 <_stext+0x844>
{
42006c7a:	742020        	extui	a2, a2, 0, 8
    gpio_hal_iomux_out(gpio_context.gpio_hal, gpio_num, func, (uint32_t)oen_inv);
42006c7d:	0888      	l32i.n	a8, a8, 0
  *        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``.
  * @param oen_inv True if the output enable needs to be inverted, otherwise False.
  */
static inline void gpio_ll_iomux_out(gpio_dev_t *hw, uint8_t gpio_num, int func, uint32_t oen_inv)
{
    hw->func_out_sel_cfg[gpio_num].oen_sel = 0;
42006c7f:	ffaba2        	movi	a10, 0xfffffbff
42006c82:	0898      	l32i.n	a9, a8, 0
42006c84:	54a182        	movi	a8, 0x154
42006c87:	828a      	add.n	a8, a2, a8
42006c89:	a08890        	addx4	a8, a8, a9
42006c8c:	0020c0        	memw
42006c8f:	1898      	l32i.n	a9, a8, 4
    hw->func_out_sel_cfg[gpio_num].oen_inv_sel = oen_inv;
42006c91:	044040        	extui	a4, a4, 0, 1
    hw->func_out_sel_cfg[gpio_num].oen_sel = 0;
42006c94:	1099a0        	and	a9, a9, a10
42006c97:	0020c0        	memw
42006c9a:	1899      	s32i.n	a9, a8, 4
    hw->func_out_sel_cfg[gpio_num].oen_inv_sel = oen_inv;
42006c9c:	0020c0        	memw
42006c9f:	1898      	l32i.n	a9, a8, 4
42006ca1:	e6f8a1        	l32r	a10, 42000884 <_stext+0x864>
42006ca4:	114450        	slli	a4, a4, 11
42006ca7:	1099a0        	and	a9, a9, a10
42006caa:	209940        	or	a9, a9, a4
    gpio_ll_iomux_func_sel(GPIO_PIN_MUX_REG[gpio_num], func);
42006cad:	e6f041        	l32r	a4, 42000870 <_stext+0x850>
    hw->func_out_sel_cfg[gpio_num].oen_inv_sel = oen_inv;
42006cb0:	0020c0        	memw
42006cb3:	1899      	s32i.n	a9, a8, 4
    gpio_ll_iomux_func_sel(GPIO_PIN_MUX_REG[gpio_num], func);
42006cb5:	a02240        	addx4	a2, a2, a4
42006cb8:	0228      	l32i.n	a2, a2, 0
    if (pin_name == IO_MUX_GPIO19_REG || pin_name == IO_MUX_GPIO20_REG) {
42006cba:	b87c      	movi.n	a8, -5
42006cbc:	e6f341        	l32r	a4, 42000888 <_stext+0x868>
42006cbf:	108280        	and	a8, a2, a8
42006cc2:	129847        	bne	a8, a4, 42006cd8 <gpio_iomux_out+0x64>
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_USB_PAD_ENABLE);
42006cc5:	e6ed41        	l32r	a4, 4200087c <_stext+0x85c>
42006cc8:	e59691        	l32r	a9, 42000320 <_stext+0x300>
42006ccb:	0020c0        	memw
42006cce:	0488      	l32i.n	a8, a4, 0
42006cd0:	108890        	and	a8, a8, a9
42006cd3:	0020c0        	memw
42006cd6:	0489      	s32i.n	a8, a4, 0
    PIN_FUNC_SELECT(pin_name, func);
42006cd8:	0020c0        	memw
42006cdb:	0288      	l32i.n	a8, a2, 0
42006cdd:	e5ff41        	l32r	a4, 420004dc <_stext+0x4bc>
42006ce0:	790c      	movi.n	a9, 7
42006ce2:	113340        	slli	a3, a3, 12
42006ce5:	119940        	slli	a9, a9, 12
42006ce8:	103390        	and	a3, a3, a9
42006ceb:	108840        	and	a8, a8, a4
42006cee:	203380        	or	a3, a3, a8
42006cf1:	0020c0        	memw
42006cf4:	0239      	s32i.n	a3, a2, 0
}
42006cf6:	f01d      	retw.n

42006cf8 <rtc_gpio_is_valid_gpio>:
}

#endif // SOC_RTCIO_WAKE_SUPPORTED

bool rtc_gpio_is_valid_gpio(gpio_num_t gpio_num)
{
42006cf8:	004136        	entry	a1, 32
#if SOC_RTCIO_INPUT_OUTPUT_SUPPORTED
    return (gpio_num < GPIO_PIN_COUNT && rtc_io_num_map[gpio_num] >= 0);
42006cfb:	093c      	movi.n	a9, 48
42006cfd:	080c      	movi.n	a8, 0
42006cff:	0f2927        	blt	a9, a2, 42006d12 <rtc_gpio_is_valid_gpio+0x1a>
42006d02:	e5d981        	l32r	a8, 42000468 <_stext+0x448>
42006d05:	a02280        	addx4	a2, a2, a8
42006d08:	0228      	l32i.n	a2, a2, 0
42006d0a:	f87c      	movi.n	a8, -1
42006d0c:	308820        	xor	a8, a8, a2
42006d0f:	058f80        	extui	a8, a8, 31, 1
#else
    return false;
#endif
}
42006d12:	082d      	mov.n	a2, a8
42006d14:	f01d      	retw.n
	...

42006d18 <uart_try_set_iomux_pin>:
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
    return ESP_OK;
}

static bool uart_try_set_iomux_pin(uart_port_t uart_num, int io_num, uint32_t idx)
{
42006d18:	004136        	entry	a1, 32
    /* Store a pointer to the default pin, to optimize access to its fields. */
    const uart_periph_sig_t *upin = &uart_periph_signal[uart_num].pins[idx];

    /* In theory, if default_gpio is -1, iomux_func should also be -1, but
     * let's be safe and test both. */
    if (upin->iomux_func == -1 || upin->default_gpio == -1 || upin->default_gpio != io_num) {
42006d1b:	902220        	addx2	a2, a2, a2
42006d1e:	902240        	addx2	a2, a2, a4
42006d21:	e6da41        	l32r	a4, 4200088c <_stext+0x86c>
42006d24:	0fa052        	movi	a5, 15
42006d27:	a02240        	addx4	a2, a2, a4
42006d2a:	002242        	l32i	a4, a2, 0
42006d2d:	401500        	ssl	a5
42006d30:	a15500        	sll	a5, a5
42006d33:	108450        	and	a8, a4, a5
        return false;
42006d36:	020c      	movi.n	a2, 0
    if (upin->iomux_func == -1 || upin->default_gpio == -1 || upin->default_gpio != io_num) {
42006d38:	2c1857        	beq	a8, a5, 42006d68 <uart_try_set_iomux_pin+0x50>
42006d3b:	e6b381        	l32r	a8, 42000808 <_stext+0x7e8>
42006d3e:	e45040        	extui	a5, a4, 0, 15
42006d41:	231587        	beq	a5, a8, 42006d68 <uart_try_set_iomux_pin+0x50>
42006d44:	235470        	sext	a5, a4, 14
42006d47:	235580        	sext	a5, a5, 15
42006d4a:	1a9537        	bne	a5, a3, 42006d68 <uart_try_set_iomux_pin+0x50>
    }

    /* Assign the correct funct to the GPIO. */
    assert (upin->iomux_func != -1);
    gpio_iomux_out(io_num, upin->iomux_func, false);
42006d4d:	11b430        	slli	a11, a4, 13
42006d50:	02cd      	mov.n	a12, a2
42006d52:	31bcb0        	srai	a11, a11, 28
42006d55:	74a050        	extui	a10, a5, 0, 8
42006d58:	fff1a5        	call8	42006c74 <gpio_iomux_out>
     * in order to bypasse the GPIO matrix. */
    if (upin->input) {
        gpio_iomux_in(io_num, upin->signal);
    }

    return true;
42006d5b:	120c      	movi.n	a2, 1
    if (upin->input) {
42006d5d:	077437        	bbci	a4, 19, 42006d68 <uart_try_set_iomux_pin+0x50>
        gpio_iomux_in(io_num, upin->signal);
42006d60:	b5b440        	extui	a11, a4, 20, 12
42006d63:	05ad      	mov.n	a10, a5
42006d65:	ffed25        	call8	42006c38 <gpio_iomux_in>
}
42006d68:	f01d      	retw.n
	...

42006d6c <uart_module_enable>:
{
42006d6c:	004136        	entry	a1, 32
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42006d6f:	e6c831        	l32r	a3, 42000890 <_stext+0x870>
42006d72:	1152c0        	slli	a5, a2, 4
42006d75:	04c542        	addi	a4, a5, 4
42006d78:	804430        	add	a4, a4, a3
42006d7b:	fb7c      	movi.n	a11, -1
42006d7d:	04ad      	mov.n	a10, a4
    if (uart_context[uart_num].hw_enabled != true) {
42006d7f:	635a      	add.n	a6, a3, a5
42006d81:	e4af81        	l32r	a8, 42000040 <_stext+0x20>
42006d84:	0008e0        	callx8	a8
42006d87:	0c0672        	l8ui	a7, a6, 12
42006d8a:	047756        	bnez	a7, 42006dd5 <uart_module_enable+0x69>
        periph_module_enable(uart_periph_signal[uart_num].module);
42006d8d:	e6bf71        	l32r	a7, 4200088c <_stext+0x86c>
42006d90:	908220        	addx2	a8, a2, a2
42006d93:	b08870        	addx8	a8, a8, a7
42006d96:	5878      	l32i.n	a7, a8, 20
42006d98:	07ad      	mov.n	a10, a7
42006d9a:	fc16e5        	call8	42002f08 <periph_module_enable>
        if (uart_num != CONFIG_ESP_CONSOLE_UART_NUM) {
42006d9d:	d2ac      	beqz.n	a2, 42006dce <uart_module_enable+0x62>
            uart_hal_set_reset_core(&(uart_context[uart_num].hal), true);
42006d9f:	0698      	l32i.n	a9, a6, 0
    hw->clk_conf.rst_core = core_rst_en;
42006da1:	180c      	movi.n	a8, 1
42006da3:	0020c0        	memw
42006da6:	1e2922        	l32i	a2, a9, 120
42006da9:	018890        	slli	a8, a8, 23
42006dac:	202280        	or	a2, a2, a8
42006daf:	0020c0        	memw
42006db2:	1e6922        	s32i	a2, a9, 120
            periph_module_reset(uart_periph_signal[uart_num].module);
42006db5:	07ad      	mov.n	a10, a7
42006db7:	fc2665        	call8	4200301c <periph_module_reset>
            uart_hal_set_reset_core(&(uart_context[uart_num].hal), false);
42006dba:	0668      	l32i.n	a6, a6, 0
42006dbc:	e6b671        	l32r	a7, 42000894 <_stext+0x874>
42006dbf:	0020c0        	memw
42006dc2:	1e2622        	l32i	a2, a6, 120
42006dc5:	102270        	and	a2, a2, a7
42006dc8:	0020c0        	memw
42006dcb:	1e6622        	s32i	a2, a6, 120
        uart_context[uart_num].hw_enabled = true;
42006dce:	335a      	add.n	a3, a3, a5
42006dd0:	120c      	movi.n	a2, 1
42006dd2:	0c4322        	s8i	a2, a3, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42006dd5:	04ad      	mov.n	a10, a4
42006dd7:	e49b81        	l32r	a8, 42000044 <_stext+0x24>
42006dda:	0008e0        	callx8	a8
}
42006ddd:	f01d      	retw.n
	...

42006de0 <uart_enable_tx_write_fifo>:
    }
    return len;
}

static uint32_t UART_ISR_ATTR uart_enable_tx_write_fifo(uart_port_t uart_num, const uint8_t *pbuf, uint32_t len)
{
42006de0:	006136        	entry	a1, 48
    uint32_t sent_len = 0;
    UART_ENTER_CRITICAL_SAFE(&(uart_context[uart_num].spinlock));
42006de3:	e6ab71        	l32r	a7, 42000890 <_stext+0x870>
    uint32_t sent_len = 0;
42006de6:	050c      	movi.n	a5, 0
42006de8:	1162c0        	slli	a6, a2, 4
42006deb:	0159      	s32i.n	a5, a1, 0
    UART_ENTER_CRITICAL_SAFE(&(uart_context[uart_num].spinlock));
42006ded:	564b      	addi.n	a5, a6, 4
    if (xPortInIsrContext()) {
42006def:	e56d81        	l32r	a8, 420003a4 <_stext+0x384>
42006df2:	0008e0        	callx8	a8
42006df5:	557a      	add.n	a5, a5, a7
        ret = portTRY_ENTER_CRITICAL(mux, timeout);
42006df7:	fb7c      	movi.n	a11, -1
42006df9:	05ad      	mov.n	a10, a5
42006dfb:	e49181        	l32r	a8, 42000040 <_stext+0x20>
42006dfe:	0008e0        	callx8	a8
    if (UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX)) {
42006e01:	e6a581        	l32r	a8, 42000898 <_stext+0x878>
42006e04:	a02280        	addx4	a2, a2, a8
42006e07:	0228      	l32i.n	a2, a2, 0
42006e09:	3228      	l32i.n	a2, a2, 12
42006e0b:	281266        	bnei	a2, 1, 42006e37 <uart_enable_tx_write_fifo+0x57>
        uart_hal_set_rts(&(uart_context[uart_num].hal), 0);
42006e0e:	276a      	add.n	a2, a7, a6
42006e10:	0288      	l32i.n	a8, a2, 0
 *
 * @return None.
 */
FORCE_INLINE_ATTR void uart_ll_set_rts_active_level(uart_dev_t *hw, int level)
{
    hw->conf0.sw_rts = level & 0x1;
42006e12:	bfaf92        	movi	a9, -65
42006e15:	0020c0        	memw
42006e18:	8828      	l32i.n	a2, a8, 32
42006e1a:	102290        	and	a2, a2, a9
    hw->int_clr.val = mask;
42006e1d:	e69f91        	l32r	a9, 4200089c <_stext+0x87c>
    hw->conf0.sw_rts = level & 0x1;
42006e20:	0020c0        	memw
42006e23:	8829      	s32i.n	a2, a8, 32
    hw->int_clr.val = mask;
42006e25:	0020c0        	memw
42006e28:	4899      	s32i.n	a9, a8, 16
    hw->int_ena.val |= mask;
42006e2a:	0020c0        	memw
42006e2d:	3828      	l32i.n	a2, a8, 12
42006e2f:	202290        	or	a2, a2, a9
42006e32:	0020c0        	memw
42006e35:	3829      	s32i.n	a2, a8, 12
        // If any new things are written to fifo, then we can always clear the previous TX_DONE interrupt bit (if it was set)
        // Old TX_DONE bit might reset the RTS, leading new tx transmission failure for rs485 mode
        uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TX_DONE);
        uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_DONE);
    }
    uart_hal_write_txfifo(&(uart_context[uart_num].hal), pbuf, len, &sent_len);
42006e37:	01dd      	mov.n	a13, a1
42006e39:	04cd      	mov.n	a12, a4
42006e3b:	20b330        	or	a11, a3, a3
42006e3e:	80a760        	add	a10, a7, a6
42006e41:	10e5a5        	call8	42017c9c <uart_hal_write_txfifo>
    if (xPortInIsrContext()) {
42006e44:	e55881        	l32r	a8, 420003a4 <_stext+0x384>
42006e47:	0008e0        	callx8	a8
        portEXIT_CRITICAL(mux);
42006e4a:	05ad      	mov.n	a10, a5
42006e4c:	e47e81        	l32r	a8, 42000044 <_stext+0x24>
42006e4f:	0008e0        	callx8	a8
    UART_EXIT_CRITICAL_SAFE(&(uart_context[uart_num].spinlock));
    return sent_len;
}
42006e52:	0128      	l32i.n	a2, a1, 0
42006e54:	f01d      	retw.n
	...

42006e58 <uart_free_driver_obj>:
    xSemaphoreGive(p_uart->rx_mux);
    return ESP_OK;
}

static void uart_free_driver_obj(uart_obj_t *uart_obj)
{
42006e58:	004136        	entry	a1, 32
    if (uart_obj->tx_fifo_sem) {
42006e5b:	3e22a2        	l32i	a10, a2, 248
42006e5e:	4a8c      	beqz.n	a10, 42006e66 <uart_free_driver_obj+0xe>
        vSemaphoreDelete(uart_obj->tx_fifo_sem);
42006e60:	e69081        	l32r	a8, 420008a0 <_stext+0x880>
42006e63:	0008e0        	callx8	a8
    }
    if (uart_obj->tx_done_sem) {
42006e66:	3f22a2        	l32i	a10, a2, 252
42006e69:	4a8c      	beqz.n	a10, 42006e71 <uart_free_driver_obj+0x19>
        vSemaphoreDelete(uart_obj->tx_done_sem);
42006e6b:	e68d81        	l32r	a8, 420008a0 <_stext+0x880>
42006e6e:	0008e0        	callx8	a8
    }
    if (uart_obj->tx_brk_sem) {
42006e71:	4022a2        	l32i	a10, a2, 0x100
42006e74:	005a16        	beqz	a10, 42006e7d <uart_free_driver_obj+0x25>
        vSemaphoreDelete(uart_obj->tx_brk_sem);
42006e77:	e68a81        	l32r	a8, 420008a0 <_stext+0x880>
42006e7a:	0008e0        	callx8	a8
    }
    if (uart_obj->tx_mux) {
42006e7d:	3d22a2        	l32i	a10, a2, 244
42006e80:	005a16        	beqz	a10, 42006e89 <uart_free_driver_obj+0x31>
        vSemaphoreDelete(uart_obj->tx_mux);
42006e83:	e68781        	l32r	a8, 420008a0 <_stext+0x880>
42006e86:	0008e0        	callx8	a8
    }
    if (uart_obj->rx_mux) {
42006e89:	3c22a2        	l32i	a10, a2, 240
42006e8c:	005a16        	beqz	a10, 42006e95 <uart_free_driver_obj+0x3d>
        vSemaphoreDelete(uart_obj->rx_mux);
42006e8f:	e68481        	l32r	a8, 420008a0 <_stext+0x880>
42006e92:	0008e0        	callx8	a8
    }
    if (uart_obj->event_queue) {
42006e95:	3922a2        	l32i	a10, a2, 228
42006e98:	005a16        	beqz	a10, 42006ea1 <uart_free_driver_obj+0x49>
        vQueueDelete(uart_obj->event_queue);
42006e9b:	e68181        	l32r	a8, 420008a0 <_stext+0x880>
42006e9e:	0008e0        	callx8	a8
    }
    if (uart_obj->rx_ring_buf) {
42006ea1:	3a22a2        	l32i	a10, a2, 232
42006ea4:	005a16        	beqz	a10, 42006ead <uart_free_driver_obj+0x55>
        vRingbufferDelete(uart_obj->rx_ring_buf);
42006ea7:	e67f81        	l32r	a8, 420008a4 <_stext+0x884>
42006eaa:	0008e0        	callx8	a8
    }
    if (uart_obj->tx_ring_buf) {
42006ead:	3b22a2        	l32i	a10, a2, 236
42006eb0:	4a8c      	beqz.n	a10, 42006eb8 <uart_free_driver_obj+0x60>
        vRingbufferDelete(uart_obj->tx_ring_buf);
42006eb2:	e67c81        	l32r	a8, 420008a4 <_stext+0x884>
42006eb5:	0008e0        	callx8	a8
    free(uart_obj->tx_mux_struct);
    free(uart_obj->tx_brk_sem_struct);
    free(uart_obj->tx_done_sem_struct);
    free(uart_obj->tx_fifo_sem_struct);
#endif
    free(uart_obj);
42006eb8:	02ad      	mov.n	a10, a2
42006eba:	e45a81        	l32r	a8, 42000024 <_stext+0x4>
42006ebd:	0008e0        	callx8	a8
}
42006ec0:	f01d      	retw.n
	...

42006ec4 <uart_reenable_intr_mask$constprop$0$isra$0>:
static esp_err_t uart_reenable_intr_mask(uart_port_t uart_num, uint32_t enable_mask)
42006ec4:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42006ec7:	4532e6        	bgei	a2, 3, 42006f10 <uart_reenable_intr_mask$constprop$0$isra$0+0x4c>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42006eca:	e67141        	l32r	a4, 42000890 <_stext+0x870>
42006ecd:	1152c0        	slli	a5, a2, 4
42006ed0:	354b      	addi.n	a3, a5, 4
42006ed2:	334a      	add.n	a3, a3, a4
    xPortEnterCriticalTimeout(mux, portMUX_NO_TIMEOUT);
42006ed4:	ffafb2        	movi	a11, -1
42006ed7:	20a330        	or	a10, a3, a3
42006eda:	e45981        	l32r	a8, 42000040 <_stext+0x20>
42006edd:	0008e0        	callx8	a8
    uint32_t mask = p_uart_obj[uart_num]->rx_int_usr_mask & enable_mask;
42006ee0:	e66e81        	l32r	a8, 42000898 <_stext+0x878>
    uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), mask);
42006ee3:	445a      	add.n	a4, a4, a5
    uint32_t mask = p_uart_obj[uart_num]->rx_int_usr_mask & enable_mask;
42006ee5:	a02280        	addx4	a2, a2, a8
42006ee8:	0228      	l32i.n	a2, a2, 0
42006eea:	01a182        	movi	a8, 0x101
42006eed:	2c2222        	l32i	a2, a2, 176
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42006ef0:	03ad      	mov.n	a10, a3
    uint32_t mask = p_uart_obj[uart_num]->rx_int_usr_mask & enable_mask;
42006ef2:	108820        	and	a8, a8, a2
    uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), mask);
42006ef5:	0428      	l32i.n	a2, a4, 0
    hw->int_clr.val = mask;
42006ef7:	0020c0        	memw
42006efa:	4289      	s32i.n	a8, a2, 16
    hw->int_ena.val |= mask;
42006efc:	0020c0        	memw
42006eff:	3248      	l32i.n	a4, a2, 12
42006f01:	208840        	or	a8, a8, a4
42006f04:	0020c0        	memw
42006f07:	036282        	s32i	a8, a2, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42006f0a:	e44e81        	l32r	a8, 42000044 <_stext+0x24>
42006f0d:	0008e0        	callx8	a8
}
42006f10:	f01d      	retw.n
	...

42006f14 <uart_check_buf_full>:
{
42006f14:	004136        	entry	a1, 32
    if (p_uart_obj[uart_num]->rx_buffer_full_flg) {
42006f17:	e66041        	l32r	a4, 42000898 <_stext+0x878>
42006f1a:	a04240        	addx4	a4, a2, a4
42006f1d:	0438      	l32i.n	a3, a4, 0
42006f1f:	1c0352        	l8ui	a5, a3, 28
42006f22:	65cc      	bnez.n	a5, 42006f2c <uart_check_buf_full+0x18>
    return false;
42006f24:	050c      	movi.n	a5, 0
}
42006f26:	052d      	mov.n	a2, a5
42006f28:	f01d      	retw.n
42006f2a:	00          	.byte 00
42006f2b:	00          	.byte 00
        BaseType_t res = xRingbufferSend(p_uart_obj[uart_num]->rx_ring_buf, p_uart_obj[uart_num]->rx_data_buf, p_uart_obj[uart_num]->rx_stash_len, 1);
42006f2c:	ac03c2        	l8ui	a12, a3, 172
42006f2f:	3a23a2        	l32i	a10, a3, 232
42006f32:	1d0c      	movi.n	a13, 1
42006f34:	2cc3b2        	addi	a11, a3, 44
42006f37:	e65c81        	l32r	a8, 420008a8 <_stext+0x888>
42006f3a:	0008e0        	callx8	a8
        if (res == pdTRUE) {
42006f3d:	e31a66        	bnei	a10, 1, 42006f24 <uart_check_buf_full+0x10>
            UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42006f40:	1132c0        	slli	a3, a2, 4
42006f43:	e65321        	l32r	a2, 42000890 <_stext+0x870>
42006f46:	334b      	addi.n	a3, a3, 4
42006f48:	332a      	add.n	a3, a3, a2
42006f4a:	fb7c      	movi.n	a11, -1
42006f4c:	03ad      	mov.n	a10, a3
42006f4e:	e43c81        	l32r	a8, 42000040 <_stext+0x20>
42006f51:	0008e0        	callx8	a8
            p_uart_obj[uart_num]->rx_buffered_len += p_uart_obj[uart_num]->rx_stash_len;
42006f54:	0488      	l32i.n	a8, a4, 0
            UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42006f56:	03ad      	mov.n	a10, a3
            p_uart_obj[uart_num]->rx_buffered_len += p_uart_obj[uart_num]->rx_stash_len;
42006f58:	5828      	l32i.n	a2, a8, 20
42006f5a:	ac0892        	l8ui	a9, a8, 172
42006f5d:	229a      	add.n	a2, a2, a9
42006f5f:	5829      	s32i.n	a2, a8, 20
            p_uart_obj[uart_num]->rx_buffer_full_flg = false;
42006f61:	00a022        	movi	a2, 0
42006f64:	1c4822        	s8i	a2, a8, 28
            UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42006f67:	e43781        	l32r	a8, 42000044 <_stext+0x24>
42006f6a:	0008e0        	callx8	a8
            uart_reenable_intr_mask(p_uart_obj[uart_num]->uart_num, UART_INTR_RXFIFO_TOUT | UART_INTR_RXFIFO_FULL);
42006f6d:	0428      	l32i.n	a2, a4, 0
42006f6f:	02a8      	l32i.n	a10, a2, 0
42006f71:	fff525        	call8	42006ec4 <uart_reenable_intr_mask$constprop$0$isra$0>
            return true;
42006f74:	ffeb86        	j	42006f26 <uart_check_buf_full+0x12>
	...

42006f78 <uart_pattern_queue_update$isra$0>:
static esp_err_t uart_pattern_queue_update(uart_port_t uart_num, int diff_len)
42006f78:	004136        	entry	a1, 32
    uart_pat_rb_t *p_pos = &p_uart_obj[uart_num]->rx_pattern_pos;
42006f7b:	e64781        	l32r	a8, 42000898 <_stext+0x878>
42006f7e:	a02280        	addx4	a2, a2, a8
42006f81:	0298      	l32i.n	a9, a2, 0
    int rd = p_pos->rd;
42006f83:	2e2982        	l32i	a8, a9, 184
    while (rd != p_pos->wr) {
42006f86:	2d2922        	l32i	a2, a9, 180
42006f89:	049827        	bne	a8, a2, 42006f91 <uart_pattern_queue_update$isra$0+0x19>
}
42006f8c:	f01d      	retw.n
42006f8e:	00          	.byte 00
42006f8f:	00          	.byte 00
42006f90:	00          	.byte 00
        p_pos->data[rd] -= diff_len;
42006f91:	3029b2        	l32i	a11, a9, 192
42006f94:	a0b8b0        	addx4	a11, a8, a11
42006f97:	0ba8      	l32i.n	a10, a11, 0
        rd ++;
42006f99:	881b      	addi.n	a8, a8, 1
        p_pos->data[rd] -= diff_len;
42006f9b:	c0aa30        	sub	a10, a10, a3
42006f9e:	0ba9      	s32i.n	a10, a11, 0
        if (rd >= p_pos->len) {
42006fa0:	2f2922        	l32i	a2, a9, 188
42006fa3:	012827        	blt	a8, a2, 42006fa8 <uart_pattern_queue_update$isra$0+0x30>
            rd = 0;
42006fa6:	080c      	movi.n	a8, 0
        if (p_pos->data[rd_rec] < 0) {
42006fa8:	fdaad6        	bgez	a10, 42006f86 <uart_pattern_queue_update$isra$0+0xe>
            p_pos->rd = rd;
42006fab:	2e6982        	s32i	a8, a9, 184
42006fae:	fff506        	j	42006f86 <uart_pattern_queue_update$isra$0+0xe>
42006fb1:	000000        	ill

42006fb4 <uart_pattern_enqueue$isra$0>:
static esp_err_t UART_ISR_ATTR uart_pattern_enqueue(uart_port_t uart_num, int pos)
42006fb4:	004136        	entry	a1, 32
    uart_pat_rb_t *p_pos = &p_uart_obj[uart_num]->rx_pattern_pos;
42006fb7:	e63881        	l32r	a8, 42000898 <_stext+0x878>
42006fba:	a02280        	addx4	a2, a2, a8
42006fbd:	0288      	l32i.n	a8, a2, 0
    int next = p_pos->wr + 1;
42006fbf:	2d28a2        	l32i	a10, a8, 180
    if (next >= p_pos->len) {
42006fc2:	2f2822        	l32i	a2, a8, 188
    int next = p_pos->wr + 1;
42006fc5:	9a1b      	addi.n	a9, a10, 1
    if (next >= p_pos->len) {
42006fc7:	012927        	blt	a9, a2, 42006fcc <uart_pattern_enqueue$isra$0+0x18>
        next = 0;
42006fca:	090c      	movi.n	a9, 0
    if (next == p_pos->rd) {
42006fcc:	2e2822        	l32i	a2, a8, 184
42006fcf:	0a1297        	beq	a2, a9, 42006fdd <uart_pattern_enqueue$isra$0+0x29>
        p_pos->data[p_pos->wr] = pos;
42006fd2:	302822        	l32i	a2, a8, 192
42006fd5:	a0aa20        	addx4	a10, a10, a2
42006fd8:	0a39      	s32i.n	a3, a10, 0
        p_pos->wr = next;
42006fda:	2d6892        	s32i	a9, a8, 180
}
42006fdd:	f01d      	retw.n
	...

42006fe0 <uart_rx_intr_handler_default>:
{
42006fe0:	00c136        	entry	a1, 96
    int rx_fifo_len = 0;
42006fe3:	000252        	l8ui	a5, a2, 0
42006fe6:	030c      	movi.n	a3, 0
                UART_ENTER_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
42006fe8:	e62a61        	l32r	a6, 42000890 <_stext+0x870>
            if (UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX) && uart_hal_is_tx_idle(&(uart_context[uart_num].hal)) != true) {
42006feb:	e62b81        	l32r	a8, 42000898 <_stext+0x878>
    int rx_fifo_len = 0;
42006fee:	7139      	s32i.n	a3, a1, 28
    portBASE_TYPE HPTaskAwoken = 0;
42006ff0:	6139      	s32i.n	a3, a1, 24
42006ff2:	1135c0        	slli	a3, a5, 4
                UART_ENTER_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
42006ff5:	434b      	addi.n	a4, a3, 4
42006ff7:	446a      	add.n	a4, a4, a6
                    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
42006ff9:	336a      	add.n	a3, a3, a6
            if (UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX) && uart_hal_is_tx_idle(&(uart_context[uart_num].hal)) != true) {
42006ffb:	a08580        	addx4	a8, a5, a8
42006ffe:	1165e0        	slli	a6, a5, 2
42007001:	9169      	s32i.n	a6, a1, 36
42007003:	b189      	s32i.n	a8, a1, 44
        uart_intr_status = uart_hal_get_intsts_mask(&(uart_context[uart_num].hal));
42007005:	0388      	l32i.n	a8, a3, 0
    return hw->int_st.val;
42007007:	0020c0        	memw
4200700a:	2878      	l32i.n	a7, a8, 8
        if (uart_intr_status == 0) {
4200700c:	63c716        	beqz	a7, 4200764c <uart_rx_intr_handler_default+0x66c>
        uart_event.type = UART_EVENT_MAX;
4200700f:	960c      	movi.n	a6, 9
42007011:	0169      	s32i.n	a6, a1, 0
        if (uart_intr_status & UART_INTR_TXFIFO_EMPTY) {
42007013:	260c      	movi.n	a6, 2
42007015:	10a760        	and	a10, a7, a6
42007018:	1a4a16        	beqz	a10, 420071c0 <uart_rx_intr_handler_default+0x1e0>
4200701b:	fb7c      	movi.n	a11, -1
4200701d:	04ad      	mov.n	a10, a4
4200701f:	e40881        	l32r	a8, 42000040 <_stext+0x20>
42007022:	0008e0        	callx8	a8
            uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
42007025:	0388      	l32i.n	a8, a3, 0
    hw->int_ena.val &= (~mask);
42007027:	d97c      	movi.n	a9, -3
42007029:	0020c0        	memw
4200702c:	3878      	l32i.n	a7, a8, 12
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
4200702e:	04ad      	mov.n	a10, a4
42007030:	107790        	and	a7, a7, a9
42007033:	0020c0        	memw
42007036:	3879      	s32i.n	a7, a8, 12
42007038:	e40381        	l32r	a8, 42000044 <_stext+0x24>
4200703b:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
4200703e:	0378      	l32i.n	a7, a3, 0
    hw->int_clr.val = mask;
42007040:	0020c0        	memw
42007043:	4769      	s32i.n	a6, a7, 16
            if (p_uart->tx_waiting_brk) {
42007045:	de0262        	l8ui	a6, a2, 222
42007048:	fb9656        	bnez	a6, 42007005 <uart_rx_intr_handler_default+0x25>
            if (p_uart->tx_waiting_fifo == true && p_uart->tx_buf_size == 0) {
4200704b:	c80282        	l8ui	a8, a2, 200
4200704e:	312262        	l32i	a6, a2, 196
42007051:	289c      	beqz.n	a8, 42007067 <uart_rx_intr_handler_default+0x87>
42007053:	36dc      	bnez.n	a6, 4200706a <uart_rx_intr_handler_default+0x8a>
                xSemaphoreGiveFromISR(p_uart->tx_fifo_sem, &HPTaskAwoken);
42007055:	3e22a2        	l32i	a10, a2, 248
                p_uart->tx_waiting_fifo = false;
42007058:	c84262        	s8i	a6, a2, 200
                xSemaphoreGiveFromISR(p_uart->tx_fifo_sem, &HPTaskAwoken);
4200705b:	18c1b2        	addi	a11, a1, 24
                xSemaphoreGiveFromISR(p_uart->tx_brk_sem, &HPTaskAwoken);
4200705e:	e59481        	l32r	a8, 420006b0 <_stext+0x690>
42007061:	0008e0        	callx8	a8
42007064:	001006        	j	420070a8 <uart_rx_intr_handler_default+0xc8>
                if (p_uart->tx_buf_size == 0) {
42007067:	f9a616        	beqz	a6, 42007005 <uart_rx_intr_handler_default+0x25>
    return UART_LL_FIFO_DEF_LEN - hw->status.txfifo_cnt;
4200706a:	0020c0        	memw
4200706d:	7778      	l32i.n	a7, a7, 28
4200706f:	80a062        	movi	a6, 128
42007072:	957070        	extui	a7, a7, 16, 10
42007075:	c06670        	sub	a6, a6, a7
                bool en_tx_flg = false;
42007078:	070c      	movi.n	a7, 0
                while (tx_fifo_rem) {
4200707a:	76fc      	bnez.n	a6, 420070b5 <uart_rx_intr_handler_default+0xd5>
                if (en_tx_flg) {
4200707c:	87ac      	beqz.n	a7, 420070a8 <uart_rx_intr_handler_default+0xc8>
                    uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
4200707e:	0368      	l32i.n	a6, a3, 0
    hw->int_clr.val = mask;
42007080:	270c      	movi.n	a7, 2
42007082:	0020c0        	memw
42007085:	4679      	s32i.n	a7, a6, 16
42007087:	fb7c      	movi.n	a11, -1
42007089:	04ad      	mov.n	a10, a4
4200708b:	e3ed81        	l32r	a8, 42000040 <_stext+0x20>
4200708e:	0008e0        	callx8	a8
                    uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
42007091:	0388      	l32i.n	a8, a3, 0
    hw->int_ena.val |= mask;
42007093:	0020c0        	memw
42007096:	3868      	l32i.n	a6, a8, 12
42007098:	206670        	or	a6, a6, a7
4200709b:	0020c0        	memw
4200709e:	3869      	s32i.n	a6, a8, 12
                    UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
420070a0:	04ad      	mov.n	a10, a4
420070a2:	e3e881        	l32r	a8, 42000044 <_stext+0x24>
420070a5:	0008e0        	callx8	a8
        if (uart_event.type != UART_EVENT_MAX && p_uart->event_queue) {
420070a8:	0178      	l32i.n	a7, a1, 0
420070aa:	960c      	movi.n	a6, 9
420070ac:	029767        	bne	a7, a6, 420070b2 <uart_rx_intr_handler_default+0xd2>
420070af:	ffd486        	j	42007005 <uart_rx_intr_handler_default+0x25>
420070b2:	00c5c6        	j	420073cd <uart_rx_intr_handler_default+0x3ed>
                    if (p_uart->tx_len_tot == 0 || p_uart->tx_ptr == NULL || p_uart->tx_len_cur == 0) {
420070b5:	352282        	l32i	a8, a2, 212
420070b8:	988c      	beqz.n	a8, 420070c5 <uart_rx_intr_handler_default+0xe5>
420070ba:	332282        	l32i	a8, a2, 204
420070bd:	488c      	beqz.n	a8, 420070c5 <uart_rx_intr_handler_default+0xe5>
420070bf:	362282        	l32i	a8, a2, 216
420070c2:	044856        	bnez	a8, 4200710a <uart_rx_intr_handler_default+0x12a>
                        p_uart->tx_head = (uart_tx_data_t *) xRingbufferReceiveFromISR(p_uart->tx_ring_buf, &size);
420070c5:	3b22a2        	l32i	a10, a2, 236
420070c8:	14c1b2        	addi	a11, a1, 20
420070cb:	e5ff81        	l32r	a8, 420008c8 <_stext+0x8a8>
420070ce:	0008e0        	callx8	a8
420070d1:	3462a2        	s32i	a10, a2, 208
                        if (p_uart->tx_head) {
420070d4:	fa4a16        	beqz	a10, 4200707c <uart_rx_intr_handler_default+0x9c>
                            if (p_uart->tx_len_tot == 0) {
420070d7:	352282        	l32i	a8, a2, 212
420070da:	0ce856        	bnez	a8, 420071ac <uart_rx_intr_handler_default+0x1cc>
                                p_uart->tx_ptr = NULL;
420070dd:	336282        	s32i	a8, a2, 204
                                p_uart->tx_len_tot = p_uart->tx_head->tx_data.size;
420070e0:	2a88      	l32i.n	a8, a10, 8
420070e2:	356282        	s32i	a8, a2, 212
                                if (p_uart->tx_head->type == UART_DATA_BREAK) {
420070e5:	0a88      	l32i.n	a8, a10, 0
420070e7:	0b6866        	bnei	a8, 6, 420070f6 <uart_rx_intr_handler_default+0x116>
                                    p_uart->tx_brk_flg = 1;
420070ea:	01a082        	movi	a8, 1
420070ed:	dc4282        	s8i	a8, a2, 220
                                    p_uart->tx_brk_len = p_uart->tx_head->tx_data.brk_len;
420070f0:	012a82        	l32i	a8, a10, 4
420070f3:	dd4282        	s8i	a8, a2, 221
                                vRingbufferReturnItemFromISR(p_uart->tx_ring_buf, p_uart->tx_head, &HPTaskAwoken);
420070f6:	0abd      	mov.n	a11, a10
420070f8:	3b22a2        	l32i	a10, a2, 236
420070fb:	18c1c2        	addi	a12, a1, 24
420070fe:	e5f381        	l32r	a8, 420008cc <_stext+0x8ac>
42007101:	0008e0        	callx8	a8
                    if (p_uart->tx_len_tot > 0 && p_uart->tx_ptr && p_uart->tx_len_cur > 0) {
42007104:	352282        	l32i	a8, a2, 212
42007107:	f6f816        	beqz	a8, 4200707a <uart_rx_intr_handler_default+0x9a>
4200710a:	3322b2        	l32i	a11, a2, 204
4200710d:	f69b16        	beqz	a11, 4200707a <uart_rx_intr_handler_default+0x9a>
42007110:	3622c2        	l32i	a12, a2, 216
42007113:	f63c16        	beqz	a12, 4200707a <uart_rx_intr_handler_default+0x9a>
                        uint32_t send_len = uart_enable_tx_write_fifo(uart_num, (const uint8_t *) p_uart->tx_ptr,
42007116:	63cc60        	minu	a12, a12, a6
42007119:	05ad      	mov.n	a10, a5
4200711b:	ffcc65        	call8	42006de0 <uart_enable_tx_write_fifo>
                        p_uart->tx_ptr += send_len;
4200711e:	332272        	l32i	a7, a2, 204
                        p_uart->tx_len_cur -= send_len;
42007121:	362282        	l32i	a8, a2, 216
                        p_uart->tx_ptr += send_len;
42007124:	77aa      	add.n	a7, a7, a10
42007126:	336272        	s32i	a7, a2, 204
                        p_uart->tx_len_tot -= send_len;
42007129:	352272        	l32i	a7, a2, 212
                        p_uart->tx_len_cur -= send_len;
4200712c:	c088a0        	sub	a8, a8, a10
                        p_uart->tx_len_tot -= send_len;
4200712f:	c077a0        	sub	a7, a7, a10
42007132:	356272        	s32i	a7, a2, 212
                        p_uart->tx_len_cur -= send_len;
42007135:	366282        	s32i	a8, a2, 216
                        tx_fifo_rem -= send_len;
42007138:	c066a0        	sub	a6, a6, a10
                            en_tx_flg = true;
4200713b:	170c      	movi.n	a7, 1
                        if (p_uart->tx_len_cur == 0) {
4200713d:	f39856        	bnez	a8, 4200707a <uart_rx_intr_handler_default+0x9a>
                            vRingbufferReturnItemFromISR(p_uart->tx_ring_buf, p_uart->tx_head, &HPTaskAwoken);
42007140:	3422b2        	l32i	a11, a2, 208
42007143:	3b22a2        	l32i	a10, a2, 236
42007146:	18c1c2        	addi	a12, a1, 24
42007149:	c189      	s32i.n	a8, a1, 48
4200714b:	e5e081        	l32r	a8, 420008cc <_stext+0x8ac>
4200714e:	0008e0        	callx8	a8
                            p_uart->tx_head = NULL;
42007151:	c188      	l32i.n	a8, a1, 48
                            if (p_uart->tx_len_tot == 0 && p_uart->tx_brk_flg == 1) {
42007153:	352292        	l32i	a9, a2, 212
                            p_uart->tx_head = NULL;
42007156:	346282        	s32i	a8, a2, 208
                            p_uart->tx_ptr = NULL;
42007159:	336282        	s32i	a8, a2, 204
                            if (p_uart->tx_len_tot == 0 && p_uart->tx_brk_flg == 1) {
4200715c:	f1a956        	bnez	a9, 4200707a <uart_rx_intr_handler_default+0x9a>
4200715f:	dc02c2        	l8ui	a12, a2, 220
42007162:	021c77        	beq	a12, a7, 42007168 <uart_rx_intr_handler_default+0x188>
42007165:	ffc446        	j	4200707a <uart_rx_intr_handler_default+0x9a>
                                uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
42007168:	0388      	l32i.n	a8, a3, 0
    hw->int_clr.val = mask;
4200716a:	e5d071        	l32r	a7, 420008ac <_stext+0x88c>
4200716d:	fb7c      	movi.n	a11, -1
4200716f:	0020c0        	memw
42007172:	4879      	s32i.n	a7, a8, 16
42007174:	04ad      	mov.n	a10, a4
42007176:	c199      	s32i.n	a9, a1, 48
42007178:	d1c9      	s32i.n	a12, a1, 52
4200717a:	e3b181        	l32r	a8, 42000040 <_stext+0x20>
4200717d:	0008e0        	callx8	a8
                                uart_hal_tx_break(&(uart_context[uart_num].hal), p_uart->tx_brk_len);
42007180:	dd02b2        	l8ui	a11, a2, 221
42007183:	20a330        	or	a10, a3, a3
42007186:	10ac25        	call8	42017c48 <uart_hal_tx_break>
                                uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
42007189:	03a8      	l32i.n	a10, a3, 0
    hw->int_ena.val |= mask;
4200718b:	0020c0        	memw
4200718e:	3a88      	l32i.n	a8, a10, 12
42007190:	207870        	or	a7, a8, a7
42007193:	0020c0        	memw
42007196:	3a79      	s32i.n	a7, a10, 12
                                UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
42007198:	04ad      	mov.n	a10, a4
4200719a:	e3aa81        	l32r	a8, 42000044 <_stext+0x24>
4200719d:	0008e0        	callx8	a8
                                p_uart->tx_waiting_brk = 1;
420071a0:	d1c8      	l32i.n	a12, a1, 52
420071a2:	de42c2        	s8i	a12, a2, 222
                                en_tx_flg = false;
420071a5:	c198      	l32i.n	a9, a1, 48
420071a7:	097d      	mov.n	a7, a9
420071a9:	ffb346        	j	4200707a <uart_rx_intr_handler_default+0x9a>
                            } else if (p_uart->tx_ptr == NULL) {
420071ac:	332282        	l32i	a8, a2, 204
420071af:	f51856        	bnez	a8, 42007104 <uart_rx_intr_handler_default+0x124>
                                p_uart->tx_len_cur = size;
420071b2:	5178      	l32i.n	a7, a1, 20
                                p_uart->tx_ptr = (uint8_t *)p_uart->tx_head;
420071b4:	3362a2        	s32i	a10, a2, 204
                                p_uart->tx_len_cur = size;
420071b7:	366272        	s32i	a7, a2, 216
                                en_tx_flg = true;
420071ba:	170c      	movi.n	a7, 1
420071bc:	ffd106        	j	42007104 <uart_rx_intr_handler_default+0x124>
420071bf:	00          	.byte 00
                   || (uart_intr_status & UART_INTR_CMD_CHAR_DET)
420071c0:	e5bc91        	l32r	a9, 420008b0 <_stext+0x890>
        } else if ((uart_intr_status & UART_INTR_RXFIFO_TOUT)
420071c3:	028797        	bany	a7, a9, 420071c9 <uart_rx_intr_handler_default+0x1e9>
420071c6:	008686        	j	420073e4 <uart_rx_intr_handler_default+0x404>
            if (pat_flg == 1) {
420071c9:	e5bac1        	l32r	a12, 420008b4 <_stext+0x894>
420071cc:	190c      	movi.n	a9, 1
420071ce:	000c62        	l8ui	a6, a12, 0
420071d1:	0199e0        	slli	a9, a9, 18
420071d4:	051666        	bnei	a6, 1, 420071dd <uart_rx_intr_handler_default+0x1fd>
                uart_intr_status |= UART_INTR_CMD_CHAR_DET;
420071d7:	207790        	or	a7, a7, a9
                pat_flg = 0;
420071da:	004ca2        	s8i	a10, a12, 0
            if (p_uart->rx_buffer_full_flg == false) {
420071dd:	1c02a2        	l8ui	a10, a2, 28
                if (uart_intr_status & UART_INTR_CMD_CHAR_DET) {
420071e0:	106790        	and	a6, a7, a9
            if (p_uart->rx_buffer_full_flg == false) {
420071e3:	19ba56        	bnez	a10, 42007382 <uart_rx_intr_handler_default+0x3a2>
                if ((p_uart_obj[uart_num]->rx_always_timeout_flg) && !(uart_intr_status & UART_INTR_RXFIFO_TOUT)) {
420071e6:	e5ac91        	l32r	a9, 42000898 <_stext+0x878>
420071e9:	91a8      	l32i.n	a10, a1, 36
    return hw->status.rxfifo_cnt;
420071eb:	0020c0        	memw
420071ee:	7888      	l32i.n	a8, a8, 28
420071f0:	99aa      	add.n	a9, a9, a10
420071f2:	0998      	l32i.n	a9, a9, 0
420071f4:	948080        	extui	a8, a8, 0, 10
420071f7:	110992        	l8ui	a9, a9, 17
                rx_fifo_len = uart_hal_get_rxfifo_len(&(uart_context[uart_num].hal));
420071fa:	7189      	s32i.n	a8, a1, 28
                if ((p_uart_obj[uart_num]->rx_always_timeout_flg) && !(uart_intr_status & UART_INTR_RXFIFO_TOUT)) {
420071fc:	598c      	beqz.n	a9, 42007205 <uart_rx_intr_handler_default+0x225>
420071fe:	03e787        	bbsi	a7, 8, 42007205 <uart_rx_intr_handler_default+0x225>
                    rx_fifo_len--; // leave one byte in the fifo in order to trigger uart_intr_rxfifo_tout
42007201:	880b      	addi.n	a8, a8, -1
42007203:	7189      	s32i.n	a8, a1, 28
                uart_hal_read_rxfifo(&(uart_context[uart_num].hal), p_uart->rx_data_buf, &rx_fifo_len);
42007205:	2cc282        	addi	a8, a2, 44
42007208:	08bd      	mov.n	a11, a8
4200720a:	03ad      	mov.n	a10, a3
4200720c:	1cc1c2        	addi	a12, a1, 28
4200720f:	a189      	s32i.n	a8, a1, 40
42007211:	10ac25        	call8	42017cd4 <uart_hal_read_rxfifo>
                uart_hal_get_at_cmd_char(&(uart_context[uart_num].hal), &pat_chr, &pat_num);
42007214:	0388      	l32i.n	a8, a3, 0
 *
 * @return None.
 */
FORCE_INLINE_ATTR void uart_ll_get_at_cmd_char(uart_dev_t *hw, uint8_t *cmd_char, uint8_t *char_num)
{
    *cmd_char = HAL_FORCE_READ_U32_REG_FIELD(hw->at_cmd_char, at_cmd_char);
42007216:	0020c0        	memw
42007219:	172892        	l32i	a9, a8, 92
4200721c:	0020c0        	memw
4200721f:	4199      	s32i.n	a9, a1, 16
42007221:	0020c0        	memw
42007224:	41a8      	l32i.n	a10, a1, 16
    *char_num = HAL_FORCE_READ_U32_REG_FIELD(hw->at_cmd_char, char_num);
42007226:	0020c0        	memw
42007229:	172892        	l32i	a9, a8, 92
    *cmd_char = HAL_FORCE_READ_U32_REG_FIELD(hw->at_cmd_char, at_cmd_char);
4200722c:	74a0a0        	extui	a10, a10, 0, 8
    *char_num = HAL_FORCE_READ_U32_REG_FIELD(hw->at_cmd_char, char_num);
4200722f:	0020c0        	memw
42007232:	3199      	s32i.n	a9, a1, 12
42007234:	0020c0        	memw
42007237:	3198      	l32i.n	a9, a1, 12
42007239:	749890        	extui	a9, a9, 8, 8
4200723c:	8199      	s32i.n	a9, a1, 32
                if (uart_intr_status & UART_INTR_CMD_CHAR_DET) {
4200723e:	7198      	l32i.n	a9, a1, 28
42007240:	0bd616        	beqz	a6, 42007301 <uart_rx_intr_handler_default+0x321>
    hw->int_clr.val = mask;
42007243:	e59d71        	l32r	a7, 420008b8 <_stext+0x898>
                    uart_event.size = rx_fifo_len;
42007246:	1199      	s32i.n	a9, a1, 4
42007248:	0020c0        	memw
4200724b:	4879      	s32i.n	a7, a8, 16
                    uart_event.type = UART_PATTERN_DET;
4200724d:	770c      	movi.n	a7, 7
4200724f:	0179      	s32i.n	a7, a1, 0
    int cnt = 0;
42007251:	00a082        	movi	a8, 0
                    pat_idx = uart_find_pattern_from_last(p_uart->rx_data_buf, rx_fifo_len - 1, pat_chr, pat_num);
42007254:	ffc972        	addi	a7, a9, -1
    while (len >= 0) {
42007257:	08d7d6        	bgez	a7, 420072e8 <uart_rx_intr_handler_default+0x308>
                p_uart->rx_stash_len = rx_fifo_len;
4200725a:	71c8      	l32i.n	a12, a1, 28
                if (pdFALSE == xRingbufferSendFromISR(p_uart->rx_ring_buf, p_uart->rx_data_buf, p_uart->rx_stash_len, &HPTaskAwoken)) {
4200725c:	a1b8      	l32i.n	a11, a1, 40
4200725e:	3a22a2        	l32i	a10, a2, 232
                p_uart->rx_stash_len = rx_fifo_len;
42007261:	ac42c2        	s8i	a12, a2, 172
                if (pdFALSE == xRingbufferSendFromISR(p_uart->rx_ring_buf, p_uart->rx_data_buf, p_uart->rx_stash_len, &HPTaskAwoken)) {
42007264:	18c1d2        	addi	a13, a1, 24
42007267:	74c0c0        	extui	a12, a12, 0, 8
4200726a:	e59981        	l32r	a8, 420008d0 <_stext+0x8b0>
4200726d:	0008e0        	callx8	a8
42007270:	0d6a56        	bnez	a10, 4200734a <uart_rx_intr_handler_default+0x36a>
                    p_uart->rx_buffer_full_flg = true;
42007273:	160c      	movi.n	a6, 1
42007275:	1c4262        	s8i	a6, a2, 28
42007278:	fb7c      	movi.n	a11, -1
4200727a:	04ad      	mov.n	a10, a4
4200727c:	e37181        	l32r	a8, 42000040 <_stext+0x20>
4200727f:	0008e0        	callx8	a8
                    uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_RXFIFO_TOUT | UART_INTR_RXFIFO_FULL);
42007282:	0388      	l32i.n	a8, a3, 0
    hw->int_ena.val &= (~mask);
42007284:	feae92        	movi	a9, 0xfffffefe
42007287:	0020c0        	memw
4200728a:	3868      	l32i.n	a6, a8, 12
                    UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
4200728c:	20a440        	or	a10, a4, a4
4200728f:	106690        	and	a6, a6, a9
42007292:	0020c0        	memw
42007295:	036862        	s32i	a6, a8, 12
42007298:	e36b81        	l32r	a8, 42000044 <_stext+0x24>
4200729b:	0008e0        	callx8	a8
                    if (uart_event.type == UART_PATTERN_DET) {
4200729e:	0168      	l32i.n	a6, a1, 0
420072a0:	3c7666        	bnei	a6, 7, 420072e0 <uart_rx_intr_handler_default+0x300>
420072a3:	fb7c      	movi.n	a11, -1
420072a5:	20a440        	or	a10, a4, a4
420072a8:	e36681        	l32r	a8, 42000040 <_stext+0x20>
420072ab:	0008e0        	callx8	a8
                        if (rx_fifo_len < pat_num) {
420072ae:	8198      	l32i.n	a9, a1, 32
420072b0:	7168      	l32i.n	a6, a1, 28
420072b2:	052282        	l32i	a8, a2, 20
420072b5:	022697        	blt	a6, a9, 420072bb <uart_rx_intr_handler_default+0x2db>
420072b8:	002046        	j	4200733d <uart_rx_intr_handler_default+0x35d>
                            uart_pattern_enqueue(uart_num, p_uart->rx_buffered_len - (pat_num - rx_fifo_len));
420072bb:	c06960        	sub	a6, a9, a6
420072be:	c0b860        	sub	a11, a8, a6
                            uart_pattern_enqueue(uart_num,
420072c1:	05ad      	mov.n	a10, a5
420072c3:	ffcf25        	call8	42006fb4 <uart_pattern_enqueue$isra$0>
                        UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
420072c6:	04ad      	mov.n	a10, a4
420072c8:	e35f81        	l32r	a8, 42000044 <_stext+0x24>
420072cb:	0008e0        	callx8	a8
                        if ((p_uart->event_queue != NULL) && (pdFALSE == xQueueSendFromISR(p_uart->event_queue, (void * )&uart_event, &HPTaskAwoken))) {
420072ce:	3922a2        	l32i	a10, a2, 228
420072d1:	ba8c      	beqz.n	a10, 420072e0 <uart_rx_intr_handler_default+0x300>
420072d3:	0d0c      	movi.n	a13, 0
420072d5:	18c1c2        	addi	a12, a1, 24
420072d8:	01bd      	mov.n	a11, a1
420072da:	e57e81        	l32r	a8, 420008d4 <_stext+0x8b4>
420072dd:	0008e0        	callx8	a8
                    uart_event.type = UART_BUFFER_FULL;
420072e0:	260c      	movi.n	a6, 2
            uart_event.type = UART_WAKEUP;
420072e2:	0169      	s32i.n	a6, a1, 0
420072e4:	003946        	j	420073cd <uart_rx_intr_handler_default+0x3ed>
420072e7:	00          	.byte 00
        if (buf[len] == pat_chr) {
420072e8:	927a      	add.n	a9, a2, a7
420072ea:	2c0992        	l8ui	a9, a9, 44
            cnt++;
420072ed:	881b      	addi.n	a8, a8, 1
        if (buf[len] == pat_chr) {
420072ef:	0119a7        	beq	a9, a10, 420072f4 <uart_rx_intr_handler_default+0x314>
            cnt = 0;
420072f2:	080c      	movi.n	a8, 0
        if (cnt >= pat_num) {
420072f4:	8198      	l32i.n	a9, a1, 32
420072f6:	022897        	blt	a8, a9, 420072fc <uart_rx_intr_handler_default+0x31c>
420072f9:	ffd746        	j	4200725a <uart_rx_intr_handler_default+0x27a>
        len --;
420072fc:	770b      	addi.n	a7, a7, -1
420072fe:	ffd546        	j	42007257 <uart_rx_intr_handler_default+0x277>
                    uart_event.timeout_flag = (uart_intr_status & UART_INTR_RXFIFO_TOUT) ? true : false;
42007301:	047870        	extui	a7, a7, 8, 1
42007304:	084172        	s8i	a7, a1, 8
42007307:	e56d71        	l32r	a7, 420008bc <_stext+0x89c>
    hw->int_clr.val = mask;
4200730a:	01a1a2        	movi	a10, 0x101
4200730d:	0020c0        	memw
42007310:	48a9      	s32i.n	a10, a8, 16
42007312:	fb7c      	movi.n	a11, -1
42007314:	07ad      	mov.n	a10, a7
                    uart_event.type = UART_DATA;
42007316:	0169      	s32i.n	a6, a1, 0
                    uart_event.size = rx_fifo_len;
42007318:	016192        	s32i	a9, a1, 4
4200731b:	e34981        	l32r	a8, 42000040 <_stext+0x20>
4200731e:	0008e0        	callx8	a8
                    if (p_uart->uart_select_notif_callback) {
42007321:	382282        	l32i	a8, a2, 224
42007324:	888c      	beqz.n	a8, 42007330 <uart_rx_intr_handler_default+0x350>
                        p_uart->uart_select_notif_callback(uart_num, UART_SELECT_READ_NOTIF, &HPTaskAwoken);
42007326:	18c1c2        	addi	a12, a1, 24
42007329:	06bd      	mov.n	a11, a6
4200732b:	05ad      	mov.n	a10, a5
4200732d:	0008e0        	callx8	a8
                    UART_EXIT_CRITICAL_ISR(&uart_selectlock);
42007330:	07ad      	mov.n	a10, a7
42007332:	e34481        	l32r	a8, 42000044 <_stext+0x24>
42007335:	0008e0        	callx8	a8
                int pat_idx = -1;
42007338:	f77c      	movi.n	a7, -1
4200733a:	ffc706        	j	4200725a <uart_rx_intr_handler_default+0x27a>
                            uart_pattern_enqueue(uart_num,
4200733d:	b78a      	add.n	a11, a7, a8
4200733f:	f7e7d6        	bgez	a7, 420072c1 <uart_rx_intr_handler_default+0x2e1>
                                                 p_uart->rx_buffered_len + p_uart->rx_stash_len :
42007342:	ac02b2        	l8ui	a11, a2, 172
                            uart_pattern_enqueue(uart_num,
42007345:	bb8a      	add.n	a11, a11, a8
42007347:	ffdd86        	j	420072c1 <uart_rx_intr_handler_default+0x2e1>
4200734a:	ffafb2        	movi	a11, -1
4200734d:	20a440        	or	a10, a4, a4
42007350:	e33c81        	l32r	a8, 42000040 <_stext+0x20>
42007353:	0008e0        	callx8	a8
                    if (uart_intr_status & UART_INTR_CMD_CHAR_DET) {
42007356:	013616        	beqz	a6, 4200736d <uart_rx_intr_handler_default+0x38d>
                        if (rx_fifo_len < pat_num) {
42007359:	7168      	l32i.n	a6, a1, 28
4200735b:	8188      	l32i.n	a8, a1, 32
                            uart_pattern_enqueue(uart_num, p_uart->rx_buffered_len - (pat_num - rx_fifo_len));
4200735d:	52b8      	l32i.n	a11, a2, 20
                        if (rx_fifo_len < pat_num) {
4200735f:	16a687        	bge	a6, a8, 42007379 <uart_rx_intr_handler_default+0x399>
                            uart_pattern_enqueue(uart_num, p_uart->rx_buffered_len - (pat_num - rx_fifo_len));
42007362:	c06860        	sub	a6, a8, a6
42007365:	c0bb60        	sub	a11, a11, a6
                            uart_pattern_enqueue(uart_num, p_uart->rx_buffered_len + pat_idx);
42007368:	05ad      	mov.n	a10, a5
4200736a:	ffc4a5        	call8	42006fb4 <uart_pattern_enqueue$isra$0>
                    p_uart->rx_buffered_len += p_uart->rx_stash_len;
4200736d:	5268      	l32i.n	a6, a2, 20
4200736f:	ac0272        	l8ui	a7, a2, 172
42007372:	667a      	add.n	a6, a6, a7
42007374:	5269      	s32i.n	a6, a2, 20
42007376:	ff4986        	j	420070a0 <uart_rx_intr_handler_default+0xc0>
                        } else if (pat_idx >= 0) {
42007379:	ff0796        	bltz	a7, 4200736d <uart_rx_intr_handler_default+0x38d>
                            uart_pattern_enqueue(uart_num, p_uart->rx_buffered_len + pat_idx);
4200737c:	b7ba      	add.n	a11, a7, a11
4200737e:	fff986        	j	42007368 <uart_rx_intr_handler_default+0x388>
42007381:	00          	.byte 00
42007382:	fb7c      	movi.n	a11, -1
42007384:	04ad      	mov.n	a10, a4
42007386:	c199      	s32i.n	a9, a1, 48
42007388:	d1c9      	s32i.n	a12, a1, 52
4200738a:	e32d81        	l32r	a8, 42000040 <_stext+0x20>
4200738d:	0008e0        	callx8	a8
                uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
42007390:	0388      	l32i.n	a8, a3, 0
    hw->int_ena.val &= (~mask);
42007392:	feaea2        	movi	a10, 0xfffffefe
42007395:	0020c0        	memw
42007398:	3878      	l32i.n	a7, a8, 12
4200739a:	1077a0        	and	a7, a7, a10
4200739d:	0020c0        	memw
420073a0:	3879      	s32i.n	a7, a8, 12
                UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
420073a2:	04ad      	mov.n	a10, a4
420073a4:	e32881        	l32r	a8, 42000044 <_stext+0x24>
420073a7:	0008e0        	callx8	a8
                uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
420073aa:	0378      	l32i.n	a7, a3, 0
    hw->int_clr.val = mask;
420073ac:	01a182        	movi	a8, 0x101
420073af:	0020c0        	memw
420073b2:	4789      	s32i.n	a8, a7, 16
                if (uart_intr_status & UART_INTR_CMD_CHAR_DET) {
420073b4:	c198      	l32i.n	a9, a1, 48
420073b6:	d1c8      	l32i.n	a12, a1, 52
420073b8:	cec616        	beqz	a6, 420070a8 <uart_rx_intr_handler_default+0xc8>
                    uart_event.type = UART_PATTERN_DET;
420073bb:	760c      	movi.n	a6, 7
420073bd:	0169      	s32i.n	a6, a1, 0
                    uart_event.size = rx_fifo_len;
420073bf:	7168      	l32i.n	a6, a1, 28
420073c1:	0020c0        	memw
420073c4:	4799      	s32i.n	a9, a7, 16
420073c6:	1169      	s32i.n	a6, a1, 4
                    pat_flg = 1;
420073c8:	160c      	movi.n	a6, 1
420073ca:	004c62        	s8i	a6, a12, 0
        if (uart_event.type != UART_EVENT_MAX && p_uart->event_queue) {
420073cd:	3922a2        	l32i	a10, a2, 228
420073d0:	c31a16        	beqz	a10, 42007005 <uart_rx_intr_handler_default+0x25>
            if (pdFALSE == xQueueSendFromISR(p_uart->event_queue, (void * )&uart_event, &HPTaskAwoken)) {
420073d3:	0d0c      	movi.n	a13, 0
420073d5:	18c1c2        	addi	a12, a1, 24
420073d8:	01bd      	mov.n	a11, a1
420073da:	e53e81        	l32r	a8, 420008d4 <_stext+0x8b4>
420073dd:	0008e0        	callx8	a8
420073e0:	ff0846        	j	42007005 <uart_rx_intr_handler_default+0x25>
420073e3:	00          	.byte 00
        } else if (uart_intr_status & UART_INTR_RXFIFO_OVF) {
420073e4:	4a6747        	bbci	a7, 4, 42007432 <uart_rx_intr_handler_default+0x452>
420073e7:	fb7c      	movi.n	a11, -1
420073e9:	04ad      	mov.n	a10, a4
420073eb:	e31581        	l32r	a8, 42000040 <_stext+0x20>
420073ee:	0008e0        	callx8	a8
            uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
420073f1:	03ad      	mov.n	a10, a3
420073f3:	fac3e5        	call8	42002030 <uart_hal_rxfifo_rst>
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
420073f6:	04ad      	mov.n	a10, a4
420073f8:	e31381        	l32r	a8, 42000044 <_stext+0x24>
420073fb:	0008e0        	callx8	a8
420073fe:	e52f71        	l32r	a7, 420008bc <_stext+0x89c>
42007401:	fb7c      	movi.n	a11, -1
42007403:	20a770        	or	a10, a7, a7
42007406:	e30e81        	l32r	a8, 42000040 <_stext+0x20>
42007409:	0008e0        	callx8	a8
            if (p_uart->uart_select_notif_callback) {
4200740c:	382282        	l32i	a8, a2, 224
4200740f:	988c      	beqz.n	a8, 4200741c <uart_rx_intr_handler_default+0x43c>
                p_uart->uart_select_notif_callback(uart_num, UART_SELECT_ERROR_NOTIF, &HPTaskAwoken);
42007411:	18c1c2        	addi	a12, a1, 24
42007414:	06bd      	mov.n	a11, a6
42007416:	20a550        	or	a10, a5, a5
42007419:	0008e0        	callx8	a8
            UART_EXIT_CRITICAL_ISR(&uart_selectlock);
4200741c:	07ad      	mov.n	a10, a7
4200741e:	e30981        	l32r	a8, 42000044 <_stext+0x24>
42007421:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_RXFIFO_OVF);
42007424:	0368      	l32i.n	a6, a3, 0
42007426:	071c      	movi.n	a7, 16
42007428:	0020c0        	memw
4200742b:	4679      	s32i.n	a7, a6, 16
            uart_event.type = UART_FIFO_OVF;
4200742d:	360c      	movi.n	a6, 3
4200742f:	ffabc6        	j	420072e2 <uart_rx_intr_handler_default+0x302>
        } else if (uart_intr_status & UART_INTR_BRK_DET) {
42007432:	80a092        	movi	a9, 128
42007435:	0c0797        	bnone	a7, a9, 42007445 <uart_rx_intr_handler_default+0x465>
42007438:	0020c0        	memw
4200743b:	4899      	s32i.n	a9, a8, 16
            uart_event.type = UART_BREAK;
4200743d:	160c      	movi.n	a6, 1
4200743f:	ffa7c6        	j	420072e2 <uart_rx_intr_handler_default+0x302>
42007442:	00          	.byte 00
42007443:	00          	.byte 00
42007444:	00          	.byte 00
        } else if (uart_intr_status & UART_INTR_FRAM_ERR) {
42007445:	316737        	bbci	a7, 3, 4200747a <uart_rx_intr_handler_default+0x49a>
42007448:	e51d71        	l32r	a7, 420008bc <_stext+0x89c>
4200744b:	fb7c      	movi.n	a11, -1
4200744d:	07ad      	mov.n	a10, a7
4200744f:	e2fc81        	l32r	a8, 42000040 <_stext+0x20>
42007452:	0008e0        	callx8	a8
            if (p_uart->uart_select_notif_callback) {
42007455:	382282        	l32i	a8, a2, 224
42007458:	888c      	beqz.n	a8, 42007464 <uart_rx_intr_handler_default+0x484>
                p_uart->uart_select_notif_callback(uart_num, UART_SELECT_ERROR_NOTIF, &HPTaskAwoken);
4200745a:	18c1c2        	addi	a12, a1, 24
4200745d:	06bd      	mov.n	a11, a6
4200745f:	05ad      	mov.n	a10, a5
42007461:	0008e0        	callx8	a8
            UART_EXIT_CRITICAL_ISR(&uart_selectlock);
42007464:	07ad      	mov.n	a10, a7
42007466:	e2f781        	l32r	a8, 42000044 <_stext+0x24>
42007469:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_FRAM_ERR);
4200746c:	0368      	l32i.n	a6, a3, 0
4200746e:	870c      	movi.n	a7, 8
42007470:	0020c0        	memw
42007473:	4679      	s32i.n	a7, a6, 16
            uart_event.type = UART_FRAME_ERR;
42007475:	460c      	movi.n	a6, 4
42007477:	ff99c6        	j	420072e2 <uart_rx_intr_handler_default+0x302>
        } else if (uart_intr_status & UART_INTR_PARITY_ERR) {
4200747a:	4c0c      	movi.n	a12, 4
4200747c:	10c7c0        	and	a12, a7, a12
4200747f:	3cbc      	beqz.n	a12, 420074b6 <uart_rx_intr_handler_default+0x4d6>
42007481:	e50e71        	l32r	a7, 420008bc <_stext+0x89c>
42007484:	ffafb2        	movi	a11, -1
42007487:	20a770        	or	a10, a7, a7
4200748a:	e2ed81        	l32r	a8, 42000040 <_stext+0x20>
4200748d:	0008e0        	callx8	a8
            if (p_uart->uart_select_notif_callback) {
42007490:	382282        	l32i	a8, a2, 224
42007493:	988c      	beqz.n	a8, 420074a0 <uart_rx_intr_handler_default+0x4c0>
                p_uart->uart_select_notif_callback(uart_num, UART_SELECT_ERROR_NOTIF, &HPTaskAwoken);
42007495:	18c1c2        	addi	a12, a1, 24
42007498:	06bd      	mov.n	a11, a6
4200749a:	20a550        	or	a10, a5, a5
4200749d:	0008e0        	callx8	a8
            UART_EXIT_CRITICAL_ISR(&uart_selectlock);
420074a0:	07ad      	mov.n	a10, a7
420074a2:	e2e881        	l32r	a8, 42000044 <_stext+0x24>
420074a5:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_PARITY_ERR);
420074a8:	0368      	l32i.n	a6, a3, 0
420074aa:	470c      	movi.n	a7, 4
420074ac:	0020c0        	memw
420074af:	4679      	s32i.n	a7, a6, 16
            uart_event.type = UART_PARITY_ERR;
420074b1:	560c      	movi.n	a6, 5
420074b3:	ff8ac6        	j	420072e2 <uart_rx_intr_handler_default+0x302>
        } else if (uart_intr_status & UART_INTR_TX_BRK_DONE) {
420074b6:	190c      	movi.n	a9, 1
420074b8:	6567c7        	bbci	a7, 12, 42007521 <uart_rx_intr_handler_default+0x541>
420074bb:	fb7c      	movi.n	a11, -1
420074bd:	04ad      	mov.n	a10, a4
420074bf:	d1c9      	s32i.n	a12, a1, 52
420074c1:	e2df81        	l32r	a8, 42000040 <_stext+0x20>
420074c4:	0008e0        	callx8	a8
            uart_hal_tx_break(&(uart_context[uart_num].hal), 0);
420074c7:	d1c8      	l32i.n	a12, a1, 52
420074c9:	03ad      	mov.n	a10, a3
420074cb:	0cbd      	mov.n	a11, a12
420074cd:	1077a5        	call8	42017c48 <uart_hal_tx_break>
            uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
420074d0:	0378      	l32i.n	a7, a3, 0
    hw->int_ena.val &= (~mask);
420074d2:	e4fb91        	l32r	a9, 420008c0 <_stext+0x8a0>
420074d5:	0020c0        	memw
420074d8:	3788      	l32i.n	a8, a7, 12
420074da:	108890        	and	a8, a8, a9
420074dd:	0020c0        	memw
420074e0:	3789      	s32i.n	a8, a7, 12
            if (p_uart->tx_brk_flg == 1) {
420074e2:	dc0282        	l8ui	a8, a2, 220
420074e5:	0c1866        	bnei	a8, 1, 420074f5 <uart_rx_intr_handler_default+0x515>
    hw->int_ena.val |= mask;
420074e8:	0020c0        	memw
420074eb:	3788      	l32i.n	a8, a7, 12
420074ed:	206860        	or	a6, a8, a6
420074f0:	0020c0        	memw
420074f3:	3769      	s32i.n	a6, a7, 12
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
420074f5:	04ad      	mov.n	a10, a4
420074f7:	e2d381        	l32r	a8, 42000044 <_stext+0x24>
420074fa:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
420074fd:	0368      	l32i.n	a6, a3, 0
    hw->int_clr.val = mask;
420074ff:	e4eb71        	l32r	a7, 420008ac <_stext+0x88c>
42007502:	0020c0        	memw
42007505:	4679      	s32i.n	a7, a6, 16
            if (p_uart->tx_brk_flg == 1) {
42007507:	dc0262        	l8ui	a6, a2, 220
4200750a:	0a1666        	bnei	a6, 1, 42007518 <uart_rx_intr_handler_default+0x538>
                p_uart->tx_brk_flg = 0;
4200750d:	060c      	movi.n	a6, 0
4200750f:	dc4262        	s8i	a6, a2, 220
                p_uart->tx_waiting_brk = 0;
42007512:	de4262        	s8i	a6, a2, 222
42007515:	fee3c6        	j	420070a8 <uart_rx_intr_handler_default+0xc8>
                xSemaphoreGiveFromISR(p_uart->tx_brk_sem, &HPTaskAwoken);
42007518:	4022a2        	l32i	a10, a2, 0x100
4200751b:	18c1b2        	addi	a11, a1, 24
4200751e:	fecf06        	j	4200705e <uart_rx_intr_handler_default+0x7e>
        } else if (uart_intr_status & UART_INTR_TX_BRK_IDLE) {
42007521:	11c930        	slli	a12, a9, 13
42007524:	3407c7        	bnone	a7, a12, 4200755c <uart_rx_intr_handler_default+0x57c>
42007527:	fb7c      	movi.n	a11, -1
42007529:	20a440        	or	a10, a4, a4
4200752c:	d1c9      	s32i.n	a12, a1, 52
4200752e:	e2c481        	l32r	a8, 42000040 <_stext+0x20>
42007531:	0008e0        	callx8	a8
            uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_IDLE);
42007534:	0378      	l32i.n	a7, a3, 0
    hw->int_ena.val &= (~mask);
42007536:	e4e381        	l32r	a8, 420008c4 <_stext+0x8a4>
42007539:	0020c0        	memw
4200753c:	3768      	l32i.n	a6, a7, 12
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
4200753e:	04ad      	mov.n	a10, a4
42007540:	106680        	and	a6, a6, a8
42007543:	0020c0        	memw
42007546:	3769      	s32i.n	a6, a7, 12
42007548:	e2bf81        	l32r	a8, 42000044 <_stext+0x24>
4200754b:	0008e0        	callx8	a8
    hw->int_clr.val = mask;
4200754e:	d1c8      	l32i.n	a12, a1, 52
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_IDLE);
42007550:	0368      	l32i.n	a6, a3, 0
42007552:	0020c0        	memw
42007555:	46c9      	s32i.n	a12, a6, 16
}
42007557:	fed346        	j	420070a8 <uart_rx_intr_handler_default+0xc8>
4200755a:	00          	.byte 00
4200755b:	00          	.byte 00
        } else if (uart_intr_status & UART_INTR_CMD_CHAR_DET) {
4200755c:	0199e0        	slli	a9, a9, 18
4200755f:	760c      	movi.n	a6, 7
42007561:	070797        	bnone	a7, a9, 4200756c <uart_rx_intr_handler_default+0x58c>
    hw->int_clr.val = mask;
42007564:	0020c0        	memw
42007567:	4899      	s32i.n	a9, a8, 16
            uart_event.type = UART_PATTERN_DET;
42007569:	ff5d46        	j	420072e2 <uart_rx_intr_handler_default+0x302>
                   || (uart_intr_status & UART_INTR_RS485_CLASH)) {
4200756c:	116610        	slli	a6, a6, 15
        } else if ((uart_intr_status & UART_INTR_RS485_PARITY_ERR)
4200756f:	350767        	bnone	a7, a6, 420075a8 <uart_rx_intr_handler_default+0x5c8>
42007572:	ffafb2        	movi	a11, -1
42007575:	20a440        	or	a10, a4, a4
42007578:	e2b281        	l32r	a8, 42000040 <_stext+0x20>
4200757b:	0008e0        	callx8	a8
            uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
4200757e:	20a330        	or	a10, a3, a3
42007581:	faaae5        	call8	42002030 <uart_hal_rxfifo_rst>
            p_uart_obj[uart_num]->coll_det_flg = true;
42007584:	9198      	l32i.n	a9, a1, 36
42007586:	e4c471        	l32r	a7, 42000898 <_stext+0x878>
42007589:	180c      	movi.n	a8, 1
4200758b:	779a      	add.n	a7, a7, a9
4200758d:	0778      	l32i.n	a7, a7, 0
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
4200758f:	04ad      	mov.n	a10, a4
            p_uart_obj[uart_num]->coll_det_flg = true;
42007591:	104782        	s8i	a8, a7, 16
            UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
42007594:	e2ac81        	l32r	a8, 42000044 <_stext+0x24>
42007597:	0008e0        	callx8	a8
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_RS485_CLASH | UART_INTR_RS485_FRM_ERR | UART_INTR_RS485_PARITY_ERR);
4200759a:	0378      	l32i.n	a7, a3, 0
4200759c:	0020c0        	memw
4200759f:	4769      	s32i.n	a6, a7, 16
            uart_event.type = UART_EVENT_MAX;
420075a1:	960c      	movi.n	a6, 9
420075a3:	0169      	s32i.n	a6, a1, 0
420075a5:	fe9706        	j	42007005 <uart_rx_intr_handler_default+0x25>
        } else if (uart_intr_status & UART_INTR_TX_DONE) {
420075a8:	02e7e7        	bbsi	a7, 14, 420075ae <uart_rx_intr_handler_default+0x5ce>
420075ab:	0020c6        	j	42007632 <uart_rx_intr_handler_default+0x652>
            if (UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX) && uart_hal_is_tx_idle(&(uart_context[uart_num].hal)) != true) {
420075ae:	b198      	l32i.n	a9, a1, 44
420075b0:	0968      	l32i.n	a6, a9, 0
420075b2:	3668      	l32i.n	a6, a6, 12
420075b4:	171666        	bnei	a6, 1, 420075cf <uart_rx_intr_handler_default+0x5ef>
 *
 * @return True if the state machine is in the IDLE state, otherwise false is returned.
 */
FORCE_INLINE_ATTR bool uart_ll_is_tx_idle(uart_dev_t *hw)
{
    return ((hw->status.txfifo_cnt == 0) && (hw->fsm_status.st_utx_out == 0));
420075b7:	0020c0        	memw
420075ba:	072862        	l32i	a6, a8, 28
420075bd:	956060        	extui	a6, a6, 16, 10
420075c0:	a41656        	bnez	a6, 42007005 <uart_rx_intr_handler_default+0x25>
420075c3:	0020c0        	memw
420075c6:	1b2862        	l32i	a6, a8, 108
420075c9:	346460        	extui	a6, a6, 4, 4
420075cc:	a35656        	bnez	a6, 42007005 <uart_rx_intr_handler_default+0x25>
    hw->int_clr.val = mask;
420075cf:	e4b361        	l32r	a6, 4200089c <_stext+0x87c>
420075d2:	fb7c      	movi.n	a11, -1
420075d4:	0020c0        	memw
420075d7:	4869      	s32i.n	a6, a8, 16
420075d9:	04ad      	mov.n	a10, a4
420075db:	e29981        	l32r	a8, 42000040 <_stext+0x20>
420075de:	0008e0        	callx8	a8
                uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_DONE);
420075e1:	0378      	l32i.n	a7, a3, 0
    hw->int_ena.val &= (~mask);
420075e3:	e34f81        	l32r	a8, 42000320 <_stext+0x300>
420075e6:	0020c0        	memw
420075e9:	3768      	l32i.n	a6, a7, 12
                if (UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX)) {
420075eb:	e4aba1        	l32r	a10, 42000898 <_stext+0x878>
420075ee:	106680        	and	a6, a6, a8
420075f1:	9188      	l32i.n	a8, a1, 36
420075f3:	0020c0        	memw
420075f6:	3769      	s32i.n	a6, a7, 12
420075f8:	6a8a      	add.n	a6, a10, a8
420075fa:	0668      	l32i.n	a6, a6, 0
420075fc:	3668      	l32i.n	a6, a6, 12
420075fe:	161666        	bnei	a6, 1, 42007618 <uart_rx_intr_handler_default+0x638>
                    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
42007601:	03ad      	mov.n	a10, a3
42007603:	faa2e5        	call8	42002030 <uart_hal_rxfifo_rst>
                    uart_hal_set_rts(&(uart_context[uart_num].hal), 1);
42007606:	0378      	l32i.n	a7, a3, 0
    hw->conf0.sw_rts = level & 0x1;
42007608:	084c      	movi.n	a8, 64
4200760a:	0020c0        	memw
4200760d:	8768      	l32i.n	a6, a7, 32
4200760f:	206680        	or	a6, a6, a8
42007612:	0020c0        	memw
42007615:	086762        	s32i	a6, a7, 32
                UART_EXIT_CRITICAL_ISR(&(uart_context[uart_num].spinlock));
42007618:	04ad      	mov.n	a10, a4
4200761a:	e28a81        	l32r	a8, 42000044 <_stext+0x24>
4200761d:	0008e0        	callx8	a8
                xSemaphoreGiveFromISR(p_uart_obj[uart_num]->tx_done_sem, &HPTaskAwoken);
42007620:	e49e91        	l32r	a9, 42000898 <_stext+0x878>
42007623:	9188      	l32i.n	a8, a1, 36
42007625:	18c1b2        	addi	a11, a1, 24
42007628:	698a      	add.n	a6, a9, a8
4200762a:	0668      	l32i.n	a6, a6, 0
4200762c:	3f26a2        	l32i	a10, a6, 252
4200762f:	fe8ac6        	j	4200705e <uart_rx_intr_handler_default+0x7e>
        else if (uart_intr_status & UART_INTR_WAKEUP) {
42007632:	160c      	movi.n	a6, 1
42007634:	0166d0        	slli	a6, a6, 19
42007637:	090767        	bnone	a7, a6, 42007644 <uart_rx_intr_handler_default+0x664>
    hw->int_clr.val = mask;
4200763a:	0020c0        	memw
4200763d:	4869      	s32i.n	a6, a8, 16
            uart_event.type = UART_WAKEUP;
4200763f:	860c      	movi.n	a6, 8
42007641:	ff2746        	j	420072e2 <uart_rx_intr_handler_default+0x302>
42007644:	0020c0        	memw
42007647:	4879      	s32i.n	a7, a8, 16
            uart_event.type = UART_EVENT_MAX;
42007649:	fe6e06        	j	42007005 <uart_rx_intr_handler_default+0x25>
    if (HPTaskAwoken == pdTRUE) {
4200764c:	6128      	l32i.n	a2, a1, 24
4200764e:	051266        	bnei	a2, 1, 42007657 <uart_rx_intr_handler_default+0x677>
        portYIELD_FROM_ISR();
42007651:	e4a181        	l32r	a8, 420008d8 <_stext+0x8b8>
42007654:	0008e0        	callx8	a8
}
42007657:	f01d      	retw.n
42007659:	000000        	ill

4200765c <uart_get_sclk_freq>:
{
4200765c:	004136        	entry	a1, 32
4200765f:	028d      	mov.n	a8, a2
    switch (sclk) {
42007661:	920c      	movi.n	a2, 9
42007663:	221827        	beq	a8, a2, 42007689 <uart_get_sclk_freq+0x2d>
42007666:	0ba022        	movi	a2, 11
42007669:	131827        	beq	a8, a2, 42007680 <uart_get_sclk_freq+0x24>
4200766c:	02a122        	movi	a2, 0x102
4200766f:	094866        	bnei	a8, 4, 4200767c <uart_get_sclk_freq+0x20>
        freq = esp_clk_apb_freq();
42007672:	e49b81        	l32r	a8, 420008e0 <_stext+0x8c0>
42007675:	0008e0        	callx8	a8
    *out_freq_hz = freq;
42007678:	03a9      	s32i.n	a10, a3, 0
    return ESP_OK;
4200767a:	020c      	movi.n	a2, 0
}
4200767c:	f01d      	retw.n
4200767e:	00          	.byte 00
4200767f:	00          	.byte 00
        freq = esp_clk_xtal_freq();
42007680:	e49981        	l32r	a8, 420008e4 <_stext+0x8c4>
42007683:	0008e0        	callx8	a8
        break;
42007686:	fffb86        	j	42007678 <uart_get_sclk_freq+0x1c>
    switch (sclk) {
42007689:	e494a1        	l32r	a10, 420008dc <_stext+0x8bc>
4200768c:	fffa06        	j	42007678 <uart_get_sclk_freq+0x1c>
	...

42007690 <uart_set_word_length>:
{
42007690:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((data_bit < UART_DATA_BITS_MAX), ESP_FAIL, UART_TAG, "data bit error");
42007693:	2943f6        	bgeui	a3, 4, 420076c0 <uart_set_word_length+0x30>
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007696:	2632e6        	bgei	a2, 3, 420076c0 <uart_set_word_length+0x30>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007699:	e47d51        	l32r	a5, 42000890 <_stext+0x870>
4200769c:	1122c0        	slli	a2, a2, 4
4200769f:	424b      	addi.n	a4, a2, 4
420076a1:	445a      	add.n	a4, a4, a5
420076a3:	fb7c      	movi.n	a11, -1
420076a5:	04ad      	mov.n	a10, a4
420076a7:	e26681        	l32r	a8, 42000040 <_stext+0x20>
420076aa:	0008e0        	callx8	a8
    uart_hal_set_data_bit_num(&(uart_context[uart_num].hal), data_bit);
420076ad:	a52a      	add.n	a10, a5, a2
420076af:	03bd      	mov.n	a11, a3
420076b1:	10a2e5        	call8	420180e0 <uart_hal_set_data_bit_num>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420076b4:	04ad      	mov.n	a10, a4
420076b6:	e26381        	l32r	a8, 42000044 <_stext+0x24>
420076b9:	0008e0        	callx8	a8
    return ESP_OK;
420076bc:	020c      	movi.n	a2, 0
}
420076be:	f01d      	retw.n
    ESP_RETURN_ON_FALSE((data_bit < UART_DATA_BITS_MAX), ESP_FAIL, UART_TAG, "data bit error");
420076c0:	f27c      	movi.n	a2, -1
420076c2:	fffe06        	j	420076be <uart_set_word_length+0x2e>
420076c5:	000000        	ill

420076c8 <uart_get_word_length>:
{
420076c8:	004136        	entry	a1, 32
420076cb:	20a220        	or	a10, a2, a2
420076ce:	20b330        	or	a11, a3, a3
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420076d1:	ffaf22        	movi	a2, -1
420076d4:	0c3ae6        	bgei	a10, 3, 420076e4 <uart_get_word_length+0x1c>
    uart_hal_get_data_bit_num(&(uart_context[uart_num].hal), data_bit);
420076d7:	e46e21        	l32r	a2, 42000890 <_stext+0x870>
420076da:	11aac0        	slli	a10, a10, 4
420076dd:	a2aa      	add.n	a10, a2, a10
420076df:	10a225        	call8	42018100 <uart_hal_get_data_bit_num>
    return ESP_OK;
420076e2:	020c      	movi.n	a2, 0
}
420076e4:	f01d      	retw.n
	...

420076e8 <uart_set_stop_bits>:
{
420076e8:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((stop_bit < UART_STOP_BITS_MAX), ESP_FAIL, UART_TAG, "stop bit error");
420076eb:	2943f6        	bgeui	a3, 4, 42007718 <uart_set_stop_bits+0x30>
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420076ee:	2632e6        	bgei	a2, 3, 42007718 <uart_set_stop_bits+0x30>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
420076f1:	e46751        	l32r	a5, 42000890 <_stext+0x870>
420076f4:	1122c0        	slli	a2, a2, 4
420076f7:	424b      	addi.n	a4, a2, 4
420076f9:	445a      	add.n	a4, a4, a5
420076fb:	fb7c      	movi.n	a11, -1
420076fd:	04ad      	mov.n	a10, a4
420076ff:	e25081        	l32r	a8, 42000040 <_stext+0x20>
42007702:	0008e0        	callx8	a8
    uart_hal_set_stop_bits(&(uart_context[uart_num].hal), stop_bit);
42007705:	a52a      	add.n	a10, a5, a2
42007707:	03bd      	mov.n	a11, a3
42007709:	109a25        	call8	420180ac <uart_hal_set_stop_bits>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
4200770c:	04ad      	mov.n	a10, a4
4200770e:	e24d81        	l32r	a8, 42000044 <_stext+0x24>
42007711:	0008e0        	callx8	a8
    return ESP_OK;
42007714:	020c      	movi.n	a2, 0
}
42007716:	f01d      	retw.n
    ESP_RETURN_ON_FALSE((stop_bit < UART_STOP_BITS_MAX), ESP_FAIL, UART_TAG, "stop bit error");
42007718:	f27c      	movi.n	a2, -1
4200771a:	fffe06        	j	42007716 <uart_set_stop_bits+0x2e>
4200771d:	000000        	ill

42007720 <uart_get_stop_bits>:
{
42007720:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007723:	ffaf42        	movi	a4, -1
42007726:	2632e6        	bgei	a2, 3, 42007750 <uart_get_stop_bits+0x30>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007729:	e45951        	l32r	a5, 42000890 <_stext+0x870>
4200772c:	1122c0        	slli	a2, a2, 4
4200772f:	04c242        	addi	a4, a2, 4
42007732:	804450        	add	a4, a4, a5
42007735:	fb7c      	movi.n	a11, -1
42007737:	04ad      	mov.n	a10, a4
42007739:	e24181        	l32r	a8, 42000040 <_stext+0x20>
4200773c:	0008e0        	callx8	a8
    uart_hal_get_stop_bits(&(uart_context[uart_num].hal), stop_bit);
4200773f:	03bd      	mov.n	a11, a3
42007741:	a52a      	add.n	a10, a5, a2
42007743:	1098a5        	call8	420180cc <uart_hal_get_stop_bits>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007746:	04ad      	mov.n	a10, a4
42007748:	e23f81        	l32r	a8, 42000044 <_stext+0x24>
4200774b:	0008e0        	callx8	a8
    return ESP_OK;
4200774e:	040c      	movi.n	a4, 0
}
42007750:	042d      	mov.n	a2, a4
42007752:	f01d      	retw.n

42007754 <uart_set_parity>:
{
42007754:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007757:	ffaf42        	movi	a4, -1
4200775a:	2632e6        	bgei	a2, 3, 42007784 <uart_set_parity+0x30>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
4200775d:	e44c51        	l32r	a5, 42000890 <_stext+0x870>
42007760:	1122c0        	slli	a2, a2, 4
42007763:	04c242        	addi	a4, a2, 4
42007766:	804450        	add	a4, a4, a5
42007769:	fb7c      	movi.n	a11, -1
4200776b:	04ad      	mov.n	a10, a4
4200776d:	e23481        	l32r	a8, 42000040 <_stext+0x20>
42007770:	0008e0        	callx8	a8
    uart_hal_set_parity(&(uart_context[uart_num].hal), parity_mode);
42007773:	03bd      	mov.n	a11, a3
42007775:	a52a      	add.n	a10, a5, a2
42007777:	1099e5        	call8	42018114 <uart_hal_set_parity>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
4200777a:	04ad      	mov.n	a10, a4
4200777c:	e23281        	l32r	a8, 42000044 <_stext+0x24>
4200777f:	0008e0        	callx8	a8
    return ESP_OK;
42007782:	040c      	movi.n	a4, 0
}
42007784:	042d      	mov.n	a2, a4
42007786:	f01d      	retw.n

42007788 <uart_get_parity>:
{
42007788:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
4200778b:	ffaf42        	movi	a4, -1
4200778e:	2632e6        	bgei	a2, 3, 420077b8 <uart_get_parity+0x30>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007791:	e43f51        	l32r	a5, 42000890 <_stext+0x870>
42007794:	1122c0        	slli	a2, a2, 4
42007797:	04c242        	addi	a4, a2, 4
4200779a:	804450        	add	a4, a4, a5
4200779d:	fb7c      	movi.n	a11, -1
4200779f:	04ad      	mov.n	a10, a4
420077a1:	e22781        	l32r	a8, 42000040 <_stext+0x20>
420077a4:	0008e0        	callx8	a8
    uart_hal_get_parity(&(uart_context[uart_num].hal), parity_mode);
420077a7:	03bd      	mov.n	a11, a3
420077a9:	a52a      	add.n	a10, a5, a2
420077ab:	109a25        	call8	4201814c <uart_hal_get_parity>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420077ae:	04ad      	mov.n	a10, a4
420077b0:	e22581        	l32r	a8, 42000044 <_stext+0x24>
420077b3:	0008e0        	callx8	a8
    return ESP_OK;
420077b6:	040c      	movi.n	a4, 0
}
420077b8:	042d      	mov.n	a2, a4
420077ba:	f01d      	retw.n

420077bc <uart_set_baudrate>:
{
420077bc:	006136        	entry	a1, 48
420077bf:	204220        	or	a4, a2, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420077c2:	f27c      	movi.n	a2, -1
420077c4:	3834e6        	bgei	a4, 3, 42007800 <uart_set_baudrate+0x44>
    uart_hal_get_sclk(&(uart_context[uart_num].hal), &src_clk);
420077c7:	e43261        	l32r	a6, 42000890 <_stext+0x870>
420077ca:	1144c0        	slli	a4, a4, 4
420077cd:	546a      	add.n	a5, a4, a6
420077cf:	b14b      	addi.n	a11, a1, 4
420077d1:	05ad      	mov.n	a10, a5
420077d3:	1087e5        	call8	42018050 <uart_hal_get_sclk>
    ESP_RETURN_ON_ERROR(uart_get_sclk_freq(src_clk, &sclk_freq), UART_TAG, "Invalid src_clk");
420077d6:	11a8      	l32i.n	a10, a1, 4
420077d8:	01bd      	mov.n	a11, a1
420077da:	ffe825        	call8	4200765c <uart_get_sclk_freq>
420077dd:	0a2d      	mov.n	a2, a10
420077df:	dadc      	bnez.n	a10, 42007800 <uart_set_baudrate+0x44>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
420077e1:	444b      	addi.n	a4, a4, 4
420077e3:	446a      	add.n	a4, a4, a6
420077e5:	fb7c      	movi.n	a11, -1
420077e7:	04ad      	mov.n	a10, a4
420077e9:	e21581        	l32r	a8, 42000040 <_stext+0x20>
420077ec:	0008e0        	callx8	a8
    uart_hal_set_baudrate(&(uart_context[uart_num].hal), baud_rate, sclk_freq);
420077ef:	01c8      	l32i.n	a12, a1, 0
420077f1:	05ad      	mov.n	a10, a5
420077f3:	03bd      	mov.n	a11, a3
420077f5:	0170e5        	call8	42008f04 <uart_hal_set_baudrate>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420077f8:	04ad      	mov.n	a10, a4
420077fa:	e21281        	l32r	a8, 42000044 <_stext+0x24>
420077fd:	0008e0        	callx8	a8
}
42007800:	f01d      	retw.n
	...

42007804 <uart_get_baudrate>:
{
42007804:	006136        	entry	a1, 48
42007807:	204220        	or	a4, a2, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
4200780a:	f27c      	movi.n	a2, -1
4200780c:	3834e6        	bgei	a4, 3, 42007848 <uart_get_baudrate+0x44>
    uart_hal_get_sclk(&(uart_context[uart_num].hal), &src_clk);
4200780f:	e42061        	l32r	a6, 42000890 <_stext+0x870>
42007812:	1144c0        	slli	a4, a4, 4
42007815:	546a      	add.n	a5, a4, a6
42007817:	b14b      	addi.n	a11, a1, 4
42007819:	05ad      	mov.n	a10, a5
4200781b:	108365        	call8	42018050 <uart_hal_get_sclk>
    ESP_RETURN_ON_ERROR(uart_get_sclk_freq(src_clk, &sclk_freq), UART_TAG, "Invalid src_clk");
4200781e:	11a8      	l32i.n	a10, a1, 4
42007820:	01bd      	mov.n	a11, a1
42007822:	ffe3a5        	call8	4200765c <uart_get_sclk_freq>
42007825:	0a2d      	mov.n	a2, a10
42007827:	dadc      	bnez.n	a10, 42007848 <uart_get_baudrate+0x44>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007829:	444b      	addi.n	a4, a4, 4
4200782b:	446a      	add.n	a4, a4, a6
4200782d:	fb7c      	movi.n	a11, -1
4200782f:	04ad      	mov.n	a10, a4
42007831:	e20381        	l32r	a8, 42000040 <_stext+0x20>
42007834:	0008e0        	callx8	a8
    uart_hal_get_baudrate(&(uart_context[uart_num].hal), baudrate, sclk_freq);
42007837:	01c8      	l32i.n	a12, a1, 0
42007839:	05ad      	mov.n	a10, a5
4200783b:	03bd      	mov.n	a11, a3
4200783d:	108365        	call8	42018074 <uart_hal_get_baudrate>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007840:	04ad      	mov.n	a10, a4
42007842:	e20081        	l32r	a8, 42000044 <_stext+0x24>
42007845:	0008e0        	callx8	a8
}
42007848:	f01d      	retw.n
	...

4200784c <uart_disable_intr_mask>:
{
4200784c:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
4200784f:	f47c      	movi.n	a4, -1
42007851:	4532e6        	bgei	a2, 3, 4200789a <uart_disable_intr_mask+0x4e>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007854:	e40f51        	l32r	a5, 42000890 <_stext+0x870>
42007857:	1162c0        	slli	a6, a2, 4
4200785a:	464b      	addi.n	a4, a6, 4
4200785c:	445a      	add.n	a4, a4, a5
4200785e:	fb7c      	movi.n	a11, -1
42007860:	20a440        	or	a10, a4, a4
42007863:	e1f781        	l32r	a8, 42000040 <_stext+0x20>
42007866:	0008e0        	callx8	a8
    p_uart_obj[uart_num]->rx_int_usr_mask &= ~disable_mask;
42007869:	e40b81        	l32r	a8, 42000898 <_stext+0x878>
    uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), disable_mask);
4200786c:	556a      	add.n	a5, a5, a6
    p_uart_obj[uart_num]->rx_int_usr_mask &= ~disable_mask;
4200786e:	a02280        	addx4	a2, a2, a8
42007871:	0288      	l32i.n	a8, a2, 0
42007873:	f27c      	movi.n	a2, -1
42007875:	303230        	xor	a3, a2, a3
42007878:	2c2822        	l32i	a2, a8, 176
    uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), disable_mask);
4200787b:	0558      	l32i.n	a5, a5, 0
    p_uart_obj[uart_num]->rx_int_usr_mask &= ~disable_mask;
4200787d:	102230        	and	a2, a2, a3
42007880:	2c6822        	s32i	a2, a8, 176
    hw->int_ena.val &= (~mask);
42007883:	0020c0        	memw
42007886:	3528      	l32i.n	a2, a5, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007888:	04ad      	mov.n	a10, a4
4200788a:	102230        	and	a2, a2, a3
4200788d:	0020c0        	memw
42007890:	3529      	s32i.n	a2, a5, 12
42007892:	e1ec81        	l32r	a8, 42000044 <_stext+0x24>
42007895:	0008e0        	callx8	a8
    return ESP_OK;
42007898:	040c      	movi.n	a4, 0
}
4200789a:	042d      	mov.n	a2, a4
4200789c:	f01d      	retw.n
	...

420078a0 <uart_pattern_queue_reset>:
{
420078a0:	004136        	entry	a1, 32
420078a3:	024d      	mov.n	a4, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420078a5:	f27c      	movi.n	a2, -1
420078a7:	5534e6        	bgei	a4, 3, 42007900 <uart_pattern_queue_reset+0x60>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), ESP_ERR_INVALID_STATE, UART_TAG, "uart driver error");
420078aa:	e3fb51        	l32r	a5, 42000898 <_stext+0x878>
420078ad:	03a122        	movi	a2, 0x103
420078b0:	a05450        	addx4	a5, a4, a5
420078b3:	0568      	l32i.n	a6, a5, 0
420078b5:	047616        	beqz	a6, 42007900 <uart_pattern_queue_reset+0x60>
    int *pdata = (int *) malloc(queue_length * sizeof(int));
420078b8:	11a3e0        	slli	a10, a3, 2
420078bb:	e1e381        	l32r	a8, 42000048 <_stext+0x28>
420078be:	0008e0        	callx8	a8
420078c1:	0a6d      	mov.n	a6, a10
        return ESP_ERR_NO_MEM;
420078c3:	01a122        	movi	a2, 0x101
    if (pdata == NULL) {
420078c6:	6abc      	beqz.n	a10, 42007900 <uart_pattern_queue_reset+0x60>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
420078c8:	e3f221        	l32r	a2, 42000890 <_stext+0x870>
420078cb:	1144c0        	slli	a4, a4, 4
420078ce:	444b      	addi.n	a4, a4, 4
420078d0:	442a      	add.n	a4, a4, a2
420078d2:	fb7c      	movi.n	a11, -1
420078d4:	20a440        	or	a10, a4, a4
420078d7:	e1da81        	l32r	a8, 42000040 <_stext+0x20>
420078da:	0008e0        	callx8	a8
    int *ptmp = p_uart_obj[uart_num]->rx_pattern_pos.data;
420078dd:	0588      	l32i.n	a8, a5, 0
    p_uart_obj[uart_num]->rx_pattern_pos.rd = 0;
420078df:	020c      	movi.n	a2, 0
    int *ptmp = p_uart_obj[uart_num]->rx_pattern_pos.data;
420078e1:	302852        	l32i	a5, a8, 192
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420078e4:	04ad      	mov.n	a10, a4
    p_uart_obj[uart_num]->rx_pattern_pos.data = pdata;
420078e6:	306862        	s32i	a6, a8, 192
    p_uart_obj[uart_num]->rx_pattern_pos.len = queue_length;
420078e9:	2f6832        	s32i	a3, a8, 188
    p_uart_obj[uart_num]->rx_pattern_pos.rd = 0;
420078ec:	2e6822        	s32i	a2, a8, 184
    p_uart_obj[uart_num]->rx_pattern_pos.wr = 0;
420078ef:	2d6822        	s32i	a2, a8, 180
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420078f2:	e1d481        	l32r	a8, 42000044 <_stext+0x24>
420078f5:	0008e0        	callx8	a8
    free(ptmp);
420078f8:	05ad      	mov.n	a10, a5
420078fa:	e1ca81        	l32r	a8, 42000024 <_stext+0x4>
420078fd:	0008e0        	callx8	a8
}
42007900:	f01d      	retw.n
	...

42007904 <uart_disable_rx_intr>:
{
42007904:	004136        	entry	a1, 32
    return uart_disable_intr_mask(uart_num, UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
42007907:	01a1b2        	movi	a11, 0x101
4200790a:	20a220        	or	a10, a2, a2
4200790d:	fff3e5        	call8	4200784c <uart_disable_intr_mask>
}
42007910:	202aa0        	or	a2, a10, a10
42007913:	000090        	retw
	...

42007918 <uart_disable_tx_intr>:
{
42007918:	004136        	entry	a1, 32
    return uart_disable_intr_mask(uart_num, UART_INTR_TXFIFO_EMPTY);
4200791b:	02a0b2        	movi	a11, 2
4200791e:	20a220        	or	a10, a2, a2
42007921:	fff2a5        	call8	4200784c <uart_disable_intr_mask>
}
42007924:	202aa0        	or	a2, a10, a10
42007927:	f01d      	retw.n
42007929:	000000        	ill

4200792c <uart_enable_tx_intr>:
{
4200792c:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
4200792f:	4732e6        	bgei	a2, 3, 4200797a <uart_enable_tx_intr+0x4e>
    ESP_RETURN_ON_FALSE((thresh < SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "empty intr threshold error");
42007932:	7fa032        	movi	a3, 127
42007935:	412347        	blt	a3, a4, 4200797a <uart_enable_tx_intr+0x4e>
    uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
42007938:	e3d681        	l32r	a8, 42000890 <_stext+0x870>
4200793b:	1122c0        	slli	a2, a2, 4
4200793e:	382a      	add.n	a3, a8, a2
42007940:	0398      	l32i.n	a9, a3, 0
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007942:	224b      	addi.n	a2, a2, 4
42007944:	228a      	add.n	a2, a2, a8
    hw->int_clr.val = mask;
42007946:	250c      	movi.n	a5, 2
42007948:	0020c0        	memw
4200794b:	4959      	s32i.n	a5, a9, 16
4200794d:	fb7c      	movi.n	a11, -1
4200794f:	02ad      	mov.n	a10, a2
42007951:	e1bb81        	l32r	a8, 42000040 <_stext+0x20>
42007954:	0008e0        	callx8	a8
    uart_hal_set_txfifo_empty_thr(&(uart_context[uart_num].hal), thresh);
42007957:	03ad      	mov.n	a10, a3
42007959:	04bd      	mov.n	a11, a4
4200795b:	016b65        	call8	42009010 <uart_hal_set_txfifo_empty_thr>
    uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TXFIFO_EMPTY);
4200795e:	0338      	l32i.n	a3, a3, 0
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007960:	02ad      	mov.n	a10, a2
    hw->int_ena.val |= mask;
42007962:	0020c0        	memw
42007965:	3388      	l32i.n	a8, a3, 12
    return ESP_OK;
42007967:	020c      	movi.n	a2, 0
42007969:	208850        	or	a8, a8, a5
4200796c:	0020c0        	memw
4200796f:	036382        	s32i	a8, a3, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007972:	e1b481        	l32r	a8, 42000044 <_stext+0x24>
42007975:	0008e0        	callx8	a8
}
42007978:	f01d      	retw.n
    ESP_RETURN_ON_FALSE((thresh < SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "empty intr threshold error");
4200797a:	f27c      	movi.n	a2, -1
4200797c:	fffe06        	j	42007978 <uart_enable_tx_intr+0x4c>
	...

42007980 <uart_tx_all$part$0>:
static int uart_tx_all(uart_port_t uart_num, const char *src, size_t size, bool brk_en, int brk_len)
42007980:	008136        	entry	a1, 64
42007983:	5159      	s32i.n	a5, a1, 20
    xSemaphoreTake(p_uart_obj[uart_num]->tx_mux, (TickType_t)portMAX_DELAY);
42007985:	1152e0        	slli	a5, a2, 2
42007988:	4159      	s32i.n	a5, a1, 16
4200798a:	e3c351        	l32r	a5, 42000898 <_stext+0x878>
4200798d:	fb7c      	movi.n	a11, -1
4200798f:	a07250        	addx4	a7, a2, a5
42007992:	002782        	l32i	a8, a7, 0
42007995:	205440        	or	a5, a4, a4
42007998:	3d28a2        	l32i	a10, a8, 244
4200799b:	e3d381        	l32r	a8, 420008e8 <_stext+0x8c8>
4200799e:	0008e0        	callx8	a8
    p_uart_obj[uart_num]->coll_det_flg = false;
420079a1:	0798      	l32i.n	a9, a7, 0
420079a3:	080c      	movi.n	a8, 0
    if (p_uart_obj[uart_num]->tx_buf_size > 0) {
420079a5:	3129a2        	l32i	a10, a9, 196
    p_uart_obj[uart_num]->coll_det_flg = false;
420079a8:	104982        	s8i	a8, a9, 16
    if (p_uart_obj[uart_num]->tx_buf_size > 0) {
420079ab:	021ae6        	bgei	a10, 1, 420079b1 <uart_tx_all$part$0+0x31>
420079ae:	002fc6        	j	42007a71 <uart_tx_all$part$0+0xf1>
        size_t max_size = xRingbufferGetMaxItemSize(p_uart_obj[uart_num]->tx_ring_buf);
420079b1:	3b29a2        	l32i	a10, a9, 236
            evt.type = UART_DATA;
420079b4:	050c      	movi.n	a5, 0
        size_t max_size = xRingbufferGetMaxItemSize(p_uart_obj[uart_num]->tx_ring_buf);
420079b6:	e3cd81        	l32r	a8, 420008ec <_stext+0x8cc>
420079b9:	0008e0        	callx8	a8
        evt.tx_data.brk_len = brk_len;
420079bc:	1169      	s32i.n	a6, a1, 4
            evt.type = UART_DATA;
420079be:	5168      	l32i.n	a6, a1, 20
420079c0:	680c      	movi.n	a8, 6
420079c2:	838560        	moveqz	a8, a5, a6
        xRingbufferSend(p_uart_obj[uart_num]->tx_ring_buf, (void *) &evt, sizeof(uart_tx_data_t), portMAX_DELAY);
420079c5:	0768      	l32i.n	a6, a7, 0
        size_t max_size = xRingbufferGetMaxItemSize(p_uart_obj[uart_num]->tx_ring_buf);
420079c7:	0a9d      	mov.n	a9, a10
        xRingbufferSend(p_uart_obj[uart_num]->tx_ring_buf, (void *) &evt, sizeof(uart_tx_data_t), portMAX_DELAY);
420079c9:	3b26a2        	l32i	a10, a6, 236
420079cc:	fd7c      	movi.n	a13, -1
420079ce:	cc0c      	movi.n	a12, 12
420079d0:	01bd      	mov.n	a11, a1
420079d2:	0189      	s32i.n	a8, a1, 0
420079d4:	7199      	s32i.n	a9, a1, 28
        evt.tx_data.size = size;
420079d6:	2149      	s32i.n	a4, a1, 8
        xRingbufferSend(p_uart_obj[uart_num]->tx_ring_buf, (void *) &evt, sizeof(uart_tx_data_t), portMAX_DELAY);
420079d8:	e3b481        	l32r	a8, 420008a8 <_stext+0x888>
420079db:	0008e0        	callx8	a8
            size_t send_size = size > max_size / 2 ? max_size / 2 : size;
420079de:	7198      	l32i.n	a9, a1, 28
        while (size > 0) {
420079e0:	048d      	mov.n	a8, a4
            size_t send_size = size > max_size / 2 ? max_size / 2 : size;
420079e2:	419190        	srli	a9, a9, 1
            xRingbufferSend(p_uart_obj[uart_num]->tx_ring_buf, (void *) (src + offset), send_size, portMAX_DELAY);
420079e5:	07a8      	l32i.n	a10, a7, 0
        while (size > 0) {
420079e7:	a8dc      	bnez.n	a8, 42007a05 <uart_tx_all$part$0+0x85>
    xSemaphoreGive(p_uart_obj[uart_num]->tx_mux);
420079e9:	e3ab61        	l32r	a6, 42000898 <_stext+0x878>
420079ec:	4138      	l32i.n	a3, a1, 16
420079ee:	0d0c      	movi.n	a13, 0
420079f0:	263a      	add.n	a2, a6, a3
420079f2:	0228      	l32i.n	a2, a2, 0
420079f4:	0dcd      	mov.n	a12, a13
420079f6:	3d22a2        	l32i	a10, a2, 244
420079f9:	0dbd      	mov.n	a11, a13
420079fb:	e32c81        	l32r	a8, 420006ac <_stext+0x68c>
420079fe:	0008e0        	callx8	a8
}
42007a01:	042d      	mov.n	a2, a4
42007a03:	f01d      	retw.n
            size_t send_size = size > max_size / 2 ? max_size / 2 : size;
42007a05:	636980        	minu	a6, a9, a8
            xRingbufferSend(p_uart_obj[uart_num]->tx_ring_buf, (void *) (src + offset), send_size, portMAX_DELAY);
42007a08:	3b2aa2        	l32i	a10, a10, 236
42007a0b:	b35a      	add.n	a11, a3, a5
42007a0d:	fd7c      	movi.n	a13, -1
42007a0f:	06cd      	mov.n	a12, a6
42007a11:	7199      	s32i.n	a9, a1, 28
42007a13:	6189      	s32i.n	a8, a1, 24
42007a15:	e3a481        	l32r	a8, 420008a8 <_stext+0x888>
42007a18:	0008e0        	callx8	a8
            size -= send_size;
42007a1b:	6188      	l32i.n	a8, a1, 24
            uart_enable_tx_intr(uart_num, 1, UART_EMPTY_THRESH_DEFAULT);
42007a1d:	ac0c      	movi.n	a12, 10
            size -= send_size;
42007a1f:	c08860        	sub	a8, a8, a6
            uart_enable_tx_intr(uart_num, 1, UART_EMPTY_THRESH_DEFAULT);
42007a22:	1b0c      	movi.n	a11, 1
42007a24:	02ad      	mov.n	a10, a2
42007a26:	066182        	s32i	a8, a1, 24
42007a29:	fff025        	call8	4200792c <uart_enable_tx_intr>
42007a2c:	7198      	l32i.n	a9, a1, 28
42007a2e:	6188      	l32i.n	a8, a1, 24
            offset += send_size;
42007a30:	565a      	add.n	a5, a6, a5
            uart_enable_tx_intr(uart_num, 1, UART_EMPTY_THRESH_DEFAULT);
42007a32:	ffebc6        	j	420079e5 <uart_tx_all$part$0+0x65>
            if (pdTRUE == xSemaphoreTake(p_uart_obj[uart_num]->tx_fifo_sem, (TickType_t)portMAX_DELAY)) {
42007a35:	0798      	l32i.n	a9, a7, 0
42007a37:	fb7c      	movi.n	a11, -1
42007a39:	3e29a2        	l32i	a10, a9, 248
42007a3c:	e3ab81        	l32r	a8, 420008e8 <_stext+0x8c8>
42007a3f:	0008e0        	callx8	a8
42007a42:	0add      	mov.n	a13, a10
42007a44:	291a66        	bnei	a10, 1, 42007a71 <uart_tx_all$part$0+0xf1>
                uint32_t sent = uart_enable_tx_write_fifo(uart_num, (const uint8_t *) src, size);
42007a47:	05cd      	mov.n	a12, a5
42007a49:	03bd      	mov.n	a11, a3
42007a4b:	02ad      	mov.n	a10, a2
42007a4d:	61d9      	s32i.n	a13, a1, 24
42007a4f:	ff3925        	call8	42006de0 <uart_enable_tx_write_fifo>
                if (sent < size) {
42007a52:	61d8      	l32i.n	a13, a1, 24
                uint32_t sent = uart_enable_tx_write_fifo(uart_num, (const uint8_t *) src, size);
42007a54:	0a9d      	mov.n	a9, a10
                if (sent < size) {
42007a56:	12ba57        	bgeu	a10, a5, 42007a6c <uart_tx_all$part$0+0xec>
                    p_uart_obj[uart_num]->tx_waiting_fifo = true;
42007a59:	07a8      	l32i.n	a10, a7, 0
                    uart_enable_tx_intr(uart_num, 1, UART_EMPTY_THRESH_DEFAULT);
42007a5b:	ac0c      	movi.n	a12, 10
                    p_uart_obj[uart_num]->tx_waiting_fifo = true;
42007a5d:	c84ad2        	s8i	a13, a10, 200
                    uart_enable_tx_intr(uart_num, 1, UART_EMPTY_THRESH_DEFAULT);
42007a60:	0dbd      	mov.n	a11, a13
42007a62:	02ad      	mov.n	a10, a2
42007a64:	076192        	s32i	a9, a1, 28
42007a67:	ffec65        	call8	4200792c <uart_enable_tx_intr>
42007a6a:	7198      	l32i.n	a9, a1, 28
                size -= sent;
42007a6c:	c05590        	sub	a5, a5, a9
                src += sent;
42007a6f:	339a      	add.n	a3, a3, a9
        while (size) {
42007a71:	fc0556        	bnez	a5, 42007a35 <uart_tx_all$part$0+0xb5>
        if (brk_en) {
42007a74:	5138      	l32i.n	a3, a1, 20
42007a76:	052316        	beqz	a3, 42007acc <uart_tx_all$part$0+0x14c>
            uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
42007a79:	e38571        	l32r	a7, 42000890 <_stext+0x870>
42007a7c:	1122c0        	slli	a2, a2, 4
42007a7f:	572a      	add.n	a5, a7, a2
42007a81:	0588      	l32i.n	a8, a5, 0
    hw->int_clr.val = mask;
42007a83:	e38a31        	l32r	a3, 420008ac <_stext+0x88c>
            UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007a86:	224b      	addi.n	a2, a2, 4
42007a88:	227a      	add.n	a2, a2, a7
42007a8a:	0020c0        	memw
42007a8d:	4839      	s32i.n	a3, a8, 16
42007a8f:	fb7c      	movi.n	a11, -1
42007a91:	02ad      	mov.n	a10, a2
42007a93:	e16b81        	l32r	a8, 42000040 <_stext+0x20>
42007a96:	0008e0        	callx8	a8
            uart_hal_tx_break(&(uart_context[uart_num].hal), brk_len);
42007a99:	06bd      	mov.n	a11, a6
42007a9b:	20a550        	or	a10, a5, a5
42007a9e:	101aa5        	call8	42017c48 <uart_hal_tx_break>
            uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_BRK_DONE);
42007aa1:	0568      	l32i.n	a6, a5, 0
            UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007aa3:	02ad      	mov.n	a10, a2
    hw->int_ena.val |= mask;
42007aa5:	0020c0        	memw
42007aa8:	3658      	l32i.n	a5, a6, 12
42007aaa:	203530        	or	a3, a5, a3
42007aad:	0020c0        	memw
42007ab0:	3639      	s32i.n	a3, a6, 12
42007ab2:	e16481        	l32r	a8, 42000044 <_stext+0x24>
42007ab5:	0008e0        	callx8	a8
            xSemaphoreTake(p_uart_obj[uart_num]->tx_brk_sem, (TickType_t)portMAX_DELAY);
42007ab8:	e37851        	l32r	a5, 42000898 <_stext+0x878>
42007abb:	4168      	l32i.n	a6, a1, 16
42007abd:	fb7c      	movi.n	a11, -1
42007abf:	256a      	add.n	a2, a5, a6
42007ac1:	0228      	l32i.n	a2, a2, 0
42007ac3:	4022a2        	l32i	a10, a2, 0x100
42007ac6:	e38881        	l32r	a8, 420008e8 <_stext+0x8c8>
42007ac9:	0008e0        	callx8	a8
        xSemaphoreGive(p_uart_obj[uart_num]->tx_fifo_sem);
42007acc:	e37331        	l32r	a3, 42000898 <_stext+0x878>
42007acf:	4158      	l32i.n	a5, a1, 16
42007ad1:	0d0c      	movi.n	a13, 0
42007ad3:	235a      	add.n	a2, a3, a5
42007ad5:	0228      	l32i.n	a2, a2, 0
42007ad7:	0dcd      	mov.n	a12, a13
42007ad9:	3e22a2        	l32i	a10, a2, 248
42007adc:	0dbd      	mov.n	a11, a13
42007ade:	e2f381        	l32r	a8, 420006ac <_stext+0x68c>
42007ae1:	0008e0        	callx8	a8
42007ae4:	ffc046        	j	420079e9 <uart_tx_all$part$0+0x69>
	...

42007ae8 <uart_set_pin>:
{
42007ae8:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007aeb:	f87c      	movi.n	a8, -1
42007aed:	0232b6        	bltui	a2, 3, 42007af3 <uart_set_pin+0xb>
42007af0:	007286        	j	42007cbe <uart_set_pin+0x1d6>
    ESP_RETURN_ON_FALSE((tx_io_num < 0 || (GPIO_IS_VALID_OUTPUT_GPIO(tx_io_num))), ESP_FAIL, UART_TAG, "tx_io_num error");
42007af3:	015396        	bltz	a3, 42007b0c <uart_set_pin+0x24>
42007af6:	e359a1        	l32r	a10, 4200085c <_stext+0x83c>
42007af9:	e359b1        	l32r	a11, 42000860 <_stext+0x840>
42007afc:	03cd      	mov.n	a12, a3
42007afe:	e35581        	l32r	a8, 42000854 <_stext+0x834>
42007b01:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007b04:	f87c      	movi.n	a8, -1
    ESP_RETURN_ON_FALSE((tx_io_num < 0 || (GPIO_IS_VALID_OUTPUT_GPIO(tx_io_num))), ESP_FAIL, UART_TAG, "tx_io_num error");
42007b06:	02ea07        	bbsi	a10, 0, 42007b0c <uart_set_pin+0x24>
42007b09:	006c46        	j	42007cbe <uart_set_pin+0x1d6>
    ESP_RETURN_ON_FALSE((rx_io_num < 0 || (GPIO_IS_VALID_GPIO(rx_io_num))), ESP_FAIL, UART_TAG, "rx_io_num error");
42007b0c:	015496        	bltz	a4, 42007b25 <uart_set_pin+0x3d>
42007b0f:	e353a1        	l32r	a10, 4200085c <_stext+0x83c>
42007b12:	e353b1        	l32r	a11, 42000860 <_stext+0x840>
42007b15:	04cd      	mov.n	a12, a4
42007b17:	e34f81        	l32r	a8, 42000854 <_stext+0x834>
42007b1a:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007b1d:	f87c      	movi.n	a8, -1
    ESP_RETURN_ON_FALSE((rx_io_num < 0 || (GPIO_IS_VALID_GPIO(rx_io_num))), ESP_FAIL, UART_TAG, "rx_io_num error");
42007b1f:	02ea07        	bbsi	a10, 0, 42007b25 <uart_set_pin+0x3d>
42007b22:	006606        	j	42007cbe <uart_set_pin+0x1d6>
    ESP_RETURN_ON_FALSE((rts_io_num < 0 || (GPIO_IS_VALID_OUTPUT_GPIO(rts_io_num))), ESP_FAIL, UART_TAG, "rts_io_num error");
42007b25:	015596        	bltz	a5, 42007b3e <uart_set_pin+0x56>
42007b28:	e34da1        	l32r	a10, 4200085c <_stext+0x83c>
42007b2b:	e34db1        	l32r	a11, 42000860 <_stext+0x840>
42007b2e:	05cd      	mov.n	a12, a5
42007b30:	e34981        	l32r	a8, 42000854 <_stext+0x834>
42007b33:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007b36:	f87c      	movi.n	a8, -1
    ESP_RETURN_ON_FALSE((rts_io_num < 0 || (GPIO_IS_VALID_OUTPUT_GPIO(rts_io_num))), ESP_FAIL, UART_TAG, "rts_io_num error");
42007b38:	02ea07        	bbsi	a10, 0, 42007b3e <uart_set_pin+0x56>
42007b3b:	005fc6        	j	42007cbe <uart_set_pin+0x1d6>
    ESP_RETURN_ON_FALSE((cts_io_num < 0 || (GPIO_IS_VALID_GPIO(cts_io_num))), ESP_FAIL, UART_TAG, "cts_io_num error");
42007b3e:	017696        	bltz	a6, 42007b59 <uart_set_pin+0x71>
42007b41:	e346a1        	l32r	a10, 4200085c <_stext+0x83c>
42007b44:	e347b1        	l32r	a11, 42000860 <_stext+0x840>
42007b47:	20c660        	or	a12, a6, a6
42007b4a:	e34281        	l32r	a8, 42000854 <_stext+0x834>
42007b4d:	0008e0        	callx8	a8
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007b50:	ffaf82        	movi	a8, -1
    ESP_RETURN_ON_FALSE((cts_io_num < 0 || (GPIO_IS_VALID_GPIO(cts_io_num))), ESP_FAIL, UART_TAG, "cts_io_num error");
42007b53:	02ea07        	bbsi	a10, 0, 42007b59 <uart_set_pin+0x71>
42007b56:	005906        	j	42007cbe <uart_set_pin+0x1d6>
    if (tx_io_num >= 0 && !uart_try_set_iomux_pin(uart_num, tx_io_num, SOC_UART_TX_PIN_IDX)) {
42007b59:	070396        	bltz	a3, 42007bcd <uart_set_pin+0xe5>
42007b5c:	00a0c2        	movi	a12, 0
42007b5f:	20b330        	or	a11, a3, a3
42007b62:	20a220        	or	a10, a2, a2
42007b65:	ff1b25        	call8	42006d18 <uart_try_set_iomux_pin>
42007b68:	061a56        	bnez	a10, 42007bcd <uart_set_pin+0xe5>
        gpio_hal_iomux_func_sel(GPIO_PIN_MUX_REG[tx_io_num], PIN_FUNC_GPIO);
42007b6b:	e34181        	l32r	a8, 42000870 <_stext+0x850>
    if (pin_name == IO_MUX_GPIO19_REG || pin_name == IO_MUX_GPIO20_REG) {
42007b6e:	e346a1        	l32r	a10, 42000888 <_stext+0x868>
42007b71:	a08380        	addx4	a8, a3, a8
42007b74:	0898      	l32i.n	a9, a8, 0
42007b76:	b87c      	movi.n	a8, -5
42007b78:	108980        	and	a8, a9, a8
42007b7b:	1298a7        	bne	a8, a10, 42007b91 <uart_set_pin+0xa9>
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_USB_PAD_ENABLE);
42007b7e:	e33fa1        	l32r	a10, 4200087c <_stext+0x85c>
42007b81:	e1e7b1        	l32r	a11, 42000320 <_stext+0x300>
42007b84:	0020c0        	memw
42007b87:	0a88      	l32i.n	a8, a10, 0
42007b89:	1088b0        	and	a8, a8, a11
42007b8c:	0020c0        	memw
42007b8f:	0a89      	s32i.n	a8, a10, 0
    PIN_FUNC_SELECT(pin_name, func);
42007b91:	0020c0        	memw
42007b94:	0988      	l32i.n	a8, a9, 0
42007b96:	e251a1        	l32r	a10, 420004dc <_stext+0x4bc>
        gpio_set_level(tx_io_num, 1);
42007b99:	1b0c      	movi.n	a11, 1
42007b9b:	1088a0        	and	a8, a8, a10
42007b9e:	1a0c      	movi.n	a10, 1
42007ba0:	11aa40        	slli	a10, a10, 12
42007ba3:	2088a0        	or	a8, a8, a10
42007ba6:	0020c0        	memw
42007ba9:	0989      	s32i.n	a8, a9, 0
42007bab:	03ad      	mov.n	a10, a3
42007bad:	fef465        	call8	42006af4 <gpio_set_level>
        esp_rom_gpio_connect_out_signal(tx_io_num, UART_PERIPH_SIGNAL(uart_num, SOC_UART_TX_PIN_IDX), 0, 0);
42007bb0:	e33791        	l32r	a9, 4200088c <_stext+0x86c>
42007bb3:	908220        	addx2	a8, a2, a2
42007bb6:	b08890        	addx8	a8, a8, a9
42007bb9:	08b8      	l32i.n	a11, a8, 0
42007bbb:	00a0d2        	movi	a13, 0
42007bbe:	20cdd0        	or	a12, a13, a13
42007bc1:	b5b4b0        	extui	a11, a11, 20, 12
42007bc4:	20a330        	or	a10, a3, a3
42007bc7:	e32881        	l32r	a8, 42000868 <_stext+0x848>
42007bca:	0008e0        	callx8	a8
    if (rx_io_num >= 0 && !uart_try_set_iomux_pin(uart_num, rx_io_num, SOC_UART_RX_PIN_IDX)) {
42007bcd:	074496        	bltz	a4, 42007c45 <uart_set_pin+0x15d>
42007bd0:	01a0c2        	movi	a12, 1
42007bd3:	20b440        	or	a11, a4, a4
42007bd6:	20a220        	or	a10, a2, a2
42007bd9:	ff13e5        	call8	42006d18 <uart_try_set_iomux_pin>
42007bdc:	065a56        	bnez	a10, 42007c45 <uart_set_pin+0x15d>
        gpio_hal_iomux_func_sel(GPIO_PIN_MUX_REG[rx_io_num], PIN_FUNC_GPIO);
42007bdf:	e32431        	l32r	a3, 42000870 <_stext+0x850>
    if (pin_name == IO_MUX_GPIO19_REG || pin_name == IO_MUX_GPIO20_REG) {
42007be2:	e32991        	l32r	a9, 42000888 <_stext+0x868>
42007be5:	a03430        	addx4	a3, a4, a3
42007be8:	0388      	l32i.n	a8, a3, 0
42007bea:	b37c      	movi.n	a3, -5
42007bec:	103830        	and	a3, a8, a3
42007bef:	129397        	bne	a3, a9, 42007c05 <uart_set_pin+0x11d>
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_USB_PAD_ENABLE);
42007bf2:	e32291        	l32r	a9, 4200087c <_stext+0x85c>
42007bf5:	e1caa1        	l32r	a10, 42000320 <_stext+0x300>
42007bf8:	0020c0        	memw
42007bfb:	0938      	l32i.n	a3, a9, 0
42007bfd:	1033a0        	and	a3, a3, a10
42007c00:	0020c0        	memw
42007c03:	0939      	s32i.n	a3, a9, 0
    PIN_FUNC_SELECT(pin_name, func);
42007c05:	0020c0        	memw
42007c08:	0838      	l32i.n	a3, a8, 0
42007c0a:	e23491        	l32r	a9, 420004dc <_stext+0x4bc>
        gpio_set_pull_mode(rx_io_num, GPIO_PULLUP_ONLY);
42007c0d:	0b0c      	movi.n	a11, 0
42007c0f:	103390        	and	a3, a3, a9
42007c12:	190c      	movi.n	a9, 1
42007c14:	119940        	slli	a9, a9, 12
42007c17:	203390        	or	a3, a3, a9
42007c1a:	0020c0        	memw
42007c1d:	0839      	s32i.n	a3, a8, 0
42007c1f:	20a440        	or	a10, a4, a4
42007c22:	fef5e5        	call8	42006b80 <gpio_set_pull_mode>
        gpio_set_direction(rx_io_num, GPIO_MODE_INPUT);
42007c25:	1b0c      	movi.n	a11, 1
42007c27:	20a440        	or	a10, a4, a4
42007c2a:	fefba5        	call8	42006be4 <gpio_set_direction>
        esp_rom_gpio_connect_in_signal(rx_io_num, UART_PERIPH_SIGNAL(uart_num, SOC_UART_RX_PIN_IDX), 0);
42007c2d:	e31781        	l32r	a8, 4200088c <_stext+0x86c>
42007c30:	903220        	addx2	a3, a2, a2
42007c33:	b03380        	addx8	a3, a3, a8
42007c36:	13b8      	l32i.n	a11, a3, 4
42007c38:	0c0c      	movi.n	a12, 0
42007c3a:	b5b4b0        	extui	a11, a11, 20, 12
42007c3d:	04ad      	mov.n	a10, a4
42007c3f:	e32c81        	l32r	a8, 420008f0 <_stext+0x8d0>
42007c42:	0008e0        	callx8	a8
    if (rts_io_num >= 0 && !uart_try_set_iomux_pin(uart_num, rts_io_num, SOC_UART_RTS_PIN_IDX)) {
42007c45:	070596        	bltz	a5, 42007cb9 <uart_set_pin+0x1d1>
42007c48:	02a0c2        	movi	a12, 2
42007c4b:	20b550        	or	a11, a5, a5
42007c4e:	20a220        	or	a10, a2, a2
42007c51:	ff0c65        	call8	42006d18 <uart_try_set_iomux_pin>
42007c54:	061a56        	bnez	a10, 42007cb9 <uart_set_pin+0x1d1>
        gpio_hal_iomux_func_sel(GPIO_PIN_MUX_REG[rts_io_num], PIN_FUNC_GPIO);
42007c57:	e30631        	l32r	a3, 42000870 <_stext+0x850>
    if (pin_name == IO_MUX_GPIO19_REG || pin_name == IO_MUX_GPIO20_REG) {
42007c5a:	e30b81        	l32r	a8, 42000888 <_stext+0x868>
42007c5d:	a03530        	addx4	a3, a5, a3
42007c60:	0348      	l32i.n	a4, a3, 0
42007c62:	b37c      	movi.n	a3, -5
42007c64:	103430        	and	a3, a4, a3
42007c67:	129387        	bne	a3, a8, 42007c7d <uart_set_pin+0x195>
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_USB_PAD_ENABLE);
42007c6a:	e30481        	l32r	a8, 4200087c <_stext+0x85c>
42007c6d:	e1ac91        	l32r	a9, 42000320 <_stext+0x300>
42007c70:	0020c0        	memw
42007c73:	0838      	l32i.n	a3, a8, 0
42007c75:	103390        	and	a3, a3, a9
42007c78:	0020c0        	memw
42007c7b:	0839      	s32i.n	a3, a8, 0
    PIN_FUNC_SELECT(pin_name, func);
42007c7d:	0020c0        	memw
42007c80:	0438      	l32i.n	a3, a4, 0
42007c82:	e21681        	l32r	a8, 420004dc <_stext+0x4bc>
        gpio_set_direction(rts_io_num, GPIO_MODE_OUTPUT);
42007c85:	2b0c      	movi.n	a11, 2
42007c87:	103380        	and	a3, a3, a8
42007c8a:	180c      	movi.n	a8, 1
42007c8c:	118840        	slli	a8, a8, 12
42007c8f:	203380        	or	a3, a3, a8
42007c92:	0020c0        	memw
42007c95:	0439      	s32i.n	a3, a4, 0
42007c97:	05ad      	mov.n	a10, a5
42007c99:	fef4a5        	call8	42006be4 <gpio_set_direction>
        esp_rom_gpio_connect_out_signal(rts_io_num, UART_PERIPH_SIGNAL(uart_num, SOC_UART_RTS_PIN_IDX), 0, 0);
42007c9c:	e2fc41        	l32r	a4, 4200088c <_stext+0x86c>
42007c9f:	903220        	addx2	a3, a2, a2
42007ca2:	b03340        	addx8	a3, a3, a4
42007ca5:	23b8      	l32i.n	a11, a3, 8
42007ca7:	00a0d2        	movi	a13, 0
42007caa:	20cdd0        	or	a12, a13, a13
42007cad:	b5b4b0        	extui	a11, a11, 20, 12
42007cb0:	20a550        	or	a10, a5, a5
42007cb3:	e2ed81        	l32r	a8, 42000868 <_stext+0x848>
42007cb6:	0008e0        	callx8	a8
    if (cts_io_num >= 0  && !uart_try_set_iomux_pin(uart_num, cts_io_num, SOC_UART_CTS_PIN_IDX)) {
42007cb9:	0056d6        	bgez	a6, 42007cc2 <uart_set_pin+0x1da>
    return ESP_OK;
42007cbc:	080c      	movi.n	a8, 0
}
42007cbe:	082d      	mov.n	a2, a8
42007cc0:	f01d      	retw.n
    if (cts_io_num >= 0  && !uart_try_set_iomux_pin(uart_num, cts_io_num, SOC_UART_CTS_PIN_IDX)) {
42007cc2:	3c0c      	movi.n	a12, 3
42007cc4:	06bd      	mov.n	a11, a6
42007cc6:	20a220        	or	a10, a2, a2
42007cc9:	ff04e5        	call8	42006d18 <uart_try_set_iomux_pin>
42007ccc:	feca56        	bnez	a10, 42007cbc <uart_set_pin+0x1d4>
        gpio_hal_iomux_func_sel(GPIO_PIN_MUX_REG[cts_io_num], PIN_FUNC_GPIO);
42007ccf:	e2e831        	l32r	a3, 42000870 <_stext+0x850>
    if (pin_name == IO_MUX_GPIO19_REG || pin_name == IO_MUX_GPIO20_REG) {
42007cd2:	e2ed51        	l32r	a5, 42000888 <_stext+0x868>
42007cd5:	a03630        	addx4	a3, a6, a3
42007cd8:	0348      	l32i.n	a4, a3, 0
42007cda:	b37c      	movi.n	a3, -5
42007cdc:	103430        	and	a3, a4, a3
42007cdf:	129357        	bne	a3, a5, 42007cf5 <uart_set_pin+0x20d>
        CLEAR_PERI_REG_MASK(USB_SERIAL_JTAG_CONF0_REG, USB_SERIAL_JTAG_USB_PAD_ENABLE);
42007ce2:	e2e651        	l32r	a5, 4200087c <_stext+0x85c>
42007ce5:	e18e81        	l32r	a8, 42000320 <_stext+0x300>
42007ce8:	0020c0        	memw
42007ceb:	0538      	l32i.n	a3, a5, 0
42007ced:	103380        	and	a3, a3, a8
42007cf0:	0020c0        	memw
42007cf3:	0539      	s32i.n	a3, a5, 0
    PIN_FUNC_SELECT(pin_name, func);
42007cf5:	0020c0        	memw
42007cf8:	0438      	l32i.n	a3, a4, 0
42007cfa:	e1f851        	l32r	a5, 420004dc <_stext+0x4bc>
        gpio_set_pull_mode(cts_io_num, GPIO_PULLUP_ONLY);
42007cfd:	0b0c      	movi.n	a11, 0
42007cff:	103350        	and	a3, a3, a5
42007d02:	150c      	movi.n	a5, 1
42007d04:	115540        	slli	a5, a5, 12
42007d07:	203350        	or	a3, a3, a5
42007d0a:	0020c0        	memw
42007d0d:	0439      	s32i.n	a3, a4, 0
42007d0f:	20a660        	or	a10, a6, a6
42007d12:	fee6e5        	call8	42006b80 <gpio_set_pull_mode>
        gpio_set_direction(cts_io_num, GPIO_MODE_INPUT);
42007d15:	1b0c      	movi.n	a11, 1
42007d17:	06ad      	mov.n	a10, a6
42007d19:	feeca5        	call8	42006be4 <gpio_set_direction>
        esp_rom_gpio_connect_in_signal(cts_io_num, UART_PERIPH_SIGNAL(uart_num, SOC_UART_CTS_PIN_IDX), 0);
42007d1c:	e2dc31        	l32r	a3, 4200088c <_stext+0x86c>
42007d1f:	902220        	addx2	a2, a2, a2
42007d22:	b02230        	addx8	a2, a2, a3
42007d25:	32b8      	l32i.n	a11, a2, 12
42007d27:	0c0c      	movi.n	a12, 0
42007d29:	b5b4b0        	extui	a11, a11, 20, 12
42007d2c:	06ad      	mov.n	a10, a6
42007d2e:	e2f081        	l32r	a8, 420008f0 <_stext+0x8d0>
42007d31:	0008e0        	callx8	a8
42007d34:	ffe106        	j	42007cbc <uart_set_pin+0x1d4>
	...

42007d38 <uart_param_config>:
{
42007d38:	006136        	entry	a1, 48
42007d3b:	025d      	mov.n	a5, a2
    ESP_RETURN_ON_FALSE((uart_config), ESP_FAIL, UART_TAG, "param null");
42007d3d:	0a3316        	beqz	a3, 42007de4 <uart_param_config+0xac>
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007d40:	0232a6        	blti	a2, 3, 42007d46 <uart_param_config+0xe>
42007d43:	002746        	j	42007de4 <uart_param_config+0xac>
    ESP_RETURN_ON_FALSE((uart_config->rx_flow_ctrl_thresh < SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "rx flow thresh error");
42007d46:	140342        	l8ui	a4, a3, 20
    ESP_RETURN_ON_FALSE((uart_config), ESP_FAIL, UART_TAG, "param null");
42007d49:	f27c      	movi.n	a2, -1
    ESP_RETURN_ON_FALSE((uart_config->rx_flow_ctrl_thresh < SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "rx flow thresh error");
42007d4b:	026477        	bbci	a4, 7, 42007d51 <uart_param_config+0x19>
42007d4e:	0023c6        	j	42007de1 <uart_param_config+0xa9>
    ESP_RETURN_ON_FALSE((uart_config->flow_ctrl < UART_HW_FLOWCTRL_MAX), ESP_FAIL, UART_TAG, "hw_flowctrl mode error");
42007d51:	4348      	l32i.n	a4, a3, 16
42007d53:	0244b6        	bltui	a4, 4, 42007d59 <uart_param_config+0x21>
42007d56:	0021c6        	j	42007de1 <uart_param_config+0xa9>
    ESP_RETURN_ON_FALSE((uart_config->data_bits < UART_DATA_BITS_MAX), ESP_FAIL, UART_TAG, "data bit error");
42007d59:	1348      	l32i.n	a4, a3, 4
42007d5b:	0244b6        	bltui	a4, 4, 42007d61 <uart_param_config+0x29>
42007d5e:	001fc6        	j	42007de1 <uart_param_config+0xa9>
    uart_module_enable(uart_num);
42007d61:	05ad      	mov.n	a10, a5
42007d63:	ff00a5        	call8	42006d6c <uart_module_enable>
    if (uart_config->source_clk == UART_SCLK_RTC) {
42007d66:	6348      	l32i.n	a4, a3, 24
42007d68:	920c      	movi.n	a2, 9
42007d6a:	029427        	bne	a4, a2, 42007d70 <uart_param_config+0x38>
        periph_rtc_dig_clk8m_enable();
42007d6d:	015a25        	call8	42009310 <periph_rtc_dig_clk8m_enable>
    ESP_RETURN_ON_ERROR(uart_get_sclk_freq(uart_config->source_clk, &sclk_freq), UART_TAG, "Invalid src_clk");
42007d70:	63a8      	l32i.n	a10, a3, 24
42007d72:	01bd      	mov.n	a11, a1
42007d74:	ff8e65        	call8	4200765c <uart_get_sclk_freq>
42007d77:	0a2d      	mov.n	a2, a10
42007d79:	064a56        	bnez	a10, 42007de1 <uart_param_config+0xa9>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007d7c:	e2c571        	l32r	a7, 42000890 <_stext+0x870>
42007d7f:	1145c0        	slli	a4, a5, 4
42007d82:	644b      	addi.n	a6, a4, 4
42007d84:	667a      	add.n	a6, a6, a7
42007d86:	fb7c      	movi.n	a11, -1
42007d88:	06ad      	mov.n	a10, a6
    uart_hal_init(&(uart_context[uart_num].hal), uart_num);
42007d8a:	447a      	add.n	a4, a4, a7
42007d8c:	e0ad81        	l32r	a8, 42000040 <_stext+0x20>
42007d8f:	0008e0        	callx8	a8
42007d92:	05bd      	mov.n	a11, a5
42007d94:	04ad      	mov.n	a10, a4
42007d96:	0129a5        	call8	42009030 <uart_hal_init>
    uart_hal_set_sclk(&(uart_context[uart_num].hal), uart_config->source_clk);
42007d99:	63b8      	l32i.n	a11, a3, 24
42007d9b:	04ad      	mov.n	a10, a4
42007d9d:	0111a5        	call8	42008eb8 <uart_hal_set_sclk>
    uart_hal_set_baudrate(&(uart_context[uart_num].hal), uart_config->baud_rate, sclk_freq);
42007da0:	01c8      	l32i.n	a12, a1, 0
42007da2:	03b8      	l32i.n	a11, a3, 0
42007da4:	04ad      	mov.n	a10, a4
42007da6:	0115e5        	call8	42008f04 <uart_hal_set_baudrate>
    uart_hal_set_parity(&(uart_context[uart_num].hal), uart_config->parity);
42007da9:	23b8      	l32i.n	a11, a3, 8
42007dab:	04ad      	mov.n	a10, a4
42007dad:	103665        	call8	42018114 <uart_hal_set_parity>
    uart_hal_set_data_bit_num(&(uart_context[uart_num].hal), uart_config->data_bits);
42007db0:	13b8      	l32i.n	a11, a3, 4
42007db2:	04ad      	mov.n	a10, a4
42007db4:	1032a5        	call8	420180e0 <uart_hal_set_data_bit_num>
    uart_hal_set_stop_bits(&(uart_context[uart_num].hal), uart_config->stop_bits);
42007db7:	33b8      	l32i.n	a11, a3, 12
42007db9:	04ad      	mov.n	a10, a4
42007dbb:	102f25        	call8	420180ac <uart_hal_set_stop_bits>
    uart_hal_set_tx_idle_num(&(uart_context[uart_num].hal), UART_TX_IDLE_NUM_DEFAULT);
42007dbe:	02bd      	mov.n	a11, a2
42007dc0:	04ad      	mov.n	a10, a4
42007dc2:	0122a5        	call8	42008fec <uart_hal_set_tx_idle_num>
    uart_hal_set_hw_flow_ctrl(&(uart_context[uart_num].hal), uart_config->flow_ctrl, uart_config->rx_flow_ctrl_thresh);
42007dc5:	1403c2        	l8ui	a12, a3, 20
42007dc8:	43b8      	l32i.n	a11, a3, 16
42007dca:	04ad      	mov.n	a10, a4
42007dcc:	011b65        	call8	42008f84 <uart_hal_set_hw_flow_ctrl>
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007dcf:	06ad      	mov.n	a10, a6
42007dd1:	e09c81        	l32r	a8, 42000044 <_stext+0x24>
42007dd4:	0008e0        	callx8	a8
    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
42007dd7:	04ad      	mov.n	a10, a4
42007dd9:	fa2565        	call8	42002030 <uart_hal_rxfifo_rst>
    uart_hal_txfifo_rst(&(uart_context[uart_num].hal));
42007ddc:	04ad      	mov.n	a10, a4
42007dde:	fa2265        	call8	42002004 <uart_hal_txfifo_rst>
}
42007de1:	f01d      	retw.n
42007de3:	00          	.byte 00
    ESP_RETURN_ON_FALSE((uart_config), ESP_FAIL, UART_TAG, "param null");
42007de4:	f27c      	movi.n	a2, -1
42007de6:	fffdc6        	j	42007de1 <uart_param_config+0xa9>
42007de9:	000000        	ill

42007dec <uart_intr_config>:
{
42007dec:	004136        	entry	a1, 32
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007def:	7232e6        	bgei	a2, 3, 42007e65 <uart_intr_config+0x79>
    ESP_RETURN_ON_FALSE((intr_conf), ESP_FAIL, UART_TAG, "param null");
42007df2:	06f316        	beqz	a3, 42007e65 <uart_intr_config+0x79>
    uart_hal_clr_intsts_mask(&(uart_context[uart_num].hal), UART_LL_INTR_MASK);
42007df5:	e2a641        	l32r	a4, 42000890 <_stext+0x870>
42007df8:	1122c0        	slli	a2, a2, 4
42007dfb:	542a      	add.n	a5, a4, a2
42007dfd:	0568      	l32i.n	a6, a5, 0
    hw->int_clr.val = mask;
42007dff:	e2bd81        	l32r	a8, 420008f4 <_stext+0x8d4>
42007e02:	fb7c      	movi.n	a11, -1
42007e04:	0020c0        	memw
42007e07:	4689      	s32i.n	a8, a6, 16
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007e09:	624b      	addi.n	a6, a2, 4
42007e0b:	664a      	add.n	a6, a6, a4
42007e0d:	06ad      	mov.n	a10, a6
42007e0f:	e08c81        	l32r	a8, 42000040 <_stext+0x20>
42007e12:	0008e0        	callx8	a8
    if (intr_conf->intr_enable_mask & UART_INTR_RXFIFO_TOUT) {
42007e15:	0388      	l32i.n	a8, a3, 0
42007e17:	00a1b2        	movi	a11, 0x100
42007e1a:	10bb80        	and	a11, a11, a8
42007e1d:	1b8c      	beqz.n	a11, 42007e22 <uart_intr_config+0x36>
        uart_hal_set_rx_timeout(&(uart_context[uart_num].hal), intr_conf->rx_timeout_thresh);
42007e1f:	0403b2        	l8ui	a11, a3, 4
        uart_hal_set_rx_timeout(&(uart_context[uart_num].hal), 0);
42007e22:	20a550        	or	a10, a5, a5
42007e25:	012d65        	call8	420090fc <uart_hal_set_rx_timeout>
    if (intr_conf->intr_enable_mask & UART_INTR_RXFIFO_FULL) {
42007e28:	002382        	l32i	a8, a3, 0
42007e2b:	076807        	bbci	a8, 0, 42007e36 <uart_intr_config+0x4a>
        uart_hal_set_rxfifo_full_thr(&(uart_context[uart_num].hal), intr_conf->rxfifo_full_thresh);
42007e2e:	0603b2        	l8ui	a11, a3, 6
42007e31:	05ad      	mov.n	a10, a5
42007e33:	1033a5        	call8	4201816c <uart_hal_set_rxfifo_full_thr>
    if (intr_conf->intr_enable_mask & UART_INTR_TXFIFO_EMPTY) {
42007e36:	0388      	l32i.n	a8, a3, 0
42007e38:	0a6817        	bbci	a8, 1, 42007e46 <uart_intr_config+0x5a>
        uart_hal_set_txfifo_empty_thr(&(uart_context[uart_num].hal), intr_conf->txfifo_empty_intr_thresh);
42007e3b:	0503b2        	l8ui	a11, a3, 5
42007e3e:	05ad      	mov.n	a10, a5
42007e40:	201110        	or	a1, a1, a1
42007e43:	011ce5        	call8	42009010 <uart_hal_set_txfifo_empty_thr>
    uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), intr_conf->intr_enable_mask);
42007e46:	442a      	add.n	a4, a4, a2
42007e48:	0448      	l32i.n	a4, a4, 0
    hw->int_ena.val |= mask;
42007e4a:	0338      	l32i.n	a3, a3, 0
42007e4c:	0020c0        	memw
42007e4f:	3428      	l32i.n	a2, a4, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007e51:	06ad      	mov.n	a10, a6
42007e53:	202230        	or	a2, a2, a3
42007e56:	0020c0        	memw
42007e59:	3429      	s32i.n	a2, a4, 12
42007e5b:	e07a81        	l32r	a8, 42000044 <_stext+0x24>
42007e5e:	0008e0        	callx8	a8
    return ESP_OK;
42007e61:	020c      	movi.n	a2, 0
}
42007e63:	f01d      	retw.n
    ESP_RETURN_ON_FALSE((intr_conf), ESP_FAIL, UART_TAG, "param null");
42007e65:	f27c      	movi.n	a2, -1
42007e67:	fffe06        	j	42007e63 <uart_intr_config+0x77>
	...

42007e6c <uart_wait_tx_done>:
{
42007e6c:	006136        	entry	a1, 48
42007e6f:	024d      	mov.n	a4, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007e71:	0232a6        	blti	a2, 3, 42007e77 <uart_wait_tx_done+0xb>
42007e74:	005706        	j	42007fd4 <uart_wait_tx_done+0x168>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), ESP_FAIL, UART_TAG, "uart driver error");
42007e77:	e28881        	l32r	a8, 42000898 <_stext+0x878>
42007e7a:	1122e0        	slli	a2, a2, 2
42007e7d:	a07480        	addx4	a7, a4, a8
42007e80:	0129      	s32i.n	a2, a1, 0
42007e82:	002722        	l32i	a2, a7, 0
42007e85:	14b216        	beqz	a2, 42007fd4 <uart_wait_tx_done+0x168>
    TickType_t ticks_start = xTaskGetTickCount();
42007e88:	e29f81        	l32r	a8, 42000904 <_stext+0x8e4>
42007e8b:	0008e0        	callx8	a8
    res = xSemaphoreTake(p_uart_obj[uart_num]->tx_mux, (TickType_t)ticks_to_wait);
42007e8e:	0768      	l32i.n	a6, a7, 0
    TickType_t ticks_start = xTaskGetTickCount();
42007e90:	0a2d      	mov.n	a2, a10
    res = xSemaphoreTake(p_uart_obj[uart_num]->tx_mux, (TickType_t)ticks_to_wait);
42007e92:	3d26a2        	l32i	a10, a6, 244
42007e95:	03bd      	mov.n	a11, a3
42007e97:	e29481        	l32r	a8, 420008e8 <_stext+0x8c8>
42007e9a:	0008e0        	callx8	a8
    if (res == pdFALSE) {
42007e9d:	120a16        	beqz	a10, 42007fc1 <uart_wait_tx_done+0x155>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42007ea0:	e27c61        	l32r	a6, 42000890 <_stext+0x870>
42007ea3:	1144c0        	slli	a4, a4, 4
42007ea6:	944b      	addi.n	a9, a4, 4
42007ea8:	596a      	add.n	a5, a9, a6
42007eaa:	fb7c      	movi.n	a11, -1
42007eac:	05ad      	mov.n	a10, a5
42007eae:	e06481        	l32r	a8, 42000040 <_stext+0x20>
42007eb1:	0008e0        	callx8	a8
    bool disabled = !(uart_hal_get_intr_ena_status(&(uart_context[uart_num].hal)) & UART_INTR_TX_DONE);
42007eb4:	864a      	add.n	a8, a6, a4
42007eb6:	08c8      	l32i.n	a12, a8, 0
    bool is_rs485_mode = UART_IS_MODE_SET(uart_num, UART_MODE_RS485_HALF_DUPLEX);
42007eb8:	07d8      	l32i.n	a13, a7, 0
    return hw->int_ena.val;
42007eba:	0020c0        	memw
42007ebd:	3cb8      	l32i.n	a11, a12, 12
    assert(!(is_rs485_mode &&
42007ebf:	3dd8      	l32i.n	a13, a13, 12
    bool disabled = !(uart_hal_get_intr_ena_status(&(uart_context[uart_num].hal)) & UART_INTR_TX_DONE);
42007ec1:	1a0c      	movi.n	a10, 1
42007ec3:	0f0c      	movi.n	a15, 0
42007ec5:	11aa20        	slli	a10, a10, 14
42007ec8:	180c      	movi.n	a8, 1
42007eca:	10bba0        	and	a11, a11, a10
42007ecd:	0fed      	mov.n	a14, a15
    assert(!(is_rs485_mode &&
42007ecf:	dd0b      	addi.n	a13, a13, -1
    bool disabled = !(uart_hal_get_intr_ena_status(&(uart_context[uart_num].hal)) & UART_INTR_TX_DONE);
42007ed1:	83e8b0        	moveqz	a14, a8, a11
    assert(!(is_rs485_mode &&
42007ed4:	838fd0        	moveqz	a8, a15, a13
    bool disabled = !(uart_hal_get_intr_ena_status(&(uart_context[uart_num].hal)) & UART_INTR_TX_DONE);
42007ed7:	74e0e0        	extui	a14, a14, 0, 8
    assert(!(is_rs485_mode &&
42007eda:	748080        	extui	a8, a8, 0, 8
42007edd:	1c9bf7        	bne	a11, a15, 42007efd <uart_wait_tx_done+0x91>
42007ee0:	1998f7        	bne	a8, a15, 42007efd <uart_wait_tx_done+0x91>
    return hw->int_raw.val;
42007ee3:	0020c0        	memw
42007ee6:	1c88      	l32i.n	a8, a12, 4
42007ee8:	1a08a7        	bnone	a8, a10, 42007f06 <uart_wait_tx_done+0x9a>
42007eeb:	e283d1        	l32r	a13, 420008f8 <_stext+0x8d8>
42007eee:	e283c1        	l32r	a12, 420008fc <_stext+0x8dc>
42007ef1:	e283a1        	l32r	a10, 42000900 <_stext+0x8e0>
42007ef4:	6aa4b2        	movi	a11, 0x46a
42007ef7:	e06381        	l32r	a8, 42000084 <_stext+0x64>
42007efa:	0008e0        	callx8	a8
    if (disabled && !is_rs485_mode) {
42007efd:	5e8c      	beqz.n	a14, 42007f06 <uart_wait_tx_done+0x9a>
42007eff:	388c      	beqz.n	a8, 42007f06 <uart_wait_tx_done+0x9a>
    hw->int_clr.val = mask;
42007f01:	0020c0        	memw
42007f04:	4ca9      	s32i.n	a10, a12, 16
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007f06:	05ad      	mov.n	a10, a5
42007f08:	e04f81        	l32r	a8, 42000044 <_stext+0x24>
42007f0b:	0008e0        	callx8	a8
    xSemaphoreTake(p_uart_obj[uart_num]->tx_done_sem, 0);
42007f0e:	e26291        	l32r	a9, 42000898 <_stext+0x878>
42007f11:	0188      	l32i.n	a8, a1, 0
42007f13:	0b0c      	movi.n	a11, 0
42007f15:	c98a      	add.n	a12, a9, a8
42007f17:	0c88      	l32i.n	a8, a12, 0
42007f19:	3f28a2        	l32i	a10, a8, 252
42007f1c:	11c9      	s32i.n	a12, a1, 4
42007f1e:	e27281        	l32r	a8, 420008e8 <_stext+0x8c8>
42007f21:	0008e0        	callx8	a8
    esp_rom_delay_us(2);
42007f24:	2a0c      	movi.n	a10, 2
42007f26:	e08e81        	l32r	a8, 42000160 <_stext+0x140>
42007f29:	0008e0        	callx8	a8
    if (uart_hal_is_tx_idle(&(uart_context[uart_num].hal))) {
42007f2c:	864a      	add.n	a8, a6, a4
42007f2e:	08a8      	l32i.n	a10, a8, 0
    return ((hw->status.txfifo_cnt == 0) && (hw->fsm_status.st_utx_out == 0));
42007f30:	11c8      	l32i.n	a12, a1, 4
42007f32:	0020c0        	memw
42007f35:	7a88      	l32i.n	a8, a10, 28
42007f37:	958080        	extui	a8, a8, 16, 10
42007f3a:	28ec      	bnez.n	a8, 42007f60 <uart_wait_tx_done+0xf4>
42007f3c:	0020c0        	memw
42007f3f:	1b2a82        	l32i	a8, a10, 108
42007f42:	348480        	extui	a8, a8, 4, 4
42007f45:	78dc      	bnez.n	a8, 42007f60 <uart_wait_tx_done+0xf4>
        xSemaphoreGive(p_uart_obj[uart_num]->tx_mux);
42007f47:	0c28      	l32i.n	a2, a12, 0
42007f49:	08dd      	mov.n	a13, a8
42007f4b:	3d22a2        	l32i	a10, a2, 244
42007f4e:	08cd      	mov.n	a12, a8
42007f50:	08bd      	mov.n	a11, a8
42007f52:	1189      	s32i.n	a8, a1, 4
    xSemaphoreGive(p_uart_obj[uart_num]->tx_mux);
42007f54:	e1d681        	l32r	a8, 420006ac <_stext+0x68c>
42007f57:	0008e0        	callx8	a8
    return ESP_OK;
42007f5a:	020c      	movi.n	a2, 0
}
42007f5c:	f01d      	retw.n
42007f5e:	00          	.byte 00
42007f5f:	00          	.byte 00
42007f60:	fb7c      	movi.n	a11, -1
42007f62:	05ad      	mov.n	a10, a5
42007f64:	e03781        	l32r	a8, 42000040 <_stext+0x20>
42007f67:	0008e0        	callx8	a8
    uart_hal_ena_intr_mask(&(uart_context[uart_num].hal), UART_INTR_TX_DONE);
42007f6a:	664a      	add.n	a6, a6, a4
42007f6c:	0688      	l32i.n	a8, a6, 0
    hw->int_ena.val |= mask;
42007f6e:	160c      	movi.n	a6, 1
42007f70:	0020c0        	memw
42007f73:	3848      	l32i.n	a4, a8, 12
42007f75:	116620        	slli	a6, a6, 14
42007f78:	204460        	or	a4, a4, a6
42007f7b:	0020c0        	memw
42007f7e:	3849      	s32i.n	a4, a8, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42007f80:	20a550        	or	a10, a5, a5
42007f83:	e03081        	l32r	a8, 42000044 <_stext+0x24>
42007f86:	0008e0        	callx8	a8
    TickType_t ticks_end = xTaskGetTickCount();
42007f89:	e25e81        	l32r	a8, 42000904 <_stext+0x8e4>
42007f8c:	0008e0        	callx8	a8
    if (ticks_end - ticks_start > ticks_to_wait) {
42007f8f:	c04a20        	sub	a4, a10, a2
        ticks_to_wait = 0;
42007f92:	0b0c      	movi.n	a11, 0
    if (ticks_end - ticks_start > ticks_to_wait) {
42007f94:	043347        	bltu	a3, a4, 42007f9c <uart_wait_tx_done+0x130>
        ticks_to_wait = ticks_to_wait - (ticks_end - ticks_start);
42007f97:	332a      	add.n	a3, a3, a2
42007f99:	c0b3a0        	sub	a11, a3, a10
    res = xSemaphoreTake(p_uart_obj[uart_num]->tx_done_sem, (TickType_t)ticks_to_wait);
42007f9c:	0128      	l32i.n	a2, a1, 0
42007f9e:	e23e91        	l32r	a9, 42000898 <_stext+0x878>
42007fa1:	592a      	add.n	a5, a9, a2
42007fa3:	0528      	l32i.n	a2, a5, 0
42007fa5:	3f22a2        	l32i	a10, a2, 252
42007fa8:	e25081        	l32r	a8, 420008e8 <_stext+0x8c8>
42007fab:	0008e0        	callx8	a8
    if (res == pdFALSE) {
42007fae:	0528      	l32i.n	a2, a5, 0
42007fb0:	4adc      	bnez.n	a10, 42007fc8 <uart_wait_tx_done+0x15c>
        xSemaphoreGive(p_uart_obj[uart_num]->tx_mux);
42007fb2:	0add      	mov.n	a13, a10
42007fb4:	0acd      	mov.n	a12, a10
42007fb6:	0abd      	mov.n	a11, a10
42007fb8:	3d22a2        	l32i	a10, a2, 244
42007fbb:	e1bc81        	l32r	a8, 420006ac <_stext+0x68c>
42007fbe:	0008e0        	callx8	a8
        return ESP_ERR_TIMEOUT;
42007fc1:	07a122        	movi	a2, 0x107
42007fc4:	ffe506        	j	42007f5c <uart_wait_tx_done+0xf0>
42007fc7:	00          	.byte 00
    xSemaphoreGive(p_uart_obj[uart_num]->tx_mux);
42007fc8:	0d0c      	movi.n	a13, 0
42007fca:	3d22a2        	l32i	a10, a2, 244
42007fcd:	0dcd      	mov.n	a12, a13
42007fcf:	0dbd      	mov.n	a11, a13
42007fd1:	ffdfc6        	j	42007f54 <uart_wait_tx_done+0xe8>
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42007fd4:	f27c      	movi.n	a2, -1
42007fd6:	ffe086        	j	42007f5c <uart_wait_tx_done+0xf0>
42007fd9:	000000        	ill

42007fdc <uart_write_bytes>:
{
42007fdc:	004136        	entry	a1, 32
42007fdf:	02ad      	mov.n	a10, a2
42007fe1:	03bd      	mov.n	a11, a3
42007fe3:	04cd      	mov.n	a12, a4
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), (-1), UART_TAG, "uart_num error");
42007fe5:	fd7c      	movi.n	a13, -1
42007fe7:	2132e6        	bgei	a2, 3, 4200800c <uart_write_bytes+0x30>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num] != NULL), (-1), UART_TAG, "uart driver error");
42007fea:	e22b81        	l32r	a8, 42000898 <_stext+0x878>
42007fed:	1d0c      	movi.n	a13, 1
42007fef:	a08280        	addx4	a8, a2, a8
42007ff2:	0898      	l32i.n	a9, a8, 0
42007ff4:	080c      	movi.n	a8, 0
42007ff6:	838d90        	moveqz	a8, a13, a9
    ESP_RETURN_ON_FALSE(src, (-1), UART_TAG, "buffer null");
42007ff9:	749080        	extui	a9, a8, 0, 8
42007ffc:	08dc      	bnez.n	a8, 42008010 <uart_write_bytes+0x34>
42007ffe:	93d930        	movnez	a13, a9, a3
42008001:	bdcc      	bnez.n	a13, 42008010 <uart_write_bytes+0x34>
    if (size == 0) {
42008003:	548c      	beqz.n	a4, 4200800c <uart_write_bytes+0x30>
42008005:	0ded      	mov.n	a14, a13
42008007:	ff97a5        	call8	42007980 <uart_tx_all$part$0>
4200800a:	0add      	mov.n	a13, a10
}
4200800c:	0d2d      	mov.n	a2, a13
4200800e:	f01d      	retw.n
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), (-1), UART_TAG, "uart_num error");
42008010:	fd7c      	movi.n	a13, -1
42008012:	fffd86        	j	4200800c <uart_write_bytes+0x30>
42008015:	000000        	ill

42008018 <uart_read_bytes>:
{
42008018:	008136        	entry	a1, 64
4200801b:	5139      	s32i.n	a3, a1, 20
    ESP_RETURN_ON_FALSE((buf), (-1), UART_TAG, "uart data null");
4200801d:	5188      	l32i.n	a8, a1, 20
4200801f:	060c      	movi.n	a6, 0
{
42008021:	043d      	mov.n	a3, a4
    ESP_RETURN_ON_FALSE((buf), (-1), UART_TAG, "uart data null");
42008023:	140c      	movi.n	a4, 1
42008025:	934680        	movnez	a4, a6, a8
42008028:	746040        	extui	a6, a4, 0, 8
4200802b:	b4cc      	bnez.n	a4, 4200803a <uart_read_bytes+0x22>
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), (-1), UART_TAG, "uart_num error");
4200802d:	0932e6        	bgei	a2, 3, 4200803a <uart_read_bytes+0x22>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), (-1), UART_TAG, "uart driver error");
42008030:	e21a71        	l32r	a7, 42000898 <_stext+0x878>
42008033:	a07270        	addx4	a7, a2, a7
42008036:	0748      	l32i.n	a4, a7, 0
42008038:	54cc      	bnez.n	a4, 42008041 <uart_read_bytes+0x29>
    ESP_RETURN_ON_FALSE((buf), (-1), UART_TAG, "uart data null");
4200803a:	f27c      	movi.n	a2, -1
}
4200803c:	f01d      	retw.n
4200803e:	00          	.byte 00
4200803f:	00          	.byte 00
42008040:	00          	.byte 00
    if (xSemaphoreTake(p_uart_obj[uart_num]->rx_mux, (TickType_t)ticks_to_wait) != pdTRUE) {
42008041:	3c24a2        	l32i	a10, a4, 240
42008044:	20b550        	or	a11, a5, a5
42008047:	e22881        	l32r	a8, 420008e8 <_stext+0x8c8>
4200804a:	0008e0        	callx8	a8
4200804d:	e91a66        	bnei	a10, 1, 4200803a <uart_read_bytes+0x22>
        UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42008050:	e21081        	l32r	a8, 42000890 <_stext+0x870>
42008053:	1142c0        	slli	a4, a2, 4
42008056:	444b      	addi.n	a4, a4, 4
42008058:	848a      	add.n	a8, a4, a8
4200805a:	4189      	s32i.n	a8, a1, 16
        if (p_uart_obj[uart_num]->rx_cur_remain == 0) {
4200805c:	0788      	l32i.n	a8, a7, 0
    while (length) {
4200805e:	a3cc      	bnez.n	a3, 4200806c <uart_read_bytes+0x54>
    xSemaphoreGive(p_uart_obj[uart_num]->rx_mux);
42008060:	3c28a2        	l32i	a10, a8, 240
42008063:	03dd      	mov.n	a13, a3
42008065:	03cd      	mov.n	a12, a3
42008067:	03bd      	mov.n	a11, a3
42008069:	002946        	j	42008112 <uart_read_bytes+0xfa>
        if (p_uart_obj[uart_num]->rx_cur_remain == 0) {
4200806c:	88a8      	l32i.n	a10, a8, 32
4200806e:	8adc      	bnez.n	a10, 4200808a <uart_read_bytes+0x72>
            data = (uint8_t *) xRingbufferReceive(p_uart_obj[uart_num]->rx_ring_buf, &size, (TickType_t) ticks_to_wait);
42008070:	3a28a2        	l32i	a10, a8, 232
42008073:	05cd      	mov.n	a12, a5
42008075:	01bd      	mov.n	a11, a1
42008077:	e22481        	l32r	a8, 42000908 <_stext+0x8e8>
4200807a:	0008e0        	callx8	a8
            if (data) {
4200807d:	07ba16        	beqz	a10, 420080fc <uart_read_bytes+0xe4>
                p_uart_obj[uart_num]->rx_head_ptr = data;
42008080:	0788      	l32i.n	a8, a7, 0
42008082:	a8a9      	s32i.n	a10, a8, 40
                p_uart_obj[uart_num]->rx_ptr = data;
42008084:	98a9      	s32i.n	a10, a8, 36
                p_uart_obj[uart_num]->rx_cur_remain = size;
42008086:	01a8      	l32i.n	a10, a1, 0
42008088:	88a9      	s32i.n	a10, a8, 32
        if (p_uart_obj[uart_num]->rx_cur_remain > length) {
4200808a:	07a8      	l32i.n	a10, a7, 0
4200808c:	8a88      	l32i.n	a8, a10, 32
        memcpy((uint8_t *)buf + copy_len, p_uart_obj[uart_num]->rx_ptr, len_tmp);
4200808e:	9ab8      	l32i.n	a11, a10, 36
            len_tmp = length;
42008090:	634380        	minu	a4, a3, a8
        memcpy((uint8_t *)buf + copy_len, p_uart_obj[uart_num]->rx_ptr, len_tmp);
42008093:	5188      	l32i.n	a8, a1, 20
42008095:	04cd      	mov.n	a12, a4
42008097:	80a860        	add	a10, a8, a6
4200809a:	e04c81        	l32r	a8, 420001cc <_stext+0x1ac>
4200809d:	0008e0        	callx8	a8
420080a0:	0421a2        	l32i	a10, a1, 16
420080a3:	ffafb2        	movi	a11, -1
420080a6:	dfe681        	l32r	a8, 42000040 <_stext+0x20>
420080a9:	0008e0        	callx8	a8
        p_uart_obj[uart_num]->rx_buffered_len -= len_tmp;
420080ac:	07c8      	l32i.n	a12, a7, 0
        uart_pattern_queue_update(uart_num, len_tmp);
420080ae:	04bd      	mov.n	a11, a4
        p_uart_obj[uart_num]->rx_buffered_len -= len_tmp;
420080b0:	5ca8      	l32i.n	a10, a12, 20
        copy_len += len_tmp;
420080b2:	664a      	add.n	a6, a6, a4
        p_uart_obj[uart_num]->rx_buffered_len -= len_tmp;
420080b4:	c0aa40        	sub	a10, a10, a4
420080b7:	5ca9      	s32i.n	a10, a12, 20
        uart_pattern_queue_update(uart_num, len_tmp);
420080b9:	02ad      	mov.n	a10, a2
420080bb:	61c9      	s32i.n	a12, a1, 24
420080bd:	feeba5        	call8	42006f78 <uart_pattern_queue_update$isra$0>
        p_uart_obj[uart_num]->rx_ptr += len_tmp;
420080c0:	61c8      	l32i.n	a12, a1, 24
        length -= len_tmp;
420080c2:	c03340        	sub	a3, a3, a4
        p_uart_obj[uart_num]->rx_ptr += len_tmp;
420080c5:	9ca8      	l32i.n	a10, a12, 36
420080c7:	aa4a      	add.n	a10, a10, a4
420080c9:	9ca9      	s32i.n	a10, a12, 36
        UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420080cb:	41a8      	l32i.n	a10, a1, 16
420080cd:	dfdd81        	l32r	a8, 42000044 <_stext+0x24>
420080d0:	0008e0        	callx8	a8
        p_uart_obj[uart_num]->rx_cur_remain -= len_tmp;
420080d3:	07a8      	l32i.n	a10, a7, 0
420080d5:	8ac8      	l32i.n	a12, a10, 32
420080d7:	c0cc40        	sub	a12, a12, a4
420080da:	8ac9      	s32i.n	a12, a10, 32
        if (p_uart_obj[uart_num]->rx_cur_remain == 0) {
420080dc:	f7cc56        	bnez	a12, 4200805c <uart_read_bytes+0x44>
            vRingbufferReturnItem(p_uart_obj[uart_num]->rx_ring_buf, p_uart_obj[uart_num]->rx_head_ptr);
420080df:	aab8      	l32i.n	a11, a10, 40
420080e1:	3a2aa2        	l32i	a10, a10, 232
420080e4:	61c9      	s32i.n	a12, a1, 24
420080e6:	e20981        	l32r	a8, 4200090c <_stext+0x8ec>
420080e9:	0008e0        	callx8	a8
            p_uart_obj[uart_num]->rx_head_ptr = NULL;
420080ec:	0788      	l32i.n	a8, a7, 0
420080ee:	61c8      	l32i.n	a12, a1, 24
            uart_check_buf_full(uart_num);
420080f0:	02ad      	mov.n	a10, a2
            p_uart_obj[uart_num]->rx_head_ptr = NULL;
420080f2:	a8c9      	s32i.n	a12, a8, 40
            p_uart_obj[uart_num]->rx_ptr = NULL;
420080f4:	98c9      	s32i.n	a12, a8, 36
            uart_check_buf_full(uart_num);
420080f6:	fee1e5        	call8	42006f14 <uart_check_buf_full>
420080f9:	ffd7c6        	j	4200805c <uart_read_bytes+0x44>
                if (uart_check_buf_full(uart_num)) {
420080fc:	20a220        	or	a10, a2, a2
420080ff:	fee165        	call8	42006f14 <uart_check_buf_full>
42008102:	f56a56        	bnez	a10, 4200805c <uart_read_bytes+0x44>
                    xSemaphoreGive(p_uart_obj[uart_num]->rx_mux);
42008105:	002722        	l32i	a2, a7, 0
42008108:	20daa0        	or	a13, a10, a10
4200810b:	0acd      	mov.n	a12, a10
4200810d:	0abd      	mov.n	a11, a10
4200810f:	3c22a2        	l32i	a10, a2, 240
    xSemaphoreGive(p_uart_obj[uart_num]->rx_mux);
42008112:	e16681        	l32r	a8, 420006ac <_stext+0x68c>
42008115:	0008e0        	callx8	a8
    return copy_len;
42008118:	062d      	mov.n	a2, a6
4200811a:	ffc786        	j	4200803c <uart_read_bytes+0x24>
4200811d:	000000        	ill

42008120 <uart_get_buffered_data_len>:
{
42008120:	004136        	entry	a1, 32
42008123:	028d      	mov.n	a8, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42008125:	f27c      	movi.n	a2, -1
42008127:	2d38e6        	bgei	a8, 3, 42008158 <uart_get_buffered_data_len+0x38>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), ESP_FAIL, UART_TAG, "uart driver error");
4200812a:	e1db41        	l32r	a4, 42000898 <_stext+0x878>
4200812d:	a04840        	addx4	a4, a8, a4
42008130:	0498      	l32i.n	a9, a4, 0
42008132:	29ac      	beqz.n	a9, 42008158 <uart_get_buffered_data_len+0x38>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42008134:	1128c0        	slli	a2, a8, 4
42008137:	e1d681        	l32r	a8, 42000890 <_stext+0x870>
4200813a:	224b      	addi.n	a2, a2, 4
4200813c:	228a      	add.n	a2, a2, a8
4200813e:	fb7c      	movi.n	a11, -1
42008140:	02ad      	mov.n	a10, a2
42008142:	dfbf81        	l32r	a8, 42000040 <_stext+0x20>
42008145:	0008e0        	callx8	a8
    *size = p_uart_obj[uart_num]->rx_buffered_len;
42008148:	0448      	l32i.n	a4, a4, 0
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
4200814a:	02ad      	mov.n	a10, a2
    *size = p_uart_obj[uart_num]->rx_buffered_len;
4200814c:	5448      	l32i.n	a4, a4, 20
    return ESP_OK;
4200814e:	020c      	movi.n	a2, 0
    *size = p_uart_obj[uart_num]->rx_buffered_len;
42008150:	0349      	s32i.n	a4, a3, 0
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42008152:	dfbc81        	l32r	a8, 42000044 <_stext+0x24>
42008155:	0008e0        	callx8	a8
}
42008158:	f01d      	retw.n
	...

4200815c <uart_flush>:
{
4200815c:	008136        	entry	a1, 64
4200815f:	025d      	mov.n	a5, a2
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42008161:	f27c      	movi.n	a2, -1
42008163:	0235a6        	blti	a5, 3, 42008169 <uart_flush+0xd>
42008166:	003c86        	j	4200825c <uart_flush+0x100>
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), ESP_FAIL, UART_TAG, "uart driver error");
42008169:	e1cb31        	l32r	a3, 42000898 <_stext+0x878>
4200816c:	1125e0        	slli	a2, a5, 2
4200816f:	4129      	s32i.n	a2, a1, 16
42008171:	a02530        	addx4	a2, a5, a3
42008174:	0238      	l32i.n	a3, a2, 0
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
42008176:	ffaf22        	movi	a2, -1
    ESP_RETURN_ON_FALSE((p_uart_obj[uart_num]), ESP_FAIL, UART_TAG, "uart driver error");
42008179:	0df316        	beqz	a3, 4200825c <uart_flush+0x100>
    xSemaphoreTake(p_uart->rx_mux, (TickType_t)portMAX_DELAY);
4200817c:	3c23a2        	l32i	a10, a3, 240
4200817f:	20b220        	or	a11, a2, a2
42008182:	e1d981        	l32r	a8, 420008e8 <_stext+0x8c8>
42008185:	0008e0        	callx8	a8
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42008188:	1175c0        	slli	a7, a5, 4
4200818b:	e1c161        	l32r	a6, 42000890 <_stext+0x870>
4200818e:	474b      	addi.n	a4, a7, 4
42008190:	446a      	add.n	a4, a4, a6
42008192:	02bd      	mov.n	a11, a2
42008194:	04ad      	mov.n	a10, a4
    uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT);
42008196:	267a      	add.n	a2, a6, a7
42008198:	dfaa81        	l32r	a8, 42000040 <_stext+0x20>
4200819b:	0008e0        	callx8	a8
4200819e:	0268      	l32i.n	a6, a2, 0
    hw->int_ena.val &= (~mask);
420081a0:	feae82        	movi	a8, 0xfffffefe
420081a3:	0020c0        	memw
420081a6:	3628      	l32i.n	a2, a6, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420081a8:	04ad      	mov.n	a10, a4
420081aa:	102280        	and	a2, a2, a8
420081ad:	0020c0        	memw
420081b0:	3629      	s32i.n	a2, a6, 12
420081b2:	dfa481        	l32r	a8, 42000044 <_stext+0x24>
420081b5:	0008e0        	callx8	a8
            p_uart->rx_ptr = NULL;
420081b8:	020c      	movi.n	a2, 0
        if (p_uart->rx_head_ptr) {
420081ba:	a3b8      	l32i.n	a11, a3, 40
420081bc:	9bbc      	beqz.n	a11, 420081f9 <uart_flush+0x9d>
            vRingbufferReturnItem(p_uart->rx_ring_buf, p_uart->rx_head_ptr);
420081be:	3a23a2        	l32i	a10, a3, 232
420081c1:	e1d281        	l32r	a8, 4200090c <_stext+0x8ec>
420081c4:	0008e0        	callx8	a8
420081c7:	fb7c      	movi.n	a11, -1
420081c9:	04ad      	mov.n	a10, a4
420081cb:	df9d81        	l32r	a8, 42000040 <_stext+0x20>
420081ce:	0008e0        	callx8	a8
            p_uart_obj[uart_num]->rx_buffered_len -= p_uart->rx_cur_remain;
420081d1:	e1b181        	l32r	a8, 42000898 <_stext+0x878>
420081d4:	4198      	l32i.n	a9, a1, 16
420081d6:	83b8      	l32i.n	a11, a3, 32
420081d8:	689a      	add.n	a6, a8, a9
420081da:	0688      	l32i.n	a8, a6, 0
            uart_pattern_queue_update(uart_num, p_uart->rx_cur_remain);
420081dc:	05ad      	mov.n	a10, a5
            p_uart_obj[uart_num]->rx_buffered_len -= p_uart->rx_cur_remain;
420081de:	052862        	l32i	a6, a8, 20
420081e1:	c066b0        	sub	a6, a6, a11
420081e4:	056862        	s32i	a6, a8, 20
            uart_pattern_queue_update(uart_num, p_uart->rx_cur_remain);
420081e7:	fed925        	call8	42006f78 <uart_pattern_queue_update$isra$0>
            UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420081ea:	04ad      	mov.n	a10, a4
420081ec:	df9681        	l32r	a8, 42000044 <_stext+0x24>
420081ef:	0008e0        	callx8	a8
            p_uart->rx_ptr = NULL;
420081f2:	9329      	s32i.n	a2, a3, 36
            p_uart->rx_cur_remain = 0;
420081f4:	8329      	s32i.n	a2, a3, 32
            p_uart->rx_head_ptr = NULL;
420081f6:	0a6322        	s32i	a2, a3, 40
        data = (uint8_t*) xRingbufferReceive(p_uart->rx_ring_buf, &size, (TickType_t) 0);
420081f9:	3a23a2        	l32i	a10, a3, 232
420081fc:	01bd      	mov.n	a11, a1
420081fe:	02cd      	mov.n	a12, a2
42008200:	e1c281        	l32r	a8, 42000908 <_stext+0x8e8>
42008203:	0008e0        	callx8	a8
42008206:	0a8d      	mov.n	a8, a10
42008208:	5189      	s32i.n	a8, a1, 20
4200820a:	ffafb2        	movi	a11, -1
4200820d:	20a440        	or	a10, a4, a4
        if(data == NULL) {
42008210:	04c856        	bnez	a8, 42008260 <uart_flush+0x104>
42008213:	df8b81        	l32r	a8, 42000040 <_stext+0x20>
42008216:	0008e0        	callx8	a8
            if( p_uart_obj[uart_num]->rx_buffered_len != 0 ) {
42008219:	e19fa1        	l32r	a10, 42000898 <_stext+0x878>
4200821c:	4168      	l32i.n	a6, a1, 16
4200821e:	5188      	l32i.n	a8, a1, 20
42008220:	2a6a      	add.n	a2, a10, a6
42008222:	0228      	l32i.n	a2, a2, 0
42008224:	5268      	l32i.n	a6, a2, 20
42008226:	068c      	beqz.n	a6, 4200822a <uart_flush+0xce>
                p_uart_obj[uart_num]->rx_buffered_len = 0;
42008228:	5289      	s32i.n	a8, a2, 20
            p_uart_obj[uart_num]->rx_buffer_full_flg = false;
4200822a:	060c      	movi.n	a6, 0
4200822c:	1c4262        	s8i	a6, a2, 28
            UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
4200822f:	04ad      	mov.n	a10, a4
42008231:	df8481        	l32r	a8, 42000044 <_stext+0x24>
42008234:	0008e0        	callx8	a8
    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
42008237:	e19681        	l32r	a8, 42000890 <_stext+0x870>
    p_uart->rx_ptr = NULL;
4200823a:	020c      	movi.n	a2, 0
    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
4200823c:	a87a      	add.n	a10, a8, a7
    p_uart->rx_ptr = NULL;
4200823e:	9329      	s32i.n	a2, a3, 36
    p_uart->rx_cur_remain = 0;
42008240:	8329      	s32i.n	a2, a3, 32
    p_uart->rx_head_ptr = NULL;
42008242:	a329      	s32i.n	a2, a3, 40
    uart_hal_rxfifo_rst(&(uart_context[uart_num].hal));
42008244:	f9dea5        	call8	42002030 <uart_hal_rxfifo_rst>
    uart_reenable_intr_mask(uart_num, UART_INTR_RXFIFO_TOUT | UART_INTR_RXFIFO_FULL);
42008247:	20a550        	or	a10, a5, a5
4200824a:	fec7a5        	call8	42006ec4 <uart_reenable_intr_mask$constprop$0$isra$0>
    xSemaphoreGive(p_uart->rx_mux);
4200824d:	3c23a2        	l32i	a10, a3, 240
42008250:	02dd      	mov.n	a13, a2
42008252:	02cd      	mov.n	a12, a2
42008254:	02bd      	mov.n	a11, a2
42008256:	e11581        	l32r	a8, 420006ac <_stext+0x68c>
42008259:	0008e0        	callx8	a8
}
4200825c:	f01d      	retw.n
4200825e:	00          	.byte 00
4200825f:	00          	.byte 00
42008260:	df7881        	l32r	a8, 42000040 <_stext+0x20>
42008263:	0008e0        	callx8	a8
        p_uart_obj[uart_num]->rx_buffered_len -= size;
42008266:	e18c91        	l32r	a9, 42000898 <_stext+0x878>
42008269:	41a8      	l32i.n	a10, a1, 16
4200826b:	01b8      	l32i.n	a11, a1, 0
4200826d:	69aa      	add.n	a6, a9, a10
4200826f:	06a8      	l32i.n	a10, a6, 0
42008271:	5a98      	l32i.n	a9, a10, 20
42008273:	c099b0        	sub	a9, a9, a11
42008276:	5a99      	s32i.n	a9, a10, 20
        uart_pattern_queue_update(uart_num, size);
42008278:	05ad      	mov.n	a10, a5
4200827a:	fecfe5        	call8	42006f78 <uart_pattern_queue_update$isra$0>
        UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
4200827d:	04ad      	mov.n	a10, a4
4200827f:	df7181        	l32r	a8, 42000044 <_stext+0x24>
42008282:	0008e0        	callx8	a8
        vRingbufferReturnItem(p_uart->rx_ring_buf, data);
42008285:	5188      	l32i.n	a8, a1, 20
42008287:	3a23a2        	l32i	a10, a3, 232
4200828a:	08bd      	mov.n	a11, a8
4200828c:	e1a081        	l32r	a8, 4200090c <_stext+0x8ec>
4200828f:	0008e0        	callx8	a8
        if (p_uart_obj[uart_num]->rx_buffer_full_flg) {
42008292:	0688      	l32i.n	a8, a6, 0
42008294:	1c0892        	l8ui	a9, a8, 28
42008297:	f1f916        	beqz	a9, 420081ba <uart_flush+0x5e>
            BaseType_t res = xRingbufferSend(p_uart_obj[uart_num]->rx_ring_buf, p_uart_obj[uart_num]->rx_data_buf, p_uart_obj[uart_num]->rx_stash_len, 1);
4200829a:	ac08c2        	l8ui	a12, a8, 172
4200829d:	3a28a2        	l32i	a10, a8, 232
420082a0:	01a0d2        	movi	a13, 1
420082a3:	2cc8b2        	addi	a11, a8, 44
420082a6:	e18081        	l32r	a8, 420008a8 <_stext+0x888>
420082a9:	0008e0        	callx8	a8
            if (res == pdTRUE) {
420082ac:	021a26        	beqi	a10, 1, 420082b2 <uart_flush+0x156>
420082af:	ffc1c6        	j	420081ba <uart_flush+0x5e>
420082b2:	fb7c      	movi.n	a11, -1
420082b4:	04ad      	mov.n	a10, a4
420082b6:	df6281        	l32r	a8, 42000040 <_stext+0x20>
420082b9:	0008e0        	callx8	a8
                p_uart_obj[uart_num]->rx_buffered_len += p_uart_obj[uart_num]->rx_stash_len;
420082bc:	0668      	l32i.n	a6, a6, 0
                UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420082be:	04ad      	mov.n	a10, a4
                p_uart_obj[uart_num]->rx_buffered_len += p_uart_obj[uart_num]->rx_stash_len;
420082c0:	5688      	l32i.n	a8, a6, 20
420082c2:	ac0692        	l8ui	a9, a6, 172
420082c5:	889a      	add.n	a8, a8, a9
420082c7:	5689      	s32i.n	a8, a6, 20
                p_uart_obj[uart_num]->rx_buffer_full_flg = false;
420082c9:	080c      	movi.n	a8, 0
420082cb:	1c4682        	s8i	a8, a6, 28
                UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
420082ce:	df5d81        	l32r	a8, 42000044 <_stext+0x24>
420082d1:	0008e0        	callx8	a8
420082d4:	ffb886        	j	420081ba <uart_flush+0x5e>
	...

420082d8 <uart_driver_delete>:
    return ret;
}

//Make sure no other tasks are still using UART before you call this function
esp_err_t uart_driver_delete(uart_port_t uart_num)
{
420082d8:	008136        	entry	a1, 64
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420082db:	ffaf62        	movi	a6, -1
420082de:	0232a6        	blti	a2, 3, 420082e4 <uart_driver_delete+0xc>
420082e1:	002d46        	j	4200839a <uart_driver_delete+0xc2>
    if (p_uart_obj[uart_num] == NULL) {
420082e4:	e16d31        	l32r	a3, 42000898 <_stext+0x878>
        ESP_LOGI(UART_TAG, "ALREADY NULL");
        return ESP_OK;
420082e7:	060c      	movi.n	a6, 0
    if (p_uart_obj[uart_num] == NULL) {
420082e9:	a09230        	addx4	a9, a2, a3
420082ec:	0938      	l32i.n	a3, a9, 0
420082ee:	1172e0        	slli	a7, a2, 2
420082f1:	029367        	bne	a3, a6, 420082f7 <uart_driver_delete+0x1f>
420082f4:	002886        	j	4200839a <uart_driver_delete+0xc2>
    }
    esp_intr_free(p_uart_obj[uart_num]->intr_handle);
420082f7:	23a8      	l32i.n	a10, a3, 8
420082f9:	4199      	s32i.n	a9, a1, 16
420082fb:	fa8ae5        	call8	42002ba8 <esp_intr_free>
    uart_disable_rx_intr(uart_num);
420082fe:	02ad      	mov.n	a10, a2
42008300:	ff6025        	call8	42007904 <uart_disable_rx_intr>
    uart_disable_tx_intr(uart_num);
42008303:	02ad      	mov.n	a10, a2
42008305:	ff6125        	call8	42007918 <uart_disable_tx_intr>
    UART_ENTER_CRITICAL(&(uart_context[uart_num].spinlock));
42008308:	1152c0        	slli	a5, a2, 4
4200830b:	e16141        	l32r	a4, 42000890 <_stext+0x870>
4200830e:	354b      	addi.n	a3, a5, 4
42008310:	334a      	add.n	a3, a3, a4
42008312:	fb7c      	movi.n	a11, -1
42008314:	20a330        	or	a10, a3, a3
42008317:	df4a81        	l32r	a8, 42000040 <_stext+0x20>
4200831a:	0008e0        	callx8	a8
    if (p_uart_obj[uart_num]->rx_pattern_pos.data != NULL) {
4200831d:	4198      	l32i.n	a9, a1, 16
4200831f:	0998      	l32i.n	a9, a9, 0
42008321:	3029b2        	l32i	a11, a9, 192
42008324:	081b67        	beq	a11, a6, 42008330 <uart_driver_delete+0x58>
        p_uart_obj[uart_num]->rx_pattern_pos.data = NULL;
42008327:	306962        	s32i	a6, a9, 192
        p_uart_obj[uart_num]->rx_pattern_pos.wr = 0;
4200832a:	2d6962        	s32i	a6, a9, 180
        p_uart_obj[uart_num]->rx_pattern_pos.rd = 0;
4200832d:	2e6962        	s32i	a6, a9, 184
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42008330:	03ad      	mov.n	a10, a3
42008332:	41b9      	s32i.n	a11, a1, 16
42008334:	df4481        	l32r	a8, 42000044 <_stext+0x24>
42008337:	0008e0        	callx8	a8
    free(pdata);
4200833a:	41b8      	l32i.n	a11, a1, 16
4200833c:	0bad      	mov.n	a10, a11
4200833e:	df3981        	l32r	a8, 42000024 <_stext+0x4>
42008341:	0008e0        	callx8	a8
    uart_pattern_link_free(uart_num);
    uart_free_driver_obj(p_uart_obj[uart_num]);
42008344:	e15581        	l32r	a8, 42000898 <_stext+0x878>
42008347:	687a      	add.n	a6, a8, a7
42008349:	06a8      	l32i.n	a10, a6, 0
    p_uart_obj[uart_num] = NULL;
4200834b:	070c      	movi.n	a7, 0
    uart_free_driver_obj(p_uart_obj[uart_num]);
4200834d:	feb0a5        	call8	42006e58 <uart_free_driver_obj>

#if SOC_UART_SUPPORT_RTC_CLK
    uart_sclk_t sclk = 0;
    uart_hal_get_sclk(&(uart_context[uart_num].hal), &sclk);
42008350:	01bd      	mov.n	a11, a1
    p_uart_obj[uart_num] = NULL;
42008352:	0679      	s32i.n	a7, a6, 0
    uart_hal_get_sclk(&(uart_context[uart_num].hal), &sclk);
42008354:	a45a      	add.n	a10, a4, a5
    uart_sclk_t sclk = 0;
42008356:	0179      	s32i.n	a7, a1, 0
    uart_hal_get_sclk(&(uart_context[uart_num].hal), &sclk);
42008358:	0fcf65        	call8	42018050 <uart_hal_get_sclk>
    if (sclk == UART_SCLK_RTC) {
4200835b:	002172        	l32i	a7, a1, 0
4200835e:	09a062        	movi	a6, 9
42008361:	029767        	bne	a7, a6, 42008367 <uart_driver_delete+0x8f>
        periph_rtc_dig_clk8m_disable();
42008364:	010065        	call8	4200936c <periph_rtc_dig_clk8m_disable>
42008367:	fb7c      	movi.n	a11, -1
42008369:	03ad      	mov.n	a10, a3
    if (uart_context[uart_num].hw_enabled != false) {
4200836b:	806450        	add	a6, a4, a5
4200836e:	df3481        	l32r	a8, 42000040 <_stext+0x20>
42008371:	0008e0        	callx8	a8
42008374:	0c0662        	l8ui	a6, a6, 12
42008377:	569c      	beqz.n	a6, 42008390 <uart_driver_delete+0xb8>
        if (uart_num != CONFIG_ESP_CONSOLE_UART_NUM ) {
42008379:	c28c      	beqz.n	a2, 42008389 <uart_driver_delete+0xb1>
            periph_module_disable(uart_periph_signal[uart_num].module);
4200837b:	e14461        	l32r	a6, 4200088c <_stext+0x86c>
4200837e:	902220        	addx2	a2, a2, a2
42008381:	b02260        	addx8	a2, a2, a6
42008384:	52a8      	l32i.n	a10, a2, 20
42008386:	fac0e5        	call8	42002f94 <periph_module_disable>
        uart_context[uart_num].hw_enabled = false;
42008389:	445a      	add.n	a4, a4, a5
4200838b:	020c      	movi.n	a2, 0
4200838d:	0c4422        	s8i	a2, a4, 12
    UART_EXIT_CRITICAL(&(uart_context[uart_num].spinlock));
42008390:	03ad      	mov.n	a10, a3
42008392:	df2c81        	l32r	a8, 42000044 <_stext+0x24>
42008395:	0008e0        	callx8	a8
    }
#endif
    uart_module_disable(uart_num);
    return ESP_OK;
42008398:	060c      	movi.n	a6, 0
}
4200839a:	062d      	mov.n	a2, a6
4200839c:	f01d      	retw.n
	...

420083a0 <uart_driver_install>:
{
420083a0:	008136        	entry	a1, 64
420083a3:	5179      	s32i.n	a7, a1, 20
420083a5:	079d      	mov.n	a9, a7
    ESP_RETURN_ON_FALSE((uart_num < UART_NUM_MAX), ESP_FAIL, UART_TAG, "uart_num error");
420083a7:	4932e6        	bgei	a2, 3, 420083f4 <uart_driver_install+0x54>
    ESP_RETURN_ON_FALSE((rx_buffer_size > SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "uart rx buffer length error");
420083aa:	80a082        	movi	a8, 128
420083ad:	43a837        	bge	a8, a3, 420083f4 <uart_driver_install+0x54>
    ESP_RETURN_ON_FALSE((tx_buffer_size > SOC_UART_FIFO_LEN) || (tx_buffer_size == 0), ESP_FAIL, UART_TAG, "uart tx buffer length error");
420083b0:	052847        	blt	a8, a4, 420083b9 <uart_driver_install+0x19>
    ESP_RETURN_ON_FALSE((rx_buffer_size > SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "uart rx buffer length error");
420083b3:	ffaf82        	movi	a8, -1
    ESP_RETURN_ON_FALSE((tx_buffer_size > SOC_UART_FIFO_LEN) || (tx_buffer_size == 0), ESP_FAIL, UART_TAG, "uart tx buffer length error");
420083b6:	18a456        	bnez	a4, 42008544 <uart_driver_install+0x1a4>
    if ((intr_alloc_flags & ESP_INTR_FLAG_IRAM) != 0) {
420083b9:	0769a7        	bbci	a9, 10, 420083c4 <uart_driver_install+0x24>
        intr_alloc_flags &= ~ESP_INTR_FLAG_IRAM;
420083bc:	ffab72        	movi	a7, 0xfffffbff
420083bf:	109970        	and	a9, a9, a7
420083c2:	5199      	s32i.n	a9, a1, 20
    if (p_uart_obj[uart_num] == NULL) {
420083c4:	e13591        	l32r	a9, 42000898 <_stext+0x878>
420083c7:	1182e0        	slli	a8, a2, 2
420083ca:	a0d290        	addx4	a13, a2, a9
420083cd:	0d98      	l32i.n	a9, a13, 0
420083cf:	4189      	s32i.n	a8, a1, 16
    ESP_RETURN_ON_FALSE((rx_buffer_size > SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "uart rx buffer length error");
420083d1:	f87c      	movi.n	a8, -1
    if (p_uart_obj[uart_num] == NULL) {
420083d3:	16d956        	bnez	a9, 42008544 <uart_driver_install+0x1a4>
    uart_obj_t *uart_obj = heap_caps_calloc(1, sizeof(uart_obj_t), UART_MALLOC_CAPS);
420083d6:	1c0c      	movi.n	a12, 1
420083d8:	11cc40        	slli	a12, a12, 12
420083db:	04a1b2        	movi	a11, 0x104
420083de:	1a0c      	movi.n	a10, 1
420083e0:	7199      	s32i.n	a9, a1, 28
420083e2:	61d9      	s32i.n	a13, a1, 24
420083e4:	e14d81        	l32r	a8, 42000918 <_stext+0x8f8>
420083e7:	0008e0        	callx8	a8
    if (!uart_obj) {
420083ea:	7198      	l32i.n	a9, a1, 28
420083ec:	61d8      	l32i.n	a13, a1, 24
    uart_obj_t *uart_obj = heap_caps_calloc(1, sizeof(uart_obj_t), UART_MALLOC_CAPS);
420083ee:	0a7d      	mov.n	a7, a10
    if (!uart_obj) {
420083f0:	5acc      	bnez.n	a10, 420083f9 <uart_driver_install+0x59>
        p_uart_obj[uart_num] = uart_alloc_driver_obj(event_queue_size, tx_buffer_size, rx_buffer_size);
420083f2:	0da9      	s32i.n	a10, a13, 0
    ESP_RETURN_ON_FALSE((rx_buffer_size > SOC_UART_FIFO_LEN), ESP_FAIL, UART_TAG, "uart rx buffer length error");
420083f4:	f87c      	movi.n	a8, -1
420083f6:	005286        	j	42008544 <uart_driver_install+0x1a4>
    if (event_queue_size > 0) {
420083f9:	0215a6        	blti	a5, 1, 420083ff <uart_driver_install+0x5f>
420083fc:	005206        	j	42008548 <uart_driver_install+0x1a8>
    if (tx_buffer_size > 0) {
420083ff:	0214a6        	blti	a4, 1, 42008405 <uart_driver_install+0x65>
42008402:	005b06        	j	42008572 <uart_driver_install+0x1d2>
    uart_obj->rx_ring_buf = xRingbufferCreate(rx_buffer_size, RINGBUF_TYPE_BYTEBUF);
42008405:	2b0c      	movi.n	a11, 2
42008407:	03ad      	mov.n	a10, a3
42008409:	e14481        	l32r	a8, 4200091c <_stext+0x8fc>
4200840c:	0008e0        	callx8	a8
4200840f:	3a67a2        	s32i	a10, a7, 232
    uart_obj->tx_mux = xSemaphoreCreateMutex();
42008412:	1a0c      	movi.n	a10, 1
42008414:	df0881        	l32r	a8, 42000034 <_stext+0x14>
42008417:	0008e0        	callx8	a8
4200841a:	3d67a2        	s32i	a10, a7, 244
    uart_obj->rx_mux = xSemaphoreCreateMutex();
4200841d:	1a0c      	movi.n	a10, 1
4200841f:	df0581        	l32r	a8, 42000034 <_stext+0x14>
42008422:	0008e0        	callx8	a8
42008425:	3c67a2        	s32i	a10, a7, 240
    uart_obj->tx_brk_sem = xSemaphoreCreateBinary();
42008428:	3c0c      	movi.n	a12, 3
4200842a:	0b0c      	movi.n	a11, 0
4200842c:	1a0c      	movi.n	a10, 1
4200842e:	e13c81        	l32r	a8, 42000920 <_stext+0x900>
42008431:	0008e0        	callx8	a8
42008434:	4067a2        	s32i	a10, a7, 0x100
    uart_obj->tx_done_sem = xSemaphoreCreateBinary();
42008437:	3c0c      	movi.n	a12, 3
42008439:	0b0c      	movi.n	a11, 0
4200843b:	01a0a2        	movi	a10, 1
4200843e:	e13881        	l32r	a8, 42000920 <_stext+0x900>
42008441:	0008e0        	callx8	a8
42008444:	3f67a2        	s32i	a10, a7, 252
    uart_obj->tx_fifo_sem = xSemaphoreCreateBinary();
42008447:	3c0c      	movi.n	a12, 3
42008449:	0b0c      	movi.n	a11, 0
4200844b:	1a0c      	movi.n	a10, 1
4200844d:	e13481        	l32r	a8, 42000920 <_stext+0x900>
42008450:	0008e0        	callx8	a8
    if (!uart_obj->rx_ring_buf || !uart_obj->rx_mux || !uart_obj->tx_mux || !uart_obj->tx_brk_sem ||
42008453:	3a2732        	l32i	a3, a7, 232
    uart_obj->tx_fifo_sem = xSemaphoreCreateBinary();
42008456:	3e67a2        	s32i	a10, a7, 248
    if (!uart_obj->rx_ring_buf || !uart_obj->rx_mux || !uart_obj->tx_mux || !uart_obj->tx_brk_sem ||
42008459:	100316        	beqz	a3, 4200855d <uart_driver_install+0x1bd>
4200845c:	3c2732        	l32i	a3, a7, 240
4200845f:	0fa316        	beqz	a3, 4200855d <uart_driver_install+0x1bd>
42008462:	3d2732        	l32i	a3, a7, 244
42008465:	0f4316        	beqz	a3, 4200855d <uart_driver_install+0x1bd>
42008468:	402732        	l32i	a3, a7, 0x100
4200846b:	0ee316        	beqz	a3, 4200855d <uart_driver_install+0x1bd>
4200846e:	3f2792        	l32i	a9, a7, 252
42008471:	1b0c      	movi.n	a11, 1
42008473:	030c      	movi.n	a3, 0
42008475:	833b90        	moveqz	a3, a11, a9
            !uart_obj->tx_done_sem || !uart_obj->tx_fifo_sem) {
42008478:	749030        	extui	a9, a3, 0, 8
4200847b:	0de356        	bnez	a3, 4200855d <uart_driver_install+0x1bd>
4200847e:	93b9a0        	movnez	a11, a9, a10
42008481:	0d8b56        	bnez	a11, 4200855d <uart_driver_install+0x1bd>
        p_uart_obj[uart_num] = uart_alloc_driver_obj(event_queue_size, tx_buffer_size, rx_buffer_size);
42008484:	e10581        	l32r	a8, 42000898 <_stext+0x878>
42008487:	4198      	l32i.n	a9, a1, 16
        p_uart_obj[uart_num]->event_queue_size = event_queue_size;
42008489:	1759      	s32i.n	a5, a7, 4
        p_uart_obj[uart_num] = uart_alloc_driver_obj(event_queue_size, tx_buffer_size, rx_buffer_size);
4200848b:	389a      	add.n	a3, a8, a9
        p_uart_obj[uart_num]->rx_int_usr_mask = UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT;
4200848d:	01a152        	movi	a5, 0x101
        p_uart_obj[uart_num]->uart_mode = UART_MODE_UART;
42008490:	37b9      	s32i.n	a11, a7, 12
        p_uart_obj[uart_num]->coll_det_flg = false;
42008492:	0857b2        	s16i	a11, a7, 16
        p_uart_obj[uart_num]->tx_ptr = NULL;
42008495:	3367b2        	s32i	a11, a7, 204
        p_uart_obj[uart_num]->tx_head = NULL;
42008498:	3467b2        	s32i	a11, a7, 208
        p_uart_obj[uart_num]->tx_len_tot = 0;
4200849b:	3567b2        	s32i	a11, a7, 212
        p_uart_obj[uart_num]->tx_brk_flg = 0;
4200849e:	6e57b2        	s16i	a11, a7, 220
        p_uart_obj[uart_num]->tx_waiting_brk = 0;
420084a1:	de47b2        	s8i	a11, a7, 222
        p_uart_obj[uart_num]->rx_buffered_len = 0;
420084a4:	57b9      	s32i.n	a11, a7, 20
        p_uart_obj[uart_num]->rx_buffer_full_flg = false;
420084a6:	1c47b2        	s8i	a11, a7, 28
        p_uart_obj[uart_num]->tx_waiting_fifo = false;
420084a9:	c847b2        	s8i	a11, a7, 200
        p_uart_obj[uart_num]->rx_ptr = NULL;
420084ac:	97b9      	s32i.n	a11, a7, 36
        p_uart_obj[uart_num]->rx_cur_remain = 0;
420084ae:	87b9      	s32i.n	a11, a7, 32
        p_uart_obj[uart_num]->rx_head_ptr = NULL;
420084b0:	a7b9      	s32i.n	a11, a7, 40
        p_uart_obj[uart_num]->uart_select_notif_callback = NULL;
420084b2:	3867b2        	s32i	a11, a7, 224
        xSemaphoreGive(p_uart_obj[uart_num]->tx_fifo_sem);
420084b5:	0bdd      	mov.n	a13, a11
420084b7:	0bcd      	mov.n	a12, a11
        p_uart_obj[uart_num] = uart_alloc_driver_obj(event_queue_size, tx_buffer_size, rx_buffer_size);
420084b9:	0379      	s32i.n	a7, a3, 0
        p_uart_obj[uart_num]->uart_num = uart_num;
420084bb:	0729      	s32i.n	a2, a7, 0
        p_uart_obj[uart_num]->rx_int_usr_mask = UART_INTR_RXFIFO_FULL | UART_INTR_RXFIFO_TOUT;
420084bd:	2c6752        	s32i	a5, a7, 176
        p_uart_obj[uart_num]->tx_buf_size = tx_buffer_size;
420084c0:	316742        	s32i	a4, a7, 196
        xSemaphoreGive(p_uart_obj[uart_num]->tx_fifo_sem);
420084c3:	e07a81        	l32r	a8, 420006ac <_stext+0x68c>
420084c6:	0008e0        	callx8	a8
        uart_pattern_queue_reset(uart_num, UART_PATTERN_DET_QLEN_DEFAULT);
420084c9:	ab0c      	movi.n	a11, 10
420084cb:	02ad      	mov.n	a10, a2
420084cd:	ff3d25        	call8	420078a0 <uart_pattern_queue_reset>
        if (uart_queue) {
420084d0:	568c      	beqz.n	a6, 420084d9 <uart_driver_install+0x139>
            *uart_queue = p_uart_obj[uart_num]->event_queue;
420084d2:	0338      	l32i.n	a3, a3, 0
420084d4:	392332        	l32i	a3, a3, 228
420084d7:	0639      	s32i.n	a3, a6, 0
    uart_intr_config_t uart_intr = {
420084d9:	e10d31        	l32r	a3, 42000910 <_stext+0x8f0>
    uart_module_enable(uart_num);
420084dc:	02ad      	mov.n	a10, a2
    uart_intr_config_t uart_intr = {
420084de:	0348      	l32i.n	a4, a3, 0
420084e0:	1338      	l32i.n	a3, a3, 4
420084e2:	0149      	s32i.n	a4, a1, 0
420084e4:	1139      	s32i.n	a3, a1, 4
    uart_module_enable(uart_num);
420084e6:	fe8865        	call8	42006d6c <uart_module_enable>
    uart_hal_disable_intr_mask(&(uart_context[uart_num].hal), UART_LL_INTR_MASK);
420084e9:	e0e931        	l32r	a3, 42000890 <_stext+0x870>
420084ec:	1142c0        	slli	a4, a2, 4
420084ef:	334a      	add.n	a3, a3, a4
420084f1:	0338      	l32i.n	a3, a3, 0
420084f3:	f57c      	movi.n	a5, -1
420084f5:	0020c0        	memw
420084f8:	3348      	l32i.n	a4, a3, 12
420084fa:	0155d0        	slli	a5, a5, 19
420084fd:	104450        	and	a4, a4, a5
42008500:	0020c0        	memw
42008503:	3349      	s32i.n	a4, a3, 12
    hw->int_clr.val = mask;
42008505:	e0fb41        	l32r	a4, 420008f4 <_stext+0x8d4>
                       uart_rx_intr_handler_default, p_uart_obj[uart_num],
42008508:	4158      	l32i.n	a5, a1, 16
4200850a:	0020c0        	memw
4200850d:	4349      	s32i.n	a4, a3, 16
4200850f:	e0e241        	l32r	a4, 42000898 <_stext+0x878>
    ret = esp_intr_alloc(uart_periph_signal[uart_num].irq, intr_alloc_flags,
42008512:	e100c1        	l32r	a12, 42000914 <_stext+0x8f4>
                       uart_rx_intr_handler_default, p_uart_obj[uart_num],
42008515:	345a      	add.n	a3, a4, a5
    ret = esp_intr_alloc(uart_periph_signal[uart_num].irq, intr_alloc_flags,
42008517:	e0dd41        	l32r	a4, 4200088c <_stext+0x86c>
                       uart_rx_intr_handler_default, p_uart_obj[uart_num],
4200851a:	03d8      	l32i.n	a13, a3, 0
    ret = esp_intr_alloc(uart_periph_signal[uart_num].irq, intr_alloc_flags,
4200851c:	903220        	addx2	a3, a2, a2
4200851f:	b03340        	addx8	a3, a3, a4
42008522:	51b8      	l32i.n	a11, a1, 20
42008524:	1003a2        	l8ui	a10, a3, 16
42008527:	ed8b      	addi.n	a14, a13, 8
42008529:	fa6665        	call8	42002b90 <esp_intr_alloc>
4200852c:	0a8d      	mov.n	a8, a10
    ESP_GOTO_ON_ERROR(ret, err, UART_TAG, "Could not allocate an interrupt for UART");
4200852e:	9acc      	bnez.n	a10, 4200853b <uart_driver_install+0x19b>
    ret = uart_intr_config(uart_num, &uart_intr);
42008530:	01bd      	mov.n	a11, a1
42008532:	02ad      	mov.n	a10, a2
42008534:	ff8b65        	call8	42007dec <uart_intr_config>
42008537:	0a8d      	mov.n	a8, a10
    ESP_GOTO_ON_ERROR(ret, err, UART_TAG, "Could not configure the interrupt for UART");
42008539:	7a8c      	beqz.n	a10, 42008544 <uart_driver_install+0x1a4>
    uart_driver_delete(uart_num);
4200853b:	02ad      	mov.n	a10, a2
4200853d:	6189      	s32i.n	a8, a1, 24
4200853f:	ffd9a5        	call8	420082d8 <uart_driver_delete>
    return ret;
42008542:	6188      	l32i.n	a8, a1, 24
}
42008544:	082d      	mov.n	a2, a8
42008546:	f01d      	retw.n
        uart_obj->event_queue = xQueueCreate(event_queue_size, sizeof(uart_event_t));
42008548:	20c990        	or	a12, a9, a9
4200854b:	0ca0b2        	movi	a11, 12
4200854e:	20a550        	or	a10, a5, a5
42008551:	e0f381        	l32r	a8, 42000920 <_stext+0x900>
42008554:	0008e0        	callx8	a8
42008557:	3967a2        	s32i	a10, a7, 228
        if (!uart_obj->event_queue) {
4200855a:	ea1a56        	bnez	a10, 420083ff <uart_driver_install+0x5f>
    uart_free_driver_obj(uart_obj);
4200855d:	07ad      	mov.n	a10, a7
4200855f:	fe8fa5        	call8	42006e58 <uart_free_driver_obj>
        p_uart_obj[uart_num] = uart_alloc_driver_obj(event_queue_size, tx_buffer_size, rx_buffer_size);
42008562:	e0cd31        	l32r	a3, 42000898 <_stext+0x878>
42008565:	4148      	l32i.n	a4, a1, 16
42008567:	234a      	add.n	a2, a3, a4
42008569:	030c      	movi.n	a3, 0
4200856b:	0239      	s32i.n	a3, a2, 0
        if (p_uart_obj[uart_num] == NULL) {
4200856d:	ffa0c6        	j	420083f4 <uart_driver_install+0x54>
42008570:	00          	.byte 00
42008571:	00          	.byte 00
        uart_obj->tx_ring_buf = xRingbufferCreate(tx_buffer_size, RINGBUF_TYPE_NOSPLIT);
42008572:	0b0c      	movi.n	a11, 0
42008574:	04ad      	mov.n	a10, a4
42008576:	e0e981        	l32r	a8, 4200091c <_stext+0x8fc>
42008579:	0008e0        	callx8	a8
4200857c:	3b67a2        	s32i	a10, a7, 236
        if (!uart_obj->tx_ring_buf) {
4200857f:	e82a56        	bnez	a10, 42008405 <uart_driver_install+0x65>
42008582:	fff5c6        	j	4200855d <uart_driver_install+0x1bd>
42008585:	000000        	ill

42008588 <uart_is_driver_installed>:

bool uart_is_driver_installed(uart_port_t uart_num)
{
42008588:	004136        	entry	a1, 32
4200858b:	028d      	mov.n	a8, a2
    return uart_num < UART_NUM_MAX && (p_uart_obj[uart_num] != NULL);
4200858d:	020c      	movi.n	a2, 0
4200858f:	0d38e6        	bgei	a8, 3, 420085a0 <uart_is_driver_installed+0x18>
42008592:	e0c191        	l32r	a9, 42000898 <_stext+0x878>
42008595:	a08890        	addx4	a8, a8, a9
42008598:	0898      	l32i.n	a9, a8, 0
4200859a:	01a082        	movi	a8, 1
4200859d:	932890        	movnez	a2, a8, a9
}
420085a0:	f01d      	retw.n
	...

420085a4 <uart_set_select_notif_callback>:

void uart_set_select_notif_callback(uart_port_t uart_num, uart_select_notif_callback_t uart_select_notif_callback)
{
420085a4:	004136        	entry	a1, 32
    if (uart_num < UART_NUM_MAX && p_uart_obj[uart_num]) {
420085a7:	0d32e6        	bgei	a2, 3, 420085b8 <uart_set_select_notif_callback+0x14>
420085aa:	e0bb81        	l32r	a8, 42000898 <_stext+0x878>
420085ad:	a02280        	addx4	a2, a2, a8
420085b0:	0228      	l32i.n	a2, a2, 0
420085b2:	002216        	beqz	a2, 420085b8 <uart_set_select_notif_callback+0x14>
        p_uart_obj[uart_num]->uart_select_notif_callback = (uart_select_notif_callback_t) uart_select_notif_callback;
420085b5:	386232        	s32i	a3, a2, 224
    }
}
420085b8:	f01d      	retw.n
	...

420085bc <uart_get_selectlock>:

portMUX_TYPE *uart_get_selectlock(void)
{
420085bc:	004136        	entry	a1, 32
    return &uart_selectlock;
}
420085bf:	e0bf21        	l32r	a2, 420008bc <_stext+0x89c>
420085c2:	f01d      	retw.n

420085c4 <bootloader_init_mem>:
#include "soc/soc_caps.h"
#include "bootloader_mem.h"
#include "esp_cpu.h"

void bootloader_init_mem(void)
{
420085c4:	004136        	entry	a1, 32
#ifdef CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE
    // protect memory region
    esp_cpu_configure_region_protection();
420085c7:	0fd325        	call8	420182f8 <esp_cpu_configure_region_protection>
#endif
}
420085ca:	f01d      	retw.n

420085cc <bootloader_flash_update_id>:
#define FLASH_CS_SETUP_TIME 3
#define FLASH_CS_HOLD_TIME  3
#define FLASH_CS_HOLD_DELAY 2

void bootloader_flash_update_id()
{
420085cc:	004136        	entry	a1, 32
    esp_rom_spiflash_chip_t *chip = &rom_spiflash_legacy_data->chip;
420085cf:	e0d521        	l32r	a2, 42000924 <_stext+0x904>
420085d2:	0228      	l32i.n	a2, a2, 0
    chip->device_id = bootloader_read_flash_id();
420085d4:	e0d581        	l32r	a8, 42000928 <_stext+0x908>
420085d7:	0008e0        	callx8	a8
420085da:	02a9      	s32i.n	a10, a2, 0
}
420085dc:	f01d      	retw.n
	...

420085e0 <spi_flash_init_lock>:
{
420085e0:	004136        	entry	a1, 32
    s_flash_op_mutex = xSemaphoreCreateRecursiveMutex();
420085e3:	04a0a2        	movi	a10, 4
420085e6:	de9381        	l32r	a8, 42000034 <_stext+0x14>
420085e9:	0008e0        	callx8	a8
420085ec:	e0d081        	l32r	a8, 4200092c <_stext+0x90c>
420085ef:	08a9      	s32i.n	a10, a8, 0
    assert(s_flash_op_mutex != NULL);
420085f1:	facc      	bnez.n	a10, 42008604 <spi_flash_init_lock+0x24>
420085f3:	e0cfd1        	l32r	a13, 42000930 <_stext+0x910>
420085f6:	e0cfc1        	l32r	a12, 42000934 <_stext+0x914>
420085f9:	e0cfa1        	l32r	a10, 42000938 <_stext+0x918>
420085fc:	fb5c      	movi.n	a11, 95
420085fe:	dea181        	l32r	a8, 42000084 <_stext+0x64>
42008601:	0008e0        	callx8	a8
}
42008604:	f01d      	retw.n
	...

42008608 <spi_flash_op_lock>:
{
42008608:	004136        	entry	a1, 32
    xSemaphoreTakeRecursive(s_flash_op_mutex, portMAX_DELAY);
4200860b:	e0c881        	l32r	a8, 4200092c <_stext+0x90c>
4200860e:	fb7c      	movi.n	a11, -1
42008610:	08a8      	l32i.n	a10, a8, 0
42008612:	e0ca81        	l32r	a8, 4200093c <_stext+0x91c>
42008615:	0008e0        	callx8	a8
}
42008618:	f01d      	retw.n
	...

4200861c <spi_flash_op_unlock>:
{
4200861c:	004136        	entry	a1, 32
    xSemaphoreGiveRecursive(s_flash_op_mutex);
4200861f:	e0c381        	l32r	a8, 4200092c <_stext+0x90c>
42008622:	08a8      	l32i.n	a10, a8, 0
42008624:	e0c781        	l32r	a8, 42000940 <_stext+0x920>
42008627:	0008e0        	callx8	a8
}
4200862a:	f01d      	retw.n

4200862c <spi_flash_cache2phys>:
{
4200862c:	004136        	entry	a1, 32
    if (c < SOC_MMU_VADDR1_FIRST_USABLE_ADDR) {
4200862f:	e0c531        	l32r	a3, 42000944 <_stext+0x924>
42008632:	4a2327        	blt	a3, a2, 42008680 <spi_flash_cache2phys+0x54>
        cache_page = (c - SOC_MMU_VADDR0_START_ADDR) / SPI_FLASH_MMU_PAGE_SIZE + SOC_MMU_DROM0_PAGES_START;
42008635:	e0c881        	l32r	a8, 42000958 <_stext+0x938>
42008638:	0008e0        	callx8	a8
4200863b:	0a3d      	mov.n	a3, a10
4200863d:	413230        	srli	a3, a3, 2
42008640:	3cd332        	addmi	a3, a3, 0x3c00
42008643:	113300        	slli	a3, a3, 16
42008646:	e0c481        	l32r	a8, 42000958 <_stext+0x938>
42008649:	0008e0        	callx8	a8
4200864c:	c03230        	sub	a3, a2, a3
4200864f:	f53030        	extui	a3, a3, 16, 16
42008652:	41a2a0        	srli	a10, a10, 2
42008655:	33aa      	add.n	a3, a3, a10
    if (cache_page >= PAGES_LIMIT) {
42008657:	e0c081        	l32r	a8, 42000958 <_stext+0x938>
4200865a:	0008e0        	callx8	a8
4200865d:	0a4d      	mov.n	a4, a10
4200865f:	e0bf81        	l32r	a8, 4200095c <_stext+0x93c>
42008662:	0008e0        	callx8	a8
42008665:	418240        	srli	a8, a4, 2
42008668:	41a2a0        	srli	a10, a10, 2
4200866b:	21ba87        	bgeu	a10, a8, 42008690 <spi_flash_cache2phys+0x64>
4200866e:	e0ba81        	l32r	a8, 42000958 <_stext+0x938>
42008671:	0008e0        	callx8	a8
42008674:	41a2a0        	srli	a10, a10, 2
42008677:	1e33a7        	bltu	a3, a10, 42008699 <spi_flash_cache2phys+0x6d>
        return SPI_FLASH_CACHE2PHYS_FAIL;
4200867a:	f27c      	movi.n	a2, -1
}
4200867c:	f01d      	retw.n
4200867e:	00          	.byte 00
4200867f:	00          	.byte 00
        cache_page = (c - SOC_MMU_VADDR1_START_ADDR) / SPI_FLASH_MMU_PAGE_SIZE + SOC_MMU_IROM0_PAGES_START;
42008680:	dfaf32        	movi	a3, -33
42008683:	013370        	slli	a3, a3, 25
42008686:	323a      	add.n	a3, a2, a3
42008688:	313030        	srai	a3, a3, 16
4200868b:	fff206        	j	42008657 <spi_flash_cache2phys+0x2b>
4200868e:	00          	.byte 00
4200868f:	00          	.byte 00
    if (cache_page >= PAGES_LIMIT) {
42008690:	e0b381        	l32r	a8, 4200095c <_stext+0x93c>
42008693:	0008e0        	callx8	a8
42008696:	fff686        	j	42008674 <spi_flash_cache2phys+0x48>
    uint32_t phys_page = spi_flash_protected_read_mmu_entry(cache_page);
42008699:	03ad      	mov.n	a10, a3
 */
__attribute__((always_inline))
static inline bool mmu_ll_get_entry_is_invalid(uint32_t mmu_id, uint32_t entry_id)
{
    (void)mmu_id;
    HAL_ASSERT(entry_id < MMU_ENTRY_NUM);
4200869b:	ffa142        	movi	a4, 0x1ff
4200869e:	e0b081        	l32r	a8, 42000960 <_stext+0x940>
420086a1:	0008e0        	callx8	a8
420086a4:	11b437        	bgeu	a4, a3, 420086b9 <spi_flash_cache2phys+0x8d>
420086a7:	e0a8d1        	l32r	a13, 42000948 <_stext+0x928>
420086aa:	e0a8c1        	l32r	a12, 4200094c <_stext+0x92c>
420086ad:	e0a8a1        	l32r	a10, 42000950 <_stext+0x930>
420086b0:	cca0b2        	movi	a11, 204
420086b3:	de7481        	l32r	a8, 42000084 <_stext+0x64>
420086b6:	0008e0        	callx8	a8

    return (*(uint32_t *)(DR_REG_MMU_TABLE + entry_id * 4) & MMU_INVALID) ? true : false;
420086b9:	e0a641        	l32r	a4, 42000954 <_stext+0x934>
420086bc:	334a      	add.n	a3, a3, a4
420086be:	1133e0        	slli	a3, a3, 2
420086c1:	0338      	l32i.n	a3, a3, 0
    if (entry_is_invalid) {
420086c3:	b3e3e7        	bbsi	a3, 14, 4200867a <spi_flash_cache2phys+0x4e>
    uint32_t phys_offs = ((phys_page & SOC_MMU_ADDR_MASK) + offset) * SPI_FLASH_MMU_PAGE_SIZE;
420086c6:	d4a0a0        	extui	a10, a10, 0, 14
420086c9:	11aa00        	slli	a10, a10, 16
    return phys_offs | (c & (SPI_FLASH_MMU_PAGE_SIZE-1));
420086cc:	f42020        	extui	a2, a2, 0, 16
420086cf:	202a20        	or	a2, a10, a2
420086d2:	ffe986        	j	4200867c <spi_flash_cache2phys+0x50>
420086d5:	000000        	ill

420086d8 <check_chip_pointer_default>:
{
420086d8:	004136        	entry	a1, 32
    esp_flash_t *chip = *inout_chip;
420086db:	02a8      	l32i.n	a10, a2, 0
    if (chip == NULL) {
420086dd:	3acc      	bnez.n	a10, 420086e4 <check_chip_pointer_default+0xc>
        chip = esp_flash_default_chip;
420086df:	e0a281        	l32r	a8, 42000968 <_stext+0x948>
420086e2:	08a8      	l32i.n	a10, a8, 0
    *inout_chip = chip;
420086e4:	0062a2        	s32i	a10, a2, 0
        return ESP_ERR_FLASH_NOT_INITIALISED;
420086e7:	e09f21        	l32r	a2, 42000964 <_stext+0x944>
    if (chip == NULL || !esp_flash_chip_driver_initialized(chip)) {
420086ea:	008a16        	beqz	a10, 420086f6 <check_chip_pointer_default+0x1e>
420086ed:	0f9165        	call8	42018004 <esp_flash_chip_driver_initialized>
    return ESP_OK;
420086f0:	00a082        	movi	a8, 0
420086f3:	9328a0        	movnez	a2, a8, a10
}
420086f6:	f01d      	retw.n

420086f8 <esp_flash_read_chip_id>:
{
420086f8:	004136        	entry	a1, 32
    return read_id_core(chip, out_id, true);
420086fb:	1c0c      	movi.n	a12, 1
420086fd:	03bd      	mov.n	a11, a3
420086ff:	20a220        	or	a10, a2, a2
42008702:	e09a81        	l32r	a8, 4200096c <_stext+0x94c>
42008705:	0008e0        	callx8	a8
}
42008708:	0a2d      	mov.n	a2, a10
4200870a:	f01d      	retw.n

4200870c <spimem_flash_ll_get_source_freq_mhz>:
 * @param None
 *
 * @return the frequency of spi flash clock source.(MHz)
 */
static inline uint8_t spimem_flash_ll_get_source_freq_mhz(void)
{
4200870c:	004136        	entry	a1, 32
    // Default is PLL480M, this is hard-coded.
    // In the future, we can get the CPU clock source by calling interface.
    uint8_t clock_val = 0;
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
4200870f:	e09821        	l32r	a2, 42000970 <_stext+0x950>
42008712:	0020c0        	memw
42008715:	3b2282        	l32i	a8, a2, 236
42008718:	148080        	extui	a8, a8, 0, 2
4200871b:	111826        	beqi	a8, 1, 42008730 <spimem_flash_ll_get_source_freq_mhz+0x24>
            break;
        case 1:
            clock_val = 120;
            break;
        case 2:
            clock_val = 160;
4200871e:	a0a022        	movi	a2, 160
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
42008721:	0e2826        	beqi	a8, 2, 42008733 <spimem_flash_ll_get_source_freq_mhz+0x27>
            clock_val = 80;
42008724:	50a022        	movi	a2, 80
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
42008727:	008816        	beqz	a8, 42008733 <spimem_flash_ll_get_source_freq_mhz+0x27>
            break;
        default:
            abort();
4200872a:	de7c81        	l32r	a8, 4200011c <_stext+0xfc>
4200872d:	0008e0        	callx8	a8
    switch (SPIMEM0.core_clk_sel.core_clk_sel) {
42008730:	78a022        	movi	a2, 120
    }
    return clock_val;
}
42008733:	f01d      	retw.n
42008735:	000000        	ill

42008738 <esp_flash_init_default_chip>:
    .os_func = &esp_flash_noos_functions,
};

extern esp_err_t esp_flash_suspend_cmd_init(esp_flash_t* chip);
esp_err_t esp_flash_init_default_chip(void)
{
42008738:	00c136        	entry	a1, 96
    const esp_rom_spiflash_chip_t *legacy_chip = &g_rom_flashchip;
4200873b:	e07a21        	l32r	a2, 42000924 <_stext+0x904>
    memspi_host_config_t cfg = ESP_FLASH_HOST_CONFIG_DEFAULT();
4200873e:	4c3c      	movi.n	a12, 52
    const esp_rom_spiflash_chip_t *legacy_chip = &g_rom_flashchip;
42008740:	0238      	l32i.n	a3, a2, 0
    memspi_host_config_t cfg = ESP_FLASH_HOST_CONFIG_DEFAULT();
42008742:	0b0c      	movi.n	a11, 0
42008744:	01a022        	movi	a2, 1
42008747:	20a110        	or	a10, a1, a1
4200874a:	de9381        	l32r	a8, 42000198 <_stext+0x178>
4200874d:	0008e0        	callx8	a8
42008750:	084122        	s8i	a2, a1, 8
42008753:	104122        	s8i	a2, a1, 16
42008756:	025c      	movi.n	a2, 80
42008758:	b129      	s32i.n	a2, a1, 44

    #if !CONFIG_IDF_TARGET_ESP32 && !CONFIG_IDF_TARGET_ESP32C2
    // For esp32s2 spi IOs are configured as from IO MUX by default
    cfg.iomux = esp_rom_efuse_get_flash_gpio_info() == 0 ?  true : false;
4200875a:	140c      	movi.n	a4, 1
4200875c:	e08881        	l32r	a8, 4200097c <_stext+0x95c>
4200875f:	0008e0        	callx8	a8
42008762:	020c      	movi.n	a2, 0
42008764:	8324a0        	moveqz	a2, a4, a10
42008767:	104122        	s8i	a2, a1, 16
    cfg.default_io_mode = DEFAULT_FLASH_MODE;
    #endif

    // For chips need time tuning, get value directely from system here.
    #if SOC_SPI_MEM_SUPPORT_TIME_TUNING
    if (spi_timing_is_tuned()) {
4200876a:	e08581        	l32r	a8, 42000980 <_stext+0x960>
4200876d:	0008e0        	callx8	a8
42008770:	9a8c      	beqz.n	a10, 4200877d <esp_flash_init_default_chip+0x45>
        cfg.using_timing_tuning = 1;
        spi_timing_get_flash_timing_param(&cfg.timing_reg);
42008772:	01ad      	mov.n	a10, a1
        cfg.using_timing_tuning = 1;
42008774:	264142        	s8i	a4, a1, 38
        spi_timing_get_flash_timing_param(&cfg.timing_reg);
42008777:	e08381        	l32r	a8, 42000984 <_stext+0x964>
4200877a:	0008e0        	callx8	a8
    }
    #endif // SOC_SPI_MEM_SUPPORT_TIME_TUNING

    cfg.clock_src_freq = spi_flash_ll_get_source_clock_freq_mhz(cfg.host_id);
4200877d:	072122        	l32i	a2, a1, 28
42008780:	50a0a2        	movi	a10, 80
42008783:	002256        	bnez	a2, 42008789 <esp_flash_init_default_chip+0x51>
42008786:	fff865        	call8	4200870c <spimem_flash_ll_get_source_freq_mhz>
42008789:	c1a9      	s32i.n	a10, a1, 48

    //the host is already initialized, only do init for the data and load it to the host
    esp_err_t err = memspi_host_init_pointers(&esp_flash_default_host, &cfg);
4200878b:	e07aa1        	l32r	a10, 42000974 <_stext+0x954>
4200878e:	01bd      	mov.n	a11, a1
42008790:	e07e81        	l32r	a8, 42000988 <_stext+0x968>
42008793:	0008e0        	callx8	a8
    if (err != ESP_OK) {
42008796:	aadc      	bnez.n	a10, 420087b4 <esp_flash_init_default_chip+0x7c>
        return err;
    }

    // ROM TODO: account for non-standard default pins in efuse
    // ROM TODO: to account for chips which are slow to power on, maybe keep probing in a loop here
    err = esp_flash_init_main(&default_chip);
42008798:	e07821        	l32r	a2, 42000978 <_stext+0x958>
4200879b:	20a220        	or	a10, a2, a2
4200879e:	e07b81        	l32r	a8, 4200098c <_stext+0x96c>
420087a1:	0008e0        	callx8	a8
    if (err != ESP_OK) {
420087a4:	cacc      	bnez.n	a10, 420087b4 <esp_flash_init_default_chip+0x7c>
        return err;
    }
    if (default_chip.size < legacy_chip->chip_size) {
420087a6:	1388      	l32i.n	a8, a3, 4
420087a8:	5238      	l32i.n	a3, a2, 20
420087aa:	0a3387        	bltu	a3, a8, 420087b8 <esp_flash_init_default_chip+0x80>
        ESP_EARLY_LOGW(TAG, "Detected size(%dk) larger than the size in the binary image header(%dk). Using the size in the binary image header.", default_chip.size/1024, legacy_chip->chip_size/1024);
    }
    // Set chip->size equal to ROM flash size(also equal to the size in binary image header), which means the available size that can be used
    default_chip.size = legacy_chip->chip_size;

    esp_flash_default_chip = &default_chip;
420087ad:	e06e31        	l32r	a3, 42000968 <_stext+0x948>
    default_chip.size = legacy_chip->chip_size;
420087b0:	5289      	s32i.n	a8, a2, 20
    esp_flash_default_chip = &default_chip;
420087b2:	0329      	s32i.n	a2, a3, 0
        default_chip.hpm_dummy_ena = 1;
    }
#endif

    return ESP_OK;
}
420087b4:	0a2d      	mov.n	a2, a10
420087b6:	f01d      	retw.n
        return ESP_ERR_FLASH_SIZE_NOT_MATCH;
420087b8:	04a1a2        	movi	a10, 0x104
420087bb:	fffd46        	j	420087b4 <esp_flash_init_default_chip+0x7c>
	...

420087c0 <esp_flash_app_init>:

esp_err_t esp_flash_app_init(void)
{
420087c0:	004136        	entry	a1, 32
    esp_err_t err = ESP_OK;
    spi_flash_init_lock();
420087c3:	ffe1e5        	call8	420085e0 <spi_flash_init_lock>
    spi_flash_guard_set(&g_flash_guard_default_ops);
420087c6:	e072a1        	l32r	a10, 42000990 <_stext+0x970>
420087c9:	e07281        	l32r	a8, 42000994 <_stext+0x974>
420087cc:	0008e0        	callx8	a8
#endif
#if CONFIG_SPI_FLASH_SHARE_SPI1_BUS
    err = esp_flash_init_main_bus_lock();
    if (err != ESP_OK) return err;
#endif
    err = esp_flash_app_enable_os_functions(&default_chip);
420087cf:	e06aa1        	l32r	a10, 42000978 <_stext+0x958>
420087d2:	0000a5        	call8	420087dc <esp_flash_app_enable_os_functions>
    return err;
}
420087d5:	202aa0        	or	a2, a10, a10
420087d8:	000090        	retw
	...

420087dc <esp_flash_app_enable_os_functions>:
{
420087dc:	004136        	entry	a1, 32
    main_flash_arg = (spi1_app_func_arg_t) {
420087df:	e06e31        	l32r	a3, 42000998 <_stext+0x978>
420087e2:	cc0c      	movi.n	a12, 12
420087e4:	0348      	l32i.n	a4, a3, 0
420087e6:	e06d31        	l32r	a3, 4200099c <_stext+0x97c>
420087e9:	0b0c      	movi.n	a11, 0
420087eb:	04c3a2        	addi	a10, a3, 4
420087ee:	de6a81        	l32r	a8, 42000198 <_stext+0x178>
420087f1:	0008e0        	callx8	a8
    chip->os_func = &esp_flash_spi1_default_os_functions;
420087f4:	e06b81        	l32r	a8, 420009a0 <_stext+0x980>
    chip->os_func_data = &main_flash_arg;
420087f7:	3239      	s32i.n	a3, a2, 12
    chip->os_func = &esp_flash_spi1_default_os_functions;
420087f9:	2289      	s32i.n	a8, a2, 8
    main_flash_arg = (spi1_app_func_arg_t) {
420087fb:	0349      	s32i.n	a4, a3, 0
}
420087fd:	020c      	movi.n	a2, 0
420087ff:	f01d      	retw.n
42008801:	000000        	ill

42008804 <esp_crosscore_int_init>:
void esp_crosscore_int_init(void) {
42008804:	004136        	entry	a1, 32
42008807:	e06741        	l32r	a4, 420009a4 <_stext+0x984>
4200880a:	fb7c      	movi.n	a11, -1
4200880c:	04ad      	mov.n	a10, a4
4200880e:	de0c81        	l32r	a8, 42000040 <_stext+0x20>
42008811:	0008e0        	callx8	a8
42008814:	03eb80        	rsr.prid	a8
42008817:	048d80        	extui	a8, a8, 13, 1
    reason[esp_cpu_get_core_id()]=0;
4200881a:	e06331        	l32r	a3, 420009a8 <_stext+0x988>
4200881d:	020c      	movi.n	a2, 0
4200881f:	a08830        	addx4	a8, a8, a3
42008822:	0020c0        	memw
42008825:	0829      	s32i.n	a2, a8, 0
    portEXIT_CRITICAL(&reason_spinlock);
42008827:	04ad      	mov.n	a10, a4
42008829:	de0681        	l32r	a8, 42000044 <_stext+0x24>
4200882c:	0008e0        	callx8	a8
4200882f:	03ebe0        	rsr.prid	a14
42008832:	04ede0        	extui	a14, a14, 13, 1
    return id;
42008835:	e05dc1        	l32r	a12, 420009ac <_stext+0x98c>
    if (esp_cpu_get_core_id()==0) {
42008838:	1d9e27        	bne	a14, a2, 42008859 <esp_crosscore_int_init+0x55>
        err = esp_intr_alloc(ETS_FROM_CPU_INTR0_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[0], NULL);
4200883b:	03dd      	mov.n	a13, a3
4200883d:	00a4b2        	movi	a11, 0x400
42008840:	fa4c      	movi.n	a10, 79
        err = esp_intr_alloc(ETS_FROM_CPU_INTR1_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[1], NULL);
42008842:	fa34e5        	call8	42002b90 <esp_intr_alloc>
    ESP_ERROR_CHECK(err);
42008845:	da9c      	beqz.n	a10, 42008866 <esp_crosscore_int_init+0x62>
42008847:	e05be1        	l32r	a14, 420009b4 <_stext+0x994>
4200884a:	e05bd1        	l32r	a13, 420009b8 <_stext+0x998>
4200884d:	e05bb1        	l32r	a11, 420009bc <_stext+0x99c>
42008850:	7ea0c2        	movi	a12, 126
42008853:	dfdc81        	l32r	a8, 420007c4 <_stext+0x7a4>
42008856:	0008e0        	callx8	a8
        err = esp_intr_alloc(ETS_FROM_CPU_INTR1_SOURCE, ESP_INTR_FLAG_IRAM, esp_crosscore_isr, (void*)&reason[1], NULL);
42008859:	e055d1        	l32r	a13, 420009b0 <_stext+0x990>
4200885c:	02ed      	mov.n	a14, a2
4200885e:	00a4b2        	movi	a11, 0x400
42008861:	0a5c      	movi.n	a10, 80
42008863:	fff6c6        	j	42008842 <esp_crosscore_int_init+0x3e>
}
42008866:	f01d      	retw.n

42008868 <esp_ipc_call_and_wait>:
        (void)res;
    }
}

static esp_err_t esp_ipc_call_and_wait(uint32_t cpu_id, esp_ipc_func_t func, void* arg, esp_ipc_wait_t wait_for)
{
42008868:	006136        	entry	a1, 48
4200886b:	207220        	or	a7, a2, a2
4200886e:	202330        	or	a2, a3, a3
    if (cpu_id >= portNUM_PROCESSORS) {
        return ESP_ERR_INVALID_ARG;
42008871:	02a132        	movi	a3, 0x102
    if (cpu_id >= portNUM_PROCESSORS) {
42008874:	0227b6        	bltui	a7, 2, 4200887a <esp_ipc_call_and_wait+0x12>
42008877:	002c46        	j	4200892c <esp_ipc_call_and_wait+0xc4>
    }
    if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
4200887a:	e05881        	l32r	a8, 420009dc <_stext+0x9bc>
4200887d:	0008e0        	callx8	a8
        return ESP_ERR_INVALID_STATE;
42008880:	03a132        	movi	a3, 0x103
    if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
42008883:	022a26        	beqi	a10, 2, 42008889 <esp_ipc_call_and_wait+0x21>
42008886:	002886        	j	4200892c <esp_ipc_call_and_wait+0xc4>
    }

#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
    TaskHandle_t task_handler = xTaskGetCurrentTaskHandle();
42008889:	e05581        	l32r	a8, 420009e0 <_stext+0x9c0>
4200888c:	0008e0        	callx8	a8
    UBaseType_t priority_of_current_task = uxTaskPriorityGet(task_handler);
4200888f:	e05581        	l32r	a8, 420009e4 <_stext+0x9c4>
42008892:	0008e0        	callx8	a8
    UBaseType_t priority_of_running_ipc_task = uxTaskPriorityGet(s_ipc_task_handle[cpu_id]);
42008895:	e04a81        	l32r	a8, 420009c0 <_stext+0x9a0>
42008898:	1167e0        	slli	a6, a7, 2
4200889b:	a07780        	addx4	a7, a7, a8
    UBaseType_t priority_of_current_task = uxTaskPriorityGet(task_handler);
4200889e:	0a3d      	mov.n	a3, a10
    UBaseType_t priority_of_running_ipc_task = uxTaskPriorityGet(s_ipc_task_handle[cpu_id]);
420088a0:	07a8      	l32i.n	a10, a7, 0
420088a2:	e05081        	l32r	a8, 420009e4 <_stext+0x9c4>
420088a5:	0008e0        	callx8	a8
    if (priority_of_running_ipc_task < priority_of_current_task) {
420088a8:	09ba37        	bgeu	a10, a3, 420088b5 <esp_ipc_call_and_wait+0x4d>
        vTaskPrioritySet(s_ipc_task_handle[cpu_id], priority_of_current_task);
420088ab:	07a8      	l32i.n	a10, a7, 0
420088ad:	03bd      	mov.n	a11, a3
420088af:	e04e81        	l32r	a8, 420009e8 <_stext+0x9c8>
420088b2:	0008e0        	callx8	a8
    }

    xSemaphoreTake(s_ipc_mutex[cpu_id], portMAX_DELAY);
420088b5:	e04381        	l32r	a8, 420009c4 <_stext+0x9a4>
420088b8:	fb7c      	movi.n	a11, -1
420088ba:	808860        	add	a8, a8, a6
420088bd:	0028a2        	l32i	a10, a8, 0
420088c0:	006182        	s32i	a8, a1, 0
420088c3:	e00981        	l32r	a8, 420008e8 <_stext+0x8c8>
420088c6:	0008e0        	callx8	a8
    vTaskPrioritySet(s_ipc_task_handle[cpu_id], priority_of_current_task);
420088c9:	e03d91        	l32r	a9, 420009c0 <_stext+0x9a0>
420088cc:	03bd      	mov.n	a11, a3
420088ce:	796a      	add.n	a7, a9, a6
420088d0:	0027a2        	l32i	a10, a7, 0
420088d3:	e04581        	l32r	a8, 420009e8 <_stext+0x9c8>
420088d6:	0008e0        	callx8	a8
#else
    xSemaphoreTake(s_ipc_mutex[0], portMAX_DELAY);
#endif

    s_func[cpu_id] = func;
420088d9:	e03b31        	l32r	a3, 420009c8 <_stext+0x9a8>
    s_func_arg[cpu_id] = arg;
    s_ipc_wait[cpu_id] = wait_for;
    xSemaphoreGive(s_ipc_sem[cpu_id]);
420088dc:	0d0c      	movi.n	a13, 0
    s_func[cpu_id] = func;
420088de:	336a      	add.n	a3, a3, a6
420088e0:	0020c0        	memw
420088e3:	0329      	s32i.n	a2, a3, 0
    s_func_arg[cpu_id] = arg;
420088e5:	e03921        	l32r	a2, 420009cc <_stext+0x9ac>
    xSemaphoreGive(s_ipc_sem[cpu_id]);
420088e8:	0dcd      	mov.n	a12, a13
    s_func_arg[cpu_id] = arg;
420088ea:	226a      	add.n	a2, a2, a6
420088ec:	0020c0        	memw
420088ef:	0249      	s32i.n	a4, a2, 0
    s_ipc_wait[cpu_id] = wait_for;
420088f1:	e03721        	l32r	a2, 420009d0 <_stext+0x9b0>
    xSemaphoreGive(s_ipc_sem[cpu_id]);
420088f4:	0dbd      	mov.n	a11, a13
    s_ipc_wait[cpu_id] = wait_for;
420088f6:	226a      	add.n	a2, a2, a6
420088f8:	0020c0        	memw
420088fb:	0259      	s32i.n	a5, a2, 0
    xSemaphoreGive(s_ipc_sem[cpu_id]);
420088fd:	e03521        	l32r	a2, 420009d4 <_stext+0x9b4>
    xSemaphoreTake(s_ipc_ack[cpu_id], portMAX_DELAY);
#ifdef CONFIG_ESP_IPC_USES_CALLERS_PRIORITY
    xSemaphoreGive(s_ipc_mutex[cpu_id]);
42008900:	030c      	movi.n	a3, 0
    xSemaphoreGive(s_ipc_sem[cpu_id]);
42008902:	226a      	add.n	a2, a2, a6
42008904:	0022a2        	l32i	a10, a2, 0
42008907:	df6981        	l32r	a8, 420006ac <_stext+0x68c>
4200890a:	0008e0        	callx8	a8
    xSemaphoreTake(s_ipc_ack[cpu_id], portMAX_DELAY);
4200890d:	e03221        	l32r	a2, 420009d8 <_stext+0x9b8>
42008910:	fb7c      	movi.n	a11, -1
42008912:	226a      	add.n	a2, a2, a6
42008914:	02a8      	l32i.n	a10, a2, 0
42008916:	dff481        	l32r	a8, 420008e8 <_stext+0x8c8>
42008919:	0008e0        	callx8	a8
    xSemaphoreGive(s_ipc_mutex[cpu_id]);
4200891c:	0188      	l32i.n	a8, a1, 0
4200891e:	0d0c      	movi.n	a13, 0
42008920:	08a8      	l32i.n	a10, a8, 0
42008922:	0dcd      	mov.n	a12, a13
42008924:	0dbd      	mov.n	a11, a13
42008926:	df6181        	l32r	a8, 420006ac <_stext+0x68c>
42008929:	0008e0        	callx8	a8
#else
    xSemaphoreGive(s_ipc_mutex[0]);
#endif
    return ESP_OK;
}
4200892c:	032d      	mov.n	a2, a3
4200892e:	f01d      	retw.n

42008930 <esp_ipc_init>:
{
42008930:	008136        	entry	a1, 64
42008933:	020c      	movi.n	a2, 0
    for (int i = 0; i < portNUM_PROCESSORS; ++i) {
42008935:	023d      	mov.n	a3, a2
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
42008937:	01a062        	movi	a6, 1
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
4200893a:	204220        	or	a4, a2, a2
        snprintf(task_name, sizeof(task_name), "ipc%d", i);
4200893d:	e02bc1        	l32r	a12, 420009ec <_stext+0x9cc>
42008940:	0b1c      	movi.n	a11, 16
42008942:	03dd      	mov.n	a13, a3
42008944:	a1ba      	add.n	a10, a1, a11
42008946:	01d3a5        	call8	4200a680 <snprintf>
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
42008949:	e029b1        	l32r	a11, 420009f0 <_stext+0x9d0>
4200894c:	06ad      	mov.n	a10, a6
4200894e:	bb2a      	add.n	a11, a11, a2
42008950:	df1981        	l32r	a8, 420005b4 <_stext+0x594>
42008953:	0008e0        	callx8	a8
42008956:	e01b51        	l32r	a5, 420009c4 <_stext+0x9a4>
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
42008959:	e026d1        	l32r	a13, 420009f4 <_stext+0x9d4>
        s_ipc_mutex[i] = xSemaphoreCreateMutexStatic(&s_ipc_mutex_buffer[i]);
4200895c:	a05350        	addx4	a5, a3, a5
4200895f:	05a9      	s32i.n	a10, a5, 0
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
42008961:	3e0c      	movi.n	a14, 3
42008963:	dd2a      	add.n	a13, a13, a2
42008965:	04cd      	mov.n	a12, a4
42008967:	04bd      	mov.n	a11, a4
42008969:	06ad      	mov.n	a10, a6
4200896b:	e02881        	l32r	a8, 42000a0c <_stext+0x9ec>
4200896e:	0008e0        	callx8	a8
42008971:	e01951        	l32r	a5, 420009d8 <_stext+0x9b8>
42008974:	1173e0        	slli	a7, a3, 2
        s_ipc_sem[i] = xSemaphoreCreateBinaryStatic(&s_ipc_sem_buffer[i]);
42008977:	e020d1        	l32r	a13, 420009f8 <_stext+0x9d8>
        s_ipc_ack[i] = xSemaphoreCreateBinaryStatic(&s_ipc_ack_buffer[i]);
4200897a:	575a      	add.n	a5, a7, a5
4200897c:	05a9      	s32i.n	a10, a5, 0
        s_ipc_sem[i] = xSemaphoreCreateBinaryStatic(&s_ipc_sem_buffer[i]);
4200897e:	3e0c      	movi.n	a14, 3
42008980:	dd2a      	add.n	a13, a13, a2
42008982:	04cd      	mov.n	a12, a4
42008984:	04bd      	mov.n	a11, a4
42008986:	06ad      	mov.n	a10, a6
42008988:	e02181        	l32r	a8, 42000a0c <_stext+0x9ec>
4200898b:	0008e0        	callx8	a8
4200898e:	e01151        	l32r	a5, 420009d4 <_stext+0x9b4>
        portBASE_TYPE res = xTaskCreatePinnedToCore(ipc_task, task_name, IPC_STACK_SIZE, (void*) i,
42008991:	e00bf1        	l32r	a15, 420009c0 <_stext+0x9a0>
        s_ipc_sem[i] = xSemaphoreCreateBinaryStatic(&s_ipc_sem_buffer[i]);
42008994:	575a      	add.n	a5, a7, a5
42008996:	05a9      	s32i.n	a10, a5, 0
        portBASE_TYPE res = xTaskCreatePinnedToCore(ipc_task, task_name, IPC_STACK_SIZE, (void*) i,
42008998:	e019a1        	l32r	a10, 420009fc <_stext+0x9dc>
4200899b:	0139      	s32i.n	a3, a1, 0
4200899d:	03dd      	mov.n	a13, a3
4200899f:	ff7a      	add.n	a15, a15, a7
420089a1:	8e1c      	movi.n	a14, 24
420089a3:	00a5c2        	movi	a12, 0x500
420089a6:	10c1b2        	addi	a11, a1, 16
420089a9:	df2281        	l32r	a8, 42000634 <_stext+0x614>
420089ac:	0008e0        	callx8	a8
420089af:	035d      	mov.n	a5, a3
420089b1:	0a3d      	mov.n	a3, a10
        assert(res == pdTRUE);
420089b3:	111a26        	beqi	a10, 1, 420089c8 <esp_ipc_init+0x98>
420089b6:	e012d1        	l32r	a13, 42000a00 <_stext+0x9e0>
420089b9:	e012c1        	l32r	a12, 42000a04 <_stext+0x9e4>
420089bc:	e013a1        	l32r	a10, 42000a08 <_stext+0x9e8>
420089bf:	7da0b2        	movi	a11, 125
420089c2:	ddb081        	l32r	a8, 42000084 <_stext+0x64>
420089c5:	0008e0        	callx8	a8
    for (int i = 0; i < portNUM_PROCESSORS; ++i) {
420089c8:	54c222        	addi	a2, a2, 84
420089cb:	021526        	beqi	a5, 1, 420089d1 <esp_ipc_init+0xa1>
420089ce:	ffdac6        	j	4200893d <esp_ipc_init+0xd>
}
420089d1:	f01d      	retw.n
	...

420089d4 <esp_ipc_call>:

esp_err_t esp_ipc_call(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
420089d4:	004136        	entry	a1, 32
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_START);
420089d7:	00a0d2        	movi	a13, 0
420089da:	20c440        	or	a12, a4, a4
420089dd:	20b330        	or	a11, a3, a3
420089e0:	02ad      	mov.n	a10, a2
420089e2:	ffe865        	call8	42008868 <esp_ipc_call_and_wait>
}
420089e5:	0a2d      	mov.n	a2, a10
420089e7:	f01d      	retw.n
420089e9:	000000        	ill

420089ec <esp_ipc_call_blocking>:

esp_err_t esp_ipc_call_blocking(uint32_t cpu_id, esp_ipc_func_t func, void* arg)
{
420089ec:	004136        	entry	a1, 32
    return esp_ipc_call_and_wait(cpu_id, func, arg, IPC_WAIT_FOR_END);
420089ef:	01a0d2        	movi	a13, 1
420089f2:	20c440        	or	a12, a4, a4
420089f5:	20b330        	or	a11, a3, a3
420089f8:	02ad      	mov.n	a10, a2
420089fa:	ffe6e5        	call8	42008868 <esp_ipc_call_and_wait>
}
420089fd:	0a2d      	mov.n	a2, a10
420089ff:	f01d      	retw.n
42008a01:	000000        	ill

42008a04 <find_entry_and_check_all_reset>:
 * @param[in] user_entry User entry
 * @param[out] all_reset Whether all entries have been reset
 * @return Whether the user entry exists
 */
static bool find_entry_and_check_all_reset(twdt_entry_t *user_entry, bool *all_reset)
{
42008a04:	004136        	entry	a1, 32
    bool found_user_entry = false;
    bool found_non_reset = false;

    twdt_entry_t *entry;
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a07:	e00281        	l32r	a8, 42000a10 <_stext+0x9f0>
        if (entry == user_entry) {
            found_user_entry = true;
42008a0a:	1b0c      	movi.n	a11, 1
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a0c:	0888      	l32i.n	a8, a8, 0
42008a0e:	1898      	l32i.n	a9, a8, 4
    bool found_non_reset = false;
42008a10:	080c      	movi.n	a8, 0
    bool found_user_entry = false;
42008a12:	08ad      	mov.n	a10, a8
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a14:	c9cc      	bnez.n	a9, 42008a24 <find_entry_and_check_all_reset+0x20>
        } else if (entry->has_reset == false) {
            found_non_reset = true;
        }
    }

    *all_reset = !found_non_reset;
42008a16:	190c      	movi.n	a9, 1
42008a18:	308890        	xor	a8, a8, a9
42008a1b:	004382        	s8i	a8, a3, 0
    return found_user_entry;
}
42008a1e:	0a2d      	mov.n	a2, a10
42008a20:	f01d      	retw.n
42008a22:	00          	.byte 00
42008a23:	00          	.byte 00
        if (entry == user_entry) {
42008a24:	0a1927        	beq	a9, a2, 42008a32 <find_entry_and_check_all_reset+0x2e>
        } else if (entry->has_reset == false) {
42008a27:	0c09c2        	l8ui	a12, a9, 12
            found_non_reset = true;
42008a2a:	838bc0        	moveqz	a8, a11, a12
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a2d:	0998      	l32i.n	a9, a9, 0
42008a2f:	fff846        	j	42008a14 <find_entry_and_check_all_reset+0x10>
            found_user_entry = true;
42008a32:	0bad      	mov.n	a10, a11
42008a34:	fffd46        	j	42008a2d <find_entry_and_check_all_reset+0x29>
	...

42008a38 <find_entry_from_task_handle_and_check_all_reset>:
 * @param[in] handle Task handle
 * @param[out] all_reset Whether all entries have been reset
 * @return Task entry, or NULL if not found
 */
static twdt_entry_t *find_entry_from_task_handle_and_check_all_reset(TaskHandle_t handle, bool *all_reset)
{
42008a38:	004136        	entry	a1, 32
    twdt_entry_t *target = NULL;
    bool found_non_reset = false;

    twdt_entry_t *entry;
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a3b:	dff581        	l32r	a8, 42000a10 <_stext+0x9f0>
        if (entry->task_handle == handle) {
            target = entry;
        } else if (entry->has_reset == false) {
            found_non_reset = true;
42008a3e:	1b0c      	movi.n	a11, 1
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a40:	0888      	l32i.n	a8, a8, 0
42008a42:	1898      	l32i.n	a9, a8, 4
    bool found_non_reset = false;
42008a44:	080c      	movi.n	a8, 0
    twdt_entry_t *target = NULL;
42008a46:	08ad      	mov.n	a10, a8
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a48:	a9cc      	bnez.n	a9, 42008a56 <find_entry_from_task_handle_and_check_all_reset+0x1e>
        }
    }

    *all_reset = !found_non_reset;
42008a4a:	190c      	movi.n	a9, 1
42008a4c:	308890        	xor	a8, a8, a9
42008a4f:	004382        	s8i	a8, a3, 0
    return target;
}
42008a52:	0a2d      	mov.n	a2, a10
42008a54:	f01d      	retw.n
        if (entry->task_handle == handle) {
42008a56:	19c8      	l32i.n	a12, a9, 4
42008a58:	0a1c27        	beq	a12, a2, 42008a66 <find_entry_from_task_handle_and_check_all_reset+0x2e>
        } else if (entry->has_reset == false) {
42008a5b:	0c09c2        	l8ui	a12, a9, 12
            found_non_reset = true;
42008a5e:	838bc0        	moveqz	a8, a11, a12
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a61:	0998      	l32i.n	a9, a9, 0
42008a63:	fff846        	j	42008a48 <find_entry_from_task_handle_and_check_all_reset+0x10>
42008a66:	09ad      	mov.n	a10, a9
42008a68:	fffd46        	j	42008a61 <find_entry_from_task_handle_and_check_all_reset+0x29>
	...

42008a6c <task_wdt_timer_feed>:
{
42008a6c:	004136        	entry	a1, 32
    esp_task_wdt_impl_timer_feed(p_twdt_obj->impl_ctx);
42008a6f:	dfe821        	l32r	a2, 42000a10 <_stext+0x9f0>
42008a72:	002282        	l32i	a8, a2, 0
42008a75:	0028a2        	l32i	a10, a8, 0
42008a78:	003c65        	call8	42008e40 <esp_task_wdt_impl_timer_feed>
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a7b:	002222        	l32i	a2, a2, 0
42008a7e:	1288      	l32i.n	a8, a2, 4
        entry->has_reset = false;
42008a80:	020c      	movi.n	a2, 0
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a82:	28cc      	bnez.n	a8, 42008a88 <task_wdt_timer_feed+0x1c>
}
42008a84:	f01d      	retw.n
42008a86:	00          	.byte 00
42008a87:	00          	.byte 00
        entry->has_reset = false;
42008a88:	0c4822        	s8i	a2, a8, 12
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008a8b:	0888      	l32i.n	a8, a8, 0
42008a8d:	fffc46        	j	42008a82 <task_wdt_timer_feed+0x16>

42008a90 <add_entry>:
 * @param[in] entry_data Data associated with the entry (either a task handle or user entry name)
 * @param[out] entry_ret Pointer to created entry
 * @return ESP_OK if entry was added, failure otherwise
 */
static esp_err_t add_entry(bool is_task, void *entry_data, twdt_entry_t **entry_ret)
{
42008a90:	006136        	entry	a1, 48
    esp_err_t ret;

    // Allocate entry object
    twdt_entry_t *entry = calloc(1, sizeof(twdt_entry_t));
42008a93:	10a0b2        	movi	a11, 16
42008a96:	1a0c      	movi.n	a10, 1
42008a98:	dfe081        	l32r	a8, 42000a18 <_stext+0x9f8>
42008a9b:	0008e0        	callx8	a8
{
42008a9e:	027d      	mov.n	a7, a2
    twdt_entry_t *entry = calloc(1, sizeof(twdt_entry_t));
42008aa0:	0a5d      	mov.n	a5, a10
    if (entry == NULL) {
        return ESP_ERR_NO_MEM;
42008aa2:	01a122        	movi	a2, 0x101
    if (entry == NULL) {
42008aa5:	050a16        	beqz	a10, 42008af9 <add_entry+0x69>
    }
    if (is_task) {
42008aa8:	050716        	beqz	a7, 42008afc <add_entry+0x6c>
        entry->task_handle = (TaskHandle_t)entry_data;
42008aab:	1a39      	s32i.n	a3, a10, 4
42008aad:	dfd961        	l32r	a6, 42000a14 <_stext+0x9f4>
42008ab0:	fb7c      	movi.n	a11, -1
42008ab2:	06ad      	mov.n	a10, a6
42008ab4:	dd6381        	l32r	a8, 42000040 <_stext+0x20>
42008ab7:	0008e0        	callx8	a8
        entry->user_name = (const char *)entry_data;
    }

    portENTER_CRITICAL(&spinlock);
    // Check TWDT state
    ESP_GOTO_ON_FALSE_ISR((p_twdt_obj != NULL), ESP_ERR_INVALID_STATE, state_err, TAG, "task watchdog was never initialized");
42008aba:	dfd521        	l32r	a2, 42000a10 <_stext+0x9f0>
42008abd:	0238      	l32i.n	a3, a2, 0
42008abf:	05d316        	beqz	a3, 42008b20 <add_entry+0x90>
    // Check if the task is an entry, and if all entries have been reset
    bool all_reset;
    if (is_task) {
        twdt_entry_t *entry_found = find_entry_from_task_handle_and_check_all_reset(entry->task_handle, &all_reset);
42008ac2:	01bd      	mov.n	a11, a1
    if (is_task) {
42008ac4:	04f716        	beqz	a7, 42008b17 <add_entry+0x87>
        twdt_entry_t *entry_found = find_entry_from_task_handle_and_check_all_reset(entry->task_handle, &all_reset);
42008ac7:	15a8      	l32i.n	a10, a5, 4
42008ac9:	fff6e5        	call8	42008a38 <find_entry_from_task_handle_and_check_all_reset>
        ESP_GOTO_ON_FALSE_ISR((entry_found == NULL), ESP_ERR_INVALID_ARG, state_err, TAG, "task is already subscribed");
42008acc:	1afc      	bnez.n	a10, 42008b01 <add_entry+0x71>
    } else {
        bool entry_found = find_entry_and_check_all_reset(entry, &all_reset);
        ESP_GOTO_ON_FALSE_ISR(!entry_found, ESP_ERR_INVALID_ARG, state_err, TAG, "user is already subscribed");
    }
    // Add entry to list
    SLIST_INSERT_HEAD(&p_twdt_obj->entries_slist, entry, slist_entry);
42008ace:	1378      	l32i.n	a7, a3, 4
42008ad0:	0579      	s32i.n	a7, a5, 0
    // Start the timer if it has not been started yet and was waiting on a task to registered
    if (p_twdt_obj->waiting_for_task) {
42008ad2:	0d0372        	l8ui	a7, a3, 13
    SLIST_INSERT_HEAD(&p_twdt_obj->entries_slist, entry, slist_entry);
42008ad5:	1359      	s32i.n	a5, a3, 4
    if (p_twdt_obj->waiting_for_task) {
42008ad7:	a78c      	beqz.n	a7, 42008ae5 <add_entry+0x55>
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
42008ad9:	03a8      	l32i.n	a10, a3, 0
        p_twdt_obj->waiting_for_task = false;
42008adb:	030c      	movi.n	a3, 0
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
42008add:	003aa5        	call8	42008e88 <esp_task_wdt_impl_timer_restart>
        p_twdt_obj->waiting_for_task = false;
42008ae0:	0228      	l32i.n	a2, a2, 0
42008ae2:	0d4232        	s8i	a3, a2, 13
    }
    if (all_reset) {   //Reset hardware timer if all other tasks in list have reset in
42008ae5:	000122        	l8ui	a2, a1, 0
42008ae8:	128c      	beqz.n	a2, 42008aed <add_entry+0x5d>
        task_wdt_timer_feed();
42008aea:	fff825        	call8	42008a6c <task_wdt_timer_feed>
    }
    portEXIT_CRITICAL(&spinlock);
42008aed:	06ad      	mov.n	a10, a6
42008aef:	dd5581        	l32r	a8, 42000044 <_stext+0x24>
42008af2:	0008e0        	callx8	a8
    *entry_ret = entry;
    return ESP_OK;
42008af5:	020c      	movi.n	a2, 0
    *entry_ret = entry;
42008af7:	0459      	s32i.n	a5, a4, 0

state_err:
    portEXIT_CRITICAL(&spinlock);
    free(entry);
    return ret;
}
42008af9:	f01d      	retw.n
42008afb:	00          	.byte 00
        entry->user_name = (const char *)entry_data;
42008afc:	2a39      	s32i.n	a3, a10, 8
42008afe:	ffeac6        	j	42008aad <add_entry+0x1d>
        ESP_GOTO_ON_FALSE_ISR((entry_found == NULL), ESP_ERR_INVALID_ARG, state_err, TAG, "task is already subscribed");
42008b01:	02a122        	movi	a2, 0x102
    portEXIT_CRITICAL(&spinlock);
42008b04:	06ad      	mov.n	a10, a6
42008b06:	dd4f81        	l32r	a8, 42000044 <_stext+0x24>
42008b09:	0008e0        	callx8	a8
    free(entry);
42008b0c:	05ad      	mov.n	a10, a5
42008b0e:	dd4581        	l32r	a8, 42000024 <_stext+0x4>
42008b11:	0008e0        	callx8	a8
    return ret;
42008b14:	fff846        	j	42008af9 <add_entry+0x69>
        bool entry_found = find_entry_and_check_all_reset(entry, &all_reset);
42008b17:	05ad      	mov.n	a10, a5
42008b19:	ffeea5        	call8	42008a04 <find_entry_and_check_all_reset>
42008b1c:	ffeb06        	j	42008acc <add_entry+0x3c>
42008b1f:	00          	.byte 00
    ESP_GOTO_ON_FALSE_ISR((p_twdt_obj != NULL), ESP_ERR_INVALID_STATE, state_err, TAG, "task watchdog was never initialized");
42008b20:	03a122        	movi	a2, 0x103
42008b23:	fff746        	j	42008b04 <add_entry+0x74>
	...

42008b28 <task_wdt_timeout_abort_xtensa>:
 * It is called either by the function right below or by a crosscore interrupt,
 * in the case where the other core (than the main one) has to abort because one
 * of his tasks didn't reset the TWDT on time.
 */
void task_wdt_timeout_abort_xtensa(bool current_core)
{
42008b28:	006136        	entry	a1, 48
    TaskSnapshot_t snapshot = { 0 };
42008b2b:	0b0c      	movi.n	a11, 0
42008b2d:	cc0c      	movi.n	a12, 12
42008b2f:	20a110        	or	a10, a1, a1
42008b32:	dd9981        	l32r	a8, 42000198 <_stext+0x178>
42008b35:	0008e0        	callx8	a8
    BaseType_t ret = pdTRUE;

    ESP_EARLY_LOGE(TAG, "Aborting.");
    esp_reset_reason_set_hint(ESP_RST_TASK_WDT);
42008b38:	6a0c      	movi.n	a10, 6
42008b3a:	ddf581        	l32r	a8, 42000310 <_stext+0x2f0>
42008b3d:	0008e0        	callx8	a8
    ret = vTaskGetSnapshot(xTaskGetCurrentTaskHandle(), &snapshot);
42008b40:	dfa881        	l32r	a8, 420009e0 <_stext+0x9c0>
42008b43:	0008e0        	callx8	a8
42008b46:	01bd      	mov.n	a11, a1
42008b48:	dfb981        	l32r	a8, 42000a2c <_stext+0xa0c>
42008b4b:	0008e0        	callx8	a8
    assert(ret == pdTRUE);
42008b4e:	111a26        	beqi	a10, 1, 42008b63 <task_wdt_timeout_abort_xtensa+0x3b>
42008b51:	dfb2d1        	l32r	a13, 42000a1c <_stext+0x9fc>
42008b54:	dfb3c1        	l32r	a12, 42000a20 <_stext+0xa00>
42008b57:	dfb3a1        	l32r	a10, 42000a24 <_stext+0xa04>
42008b5a:	99a1b2        	movi	a11, 0x199
42008b5d:	dd4981        	l32r	a8, 42000084 <_stext+0x64>
42008b60:	0008e0        	callx8	a8
    g_panic_abort = true;
42008b63:	dd9281        	l32r	a8, 420001ac <_stext+0x18c>
42008b66:	0048a2        	s8i	a10, a8, 0
     * an ISR context, but it is intended, it is not because an ISR encountered an
     * exception. If we don't set such flag, later tested by coredump, the later would
     * switch the execution frame/context we are giving it to the interrupt stack.
     * For details about this behavior in the TODO task: IDF-5694
     */
    g_twdt_isr = true;
42008b69:	dfaf81        	l32r	a8, 42000a28 <_stext+0xa08>
42008b6c:	0048a2        	s8i	a10, a8, 0
    if (current_core) {
        ESP_EARLY_LOGE(TAG, "Print CPU %d (current core) backtrace", xPortGetCoreID());
    } else {
        ESP_EARLY_LOGE(TAG, "Print CPU %d backtrace", xPortGetCoreID());
    }
    xt_unhandled_exception(frame);
42008b6f:	0121a2        	l32i	a10, a1, 4
42008b72:	dfaf81        	l32r	a8, 42000a30 <_stext+0xa10>
42008b75:	0008e0        	callx8	a8
}
42008b78:	f01d      	retw.n
	...

42008b7c <task_wdt_isr>:
 * configured to do so.
 *
 * @param arg ISR argument
 */
static void task_wdt_isr(void *arg)
{
42008b7c:	004136        	entry	a1, 32
42008b7f:	dfa541        	l32r	a4, 42000a14 <_stext+0x9f4>
42008b82:	fb7c      	movi.n	a11, -1
42008b84:	04ad      	mov.n	a10, a4
42008b86:	dd2e81        	l32r	a8, 42000040 <_stext+0x20>
42008b89:	0008e0        	callx8	a8
    portENTER_CRITICAL_ISR(&spinlock);
    esp_task_wdt_impl_timeout_triggered(p_twdt_obj->impl_ctx);
42008b8c:	dfa121        	l32r	a2, 42000a10 <_stext+0x9f0>
42008b8f:	0238      	l32i.n	a3, a2, 0
42008b91:	03a8      	l32i.n	a10, a3, 0
42008b93:	002d65        	call8	42008e68 <esp_task_wdt_impl_timeout_triggered>

    // If there are no entries, there's nothing to do.
    if (SLIST_EMPTY(&p_twdt_obj->entries_slist)) {
42008b96:	0228      	l32i.n	a2, a2, 0
42008b98:	1238      	l32i.n	a3, a2, 4
42008b9a:	b3cc      	bnez.n	a3, 42008ba9 <task_wdt_isr+0x2d>
        portEXIT_CRITICAL_ISR(&spinlock);
42008b9c:	04ad      	mov.n	a10, a4
42008b9e:	dd2981        	l32r	a8, 42000044 <_stext+0x24>
42008ba1:	0008e0        	callx8	a8
    }

    // Trigger configured timeout behavior (e.g., panic or print backtrace)
    assert(cpus_fail != 0);
    task_wdt_timeout_handling(cpus_fail, panic);
}
42008ba4:	f01d      	retw.n
42008ba6:	00          	.byte 00
42008ba7:	00          	.byte 00
42008ba8:	00          	.byte 00
    bool panic = p_twdt_obj->panic;
42008ba9:	0c0262        	l8ui	a6, a2, 12
                    cpus_fail |= BIT(1);
42008bac:	250c      	movi.n	a5, 2
    int cpus_fail = 0;
42008bae:	00a022        	movi	a2, 0
        if (!entry->has_reset) {
42008bb1:	0c0382        	l8ui	a8, a3, 12
42008bb4:	48cc      	bnez.n	a8, 42008bbc <task_wdt_isr+0x40>
            if (entry->task_handle) {
42008bb6:	13a8      	l32i.n	a10, a3, 4
42008bb8:	caec      	bnez.n	a10, 42008be8 <task_wdt_isr+0x6c>
                cpus_fail = BIT(1) | BIT(0);
42008bba:	320c      	movi.n	a2, 3
    SLIST_FOREACH(entry, &p_twdt_obj->entries_slist, slist_entry) {
42008bbc:	0338      	l32i.n	a3, a3, 0
42008bbe:	fef356        	bnez	a3, 42008bb1 <task_wdt_isr+0x35>
    portEXIT_CRITICAL_ISR(&spinlock);
42008bc1:	04ad      	mov.n	a10, a4
42008bc3:	dd2081        	l32r	a8, 42000044 <_stext+0x24>
42008bc6:	0008e0        	callx8	a8
    if (esp_task_wdt_isr_user_handler != NULL) {
42008bc9:	df9a31        	l32r	a3, 42000a34 <_stext+0xa14>
42008bcc:	438c      	beqz.n	a3, 42008bd4 <task_wdt_isr+0x58>
        esp_task_wdt_isr_user_handler();
42008bce:	df9981        	l32r	a8, 42000a34 <_stext+0xa14>
42008bd1:	0008e0        	callx8	a8
    assert(cpus_fail != 0);
42008bd4:	92ec      	bnez.n	a2, 42008c01 <task_wdt_isr+0x85>
42008bd6:	df98d1        	l32r	a13, 42000a38 <_stext+0xa18>
42008bd9:	df98c1        	l32r	a12, 42000a3c <_stext+0xa1c>
42008bdc:	df92a1        	l32r	a10, 42000a24 <_stext+0xa04>
42008bdf:	48a2b2        	movi	a11, 0x248
42008be2:	dd2881        	l32r	a8, 42000084 <_stext+0x64>
42008be5:	0008e0        	callx8	a8
                BaseType_t task_affinity = xTaskGetAffinity(entry->task_handle);
42008be8:	df9681        	l32r	a8, 42000a40 <_stext+0xa20>
42008beb:	0008e0        	callx8	a8
                if (task_affinity == 0) {
42008bee:	6acc      	bnez.n	a10, 42008bf8 <task_wdt_isr+0x7c>
                    cpus_fail |= BIT(0);
42008bf0:	180c      	movi.n	a8, 1
42008bf2:	202280        	or	a2, a2, a8
42008bf5:	fff0c6        	j	42008bbc <task_wdt_isr+0x40>
                } else if (task_affinity == 1) {
42008bf8:	be1a66        	bnei	a10, 1, 42008bba <task_wdt_isr+0x3e>
                    cpus_fail |= BIT(1);
42008bfb:	202250        	or	a2, a2, a5
42008bfe:	ffee86        	j	42008bbc <task_wdt_isr+0x40>
    asm volatile (
42008c01:	03eb50        	rsr.prid	a5
42008c04:	045d50        	extui	a5, a5, 13, 1
    if (panic) {
42008c07:	130c      	movi.n	a3, 1
42008c09:	46bc      	beqz.n	a6, 42008c41 <task_wdt_isr+0xc5>
        const int other_core = !current_core;
42008c0b:	040c      	movi.n	a4, 0
42008c0d:	834350        	moveqz	a4, a3, a5
        if ((cores_fail & BIT(0)) && (cores_fail & BIT(1))) {
42008c10:	153266        	bnei	a2, 3, 42008c29 <task_wdt_isr+0xad>
            esp_backtrace_print(100);
42008c13:	64a0a2        	movi	a10, 100
42008c16:	df8b81        	l32r	a8, 42000a44 <_stext+0xa24>
42008c19:	0008e0        	callx8	a8
            esp_crosscore_int_send_twdt_abort(other_core);
42008c1c:	04ad      	mov.n	a10, a4
42008c1e:	df8a81        	l32r	a8, 42000a48 <_stext+0xa28>
42008c21:	0008e0        	callx8	a8
            while (1) {}
42008c24:	ffff06        	j	42008c24 <task_wdt_isr+0xa8>
42008c27:	00          	.byte 00
42008c28:	00          	.byte 00
        } else if (cores_fail & BIT(other_core)) {
42008c29:	0b5247        	bbc	a2, a4, 42008c38 <task_wdt_isr+0xbc>
            esp_crosscore_int_send_twdt_abort(other_core);
42008c2c:	04ad      	mov.n	a10, a4
42008c2e:	df8681        	l32r	a8, 42000a48 <_stext+0xa28>
42008c31:	0008e0        	callx8	a8
            while (1) {}
42008c34:	ffff06        	j	42008c34 <task_wdt_isr+0xb8>
42008c37:	00          	.byte 00
        task_wdt_timeout_abort_xtensa(true);
42008c38:	03ad      	mov.n	a10, a3
42008c3a:	ffeee5        	call8	42008b28 <task_wdt_timeout_abort_xtensa>
42008c3d:	ffd8c6        	j	42008ba4 <task_wdt_isr+0x28>
42008c40:	00          	.byte 00
        if (cores_fail & BIT(current_core)) {
42008c41:	085257        	bbc	a2, a5, 42008c4d <task_wdt_isr+0xd1>
            esp_backtrace_print(100);
42008c44:	64a0a2        	movi	a10, 100
42008c47:	df7f81        	l32r	a8, 42000a44 <_stext+0xa24>
42008c4a:	0008e0        	callx8	a8
        const int other_core = !current_core;
42008c4d:	040c      	movi.n	a4, 0
42008c4f:	04ad      	mov.n	a10, a4
42008c51:	83a350        	moveqz	a10, a3, a5
        if (cores_fail & BIT(other_core)) {
42008c54:	02d2a7        	bbs	a2, a10, 42008c5a <task_wdt_isr+0xde>
42008c57:	ffd246        	j	42008ba4 <task_wdt_isr+0x28>
            esp_crosscore_int_send_print_backtrace(other_core);
42008c5a:	df7c81        	l32r	a8, 42000a4c <_stext+0xa2c>
42008c5d:	0008e0        	callx8	a8
42008c60:	ffd006        	j	42008ba4 <task_wdt_isr+0x28>
	...

42008c64 <esp_task_wdt_add>:
    subscribe_idle(p_twdt_obj->idle_core_mask); // Resubscribe idle tasks
    return ret;
}

esp_err_t esp_task_wdt_add(TaskHandle_t task_handle)
{
42008c64:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
42008c67:	df6a81        	l32r	a8, 42000a10 <_stext+0x9f0>
{
42008c6a:	02bd      	mov.n	a11, a2
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
42008c6c:	0888      	l32i.n	a8, a8, 0
42008c6e:	03a1a2        	movi	a10, 0x103
42008c71:	010816        	beqz	a8, 42008c85 <esp_task_wdt_add+0x21>
    esp_err_t ret;
    if (task_handle == NULL) {   // Get handle of current task if none is provided
42008c74:	62cc      	bnez.n	a2, 42008c7e <esp_task_wdt_add+0x1a>
        task_handle = xTaskGetCurrentTaskHandle();
42008c76:	df5a81        	l32r	a8, 420009e0 <_stext+0x9c0>
42008c79:	0008e0        	callx8	a8
42008c7c:	0abd      	mov.n	a11, a10
    }

    twdt_entry_t *entry;
    ret = add_entry(true, (void *)task_handle, &entry);
42008c7e:	01cd      	mov.n	a12, a1
42008c80:	1a0c      	movi.n	a10, 1
42008c82:	ffe0e5        	call8	42008a90 <add_entry>
    (void) entry; // Returned entry pointer not used
    return ret;
}
42008c85:	0a2d      	mov.n	a2, a10
42008c87:	f01d      	retw.n
42008c89:	000000        	ill

42008c8c <subscribe_idle>:
{
42008c8c:	004136        	entry	a1, 32
    int core_num = 0;
42008c8f:	030c      	movi.n	a3, 0
    while (core_mask != 0) {
42008c91:	02cc      	bnez.n	a2, 42008c95 <subscribe_idle+0x9>
}
42008c93:	f01d      	retw.n
        if (core_mask & 0x1) {
42008c95:	4b6207        	bbci	a2, 0, 42008ce4 <subscribe_idle+0x58>
            TaskHandle_t idle_task_handle = xTaskGetIdleTaskHandleForCPU(core_num);
42008c98:	20a330        	or	a10, a3, a3
42008c9b:	df7381        	l32r	a8, 42000a68 <_stext+0xa48>
42008c9e:	0008e0        	callx8	a8
            assert(idle_task_handle);
42008ca1:	011a56        	bnez	a10, 42008cb6 <subscribe_idle+0x2a>
42008ca4:	df6bd1        	l32r	a13, 42000a50 <_stext+0xa30>
42008ca7:	df6bc1        	l32r	a12, 42000a54 <_stext+0xa34>
42008caa:	df5ea1        	l32r	a10, 42000a24 <_stext+0xa04>
42008cad:	30a1b2        	movi	a11, 0x130
42008cb0:	dcf581        	l32r	a8, 42000084 <_stext+0x64>
42008cb3:	0008e0        	callx8	a8
            ESP_ERROR_CHECK(esp_task_wdt_add(idle_task_handle));
42008cb6:	fffae5        	call8	42008c64 <esp_task_wdt_add>
42008cb9:	0a9c      	beqz.n	a10, 42008ccd <subscribe_idle+0x41>
42008cbb:	df67e1        	l32r	a14, 42000a58 <_stext+0xa38>
42008cbe:	df65d1        	l32r	a13, 42000a54 <_stext+0xa34>
42008cc1:	31a1c2        	movi	a12, 0x131
            ESP_ERROR_CHECK(esp_register_freertos_idle_hook_for_cpu(idle_hook_cb, core_num));
42008cc4:	df66b1        	l32r	a11, 42000a5c <_stext+0xa3c>
42008cc7:	debf81        	l32r	a8, 420007c4 <_stext+0x7a4>
42008cca:	0008e0        	callx8	a8
42008ccd:	df64a1        	l32r	a10, 42000a60 <_stext+0xa40>
42008cd0:	03bd      	mov.n	a11, a3
42008cd2:	f8f225        	call8	42001bf4 <esp_register_freertos_idle_hook_for_cpu>
42008cd5:	ba8c      	beqz.n	a10, 42008ce4 <subscribe_idle+0x58>
42008cd7:	df63e1        	l32r	a14, 42000a64 <_stext+0xa44>
42008cda:	df5ed1        	l32r	a13, 42000a54 <_stext+0xa34>
42008cdd:	32a1c2        	movi	a12, 0x132
42008ce0:	fff806        	j	42008cc4 <subscribe_idle+0x38>
42008ce3:	00          	.byte 00
        core_mask >>= 1;
42008ce4:	412120        	srli	a2, a2, 1
        core_num++;
42008ce7:	331b      	addi.n	a3, a3, 1
42008ce9:	ffe906        	j	42008c91 <subscribe_idle+0x5>

42008cec <esp_task_wdt_init>:
{
42008cec:	004136        	entry	a1, 32
42008cef:	204220        	or	a4, a2, a2
    ESP_RETURN_ON_FALSE((config != NULL && config->idle_core_mask < (1 << portNUM_PROCESSORS)), ESP_ERR_INVALID_ARG, TAG, "Invalid arguments");
42008cf2:	02a122        	movi	a2, 0x102
42008cf5:	053416        	beqz	a4, 42008d4c <esp_task_wdt_init+0x60>
42008cf8:	012432        	l32i	a3, a4, 4
42008cfb:	4d43f6        	bgeui	a3, 4, 42008d4c <esp_task_wdt_init+0x60>
    ESP_RETURN_ON_FALSE(p_twdt_obj == NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT already initialized");
42008cfe:	df4451        	l32r	a5, 42000a10 <_stext+0x9f0>
42008d01:	03a122        	movi	a2, 0x103
42008d04:	0538      	l32i.n	a3, a5, 0
42008d06:	042356        	bnez	a3, 42008d4c <esp_task_wdt_init+0x60>
    obj = calloc(1, sizeof(twdt_obj_t));
42008d09:	0b1c      	movi.n	a11, 16
42008d0b:	01a0a2        	movi	a10, 1
42008d0e:	df4281        	l32r	a8, 42000a18 <_stext+0x9f8>
42008d11:	0008e0        	callx8	a8
42008d14:	0a3d      	mov.n	a3, a10
    ESP_GOTO_ON_FALSE((obj != NULL), ESP_ERR_NO_MEM, err, TAG, "insufficient memory");
42008d16:	03fa16        	beqz	a10, 42008d59 <esp_task_wdt_init+0x6d>
    obj->panic = config->trigger_panic;
42008d19:	080422        	l8ui	a2, a4, 8
    ret = esp_task_wdt_impl_timer_allocate(config, task_wdt_isr, &obj->impl_ctx);
42008d1c:	df54b1        	l32r	a11, 42000a6c <_stext+0xa4c>
    obj->panic = config->trigger_panic;
42008d1f:	0c4a22        	s8i	a2, a10, 12
    ret = esp_task_wdt_impl_timer_allocate(config, task_wdt_isr, &obj->impl_ctx);
42008d22:	0acd      	mov.n	a12, a10
42008d24:	04ad      	mov.n	a10, a4
42008d26:	0009a5        	call8	42008dc0 <esp_task_wdt_impl_timer_allocate>
42008d29:	0a2d      	mov.n	a2, a10
    if (ret != ESP_OK) {
42008d2b:	daec      	bnez.n	a10, 42008d5c <esp_task_wdt_init+0x70>
    p_twdt_obj->idle_core_mask = config->idle_core_mask;
42008d2d:	14a8      	l32i.n	a10, a4, 4
    p_twdt_obj = obj;
42008d2f:	0539      	s32i.n	a3, a5, 0
    p_twdt_obj->idle_core_mask = config->idle_core_mask;
42008d31:	23a9      	s32i.n	a10, a3, 8
    if (config->idle_core_mask) {
42008d33:	002a16        	beqz	a10, 42008d39 <esp_task_wdt_init+0x4d>
        subscribe_idle(config->idle_core_mask);
42008d36:	fff565        	call8	42008c8c <subscribe_idle>
    if (!SLIST_EMPTY(&p_twdt_obj->entries_slist)) {
42008d39:	002532        	l32i	a3, a5, 0
42008d3c:	012342        	l32i	a4, a3, 4
42008d3f:	00b416        	beqz	a4, 42008d4e <esp_task_wdt_init+0x62>
        p_twdt_obj->waiting_for_task = false;
42008d42:	040c      	movi.n	a4, 0
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
42008d44:	03a8      	l32i.n	a10, a3, 0
        p_twdt_obj->waiting_for_task = false;
42008d46:	0d4342        	s8i	a4, a3, 13
        esp_task_wdt_impl_timer_restart(p_twdt_obj->impl_ctx);
42008d49:	0013e5        	call8	42008e88 <esp_task_wdt_impl_timer_restart>
}
42008d4c:	f01d      	retw.n
        p_twdt_obj->waiting_for_task = true;
42008d4e:	140c      	movi.n	a4, 1
42008d50:	0d4342        	s8i	a4, a3, 13
42008d53:	fffd46        	j	42008d4c <esp_task_wdt_init+0x60>
42008d56:	00          	.byte 00
42008d57:	00          	.byte 00
42008d58:	00          	.byte 00
    ESP_GOTO_ON_FALSE((obj != NULL), ESP_ERR_NO_MEM, err, TAG, "insufficient memory");
42008d59:	01a122        	movi	a2, 0x101
    free(obj);
42008d5c:	03ad      	mov.n	a10, a3
42008d5e:	dcb181        	l32r	a8, 42000024 <_stext+0x4>
42008d61:	0008e0        	callx8	a8
    return ret;
42008d64:	fff906        	j	42008d4c <esp_task_wdt_init+0x60>
	...

42008d68 <esp_task_wdt_reset>:
    }
    return ret;
}

esp_err_t esp_task_wdt_reset(void)
{
42008d68:	006136        	entry	a1, 48
    ESP_RETURN_ON_FALSE(p_twdt_obj != NULL, ESP_ERR_INVALID_STATE, TAG, "TWDT was never initialized");
42008d6b:	df2921        	l32r	a2, 42000a10 <_stext+0x9f0>
42008d6e:	0238      	l32i.n	a3, a2, 0
42008d70:	03a122        	movi	a2, 0x103
42008d73:	039316        	beqz	a3, 42008db0 <esp_task_wdt_reset+0x48>
    esp_err_t ret;
    TaskHandle_t handle = xTaskGetCurrentTaskHandle();
42008d76:	df1a81        	l32r	a8, 420009e0 <_stext+0x9c0>
42008d79:	0008e0        	callx8	a8
42008d7c:	df2631        	l32r	a3, 42000a14 <_stext+0x9f4>
42008d7f:	0a2d      	mov.n	a2, a10
42008d81:	fb7c      	movi.n	a11, -1
42008d83:	20a330        	or	a10, a3, a3
42008d86:	dcae81        	l32r	a8, 42000040 <_stext+0x20>
42008d89:	0008e0        	callx8	a8

    portENTER_CRITICAL(&spinlock);
    // Find entry from task handle
    bool all_reset;
    twdt_entry_t *entry;
    entry = find_entry_from_task_handle_and_check_all_reset(handle, &all_reset);
42008d8c:	02ad      	mov.n	a10, a2
42008d8e:	01bd      	mov.n	a11, a1
42008d90:	ffca65        	call8	42008a38 <find_entry_from_task_handle_and_check_all_reset>
    ESP_GOTO_ON_FALSE_ISR((entry != NULL), ESP_ERR_NOT_FOUND, err, TAG, "task not found");
42008d93:	05a122        	movi	a2, 0x105
42008d96:	ea8c      	beqz.n	a10, 42008da8 <esp_task_wdt_reset+0x40>
    // Mark entry as reset and issue timer reset if all entries have been reset
    entry->has_reset = true;    // Reset the task if it's on the task list
42008d98:	120c      	movi.n	a2, 1
    if (all_reset) {    // Reset if all other tasks in list have reset in
42008d9a:	000182        	l8ui	a8, a1, 0
    entry->has_reset = true;    // Reset the task if it's on the task list
42008d9d:	0c4a22        	s8i	a2, a10, 12
        task_wdt_timer_feed();
    }
    ret = ESP_OK;
42008da0:	020c      	movi.n	a2, 0
    if (all_reset) {    // Reset if all other tasks in list have reset in
42008da2:	021827        	beq	a8, a2, 42008da8 <esp_task_wdt_reset+0x40>
        task_wdt_timer_feed();
42008da5:	ffcc65        	call8	42008a6c <task_wdt_timer_feed>
err:
    portEXIT_CRITICAL(&spinlock);
42008da8:	03ad      	mov.n	a10, a3
42008daa:	dca681        	l32r	a8, 42000044 <_stext+0x24>
42008dad:	0008e0        	callx8	a8

    return ret;
}
42008db0:	f01d      	retw.n
	...

42008db4 <idle_hook_cb>:
{
42008db4:	004136        	entry	a1, 32
    esp_task_wdt_reset();
42008db7:	fffb25        	call8	42008d68 <esp_task_wdt_reset>
}
42008dba:	120c      	movi.n	a2, 1
42008dbc:	f01d      	retw.n
	...

42008dc0 <esp_task_wdt_impl_timer_allocate>:


esp_err_t esp_task_wdt_impl_timer_allocate(const esp_task_wdt_config_t *config,
                                           twdt_isr_callback callback,
                                           twdt_ctx_t *obj)
{
42008dc0:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t *ctx = &init_context;

    if (config == NULL || obj == NULL) {
42008dc3:	01a062        	movi	a6, 1
42008dc6:	00a082        	movi	a8, 0
42008dc9:	838620        	moveqz	a8, a6, a2
42008dcc:	745080        	extui	a5, a8, 0, 8
42008dcf:	065856        	bnez	a8, 42008e38 <esp_task_wdt_impl_timer_allocate+0x78>
42008dd2:	835640        	moveqz	a5, a6, a4
42008dd5:	05f556        	bnez	a5, 42008e38 <esp_task_wdt_impl_timer_allocate+0x78>
        ret = ESP_ERR_INVALID_STATE;
    }

    if (ret == ESP_OK) {
        esp_intr_alloc(TWDT_INTR_SOURCE, 0, callback, NULL, &ctx->intr_handle);
42008dd8:	df26e1        	l32r	a14, 42000a70 <_stext+0xa50>
42008ddb:	03cd      	mov.n	a12, a3
42008ddd:	05dd      	mov.n	a13, a5
42008ddf:	05bd      	mov.n	a11, a5
42008de1:	34a0a2        	movi	a10, 52
42008de4:	f9daa5        	call8	42002b90 <esp_intr_alloc>
    }

    if (ret == ESP_OK) {
        periph_module_enable(TWDT_PERIPH_MODULE);
42008de7:	aa0c      	movi.n	a10, 10
42008de9:	fa11e5        	call8	42002f08 <periph_module_enable>
        wdt_hal_init(&ctx->hal, TWDT_INSTANCE, TWDT_PRESCALER, true);
42008dec:	df2231        	l32r	a3, 42000a74 <_stext+0xa54>
42008def:	71a2c2        	movi	a12, 0x271
42008df2:	06dd      	mov.n	a13, a6
42008df4:	11cca0        	slli	a12, a12, 6
42008df7:	06bd      	mov.n	a11, a6
42008df9:	03ad      	mov.n	a10, a3
42008dfb:	dcc281        	l32r	a8, 42000104 <_stext+0xe4>
42008dfe:	0008e0        	callx8	a8

        wdt_hal_write_protect_disable(&ctx->hal);
42008e01:	03ad      	mov.n	a10, a3
42008e03:	dca581        	l32r	a8, 42000098 <_stext+0x78>
42008e06:	0008e0        	callx8	a8
        // Configure 1st stage timeout and behavior
        wdt_hal_config_stage(&ctx->hal, WDT_STAGE0, config->timeout_ms * (1000 / TWDT_TICKS_PER_US), WDT_STAGE_ACTION_INT);
42008e09:	02c8      	l32i.n	a12, a2, 0
42008e0b:	06dd      	mov.n	a13, a6
42008e0d:	ccca      	add.n	a12, a12, a12
42008e0f:	05bd      	mov.n	a11, a5
42008e11:	03ad      	mov.n	a10, a3
42008e13:	dca481        	l32r	a8, 420000a4 <_stext+0x84>
42008e16:	0008e0        	callx8	a8
        // Configure 2nd stage timeout and behavior
        wdt_hal_config_stage(&ctx->hal, WDT_STAGE1, config->timeout_ms * (2 * 1000 / TWDT_TICKS_PER_US), WDT_STAGE_ACTION_RESET_SYSTEM);
42008e19:	02c8      	l32i.n	a12, a2, 0
42008e1b:	3d0c      	movi.n	a13, 3
42008e1d:	11cce0        	slli	a12, a12, 2
42008e20:	06bd      	mov.n	a11, a6
42008e22:	03ad      	mov.n	a10, a3
42008e24:	dca081        	l32r	a8, 420000a4 <_stext+0x84>
42008e27:	0008e0        	callx8	a8
        // No need to enable to enable the WDT here, it will be enabled with `esp_task_wdt_impl_timer_restart`
        wdt_hal_write_protect_enable(&ctx->hal);
42008e2a:	03ad      	mov.n	a10, a3
42008e2c:	dc9f81        	l32r	a8, 420000a8 <_stext+0x88>
42008e2f:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
42008e32:	052d      	mov.n	a2, a5

        /* Return the implementation context to the caller */
        *obj = (twdt_ctx_t) ctx;
42008e34:	0439      	s32i.n	a3, a4, 0
    }

    return ret;
}
42008e36:	f01d      	retw.n
        ret = ESP_ERR_INVALID_STATE;
42008e38:	03a122        	movi	a2, 0x103
    return ret;
42008e3b:	fffdc6        	j	42008e36 <esp_task_wdt_impl_timer_allocate+0x76>
	...

42008e40 <esp_task_wdt_impl_timer_feed>:
    }
}


esp_err_t esp_task_wdt_impl_timer_feed(twdt_ctx_t obj)
{
42008e40:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx == NULL) {
        ret = ESP_ERR_INVALID_STATE;
42008e43:	03a182        	movi	a8, 0x103
    if (ctx == NULL) {
42008e46:	829c      	beqz.n	a2, 42008e62 <esp_task_wdt_impl_timer_feed+0x22>
    }

    if (ret == ESP_OK) {
        wdt_hal_write_protect_disable(&ctx->hal);
42008e48:	02ad      	mov.n	a10, a2
42008e4a:	dc9381        	l32r	a8, 42000098 <_stext+0x78>
42008e4d:	0008e0        	callx8	a8
        wdt_hal_feed(&ctx->hal);
42008e50:	02ad      	mov.n	a10, a2
42008e52:	dc9281        	l32r	a8, 4200009c <_stext+0x7c>
42008e55:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
42008e58:	02ad      	mov.n	a10, a2
42008e5a:	dc9381        	l32r	a8, 420000a8 <_stext+0x88>
42008e5d:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
42008e60:	080c      	movi.n	a8, 0
    }

    return ret;
}
42008e62:	082d      	mov.n	a2, a8
42008e64:	f01d      	retw.n
	...

42008e68 <esp_task_wdt_impl_timeout_triggered>:


void esp_task_wdt_impl_timeout_triggered(twdt_ctx_t obj)
{
42008e68:	004136        	entry	a1, 32
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx != NULL) {
42008e6b:	629c      	beqz.n	a2, 42008e85 <esp_task_wdt_impl_timeout_triggered+0x1d>
        /* Reset hardware timer so that 2nd stage timeout is not reached (will trigger system reset) */
        wdt_hal_write_protect_disable(&ctx->hal);
42008e6d:	02ad      	mov.n	a10, a2
42008e6f:	dc8a81        	l32r	a8, 42000098 <_stext+0x78>
42008e72:	0008e0        	callx8	a8
        wdt_hal_handle_intr(&ctx->hal);  // Feeds WDT and clears acknowledges interrupt
42008e75:	02ad      	mov.n	a10, a2
42008e77:	dccc81        	l32r	a8, 420001a8 <_stext+0x188>
42008e7a:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
42008e7d:	02ad      	mov.n	a10, a2
42008e7f:	dc8a81        	l32r	a8, 420000a8 <_stext+0x88>
42008e82:	0008e0        	callx8	a8
    }
}
42008e85:	f01d      	retw.n
	...

42008e88 <esp_task_wdt_impl_timer_restart>:
    return ret;
}


esp_err_t esp_task_wdt_impl_timer_restart(twdt_ctx_t obj)
{
42008e88:	004136        	entry	a1, 32
    esp_err_t ret = ESP_OK;
    twdt_ctx_hard_t* ctx = (twdt_ctx_hard_t*) obj;

    if (ctx == NULL) {
        ret = ESP_ERR_INVALID_STATE;
42008e8b:	03a182        	movi	a8, 0x103
    if (ctx == NULL) {
42008e8e:	02ac      	beqz.n	a2, 42008eb2 <esp_task_wdt_impl_timer_restart+0x2a>
    }

    if (ret == ESP_OK) {
        wdt_hal_write_protect_disable(&ctx->hal);
42008e90:	02ad      	mov.n	a10, a2
42008e92:	dc8181        	l32r	a8, 42000098 <_stext+0x78>
42008e95:	0008e0        	callx8	a8
        wdt_hal_enable(&ctx->hal);
42008e98:	02ad      	mov.n	a10, a2
42008e9a:	dc9b81        	l32r	a8, 42000108 <_stext+0xe8>
42008e9d:	0008e0        	callx8	a8
        wdt_hal_feed(&ctx->hal);
42008ea0:	02ad      	mov.n	a10, a2
42008ea2:	dc7e81        	l32r	a8, 4200009c <_stext+0x7c>
42008ea5:	0008e0        	callx8	a8
        wdt_hal_write_protect_enable(&ctx->hal);
42008ea8:	02ad      	mov.n	a10, a2
42008eaa:	dc7f81        	l32r	a8, 420000a8 <_stext+0x88>
42008ead:	0008e0        	callx8	a8
    esp_err_t ret = ESP_OK;
42008eb0:	080c      	movi.n	a8, 0
    }

    return ret;
}
42008eb2:	082d      	mov.n	a2, a8
42008eb4:	f01d      	retw.n
	...

42008eb8 <uart_hal_set_sclk>:

// The HAL layer for UART (common part)
#include "hal/uart_hal.h"

void uart_hal_set_sclk(uart_hal_context_t *hal, uart_sclk_t sclk)
{
42008eb8:	004136        	entry	a1, 32
    switch (source_clk) {
42008ebb:	990c      	movi.n	a9, 9
    uart_ll_set_sclk(hal->dev, sclk);
42008ebd:	0288      	l32i.n	a8, a2, 0
42008ebf:	191397        	beq	a3, a9, 42008edc <uart_hal_set_sclk+0x24>
42008ec2:	b90c      	movi.n	a9, 11
42008ec4:	301397        	beq	a3, a9, 42008ef8 <uart_hal_set_sclk+0x40>
            hw->clk_conf.sclk_sel = 1;
42008ec7:	0020c0        	memw
42008eca:	1e2892        	l32i	a9, a8, 120
42008ecd:	deea31        	l32r	a3, 42000a78 <_stext+0xa58>
42008ed0:	1a0c      	movi.n	a10, 1
42008ed2:	109930        	and	a9, a9, a3
            hw->clk_conf.sclk_sel = 3;
42008ed5:	01aac0        	slli	a10, a10, 20
42008ed8:	000446        	j	42008eed <uart_hal_set_sclk+0x35>
42008edb:	00          	.byte 00
            hw->clk_conf.sclk_sel = 2;
42008edc:	0020c0        	memw
42008edf:	1e2892        	l32i	a9, a8, 120
42008ee2:	dee531        	l32r	a3, 42000a78 <_stext+0xa58>
42008ee5:	1a0c      	movi.n	a10, 1
42008ee7:	109930        	and	a9, a9, a3
42008eea:	01aab0        	slli	a10, a10, 21
            hw->clk_conf.sclk_sel = 3;
42008eed:	2099a0        	or	a9, a9, a10
42008ef0:	0020c0        	memw
42008ef3:	1e6892        	s32i	a9, a8, 120
}
42008ef6:	f01d      	retw.n
42008ef8:	0020c0        	memw
42008efb:	1e2892        	l32i	a9, a8, 120
42008efe:	3a0c      	movi.n	a10, 3
42008f00:	fff446        	j	42008ed5 <uart_hal_set_sclk+0x1d>
	...

42008f04 <uart_hal_set_baudrate>:
{
    uart_ll_get_sclk(hal->dev, sclk);
}

void uart_hal_set_baudrate(uart_hal_context_t *hal, uint32_t baud_rate, uint32_t sclk_freq)
{
42008f04:	006136        	entry	a1, 48
    int sclk_div = DIV_UP(sclk_freq, max_div * baud);
42008f07:	11a340        	slli	a10, a3, 12
42008f0a:	c0aa30        	sub	a10, a10, a3
42008f0d:	840b      	addi.n	a8, a4, -1
42008f0f:	88aa      	add.n	a8, a8, a10
42008f11:	c288a0        	quou	a8, a8, a10
    uart_ll_set_baudrate(hal->dev, baud_rate, sclk_freq);
42008f14:	0298      	l32i.n	a9, a2, 0
    uint32_t clk_div = ((sclk_freq) << 4) / (baud * sclk_div);
42008f16:	823380        	mull	a3, a3, a8
42008f19:	1144c0        	slli	a4, a4, 4
    hw->clkdiv.clkdiv = clk_div >> 4;
42008f1c:	0020c0        	memw
42008f1f:	59a8      	l32i.n	a10, a9, 20
    uint32_t clk_div = ((sclk_freq) << 4) / (baud * sclk_div);
42008f21:	c24430        	quou	a4, a4, a3
    hw->clkdiv.clkdiv = clk_div >> 4;
42008f24:	f37c      	movi.n	a3, -1
42008f26:	113340        	slli	a3, a3, 12
42008f29:	b4b440        	extui	a11, a4, 4, 12
42008f2c:	10aa30        	and	a10, a10, a3
42008f2f:	20aab0        	or	a10, a10, a11
42008f32:	0020c0        	memw
42008f35:	59a9      	s32i.n	a10, a9, 20
    hw->clkdiv.clkdiv_frag = clk_div &  0xf;
42008f37:	0020c0        	memw
42008f3a:	59a8      	l32i.n	a10, a9, 20
42008f3c:	ded031        	l32r	a3, 42000a7c <_stext+0xa5c>
42008f3f:	344040        	extui	a4, a4, 0, 4
42008f42:	10aa30        	and	a10, a10, a3
42008f45:	0144c0        	slli	a4, a4, 20
42008f48:	204a40        	or	a4, a10, a4
42008f4b:	0020c0        	memw
42008f4e:	5949      	s32i.n	a4, a9, 20
    HAL_FORCE_MODIFY_U32_REG_FIELD(hw->clk_conf, sclk_div_num, sclk_div - 1);
42008f50:	0020c0        	memw
42008f53:	1e2932        	l32i	a3, a9, 120
42008f56:	880b      	addi.n	a8, a8, -1
42008f58:	0020c0        	memw
42008f5b:	0139      	s32i.n	a3, a1, 0
42008f5d:	0020c0        	memw
42008f60:	0148      	l32i.n	a4, a1, 0
42008f62:	dec731        	l32r	a3, 42000a80 <_stext+0xa60>
42008f65:	748080        	extui	a8, a8, 0, 8
42008f68:	104430        	and	a4, a4, a3
42008f6b:	118840        	slli	a8, a8, 12
42008f6e:	204480        	or	a4, a4, a8
42008f71:	0020c0        	memw
42008f74:	0149      	s32i.n	a4, a1, 0
42008f76:	0020c0        	memw
42008f79:	0138      	l32i.n	a3, a1, 0
42008f7b:	0020c0        	memw
42008f7e:	1e6932        	s32i	a3, a9, 120
}
42008f81:	f01d      	retw.n
	...

42008f84 <uart_hal_set_hw_flow_ctrl>:
{
    uart_ll_get_parity(hal->dev, parity_mode);
}

void uart_hal_set_hw_flow_ctrl(uart_hal_context_t *hal, uart_hw_flowcontrol_t flow_ctrl, uint8_t rx_thresh)
{
42008f84:	004136        	entry	a1, 32
    uart_ll_set_hw_flow_ctrl(hal->dev, flow_ctrl, rx_thresh);
42008f87:	0288      	l32i.n	a8, a2, 0
{
42008f89:	744040        	extui	a4, a4, 0, 8
    if (flow_ctrl & UART_HW_FLOWCTRL_RTS) {
42008f8c:	406307        	bbci	a3, 0, 42008fd0 <uart_hal_set_hw_flow_ctrl+0x4c>
        hw->mem_conf.rx_flow_thrhd = rx_thrs;
42008f8f:	0020c0        	memw
42008f92:	182892        	l32i	a9, a8, 96
42008f95:	debba1        	l32r	a10, 42000a84 <_stext+0xa64>
42008f98:	114490        	slli	a4, a4, 7
42008f9b:	1099a0        	and	a9, a9, a10
42008f9e:	209940        	or	a9, a9, a4
42008fa1:	0020c0        	memw
42008fa4:	186892        	s32i	a9, a8, 96
        hw->conf1.rx_flow_en = 1;
42008fa7:	0020c0        	memw
42008faa:	9898      	l32i.n	a9, a8, 36
42008fac:	1a0c      	movi.n	a10, 1
42008fae:	01aaa0        	slli	a10, a10, 22
42008fb1:	2099a0        	or	a9, a9, a10
        hw->conf1.rx_flow_en = 0;
42008fb4:	0020c0        	memw
42008fb7:	9899      	s32i.n	a9, a8, 36
        hw->conf0.tx_flow_en = 1;
42008fb9:	0020c0        	memw
42008fbc:	8898      	l32i.n	a9, a8, 32
    if (flow_ctrl & UART_HW_FLOWCTRL_CTS) {
42008fbe:	1e6317        	bbci	a3, 1, 42008fe0 <uart_hal_set_hw_flow_ctrl+0x5c>
        hw->conf0.tx_flow_en = 1;
42008fc1:	1a0c      	movi.n	a10, 1
42008fc3:	11aa10        	slli	a10, a10, 15
42008fc6:	2099a0        	or	a9, a9, a10
        hw->conf0.tx_flow_en = 0;
42008fc9:	0020c0        	memw
42008fcc:	8899      	s32i.n	a9, a8, 32
}
42008fce:	f01d      	retw.n
        hw->conf1.rx_flow_en = 0;
42008fd0:	0020c0        	memw
42008fd3:	9898      	l32i.n	a9, a8, 36
42008fd5:	dda641        	l32r	a4, 42000670 <_stext+0x650>
42008fd8:	109940        	and	a9, a9, a4
42008fdb:	fff546        	j	42008fb4 <uart_hal_set_hw_flow_ctrl+0x30>
42008fde:	00          	.byte 00
42008fdf:	00          	.byte 00
        hw->conf0.tx_flow_en = 0;
42008fe0:	dcd131        	l32r	a3, 42000324 <_stext+0x304>
42008fe3:	109930        	and	a9, a9, a3
42008fe6:	fff7c6        	j	42008fc9 <uart_hal_set_hw_flow_ctrl+0x45>
42008fe9:	000000        	ill

42008fec <uart_hal_set_tx_idle_num>:
{
    uart_ll_set_at_cmd_char(hal->dev, at_cmd);
}

void uart_hal_set_tx_idle_num(uart_hal_context_t *hal, uint16_t idle_num)
{
42008fec:	004136        	entry	a1, 32
    uart_ll_set_tx_idle_num(hal->dev, idle_num);
42008fef:	0298      	l32i.n	a9, a2, 0
    hw->idle_conf.tx_idle_num = idle_num;
42008ff1:	dea5a1        	l32r	a10, 42000a88 <_stext+0xa68>
42008ff4:	0020c0        	memw
42008ff7:	122982        	l32i	a8, a9, 72
42008ffa:	943030        	extui	a3, a3, 0, 10
42008ffd:	113360        	slli	a3, a3, 10
42009000:	1088a0        	and	a8, a8, a10
42009003:	208830        	or	a8, a8, a3
42009006:	0020c0        	memw
42009009:	126982        	s32i	a8, a9, 72
}
4200900c:	f01d      	retw.n
	...

42009010 <uart_hal_set_txfifo_empty_thr>:
{
    uart_ll_set_rxfifo_full_thr(hal->dev, full_thrhd);
}

void uart_hal_set_txfifo_empty_thr(uart_hal_context_t *hal, uint32_t empty_thrhd)
{
42009010:	004136        	entry	a1, 32
    uart_ll_set_txfifo_empty_thr(hal->dev, empty_thrhd);
42009013:	0298      	l32i.n	a9, a2, 0
    hw->conf1.txfifo_empty_thrhd = empty_thrhd;
42009015:	de9ca1        	l32r	a10, 42000a88 <_stext+0xa68>
42009018:	0020c0        	memw
4200901b:	9988      	l32i.n	a8, a9, 36
4200901d:	943030        	extui	a3, a3, 0, 10
42009020:	113360        	slli	a3, a3, 10
42009023:	1088a0        	and	a8, a8, a10
42009026:	208830        	or	a8, a8, a3
42009029:	0020c0        	memw
4200902c:	9989      	s32i.n	a8, a9, 36
}
4200902e:	f01d      	retw.n

42009030 <uart_hal_init>:
{
    uart_ll_set_loop_back(hal->dev, loop_back_en);
}

void uart_hal_init(uart_hal_context_t *hal, int uart_num)
{
42009030:	004136        	entry	a1, 32
    // Set default clock source
    uart_ll_set_sclk(hal->dev, UART_SCLK_DEFAULT);
42009033:	0288      	l32i.n	a8, a2, 0
            hw->clk_conf.sclk_sel = 1;
42009035:	de90a1        	l32r	a10, 42000a78 <_stext+0xa58>
42009038:	0020c0        	memw
4200903b:	1e2892        	l32i	a9, a8, 120
4200903e:	1099a0        	and	a9, a9, a10
42009041:	1a0c      	movi.n	a10, 1
42009043:	01aac0        	slli	a10, a10, 20
42009046:	2099a0        	or	a9, a9, a10
42009049:	0020c0        	memw
4200904c:	1e6892        	s32i	a9, a8, 120
    hw->rs485_conf.rs485_en = 0;
4200904f:	0020c0        	memw
42009052:	132892        	l32i	a9, a8, 76
42009055:	ea7c      	movi.n	a10, -2
42009057:	1099a0        	and	a9, a9, a10
4200905a:	0020c0        	memw
4200905d:	136892        	s32i	a9, a8, 76
    hw->rs485_conf.rs485tx_rx_en= 0;
42009060:	0020c0        	memw
42009063:	132892        	l32i	a9, a8, 76
42009066:	7a7c      	movi.n	a10, -9
42009068:	1099a0        	and	a9, a9, a10
4200906b:	0020c0        	memw
4200906e:	136892        	s32i	a9, a8, 76
    hw->rs485_conf.rs485rxby_tx_en = 0;
42009071:	0020c0        	memw
42009074:	132892        	l32i	a9, a8, 76
42009077:	fa6c      	movi.n	a10, -17
42009079:	1099a0        	and	a9, a9, a10
4200907c:	0020c0        	memw
4200907f:	136892        	s32i	a9, a8, 76
    hw->conf0.irda_en = 0;
42009082:	0020c0        	memw
42009085:	8898      	l32i.n	a9, a8, 32
42009087:	dccea1        	l32r	a10, 420003c0 <_stext+0x3a0>
4200908a:	1099a0        	and	a9, a9, a10
4200908d:	0020c0        	memw
42009090:	8899      	s32i.n	a9, a8, 32
    hw->conf0.parity_en = (parity_mode >> 1) & 0x1;
42009092:	0020c0        	memw
42009095:	8898      	l32i.n	a9, a8, 32
42009097:	da7c      	movi.n	a10, -3
42009099:	1099a0        	and	a9, a9, a10
4200909c:	0020c0        	memw
4200909f:	8899      	s32i.n	a9, a8, 32
    hw->conf0.bit_num = data_bit;
420090a1:	0020c0        	memw
420090a4:	8898      	l32i.n	a9, a8, 32
420090a6:	ca0c      	movi.n	a10, 12
420090a8:	2099a0        	or	a9, a9, a10
420090ab:	0020c0        	memw
420090ae:	8899      	s32i.n	a9, a8, 32
    hw->conf0.stop_bit_num = stop_bit;
420090b0:	0020c0        	memw
420090b3:	8898      	l32i.n	a9, a8, 32
420090b5:	cfafa2        	movi	a10, -49
420090b8:	1099a0        	and	a9, a9, a10
420090bb:	0a1c      	movi.n	a10, 16
420090bd:	2099a0        	or	a9, a9, a10
420090c0:	0020c0        	memw
420090c3:	8899      	s32i.n	a9, a8, 32
    hw->idle_conf.tx_idle_num = idle_num;
420090c5:	0020c0        	memw
420090c8:	122892        	l32i	a9, a8, 72
420090cb:	de6fa1        	l32r	a10, 42000a88 <_stext+0xa68>
420090ce:	1099a0        	and	a9, a9, a10
420090d1:	0020c0        	memw
420090d4:	126892        	s32i	a9, a8, 72
        hw->conf1.rx_flow_en = 0;
420090d7:	0020c0        	memw
420090da:	9898      	l32i.n	a9, a8, 36
420090dc:	dd65a1        	l32r	a10, 42000670 <_stext+0x650>
420090df:	1099a0        	and	a9, a9, a10
420090e2:	0020c0        	memw
420090e5:	9899      	s32i.n	a9, a8, 36
        hw->conf0.tx_flow_en = 0;
420090e7:	0020c0        	memw
420090ea:	8898      	l32i.n	a9, a8, 32
420090ec:	dc8ea1        	l32r	a10, 42000324 <_stext+0x304>
420090ef:	1099a0        	and	a9, a9, a10
420090f2:	0020c0        	memw
420090f5:	8899      	s32i.n	a9, a8, 32
    uart_ll_set_stop_bits(hal->dev, UART_STOP_BITS_1);
    // Set tx idle
    uart_ll_set_tx_idle_num(hal->dev, 0);
    // Disable hw-flow control
    uart_ll_set_hw_flow_ctrl(hal->dev, UART_HW_FLOWCTRL_DISABLE, 100);
}
420090f7:	f01d      	retw.n
420090f9:	000000        	ill

420090fc <uart_hal_set_rx_timeout>:
    symbol_len += (parity_mode > UART_PARITY_DISABLE) ? 1 : 0;
    return symbol_len;
}

void uart_hal_set_rx_timeout(uart_hal_context_t *hal, const uint8_t tout)
{
420090fc:	004136        	entry	a1, 32
    uint8_t symb_len = uart_hal_get_symb_len(hal);
420090ff:	02ad      	mov.n	a10, a2
42009101:	0f08a5        	call8	4201818c <uart_hal_get_symb_len>
{
42009104:	743030        	extui	a3, a3, 0, 8
    uart_ll_set_rx_tout(hal->dev, symb_len * tout);
42009107:	82aa30        	mull	a10, a10, a3
4200910a:	0288      	l32i.n	a8, a2, 0
4200910c:	f4a0a0        	extui	a10, a10, 0, 16
 * @return None.
 */
FORCE_INLINE_ATTR void uart_ll_set_rx_tout(uart_dev_t *hw, uint16_t tout_thrd)
{
    uint16_t tout_val = tout_thrd;
    if(tout_thrd > 0) {
4200910f:	daac      	beqz.n	a10, 42009140 <uart_hal_set_rx_timeout+0x44>
        hw->mem_conf.rx_tout_thrhd = tout_val;
42009111:	0020c0        	memw
42009114:	182832        	l32i	a3, a8, 96
42009117:	de5d21        	l32r	a2, 42000a8c <_stext+0xa6c>
4200911a:	94a0a0        	extui	a10, a10, 0, 10
4200911d:	01aaf0        	slli	a10, a10, 17
42009120:	103320        	and	a3, a3, a2
42009123:	2033a0        	or	a3, a3, a10
42009126:	0020c0        	memw
42009129:	186832        	s32i	a3, a8, 96
        hw->conf1.rx_tout_en = 1;
4200912c:	0020c0        	memw
4200912f:	9838      	l32i.n	a3, a8, 36
42009131:	190c      	movi.n	a9, 1
42009133:	019990        	slli	a9, a9, 23
42009136:	203390        	or	a3, a3, a9
    } else {
        hw->conf1.rx_tout_en = 0;
42009139:	0020c0        	memw
4200913c:	9839      	s32i.n	a3, a8, 36
}
4200913e:	f01d      	retw.n
42009140:	0020c0        	memw
42009143:	9838      	l32i.n	a3, a8, 36
42009145:	ddd321        	l32r	a2, 42000894 <_stext+0x874>
42009148:	103320        	and	a3, a3, a2
4200914b:	fffa86        	j	42009139 <uart_hal_set_rx_timeout+0x3d>
	...

42009150 <get_flash_clock_divider>:
#define APB_CYCLE_NS   (1000*1000*1000LL/APB_CLK_FREQ)

static const char *TAG = "flash_hal";

static uint32_t get_flash_clock_divider(const spi_flash_hal_config_t *cfg)
{
42009150:	004136        	entry	a1, 32
    int clk_source = cfg->clock_src_freq;
42009153:	c2a8      	l32i.n	a10, a2, 48
    // If user passes freq_mhz like 26 or 27, it's allowed to use integer divider 3.
    // However on other chips or on other frequency, we only allow user pass frequency which
    // can be integer divided. If no, the following strategy is round up the division and
    // round down flash frequency to keep it safe.
    int best_div = 0;
    if (clk_source < cfg->freq_mhz) {
42009155:	b228      	l32i.n	a2, a2, 44
42009157:	05aa27        	bge	a10, a2, 42009160 <get_flash_clock_divider+0x10>
        HAL_LOGE(TAG, "Target frequency %dMHz higher than supported.", cfg->freq_mhz);
        abort();
4200915a:	dbf081        	l32r	a8, 4200011c <_stext+0xfc>
4200915d:	0008e0        	callx8	a8
    if (cfg->freq_mhz == 26 || cfg->freq_mhz == 27) {
        best_div = 3;
    } else
#endif
    {
        best_div = (int)ceil((double)clk_source / (double)cfg->freq_mhz);
42009160:	dda781        	l32r	a8, 420007fc <_stext+0x7dc>
42009163:	0008e0        	callx8	a8
42009166:	204aa0        	or	a4, a10, a10
42009169:	20a220        	or	a10, a2, a2
4200916c:	205bb0        	or	a5, a11, a11
4200916f:	dda381        	l32r	a8, 420007fc <_stext+0x7dc>
42009172:	0008e0        	callx8	a8
42009175:	0acd      	mov.n	a12, a10
42009177:	0bdd      	mov.n	a13, a11
42009179:	04ad      	mov.n	a10, a4
4200917b:	05bd      	mov.n	a11, a5
4200917d:	de4481        	l32r	a8, 42000a90 <_stext+0xa70>
42009180:	0008e0        	callx8	a8
42009183:	005425        	call8	420096c4 <ceil>
42009186:	dd9f81        	l32r	a8, 42000804 <_stext+0x7e4>
42009189:	0008e0        	callx8	a8
            HAL_LOGW(TAG, "Flash clock frequency round down to %d", (int)floor((double)clk_source / (double)best_div));
        }
    }

    return best_div;
}
4200918c:	0a2d      	mov.n	a2, a10
4200918e:	f01d      	retw.n

42009190 <spi_flash_hal_init>:
    return extra_dummy;
}
#endif //SOC_SPI_MEM_SUPPORT_TIME_TUNING

esp_err_t spi_flash_hal_init(spi_flash_hal_context_t *data_out, const spi_flash_hal_config_t *cfg)
{
42009190:	006136        	entry	a1, 48
    if (cfg->cs_num >= SOC_SPI_PERIPH_CS_NUM(cfg->host_id)) {
42009193:	7368      	l32i.n	a6, a3, 28
42009195:	8378      	l32i.n	a7, a3, 32
42009197:	240c      	movi.n	a4, 2
42009199:	868c      	beqz.n	a6, 420091a5 <spi_flash_hal_init+0x15>
4200919b:	560b      	addi.n	a5, a6, -1
4200919d:	640c      	movi.n	a4, 6
4200919f:	03a082        	movi	a8, 3
420091a2:	934850        	movnez	a4, a8, a5
420091a5:	022747        	blt	a7, a4, 420091ab <spi_flash_hal_init+0x1b>
420091a8:	004d06        	j	420092e0 <spi_flash_hal_init+0x150>
        return ESP_ERR_INVALID_ARG;
    }

    *data_out = (spi_flash_hal_context_t) {
        .inst = data_out->inst, // Keeps the function pointer table
420091ab:	02d8      	l32i.n	a13, a2, 0
        .spi = spi_flash_ll_get_hw(cfg->host_id),
420091ad:	d68c      	beqz.n	a6, 420091be <spi_flash_hal_init+0x2e>
420091af:	7a1626        	beqi	a6, 1, 4200922d <spi_flash_hal_init+0x9d>
420091b2:	de3a51        	l32r	a5, 42000a9c <_stext+0xa7c>
420091b5:	082626        	beqi	a6, 2, 420091c1 <spi_flash_hal_init+0x31>
420091b8:	dbd981        	l32r	a8, 4200011c <_stext+0xfc>
420091bb:	0008e0        	callx8	a8
420091be:	de3551        	l32r	a5, 42000a94 <_stext+0xa74>
        .cs_num = cfg->cs_num,
        .cs_hold = cfg->cs_hold,
        .cs_setup = cfg->cs_setup,
420091c1:	080392        	l8ui	a9, a3, 8
    *data_out = (spi_flash_hal_context_t) {
420091c4:	040382        	l8ui	a8, a3, 4
420091c7:	8c2c      	movi.n	a12, 40
420091c9:	0b0c      	movi.n	a11, 0
420091cb:	02ad      	mov.n	a10, a2
        .base_io_mode = cfg->default_io_mode,
420091cd:	a348      	l32i.n	a4, a3, 40
    *data_out = (spi_flash_hal_context_t) {
420091cf:	016182        	s32i	a8, a1, 4
420091d2:	006192        	s32i	a9, a1, 0
420091d5:	21d9      	s32i.n	a13, a1, 8
420091d7:	dbf081        	l32r	a8, 42000198 <_stext+0x178>
420091da:	0008e0        	callx8	a8
420091dd:	0198      	l32i.n	a9, a1, 0
420091df:	21d8      	l32i.n	a13, a1, 8
420091e1:	0d4292        	s8i	a9, a2, 13
420091e4:	1188      	l32i.n	a8, a1, 4
420091e6:	1259      	s32i.n	a5, a2, 4
420091e8:	0e4282        	s8i	a8, a2, 14
    };
#if SOC_SPI_MEM_SUPPORT_TIME_TUNING
    if (cfg->using_timing_tuning) {
420091eb:	260352        	l8ui	a5, a3, 38
    *data_out = (spi_flash_hal_context_t) {
420091ee:	02d9      	s32i.n	a13, a2, 0
420091f0:	2279      	s32i.n	a7, a2, 8
420091f2:	5249      	s32i.n	a4, a2, 20
    if (cfg->using_timing_tuning) {
420091f4:	d5bc      	beqz.n	a5, 42009235 <spi_flash_hal_init+0xa5>
    if (main_flash) {
420091f6:	207760        	or	a7, a7, a6
420091f9:	fbb756        	bnez	a7, 420091b8 <spi_flash_hal_init+0x28>
        data_out->extra_dummy = extra_dummy_under_timing_tuning(cfg);
420091fc:	0358      	l32i.n	a5, a3, 0
420091fe:	0c4252        	s8i	a5, a2, 12
        data_out->clock_conf = cfg->clock_config;
42009201:	3358      	l32i.n	a5, a3, 12
42009203:	4259      	s32i.n	a5, a2, 16
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
        data_out->clock_conf = (spi_flash_ll_clock_reg_t)spi_flash_cal_clock(cfg);
    }


    if (cfg->auto_sus_en) {
42009205:	240352        	l8ui	a5, a3, 36
42009208:	004516        	beqz	a5, 42009210 <spi_flash_hal_init+0x80>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_SUSPEND;
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_AUTO_RESUME;
4200920b:	03a052        	movi	a5, 3
4200920e:	6259      	s32i.n	a5, a2, 24
    }

#if SOC_SPI_MEM_SUPPORT_OPI_MODE
    if (cfg->octal_mode_en) {
42009210:	250332        	l8ui	a3, a3, 37
42009213:	738c      	beqz.n	a3, 4200921e <spi_flash_hal_init+0x8e>
        data_out->flags |= SPI_FLASH_HOST_CONTEXT_FLAG_OCTAL_MODE;
42009215:	6238      	l32i.n	a3, a2, 24
42009217:	450c      	movi.n	a5, 4
42009219:	203350        	or	a3, a3, a5
4200921c:	6239      	s32i.n	a3, a2, 24
    }

    if (cfg->default_io_mode == SPI_FLASH_OPI_DTR) {
4200921e:	151c      	movi.n	a5, 17
        data_out->slicer_flags |= SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR;
    }
#endif

    return ESP_OK;
42009220:	030c      	movi.n	a3, 0
    if (cfg->default_io_mode == SPI_FLASH_OPI_DTR) {
42009222:	039457        	bne	a4, a5, 42009229 <spi_flash_hal_init+0x99>
        data_out->slicer_flags |= SPI_FLASH_HOST_CONTEXT_SLICER_FLAG_DTR;
42009225:	140c      	movi.n	a4, 1
42009227:	9249      	s32i.n	a4, a2, 36
}
42009229:	032d      	mov.n	a2, a3
4200922b:	f01d      	retw.n
        .spi = spi_flash_ll_get_hw(cfg->host_id),
4200922d:	de1a51        	l32r	a5, 42000a98 <_stext+0xa78>
42009230:	ffe346        	j	420091c1 <spi_flash_hal_init+0x31>
42009233:	00          	.byte 00
42009234:	00          	.byte 00
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
42009235:	03ad      	mov.n	a10, a3
42009237:	fff1a5        	call8	42009150 <get_flash_clock_divider>
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200923a:	5388      	l32i.n	a8, a3, 20
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
4200923c:	de1971        	l32r	a7, 42000aa0 <_stext+0xa80>
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200923f:	881b      	addi.n	a8, a8, 1
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
42009241:	c2a7a0        	quou	a10, a7, a10
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
42009244:	a08880        	addx4	a8, a8, a8
    const int apbclk_n = APB_CLK_FREQ / eff_clk;
42009247:	d2a7a0        	quos	a10, a7, a10
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
4200924a:	1188c0        	slli	a8, a8, 4
    if (apb_period_n < 0) {
4200924d:	19ac72        	movi	a7, 0xfffffc19
42009250:	0e2877        	blt	a8, a7, 42009262 <spi_flash_hal_init+0xd2>
    int apb_period_n = (1 + input_delay_ns + gpio_delay_ns) * apbclk_kHz / 1000 / 1000;
42009253:	de1451        	l32r	a5, 42000aa4 <_stext+0xa84>
42009256:	b25850        	mulsh	a5, a8, a5
42009259:	318f80        	srai	a8, a8, 31
4200925c:	215650        	srai	a5, a5, 6
4200925f:	c05580        	sub	a5, a5, a8
    return apb_period_n / apbclk_n;
42009262:	d255a0        	quos	a5, a5, a10
        data_out->extra_dummy = get_dummy_n(!cfg->iomux, cfg->input_delay_ns, APB_CLK_FREQ/get_flash_clock_divider(cfg));
42009265:	0c4252        	s8i	a5, a2, 12
    uint32_t div_parameter = spi_flash_ll_calculate_clock_reg(cfg->host_id, get_flash_clock_divider(cfg));
42009268:	03ad      	mov.n	a10, a3
4200926a:	66fc      	bnez.n	a6, 420092a4 <spi_flash_hal_init+0x114>
4200926c:	ffee25        	call8	42009150 <get_flash_clock_divider>
4200926f:	7450a0        	extui	a5, a10, 0, 8
static inline uint32_t spimem_flash_ll_calculate_clock_reg(uint8_t clkdiv)
{
    uint32_t div_parameter;
    // See comments of `clock` in `spi_mem_struct.h`
    if (clkdiv == 1) {
        div_parameter = (1 << 31);
42009272:	f87c      	movi.n	a8, -1
    if (clkdiv == 1) {
42009274:	74a0a0        	extui	a10, a10, 0, 8
        div_parameter = (1 << 31);
42009277:	018810        	slli	a8, a8, 31
    if (clkdiv == 1) {
4200927a:	1e1a26        	beqi	a10, 1, 4200929c <spi_flash_hal_init+0x10c>
    } else {
        div_parameter = ((clkdiv - 1) | (((clkdiv - 1) / 2 & 0xff) << 8 ) | (((clkdiv - 1) & 0xff) << 16));
4200927d:	550b      	addi.n	a5, a5, -1
4200927f:	058f50        	extui	a8, a5, 31, 1
42009282:	885a      	add.n	a8, a8, a5
42009284:	ffa072        	movi	a7, 255
42009287:	218180        	srai	a8, a8, 1
4200928a:	116500        	slli	a6, a5, 16
4200928d:	117700        	slli	a7, a7, 16
42009290:	118880        	slli	a8, a8, 8
42009293:	106670        	and	a6, a6, a7
42009296:	208860        	or	a8, a8, a6
42009299:	208850        	or	a8, a8, a5
        data_out->clock_conf = (spi_flash_ll_clock_reg_t)spi_flash_cal_clock(cfg);
4200929c:	0020c0        	memw
4200929f:	4289      	s32i.n	a8, a2, 16
420092a1:	ffd806        	j	42009205 <spi_flash_hal_init+0x75>
    uint32_t div_parameter = spi_flash_ll_calculate_clock_reg(cfg->host_id, get_flash_clock_divider(cfg));
420092a4:	ffeaa5        	call8	42009150 <get_flash_clock_divider>
420092a7:	7450a0        	extui	a5, a10, 0, 8
        div_parameter = (1 << 31);
420092aa:	ffaf82        	movi	a8, -1
420092ad:	74a0a0        	extui	a10, a10, 0, 8
420092b0:	018810        	slli	a8, a8, 31
 */
static inline uint32_t gpspi_flash_ll_calculate_clock_reg(uint8_t clkdiv)
{
    uint32_t div_parameter;
    // See comments of `clock` in `spi_struct.h`
    if (clkdiv == 1) {
420092b3:	e51a26        	beqi	a10, 1, 4200929c <spi_flash_hal_init+0x10c>
        div_parameter = (1 << 31);
    } else {
        div_parameter = ((clkdiv - 1) | (((clkdiv/2 - 1) & 0xff) << 6 ) | (((clkdiv - 1) & 0xff) << 12));
420092b6:	41a1a0        	srli	a10, a10, 1
420092b9:	ffcaa2        	addi	a10, a10, -1
420092bc:	ffa062        	movi	a6, 255
420092bf:	1166a0        	slli	a6, a6, 6
420092c2:	11aaa0        	slli	a10, a10, 6
420092c5:	ffc552        	addi	a5, a5, -1
420092c8:	10aa60        	and	a10, a10, a6
420092cb:	ffa062        	movi	a6, 255
420092ce:	118540        	slli	a8, a5, 12
420092d1:	116640        	slli	a6, a6, 12
420092d4:	108860        	and	a8, a8, a6
420092d7:	208850        	or	a8, a8, a5
420092da:	208a80        	or	a8, a10, a8
420092dd:	ffeec6        	j	4200929c <spi_flash_hal_init+0x10c>
        return ESP_ERR_INVALID_ARG;
420092e0:	02a132        	movi	a3, 0x102
420092e3:	ffd086        	j	42009229 <spi_flash_hal_init+0x99>
	...

420092e8 <spi_flash_hal_supports_direct_write>:

bool spi_flash_hal_supports_direct_write(spi_flash_host_inst_t *host, const void *p)
{
420092e8:	004136        	entry	a1, 32
    (void)p;
    bool direct_write = (((spi_flash_hal_context_t *)host)->spi != spi_flash_ll_get_hw(SPI1_HOST));
420092eb:	1288      	l32i.n	a8, a2, 4
420092ed:	dde921        	l32r	a2, 42000a94 <_stext+0xa74>
420092f0:	090c      	movi.n	a9, 0
420092f2:	c08820        	sub	a8, a8, a2
420092f5:	120c      	movi.n	a2, 1
420092f7:	832980        	moveqz	a2, a9, a8
    return direct_write;
}
420092fa:	f01d      	retw.n

420092fc <spi_flash_hal_supports_direct_read>:
420092fc:	004136        	entry	a1, 32
420092ff:	1288      	l32i.n	a8, a2, 4
42009301:	dde421        	l32r	a2, 42000a94 <_stext+0xa74>
42009304:	090c      	movi.n	a9, 0
42009306:	c08820        	sub	a8, a8, a2
42009309:	120c      	movi.n	a2, 1
4200930b:	832980        	moveqz	a2, a9, a8
4200930e:	f01d      	retw.n

42009310 <periph_rtc_dig_clk8m_enable>:
static int s_apll_ref_cnt = 0;
#endif


bool periph_rtc_dig_clk8m_enable(void)
{
42009310:	004136        	entry	a1, 32
42009313:	dde531        	l32r	a3, 42000aa8 <_stext+0xa88>
42009316:	fb7c      	movi.n	a11, -1
42009318:	03ad      	mov.n	a10, a3
4200931a:	db4981        	l32r	a8, 42000040 <_stext+0x20>
4200931d:	0008e0        	callx8	a8
    portENTER_CRITICAL(&periph_spinlock);
    if (s_periph_ref_counts == 0) {
42009320:	dde341        	l32r	a4, 42000aac <_stext+0xa8c>
42009323:	000422        	l8ui	a2, a4, 0
42009326:	a2ec      	bnez.n	a2, 42009354 <periph_rtc_dig_clk8m_enable+0x44>
        rtc_dig_clk8m_enable();
42009328:	dde381        	l32r	a8, 42000ab4 <_stext+0xa94>
4200932b:	0008e0        	callx8	a8
#if !CONFIG_IDF_TARGET_ESP32H2
        s_rtc_clk_freq = rtc_clk_freq_cal(rtc_clk_cal(RTC_CAL_8MD256, 100));
4200932e:	64a0b2        	movi	a11, 100
42009331:	1a0c      	movi.n	a10, 1
42009333:	db4981        	l32r	a8, 42000058 <_stext+0x38>
42009336:	0008e0        	callx8	a8
42009339:	dddf81        	l32r	a8, 42000ab8 <_stext+0xa98>
4200933c:	0008e0        	callx8	a8
4200933f:	dddc81        	l32r	a8, 42000ab0 <_stext+0xa90>
42009342:	0a2d      	mov.n	a2, a10
42009344:	08a9      	s32i.n	a10, a8, 0
        if (s_rtc_clk_freq == 0) {
42009346:	aacc      	bnez.n	a10, 42009354 <periph_rtc_dig_clk8m_enable+0x44>
            portEXIT_CRITICAL(&periph_spinlock);
42009348:	03ad      	mov.n	a10, a3
4200934a:	db3e81        	l32r	a8, 42000044 <_stext+0x24>
4200934d:	0008e0        	callx8	a8
#endif
    }
    s_periph_ref_counts++;
    portEXIT_CRITICAL(&periph_spinlock);
    return true;
}
42009350:	f01d      	retw.n
42009352:	00          	.byte 00
42009353:	00          	.byte 00
    s_periph_ref_counts++;
42009354:	000422        	l8ui	a2, a4, 0
    portEXIT_CRITICAL(&periph_spinlock);
42009357:	03ad      	mov.n	a10, a3
    s_periph_ref_counts++;
42009359:	221b      	addi.n	a2, a2, 1
4200935b:	004422        	s8i	a2, a4, 0
    portEXIT_CRITICAL(&periph_spinlock);
4200935e:	db3981        	l32r	a8, 42000044 <_stext+0x24>
42009361:	0008e0        	callx8	a8
    return true;
42009364:	120c      	movi.n	a2, 1
42009366:	fff986        	j	42009350 <periph_rtc_dig_clk8m_enable+0x40>
42009369:	000000        	ill

4200936c <periph_rtc_dig_clk8m_disable>:
    return s_rtc_clk_freq * 256;
#endif
}

void periph_rtc_dig_clk8m_disable(void)
{
4200936c:	004136        	entry	a1, 32
4200936f:	ddce21        	l32r	a2, 42000aa8 <_stext+0xa88>
42009372:	fb7c      	movi.n	a11, -1
42009374:	02ad      	mov.n	a10, a2
42009376:	db3281        	l32r	a8, 42000040 <_stext+0x20>
42009379:	0008e0        	callx8	a8
    portENTER_CRITICAL(&periph_spinlock);
    assert(s_periph_ref_counts > 0);
4200937c:	ddcc91        	l32r	a9, 42000aac <_stext+0xa8c>
4200937f:	000982        	l8ui	a8, a9, 0
42009382:	f8cc      	bnez.n	a8, 42009395 <periph_rtc_dig_clk8m_disable+0x29>
42009384:	ddced1        	l32r	a13, 42000abc <_stext+0xa9c>
42009387:	ddcec1        	l32r	a12, 42000ac0 <_stext+0xaa0>
4200938a:	ddcea1        	l32r	a10, 42000ac4 <_stext+0xaa4>
4200938d:	7b3c      	movi.n	a11, 55
4200938f:	db3d81        	l32r	a8, 42000084 <_stext+0x64>
42009392:	0008e0        	callx8	a8
    s_periph_ref_counts--;
42009395:	880b      	addi.n	a8, a8, -1
42009397:	748080        	extui	a8, a8, 0, 8
4200939a:	004982        	s8i	a8, a9, 0
    if (s_periph_ref_counts == 0) {
4200939d:	98cc      	bnez.n	a8, 420093aa <periph_rtc_dig_clk8m_disable+0x3e>
        s_rtc_clk_freq = 0;
4200939f:	ddc491        	l32r	a9, 42000ab0 <_stext+0xa90>
420093a2:	0989      	s32i.n	a8, a9, 0
        rtc_dig_clk8m_disable();
420093a4:	ddc981        	l32r	a8, 42000ac8 <_stext+0xaa8>
420093a7:	0008e0        	callx8	a8
    }
    portEXIT_CRITICAL(&periph_spinlock);
420093aa:	02ad      	mov.n	a10, a2
420093ac:	db2681        	l32r	a8, 42000044 <_stext+0x24>
420093af:	0008e0        	callx8	a8
}
420093b2:	f01d      	retw.n

420093b4 <esp_partition_main_flash_region_safe>:
    }
    return false;
}

bool esp_partition_main_flash_region_safe(size_t addr, size_t size)
{
420093b4:	004136        	entry	a1, 32
    bool result = true;
    if (addr <= ESP_PARTITION_TABLE_OFFSET + ESP_PARTITION_TABLE_MAX_LEN) {
420093b7:	382c      	movi.n	a8, 35
420093b9:	118860        	slli	a8, a8, 10
        return false;
420093bc:	040c      	movi.n	a4, 0
    if (addr <= ESP_PARTITION_TABLE_OFFSET + ESP_PARTITION_TABLE_MAX_LEN) {
420093be:	16b827        	bgeu	a8, a2, 420093d8 <esp_partition_main_flash_region_safe+0x24>
    }
    const esp_partition_t *p = esp_ota_get_running_partition();
420093c1:	0002a5        	call8	420093ec <esp_ota_get_running_partition>
    if (addr >= p->address && addr < p->address + p->size) {
420093c4:	3a88      	l32i.n	a8, a10, 12
420093c6:	123287        	bltu	a2, a8, 420093dc <esp_partition_main_flash_region_safe+0x28>
420093c9:	4a38      	l32i.n	a3, a10, 16
420093cb:	883a      	add.n	a8, a8, a3
420093cd:	130c      	movi.n	a3, 1
420093cf:	02b287        	bgeu	a2, a8, 420093d5 <esp_partition_main_flash_region_safe+0x21>
420093d2:	203440        	or	a3, a4, a4
420093d5:	744030        	extui	a4, a3, 0, 8
    }
    if (addr < p->address && addr + size > p->address) {
        return false;
    }
    return result;
}
420093d8:	042d      	mov.n	a2, a4
420093da:	f01d      	retw.n
    if (addr < p->address && addr + size > p->address) {
420093dc:	323a      	add.n	a3, a2, a3
420093de:	120c      	movi.n	a2, 1
420093e0:	01b837        	bgeu	a8, a3, 420093e5 <esp_partition_main_flash_region_safe+0x31>
420093e3:	042d      	mov.n	a2, a4
420093e5:	744020        	extui	a4, a2, 0, 8
420093e8:	fffb06        	j	420093d8 <esp_partition_main_flash_region_safe+0x24>
	...

420093ec <esp_ota_get_running_partition>:
    }
}


const esp_partition_t* esp_ota_get_running_partition(void)
{
420093ec:	004136        	entry	a1, 32

    /*
     * Currently running partition is unlikely to change across reset cycle,
     * so it can be cached here, and avoid lookup on every flash write operation.
     */
    if (curr_partition != NULL) {
420093ef:	ddb751        	l32r	a5, 42000acc <_stext+0xaac>
420093f2:	0528      	l32i.n	a2, a5, 0
420093f4:	056256        	bnez	a2, 4200944e <esp_ota_get_running_partition+0x62>
        return curr_partition;
    }

    /* Find the flash address of this exact function. By definition that is part
       of the currently running firmware. Then find the enclosing partition. */
    size_t phys_offs = spi_flash_cache2phys(esp_ota_get_running_partition);
420093f7:	ddb6a1        	l32r	a10, 42000ad0 <_stext+0xab0>
420093fa:	ff2325        	call8	4200862c <spi_flash_cache2phys>
420093fd:	0a4d      	mov.n	a4, a10

    assert (phys_offs != SPI_FLASH_CACHE2PHYS_FAIL); /* indicates cache2phys lookup is buggy */
420093ff:	110a66        	bnei	a10, -1, 42009414 <esp_ota_get_running_partition+0x28>
42009402:	ddb4d1        	l32r	a13, 42000ad4 <_stext+0xab4>
42009405:	ddb4c1        	l32r	a12, 42000ad8 <_stext+0xab8>
42009408:	30a2b2        	movi	a11, 0x230

    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP,
                                                     ESP_PARTITION_SUBTYPE_ANY,
                                                     NULL);
    assert(it != NULL); /* has to be at least one app partition */
4200940b:	ddb4a1        	l32r	a10, 42000adc <_stext+0xabc>
4200940e:	db1d81        	l32r	a8, 42000084 <_stext+0x64>
42009411:	0008e0        	callx8	a8
    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_APP,
42009414:	20c220        	or	a12, a2, a2
42009417:	ffa0b2        	movi	a11, 255
4200941a:	20a220        	or	a10, a2, a2
4200941d:	0022e5        	call8	4200964c <esp_partition_find>
42009420:	203aa0        	or	a3, a10, a10
    assert(it != NULL); /* has to be at least one app partition */
42009423:	bacc      	bnez.n	a10, 42009432 <esp_ota_get_running_partition+0x46>
42009425:	ddaed1        	l32r	a13, 42000ae0 <_stext+0xac0>
42009428:	ddacc1        	l32r	a12, 42000ad8 <_stext+0xab8>
4200942b:	35a2b2        	movi	a11, 0x235
4200942e:	fff646        	j	4200940b <esp_ota_get_running_partition+0x1f>
42009431:	00          	.byte 00

    while (it != NULL) {
        const esp_partition_t *p = esp_partition_get(it);
42009432:	20a330        	or	a10, a3, a3
42009435:	002725        	call8	420096a8 <esp_partition_get>
        if (p->address <= phys_offs && p->address + p->size > phys_offs) {
42009438:	032a82        	l32i	a8, a10, 12
        const esp_partition_t *p = esp_partition_get(it);
4200943b:	0a2d      	mov.n	a2, a10
            esp_partition_iterator_release(it);
4200943d:	03ad      	mov.n	a10, a3
        if (p->address <= phys_offs && p->address + p->size > phys_offs) {
4200943f:	0d3487        	bltu	a4, a8, 42009450 <esp_ota_get_running_partition+0x64>
42009442:	4298      	l32i.n	a9, a2, 16
42009444:	889a      	add.n	a8, a8, a9
42009446:	06b487        	bgeu	a4, a8, 42009450 <esp_ota_get_running_partition+0x64>
            esp_partition_iterator_release(it);
42009449:	0024e5        	call8	42009698 <esp_partition_iterator_release>
            curr_partition = p;
4200944c:	0529      	s32i.n	a2, a5, 0
        }
        it = esp_partition_next(it);
    }

    abort(); /* Partition table is invalid or corrupt */
}
4200944e:	f01d      	retw.n
        it = esp_partition_next(it);
42009450:	0017e5        	call8	420095d0 <esp_partition_next>
42009453:	0a3d      	mov.n	a3, a10
    while (it != NULL) {
42009455:	fd9a56        	bnez	a10, 42009432 <esp_ota_get_running_partition+0x46>
    abort(); /* Partition table is invalid or corrupt */
42009458:	db3181        	l32r	a8, 4200011c <_stext+0xfc>
4200945b:	0008e0        	callx8	a8
	...

42009460 <ensure_partitions_loaded$part$0>:
#endif

    return err;
}

static esp_err_t ensure_partitions_loaded(void)
42009460:	014136        	entry	a1, 160
{
    esp_err_t err = ESP_OK;
    if (SLIST_EMPTY(&s_partition_list)) {
        // only lock if list is empty (and check again after acquiring lock)
        _lock_acquire(&s_partition_list_lock);
42009463:	dda061        	l32r	a6, 42000ae4 <_stext+0xac4>
42009466:	06ad      	mov.n	a10, a6
42009468:	dc5d81        	l32r	a8, 420005dc <_stext+0x5bc>
4200946b:	0008e0        	callx8	a8
        if (SLIST_EMPTY(&s_partition_list)) {
4200946e:	dd9e21        	l32r	a2, 42000ae8 <_stext+0xac8>
42009471:	0238      	l32i.n	a3, a2, 0
    esp_err_t err = ESP_OK;
42009473:	020c      	movi.n	a2, 0
        if (SLIST_EMPTY(&s_partition_list)) {
42009475:	021327        	beq	a3, a2, 4200947b <ensure_partitions_loaded$part$0+0x1b>
42009478:	005246        	j	420095c5 <ensure_partitions_loaded$part$0+0x165>
    esp_rom_md5_init(&context);
4200947b:	20a110        	or	a10, a1, a1
4200947e:	dd9d81        	l32r	a8, 42000af4 <_stext+0xad4>
42009481:	0008e0        	callx8	a8
    esp_err_t err = spi_flash_mmap(partition_align_pg_size,
42009484:	1b0c      	movi.n	a11, 1
42009486:	78c1e2        	addi	a14, a1, 120
42009489:	7cc1d2        	addi	a13, a1, 124
4200948c:	03cd      	mov.n	a12, a3
4200948e:	11bb40        	slli	a11, a11, 12
42009491:	20a330        	or	a10, a3, a3
42009494:	dd9981        	l32r	a8, 42000af8 <_stext+0xad8>
42009497:	0008e0        	callx8	a8
4200949a:	0a2d      	mov.n	a2, a10
    if (err != ESP_OK) {
4200949c:	125a56        	bnez	a10, 420095c5 <ensure_partitions_loaded$part$0+0x165>
    p_start += partition_pad;
4200949f:	1f2152        	l32i	a5, a1, 124
420094a2:	120c      	movi.n	a2, 1
420094a4:	112210        	slli	a2, a2, 15
420094a7:	940c      	movi.n	a4, 9
420094a9:	252a      	add.n	a2, a5, a2
420094ab:	114440        	slli	a4, a4, 12
420094ae:	554a      	add.n	a5, a5, a4
420094b0:	1f6122        	s32i	a2, a1, 124
    typeof(s_partition_list) new_partitions_list = SLIST_HEAD_INITIALIZER(s_partition_list);
420094b3:	034d      	mov.n	a4, a3
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
420094b5:	079257        	bne	a2, a5, 420094c0 <ensure_partitions_loaded$part$0+0x60>
        err = ESP_ERR_NOT_FOUND;
420094b8:	05a122        	movi	a2, 0x105
        while (it) {
420094bb:	003246        	j	42009588 <ensure_partitions_loaded$part$0+0x128>
420094be:	00          	.byte 00
420094bf:	00          	.byte 00
        memcpy(&entry, p_entry, sizeof(entry));
420094c0:	0c2c      	movi.n	a12, 32
420094c2:	02bd      	mov.n	a11, a2
420094c4:	58c1a2        	addi	a10, a1, 88
420094c7:	db4181        	l32r	a8, 420001cc <_stext+0x1ac>
420094ca:	0008e0        	callx8	a8
        if (entry.magic == ESP_PARTITION_MAGIC_MD5) {
420094cd:	dd8781        	l32r	a8, 42000aec <_stext+0xacc>
420094d0:	2c1192        	l16ui	a9, a1, 88
420094d3:	f48080        	extui	a8, a8, 0, 16
420094d6:	029987        	bne	a9, a8, 420094dc <ensure_partitions_loaded$part$0+0x7c>
420094d9:	002f46        	j	4200959a <ensure_partitions_loaded$part$0+0x13a>
        if (entry.magic != ESP_PARTITION_MAGIC) {
420094dc:	dd8581        	l32r	a8, 42000af0 <_stext+0xad0>
420094df:	f48080        	extui	a8, a8, 0, 16
420094e2:	d29987        	bne	a9, a8, 420094b8 <ensure_partitions_loaded$part$0+0x58>
        esp_rom_md5_update(&context, &entry, sizeof(entry));
420094e5:	0c2c      	movi.n	a12, 32
420094e7:	58c1b2        	addi	a11, a1, 88
420094ea:	01ad      	mov.n	a10, a1
420094ec:	dd8481        	l32r	a8, 42000afc <_stext+0xadc>
420094ef:	0008e0        	callx8	a8
        partition_list_item_t *item = (partition_list_item_t *) calloc(sizeof(partition_list_item_t), 1);
420094f2:	1b0c      	movi.n	a11, 1
420094f4:	4a3c      	movi.n	a10, 52
420094f6:	dd4881        	l32r	a8, 42000a18 <_stext+0x9f8>
420094f9:	0008e0        	callx8	a8
420094fc:	0a7d      	mov.n	a7, a10
        if (item == NULL) {
420094fe:	fb6a16        	beqz	a10, 420094b8 <ensure_partitions_loaded$part$0+0x58>
        item->info.flash_chip = esp_flash_default_chip;
42009501:	dd1991        	l32r	a9, 42000968 <_stext+0x948>
42009504:	0998      	l32i.n	a9, a9, 0
42009506:	0a99      	s32i.n	a9, a10, 0
        item->info.address = entry.pos.offset;
42009508:	172192        	l32i	a9, a1, 92
4200950b:	3a99      	s32i.n	a9, a10, 12
        item->info.size = entry.pos.size;
4200950d:	182192        	l32i	a9, a1, 96
42009510:	4a99      	s32i.n	a9, a10, 16
        item->info.erase_size = SPI_FLASH_SEC_SIZE;
42009512:	dce691        	l32r	a9, 420008ac <_stext+0x88c>
42009515:	5a99      	s32i.n	a9, a10, 20
        item->info.type = entry.type;
42009517:	5a0192        	l8ui	a9, a1, 90
4200951a:	1a99      	s32i.n	a9, a10, 4
        item->info.subtype = entry.subtype;
4200951c:	5b0192        	l8ui	a9, a1, 91
4200951f:	2a99      	s32i.n	a9, a10, 8
        item->info.encrypted = entry.flags & PART_FLAG_ENCRYPTED;
42009521:	1d2192        	l32i	a9, a1, 116
42009524:	049090        	extui	a9, a9, 0, 1
42009527:	294a92        	s8i	a9, a10, 41
        item->user_registered = false;
4200952a:	090c      	movi.n	a9, 0
4200952c:	2c4a92        	s8i	a9, a10, 44
        if (!esp_flash_encryption_enabled()) {
4200952f:	dd7481        	l32r	a8, 42000b00 <_stext+0xae0>
42009532:	0008e0        	callx8	a8
42009535:	fadc      	bnez.n	a10, 42009558 <ensure_partitions_loaded$part$0+0xf8>
            item->info.encrypted = false;
42009537:	2947a2        	s8i	a10, a7, 41
        strncpy(item->info.label, (const char *) entry.label, sizeof(item->info.label) - 1);
4200953a:	0c1c      	movi.n	a12, 16
4200953c:	64c1b2        	addi	a11, a1, 100
4200953f:	18c7a2        	addi	a10, a7, 24
42009542:	dd7081        	l32r	a8, 42000b04 <_stext+0xae4>
42009545:	0008e0        	callx8	a8
        if (last == NULL) {
42009548:	d3ec      	bnez.n	a3, 42009579 <ensure_partitions_loaded$part$0+0x119>
            SLIST_INSERT_HEAD(&new_partitions_list, item, next);
4200954a:	c749      	s32i.n	a4, a7, 48
4200954c:	074d      	mov.n	a4, a7
    for (const uint8_t *p_entry = p_start; p_entry < p_end; p_entry += sizeof(esp_partition_info_t)) {
4200954e:	20c222        	addi	a2, a2, 32
42009551:	073d      	mov.n	a3, a7
42009553:	ffd786        	j	420094b5 <ensure_partitions_loaded$part$0+0x55>
42009556:	00          	.byte 00
42009557:	00          	.byte 00
        } else if (entry.type == ESP_PARTITION_TYPE_APP
42009558:	5a0192        	l8ui	a9, a1, 90
4200955b:	299c      	beqz.n	a9, 42009571 <ensure_partitions_loaded$part$0+0x111>
                   || (entry.type == ESP_PARTITION_TYPE_DATA && entry.subtype == ESP_PARTITION_SUBTYPE_DATA_OTA)
4200955d:	1621a2        	l32i	a10, a1, 88
42009560:	ffab92        	movi	a9, 0xfffffbff
42009563:	119900        	slli	a9, a9, 16
42009566:	10aa90        	and	a10, a10, a9
                   || (entry.type == ESP_PARTITION_TYPE_DATA && entry.subtype == ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS)) {
42009569:	190c      	movi.n	a9, 1
4200956b:	119900        	slli	a9, a9, 16
4200956e:	c89a97        	bne	a10, a9, 4200953a <ensure_partitions_loaded$part$0+0xda>
            item->info.encrypted = true;
42009571:	190c      	movi.n	a9, 1
42009573:	294792        	s8i	a9, a7, 41
42009576:	fff006        	j	4200953a <ensure_partitions_loaded$part$0+0xda>
            SLIST_INSERT_AFTER(last, item, next);
42009579:	c398      	l32i.n	a9, a3, 48
4200957b:	c799      	s32i.n	a9, a7, 48
4200957d:	c379      	s32i.n	a7, a3, 48
4200957f:	fff2c6        	j	4200954e <ensure_partitions_loaded$part$0+0xee>
42009582:	00          	.byte 00
42009583:	00          	.byte 00
42009584:	00          	.byte 00
            err = ESP_ERR_INVALID_STATE;
42009585:	03a122        	movi	a2, 0x103
        while (it) {
42009588:	04bc      	beqz.n	a4, 420095bc <ensure_partitions_loaded$part$0+0x15c>
            partition_list_item_t *next = it->next.sle_next;
4200958a:	c438      	l32i.n	a3, a4, 48
            free(it);
4200958c:	04ad      	mov.n	a10, a4
4200958e:	daa581        	l32r	a8, 42000024 <_stext+0x4>
42009591:	0008e0        	callx8	a8
            it = next;
42009594:	034d      	mov.n	a4, a3
42009596:	fffb86        	j	42009588 <ensure_partitions_loaded$part$0+0x128>
42009599:	00          	.byte 00
        esp_rom_md5_final(calc_md5, &context);
4200959a:	01bd      	mov.n	a11, a1
4200959c:	58c1a2        	addi	a10, a1, 88
4200959f:	dd5a81        	l32r	a8, 42000b08 <_stext+0xae8>
420095a2:	0008e0        	callx8	a8
        if (memcmp(calc_md5, stored_md5, ESP_ROM_MD5_DIGEST_LEN) != 0) {
420095a5:	0c1c      	movi.n	a12, 16
420095a7:	b2ca      	add.n	a11, a2, a12
420095a9:	58c1a2        	addi	a10, a1, 88
420095ac:	dc3e81        	l32r	a8, 420006a4 <_stext+0x684>
420095af:	0008e0        	callx8	a8
420095b2:	0a2d      	mov.n	a2, a10
420095b4:	fcda56        	bnez	a10, 42009585 <ensure_partitions_loaded$part$0+0x125>
        s_partition_list = new_partitions_list;
420095b7:	dd4c31        	l32r	a3, 42000ae8 <_stext+0xac8>
420095ba:	0349      	s32i.n	a4, a3, 0
    spi_flash_munmap(handle);
420095bc:	1e21a2        	l32i	a10, a1, 120
420095bf:	dd5381        	l32r	a8, 42000b0c <_stext+0xaec>
420095c2:	0008e0        	callx8	a8
            err = load_partitions();
            if (err != ESP_OK) {
                ESP_LOGE(TAG, "load_partitions returned 0x%x", err);
            }
        }
        _lock_release(&s_partition_list_lock);
420095c5:	06ad      	mov.n	a10, a6
420095c7:	dc0681        	l32r	a8, 420005e0 <_stext+0x5c0>
420095ca:	0008e0        	callx8	a8
    }
    return err;
}
420095cd:	f01d      	retw.n
	...

420095d0 <esp_partition_next>:
    // if nothing found, it == NULL and iterator has been released
    return it;
}

esp_partition_iterator_t esp_partition_next(esp_partition_iterator_t it)
{
420095d0:	004136        	entry	a1, 32
    assert(it);
420095d3:	011256        	bnez	a2, 420095e8 <esp_partition_next+0x18>
420095d6:	dd4ed1        	l32r	a13, 42000b10 <_stext+0xaf0>
420095d9:	dd4ec1        	l32r	a12, 42000b14 <_stext+0xaf4>
420095dc:	dd4fa1        	l32r	a10, 42000b18 <_stext+0xaf8>
420095df:	1fa1b2        	movi	a11, 0x11f
420095e2:	daa881        	l32r	a8, 42000084 <_stext+0x64>
420095e5:	0008e0        	callx8	a8
    // iterator reached the end of linked list?
    if (it->next_item == NULL) {
420095e8:	3238      	l32i.n	a3, a2, 12
420095ea:	a3cc      	bnez.n	a3, 420095f8 <esp_partition_next+0x28>


void esp_partition_iterator_release(esp_partition_iterator_t iterator)
{
    // iterator == NULL is okay
    free(iterator);
420095ec:	02ad      	mov.n	a10, a2
420095ee:	da8d81        	l32r	a8, 42000024 <_stext+0x4>
420095f1:	0008e0        	callx8	a8
        return NULL;
420095f4:	020c      	movi.n	a2, 0
}
420095f6:	f01d      	retw.n
    _lock_acquire(&s_partition_list_lock);
420095f8:	dd3b41        	l32r	a4, 42000ae4 <_stext+0xac4>
        if (it->type != ESP_PARTITION_TYPE_ANY && it->type != p->type) {
420095fb:	ffa052        	movi	a5, 255
    _lock_acquire(&s_partition_list_lock);
420095fe:	04ad      	mov.n	a10, a4
42009600:	dbf781        	l32r	a8, 420005dc <_stext+0x5bc>
42009603:	0008e0        	callx8	a8
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
42009606:	3238      	l32i.n	a3, a2, 12
42009608:	43dc      	bnez.n	a3, 42009620 <esp_partition_next+0x50>
    _lock_release(&s_partition_list_lock);
4200960a:	04ad      	mov.n	a10, a4
4200960c:	dbf581        	l32r	a8, 420005e0 <_stext+0x5c0>
4200960f:	0008e0        	callx8	a8
    if (it->next_item == NULL) {
42009612:	3238      	l32i.n	a3, a2, 12
42009614:	fd4316        	beqz	a3, 420095ec <esp_partition_next+0x1c>
    it->info = &it->next_item->info;
42009617:	4239      	s32i.n	a3, a2, 16
    it->next_item = SLIST_NEXT(it->next_item, next);
42009619:	c338      	l32i.n	a3, a3, 48
4200961b:	3239      	s32i.n	a3, a2, 12
    return it;
4200961d:	fff546        	j	420095f6 <esp_partition_next+0x26>
        if (it->type != ESP_PARTITION_TYPE_ANY && it->type != p->type) {
42009620:	0288      	l32i.n	a8, a2, 0
42009622:	041857        	beq	a8, a5, 4200962a <esp_partition_next+0x5a>
42009625:	1398      	l32i.n	a9, a3, 4
42009627:	1a9897        	bne	a8, a9, 42009645 <esp_partition_next+0x75>
        if (it->subtype != ESP_PARTITION_SUBTYPE_ANY && it->subtype != p->subtype) {
4200962a:	1288      	l32i.n	a8, a2, 4
4200962c:	041857        	beq	a8, a5, 42009634 <esp_partition_next+0x64>
4200962f:	2398      	l32i.n	a9, a3, 8
42009631:	109897        	bne	a8, a9, 42009645 <esp_partition_next+0x75>
        if (it->label != NULL && strcmp(it->label, p->label) != 0) {
42009634:	22a8      	l32i.n	a10, a2, 8
42009636:	fd0a16        	beqz	a10, 4200960a <esp_partition_next+0x3a>
42009639:	18c3b2        	addi	a11, a3, 24
4200963c:	dc4381        	l32r	a8, 42000748 <_stext+0x728>
4200963f:	0008e0        	callx8	a8
42009642:	fc4a16        	beqz	a10, 4200960a <esp_partition_next+0x3a>
    for (; it->next_item != NULL; it->next_item = SLIST_NEXT(it->next_item, next)) {
42009645:	c338      	l32i.n	a3, a3, 48
42009647:	3239      	s32i.n	a3, a2, 12
42009649:	ffee46        	j	42009606 <esp_partition_next+0x36>

4200964c <esp_partition_find>:
{
4200964c:	004136        	entry	a1, 32
    if (SLIST_EMPTY(&s_partition_list)) {
4200964f:	dd2651        	l32r	a5, 42000ae8 <_stext+0xac8>
42009652:	002582        	l32i	a8, a5, 0
42009655:	00f816        	beqz	a8, 42009668 <esp_partition_find+0x1c>
    if (type == ESP_PARTITION_TYPE_ANY && subtype != ESP_PARTITION_SUBTYPE_ANY) {
42009658:	01af82        	movi	a8, -255
4200965b:	928a      	add.n	a9, a2, a8
4200965d:	39dc      	bnez.n	a9, 42009674 <esp_partition_find+0x28>
4200965f:	808380        	add	a8, a3, a8
42009662:	e88c      	beqz.n	a8, 42009674 <esp_partition_find+0x28>
        return NULL;
42009664:	020c      	movi.n	a2, 0
}
42009666:	f01d      	retw.n
42009668:	ffdf65        	call8	42009460 <ensure_partitions_loaded$part$0>
    if (ensure_partitions_loaded() != ESP_OK) {
4200966b:	fe9a16        	beqz	a10, 42009658 <esp_partition_find+0xc>
4200966e:	fffc86        	j	42009664 <esp_partition_find+0x18>
42009671:	00          	.byte 00
42009672:	00          	.byte 00
42009673:	00          	.byte 00
        (esp_partition_iterator_opaque_t *) malloc(sizeof(esp_partition_iterator_opaque_t));
42009674:	4a1c      	movi.n	a10, 20
42009676:	da7481        	l32r	a8, 42000048 <_stext+0x28>
42009679:	0008e0        	callx8	a8
    if (it == NULL) {
4200967c:	fe4a16        	beqz	a10, 42009664 <esp_partition_find+0x18>
    it->type = type;
4200967f:	0a29      	s32i.n	a2, a10, 0
    it->next_item = SLIST_FIRST(&s_partition_list);
42009681:	0528      	l32i.n	a2, a5, 0
    it->subtype = subtype;
42009683:	1a39      	s32i.n	a3, a10, 4
    it->next_item = SLIST_FIRST(&s_partition_list);
42009685:	3a29      	s32i.n	a2, a10, 12
    it->info = NULL;
42009687:	020c      	movi.n	a2, 0
42009689:	4a29      	s32i.n	a2, a10, 16
    it->label = label;
4200968b:	2a49      	s32i.n	a4, a10, 8
    it = esp_partition_next(it);
4200968d:	fff425        	call8	420095d0 <esp_partition_next>
42009690:	0a2d      	mov.n	a2, a10
    return it;
42009692:	fff406        	j	42009666 <esp_partition_find+0x1a>
42009695:	000000        	ill

42009698 <esp_partition_iterator_release>:
{
42009698:	004136        	entry	a1, 32
    free(iterator);
4200969b:	20a220        	or	a10, a2, a2
4200969e:	da6181        	l32r	a8, 42000024 <_stext+0x4>
420096a1:	0008e0        	callx8	a8
}
420096a4:	f01d      	retw.n
	...

420096a8 <esp_partition_get>:

const esp_partition_t *esp_partition_get(esp_partition_iterator_t iterator)
{
420096a8:	004136        	entry	a1, 32
    assert(iterator != NULL);
420096ab:	011256        	bnez	a2, 420096c0 <esp_partition_get+0x18>
420096ae:	dd1bd1        	l32r	a13, 42000b1c <_stext+0xafc>
420096b1:	dd1bc1        	l32r	a12, 42000b20 <_stext+0xb00>
420096b4:	dd19a1        	l32r	a10, 42000b18 <_stext+0xaf8>
420096b7:	53a1b2        	movi	a11, 0x153
420096ba:	da7281        	l32r	a8, 42000084 <_stext+0x64>
420096bd:	0008e0        	callx8	a8
    return iterator->info;
}
420096c0:	4228      	l32i.n	a2, a2, 16
420096c2:	f01d      	retw.n

420096c4 <ceil>:
420096c4:	004136        	entry	a1, 32
420096c7:	a56430        	extui	a6, a3, 20, 11
420096ca:	03bd      	mov.n	a11, a3
420096cc:	034d      	mov.n	a4, a3
420096ce:	01ac32        	movi	a3, 0xfffffc01
420096d1:	363a      	add.n	a3, a6, a3
420096d3:	381c      	movi.n	a8, 19
420096d5:	025d      	mov.n	a5, a2
420096d7:	027d      	mov.n	a7, a2
420096d9:	02a837        	bge	a8, a3, 420096df <ceil+0x1b>
420096dc:	002246        	j	42009769 <ceil+0xa5>
420096df:	0363d6        	bgez	a3, 42009719 <ceil+0x55>
420096e2:	dd10c1        	l32r	a12, 42000b24 <_stext+0xb04>
420096e5:	dd10d1        	l32r	a13, 42000b28 <_stext+0xb08>
420096e8:	02ad      	mov.n	a10, a2
420096ea:	dc4581        	l32r	a8, 42000800 <_stext+0x7e0>
420096ed:	0008e0        	callx8	a8
420096f0:	dc40c1        	l32r	a12, 420007f0 <_stext+0x7d0>
420096f3:	dc3fd1        	l32r	a13, 420007f0 <_stext+0x7d0>
420096f6:	dd0e81        	l32r	a8, 42000b30 <_stext+0xb10>
420096f9:	0008e0        	callx8	a8
420096fc:	021ae6        	bgei	a10, 1, 42009702 <ceil+0x3e>
420096ff:	003746        	j	420097e0 <ceil+0x11c>
42009702:	0d3496        	bltz	a4, 420097d9 <ceil+0x115>
42009705:	204420        	or	a4, a4, a2
42009708:	050c      	movi.n	a5, 0
4200970a:	029457        	bne	a4, a5, 42009710 <ceil+0x4c>
4200970d:	0033c6        	j	420097e0 <ceil+0x11c>
42009710:	ffa342        	movi	a4, 0x3ff
42009713:	0144c0        	slli	a4, a4, 20
42009716:	003186        	j	420097e0 <ceil+0x11c>
42009719:	dd0461        	l32r	a6, 42000b2c <_stext+0xb0c>
4200971c:	400300        	ssr	a3
4200971f:	b16060        	sra	a6, a6
42009722:	107b60        	and	a7, a11, a6
42009725:	207720        	or	a7, a7, a2
42009728:	0b8716        	beqz	a7, 420097e4 <ceil+0x120>
4200972b:	dcfec1        	l32r	a12, 42000b24 <_stext+0xb04>
4200972e:	dcfed1        	l32r	a13, 42000b28 <_stext+0xb08>
42009731:	02ad      	mov.n	a10, a2
42009733:	dc3381        	l32r	a8, 42000800 <_stext+0x7e0>
42009736:	0008e0        	callx8	a8
42009739:	dc2dc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200973c:	dc2dd1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200973f:	dcfc81        	l32r	a8, 42000b30 <_stext+0xb10>
42009742:	0008e0        	callx8	a8
42009745:	021ae6        	bgei	a10, 1, 4200974b <ceil+0x87>
42009748:	002506        	j	420097e0 <ceil+0x11c>
4200974b:	0d14a6        	blti	a4, 1, 4200975c <ceil+0x98>
4200974e:	120c      	movi.n	a2, 1
42009750:	0122c0        	slli	a2, a2, 20
42009753:	400300        	ssr	a3
42009756:	b12020        	sra	a2, a2
42009759:	804420        	add	a4, a4, a2
4200975c:	f27c      	movi.n	a2, -1
4200975e:	302260        	xor	a2, a2, a6
42009761:	104420        	and	a4, a4, a2
42009764:	050c      	movi.n	a5, 0
42009766:	001d86        	j	420097e0 <ceil+0x11c>
42009769:	383c      	movi.n	a8, 51
4200976b:	16a837        	bge	a8, a3, 42009785 <ceil+0xc1>
4200976e:	00a442        	movi	a4, 0x400
42009771:	6f9347        	bne	a3, a4, 420097e4 <ceil+0x120>
42009774:	02cd      	mov.n	a12, a2
42009776:	02ad      	mov.n	a10, a2
42009778:	0bdd      	mov.n	a13, a11
4200977a:	dc2181        	l32r	a8, 42000800 <_stext+0x7e0>
4200977d:	0008e0        	callx8	a8
42009780:	0a2d      	mov.n	a2, a10
42009782:	001786        	j	420097e4 <ceil+0x120>
42009785:	66db      	addi.n	a6, a6, 13
42009787:	f87c      	movi.n	a8, -1
42009789:	400600        	ssr	a6
4200978c:	916080        	srl	a6, a8
4200978f:	510267        	bnone	a2, a6, 420097e4 <ceil+0x120>
42009792:	dce4c1        	l32r	a12, 42000b24 <_stext+0xb04>
42009795:	dce4d1        	l32r	a13, 42000b28 <_stext+0xb08>
42009798:	02ad      	mov.n	a10, a2
4200979a:	dc1981        	l32r	a8, 42000800 <_stext+0x7e0>
4200979d:	0008e0        	callx8	a8
420097a0:	dc14c1        	l32r	a12, 420007f0 <_stext+0x7d0>
420097a3:	dc13d1        	l32r	a13, 420007f0 <_stext+0x7d0>
420097a6:	dce281        	l32r	a8, 42000b30 <_stext+0xb10>
420097a9:	0008e0        	callx8	a8
420097ac:	301aa6        	blti	a10, 1, 420097e0 <ceil+0x11c>
420097af:	1b14a6        	blti	a4, 1, 420097ce <ceil+0x10a>
420097b2:	421c      	movi.n	a2, 20
420097b4:	029327        	bne	a3, a2, 420097ba <ceil+0xf6>
420097b7:	000446        	j	420097cc <ceil+0x108>
420097ba:	423c      	movi.n	a2, 52
420097bc:	c03230        	sub	a3, a2, a3
420097bf:	120c      	movi.n	a2, 1
420097c1:	401300        	ssl	a3
420097c4:	a12200        	sll	a2, a2
420097c7:	552a      	add.n	a5, a5, a2
420097c9:	01b577        	bgeu	a5, a7, 420097ce <ceil+0x10a>
420097cc:	441b      	addi.n	a4, a4, 1
420097ce:	f27c      	movi.n	a2, -1
420097d0:	302260        	xor	a2, a2, a6
420097d3:	105520        	and	a5, a5, a2
420097d6:	000186        	j	420097e0 <ceil+0x11c>
420097d9:	f47c      	movi.n	a4, -1
420097db:	050c      	movi.n	a5, 0
420097dd:	014410        	slli	a4, a4, 31
420097e0:	052d      	mov.n	a2, a5
420097e2:	04bd      	mov.n	a11, a4
420097e4:	024d      	mov.n	a4, a2
420097e6:	0b5d      	mov.n	a5, a11
420097e8:	0b3d      	mov.n	a3, a11
420097ea:	f01d      	retw.n

420097ec <round>:
420097ec:	004136        	entry	a1, 32
420097ef:	a5c430        	extui	a12, a3, 20, 11
420097f2:	01ac92        	movi	a9, 0xfffffc01
420097f5:	02ad      	mov.n	a10, a2
420097f7:	9c9a      	add.n	a9, a12, a9
420097f9:	321c      	movi.n	a2, 19
420097fb:	03bd      	mov.n	a11, a3
420097fd:	038d      	mov.n	a8, a3
420097ff:	492297        	blt	a2, a9, 4200984c <round+0x60>
42009802:	01a9d6        	bgez	a9, 42009820 <round+0x34>
42009805:	f27c      	movi.n	a2, -1
42009807:	012210        	slli	a2, a2, 31
4200980a:	108320        	and	a8, a3, a2
4200980d:	0a0c      	movi.n	a10, 0
4200980f:	7b0966        	bnei	a9, -1, 4200988e <round+0xa2>
42009812:	ffa322        	movi	a2, 0x3ff
42009815:	0122c0        	slli	a2, a2, 20
42009818:	208820        	or	a8, a8, a2
4200981b:	001bc6        	j	4200988e <round+0xa2>
4200981e:	00          	.byte 00
4200981f:	00          	.byte 00
42009820:	dcc3c1        	l32r	a12, 42000b2c <_stext+0xb0c>
42009823:	400900        	ssr	a9
42009826:	b1c0c0        	sra	a12, a12
42009829:	1023c0        	and	a2, a3, a12
4200982c:	2022a0        	or	a2, a2, a10
4200982f:	05d216        	beqz	a2, 42009890 <round+0xa4>
42009832:	1a0c      	movi.n	a10, 1
42009834:	01aad0        	slli	a10, a10, 19
42009837:	400900        	ssr	a9
4200983a:	b1a0a0        	sra	a10, a10
4200983d:	f87c      	movi.n	a8, -1
4200983f:	aa3a      	add.n	a10, a10, a3
42009841:	3088c0        	xor	a8, a8, a12
42009844:	1088a0        	and	a8, a8, a10
42009847:	0a0c      	movi.n	a10, 0
42009849:	001046        	j	4200988e <round+0xa2>
4200984c:	3e3c      	movi.n	a14, 51
4200984e:	14ae97        	bge	a14, a9, 42009866 <round+0x7a>
42009851:	00a422        	movi	a2, 0x400
42009854:	389927        	bne	a9, a2, 42009890 <round+0xa4>
42009857:	0acd      	mov.n	a12, a10
42009859:	03dd      	mov.n	a13, a3
4200985b:	dbe981        	l32r	a8, 42000800 <_stext+0x7e0>
4200985e:	0008e0        	callx8	a8
42009861:	000ac6        	j	42009890 <round+0xa4>
42009864:	00          	.byte 00
42009865:	00          	.byte 00
42009866:	fcdb      	addi.n	a15, a12, 13
42009868:	fc7c      	movi.n	a12, -1
4200986a:	400f00        	ssr	a15
4200986d:	91c0c0        	srl	a12, a12
42009870:	1c0ca7        	bnone	a12, a10, 42009890 <round+0xa4>
42009873:	c0ee90        	sub	a14, a14, a9
42009876:	190c      	movi.n	a9, 1
42009878:	401e00        	ssl	a14
4200987b:	a19900        	sll	a9, a9
4200987e:	99aa      	add.n	a9, a9, a10
42009880:	02b9a7        	bgeu	a9, a10, 42009886 <round+0x9a>
42009883:	01c382        	addi	a8, a3, 1
42009886:	fa7c      	movi.n	a10, -1
42009888:	30aac0        	xor	a10, a10, a12
4200988b:	10aa90        	and	a10, a10, a9
4200988e:	08bd      	mov.n	a11, a8
42009890:	0a2d      	mov.n	a2, a10
42009892:	0b3d      	mov.n	a3, a11
42009894:	f01d      	retw.n
	...

42009898 <__errno>:
42009898:	004136        	entry	a1, 32
4200989b:	dca681        	l32r	a8, 42000b34 <_stext+0xb14>
4200989e:	0008e0        	callx8	a8
420098a1:	0a2d      	mov.n	a2, a10
420098a3:	f01d      	retw.n
420098a5:	000000        	ill

420098a8 <std>:
420098a8:	004136        	entry	a1, 32
420098ab:	0b0c      	movi.n	a11, 0
420098ad:	02b9      	s32i.n	a11, a2, 0
420098af:	12b9      	s32i.n	a11, a2, 4
420098b1:	22b9      	s32i.n	a11, a2, 8
420098b3:	065232        	s16i	a3, a2, 12
420098b6:	1962b2        	s32i	a11, a2, 100
420098b9:	075242        	s16i	a4, a2, 14
420098bc:	42b9      	s32i.n	a11, a2, 16
420098be:	52b9      	s32i.n	a11, a2, 20
420098c0:	62b9      	s32i.n	a11, a2, 24
420098c2:	8c0c      	movi.n	a12, 8
420098c4:	5cc2a2        	addi	a10, a2, 92
420098c7:	da3481        	l32r	a8, 42000198 <_stext+0x178>
420098ca:	0008e0        	callx8	a8
420098cd:	dc9a81        	l32r	a8, 42000b38 <_stext+0xb18>
420098d0:	8229      	s32i.n	a2, a2, 32
420098d2:	9289      	s32i.n	a8, a2, 36
420098d4:	dc9a81        	l32r	a8, 42000b3c <_stext+0xb1c>
420098d7:	a289      	s32i.n	a8, a2, 40
420098d9:	dc9981        	l32r	a8, 42000b40 <_stext+0xb20>
420098dc:	b289      	s32i.n	a8, a2, 44
420098de:	dc9981        	l32r	a8, 42000b44 <_stext+0xb24>
420098e1:	c289      	s32i.n	a8, a2, 48
420098e3:	f01d      	retw.n
420098e5:	000000        	ill

420098e8 <_cleanup_r>:
420098e8:	004136        	entry	a1, 32
420098eb:	dc97b1        	l32r	a11, 42000b48 <_stext+0xb28>
420098ee:	02ad      	mov.n	a10, a2
420098f0:	201110        	or	a1, a1, a1
420098f3:	0e9165        	call8	42018208 <_fwalk_reent>
420098f6:	f01d      	retw.n

420098f8 <__fp_lock>:
420098f8:	004136        	entry	a1, 32
420098fb:	192282        	l32i	a8, a2, 100
420098fe:	0ee807        	bbsi	a8, 0, 42009910 <__fp_lock+0x18>
42009901:	061282        	l16ui	a8, a2, 12
42009904:	08e897        	bbsi	a8, 9, 42009910 <__fp_lock+0x18>
42009907:	1622a2        	l32i	a10, a2, 88
4200990a:	dc9081        	l32r	a8, 42000b4c <_stext+0xb2c>
4200990d:	0008e0        	callx8	a8
42009910:	020c      	movi.n	a2, 0
42009912:	f01d      	retw.n

42009914 <__fp_unlock>:
42009914:	004136        	entry	a1, 32
42009917:	192282        	l32i	a8, a2, 100
4200991a:	0ee807        	bbsi	a8, 0, 4200992c <__fp_unlock+0x18>
4200991d:	061282        	l16ui	a8, a2, 12
42009920:	08e897        	bbsi	a8, 9, 4200992c <__fp_unlock+0x18>
42009923:	1622a2        	l32i	a10, a2, 88
42009926:	dc8a81        	l32r	a8, 42000b50 <_stext+0xb30>
42009929:	0008e0        	callx8	a8
4200992c:	020c      	movi.n	a2, 0
4200992e:	f01d      	retw.n

42009930 <__sfmoreglue>:
42009930:	004136        	entry	a1, 32
42009933:	830b      	addi.n	a8, a3, -1
42009935:	904880        	addx2	a4, a8, a8
42009938:	a04480        	addx4	a4, a4, a8
4200993b:	1144d0        	slli	a4, a4, 3
4200993e:	02ad      	mov.n	a10, a2
42009940:	74c4b2        	addi	a11, a4, 116
42009943:	dc8481        	l32r	a8, 42000b54 <_stext+0xb34>
42009946:	0008e0        	callx8	a8
42009949:	0a2d      	mov.n	a2, a10
4200994b:	1a9c      	beqz.n	a10, 42009960 <__sfmoreglue+0x30>
4200994d:	0b0c      	movi.n	a11, 0
4200994f:	0ab9      	s32i.n	a11, a10, 0
42009951:	1a39      	s32i.n	a3, a10, 4
42009953:	aacb      	addi.n	a10, a10, 12
42009955:	22a9      	s32i.n	a10, a2, 8
42009957:	68c4c2        	addi	a12, a4, 104
4200995a:	da0f81        	l32r	a8, 42000198 <_stext+0x178>
4200995d:	0008e0        	callx8	a8
42009960:	f01d      	retw.n
	...

42009964 <_cleanup>:
42009964:	004136        	entry	a1, 32
42009967:	d9f181        	l32r	a8, 4200012c <_stext+0x10c>
4200996a:	0028a2        	l32i	a10, a8, 0
4200996d:	fff7a5        	call8	420098e8 <_cleanup_r>
42009970:	f01d      	retw.n
	...

42009974 <__sfp_lock_acquire>:
42009974:	004136        	entry	a1, 32
42009977:	db0ca1        	l32r	a10, 420005a8 <_stext+0x588>
4200997a:	dc7481        	l32r	a8, 42000b4c <_stext+0xb2c>
4200997d:	0008e0        	callx8	a8
42009980:	f01d      	retw.n
	...

42009984 <__sfp_lock_release>:
42009984:	004136        	entry	a1, 32
42009987:	db08a1        	l32r	a10, 420005a8 <_stext+0x588>
4200998a:	dc7181        	l32r	a8, 42000b50 <_stext+0xb30>
4200998d:	0008e0        	callx8	a8
42009990:	f01d      	retw.n
	...

42009994 <__sinit_lock_acquire>:
42009994:	004136        	entry	a1, 32
42009997:	db04a1        	l32r	a10, 420005a8 <_stext+0x588>
4200999a:	dc6c81        	l32r	a8, 42000b4c <_stext+0xb2c>
4200999d:	0008e0        	callx8	a8
420099a0:	f01d      	retw.n
	...

420099a4 <__sinit_lock_release>:
420099a4:	004136        	entry	a1, 32
420099a7:	db00a1        	l32r	a10, 420005a8 <_stext+0x588>
420099aa:	dc6981        	l32r	a8, 42000b50 <_stext+0xb30>
420099ad:	0008e0        	callx8	a8
420099b0:	f01d      	retw.n
	...

420099b4 <__sinit>:
420099b4:	004136        	entry	a1, 32
420099b7:	fffde5        	call8	42009994 <__sinit_lock_acquire>
420099ba:	6238      	l32i.n	a3, a2, 24
420099bc:	138c      	beqz.n	a3, 420099c1 <__sinit+0xd>
420099be:	001506        	j	42009a16 <__sinit+0x62>
420099c1:	dc6541        	l32r	a4, 42000b58 <_stext+0xb38>
420099c4:	366232        	s32i	a3, a2, 216
420099c7:	a249      	s32i.n	a4, a2, 40
420099c9:	01a042        	movi	a4, 1
420099cc:	066242        	s32i	a4, a2, 24
420099cf:	376232        	s32i	a3, a2, 220
420099d2:	386232        	s32i	a3, a2, 224
420099d5:	20a220        	or	a10, a2, a2
420099d8:	201110        	or	a1, a1, a1
420099db:	000425        	call8	42009a1c <__sfp>
420099de:	0162a2        	s32i	a10, a2, 4
420099e1:	20a220        	or	a10, a2, a2
420099e4:	201110        	or	a1, a1, a1
420099e7:	000365        	call8	42009a1c <__sfp>
420099ea:	0262a2        	s32i	a10, a2, 8
420099ed:	20a220        	or	a10, a2, a2
420099f0:	201110        	or	a1, a1, a1
420099f3:	0002a5        	call8	42009a1c <__sfp>
420099f6:	32a9      	s32i.n	a10, a2, 12
420099f8:	12a8      	l32i.n	a10, a2, 4
420099fa:	03cd      	mov.n	a12, a3
420099fc:	4b0c      	movi.n	a11, 4
420099fe:	ffeaa5        	call8	420098a8 <std>
42009a01:	22a8      	l32i.n	a10, a2, 8
42009a03:	04cd      	mov.n	a12, a4
42009a05:	8b0c      	movi.n	a11, 8
42009a07:	ffea25        	call8	420098a8 <std>
42009a0a:	32a8      	l32i.n	a10, a2, 12
42009a0c:	2c0c      	movi.n	a12, 2
42009a0e:	12a0b2        	movi	a11, 18
42009a11:	ffe965        	call8	420098a8 <std>
42009a14:	6249      	s32i.n	a4, a2, 24
42009a16:	fff8e5        	call8	420099a4 <__sinit_lock_release>
42009a19:	f01d      	retw.n
	...

42009a1c <__sfp>:
42009a1c:	006136        	entry	a1, 48
42009a1f:	01bd      	mov.n	a11, a1
42009a21:	1a0c      	movi.n	a10, 1
42009a23:	201110        	or	a1, a1, a1
42009a26:	0e4ee5        	call8	42017f14 <pthread_setcancelstate>
42009a29:	fff4a5        	call8	42009974 <__sfp_lock_acquire>
42009a2c:	025d      	mov.n	a5, a2
42009a2e:	d9bf21        	l32r	a2, 4200012c <_stext+0x10c>
42009a31:	02a8      	l32i.n	a10, a2, 0
42009a33:	6a38      	l32i.n	a3, a10, 24
42009a35:	13cc      	bnez.n	a3, 42009a3a <__sfp+0x1e>
42009a37:	fff7e5        	call8	420099b4 <__sinit>
42009a3a:	0248      	l32i.n	a4, a2, 0
42009a3c:	d8a022        	movi	a2, 216
42009a3f:	442a      	add.n	a4, a4, a2
42009a41:	460c      	movi.n	a6, 4
42009a43:	2428      	l32i.n	a2, a4, 8
42009a45:	1488      	l32i.n	a8, a4, 4
42009a47:	001446        	j	42009a9c <__sfp+0x80>
42009a4a:	00          	.byte 00
42009a4b:	00          	.byte 00
42009a4c:	00          	.byte 00
42009a4d:	069232        	l16si	a3, a2, 12
42009a50:	045356        	bnez	a3, 42009a99 <__sfp+0x7d>
42009a53:	dc4241        	l32r	a4, 42000b5c <_stext+0xb3c>
42009a56:	58c2a2        	addi	a10, a2, 88
42009a59:	036242        	s32i	a4, a2, 12
42009a5c:	196232        	s32i	a3, a2, 100
42009a5f:	dc4081        	l32r	a8, 42000b60 <_stext+0xb40>
42009a62:	0008e0        	callx8	a8
42009a65:	fff1e5        	call8	42009984 <__sfp_lock_release>
42009a68:	01a8      	l32i.n	a10, a1, 0
42009a6a:	01bd      	mov.n	a11, a1
42009a6c:	201110        	or	a1, a1, a1
42009a6f:	0e4a65        	call8	42017f14 <pthread_setcancelstate>
42009a72:	8c0c      	movi.n	a12, 8
42009a74:	0239      	s32i.n	a3, a2, 0
42009a76:	2239      	s32i.n	a3, a2, 8
42009a78:	1239      	s32i.n	a3, a2, 4
42009a7a:	4239      	s32i.n	a3, a2, 16
42009a7c:	5239      	s32i.n	a3, a2, 20
42009a7e:	6239      	s32i.n	a3, a2, 24
42009a80:	20b330        	or	a11, a3, a3
42009a83:	5cc2a2        	addi	a10, a2, 92
42009a86:	d9c481        	l32r	a8, 42000198 <_stext+0x178>
42009a89:	0008e0        	callx8	a8
42009a8c:	d239      	s32i.n	a3, a2, 52
42009a8e:	e239      	s32i.n	a3, a2, 56
42009a90:	126232        	s32i	a3, a2, 72
42009a93:	136232        	s32i	a3, a2, 76
42009a96:	000c06        	j	42009aca <__sfp+0xae>
42009a99:	68c222        	addi	a2, a2, 104
42009a9c:	880b      	addi.n	a8, a8, -1
42009a9e:	fab8d6        	bgez	a8, 42009a4d <__sfp+0x31>
42009aa1:	0428      	l32i.n	a2, a4, 0
42009aa3:	328c      	beqz.n	a2, 42009aaa <__sfp+0x8e>
42009aa5:	0448      	l32i.n	a4, a4, 0
42009aa7:	ffe606        	j	42009a43 <__sfp+0x27>
42009aaa:	06bd      	mov.n	a11, a6
42009aac:	20a550        	or	a10, a5, a5
42009aaf:	ffe825        	call8	42009930 <__sfmoreglue>
42009ab2:	04a9      	s32i.n	a10, a4, 0
42009ab4:	0a2d      	mov.n	a2, a10
42009ab6:	feba56        	bnez	a10, 42009aa5 <__sfp+0x89>
42009ab9:	ffeca5        	call8	42009984 <__sfp_lock_release>
42009abc:	01a8      	l32i.n	a10, a1, 0
42009abe:	01bd      	mov.n	a11, a1
42009ac0:	c30c      	movi.n	a3, 12
42009ac2:	201110        	or	a1, a1, a1
42009ac5:	0e44e5        	call8	42017f14 <pthread_setcancelstate>
42009ac8:	0539      	s32i.n	a3, a5, 0
42009aca:	f01d      	retw.n

42009acc <__fp_lock_all>:
42009acc:	004136        	entry	a1, 32
42009acf:	ffea65        	call8	42009974 <__sfp_lock_acquire>
42009ad2:	dc1881        	l32r	a8, 42000b34 <_stext+0xb14>
42009ad5:	0008e0        	callx8	a8
42009ad8:	dc23b1        	l32r	a11, 42000b64 <_stext+0xb44>
42009adb:	201110        	or	a1, a1, a1
42009ade:	0e6f65        	call8	420181d4 <_fwalk>
42009ae1:	f01d      	retw.n
	...

42009ae4 <__fp_unlock_all>:
42009ae4:	004136        	entry	a1, 32
42009ae7:	dc1381        	l32r	a8, 42000b34 <_stext+0xb14>
42009aea:	0008e0        	callx8	a8
42009aed:	dc1eb1        	l32r	a11, 42000b68 <_stext+0xb48>
42009af0:	201110        	or	a1, a1, a1
42009af3:	0e6e25        	call8	420181d4 <_fwalk>
42009af6:	ffe8e5        	call8	42009984 <__sfp_lock_release>
42009af9:	f01d      	retw.n
	...

42009afc <_fopen_r>:
42009afc:	006136        	entry	a1, 48
42009aff:	04bd      	mov.n	a11, a4
42009b01:	c14b      	addi.n	a12, a1, 4
42009b03:	20a220        	or	a10, a2, a2
42009b06:	201110        	or	a1, a1, a1
42009b09:	0e73a5        	call8	42018244 <__sflags>
42009b0c:	025d      	mov.n	a5, a2
42009b0e:	0a4d      	mov.n	a4, a10
42009b10:	1acc      	bnez.n	a10, 42009b15 <_fopen_r+0x19>
42009b12:	001386        	j	42009b64 <_fopen_r+0x68>
42009b15:	02ad      	mov.n	a10, a2
42009b17:	201110        	or	a1, a1, a1
42009b1a:	fff025        	call8	42009a1c <__sfp>
42009b1d:	0a2d      	mov.n	a2, a10
42009b1f:	041a16        	beqz	a10, 42009b64 <_fopen_r+0x68>
42009b22:	11c8      	l32i.n	a12, a1, 4
42009b24:	03bd      	mov.n	a11, a3
42009b26:	b6a1d2        	movi	a13, 0x1b6
42009b29:	05ad      	mov.n	a10, a5
42009b2b:	201110        	or	a1, a1, a1
42009b2e:	fb0aa5        	call8	42004bd8 <_open_r>
42009b31:	0a3d      	mov.n	a3, a10
42009b33:	01bd      	mov.n	a11, a1
42009b35:	1a0c      	movi.n	a10, 1
42009b37:	02e3d6        	bgez	a3, 42009b69 <_fopen_r+0x6d>
42009b3a:	201110        	or	a1, a1, a1
42009b3d:	0e3d65        	call8	42017f14 <pthread_setcancelstate>
42009b40:	201110        	or	a1, a1, a1
42009b43:	ffe325        	call8	42009974 <__sfp_lock_acquire>
42009b46:	1622a2        	l32i	a10, a2, 88
42009b49:	030c      	movi.n	a3, 0
42009b4b:	065232        	s16i	a3, a2, 12
42009b4e:	dc0781        	l32r	a8, 42000b6c <_stext+0xb4c>
42009b51:	0008e0        	callx8	a8
42009b54:	201110        	or	a1, a1, a1
42009b57:	ffe2e5        	call8	42009984 <__sfp_lock_release>
42009b5a:	01a8      	l32i.n	a10, a1, 0
42009b5c:	01bd      	mov.n	a11, a1
42009b5e:	201110        	or	a1, a1, a1
42009b61:	0e3b25        	call8	42017f14 <pthread_setcancelstate>
42009b64:	020c      	movi.n	a2, 0
42009b66:	001986        	j	42009bd0 <_fopen_r+0xd4>
42009b69:	201110        	or	a1, a1, a1
42009b6c:	0e3a65        	call8	42017f14 <pthread_setcancelstate>
42009b6f:	192282        	l32i	a8, a2, 100
42009b72:	0ee807        	bbsi	a8, 0, 42009b84 <_fopen_r+0x88>
42009b75:	061282        	l16ui	a8, a2, 12
42009b78:	08e897        	bbsi	a8, 9, 42009b84 <_fopen_r+0x88>
42009b7b:	1622a2        	l32i	a10, a2, 88
42009b7e:	dbf381        	l32r	a8, 42000b4c <_stext+0xb2c>
42009b81:	0008e0        	callx8	a8
42009b84:	075232        	s16i	a3, a2, 14
42009b87:	dbec31        	l32r	a3, 42000b38 <_stext+0xb18>
42009b8a:	065242        	s16i	a4, a2, 12
42009b8d:	9239      	s32i.n	a3, a2, 36
42009b8f:	dbeb31        	l32r	a3, 42000b3c <_stext+0xb1c>
42009b92:	8229      	s32i.n	a2, a2, 32
42009b94:	a239      	s32i.n	a3, a2, 40
42009b96:	dbea31        	l32r	a3, 42000b40 <_stext+0xb20>
42009b99:	b239      	s32i.n	a3, a2, 44
42009b9b:	dbea31        	l32r	a3, 42000b44 <_stext+0xb24>
42009b9e:	c239      	s32i.n	a3, a2, 48
42009ba0:	0d6487        	bbci	a4, 8, 42009bb1 <_fopen_r+0xb5>
42009ba3:	2d0c      	movi.n	a13, 2
42009ba5:	0c0c      	movi.n	a12, 0
42009ba7:	02bd      	mov.n	a11, a2
42009ba9:	05ad      	mov.n	a10, a5
42009bab:	201110        	or	a1, a1, a1
42009bae:	0003a5        	call8	42009be8 <_fseek_r>
42009bb1:	192232        	l32i	a3, a2, 100
42009bb4:	0ee307        	bbsi	a3, 0, 42009bc6 <_fopen_r+0xca>
42009bb7:	061232        	l16ui	a3, a2, 12
42009bba:	08e397        	bbsi	a3, 9, 42009bc6 <_fopen_r+0xca>
42009bbd:	1622a2        	l32i	a10, a2, 88
42009bc0:	dbe481        	l32r	a8, 42000b50 <_stext+0xb30>
42009bc3:	0008e0        	callx8	a8
42009bc6:	01a8      	l32i.n	a10, a1, 0
42009bc8:	01bd      	mov.n	a11, a1
42009bca:	201110        	or	a1, a1, a1
42009bcd:	0e3465        	call8	42017f14 <pthread_setcancelstate>
42009bd0:	f01d      	retw.n
	...

42009bd4 <fopen>:
42009bd4:	004136        	entry	a1, 32
42009bd7:	dbd781        	l32r	a8, 42000b34 <_stext+0xb14>
42009bda:	0008e0        	callx8	a8
42009bdd:	02bd      	mov.n	a11, a2
42009bdf:	03cd      	mov.n	a12, a3
42009be1:	fff1a5        	call8	42009afc <_fopen_r>
42009be4:	0a2d      	mov.n	a2, a10
42009be6:	f01d      	retw.n

42009be8 <_fseek_r>:
42009be8:	004136        	entry	a1, 32
42009beb:	05dd      	mov.n	a13, a5
42009bed:	04cd      	mov.n	a12, a4
42009bef:	03bd      	mov.n	a11, a3
42009bf1:	02ad      	mov.n	a10, a2
42009bf3:	201110        	or	a1, a1, a1
42009bf6:	000265        	call8	42009c1c <_fseeko_r>
42009bf9:	0a2d      	mov.n	a2, a10
42009bfb:	f01d      	retw.n
42009bfd:	000000        	ill

42009c00 <fseek>:
42009c00:	004136        	entry	a1, 32
42009c03:	dbcc81        	l32r	a8, 42000b34 <_stext+0xb14>
42009c06:	0008e0        	callx8	a8
42009c09:	02bd      	mov.n	a11, a2
42009c0b:	04dd      	mov.n	a13, a4
42009c0d:	03cd      	mov.n	a12, a3
42009c0f:	201110        	or	a1, a1, a1
42009c12:	0000a5        	call8	42009c1c <_fseeko_r>
42009c15:	0a2d      	mov.n	a2, a10
42009c17:	f01d      	retw.n
42009c19:	000000        	ill

42009c1c <_fseeko_r>:
42009c1c:	012136        	entry	a1, 144
42009c1f:	026d      	mov.n	a6, a2
42009c21:	b28c      	beqz.n	a2, 42009c30 <_fseeko_r+0x14>
42009c23:	6228      	l32i.n	a2, a2, 24
42009c25:	72cc      	bnez.n	a2, 42009c30 <_fseeko_r+0x14>
42009c27:	20a660        	or	a10, a6, a6
42009c2a:	201110        	or	a1, a1, a1
42009c2d:	ffd865        	call8	420099b4 <__sinit>
42009c30:	dbd021        	l32r	a2, 42000b70 <_stext+0xb50>
42009c33:	059327        	bne	a3, a2, 42009c3c <_fseeko_r+0x20>
42009c36:	1638      	l32i.n	a3, a6, 4
42009c38:	000546        	j	42009c51 <_fseeko_r+0x35>
42009c3b:	00          	.byte 00
42009c3c:	dbce21        	l32r	a2, 42000b74 <_stext+0xb54>
42009c3f:	069327        	bne	a3, a2, 42009c49 <_fseeko_r+0x2d>
42009c42:	2638      	l32i.n	a3, a6, 8
42009c44:	000246        	j	42009c51 <_fseeko_r+0x35>
42009c47:	00          	.byte 00
42009c48:	00          	.byte 00
42009c49:	dbcb21        	l32r	a2, 42000b78 <_stext+0xb58>
42009c4c:	019327        	bne	a3, a2, 42009c51 <_fseeko_r+0x35>
42009c4f:	3638      	l32i.n	a3, a6, 12
42009c51:	58c1b2        	addi	a11, a1, 88
42009c54:	1a0c      	movi.n	a10, 1
42009c56:	201110        	or	a1, a1, a1
42009c59:	0e2ba5        	call8	42017f14 <pthread_setcancelstate>
42009c5c:	192322        	l32i	a2, a3, 100
42009c5f:	0ee207        	bbsi	a2, 0, 42009c71 <_fseeko_r+0x55>
42009c62:	061322        	l16ui	a2, a3, 12
42009c65:	08e297        	bbsi	a2, 9, 42009c71 <_fseeko_r+0x55>
42009c68:	1623a2        	l32i	a10, a3, 88
42009c6b:	dbb881        	l32r	a8, 42000b4c <_stext+0xb2c>
42009c6e:	0008e0        	callx8	a8
42009c71:	061322        	l16ui	a2, a3, 12
42009c74:	08a172        	movi	a7, 0x108
42009c77:	102270        	and	a2, a2, a7
42009c7a:	0a9277        	bne	a2, a7, 42009c88 <_fseeko_r+0x6c>
42009c7d:	03bd      	mov.n	a11, a3
42009c7f:	20a660        	or	a10, a6, a6
42009c82:	201110        	or	a1, a1, a1
42009c85:	0889e5        	call8	42012524 <_fflush_r>
42009c88:	b328      	l32i.n	a2, a3, 44
42009c8a:	186122        	s32i	a2, a1, 96
42009c8d:	32cc      	bnez.n	a2, 42009c94 <_fseeko_r+0x78>
42009c8f:	d21c      	movi.n	a2, 29
42009c91:	001b86        	j	42009d03 <_fseeko_r+0xe7>
42009c94:	0a1526        	beqi	a5, 1, 42009ca2 <_fseeko_r+0x86>
42009c97:	d27c      	movi.n	a2, -3
42009c99:	102520        	and	a2, a5, a2
42009c9c:	061256        	bnez	a2, 42009d01 <_fseeko_r+0xe5>
42009c9f:	001946        	j	42009d08 <_fseeko_r+0xec>
42009ca2:	03bd      	mov.n	a11, a3
42009ca4:	06ad      	mov.n	a10, a6
42009ca6:	201110        	or	a1, a1, a1
42009ca9:	0887a5        	call8	42012524 <_fflush_r>
42009cac:	061322        	l16ui	a2, a3, 12
42009caf:	11c540        	slli	a12, a5, 12
42009cb2:	10cc20        	and	a12, a12, a2
42009cb5:	4c8c      	beqz.n	a12, 42009cbd <_fseeko_r+0xa1>
42009cb7:	152322        	l32i	a2, a3, 84
42009cba:	0004c6        	j	42009cd1 <_fseeko_r+0xb5>
42009cbd:	83b8      	l32i.n	a11, a3, 32
42009cbf:	182182        	l32i	a8, a1, 96
42009cc2:	05dd      	mov.n	a13, a5
42009cc4:	06ad      	mov.n	a10, a6
42009cc6:	0008e0        	callx8	a8
42009cc9:	0a2d      	mov.n	a2, a10
42009ccb:	020a66        	bnei	a10, -1, 42009cd1 <_fseeko_r+0xb5>
42009cce:	00a486        	j	42009f64 <_fseeko_r+0x348>
42009cd1:	061372        	l16ui	a7, a3, 12
42009cd4:	116727        	bbci	a7, 2, 42009ce9 <_fseeko_r+0xcd>
42009cd7:	1378      	l32i.n	a7, a3, 4
42009cd9:	c02270        	sub	a2, a2, a7
42009cdc:	d378      	l32i.n	a7, a3, 52
42009cde:	679c      	beqz.n	a7, 42009cf8 <_fseeko_r+0xdc>
42009ce0:	102372        	l32i	a7, a3, 64
42009ce3:	c02270        	sub	a2, a2, a7
42009ce6:	000386        	j	42009cf8 <_fseeko_r+0xdc>
42009ce9:	0b6737        	bbci	a7, 3, 42009cf8 <_fseeko_r+0xdc>
42009cec:	0378      	l32i.n	a7, a3, 0
42009cee:	678c      	beqz.n	a7, 42009cf8 <_fseeko_r+0xdc>
42009cf0:	4398      	l32i.n	a9, a3, 16
42009cf2:	c07790        	sub	a7, a7, a9
42009cf5:	802270        	add	a2, a2, a7
42009cf8:	057d      	mov.n	a7, a5
42009cfa:	442a      	add.n	a4, a4, a2
42009cfc:	050c      	movi.n	a5, 0
42009cfe:	000206        	j	42009d0a <_fseeko_r+0xee>
42009d01:	621c      	movi.n	a2, 22
42009d03:	0629      	s32i.n	a2, a6, 0
42009d05:	0078c6        	j	42009eec <_fseeko_r+0x2d0>
42009d08:	027d      	mov.n	a7, a2
42009d0a:	4398      	l32i.n	a9, a3, 16
42009d0c:	89cc      	bnez.n	a9, 42009d18 <_fseeko_r+0xfc>
42009d0e:	03bd      	mov.n	a11, a3
42009d10:	06ad      	mov.n	a10, a6
42009d12:	201110        	or	a1, a1, a1
42009d15:	005be5        	call8	4200a2d4 <__smakebuf_r>
42009d18:	0da492        	movi	a9, 0x40d
42009d1b:	0613a2        	l16ui	a10, a3, 12
42009d1e:	999a      	add.n	a9, a9, a9
42009d20:	020a97        	bnone	a10, a9, 42009d26 <_fseeko_r+0x10a>
42009d23:	006dc6        	j	42009ede <_fseeko_r+0x2c2>
42009d26:	00a4d2        	movi	a13, 0x400
42009d29:	578ad7        	bany	a10, a13, 42009d84 <_fseeko_r+0x168>
42009d2c:	db8591        	l32r	a9, 42000b40 <_stext+0xb20>
42009d2f:	182182        	l32i	a8, a1, 96
42009d32:	131897        	beq	a8, a9, 42009d49 <_fseeko_r+0x12d>
42009d35:	061322        	l16ui	a2, a3, 12
42009d38:	170c      	movi.n	a7, 1
42009d3a:	117750        	slli	a7, a7, 11
42009d3d:	202270        	or	a2, a2, a7
42009d40:	065322        	s16i	a2, a3, 12
42009d43:	0065c6        	j	42009ede <_fseeko_r+0x2c2>
42009d46:	00          	.byte 00
42009d47:	00          	.byte 00
42009d48:	00          	.byte 00
42009d49:	0793b2        	l16si	a11, a3, 14
42009d4c:	fe5b96        	bltz	a11, 42009d35 <_fseeko_r+0x119>
42009d4f:	01cd      	mov.n	a12, a1
42009d51:	20a660        	or	a10, a6, a6
42009d54:	1961d2        	s32i	a13, a1, 100
42009d57:	201110        	or	a1, a1, a1
42009d5a:	fb0aa5        	call8	42004e04 <_fstat_r>
42009d5d:	1921d2        	l32i	a13, a1, 100
42009d60:	fd1a56        	bnez	a10, 42009d35 <_fseeko_r+0x119>
42009d63:	11b8      	l32i.n	a11, a1, 4
42009d65:	fa0c      	movi.n	a10, 15
42009d67:	11aa40        	slli	a10, a10, 12
42009d6a:	10bba0        	and	a11, a11, a10
42009d6d:	1a0c      	movi.n	a10, 1
42009d6f:	11aa10        	slli	a10, a10, 15
42009d72:	069392        	l16si	a9, a3, 12
42009d75:	bc9ba7        	bne	a11, a10, 42009d35 <_fseeko_r+0x119>
42009d78:	1221a2        	l32i	a10, a1, 72
42009d7b:	2099d0        	or	a9, a9, a13
42009d7e:	1463a2        	s32i	a10, a3, 80
42009d81:	065392        	s16i	a9, a3, 12
42009d84:	049d      	mov.n	a9, a4
42009d86:	259c      	beqz.n	a5, 42009d9c <_fseeko_r+0x180>
42009d88:	0793b2        	l16si	a11, a3, 14
42009d8b:	01cd      	mov.n	a12, a1
42009d8d:	06ad      	mov.n	a10, a6
42009d8f:	201110        	or	a1, a1, a1
42009d92:	fb0725        	call8	42004e04 <_fstat_r>
42009d95:	145a56        	bnez	a10, 42009ede <_fseeko_r+0x2c2>
42009d98:	4198      	l32i.n	a9, a1, 16
42009d9a:	949a      	add.n	a9, a4, a9
42009d9c:	47fc      	bnez.n	a7, 42009dd4 <_fseeko_r+0x1b8>
42009d9e:	061322        	l16ui	a2, a3, 12
42009da1:	0562c7        	bbci	a2, 12, 42009daa <_fseeko_r+0x18e>
42009da4:	1523a2        	l32i	a10, a3, 84
42009da7:	000686        	j	42009dc5 <_fseeko_r+0x1a9>
42009daa:	83b8      	l32i.n	a11, a3, 32
42009dac:	182122        	l32i	a2, a1, 96
42009daf:	196192        	s32i	a9, a1, 100
42009db2:	1d0c      	movi.n	a13, 1
42009db4:	07cd      	mov.n	a12, a7
42009db6:	20a660        	or	a10, a6, a6
42009db9:	0002e0        	callx8	a2
42009dbc:	192192        	l32i	a9, a1, 100
42009dbf:	020a66        	bnei	a10, -1, 42009dc5 <_fseeko_r+0x1a9>
42009dc2:	004606        	j	42009ede <_fseeko_r+0x2c2>
42009dc5:	1328      	l32i.n	a2, a3, 4
42009dc7:	d378      	l32i.n	a7, a3, 52
42009dc9:	c02a20        	sub	a2, a10, a2
42009dcc:	478c      	beqz.n	a7, 42009dd4 <_fseeko_r+0x1b8>
42009dce:	102372        	l32i	a7, a3, 64
42009dd1:	c02270        	sub	a2, a2, a7
42009dd4:	d3b8      	l32i.n	a11, a3, 52
42009dd6:	43a8      	l32i.n	a10, a3, 16
42009dd8:	1378      	l32i.n	a7, a3, 4
42009dda:	eb8c      	beqz.n	a11, 42009dec <_fseeko_r+0x1d0>
42009ddc:	f3c8      	l32i.n	a12, a3, 60
42009dde:	227a      	add.n	a2, a2, a7
42009de0:	c0cca0        	sub	a12, a12, a10
42009de3:	102372        	l32i	a7, a3, 64
42009de6:	c022c0        	sub	a2, a2, a12
42009de9:	0001c6        	j	42009df4 <_fseeko_r+0x1d8>
42009dec:	03c8      	l32i.n	a12, a3, 0
42009dee:	c0cca0        	sub	a12, a12, a10
42009df1:	c022c0        	sub	a2, a2, a12
42009df4:	77ca      	add.n	a7, a7, a12
42009df6:	332927        	blt	a9, a2, 42009e2d <_fseeko_r+0x211>
42009df9:	c27a      	add.n	a12, a2, a7
42009dfb:	2eb9c7        	bgeu	a9, a12, 42009e2d <_fseeko_r+0x211>
42009dfe:	c02920        	sub	a2, a9, a2
42009e01:	aa2a      	add.n	a10, a10, a2
42009e03:	c07720        	sub	a7, a7, a2
42009e06:	03a9      	s32i.n	a10, a3, 0
42009e08:	1379      	s32i.n	a7, a3, 4
42009e0a:	0b9c      	beqz.n	a11, 42009e1e <_fseeko_r+0x202>
42009e0c:	44c322        	addi	a2, a3, 68
42009e0f:	071b27        	beq	a11, a2, 42009e1a <_fseeko_r+0x1fe>
42009e12:	06ad      	mov.n	a10, a6
42009e14:	db5b81        	l32r	a8, 42000b80 <_stext+0xb60>
42009e17:	0008e0        	callx8	a8
42009e1a:	020c      	movi.n	a2, 0
42009e1c:	d329      	s32i.n	a2, a3, 52
42009e1e:	061322        	l16ui	a2, a3, 12
42009e21:	dfaf42        	movi	a4, -33
42009e24:	102240        	and	a2, a2, a4
42009e27:	065322        	s16i	a2, a3, 12
42009e2a:	001f06        	j	42009eaa <_fseeko_r+0x28e>
42009e2d:	142322        	l32i	a2, a3, 80
42009e30:	83b8      	l32i.n	a11, a3, 32
42009e32:	602020        	neg	a2, a2
42009e35:	102290        	and	a2, a2, a9
42009e38:	182182        	l32i	a8, a1, 96
42009e3b:	196192        	s32i	a9, a1, 100
42009e3e:	0d0c      	movi.n	a13, 0
42009e40:	20c220        	or	a12, a2, a2
42009e43:	20a660        	or	a10, a6, a6
42009e46:	0008e0        	callx8	a8
42009e49:	192192        	l32i	a9, a1, 100
42009e4c:	020a66        	bnei	a10, -1, 42009e52 <_fseeko_r+0x236>
42009e4f:	0022c6        	j	42009ede <_fseeko_r+0x2c2>
42009e52:	43a8      	l32i.n	a10, a3, 16
42009e54:	070c      	movi.n	a7, 0
42009e56:	d3b8      	l32i.n	a11, a3, 52
42009e58:	1379      	s32i.n	a7, a3, 4
42009e5a:	03a9      	s32i.n	a10, a3, 0
42009e5c:	161b77        	beq	a11, a7, 42009e76 <_fseeko_r+0x25a>
42009e5f:	44c3a2        	addi	a10, a3, 68
42009e62:	0e1ba7        	beq	a11, a10, 42009e74 <_fseeko_r+0x258>
42009e65:	20a660        	or	a10, a6, a6
42009e68:	196192        	s32i	a9, a1, 100
42009e6b:	db4581        	l32r	a8, 42000b80 <_stext+0xb60>
42009e6e:	0008e0        	callx8	a8
42009e71:	192192        	l32i	a9, a1, 100
42009e74:	d379      	s32i.n	a7, a3, 52
42009e76:	061372        	l16ui	a7, a3, 12
42009e79:	dfafa2        	movi	a10, -33
42009e7c:	1077a0        	and	a7, a7, a10
42009e7f:	065372        	s16i	a7, a3, 12
42009e82:	c07920        	sub	a7, a9, a2
42009e85:	211927        	beq	a9, a2, 42009eaa <_fseeko_r+0x28e>
42009e88:	20b330        	or	a11, a3, a3
42009e8b:	20a660        	or	a10, a6, a6
42009e8e:	201110        	or	a1, a1, a1
42009e91:	0065e5        	call8	4200a4f0 <__srefill_r>
42009e94:	046a56        	bnez	a10, 42009ede <_fseeko_r+0x2c2>
42009e97:	1328      	l32i.n	a2, a3, 4
42009e99:	413277        	bltu	a2, a7, 42009ede <_fseeko_r+0x2c2>
42009e9c:	0348      	l32i.n	a4, a3, 0
42009e9e:	c02270        	sub	a2, a2, a7
42009ea1:	804470        	add	a4, a4, a7
42009ea4:	006342        	s32i	a4, a3, 0
42009ea7:	016322        	s32i	a2, a3, 4
42009eaa:	8c0c      	movi.n	a12, 8
42009eac:	00a0b2        	movi	a11, 0
42009eaf:	5cc3a2        	addi	a10, a3, 92
42009eb2:	d8b981        	l32r	a8, 42000198 <_stext+0x178>
42009eb5:	0008e0        	callx8	a8
42009eb8:	192322        	l32i	a2, a3, 100
42009ebb:	0ee207        	bbsi	a2, 0, 42009ecd <_fseeko_r+0x2b1>
42009ebe:	061322        	l16ui	a2, a3, 12
42009ec1:	08e297        	bbsi	a2, 9, 42009ecd <_fseeko_r+0x2b1>
42009ec4:	1623a2        	l32i	a10, a3, 88
42009ec7:	db2281        	l32r	a8, 42000b50 <_stext+0xb30>
42009eca:	0008e0        	callx8	a8
42009ecd:	1621a2        	l32i	a10, a1, 88
42009ed0:	58c1b2        	addi	a11, a1, 88
42009ed3:	201110        	or	a1, a1, a1
42009ed6:	0e03e5        	call8	42017f14 <pthread_setcancelstate>
42009ed9:	020c      	movi.n	a2, 0
42009edb:	002986        	j	42009f85 <_fseeko_r+0x369>
42009ede:	03bd      	mov.n	a11, a3
42009ee0:	06ad      	mov.n	a10, a6
42009ee2:	201110        	or	a1, a1, a1
42009ee5:	0863e5        	call8	42012524 <_fflush_r>
42009ee8:	0a2d      	mov.n	a2, a10
42009eea:	8a8c      	beqz.n	a10, 42009ef6 <_fseeko_r+0x2da>
42009eec:	192322        	l32i	a2, a3, 100
42009eef:	1a6207        	bbci	a2, 0, 42009f0d <_fseeko_r+0x2f1>
42009ef2:	000986        	j	42009f1c <_fseeko_r+0x300>
42009ef5:	00          	.byte 00
42009ef6:	04cd      	mov.n	a12, a4
42009ef8:	83b8      	l32i.n	a11, a3, 32
42009efa:	182142        	l32i	a4, a1, 96
42009efd:	05dd      	mov.n	a13, a5
42009eff:	06ad      	mov.n	a10, a6
42009f01:	0004e0        	callx8	a4
42009f04:	260a66        	bnei	a10, -1, 42009f2e <_fseeko_r+0x312>
42009f07:	fff846        	j	42009eec <_fseeko_r+0x2d0>
42009f0a:	00          	.byte 00
42009f0b:	00          	.byte 00
42009f0c:	00          	.byte 00
42009f0d:	061322        	l16ui	a2, a3, 12
42009f10:	08e297        	bbsi	a2, 9, 42009f1c <_fseeko_r+0x300>
42009f13:	1623a2        	l32i	a10, a3, 88
42009f16:	db0e81        	l32r	a8, 42000b50 <_stext+0xb30>
42009f19:	0008e0        	callx8	a8
42009f1c:	1621a2        	l32i	a10, a1, 88
42009f1f:	58c1b2        	addi	a11, a1, 88
42009f22:	201110        	or	a1, a1, a1
42009f25:	0dfee5        	call8	42017f14 <pthread_setcancelstate>
42009f28:	f27c      	movi.n	a2, -1
42009f2a:	0015c6        	j	42009f85 <_fseeko_r+0x369>
42009f2d:	00          	.byte 00
42009f2e:	d3b8      	l32i.n	a11, a3, 52
42009f30:	1b9c      	beqz.n	a11, 42009f45 <_fseeko_r+0x329>
42009f32:	44c342        	addi	a4, a3, 68
42009f35:	081b47        	beq	a11, a4, 42009f41 <_fseeko_r+0x325>
42009f38:	20a660        	or	a10, a6, a6
42009f3b:	db1181        	l32r	a8, 42000b80 <_stext+0xb60>
42009f3e:	0008e0        	callx8	a8
42009f41:	040c      	movi.n	a4, 0
42009f43:	d349      	s32i.n	a4, a3, 52
42009f45:	4348      	l32i.n	a4, a3, 16
42009f47:	db0d51        	l32r	a5, 42000b7c <_stext+0xb5c>
42009f4a:	0349      	s32i.n	a4, a3, 0
42009f4c:	061342        	l16ui	a4, a3, 12
42009f4f:	0b0c      	movi.n	a11, 0
42009f51:	104450        	and	a4, a4, a5
42009f54:	13b9      	s32i.n	a11, a3, 4
42009f56:	065342        	s16i	a4, a3, 12
42009f59:	8c0c      	movi.n	a12, 8
42009f5b:	5cc3a2        	addi	a10, a3, 92
42009f5e:	d88e81        	l32r	a8, 42000198 <_stext+0x178>
42009f61:	0008e0        	callx8	a8
42009f64:	192342        	l32i	a4, a3, 100
42009f67:	0ee407        	bbsi	a4, 0, 42009f79 <_fseeko_r+0x35d>
42009f6a:	061342        	l16ui	a4, a3, 12
42009f6d:	08e497        	bbsi	a4, 9, 42009f79 <_fseeko_r+0x35d>
42009f70:	1623a2        	l32i	a10, a3, 88
42009f73:	daf781        	l32r	a8, 42000b50 <_stext+0xb30>
42009f76:	0008e0        	callx8	a8
42009f79:	1621a2        	l32i	a10, a1, 88
42009f7c:	58c1b2        	addi	a11, a1, 88
42009f7f:	201110        	or	a1, a1, a1
42009f82:	0df925        	call8	42017f14 <pthread_setcancelstate>
42009f85:	f01d      	retw.n
	...

42009f88 <fseeko>:
42009f88:	004136        	entry	a1, 32
42009f8b:	daea81        	l32r	a8, 42000b34 <_stext+0xb14>
42009f8e:	0008e0        	callx8	a8
42009f91:	02bd      	mov.n	a11, a2
42009f93:	04dd      	mov.n	a13, a4
42009f95:	03cd      	mov.n	a12, a3
42009f97:	ffc865        	call8	42009c1c <_fseeko_r>
42009f9a:	0a2d      	mov.n	a2, a10
42009f9c:	f01d      	retw.n
	...

42009fa0 <__sfvwrite_r>:
42009fa0:	006136        	entry	a1, 48
42009fa3:	036d      	mov.n	a6, a3
42009fa5:	2438      	l32i.n	a3, a4, 8
42009fa7:	53cc      	bnez.n	a3, 42009fb0 <__sfvwrite_r+0x10>
42009fa9:	030c      	movi.n	a3, 0
42009fab:	00a986        	j	4200a255 <__sfvwrite_r+0x2b5>
42009fae:	00          	.byte 00
42009faf:	00          	.byte 00
42009fb0:	061632        	l16ui	a3, a6, 12
42009fb3:	156337        	bbci	a3, 3, 42009fcc <__sfvwrite_r+0x2c>
42009fb6:	4638      	l32i.n	a3, a6, 16
42009fb8:	039c      	beqz.n	a3, 42009fcc <__sfvwrite_r+0x2c>
42009fba:	0438      	l32i.n	a3, a4, 0
42009fbc:	061652        	l16ui	a5, a6, 12
42009fbf:	270c      	movi.n	a7, 2
42009fc1:	0139      	s32i.n	a3, a1, 0
42009fc3:	107570        	and	a7, a5, a7
42009fc6:	37ec      	bnez.n	a7, 42009fed <__sfvwrite_r+0x4d>
42009fc8:	001446        	j	4200a01d <__sfvwrite_r+0x7d>
42009fcb:	00          	.byte 00
42009fcc:	06bd      	mov.n	a11, a6
42009fce:	02ad      	mov.n	a10, a2
42009fd0:	201110        	or	a1, a1, a1
42009fd3:	0738e5        	call8	42011360 <__swsetup_r>
42009fd6:	f37c      	movi.n	a3, -1
42009fd8:	fdea16        	beqz	a10, 42009fba <__sfvwrite_r+0x1a>
42009fdb:	009d86        	j	4200a255 <__sfvwrite_r+0x2b5>
42009fde:	0188      	l32i.n	a8, a1, 0
42009fe0:	0878      	l32i.n	a7, a8, 0
42009fe2:	1838      	l32i.n	a3, a8, 4
42009fe4:	888b      	addi.n	a8, a8, 8
42009fe6:	0189      	s32i.n	a8, a1, 0
42009fe8:	000206        	j	42009ff4 <__sfvwrite_r+0x54>
42009feb:	00          	.byte 00
42009fec:	00          	.byte 00
42009fed:	070c      	movi.n	a7, 0
42009fef:	dae551        	l32r	a5, 42000b84 <_stext+0xb64>
42009ff2:	073d      	mov.n	a3, a7
42009ff4:	a698      	l32i.n	a9, a6, 40
42009ff6:	86b8      	l32i.n	a11, a6, 32
42009ff8:	fe2316        	beqz	a3, 42009fde <__sfvwrite_r+0x3e>
42009ffb:	63d350        	minu	a13, a3, a5
42009ffe:	07cd      	mov.n	a12, a7
4200a000:	02ad      	mov.n	a10, a2
4200a002:	0009e0        	callx8	a9
4200a005:	021ae6        	bgei	a10, 1, 4200a00b <__sfvwrite_r+0x6b>
4200a008:	008f06        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a00b:	2498      	l32i.n	a9, a4, 8
4200a00d:	77aa      	add.n	a7, a7, a10
4200a00f:	c033a0        	sub	a3, a3, a10
4200a012:	c0a9a0        	sub	a10, a9, a10
4200a015:	24a9      	s32i.n	a10, a4, 8
4200a017:	fd9a56        	bnez	a10, 42009ff4 <__sfvwrite_r+0x54>
4200a01a:	ffe2c6        	j	42009fa9 <__sfvwrite_r+0x9>
4200a01d:	045050        	extui	a5, a5, 0, 1
4200a020:	a59c      	beqz.n	a5, 4200a03e <__sfvwrite_r+0x9e>
4200a022:	07ad      	mov.n	a10, a7
4200a024:	073d      	mov.n	a3, a7
4200a026:	1179      	s32i.n	a7, a1, 4
4200a028:	005a86        	j	4200a196 <__sfvwrite_r+0x1f6>
4200a02b:	00          	.byte 00
4200a02c:	0188      	l32i.n	a8, a1, 0
4200a02e:	0138      	l32i.n	a3, a1, 0
4200a030:	888b      	addi.n	a8, a8, 8
4200a032:	0358      	l32i.n	a5, a3, 0
4200a034:	0189      	s32i.n	a8, a1, 0
4200a036:	1338      	l32i.n	a3, a3, 4
4200a038:	000106        	j	4200a040 <__sfvwrite_r+0xa0>
4200a03b:	00          	.byte 00
4200a03c:	00          	.byte 00
4200a03d:	00          	.byte 00
4200a03e:	053d      	mov.n	a3, a5
4200a040:	0616c2        	l16ui	a12, a6, 12
4200a043:	06a8      	l32i.n	a10, a6, 0
4200a045:	26e8      	l32i.n	a14, a6, 8
4200a047:	fe1316        	beqz	a3, 4200a02c <__sfvwrite_r+0x8c>
4200a04a:	f4c0c0        	extui	a12, a12, 0, 16
4200a04d:	00a282        	movi	a8, 0x200
4200a050:	028c87        	bany	a12, a8, 4200a056 <__sfvwrite_r+0xb6>
4200a053:	0030c6        	j	4200a11a <__sfvwrite_r+0x17a>
4200a056:	02b3e7        	bgeu	a3, a14, 4200a05c <__sfvwrite_r+0xbc>
4200a059:	002606        	j	4200a0f5 <__sfvwrite_r+0x155>
4200a05c:	80a472        	movi	a7, 0x480
4200a05f:	028c77        	bany	a12, a7, 4200a065 <__sfvwrite_r+0xc5>
4200a062:	0023c6        	j	4200a0f5 <__sfvwrite_r+0x155>
4200a065:	46b8      	l32i.n	a11, a6, 16
4200a067:	c0aab0        	sub	a10, a10, a11
4200a06a:	11a9      	s32i.n	a10, a1, 4
4200a06c:	56a8      	l32i.n	a10, a6, 20
4200a06e:	1188      	l32i.n	a8, a1, 4
4200a070:	90aaa0        	addx2	a10, a10, a10
4200a073:	05dfa0        	extui	a13, a10, 31, 1
4200a076:	ddaa      	add.n	a13, a13, a10
4200a078:	a81b      	addi.n	a10, a8, 1
4200a07a:	2171d0        	srai	a7, a13, 1
4200a07d:	aa3a      	add.n	a10, a10, a3
4200a07f:	7377a0        	maxu	a7, a7, a10
4200a082:	326ca7        	bbci	a12, 10, 4200a0b8 <__sfvwrite_r+0x118>
4200a085:	07bd      	mov.n	a11, a7
4200a087:	20a220        	or	a10, a2, a2
4200a08a:	dab281        	l32r	a8, 42000b54 <_stext+0xb34>
4200a08d:	0008e0        	callx8	a8
4200a090:	1acc      	bnez.n	a10, 4200a095 <__sfvwrite_r+0xf5>
4200a092:	001186        	j	4200a0dc <__sfvwrite_r+0x13c>
4200a095:	46b8      	l32i.n	a11, a6, 16
4200a097:	11c8      	l32i.n	a12, a1, 4
4200a099:	21a9      	s32i.n	a10, a1, 8
4200a09b:	d84c81        	l32r	a8, 420001cc <_stext+0x1ac>
4200a09e:	0008e0        	callx8	a8
4200a0a1:	0616a2        	l16ui	a10, a6, 12
4200a0a4:	7fabb2        	movi	a11, 0xfffffb7f
4200a0a7:	10aab0        	and	a10, a10, a11
4200a0aa:	80a0b2        	movi	a11, 128
4200a0ad:	20aab0        	or	a10, a10, a11
4200a0b0:	21e8      	l32i.n	a14, a1, 8
4200a0b2:	0656a2        	s16i	a10, a6, 12
4200a0b5:	000ac6        	j	4200a0e4 <__sfvwrite_r+0x144>
4200a0b8:	07cd      	mov.n	a12, a7
4200a0ba:	02ad      	mov.n	a10, a2
4200a0bc:	dab481        	l32r	a8, 42000b8c <_stext+0xb6c>
4200a0bf:	0008e0        	callx8	a8
4200a0c2:	0aed      	mov.n	a14, a10
4200a0c4:	cadc      	bnez.n	a10, 4200a0e4 <__sfvwrite_r+0x144>
4200a0c6:	46b8      	l32i.n	a11, a6, 16
4200a0c8:	02ad      	mov.n	a10, a2
4200a0ca:	daad81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a0cd:	0008e0        	callx8	a8
4200a0d0:	061632        	l16ui	a3, a6, 12
4200a0d3:	7faf42        	movi	a4, -129
4200a0d6:	103340        	and	a3, a3, a4
4200a0d9:	065632        	s16i	a3, a6, 12
4200a0dc:	c30c      	movi.n	a3, 12
4200a0de:	0239      	s32i.n	a3, a2, 0
4200a0e0:	005906        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a0e3:	00          	.byte 00
4200a0e4:	1188      	l32i.n	a8, a1, 4
4200a0e6:	46e9      	s32i.n	a14, a6, 16
4200a0e8:	c0d780        	sub	a13, a7, a8
4200a0eb:	ee8a      	add.n	a14, a14, a8
4200a0ed:	06e9      	s32i.n	a14, a6, 0
4200a0ef:	5679      	s32i.n	a7, a6, 20
4200a0f1:	03ed      	mov.n	a14, a3
4200a0f3:	26d9      	s32i.n	a13, a6, 8
4200a0f5:	63ee30        	minu	a14, a14, a3
4200a0f8:	06a8      	l32i.n	a10, a6, 0
4200a0fa:	0ecd      	mov.n	a12, a14
4200a0fc:	05bd      	mov.n	a11, a5
4200a0fe:	21e9      	s32i.n	a14, a1, 8
4200a100:	daa481        	l32r	a8, 42000b90 <_stext+0xb70>
4200a103:	0008e0        	callx8	a8
4200a106:	26a8      	l32i.n	a10, a6, 8
4200a108:	21e8      	l32i.n	a14, a1, 8
4200a10a:	037d      	mov.n	a7, a3
4200a10c:	c0aae0        	sub	a10, a10, a14
4200a10f:	26a9      	s32i.n	a10, a6, 8
4200a111:	06a8      	l32i.n	a10, a6, 0
4200a113:	aaea      	add.n	a10, a10, a14
4200a115:	06a9      	s32i.n	a10, a6, 0
4200a117:	001686        	j	4200a175 <__sfvwrite_r+0x1d5>
4200a11a:	4678      	l32i.n	a7, a6, 16
4200a11c:	0437a7        	bltu	a7, a10, 4200a124 <__sfvwrite_r+0x184>
4200a11f:	56d8      	l32i.n	a13, a6, 20
4200a121:	2cb3d7        	bgeu	a3, a13, 4200a151 <__sfvwrite_r+0x1b1>
4200a124:	637e30        	minu	a7, a14, a3
4200a127:	05bd      	mov.n	a11, a5
4200a129:	07cd      	mov.n	a12, a7
4200a12b:	da9981        	l32r	a8, 42000b90 <_stext+0xb70>
4200a12e:	0008e0        	callx8	a8
4200a131:	26a8      	l32i.n	a10, a6, 8
4200a133:	06b8      	l32i.n	a11, a6, 0
4200a135:	c0aa70        	sub	a10, a10, a7
4200a138:	bb7a      	add.n	a11, a11, a7
4200a13a:	26a9      	s32i.n	a10, a6, 8
4200a13c:	06b9      	s32i.n	a11, a6, 0
4200a13e:	3afc      	bnez.n	a10, 4200a175 <__sfvwrite_r+0x1d5>
4200a140:	06bd      	mov.n	a11, a6
4200a142:	02ad      	mov.n	a10, a2
4200a144:	201110        	or	a1, a1, a1
4200a147:	083de5        	call8	42012524 <_fflush_r>
4200a14a:	7aac      	beqz.n	a10, 4200a175 <__sfvwrite_r+0x1d5>
4200a14c:	003e06        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a14f:	00          	.byte 00
4200a150:	00          	.byte 00
4200a151:	da8da1        	l32r	a10, 42000b88 <_stext+0xb68>
4200a154:	d89f71        	l32r	a7, 420003d0 <_stext+0x3b0>
4200a157:	013a37        	bltu	a10, a3, 4200a15c <__sfvwrite_r+0x1bc>
4200a15a:	037d      	mov.n	a7, a3
4200a15c:	d277d0        	quos	a7, a7, a13
4200a15f:	82d7d0        	mull	a13, a7, a13
4200a162:	a6e8      	l32i.n	a14, a6, 40
4200a164:	86b8      	l32i.n	a11, a6, 32
4200a166:	05cd      	mov.n	a12, a5
4200a168:	02ad      	mov.n	a10, a2
4200a16a:	000ee0        	callx8	a14
4200a16d:	0a7d      	mov.n	a7, a10
4200a16f:	021ae6        	bgei	a10, 1, 4200a175 <__sfvwrite_r+0x1d5>
4200a172:	003486        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a175:	24a8      	l32i.n	a10, a4, 8
4200a177:	557a      	add.n	a5, a5, a7
4200a179:	c03370        	sub	a3, a3, a7
4200a17c:	c07a70        	sub	a7, a10, a7
4200a17f:	2479      	s32i.n	a7, a4, 8
4200a181:	ebb756        	bnez	a7, 4200a040 <__sfvwrite_r+0xa0>
4200a184:	ff8846        	j	42009fa9 <__sfvwrite_r+0x9>
4200a187:	00          	.byte 00
4200a188:	0158      	l32i.n	a5, a1, 0
4200a18a:	0a0c      	movi.n	a10, 0
4200a18c:	1588      	l32i.n	a8, a5, 4
4200a18e:	0538      	l32i.n	a3, a5, 0
4200a190:	558b      	addi.n	a5, a5, 8
4200a192:	1189      	s32i.n	a8, a1, 4
4200a194:	0159      	s32i.n	a5, a1, 0
4200a196:	1158      	l32i.n	a5, a1, 4
4200a198:	fec516        	beqz	a5, 4200a188 <__sfvwrite_r+0x1e8>
4200a19b:	3adc      	bnez.n	a10, 4200a1b2 <__sfvwrite_r+0x212>
4200a19d:	05cd      	mov.n	a12, a5
4200a19f:	ab0c      	movi.n	a11, 10
4200a1a1:	03ad      	mov.n	a10, a3
4200a1a3:	da7c81        	l32r	a8, 42000b94 <_stext+0xb74>
4200a1a6:	0008e0        	callx8	a8
4200a1a9:	751b      	addi.n	a7, a5, 1
4200a1ab:	3a8c      	beqz.n	a10, 4200a1b2 <__sfvwrite_r+0x212>
4200a1ad:	aa1b      	addi.n	a10, a10, 1
4200a1af:	c07a30        	sub	a7, a10, a3
4200a1b2:	1188      	l32i.n	a8, a1, 4
4200a1b4:	56d8      	l32i.n	a13, a6, 20
4200a1b6:	2698      	l32i.n	a9, a6, 8
4200a1b8:	06a8      	l32i.n	a10, a6, 0
4200a1ba:	46b8      	l32i.n	a11, a6, 16
4200a1bc:	63f780        	minu	a15, a7, a8
4200a1bf:	5d9a      	add.n	a5, a13, a9
4200a1c1:	23bba7        	bgeu	a11, a10, 4200a1e8 <__sfvwrite_r+0x248>
4200a1c4:	20a5f7        	bge	a5, a15, 4200a1e8 <__sfvwrite_r+0x248>
4200a1c7:	03bd      	mov.n	a11, a3
4200a1c9:	05cd      	mov.n	a12, a5
4200a1cb:	da7181        	l32r	a8, 42000b90 <_stext+0xb70>
4200a1ce:	0008e0        	callx8	a8
4200a1d1:	06a8      	l32i.n	a10, a6, 0
4200a1d3:	06bd      	mov.n	a11, a6
4200a1d5:	aa5a      	add.n	a10, a10, a5
4200a1d7:	06a9      	s32i.n	a10, a6, 0
4200a1d9:	02ad      	mov.n	a10, a2
4200a1db:	201110        	or	a1, a1, a1
4200a1de:	083465        	call8	42012524 <_fflush_r>
4200a1e1:	7abc      	beqz.n	a10, 4200a21c <__sfvwrite_r+0x27c>
4200a1e3:	001846        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a1e6:	00          	.byte 00
4200a1e7:	00          	.byte 00
4200a1e8:	122fd7        	blt	a15, a13, 4200a1fe <__sfvwrite_r+0x25e>
4200a1eb:	a698      	l32i.n	a9, a6, 40
4200a1ed:	86b8      	l32i.n	a11, a6, 32
4200a1ef:	03cd      	mov.n	a12, a3
4200a1f1:	02ad      	mov.n	a10, a2
4200a1f3:	0009e0        	callx8	a9
4200a1f6:	0a5d      	mov.n	a5, a10
4200a1f8:	201ae6        	bgei	a10, 1, 4200a21c <__sfvwrite_r+0x27c>
4200a1fb:	001246        	j	4200a248 <__sfvwrite_r+0x2a8>
4200a1fe:	0fcd      	mov.n	a12, a15
4200a200:	03bd      	mov.n	a11, a3
4200a202:	21f9      	s32i.n	a15, a1, 8
4200a204:	da6381        	l32r	a8, 42000b90 <_stext+0xb70>
4200a207:	0008e0        	callx8	a8
4200a20a:	21f8      	l32i.n	a15, a1, 8
4200a20c:	2698      	l32i.n	a9, a6, 8
4200a20e:	0f5d      	mov.n	a5, a15
4200a210:	c099f0        	sub	a9, a9, a15
4200a213:	2699      	s32i.n	a9, a6, 8
4200a215:	0698      	l32i.n	a9, a6, 0
4200a217:	99fa      	add.n	a9, a9, a15
4200a219:	006692        	s32i	a9, a6, 0
4200a21c:	c07750        	sub	a7, a7, a5
4200a21f:	1a0c      	movi.n	a10, 1
4200a221:	b7cc      	bnez.n	a7, 4200a230 <__sfvwrite_r+0x290>
4200a223:	06bd      	mov.n	a11, a6
4200a225:	20a220        	or	a10, a2, a2
4200a228:	201110        	or	a1, a1, a1
4200a22b:	082fa5        	call8	42012524 <_fflush_r>
4200a22e:	6adc      	bnez.n	a10, 4200a248 <__sfvwrite_r+0x2a8>
4200a230:	1188      	l32i.n	a8, a1, 4
4200a232:	24b8      	l32i.n	a11, a4, 8
4200a234:	c08850        	sub	a8, a8, a5
4200a237:	c09b50        	sub	a9, a11, a5
4200a23a:	1189      	s32i.n	a8, a1, 4
4200a23c:	2499      	s32i.n	a9, a4, 8
4200a23e:	335a      	add.n	a3, a3, a5
4200a240:	f52956        	bnez	a9, 4200a196 <__sfvwrite_r+0x1f6>
4200a243:	ff5886        	j	42009fa9 <__sfvwrite_r+0x9>
4200a246:	00          	.byte 00
4200a247:	00          	.byte 00
4200a248:	061622        	l16ui	a2, a6, 12
4200a24b:	034c      	movi.n	a3, 64
4200a24d:	202230        	or	a2, a2, a3
4200a250:	065622        	s16i	a2, a6, 12
4200a253:	f37c      	movi.n	a3, -1
4200a255:	032d      	mov.n	a2, a3
4200a257:	f01d      	retw.n
4200a259:	000000        	ill

4200a25c <__swhatbuf_r>:
4200a25c:	010136        	entry	a1, 128
4200a25f:	0793b2        	l16si	a11, a3, 14
4200a262:	014bd6        	bgez	a11, 4200a27a <__swhatbuf_r+0x1e>
4200a265:	061322        	l16ui	a2, a3, 12
4200a268:	080c      	movi.n	a8, 0
4200a26a:	80a032        	movi	a3, 128
4200a26d:	0589      	s32i.n	a8, a5, 0
4200a26f:	102230        	and	a2, a2, a3
4200a272:	149287        	bne	a2, a8, 4200a28a <__swhatbuf_r+0x2e>
4200a275:	0006c6        	j	4200a294 <__swhatbuf_r+0x38>
4200a278:	00          	.byte 00
4200a279:	00          	.byte 00
4200a27a:	01cd      	mov.n	a12, a1
4200a27c:	02ad      	mov.n	a10, a2
4200a27e:	201110        	or	a1, a1, a1
4200a281:	fab825        	call8	42004e04 <_fstat_r>
4200a284:	014ad6        	bgez	a10, 4200a29c <__swhatbuf_r+0x40>
4200a287:	fff686        	j	4200a265 <__swhatbuf_r+0x9>
4200a28a:	024c      	movi.n	a2, 64
4200a28c:	0429      	s32i.n	a2, a4, 0
4200a28e:	082d      	mov.n	a2, a8
4200a290:	000f46        	j	4200a2d1 <__swhatbuf_r+0x75>
4200a293:	00          	.byte 00
4200a294:	80a032        	movi	a3, 128
4200a297:	0439      	s32i.n	a3, a4, 0
4200a299:	000d06        	j	4200a2d1 <__swhatbuf_r+0x75>
4200a29c:	1198      	l32i.n	a9, a1, 4
4200a29e:	f20c      	movi.n	a2, 15
4200a2a0:	112240        	slli	a2, a2, 12
4200a2a3:	109920        	and	a9, a9, a2
4200a2a6:	e0d9a2        	addmi	a10, a9, 0xffffe000
4200a2a9:	180c      	movi.n	a8, 1
4200a2ab:	020c      	movi.n	a2, 0
4200a2ad:	8328a0        	moveqz	a2, a8, a10
4200a2b0:	0529      	s32i.n	a2, a5, 0
4200a2b2:	122122        	l32i	a2, a1, 72
4200a2b5:	102287        	blt	a2, a8, 4200a2c9 <__swhatbuf_r+0x6d>
4200a2b8:	0429      	s32i.n	a2, a4, 0
4200a2ba:	146322        	s32i	a2, a3, 80
4200a2bd:	113810        	slli	a3, a8, 15
4200a2c0:	00a422        	movi	a2, 0x400
4200a2c3:	0a1937        	beq	a9, a3, 4200a2d1 <__swhatbuf_r+0x75>
4200a2c6:	000106        	j	4200a2ce <__swhatbuf_r+0x72>
4200a2c9:	80a022        	movi	a2, 128
4200a2cc:	0429      	s32i.n	a2, a4, 0
4200a2ce:	112850        	slli	a2, a8, 11
4200a2d1:	f01d      	retw.n
	...

4200a2d4 <__smakebuf_r>:
4200a2d4:	006136        	entry	a1, 48
4200a2d7:	061342        	l16ui	a4, a3, 12
4200a2da:	250c      	movi.n	a5, 2
4200a2dc:	020457        	bnone	a4, a5, 4200a2e2 <__smakebuf_r+0xe>
4200a2df:	000b06        	j	4200a30f <__smakebuf_r+0x3b>
4200a2e2:	01dd      	mov.n	a13, a1
4200a2e4:	c14b      	addi.n	a12, a1, 4
4200a2e6:	03bd      	mov.n	a11, a3
4200a2e8:	02ad      	mov.n	a10, a2
4200a2ea:	fff725        	call8	4200a25c <__swhatbuf_r>
4200a2ed:	11b8      	l32i.n	a11, a1, 4
4200a2ef:	0a4d      	mov.n	a4, a10
4200a2f1:	02ad      	mov.n	a10, a2
4200a2f3:	da1881        	l32r	a8, 42000b54 <_stext+0xb34>
4200a2f6:	0008e0        	callx8	a8
4200a2f9:	061382        	l16ui	a8, a3, 12
4200a2fc:	dadc      	bnez.n	a10, 4200a31d <__smakebuf_r+0x49>
4200a2fe:	234880        	sext	a4, a8, 15
4200a301:	58e897        	bbsi	a8, 9, 4200a35d <__smakebuf_r+0x89>
4200a304:	c27c      	movi.n	a2, -4
4200a306:	104420        	and	a4, a4, a2
4200a309:	204450        	or	a4, a4, a5
4200a30c:	065342        	s16i	a4, a3, 12
4200a30f:	47c322        	addi	a2, a3, 71
4200a312:	0329      	s32i.n	a2, a3, 0
4200a314:	4329      	s32i.n	a2, a3, 16
4200a316:	120c      	movi.n	a2, 1
4200a318:	5329      	s32i.n	a2, a3, 20
4200a31a:	000fc6        	j	4200a35d <__smakebuf_r+0x89>
4200a31d:	da0e51        	l32r	a5, 42000b58 <_stext+0xb38>
4200a320:	a259      	s32i.n	a5, a2, 40
4200a322:	80a052        	movi	a5, 128
4200a325:	208850        	or	a8, a8, a5
4200a328:	1158      	l32i.n	a5, a1, 4
4200a32a:	065382        	s16i	a8, a3, 12
4200a32d:	5359      	s32i.n	a5, a3, 20
4200a32f:	0158      	l32i.n	a5, a1, 0
4200a331:	03a9      	s32i.n	a10, a3, 0
4200a333:	43a9      	s32i.n	a10, a3, 16
4200a335:	b59c      	beqz.n	a5, 4200a354 <__smakebuf_r+0x80>
4200a337:	0793b2        	l16si	a11, a3, 14
4200a33a:	02ad      	mov.n	a10, a2
4200a33c:	201110        	or	a1, a1, a1
4200a33f:	0dbe65        	call8	42017f24 <_getpid_r>
4200a342:	ea8c      	beqz.n	a10, 4200a354 <__smakebuf_r+0x80>
4200a344:	061382        	l16ui	a8, a3, 12
4200a347:	c27c      	movi.n	a2, -4
4200a349:	108820        	and	a8, a8, a2
4200a34c:	120c      	movi.n	a2, 1
4200a34e:	208820        	or	a8, a8, a2
4200a351:	065382        	s16i	a8, a3, 12
4200a354:	061322        	l16ui	a2, a3, 12
4200a357:	204420        	or	a4, a4, a2
4200a35a:	065342        	s16i	a4, a3, 12
4200a35d:	f01d      	retw.n
	...

4200a360 <_printf_r>:
4200a360:	00a136        	entry	a1, 80
4200a363:	6149      	s32i.n	a4, a1, 24
4200a365:	7159      	s32i.n	a5, a1, 28
4200a367:	8169      	s32i.n	a6, a1, 32
4200a369:	9179      	s32i.n	a7, a1, 36
4200a36b:	b28c      	beqz.n	a2, 4200a37a <_printf_r+0x1a>
4200a36d:	6288      	l32i.n	a8, a2, 24
4200a36f:	78cc      	bnez.n	a8, 4200a37a <_printf_r+0x1a>
4200a371:	20a220        	or	a10, a2, a2
4200a374:	201110        	or	a1, a1, a1
4200a377:	ff63e5        	call8	420099b4 <__sinit>
4200a37a:	22b8      	l32i.n	a11, a2, 8
4200a37c:	10c1e2        	addi	a14, a1, 16
4200a37f:	30c1d2        	addi	a13, a1, 48
4200a382:	8f0c      	movi.n	a15, 8
4200a384:	03cd      	mov.n	a12, a3
4200a386:	02ad      	mov.n	a10, a2
4200a388:	11e9      	s32i.n	a14, a1, 4
4200a38a:	01d9      	s32i.n	a13, a1, 0
4200a38c:	21f9      	s32i.n	a15, a1, 8
4200a38e:	201110        	or	a1, a1, a1
4200a391:	03e1e5        	call8	4200e1b0 <_vfprintf_r>
4200a394:	0a2d      	mov.n	a2, a10
4200a396:	f01d      	retw.n

4200a398 <printf>:
4200a398:	00a136        	entry	a1, 80
4200a39b:	5139      	s32i.n	a3, a1, 20
4200a39d:	6149      	s32i.n	a4, a1, 24
4200a39f:	7159      	s32i.n	a5, a1, 28
4200a3a1:	086162        	s32i	a6, a1, 32
4200a3a4:	9179      	s32i.n	a7, a1, 36
4200a3a6:	d9e381        	l32r	a8, 42000b34 <_stext+0xb14>
4200a3a9:	0008e0        	callx8	a8
4200a3ac:	0a3d      	mov.n	a3, a10
4200a3ae:	8a8c      	beqz.n	a10, 4200a3ba <printf+0x22>
4200a3b0:	6a88      	l32i.n	a8, a10, 24
4200a3b2:	48cc      	bnez.n	a8, 4200a3ba <printf+0x22>
4200a3b4:	201110        	or	a1, a1, a1
4200a3b7:	ff5fe5        	call8	420099b4 <__sinit>
4200a3ba:	23b8      	l32i.n	a11, a3, 8
4200a3bc:	10c1e2        	addi	a14, a1, 16
4200a3bf:	30c1d2        	addi	a13, a1, 48
4200a3c2:	4f0c      	movi.n	a15, 4
4200a3c4:	02cd      	mov.n	a12, a2
4200a3c6:	03ad      	mov.n	a10, a3
4200a3c8:	11e9      	s32i.n	a14, a1, 4
4200a3ca:	01d9      	s32i.n	a13, a1, 0
4200a3cc:	21f9      	s32i.n	a15, a1, 8
4200a3ce:	201110        	or	a1, a1, a1
4200a3d1:	03dde5        	call8	4200e1b0 <_vfprintf_r>
4200a3d4:	0a2d      	mov.n	a2, a10
4200a3d6:	f01d      	retw.n

4200a3d8 <cleanup_glue>:
4200a3d8:	004136        	entry	a1, 32
4200a3db:	03b8      	l32i.n	a11, a3, 0
4200a3dd:	3b8c      	beqz.n	a11, 4200a3e4 <cleanup_glue+0xc>
4200a3df:	02ad      	mov.n	a10, a2
4200a3e1:	ffff65        	call8	4200a3d8 <cleanup_glue>
4200a3e4:	03bd      	mov.n	a11, a3
4200a3e6:	02ad      	mov.n	a10, a2
4200a3e8:	d9e681        	l32r	a8, 42000b80 <_stext+0xb60>
4200a3eb:	0008e0        	callx8	a8
4200a3ee:	f01d      	retw.n

4200a3f0 <_reclaim_reent>:
4200a3f0:	004136        	entry	a1, 32
4200a3f3:	d9d081        	l32r	a8, 42000b34 <_stext+0xb14>
4200a3f6:	0008e0        	callx8	a8
4200a3f9:	0292a7        	bne	a2, a10, 4200a3ff <_reclaim_reent+0xf>
4200a3fc:	003486        	j	4200a4d2 <_reclaim_reent+0xe2>
4200a3ff:	9238      	l32i.n	a3, a2, 36
4200a401:	d3bc      	beqz.n	a3, 4200a442 <_reclaim_reent+0x52>
4200a403:	3348      	l32i.n	a4, a3, 12
4200a405:	030c      	movi.n	a3, 0
4200a407:	1a9437        	bne	a4, a3, 4200a425 <_reclaim_reent+0x35>
4200a40a:	000986        	j	4200a434 <_reclaim_reent+0x44>
4200a40d:	bb3a      	add.n	a11, a11, a3
4200a40f:	0bb8      	l32i.n	a11, a11, 0
4200a411:	0002c6        	j	4200a420 <_reclaim_reent+0x30>
4200a414:	0b48      	l32i.n	a4, a11, 0
4200a416:	02ad      	mov.n	a10, a2
4200a418:	d9da81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a41b:	0008e0        	callx8	a8
4200a41e:	04bd      	mov.n	a11, a4
4200a420:	ff0b56        	bnez	a11, 4200a414 <_reclaim_reent+0x24>
4200a423:	334b      	addi.n	a3, a3, 4
4200a425:	9288      	l32i.n	a8, a2, 36
4200a427:	38b8      	l32i.n	a11, a8, 12
4200a429:	e0e366        	bnei	a3, 128, 4200a40d <_reclaim_reent+0x1d>
4200a42c:	02ad      	mov.n	a10, a2
4200a42e:	d9d481        	l32r	a8, 42000b80 <_stext+0xb60>
4200a431:	0008e0        	callx8	a8
4200a434:	9238      	l32i.n	a3, a2, 36
4200a436:	03b8      	l32i.n	a11, a3, 0
4200a438:	6b8c      	beqz.n	a11, 4200a442 <_reclaim_reent+0x52>
4200a43a:	02ad      	mov.n	a10, a2
4200a43c:	d9d181        	l32r	a8, 42000b80 <_stext+0xb60>
4200a43f:	0008e0        	callx8	a8
4200a442:	52b8      	l32i.n	a11, a2, 20
4200a444:	6b8c      	beqz.n	a11, 4200a44e <_reclaim_reent+0x5e>
4200a446:	02ad      	mov.n	a10, a2
4200a448:	d9ce81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a44b:	0008e0        	callx8	a8
4200a44e:	92b8      	l32i.n	a11, a2, 36
4200a450:	6b8c      	beqz.n	a11, 4200a45a <_reclaim_reent+0x6a>
4200a452:	02ad      	mov.n	a10, a2
4200a454:	d9cb81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a457:	0008e0        	callx8	a8
4200a45a:	e2b8      	l32i.n	a11, a2, 56
4200a45c:	6b8c      	beqz.n	a11, 4200a466 <_reclaim_reent+0x76>
4200a45e:	02ad      	mov.n	a10, a2
4200a460:	d9c881        	l32r	a8, 42000b80 <_stext+0xb60>
4200a463:	0008e0        	callx8	a8
4200a466:	f2b8      	l32i.n	a11, a2, 60
4200a468:	008b16        	beqz	a11, 4200a474 <_reclaim_reent+0x84>
4200a46b:	20a220        	or	a10, a2, a2
4200a46e:	d9c481        	l32r	a8, 42000b80 <_stext+0xb60>
4200a471:	0008e0        	callx8	a8
4200a474:	1022b2        	l32i	a11, a2, 64
4200a477:	6b8c      	beqz.n	a11, 4200a481 <_reclaim_reent+0x91>
4200a479:	02ad      	mov.n	a10, a2
4200a47b:	d9c181        	l32r	a8, 42000b80 <_stext+0xb60>
4200a47e:	0008e0        	callx8	a8
4200a481:	3b22b2        	l32i	a11, a2, 236
4200a484:	008b16        	beqz	a11, 4200a490 <_reclaim_reent+0xa0>
4200a487:	20a220        	or	a10, a2, a2
4200a48a:	d9bd81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a48d:	0008e0        	callx8	a8
4200a490:	3a22b2        	l32i	a11, a2, 232
4200a493:	6b8c      	beqz.n	a11, 4200a49d <_reclaim_reent+0xad>
4200a495:	02ad      	mov.n	a10, a2
4200a497:	d9ba81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a49a:	0008e0        	callx8	a8
4200a49d:	122232        	l32i	a3, a2, 72
4200a4a0:	d38c      	beqz.n	a3, 4200a4b1 <_reclaim_reent+0xc1>
4200a4a2:	2223b2        	l32i	a11, a3, 136
4200a4a5:	008b16        	beqz	a11, 4200a4b1 <_reclaim_reent+0xc1>
4200a4a8:	20a220        	or	a10, a2, a2
4200a4ab:	d9b581        	l32r	a8, 42000b80 <_stext+0xb60>
4200a4ae:	0008e0        	callx8	a8
4200a4b1:	d2b8      	l32i.n	a11, a2, 52
4200a4b3:	6b8c      	beqz.n	a11, 4200a4bd <_reclaim_reent+0xcd>
4200a4b5:	02ad      	mov.n	a10, a2
4200a4b7:	d9b281        	l32r	a8, 42000b80 <_stext+0xb60>
4200a4ba:	0008e0        	callx8	a8
4200a4bd:	6238      	l32i.n	a3, a2, 24
4200a4bf:	f38c      	beqz.n	a3, 4200a4d2 <_reclaim_reent+0xe2>
4200a4c1:	a238      	l32i.n	a3, a2, 40
4200a4c3:	02ad      	mov.n	a10, a2
4200a4c5:	0003e0        	callx8	a3
4200a4c8:	3622b2        	l32i	a11, a2, 216
4200a4cb:	3b8c      	beqz.n	a11, 4200a4d2 <_reclaim_reent+0xe2>
4200a4cd:	02ad      	mov.n	a10, a2
4200a4cf:	fff0a5        	call8	4200a3d8 <cleanup_glue>
4200a4d2:	f01d      	retw.n

4200a4d4 <lflush>:
4200a4d4:	004136        	entry	a1, 32
4200a4d7:	061282        	l16ui	a8, a2, 12
4200a4da:	990c      	movi.n	a9, 9
4200a4dc:	108890        	and	a8, a8, a9
4200a4df:	02ad      	mov.n	a10, a2
4200a4e1:	020c      	movi.n	a2, 0
4200a4e3:	079897        	bne	a8, a9, 4200a4ee <lflush+0x1a>
4200a4e6:	201110        	or	a1, a1, a1
4200a4e9:	080c65        	call8	420125b0 <fflush>
4200a4ec:	0a2d      	mov.n	a2, a10
4200a4ee:	f01d      	retw.n

4200a4f0 <__srefill_r>:
4200a4f0:	004136        	entry	a1, 32
4200a4f3:	a28c      	beqz.n	a2, 4200a501 <__srefill_r+0x11>
4200a4f5:	6248      	l32i.n	a4, a2, 24
4200a4f7:	64cc      	bnez.n	a4, 4200a501 <__srefill_r+0x11>
4200a4f9:	02ad      	mov.n	a10, a2
4200a4fb:	201110        	or	a1, a1, a1
4200a4fe:	ff4b65        	call8	420099b4 <__sinit>
4200a501:	d99b41        	l32r	a4, 42000b70 <_stext+0xb50>
4200a504:	049347        	bne	a3, a4, 4200a50c <__srefill_r+0x1c>
4200a507:	1238      	l32i.n	a3, a2, 4
4200a509:	0004c6        	j	4200a520 <__srefill_r+0x30>
4200a50c:	d99a41        	l32r	a4, 42000b74 <_stext+0xb54>
4200a50f:	059347        	bne	a3, a4, 4200a518 <__srefill_r+0x28>
4200a512:	2238      	l32i.n	a3, a2, 8
4200a514:	000206        	j	4200a520 <__srefill_r+0x30>
4200a517:	00          	.byte 00
4200a518:	d99841        	l32r	a4, 42000b78 <_stext+0xb58>
4200a51b:	019347        	bne	a3, a4, 4200a520 <__srefill_r+0x30>
4200a51e:	3238      	l32i.n	a3, a2, 12
4200a520:	061382        	l16ui	a8, a3, 12
4200a523:	040c      	movi.n	a4, 0
4200a525:	1349      	s32i.n	a4, a3, 4
4200a527:	235880        	sext	a5, a8, 15
4200a52a:	f44080        	extui	a4, a8, 0, 16
4200a52d:	036857        	bbci	a8, 5, 4200a534 <__srefill_r+0x44>
4200a530:	003806        	j	4200a614 <__srefill_r+0x124>
4200a533:	00          	.byte 00
4200a534:	42e427        	bbsi	a4, 2, 4200a57a <__srefill_r+0x8a>
4200a537:	0ee447        	bbsi	a4, 4, 4200a549 <__srefill_r+0x59>
4200a53a:	940c      	movi.n	a4, 9
4200a53c:	0249      	s32i.n	a4, a2, 0
4200a53e:	024c      	movi.n	a2, 64
4200a540:	205520        	or	a5, a5, a2
4200a543:	065352        	s16i	a5, a3, 12
4200a546:	003286        	j	4200a614 <__srefill_r+0x124>
4200a549:	1f6437        	bbci	a4, 3, 4200a56c <__srefill_r+0x7c>
4200a54c:	20b330        	or	a11, a3, a3
4200a54f:	20a220        	or	a10, a2, a2
4200a552:	201110        	or	a1, a1, a1
4200a555:	07fce5        	call8	42012524 <_fflush_r>
4200a558:	0b8a56        	bnez	a10, 4200a614 <__srefill_r+0x124>
4200a55b:	061342        	l16ui	a4, a3, 12
4200a55e:	757c      	movi.n	a5, -9
4200a560:	104450        	and	a4, a4, a5
4200a563:	065342        	s16i	a4, a3, 12
4200a566:	0263a2        	s32i	a10, a3, 8
4200a569:	0663a2        	s32i	a10, a3, 24
4200a56c:	061342        	l16ui	a4, a3, 12
4200a56f:	450c      	movi.n	a5, 4
4200a571:	204450        	or	a4, a4, a5
4200a574:	065342        	s16i	a4, a3, 12
4200a577:	0009c6        	j	4200a5a2 <__srefill_r+0xb2>
4200a57a:	d3b8      	l32i.n	a11, a3, 52
4200a57c:	2bac      	beqz.n	a11, 4200a5a2 <__srefill_r+0xb2>
4200a57e:	44c342        	addi	a4, a3, 68
4200a581:	071b47        	beq	a11, a4, 4200a58c <__srefill_r+0x9c>
4200a584:	02ad      	mov.n	a10, a2
4200a586:	d97e81        	l32r	a8, 42000b80 <_stext+0xb60>
4200a589:	0008e0        	callx8	a8
4200a58c:	102342        	l32i	a4, a3, 64
4200a58f:	080c      	movi.n	a8, 0
4200a591:	d389      	s32i.n	a8, a3, 52
4200a593:	1349      	s32i.n	a4, a3, 4
4200a595:	091487        	beq	a4, a8, 4200a5a2 <__srefill_r+0xb2>
4200a598:	f328      	l32i.n	a2, a3, 60
4200a59a:	0329      	s32i.n	a2, a3, 0
4200a59c:	082d      	mov.n	a2, a8
4200a59e:	001d06        	j	4200a616 <__srefill_r+0x126>
4200a5a1:	00          	.byte 00
4200a5a2:	4348      	l32i.n	a4, a3, 16
4200a5a4:	94cc      	bnez.n	a4, 4200a5b1 <__srefill_r+0xc1>
4200a5a6:	03bd      	mov.n	a11, a3
4200a5a8:	20a220        	or	a10, a2, a2
4200a5ab:	201110        	or	a1, a1, a1
4200a5ae:	ffd265        	call8	4200a2d4 <__smakebuf_r>
4200a5b1:	061352        	l16ui	a5, a3, 12
4200a5b4:	148050        	extui	a8, a5, 0, 2
4200a5b7:	f44050        	extui	a4, a5, 0, 16
4200a5ba:	a8ac      	beqz.n	a8, 4200a5e8 <__srefill_r+0xf8>
4200a5bc:	180c      	movi.n	a8, 1
4200a5be:	065382        	s16i	a8, a3, 12
4200a5c1:	d6da81        	l32r	a8, 4200012c <_stext+0x10c>
4200a5c4:	d975b1        	l32r	a11, 42000b98 <_stext+0xb78>
4200a5c7:	0028a2        	l32i	a10, a8, 0
4200a5ca:	201110        	or	a1, a1, a1
4200a5cd:	0dc065        	call8	420181d4 <_fwalk>
4200a5d0:	065352        	s16i	a5, a3, 12
4200a5d3:	950c      	movi.n	a5, 9
4200a5d5:	104450        	and	a4, a4, a5
4200a5d8:	950c      	movi.n	a5, 9
4200a5da:	0a9457        	bne	a4, a5, 4200a5e8 <__srefill_r+0xf8>
4200a5dd:	03bd      	mov.n	a11, a3
4200a5df:	20a220        	or	a10, a2, a2
4200a5e2:	201110        	or	a1, a1, a1
4200a5e5:	07dea5        	call8	420123d0 <__sflush_r>
4200a5e8:	43c8      	l32i.n	a12, a3, 16
4200a5ea:	9348      	l32i.n	a4, a3, 36
4200a5ec:	53d8      	l32i.n	a13, a3, 20
4200a5ee:	83b8      	l32i.n	a11, a3, 32
4200a5f0:	02ad      	mov.n	a10, a2
4200a5f2:	0063c2        	s32i	a12, a3, 0
4200a5f5:	0004e0        	callx8	a4
4200a5f8:	13a9      	s32i.n	a10, a3, 4
4200a5fa:	020c      	movi.n	a2, 0
4200a5fc:	161ae6        	bgei	a10, 1, 4200a616 <__srefill_r+0x126>
4200a5ff:	069382        	l16si	a8, a3, 12
4200a602:	049a27        	bne	a10, a2, 4200a60a <__srefill_r+0x11a>
4200a605:	022c      	movi.n	a2, 32
4200a607:	0000c6        	j	4200a60e <__srefill_r+0x11e>
4200a60a:	1329      	s32i.n	a2, a3, 4
4200a60c:	024c      	movi.n	a2, 64
4200a60e:	208820        	or	a8, a8, a2
4200a611:	065382        	s16i	a8, a3, 12
4200a614:	f27c      	movi.n	a2, -1
4200a616:	f01d      	retw.n

4200a618 <_snprintf_r>:
4200a618:	018136        	entry	a1, 192
4200a61b:	246162        	s32i	a6, a1, 144
4200a61e:	256172        	s32i	a7, a1, 148
4200a621:	05cd      	mov.n	a12, a5
4200a623:	0094d6        	bgez	a4, 4200a630 <_snprintf_r+0x18>
4200a626:	8ba032        	movi	a3, 139
4200a629:	0239      	s32i.n	a3, a2, 0
4200a62b:	fa7c      	movi.n	a10, -1
4200a62d:	001246        	j	4200a67a <_snprintf_r+0x62>
4200a630:	08a282        	movi	a8, 0x208
4200a633:	065182        	s16i	a8, a1, 12
4200a636:	0139      	s32i.n	a3, a1, 0
4200a638:	4139      	s32i.n	a3, a1, 16
4200a63a:	080c      	movi.n	a8, 0
4200a63c:	011487        	beq	a4, a8, 4200a641 <_snprintf_r+0x29>
4200a63f:	840b      	addi.n	a8, a4, -1
4200a641:	f37c      	movi.n	a3, -1
4200a643:	075132        	s16i	a3, a1, 14
4200a646:	80a0e2        	movi	a14, 128
4200a649:	a0a032        	movi	a3, 160
4200a64c:	e1ea      	add.n	a14, a1, a14
4200a64e:	d13a      	add.n	a13, a1, a3
4200a650:	0f1c      	movi.n	a15, 16
4200a652:	01bd      	mov.n	a11, a1
4200a654:	02ad      	mov.n	a10, a2
4200a656:	2189      	s32i.n	a8, a1, 8
4200a658:	5189      	s32i.n	a8, a1, 20
4200a65a:	1b61e2        	s32i	a14, a1, 108
4200a65d:	1a61d2        	s32i	a13, a1, 104
4200a660:	1c61f2        	s32i	a15, a1, 112
4200a663:	201110        	or	a1, a1, a1
4200a666:	006465        	call8	4200acac <_svfprintf_r>
4200a669:	040ae6        	bgei	a10, -1, 4200a671 <_snprintf_r+0x59>
4200a66c:	8ba032        	movi	a3, 139
4200a66f:	0239      	s32i.n	a3, a2, 0
4200a671:	548c      	beqz.n	a4, 4200a67a <_snprintf_r+0x62>
4200a673:	0128      	l32i.n	a2, a1, 0
4200a675:	030c      	movi.n	a3, 0
4200a677:	004232        	s8i	a3, a2, 0
4200a67a:	0a2d      	mov.n	a2, a10
4200a67c:	f01d      	retw.n
	...

4200a680 <snprintf>:
4200a680:	018136        	entry	a1, 192
4200a683:	236152        	s32i	a5, a1, 140
4200a686:	246162        	s32i	a6, a1, 144
4200a689:	256172        	s32i	a7, a1, 148
4200a68c:	d92a81        	l32r	a8, 42000b34 <_stext+0xb14>
4200a68f:	0008e0        	callx8	a8
4200a692:	0a5d      	mov.n	a5, a10
4200a694:	0093d6        	bgez	a3, 4200a6a1 <snprintf+0x21>
4200a697:	8ba022        	movi	a2, 139
4200a69a:	0a29      	s32i.n	a2, a10, 0
4200a69c:	fa7c      	movi.n	a10, -1
4200a69e:	0012c6        	j	4200a6ed <snprintf+0x6d>
4200a6a1:	08a282        	movi	a8, 0x208
4200a6a4:	065182        	s16i	a8, a1, 12
4200a6a7:	0129      	s32i.n	a2, a1, 0
4200a6a9:	4129      	s32i.n	a2, a1, 16
4200a6ab:	080c      	movi.n	a8, 0
4200a6ad:	011387        	beq	a3, a8, 4200a6b2 <snprintf+0x32>
4200a6b0:	830b      	addi.n	a8, a3, -1
4200a6b2:	f27c      	movi.n	a2, -1
4200a6b4:	075122        	s16i	a2, a1, 14
4200a6b7:	80a0e2        	movi	a14, 128
4200a6ba:	a0a022        	movi	a2, 160
4200a6bd:	e1ea      	add.n	a14, a1, a14
4200a6bf:	d12a      	add.n	a13, a1, a2
4200a6c1:	cf0c      	movi.n	a15, 12
4200a6c3:	04cd      	mov.n	a12, a4
4200a6c5:	01bd      	mov.n	a11, a1
4200a6c7:	05ad      	mov.n	a10, a5
4200a6c9:	2189      	s32i.n	a8, a1, 8
4200a6cb:	5189      	s32i.n	a8, a1, 20
4200a6cd:	1b61e2        	s32i	a14, a1, 108
4200a6d0:	1a61d2        	s32i	a13, a1, 104
4200a6d3:	1c61f2        	s32i	a15, a1, 112
4200a6d6:	201110        	or	a1, a1, a1
4200a6d9:	005d25        	call8	4200acac <_svfprintf_r>
4200a6dc:	040ae6        	bgei	a10, -1, 4200a6e4 <snprintf+0x64>
4200a6df:	8ba022        	movi	a2, 139
4200a6e2:	0529      	s32i.n	a2, a5, 0
4200a6e4:	538c      	beqz.n	a3, 4200a6ed <snprintf+0x6d>
4200a6e6:	0128      	l32i.n	a2, a1, 0
4200a6e8:	030c      	movi.n	a3, 0
4200a6ea:	004232        	s8i	a3, a2, 0
4200a6ed:	0a2d      	mov.n	a2, a10
4200a6ef:	f01d      	retw.n
4200a6f1:	000000        	ill

4200a6f4 <__sread>:
4200a6f4:	004136        	entry	a1, 32
4200a6f7:	0793b2        	l16si	a11, a3, 14
4200a6fa:	05dd      	mov.n	a13, a5
4200a6fc:	20c440        	or	a12, a4, a4
4200a6ff:	20a220        	or	a10, a2, a2
4200a702:	201110        	or	a1, a1, a1
4200a705:	fa62a5        	call8	42004d30 <_read_r>
4200a708:	00ca96        	bltz	a10, 4200a718 <__sread+0x24>
4200a70b:	152382        	l32i	a8, a3, 84
4200a70e:	88aa      	add.n	a8, a8, a10
4200a710:	156382        	s32i	a8, a3, 84
4200a713:	000346        	j	4200a724 <__sread+0x30>
4200a716:	00          	.byte 00
4200a717:	00          	.byte 00
4200a718:	061382        	l16ui	a8, a3, 12
4200a71b:	d86991        	l32r	a9, 420008c0 <_stext+0x8a0>
4200a71e:	108890        	and	a8, a8, a9
4200a721:	065382        	s16i	a8, a3, 12
4200a724:	0a2d      	mov.n	a2, a10
4200a726:	f01d      	retw.n

4200a728 <__seofread>:
4200a728:	004136        	entry	a1, 32
4200a72b:	020c      	movi.n	a2, 0
4200a72d:	f01d      	retw.n
	...

4200a730 <__swrite>:
4200a730:	004136        	entry	a1, 32
4200a733:	061382        	l16ui	a8, a3, 12
4200a736:	0f6887        	bbci	a8, 8, 4200a749 <__swrite+0x19>
4200a739:	0793b2        	l16si	a11, a3, 14
4200a73c:	2d0c      	movi.n	a13, 2
4200a73e:	0c0c      	movi.n	a12, 0
4200a740:	20a220        	or	a10, a2, a2
4200a743:	201110        	or	a1, a1, a1
4200a746:	fa59e5        	call8	42004ce4 <_lseek_r>
4200a749:	061382        	l16ui	a8, a3, 12
4200a74c:	d85d91        	l32r	a9, 420008c0 <_stext+0x8a0>
4200a74f:	0793b2        	l16si	a11, a3, 14
4200a752:	108890        	and	a8, a8, a9
4200a755:	065382        	s16i	a8, a3, 12
4200a758:	05dd      	mov.n	a13, a5
4200a75a:	04cd      	mov.n	a12, a4
4200a75c:	02ad      	mov.n	a10, a2
4200a75e:	201110        	or	a1, a1, a1
4200a761:	fa5365        	call8	42004c98 <_write_r>
4200a764:	0a2d      	mov.n	a2, a10
4200a766:	f01d      	retw.n

4200a768 <__sseek>:
4200a768:	004136        	entry	a1, 32
4200a76b:	0793b2        	l16si	a11, a3, 14
4200a76e:	05dd      	mov.n	a13, a5
4200a770:	20c440        	or	a12, a4, a4
4200a773:	20a220        	or	a10, a2, a2
4200a776:	201110        	or	a1, a1, a1
4200a779:	fa56a5        	call8	42004ce4 <_lseek_r>
4200a77c:	061392        	l16ui	a9, a3, 12
4200a77f:	0b0a66        	bnei	a10, -1, 4200a78e <__sseek+0x26>
4200a782:	d84f81        	l32r	a8, 420008c0 <_stext+0x8a0>
4200a785:	108890        	and	a8, a8, a9
4200a788:	065382        	s16i	a8, a3, 12
4200a78b:	000346        	j	4200a79c <__sseek+0x34>
4200a78e:	180c      	movi.n	a8, 1
4200a790:	118840        	slli	a8, a8, 12
4200a793:	208890        	or	a8, a8, a9
4200a796:	065382        	s16i	a8, a3, 12
4200a799:	1563a2        	s32i	a10, a3, 84
4200a79c:	0a2d      	mov.n	a2, a10
4200a79e:	f01d      	retw.n

4200a7a0 <__sclose>:
4200a7a0:	004136        	entry	a1, 32
4200a7a3:	0793b2        	l16si	a11, a3, 14
4200a7a6:	02ad      	mov.n	a10, a2
4200a7a8:	201110        	or	a1, a1, a1
4200a7ab:	fa5d25        	call8	42004d7c <_close_r>
4200a7ae:	0a2d      	mov.n	a2, a10
4200a7b0:	f01d      	retw.n
	...

4200a7b4 <get_arg$constprop$0>:
4200a7b4:	008136        	entry	a1, 64
4200a7b7:	102182        	l32i	a8, a1, 64
4200a7ba:	2129      	s32i.n	a2, a1, 8
4200a7bc:	2198      	l32i.n	a9, a1, 8
4200a7be:	0528      	l32i.n	a2, a5, 0
4200a7c0:	3159      	s32i.n	a5, a1, 12
4200a7c2:	0858      	l32i.n	a5, a8, 0
4200a7c4:	933550        	movnez	a3, a5, a5
4200a7c7:	0199      	s32i.n	a9, a1, 0
4200a7c9:	00ea46        	j	4200ab76 <get_arg$constprop$0+0x3c2>
4200a7cc:	00          	.byte 00
4200a7cd:	00          	.byte 00
4200a7ce:	331b      	addi.n	a3, a3, 1
4200a7d0:	000352        	l8ui	a5, a3, 0
4200a7d3:	180c      	movi.n	a8, 1
4200a7d5:	838950        	moveqz	a8, a9, a5
4200a7d8:	748080        	extui	a8, a8, 0, 8
4200a7db:	d88c      	beqz.n	a8, 4200a7ec <get_arg$constprop$0+0x38>
4200a7dd:	dbc5a2        	addi	a10, a5, -37
4200a7e0:	01a082        	movi	a8, 1
4200a7e3:	8389a0        	moveqz	a8, a9, a10
4200a7e6:	748080        	extui	a8, a8, 0, 8
4200a7e9:	fe1856        	bnez	a8, 4200a7ce <get_arg$constprop$0+0x1a>
4200a7ec:	43c516        	beqz	a5, 4200ac2c <get_arg$constprop$0+0x478>
4200a7ef:	050c      	movi.n	a5, 0
4200a7f1:	a31b      	addi.n	a10, a3, 1
4200a7f3:	05ed      	mov.n	a14, a5
4200a7f5:	f97c      	movi.n	a9, -1
4200a7f7:	05dd      	mov.n	a13, a5
4200a7f9:	1159      	s32i.n	a5, a1, 4
4200a7fb:	000046        	j	4200a800 <get_arg$constprop$0+0x4c>
4200a7fe:	03ad      	mov.n	a10, a3
4200a800:	d8e7c1        	l32r	a12, 42000b9c <_stext+0xb7c>
4200a803:	000a82        	l8ui	a8, a10, 0
4200a806:	3a1b      	addi.n	a3, a10, 1
4200a808:	bc8a      	add.n	a11, a12, a8
4200a80a:	000bc2        	l8ui	a12, a11, 0
4200a80d:	11b8      	l32i.n	a11, a1, 4
4200a80f:	b0fbb0        	addx8	a15, a11, a11
4200a812:	d8e3b1        	l32r	a11, 42000ba0 <_stext+0xb80>
4200a815:	bbfa      	add.n	a11, a11, a15
4200a817:	bbca      	add.n	a11, a11, a12
4200a819:	000bb2        	l8ui	a11, a11, 0
4200a81c:	11b9      	s32i.n	a11, a1, 4
4200a81e:	d8e1b1        	l32r	a11, 42000ba4 <_stext+0xb84>
4200a821:	bbfa      	add.n	a11, a11, a15
4200a823:	bbca      	add.n	a11, a11, a12
4200a825:	000bb2        	l8ui	a11, a11, 0
4200a828:	bb0b      	addi.n	a11, a11, -1
4200a82a:	74b0b0        	extui	a11, a11, 0, 8
4200a82d:	028bb6        	bltui	a11, 8, 4200a833 <get_arg$constprop$0+0x7f>
4200a830:	00ce06        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a833:	d8ddc1        	l32r	a12, 42000ba8 <_stext+0xb88>
4200a836:	a0bbc0        	addx4	a11, a11, a12
4200a839:	0bb8      	l32i.n	a11, a11, 0
4200a83b:	000ba0        	jx	a11
4200a83e:	00          	.byte 00
4200a83f:	9a0c      	movi.n	a10, 9
4200a841:	00c586        	j	4200ab5b <get_arg$constprop$0+0x3a7>
4200a844:	6aa0b2        	movi	a11, 106
4200a847:	3318b7        	beq	a8, a11, 4200a87e <get_arg$constprop$0+0xca>
4200a84a:	0a3b87        	bltu	a11, a8, 4200a858 <get_arg$constprop$0+0xa4>
4200a84d:	cb4c      	movi.n	a11, 76
4200a84f:	2618b7        	beq	a8, a11, 4200a879 <get_arg$constprop$0+0xc5>
4200a852:	68a0b2        	movi	a11, 104
4200a855:	0005c6        	j	4200a870 <get_arg$constprop$0+0xbc>
4200a858:	71a0b2        	movi	a11, 113
4200a85b:	1f18b7        	beq	a8, a11, 4200a87e <get_arg$constprop$0+0xca>
4200a85e:	70a0b2        	movi	a11, 112
4200a861:	1fbb87        	bgeu	a11, a8, 4200a884 <get_arg$constprop$0+0xd0>
4200a864:	74a0b2        	movi	a11, 116
4200a867:	0298b7        	bne	a8, a11, 4200a86d <get_arg$constprop$0+0xb9>
4200a86a:	00bf86        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a86d:	7aa0b2        	movi	a11, 122
4200a870:	0298b7        	bne	a8, a11, 4200a876 <get_arg$constprop$0+0xc2>
4200a873:	00bd46        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a876:	000286        	j	4200a884 <get_arg$constprop$0+0xd0>
4200a879:	880c      	movi.n	a8, 8
4200a87b:	0006c6        	j	4200a89a <get_arg$constprop$0+0xe6>
4200a87e:	082c      	movi.n	a8, 32
4200a880:	000586        	j	4200a89a <get_arg$constprop$0+0xe6>
4200a883:	00          	.byte 00
4200a884:	010ab2        	l8ui	a11, a10, 1
4200a887:	6ca082        	movi	a8, 108
4200a88a:	0a9b87        	bne	a11, a8, 4200a898 <get_arg$constprop$0+0xe4>
4200a88d:	032c      	movi.n	a3, 32
4200a88f:	20dd30        	or	a13, a13, a3
4200a892:	3a2b      	addi.n	a3, a10, 2
4200a894:	00b506        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a897:	00          	.byte 00
4200a898:	081c      	movi.n	a8, 16
4200a89a:	20dd80        	or	a13, a13, a8
4200a89d:	00b2c6        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a8a0:	61a0a2        	movi	a10, 97
4200a8a3:	442020        	extui	a2, a2, 0, 5
4200a8a6:	0298a7        	bne	a8, a10, 4200a8ac <get_arg$constprop$0+0xf8>
4200a8a9:	00f806        	j	4200ac8d <get_arg$constprop$0+0x4d9>
4200a8ac:	3c3a87        	bltu	a10, a8, 4200a8ec <get_arg$constprop$0+0x138>
4200a8af:	bfc882        	addi	a8, a8, -65
4200a8b2:	748080        	extui	a8, a8, 0, 8
4200a8b5:	7a1c      	movi.n	a10, 23
4200a8b7:	25ba87        	bgeu	a10, a8, 4200a8e0 <get_arg$constprop$0+0x12c>
4200a8ba:	0016c6        	j	4200a919 <get_arg$constprop$0+0x165>
4200a8bd:	1c0c      	movi.n	a12, 1
4200a8bf:	d8bba1        	l32r	a10, 42000bac <_stext+0xb8c>
4200a8c2:	401800        	ssl	a8
4200a8c5:	a18c00        	sll	a8, a12
4200a8c8:	3488a7        	bany	a8, a10, 4200a900 <get_arg$constprop$0+0x14c>
4200a8cb:	5a2c      	movi.n	a10, 37
4200a8cd:	11aa60        	slli	a10, a10, 10
4200a8d0:	0208a7        	bnone	a8, a10, 4200a8d6 <get_arg$constprop$0+0x122>
4200a8d3:	00eac6        	j	4200ac82 <get_arg$constprop$0+0x4ce>
4200a8d6:	ea0c      	movi.n	a10, 14
4200a8d8:	3d08a7        	bnone	a8, a10, 4200a919 <get_arg$constprop$0+0x165>
4200a8db:	00eb86        	j	4200ac8d <get_arg$constprop$0+0x4d9>
4200a8de:	00          	.byte 00
4200a8df:	00          	.byte 00
4200a8e0:	d8b4a1        	l32r	a10, 42000bb0 <_stext+0xb90>
4200a8e3:	a088a0        	addx4	a8, a8, a10
4200a8e6:	0888      	l32i.n	a8, a8, 0
4200a8e8:	0008a0        	jx	a8
4200a8eb:	00          	.byte 00
4200a8ec:	63a0a2        	movi	a10, 99
4200a8ef:	1d18a7        	beq	a8, a10, 4200a910 <get_arg$constprop$0+0x15c>
4200a8f2:	9cc882        	addi	a8, a8, -100
4200a8f5:	748080        	extui	a8, a8, 0, 8
4200a8f8:	4a1c      	movi.n	a10, 20
4200a8fa:	bfba87        	bgeu	a10, a8, 4200a8bd <get_arg$constprop$0+0x109>
4200a8fd:	000606        	j	4200a919 <get_arg$constprop$0+0x165>
4200a900:	026d47        	bbci	a13, 4, 4200a906 <get_arg$constprop$0+0x152>
4200a903:	00d346        	j	4200ac54 <get_arg$constprop$0+0x4a0>
4200a906:	026d57        	bbci	a13, 5, 4200a90c <get_arg$constprop$0+0x158>
4200a909:	00d4c6        	j	4200ac60 <get_arg$constprop$0+0x4ac>
4200a90c:	00d9c6        	j	4200ac77 <get_arg$constprop$0+0x4c3>
4200a90f:	00          	.byte 00
4200a910:	026d47        	bbci	a13, 4, 4200a916 <get_arg$constprop$0+0x162>
4200a913:	00d546        	j	4200ac6c <get_arg$constprop$0+0x4b8>
4200a916:	00d746        	j	4200ac77 <get_arg$constprop$0+0x4c3>
4200a919:	070926        	beqi	a9, -1, 4200a924 <get_arg$constprop$0+0x170>
4200a91c:	a08970        	addx4	a8, a9, a7
4200a91f:	0859      	s32i.n	a5, a8, 0
4200a921:	0091c6        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a924:	850b      	addi.n	a8, a5, -1
4200a926:	0268b6        	bltui	a8, 6, 4200a92c <get_arg$constprop$0+0x178>
4200a929:	002b06        	j	4200a9d9 <get_arg$constprop$0+0x225>
4200a92c:	d8a2a1        	l32r	a10, 42000bb4 <_stext+0xb94>
4200a92f:	a088a0        	addx4	a8, a8, a10
4200a932:	0888      	l32i.n	a8, a8, 0
4200a934:	0008a0        	jx	a8
4200a937:	2488      	l32i.n	a8, a4, 8
4200a939:	891c      	movi.n	a9, 24
4200a93b:	584b      	addi.n	a5, a8, 4
4200a93d:	2459      	s32i.n	a5, a4, 8
4200a93f:	a21b      	addi.n	a10, a2, 1
4200a941:	b02260        	addx8	a2, a2, a6
4200a944:	042957        	blt	a9, a5, 4200a94c <get_arg$constprop$0+0x198>
4200a947:	1458      	l32i.n	a5, a4, 4
4200a949:	000206        	j	4200a955 <get_arg$constprop$0+0x1a1>
4200a94c:	012987        	blt	a9, a8, 4200a951 <get_arg$constprop$0+0x19d>
4200a94f:	452c      	movi.n	a5, 36
4200a951:	2459      	s32i.n	a5, a4, 8
4200a953:	0458      	l32i.n	a5, a4, 0
4200a955:	2488      	l32i.n	a8, a4, 8
4200a957:	f97c      	movi.n	a9, -1
4200a959:	558a      	add.n	a5, a5, a8
4200a95b:	fcc552        	addi	a5, a5, -4
4200a95e:	0558      	l32i.n	a5, a5, 0
4200a960:	0259      	s32i.n	a5, a2, 0
4200a962:	0a2d      	mov.n	a2, a10
4200a964:	150c      	movi.n	a5, 1
4200a966:	008086        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a969:	2458      	l32i.n	a5, a4, 8
4200a96b:	887c      	movi.n	a8, -8
4200a96d:	557b      	addi.n	a5, a5, 7
4200a96f:	105580        	and	a5, a5, a8
4200a972:	858b      	addi.n	a8, a5, 8
4200a974:	2489      	s32i.n	a8, a4, 8
4200a976:	891c      	movi.n	a9, 24
4200a978:	a21b      	addi.n	a10, a2, 1
4200a97a:	b02260        	addx8	a2, a2, a6
4200a97d:	042987        	blt	a9, a8, 4200a985 <get_arg$constprop$0+0x1d1>
4200a980:	1458      	l32i.n	a5, a4, 4
4200a982:	000206        	j	4200a98e <get_arg$constprop$0+0x1da>
4200a985:	012957        	blt	a9, a5, 4200a98a <get_arg$constprop$0+0x1d6>
4200a988:	882c      	movi.n	a8, 40
4200a98a:	0458      	l32i.n	a5, a4, 0
4200a98c:	2489      	s32i.n	a8, a4, 8
4200a98e:	2488      	l32i.n	a8, a4, 8
4200a990:	558a      	add.n	a5, a5, a8
4200a992:	f8c552        	addi	a5, a5, -8
4200a995:	1598      	l32i.n	a9, a5, 4
4200a997:	0588      	l32i.n	a8, a5, 0
4200a999:	1299      	s32i.n	a9, a2, 4
4200a99b:	0289      	s32i.n	a8, a2, 0
4200a99d:	f97c      	movi.n	a9, -1
4200a99f:	0a2d      	mov.n	a2, a10
4200a9a1:	250c      	movi.n	a5, 2
4200a9a3:	007146        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a9a6:	2488      	l32i.n	a8, a4, 8
4200a9a8:	891c      	movi.n	a9, 24
4200a9aa:	584b      	addi.n	a5, a8, 4
4200a9ac:	2459      	s32i.n	a5, a4, 8
4200a9ae:	a21b      	addi.n	a10, a2, 1
4200a9b0:	b02260        	addx8	a2, a2, a6
4200a9b3:	052957        	blt	a9, a5, 4200a9bc <get_arg$constprop$0+0x208>
4200a9b6:	1458      	l32i.n	a5, a4, 4
4200a9b8:	000246        	j	4200a9c5 <get_arg$constprop$0+0x211>
4200a9bb:	00          	.byte 00
4200a9bc:	012987        	blt	a9, a8, 4200a9c1 <get_arg$constprop$0+0x20d>
4200a9bf:	452c      	movi.n	a5, 36
4200a9c1:	2459      	s32i.n	a5, a4, 8
4200a9c3:	0458      	l32i.n	a5, a4, 0
4200a9c5:	2488      	l32i.n	a8, a4, 8
4200a9c7:	f97c      	movi.n	a9, -1
4200a9c9:	558a      	add.n	a5, a5, a8
4200a9cb:	fcc552        	addi	a5, a5, -4
4200a9ce:	0558      	l32i.n	a5, a5, 0
4200a9d0:	0259      	s32i.n	a5, a2, 0
4200a9d2:	0a2d      	mov.n	a2, a10
4200a9d4:	650c      	movi.n	a5, 6
4200a9d6:	006486        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200a9d9:	2488      	l32i.n	a8, a4, 8
4200a9db:	891c      	movi.n	a9, 24
4200a9dd:	584b      	addi.n	a5, a8, 4
4200a9df:	2459      	s32i.n	a5, a4, 8
4200a9e1:	a21b      	addi.n	a10, a2, 1
4200a9e3:	b02260        	addx8	a2, a2, a6
4200a9e6:	062957        	blt	a9, a5, 4200a9f0 <get_arg$constprop$0+0x23c>
4200a9e9:	1458      	l32i.n	a5, a4, 4
4200a9eb:	000286        	j	4200a9f9 <get_arg$constprop$0+0x245>
4200a9ee:	00          	.byte 00
4200a9ef:	00          	.byte 00
4200a9f0:	012987        	blt	a9, a8, 4200a9f5 <get_arg$constprop$0+0x241>
4200a9f3:	452c      	movi.n	a5, 36
4200a9f5:	2459      	s32i.n	a5, a4, 8
4200a9f7:	0458      	l32i.n	a5, a4, 0
4200a9f9:	2488      	l32i.n	a8, a4, 8
4200a9fb:	f97c      	movi.n	a9, -1
4200a9fd:	558a      	add.n	a5, a5, a8
4200a9ff:	fcc552        	addi	a5, a5, -4
4200aa02:	0558      	l32i.n	a5, a5, 0
4200aa04:	0259      	s32i.n	a5, a2, 0
4200aa06:	0a2d      	mov.n	a2, a10
4200aa08:	050c      	movi.n	a5, 0
4200aa0a:	005786        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200aa0d:	2488      	l32i.n	a8, a4, 8
4200aa0f:	891c      	movi.n	a9, 24
4200aa11:	584b      	addi.n	a5, a8, 4
4200aa13:	2459      	s32i.n	a5, a4, 8
4200aa15:	a21b      	addi.n	a10, a2, 1
4200aa17:	b02260        	addx8	a2, a2, a6
4200aa1a:	062957        	blt	a9, a5, 4200aa24 <get_arg$constprop$0+0x270>
4200aa1d:	1458      	l32i.n	a5, a4, 4
4200aa1f:	000286        	j	4200aa2d <get_arg$constprop$0+0x279>
4200aa22:	00          	.byte 00
4200aa23:	00          	.byte 00
4200aa24:	012987        	blt	a9, a8, 4200aa29 <get_arg$constprop$0+0x275>
4200aa27:	452c      	movi.n	a5, 36
4200aa29:	2459      	s32i.n	a5, a4, 8
4200aa2b:	0458      	l32i.n	a5, a4, 0
4200aa2d:	2488      	l32i.n	a8, a4, 8
4200aa2f:	f97c      	movi.n	a9, -1
4200aa31:	558a      	add.n	a5, a5, a8
4200aa33:	fcc552        	addi	a5, a5, -4
4200aa36:	0558      	l32i.n	a5, a5, 0
4200aa38:	0259      	s32i.n	a5, a2, 0
4200aa3a:	0a2d      	mov.n	a2, a10
4200aa3c:	350c      	movi.n	a5, 3
4200aa3e:	004a86        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200aa41:	2458      	l32i.n	a5, a4, 8
4200aa43:	887c      	movi.n	a8, -8
4200aa45:	557b      	addi.n	a5, a5, 7
4200aa47:	105580        	and	a5, a5, a8
4200aa4a:	858b      	addi.n	a8, a5, 8
4200aa4c:	2489      	s32i.n	a8, a4, 8
4200aa4e:	891c      	movi.n	a9, 24
4200aa50:	a21b      	addi.n	a10, a2, 1
4200aa52:	b02260        	addx8	a2, a2, a6
4200aa55:	042987        	blt	a9, a8, 4200aa5d <get_arg$constprop$0+0x2a9>
4200aa58:	1458      	l32i.n	a5, a4, 4
4200aa5a:	000206        	j	4200aa66 <get_arg$constprop$0+0x2b2>
4200aa5d:	012957        	blt	a9, a5, 4200aa62 <get_arg$constprop$0+0x2ae>
4200aa60:	882c      	movi.n	a8, 40
4200aa62:	0458      	l32i.n	a5, a4, 0
4200aa64:	2489      	s32i.n	a8, a4, 8
4200aa66:	2488      	l32i.n	a8, a4, 8
4200aa68:	558a      	add.n	a5, a5, a8
4200aa6a:	f8c552        	addi	a5, a5, -8
4200aa6d:	1598      	l32i.n	a9, a5, 4
4200aa6f:	0588      	l32i.n	a8, a5, 0
4200aa71:	1299      	s32i.n	a9, a2, 4
4200aa73:	0289      	s32i.n	a8, a2, 0
4200aa75:	f97c      	movi.n	a9, -1
4200aa77:	0a2d      	mov.n	a2, a10
4200aa79:	450c      	movi.n	a5, 4
4200aa7b:	003b46        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200aa7e:	2488      	l32i.n	a8, a4, 8
4200aa80:	8a7c      	movi.n	a10, -8
4200aa82:	887b      	addi.n	a8, a8, 7
4200aa84:	1088a0        	and	a8, a8, a10
4200aa87:	a88b      	addi.n	a10, a8, 8
4200aa89:	24a9      	s32i.n	a10, a4, 8
4200aa8b:	8b1c      	movi.n	a11, 24
4200aa8d:	b0c260        	addx8	a12, a2, a6
4200aa90:	052ba7        	blt	a11, a10, 4200aa99 <get_arg$constprop$0+0x2e5>
4200aa93:	1488      	l32i.n	a8, a4, 4
4200aa95:	000246        	j	4200aaa2 <get_arg$constprop$0+0x2ee>
4200aa98:	00          	.byte 00
4200aa99:	012b87        	blt	a11, a8, 4200aa9e <get_arg$constprop$0+0x2ea>
4200aa9c:	8a2c      	movi.n	a10, 40
4200aa9e:	0488      	l32i.n	a8, a4, 0
4200aaa0:	24a9      	s32i.n	a10, a4, 8
4200aaa2:	24a8      	l32i.n	a10, a4, 8
4200aaa4:	221b      	addi.n	a2, a2, 1
4200aaa6:	88aa      	add.n	a8, a8, a10
4200aaa8:	f8c882        	addi	a8, a8, -8
4200aaab:	08a8      	l32i.n	a10, a8, 0
4200aaad:	18b8      	l32i.n	a11, a8, 4
4200aaaf:	0ca9      	s32i.n	a10, a12, 0
4200aab1:	1cb9      	s32i.n	a11, a12, 4
4200aab3:	002d46        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200aab6:	0788      	l32i.n	a8, a7, 0
4200aab8:	140866        	bnei	a8, -1, 4200aad0 <get_arg$constprop$0+0x31c>
4200aabb:	80a0c2        	movi	a12, 128
4200aabe:	0b0c      	movi.n	a11, 0
4200aac0:	07ad      	mov.n	a10, a7
4200aac2:	51d9      	s32i.n	a13, a1, 20
4200aac4:	61e9      	s32i.n	a14, a1, 24
4200aac6:	d5b481        	l32r	a8, 42000198 <_stext+0x178>
4200aac9:	0008e0        	callx8	a8
4200aacc:	61e8      	l32i.n	a14, a1, 24
4200aace:	51d8      	l32i.n	a13, a1, 20
4200aad0:	0188      	l32i.n	a8, a1, 0
4200aad2:	9e0b      	addi.n	a9, a14, -1
4200aad4:	538890        	max	a8, a8, a9
4200aad7:	000ac6        	j	4200ab06 <get_arg$constprop$0+0x352>
4200aada:	0788      	l32i.n	a8, a7, 0
4200aadc:	180866        	bnei	a8, -1, 4200aaf8 <get_arg$constprop$0+0x344>
4200aadf:	80a0c2        	movi	a12, 128
4200aae2:	0b0c      	movi.n	a11, 0
4200aae4:	07ad      	mov.n	a10, a7
4200aae6:	4199      	s32i.n	a9, a1, 16
4200aae8:	51d9      	s32i.n	a13, a1, 20
4200aaea:	61e9      	s32i.n	a14, a1, 24
4200aaec:	d5ab81        	l32r	a8, 42000198 <_stext+0x178>
4200aaef:	0008e0        	callx8	a8
4200aaf2:	61e8      	l32i.n	a14, a1, 24
4200aaf4:	51d8      	l32i.n	a13, a1, 20
4200aaf6:	4198      	l32i.n	a9, a1, 16
4200aaf8:	ee0b      	addi.n	a14, a14, -1
4200aafa:	a08e70        	addx4	a8, a14, a7
4200aafd:	0a0c      	movi.n	a10, 0
4200aaff:	08a9      	s32i.n	a10, a8, 0
4200ab01:	0188      	l32i.n	a8, a1, 0
4200ab03:	5388e0        	max	a8, a8, a14
4200ab06:	0189      	s32i.n	a8, a1, 0
4200ab08:	001806        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200ab0b:	0a3d      	mov.n	a3, a10
4200ab0d:	24a8      	l32i.n	a10, a4, 8
4200ab0f:	8b1c      	movi.n	a11, 24
4200ab11:	8a4b      	addi.n	a8, a10, 4
4200ab13:	2489      	s32i.n	a8, a4, 8
4200ab15:	c21b      	addi.n	a12, a2, 1
4200ab17:	b02260        	addx8	a2, a2, a6
4200ab1a:	062b87        	blt	a11, a8, 4200ab24 <get_arg$constprop$0+0x370>
4200ab1d:	1488      	l32i.n	a8, a4, 4
4200ab1f:	000286        	j	4200ab2d <get_arg$constprop$0+0x379>
4200ab22:	00          	.byte 00
4200ab23:	00          	.byte 00
4200ab24:	012ba7        	blt	a11, a10, 4200ab29 <get_arg$constprop$0+0x375>
4200ab27:	482c      	movi.n	a8, 36
4200ab29:	2489      	s32i.n	a8, a4, 8
4200ab2b:	0488      	l32i.n	a8, a4, 0
4200ab2d:	24a8      	l32i.n	a10, a4, 8
4200ab2f:	88aa      	add.n	a8, a8, a10
4200ab31:	fcc882        	addi	a8, a8, -4
4200ab34:	0888      	l32i.n	a8, a8, 0
4200ab36:	0289      	s32i.n	a8, a2, 0
4200ab38:	0c2d      	mov.n	a2, a12
4200ab3a:	000b86        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200ab3d:	d0c8e2        	addi	a14, a8, -48
4200ab40:	9a0c      	movi.n	a10, 9
4200ab42:	0001c6        	j	4200ab4d <get_arg$constprop$0+0x399>
4200ab45:	a0eee0        	addx4	a14, a14, a14
4200ab48:	90ee80        	addx2	a14, a14, a8
4200ab4b:	331b      	addi.n	a3, a3, 1
4200ab4d:	000382        	l8ui	a8, a3, 0
4200ab50:	889c      	beqz.n	a8, 4200ab6c <get_arg$constprop$0+0x3b8>
4200ab52:	d0c882        	addi	a8, a8, -48
4200ab55:	ecba87        	bgeu	a10, a8, 4200ab45 <get_arg$constprop$0+0x391>
4200ab58:	000406        	j	4200ab6c <get_arg$constprop$0+0x3b8>
4200ab5b:	000382        	l8ui	a8, a3, 0
4200ab5e:	d0c882        	addi	a8, a8, -48
4200ab61:	748080        	extui	a8, a8, 0, 8
4200ab64:	043a87        	bltu	a10, a8, 4200ab6c <get_arg$constprop$0+0x3b8>
4200ab67:	331b      	addi.n	a3, a3, 1
4200ab69:	fffb86        	j	4200ab5b <get_arg$constprop$0+0x3a7>
4200ab6c:	11a8      	l32i.n	a10, a1, 4
4200ab6e:	b80c      	movi.n	a8, 11
4200ab70:	021a87        	beq	a10, a8, 4200ab76 <get_arg$constprop$0+0x3c2>
4200ab73:	ff21c6        	j	4200a7fe <get_arg$constprop$0+0x4a>
4200ab76:	2188      	l32i.n	a8, a1, 8
4200ab78:	000352        	l8ui	a5, a3, 0
4200ab7b:	072827        	blt	a8, a2, 4200ab86 <get_arg$constprop$0+0x3d2>
4200ab7e:	090c      	movi.n	a9, 0
4200ab80:	021597        	beq	a5, a9, 4200ab86 <get_arg$constprop$0+0x3d2>
4200ab83:	ff1246        	j	4200a7d0 <get_arg$constprop$0+0x1c>
4200ab86:	0188      	l32i.n	a8, a1, 0
4200ab88:	2198      	l32i.n	a9, a1, 8
4200ab8a:	839850        	moveqz	a9, a8, a5
4200ab8d:	0199      	s32i.n	a9, a1, 0
4200ab8f:	002646        	j	4200ac2c <get_arg$constprop$0+0x478>
4200ab92:	00          	.byte 00
4200ab93:	00          	.byte 00
4200ab94:	a05c70        	addx4	a5, a12, a7
4200ab97:	0588      	l32i.n	a8, a5, 0
4200ab99:	cc1b      	addi.n	a12, a12, 1
4200ab9b:	880b      	addi.n	a8, a8, -1
4200ab9d:	2458      	l32i.n	a5, a4, 8
4200ab9f:	6568f6        	bgeui	a8, 6, 4200ac08 <get_arg$constprop$0+0x454>
4200aba2:	d80591        	l32r	a9, 42000bb8 <_stext+0xb98>
4200aba5:	a08890        	addx4	a8, a8, a9
4200aba8:	0888      	l32i.n	a8, a8, 0
4200abaa:	0008a0        	jx	a8
4200abad:	557b      	addi.n	a5, a5, 7
4200abaf:	1055f0        	and	a5, a5, a15
4200abb2:	858b      	addi.n	a8, a5, 8
4200abb4:	2489      	s32i.n	a8, a4, 8
4200abb6:	062a87        	blt	a10, a8, 4200abc0 <get_arg$constprop$0+0x40c>
4200abb9:	1458      	l32i.n	a5, a4, 4
4200abbb:	000286        	j	4200abc9 <get_arg$constprop$0+0x415>
4200abbe:	00          	.byte 00
4200abbf:	00          	.byte 00
4200abc0:	012a57        	blt	a10, a5, 4200abc5 <get_arg$constprop$0+0x411>
4200abc3:	0e8d      	mov.n	a8, a14
4200abc5:	0458      	l32i.n	a5, a4, 0
4200abc7:	2489      	s32i.n	a8, a4, 8
4200abc9:	2488      	l32i.n	a8, a4, 8
4200abcb:	558a      	add.n	a5, a5, a8
4200abcd:	f8c552        	addi	a5, a5, -8
4200abd0:	0588      	l32i.n	a8, a5, 0
4200abd2:	1598      	l32i.n	a9, a5, 4
4200abd4:	0b89      	s32i.n	a8, a11, 0
4200abd6:	1b99      	s32i.n	a9, a11, 4
4200abd8:	001806        	j	4200ac3c <get_arg$constprop$0+0x488>
4200abdb:	557b      	addi.n	a5, a5, 7
4200abdd:	1055f0        	and	a5, a5, a15
4200abe0:	858b      	addi.n	a8, a5, 8
4200abe2:	2489      	s32i.n	a8, a4, 8
4200abe4:	042a87        	blt	a10, a8, 4200abec <get_arg$constprop$0+0x438>
4200abe7:	1458      	l32i.n	a5, a4, 4
4200abe9:	000206        	j	4200abf5 <get_arg$constprop$0+0x441>
4200abec:	012a57        	blt	a10, a5, 4200abf1 <get_arg$constprop$0+0x43d>
4200abef:	0e8d      	mov.n	a8, a14
4200abf1:	0458      	l32i.n	a5, a4, 0
4200abf3:	2489      	s32i.n	a8, a4, 8
4200abf5:	2488      	l32i.n	a8, a4, 8
4200abf7:	558a      	add.n	a5, a5, a8
4200abf9:	f8c552        	addi	a5, a5, -8
4200abfc:	0588      	l32i.n	a8, a5, 0
4200abfe:	1598      	l32i.n	a9, a5, 4
4200ac00:	0b89      	s32i.n	a8, a11, 0
4200ac02:	1b99      	s32i.n	a9, a11, 4
4200ac04:	000d06        	j	4200ac3c <get_arg$constprop$0+0x488>
4200ac07:	00          	.byte 00
4200ac08:	854b      	addi.n	a8, a5, 4
4200ac0a:	2489      	s32i.n	a8, a4, 8
4200ac0c:	042a87        	blt	a10, a8, 4200ac14 <get_arg$constprop$0+0x460>
4200ac0f:	1458      	l32i.n	a5, a4, 4
4200ac11:	000206        	j	4200ac1d <get_arg$constprop$0+0x469>
4200ac14:	012a57        	blt	a10, a5, 4200ac19 <get_arg$constprop$0+0x465>
4200ac17:	0d8d      	mov.n	a8, a13
4200ac19:	0458      	l32i.n	a5, a4, 0
4200ac1b:	2489      	s32i.n	a8, a4, 8
4200ac1d:	2488      	l32i.n	a8, a4, 8
4200ac1f:	558a      	add.n	a5, a5, a8
4200ac21:	fcc552        	addi	a5, a5, -4
4200ac24:	0558      	l32i.n	a5, a5, 0
4200ac26:	0b59      	s32i.n	a5, a11, 0
4200ac28:	000406        	j	4200ac3c <get_arg$constprop$0+0x488>
4200ac2b:	00          	.byte 00
4200ac2c:	b0b260        	addx8	a11, a2, a6
4200ac2f:	02cd      	mov.n	a12, a2
4200ac31:	8a1c      	movi.n	a10, 24
4200ac33:	4d2c      	movi.n	a13, 36
4200ac35:	8f7c      	movi.n	a15, -8
4200ac37:	8e2c      	movi.n	a14, 40
4200ac39:	000046        	j	4200ac3e <get_arg$constprop$0+0x48a>
4200ac3c:	bb8b      	addi.n	a11, a11, 8
4200ac3e:	0158      	l32i.n	a5, a1, 0
4200ac40:	0225c7        	blt	a5, a12, 4200ac46 <get_arg$constprop$0+0x492>
4200ac43:	ffd346        	j	4200ab94 <get_arg$constprop$0+0x3e0>
4200ac46:	551b      	addi.n	a5, a5, 1
4200ac48:	040c      	movi.n	a4, 0
4200ac4a:	4a2527        	blt	a5, a2, 4200ac98 <get_arg$constprop$0+0x4e4>
4200ac4d:	c04520        	sub	a4, a5, a2
4200ac50:	001106        	j	4200ac98 <get_arg$constprop$0+0x4e4>
4200ac53:	00          	.byte 00
4200ac54:	150c      	movi.n	a5, 1
4200ac56:	020926        	beqi	a9, -1, 4200ac5c <get_arg$constprop$0+0x4a8>
4200ac59:	ff2fc6        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac5c:	ff35c6        	j	4200a937 <get_arg$constprop$0+0x183>
4200ac5f:	00          	.byte 00
4200ac60:	250c      	movi.n	a5, 2
4200ac62:	020926        	beqi	a9, -1, 4200ac68 <get_arg$constprop$0+0x4b4>
4200ac65:	ff2cc6        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac68:	ff3f46        	j	4200a969 <get_arg$constprop$0+0x1b5>
4200ac6b:	00          	.byte 00
4200ac6c:	650c      	movi.n	a5, 6
4200ac6e:	020926        	beqi	a9, -1, 4200ac74 <get_arg$constprop$0+0x4c0>
4200ac71:	ff29c6        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac74:	ff4b86        	j	4200a9a6 <get_arg$constprop$0+0x1f2>
4200ac77:	050c      	movi.n	a5, 0
4200ac79:	020926        	beqi	a9, -1, 4200ac7f <get_arg$constprop$0+0x4cb>
4200ac7c:	ff2706        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac7f:	ff5586        	j	4200a9d9 <get_arg$constprop$0+0x225>
4200ac82:	350c      	movi.n	a5, 3
4200ac84:	020926        	beqi	a9, -1, 4200ac8a <get_arg$constprop$0+0x4d6>
4200ac87:	ff2446        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac8a:	ff5fc6        	j	4200aa0d <get_arg$constprop$0+0x259>
4200ac8d:	450c      	movi.n	a5, 4
4200ac8f:	020926        	beqi	a9, -1, 4200ac95 <get_arg$constprop$0+0x4e1>
4200ac92:	ff2186        	j	4200a91c <get_arg$constprop$0+0x168>
4200ac95:	ff6a06        	j	4200aa41 <get_arg$constprop$0+0x28d>
4200ac98:	3188      	l32i.n	a8, a1, 12
4200ac9a:	424a      	add.n	a4, a2, a4
4200ac9c:	0849      	s32i.n	a4, a8, 0
4200ac9e:	102192        	l32i	a9, a1, 64
4200aca1:	2188      	l32i.n	a8, a1, 8
4200aca3:	0939      	s32i.n	a3, a9, 0
4200aca5:	b02860        	addx8	a2, a8, a6
4200aca8:	f01d      	retw.n
	...

4200acac <_svfprintf_r>:
4200acac:	062136        	entry	a1, 0x310
4200acaf:	a46122        	s32i	a2, a1, 0x290
4200acb2:	a421a2        	l32i	a10, a1, 0x290
4200acb5:	a56132        	s32i	a3, a1, 0x294
4200acb8:	a16142        	s32i	a4, a1, 0x284
4200acbb:	9c6152        	s32i	a5, a1, 0x270
4200acbe:	9d6162        	s32i	a6, a1, 0x274
4200acc1:	9e6172        	s32i	a7, a1, 0x278
4200acc4:	201110        	or	a1, a1, a1
4200acc7:	0791e5        	call8	420125e4 <_localeconv_r>
4200acca:	0aa8      	l32i.n	a10, a10, 0
4200accc:	b261a2        	s32i	a10, a1, 0x2c8
4200accf:	d67181        	l32r	a8, 42000694 <_stext+0x674>
4200acd2:	0008e0        	callx8	a8
4200acd5:	a52182        	l32i	a8, a1, 0x294
4200acd8:	ae61a2        	s32i	a10, a1, 0x2b8
4200acdb:	061822        	l16ui	a2, a8, 12
4200acde:	10c132        	addi	a3, a1, 16
4200ace1:	2f6277        	bbci	a2, 7, 4200ad14 <_svfprintf_r+0x68>
4200ace4:	4828      	l32i.n	a2, a8, 16
4200ace6:	a2ec      	bnez.n	a2, 4200ad14 <_svfprintf_r+0x68>
4200ace8:	a421a2        	l32i	a10, a1, 0x290
4200aceb:	40a0b2        	movi	a11, 64
4200acee:	d79981        	l32r	a8, 42000b54 <_stext+0xb34>
4200acf1:	0008e0        	callx8	a8
4200acf4:	a52122        	l32i	a2, a1, 0x294
4200acf7:	02a9      	s32i.n	a10, a2, 0
4200acf9:	42a9      	s32i.n	a10, a2, 16
4200acfb:	eacc      	bnez.n	a10, 4200ad0d <_svfprintf_r+0x61>
4200acfd:	a42182        	l32i	a8, a1, 0x290
4200ad00:	c20c      	movi.n	a2, 12
4200ad02:	0829      	s32i.n	a2, a8, 0
4200ad04:	f27c      	movi.n	a2, -1
4200ad06:	ad6122        	s32i	a2, a1, 0x2b4
4200ad09:	0be306        	j	4200dc99 <_svfprintf_r+0x2fed>
4200ad0c:	00          	.byte 00
4200ad0d:	a52132        	l32i	a3, a1, 0x294
4200ad10:	024c      	movi.n	a2, 64
4200ad12:	5329      	s32i.n	a2, a3, 20
4200ad14:	10c152        	addi	a5, a1, 16
4200ad17:	f47c      	movi.n	a4, -1
4200ad19:	e4a132        	movi	a3, 0x1e4
4200ad1c:	353a      	add.n	a3, a5, a3
4200ad1e:	446142        	s32i	a4, a1, 0x110
4200ad21:	d6b351        	l32r	a5, 420007f0 <_stext+0x7d0>
4200ad24:	d6b341        	l32r	a4, 420007f0 <_stext+0x7d0>
4200ad27:	020c      	movi.n	a2, 0
4200ad29:	8d6132        	s32i	a3, a1, 0x234
4200ad2c:	8f6122        	s32i	a2, a1, 0x23c
4200ad2f:	8e6122        	s32i	a2, a1, 0x238
4200ad32:	966122        	s32i	a2, a1, 0x258
4200ad35:	976122        	s32i	a2, a1, 0x25c
4200ad38:	a66122        	s32i	a2, a1, 0x298
4200ad3b:	a86142        	s32i	a4, a1, 0x2a0
4200ad3e:	a96152        	s32i	a5, a1, 0x2a4
4200ad41:	039d      	mov.n	a9, a3
4200ad43:	b46122        	s32i	a2, a1, 0x2d0
4200ad46:	b66122        	s32i	a2, a1, 0x2d8
4200ad49:	ac6122        	s32i	a2, a1, 0x2b0
4200ad4c:	b06122        	s32i	a2, a1, 0x2c0
4200ad4f:	b56122        	s32i	a2, a1, 0x2d4
4200ad52:	ad6122        	s32i	a2, a1, 0x2b4
4200ad55:	9f6122        	s32i	a2, a1, 0x27c
4200ad58:	000186        	j	4200ad62 <_svfprintf_r+0xb6>
4200ad5b:	00          	.byte 00
4200ad5c:	aa2152        	l32i	a5, a1, 0x2a8
4200ad5f:	a16152        	s32i	a5, a1, 0x284
4200ad62:	a12132        	l32i	a3, a1, 0x284
4200ad65:	000046        	j	4200ad6a <_svfprintf_r+0xbe>
4200ad68:	331b      	addi.n	a3, a3, 1
4200ad6a:	000322        	l8ui	a2, a3, 0
4200ad6d:	428c      	beqz.n	a2, 4200ad75 <_svfprintf_r+0xc9>
4200ad6f:	dbc222        	addi	a2, a2, -37
4200ad72:	ff2256        	bnez	a2, 4200ad68 <_svfprintf_r+0xbc>
4200ad75:	a12182        	l32i	a8, a1, 0x284
4200ad78:	c04380        	sub	a4, a3, a8
4200ad7b:	451387        	beq	a3, a8, 4200adc4 <_svfprintf_r+0x118>
4200ad7e:	8f2122        	l32i	a2, a1, 0x23c
4200ad81:	0989      	s32i.n	a8, a9, 0
4200ad83:	224a      	add.n	a2, a2, a4
4200ad85:	8f6122        	s32i	a2, a1, 0x23c
4200ad88:	8e2122        	l32i	a2, a1, 0x238
4200ad8b:	1949      	s32i.n	a4, a9, 4
4200ad8d:	221b      	addi.n	a2, a2, 1
4200ad8f:	10c1a2        	addi	a10, a1, 16
4200ad92:	8e6122        	s32i	a2, a1, 0x238
4200ad95:	02da52        	addmi	a5, a10, 0x200
4200ad98:	998b      	addi.n	a9, a9, 8
4200ad9a:	1e82a6        	blti	a2, 8, 4200adbc <_svfprintf_r+0x110>
4200ad9d:	10c1b2        	addi	a11, a1, 16
4200ada0:	24a2c2        	movi	a12, 0x224
4200ada3:	cbca      	add.n	a12, a11, a12
4200ada5:	a421a2        	l32i	a10, a1, 0x290
4200ada8:	a521b2        	l32i	a11, a1, 0x294
4200adab:	201110        	or	a1, a1, a1
4200adae:	087e25        	call8	42013590 <__ssprint_r>
4200adb1:	1a8c      	beqz.n	a10, 4200adb6 <_svfprintf_r+0x10a>
4200adb3:	0ba546        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200adb6:	f4a1e2        	movi	a14, 0x1f4
4200adb9:	8091e0        	add	a9, a1, a14
4200adbc:	ad2122        	l32i	a2, a1, 0x2b4
4200adbf:	224a      	add.n	a2, a2, a4
4200adc1:	ad6122        	s32i	a2, a1, 0x2b4
4200adc4:	000322        	l8ui	a2, a3, 0
4200adc7:	12cc      	bnez.n	a2, 4200adcc <_svfprintf_r+0x120>
4200adc9:	0b94c6        	j	4200dc20 <_svfprintf_r+0x2f74>
4200adcc:	10c142        	addi	a4, a1, 16
4200adcf:	02d422        	addmi	a2, a4, 0x200
4200add2:	080c      	movi.n	a8, 0
4200add4:	040c      	movi.n	a4, 0
4200add6:	f67c      	movi.n	a6, -1
4200add8:	524242        	s8i	a4, a2, 82
4200addb:	531b      	addi.n	a5, a3, 1
4200addd:	9f2122        	l32i	a2, a1, 0x27c
4200ade0:	a26162        	s32i	a6, a1, 0x288
4200ade3:	ab6182        	s32i	a8, a1, 0x2ac
4200ade6:	084d      	mov.n	a4, a8
4200ade8:	a06182        	s32i	a8, a1, 0x280
4200adeb:	000286        	j	4200adf9 <_svfprintf_r+0x14d>
4200adee:	00          	.byte 00
4200adef:	00          	.byte 00
4200adf0:	00          	.byte 00
4200adf1:	aa6152        	s32i	a5, a1, 0x2a8
4200adf4:	040c      	movi.n	a4, 0
4200adf6:	aa2152        	l32i	a5, a1, 0x2a8
4200adf9:	651b      	addi.n	a6, a5, 1
4200adfb:	000552        	l8ui	a5, a5, 0
4200adfe:	aa6162        	s32i	a6, a1, 0x2a8
4200ae01:	d774d1        	l32r	a13, 42000bd4 <_stext+0xbb4>
4200ae04:	a76152        	s32i	a5, a1, 0x29c
4200ae07:	ac5c      	movi.n	a12, 90
4200ae09:	960c      	movi.n	a6, 9
4200ae0b:	482c      	movi.n	a8, 36
4200ae0d:	aa2c      	movi.n	a10, 42
4200ae0f:	000106        	j	4200ae17 <_svfprintf_r+0x16b>
4200ae12:	00          	.byte 00
4200ae13:	00          	.byte 00
4200ae14:	ab6152        	s32i	a5, a1, 0x2ac
4200ae17:	a721b2        	l32i	a11, a1, 0x29c
4200ae1a:	e0cb52        	addi	a5, a11, -32
4200ae1d:	02bc57        	bgeu	a12, a5, 4200ae23 <_svfprintf_r+0x177>
4200ae20:	08b746        	j	4200d101 <_svfprintf_r+0x2455>
4200ae23:	a055d0        	addx4	a5, a5, a13
4200ae26:	0558      	l32i.n	a5, a5, 0
4200ae28:	0005a0        	jx	a5
4200ae2b:	00          	.byte 00
4200ae2c:	00          	.byte 00
4200ae2d:	a421a2        	l32i	a10, a1, 0x290
4200ae30:	b96192        	s32i	a9, a1, 0x2e4
4200ae33:	201110        	or	a1, a1, a1
4200ae36:	077ae5        	call8	420125e4 <_localeconv_r>
4200ae39:	1aa8      	l32i.n	a10, a10, 4
4200ae3b:	b561a2        	s32i	a10, a1, 0x2d4
4200ae3e:	d61581        	l32r	a8, 42000694 <_stext+0x674>
4200ae41:	0008e0        	callx8	a8
4200ae44:	b061a2        	s32i	a10, a1, 0x2c0
4200ae47:	a421a2        	l32i	a10, a1, 0x290
4200ae4a:	201110        	or	a1, a1, a1
4200ae4d:	077965        	call8	420125e4 <_localeconv_r>
4200ae50:	2aa8      	l32i.n	a10, a10, 8
4200ae52:	b02152        	l32i	a5, a1, 0x2c0
4200ae55:	ac61a2        	s32i	a10, a1, 0x2b0
4200ae58:	b92192        	l32i	a9, a1, 0x2e4
4200ae5b:	f97516        	beqz	a5, 4200adf6 <_svfprintf_r+0x14a>
4200ae5e:	f94a16        	beqz	a10, 4200adf6 <_svfprintf_r+0x14a>
4200ae61:	000a52        	l8ui	a5, a10, 0
4200ae64:	f8e516        	beqz	a5, 4200adf6 <_svfprintf_r+0x14a>
4200ae67:	00a452        	movi	a5, 0x400
4200ae6a:	00ba46        	j	4200b157 <_svfprintf_r+0x4ab>
4200ae6d:	10c182        	addi	a8, a1, 16
4200ae70:	02d852        	addmi	a5, a8, 0x200
4200ae73:	520562        	l8ui	a6, a5, 82
4200ae76:	f7c656        	bnez	a6, 4200adf6 <_svfprintf_r+0x14a>
4200ae79:	062c      	movi.n	a6, 32
4200ae7b:	004646        	j	4200af98 <_svfprintf_r+0x2ec>
4200ae7e:	150c      	movi.n	a5, 1
4200ae80:	00b4c6        	j	4200b157 <_svfprintf_r+0x4ab>
4200ae83:	aa2182        	l32i	a8, a1, 0x2a8
4200ae86:	970c      	movi.n	a7, 9
4200ae88:	000862        	l8ui	a6, a8, 0
4200ae8b:	d0c652        	addi	a5, a6, -48
4200ae8e:	02b757        	bgeu	a7, a5, 4200ae94 <_svfprintf_r+0x1e8>
4200ae91:	0b73c6        	j	4200dc64 <_svfprintf_r+0x2fb8>
4200ae94:	581b      	addi.n	a5, a8, 1
4200ae96:	0a0c      	movi.n	a10, 0
4200ae98:	d0c662        	addi	a6, a6, -48
4200ae9b:	a0aaa0        	addx4	a10, a10, a10
4200ae9e:	90aa60        	addx2	a10, a10, a6
4200aea1:	000562        	l8ui	a6, a5, 0
4200aea4:	551b      	addi.n	a5, a5, 1
4200aea6:	d0c682        	addi	a8, a6, -48
4200aea9:	ebb787        	bgeu	a7, a8, 4200ae98 <_svfprintf_r+0x1ec>
4200aeac:	472c      	movi.n	a7, 36
4200aeae:	021677        	beq	a6, a7, 4200aeb4 <_svfprintf_r+0x208>
4200aeb1:	ffcfc6        	j	4200adf4 <_svfprintf_r+0x148>
4200aeb4:	062c      	movi.n	a6, 32
4200aeb6:	02a6a7        	bge	a6, a10, 4200aebc <_svfprintf_r+0x210>
4200aeb9:	0b63c6        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200aebc:	972162        	l32i	a6, a1, 0x25c
4200aebf:	aa0b      	addi.n	a10, a10, -1
4200aec1:	13aa67        	bge	a10, a6, 4200aed8 <_svfprintf_r+0x22c>
4200aec4:	10c1b2        	addi	a11, a1, 16
4200aec7:	b0aab0        	addx8	a10, a10, a11
4200aeca:	0aa8      	l32i.n	a10, a10, 0
4200aecc:	9f21c2        	l32i	a12, a1, 0x27c
4200aecf:	ab61a2        	s32i	a10, a1, 0x2ac
4200aed2:	aa6152        	s32i	a5, a1, 0x2a8
4200aed5:	0028c6        	j	4200af7c <_svfprintf_r+0x2d0>
4200aed8:	10c1e2        	addi	a14, a1, 16
4200aedb:	48a262        	movi	a6, 0x248
4200aede:	6e6a      	add.n	a6, a14, a6
4200aee0:	5ca2d2        	movi	a13, 0x25c
4200aee3:	60a2c2        	movi	a12, 0x260
4200aee6:	ceca      	add.n	a12, a14, a12
4200aee8:	0169      	s32i.n	a6, a1, 0
4200aeea:	01def2        	addmi	a15, a14, 0x100
4200aeed:	dd1a      	add.n	a13, a13, a1
4200aeef:	20b330        	or	a11, a3, a3
4200aef2:	b96192        	s32i	a9, a1, 0x2e4
4200aef5:	ff8be5        	call8	4200a7b4 <get_arg$constprop$0>
4200aef8:	0aa8      	l32i.n	a10, a10, 0
4200aefa:	9f21c2        	l32i	a12, a1, 0x27c
4200aefd:	b92192        	l32i	a9, a1, 0x2e4
4200af00:	ab61a2        	s32i	a10, a1, 0x2ac
4200af03:	aa6152        	s32i	a5, a1, 0x2a8
4200af06:	001c86        	j	4200af7c <_svfprintf_r+0x2d0>
4200af09:	10c162        	addi	a6, a1, 16
4200af0c:	b05260        	addx8	a5, a2, a6
4200af0f:	001906        	j	4200af77 <_svfprintf_r+0x2cb>
4200af12:	10c182        	addi	a8, a1, 16
4200af15:	9a28a2        	l32i	a10, a8, 0x268
4200af18:	fb1c      	movi.n	a11, 31
4200af1a:	02d872        	addmi	a7, a8, 0x200
4200af1d:	5a4b      	addi.n	a5, a10, 4
4200af1f:	881c      	movi.n	a8, 24
4200af21:	332b67        	blt	a11, a6, 4200af58 <_svfprintf_r+0x2ac>
4200af24:	b61b      	addi.n	a11, a6, 1
4200af26:	9761b2        	s32i	a11, a1, 0x25c
4200af29:	1a6752        	s32i	a5, a7, 104
4200af2c:	052857        	blt	a8, a5, 4200af35 <_svfprintf_r+0x289>
4200af2f:	192752        	l32i	a5, a7, 100
4200af32:	000286        	j	4200af40 <_svfprintf_r+0x294>
4200af35:	0128a7        	blt	a8, a10, 4200af3a <_svfprintf_r+0x28e>
4200af38:	452c      	movi.n	a5, 36
4200af3a:	9e6152        	s32i	a5, a1, 0x278
4200af3d:	9c2152        	l32i	a5, a1, 0x270
4200af40:	9e2172        	l32i	a7, a1, 0x278
4200af43:	10c1b2        	addi	a11, a1, 16
4200af46:	557a      	add.n	a5, a5, a7
4200af48:	fcc552        	addi	a5, a5, -4
4200af4b:	0558      	l32i.n	a5, a5, 0
4200af4d:	b066b0        	addx8	a6, a6, a11
4200af50:	ab6152        	s32i	a5, a1, 0x2ac
4200af53:	0659      	s32i.n	a5, a6, 0
4200af55:	0008c6        	j	4200af7c <_svfprintf_r+0x2d0>
4200af58:	1a6752        	s32i	a5, a7, 104
4200af5b:	052857        	blt	a8, a5, 4200af64 <_svfprintf_r+0x2b8>
4200af5e:	192752        	l32i	a5, a7, 100
4200af61:	000286        	j	4200af6f <_svfprintf_r+0x2c3>
4200af64:	0128a7        	blt	a8, a10, 4200af69 <_svfprintf_r+0x2bd>
4200af67:	452c      	movi.n	a5, 36
4200af69:	9e6152        	s32i	a5, a1, 0x278
4200af6c:	9c2152        	l32i	a5, a1, 0x270
4200af6f:	9e2162        	l32i	a6, a1, 0x278
4200af72:	556a      	add.n	a5, a5, a6
4200af74:	fcc552        	addi	a5, a5, -4
4200af77:	0558      	l32i.n	a5, a5, 0
4200af79:	ab6152        	s32i	a5, a1, 0x2ac
4200af7c:	ab2152        	l32i	a5, a1, 0x2ac
4200af7f:	9f61c2        	s32i	a12, a1, 0x27c
4200af82:	e705d6        	bgez	a5, 4200adf6 <_svfprintf_r+0x14a>
4200af85:	605050        	neg	a5, a5
4200af88:	ab6152        	s32i	a5, a1, 0x2ac
4200af8b:	450c      	movi.n	a5, 4
4200af8d:	007186        	j	4200b157 <_svfprintf_r+0x4ab>
4200af90:	10c182        	addi	a8, a1, 16
4200af93:	b62c      	movi.n	a6, 43
4200af95:	02d852        	addmi	a5, a8, 0x200
4200af98:	524562        	s8i	a6, a5, 82
4200af9b:	ff95c6        	j	4200adf6 <_svfprintf_r+0x14a>
4200af9e:	aa21b2        	l32i	a11, a1, 0x2a8
4200afa1:	000be2        	l8ui	a14, a11, 0
4200afa4:	5b1b      	addi.n	a5, a11, 1
4200afa6:	a761e2        	s32i	a14, a1, 0x29c
4200afa9:	071ea7        	beq	a14, a10, 4200afb4 <_svfprintf_r+0x308>
4200afac:	0b0c      	movi.n	a11, 0
4200afae:	a261b2        	s32i	a11, a1, 0x288
4200afb1:	0045c6        	j	4200b0cc <_svfprintf_r+0x420>
4200afb4:	aa2162        	l32i	a6, a1, 0x2a8
4200afb7:	980c      	movi.n	a8, 9
4200afb9:	010672        	l8ui	a7, a6, 1
4200afbc:	d0c762        	addi	a6, a7, -48
4200afbf:	02b867        	bgeu	a8, a6, 4200afc5 <_svfprintf_r+0x319>
4200afc2:	0b2bc6        	j	4200dc75 <_svfprintf_r+0x2fc9>
4200afc5:	aa21a2        	l32i	a10, a1, 0x2a8
4200afc8:	6a2b      	addi.n	a6, a10, 2
4200afca:	0a0c      	movi.n	a10, 0
4200afcc:	d0c772        	addi	a7, a7, -48
4200afcf:	a0aaa0        	addx4	a10, a10, a10
4200afd2:	90aa70        	addx2	a10, a10, a7
4200afd5:	000672        	l8ui	a7, a6, 0
4200afd8:	661b      	addi.n	a6, a6, 1
4200afda:	d0c7b2        	addi	a11, a7, -48
4200afdd:	ebb8b7        	bgeu	a8, a11, 4200afcc <_svfprintf_r+0x320>
4200afe0:	482c      	movi.n	a8, 36
4200afe2:	021787        	beq	a7, a8, 4200afe8 <_svfprintf_r+0x33c>
4200afe5:	ff8206        	j	4200adf1 <_svfprintf_r+0x145>
4200afe8:	052c      	movi.n	a5, 32
4200afea:	02a5a7        	bge	a5, a10, 4200aff0 <_svfprintf_r+0x344>
4200afed:	0b16c6        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200aff0:	972152        	l32i	a5, a1, 0x25c
4200aff3:	aa0b      	addi.n	a10, a10, -1
4200aff5:	10aa57        	bge	a10, a5, 4200b009 <_svfprintf_r+0x35d>
4200aff8:	10c1b2        	addi	a11, a1, 16
4200affb:	b0aab0        	addx8	a10, a10, a11
4200affe:	0a88      	l32i.n	a8, a10, 0
4200b000:	9f21c2        	l32i	a12, a1, 0x27c
4200b003:	065d      	mov.n	a5, a6
4200b005:	002706        	j	4200b0a5 <_svfprintf_r+0x3f9>
4200b008:	00          	.byte 00
4200b009:	10c1e2        	addi	a14, a1, 16
4200b00c:	48a252        	movi	a5, 0x248
4200b00f:	5e5a      	add.n	a5, a14, a5
4200b011:	5ca2d2        	movi	a13, 0x25c
4200b014:	60a2c2        	movi	a12, 0x260
4200b017:	0159      	s32i.n	a5, a1, 0
4200b019:	ceca      	add.n	a12, a14, a12
4200b01b:	01def2        	addmi	a15, a14, 0x100
4200b01e:	dd1a      	add.n	a13, a13, a1
4200b020:	03bd      	mov.n	a11, a3
4200b022:	b96192        	s32i	a9, a1, 0x2e4
4200b025:	ff78e5        	call8	4200a7b4 <get_arg$constprop$0>
4200b028:	0a88      	l32i.n	a8, a10, 0
4200b02a:	9f21c2        	l32i	a12, a1, 0x27c
4200b02d:	b92192        	l32i	a9, a1, 0x2e4
4200b030:	065d      	mov.n	a5, a6
4200b032:	001bc6        	j	4200b0a5 <_svfprintf_r+0x3f9>
4200b035:	10c182        	addi	a8, a1, 16
4200b038:	b06280        	addx8	a6, a2, a8
4200b03b:	001906        	j	4200b0a3 <_svfprintf_r+0x3f7>
4200b03e:	10c1a2        	addi	a10, a1, 16
4200b041:	02da82        	addmi	a8, a10, 0x200
4200b044:	1a28a2        	l32i	a10, a8, 104
4200b047:	fb1c      	movi.n	a11, 31
4200b049:	6a4b      	addi.n	a6, a10, 4
4200b04b:	322b77        	blt	a11, a7, 4200b081 <_svfprintf_r+0x3d5>
4200b04e:	b71b      	addi.n	a11, a7, 1
4200b050:	9761b2        	s32i	a11, a1, 0x25c
4200b053:	1a6862        	s32i	a6, a8, 104
4200b056:	8b1c      	movi.n	a11, 24
4200b058:	052b67        	blt	a11, a6, 4200b061 <_svfprintf_r+0x3b5>
4200b05b:	192862        	l32i	a6, a8, 100
4200b05e:	000286        	j	4200b06c <_svfprintf_r+0x3c0>
4200b061:	012ba7        	blt	a11, a10, 4200b066 <_svfprintf_r+0x3ba>
4200b064:	462c      	movi.n	a6, 36
4200b066:	9e6162        	s32i	a6, a1, 0x278
4200b069:	9c2162        	l32i	a6, a1, 0x270
4200b06c:	9e2182        	l32i	a8, a1, 0x278
4200b06f:	10c1e2        	addi	a14, a1, 16
4200b072:	668a      	add.n	a6, a6, a8
4200b074:	fcc662        	addi	a6, a6, -4
4200b077:	0688      	l32i.n	a8, a6, 0
4200b079:	b077e0        	addx8	a7, a7, a14
4200b07c:	0789      	s32i.n	a8, a7, 0
4200b07e:	0008c6        	j	4200b0a5 <_svfprintf_r+0x3f9>
4200b081:	1a6862        	s32i	a6, a8, 104
4200b084:	871c      	movi.n	a7, 24
4200b086:	062767        	blt	a7, a6, 4200b090 <_svfprintf_r+0x3e4>
4200b089:	192862        	l32i	a6, a8, 100
4200b08c:	0002c6        	j	4200b09b <_svfprintf_r+0x3ef>
4200b08f:	00          	.byte 00
4200b090:	0127a7        	blt	a7, a10, 4200b095 <_svfprintf_r+0x3e9>
4200b093:	462c      	movi.n	a6, 36
4200b095:	9e6162        	s32i	a6, a1, 0x278
4200b098:	9c2162        	l32i	a6, a1, 0x270
4200b09b:	9e2172        	l32i	a7, a1, 0x278
4200b09e:	667a      	add.n	a6, a6, a7
4200b0a0:	fcc662        	addi	a6, a6, -4
4200b0a3:	0688      	l32i.n	a8, a6, 0
4200b0a5:	f67c      	movi.n	a6, -1
4200b0a7:	536860        	max	a6, a8, a6
4200b0aa:	a26162        	s32i	a6, a1, 0x288
4200b0ad:	9f61c2        	s32i	a12, a1, 0x27c
4200b0b0:	aa6152        	s32i	a5, a1, 0x2a8
4200b0b3:	ff4fc6        	j	4200adf6 <_svfprintf_r+0x14a>
4200b0b6:	00          	.byte 00
4200b0b7:	00          	.byte 00
4200b0b8:	a221e2        	l32i	a14, a1, 0x288
4200b0bb:	a0bee0        	addx4	a11, a14, a14
4200b0be:	90bb70        	addx2	a11, a11, a7
4200b0c1:	a261b2        	s32i	a11, a1, 0x288
4200b0c4:	0005b2        	l8ui	a11, a5, 0
4200b0c7:	551b      	addi.n	a5, a5, 1
4200b0c9:	a761b2        	s32i	a11, a1, 0x29c
4200b0cc:	a721e2        	l32i	a14, a1, 0x29c
4200b0cf:	aa6152        	s32i	a5, a1, 0x2a8
4200b0d2:	d0ce72        	addi	a7, a14, -48
4200b0d5:	dfb677        	bgeu	a6, a7, 4200b0b8 <_svfprintf_r+0x40c>
4200b0d8:	ab2152        	l32i	a5, a1, 0x2ac
4200b0db:	ff4d46        	j	4200ae14 <_svfprintf_r+0x168>
4200b0de:	00          	.byte 00
4200b0df:	00          	.byte 00
4200b0e0:	80a052        	movi	a5, 128
4200b0e3:	001c06        	j	4200b157 <_svfprintf_r+0x4ab>
4200b0e6:	050c      	movi.n	a5, 0
4200b0e8:	a721b2        	l32i	a11, a1, 0x29c
4200b0eb:	a05550        	addx4	a5, a5, a5
4200b0ee:	d0cb72        	addi	a7, a11, -48
4200b0f1:	905570        	addx2	a5, a5, a7
4200b0f4:	aa2172        	l32i	a7, a1, 0x2a8
4200b0f7:	0007e2        	l8ui	a14, a7, 0
4200b0fa:	b71b      	addi.n	a11, a7, 1
4200b0fc:	a761e2        	s32i	a14, a1, 0x29c
4200b0ff:	aa61b2        	s32i	a11, a1, 0x2a8
4200b102:	d0ce72        	addi	a7, a14, -48
4200b105:	dfb677        	bgeu	a6, a7, 4200b0e8 <_svfprintf_r+0x43c>
4200b108:	021e87        	beq	a14, a8, 4200b10e <_svfprintf_r+0x462>
4200b10b:	ff4146        	j	4200ae14 <_svfprintf_r+0x168>
4200b10e:	022c      	movi.n	a2, 32
4200b110:	02a257        	bge	a2, a5, 4200b116 <_svfprintf_r+0x46a>
4200b113:	0acd46        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200b116:	250b      	addi.n	a2, a5, -1
4200b118:	140c      	movi.n	a4, 1
4200b11a:	ff3606        	j	4200adf6 <_svfprintf_r+0x14a>
4200b11d:	850c      	movi.n	a5, 8
4200b11f:	000d06        	j	4200b157 <_svfprintf_r+0x4ab>
4200b122:	aa2182        	l32i	a8, a1, 0x2a8
4200b125:	68a052        	movi	a5, 104
4200b128:	000862        	l8ui	a6, a8, 0
4200b12b:	0a9657        	bne	a6, a5, 4200b139 <_svfprintf_r+0x48d>
4200b12e:	881b      	addi.n	a8, a8, 1
4200b130:	aa6182        	s32i	a8, a1, 0x2a8
4200b133:	00a252        	movi	a5, 0x200
4200b136:	000746        	j	4200b157 <_svfprintf_r+0x4ab>
4200b139:	054c      	movi.n	a5, 64
4200b13b:	000986        	j	4200b165 <_svfprintf_r+0x4b9>
4200b13e:	aa2152        	l32i	a5, a1, 0x2a8
4200b141:	000562        	l8ui	a6, a5, 0
4200b144:	6ca052        	movi	a5, 108
4200b147:	0a9657        	bne	a6, a5, 4200b155 <_svfprintf_r+0x4a9>
4200b14a:	aa2162        	l32i	a6, a1, 0x2a8
4200b14d:	661b      	addi.n	a6, a6, 1
4200b14f:	aa6162        	s32i	a6, a1, 0x2a8
4200b152:	000346        	j	4200b163 <_svfprintf_r+0x4b7>
4200b155:	051c      	movi.n	a5, 16
4200b157:	a02162        	l32i	a6, a1, 0x280
4200b15a:	206650        	or	a6, a6, a5
4200b15d:	a06162        	s32i	a6, a1, 0x280
4200b160:	ff2486        	j	4200adf6 <_svfprintf_r+0x14a>
4200b163:	052c      	movi.n	a5, 32
4200b165:	a02182        	l32i	a8, a1, 0x280
4200b168:	208850        	or	a8, a8, a5
4200b16b:	a06182        	s32i	a8, a1, 0x280
4200b16e:	ff2106        	j	4200adf6 <_svfprintf_r+0x14a>
4200b171:	972152        	l32i	a5, a1, 0x25c
4200b174:	d4bc      	beqz.n	a4, 4200b1b5 <_svfprintf_r+0x509>
4200b176:	0ea257        	bge	a2, a5, 4200b188 <_svfprintf_r+0x4dc>
4200b179:	10c1a2        	addi	a10, a1, 16
4200b17c:	b022a0        	addx8	a2, a2, a10
4200b17f:	000222        	l8ui	a2, a2, 0
4200b182:	9f2162        	l32i	a6, a1, 0x27c
4200b185:	002986        	j	4200b22f <_svfprintf_r+0x583>
4200b188:	58a2b2        	movi	a11, 0x258
4200b18b:	10c1e2        	addi	a14, a1, 16
4200b18e:	41ba      	add.n	a4, a1, a11
4200b190:	4ca2d2        	movi	a13, 0x24c
4200b193:	60a2c2        	movi	a12, 0x260
4200b196:	02ad      	mov.n	a10, a2
4200b198:	0149      	s32i.n	a4, a1, 0
4200b19a:	01def2        	addmi	a15, a14, 0x100
4200b19d:	deda      	add.n	a13, a14, a13
4200b19f:	ceca      	add.n	a12, a14, a12
4200b1a1:	03bd      	mov.n	a11, a3
4200b1a3:	b96192        	s32i	a9, a1, 0x2e4
4200b1a6:	ff60e5        	call8	4200a7b4 <get_arg$constprop$0>
4200b1a9:	000a22        	l8ui	a2, a10, 0
4200b1ac:	9f2162        	l32i	a6, a1, 0x27c
4200b1af:	b92192        	l32i	a9, a1, 0x2e4
4200b1b2:	001e46        	j	4200b22f <_svfprintf_r+0x583>
4200b1b5:	9f2132        	l32i	a3, a1, 0x27c
4200b1b8:	10c142        	addi	a4, a1, 16
4200b1bb:	631b      	addi.n	a6, a3, 1
4200b1bd:	b02240        	addx8	a2, a2, a4
4200b1c0:	682357        	blt	a3, a5, 4200b22c <_svfprintf_r+0x580>
4200b1c3:	10c182        	addi	a8, a1, 16
4200b1c6:	9a2872        	l32i	a7, a8, 0x268
4200b1c9:	02d822        	addmi	a2, a8, 0x200
4200b1cc:	f81c      	movi.n	a8, 31
4200b1ce:	374b      	addi.n	a3, a7, 4
4200b1d0:	841c      	movi.n	a4, 24
4200b1d2:	362857        	blt	a8, a5, 4200b20c <_svfprintf_r+0x560>
4200b1d5:	851b      	addi.n	a8, a5, 1
4200b1d7:	976182        	s32i	a8, a1, 0x25c
4200b1da:	1a6232        	s32i	a3, a2, 104
4200b1dd:	072437        	blt	a4, a3, 4200b1e8 <_svfprintf_r+0x53c>
4200b1e0:	192222        	l32i	a2, a2, 100
4200b1e3:	000306        	j	4200b1f3 <_svfprintf_r+0x547>
4200b1e6:	00          	.byte 00
4200b1e7:	00          	.byte 00
4200b1e8:	012477        	blt	a4, a7, 4200b1ed <_svfprintf_r+0x541>
4200b1eb:	432c      	movi.n	a3, 36
4200b1ed:	9c2122        	l32i	a2, a1, 0x270
4200b1f0:	9e6132        	s32i	a3, a1, 0x278
4200b1f3:	9e2132        	l32i	a3, a1, 0x278
4200b1f6:	10c1b2        	addi	a11, a1, 16
4200b1f9:	223a      	add.n	a2, a2, a3
4200b1fb:	fcc222        	addi	a2, a2, -4
4200b1fe:	0228      	l32i.n	a2, a2, 0
4200b200:	b055b0        	addx8	a5, a5, a11
4200b203:	0529      	s32i.n	a2, a5, 0
4200b205:	742020        	extui	a2, a2, 0, 8
4200b208:	0008c6        	j	4200b22f <_svfprintf_r+0x583>
4200b20b:	00          	.byte 00
4200b20c:	1a6232        	s32i	a3, a2, 104
4200b20f:	052437        	blt	a4, a3, 4200b218 <_svfprintf_r+0x56c>
4200b212:	192222        	l32i	a2, a2, 100
4200b215:	000286        	j	4200b223 <_svfprintf_r+0x577>
4200b218:	012477        	blt	a4, a7, 4200b21d <_svfprintf_r+0x571>
4200b21b:	432c      	movi.n	a3, 36
4200b21d:	9c2122        	l32i	a2, a1, 0x270
4200b220:	9e6132        	s32i	a3, a1, 0x278
4200b223:	9e2132        	l32i	a3, a1, 0x278
4200b226:	802230        	add	a2, a2, a3
4200b229:	fcc222        	addi	a2, a2, -4
4200b22c:	000222        	l8ui	a2, a2, 0
4200b22f:	10c142        	addi	a4, a1, 16
4200b232:	01d432        	addmi	a3, a4, 0x100
4200b235:	050c      	movi.n	a5, 0
4200b237:	804322        	s8i	a2, a3, 128
4200b23a:	9f6162        	s32i	a6, a1, 0x27c
4200b23d:	02d422        	addmi	a2, a4, 0x200
4200b240:	030c      	movi.n	a3, 0
4200b242:	160c      	movi.n	a6, 1
4200b244:	524232        	s8i	a3, a2, 82
4200b247:	a36152        	s32i	a5, a1, 0x28c
4200b24a:	a26162        	s32i	a6, a1, 0x288
4200b24d:	053d      	mov.n	a3, a5
4200b24f:	054d      	mov.n	a4, a5
4200b251:	052d      	mov.n	a2, a5
4200b253:	07b4c6        	j	4200d12a <_svfprintf_r+0x247e>
4200b256:	00          	.byte 00
4200b257:	00          	.byte 00
4200b258:	a02162        	l32i	a6, a1, 0x280
4200b25b:	051c      	movi.n	a5, 16
4200b25d:	206650        	or	a6, a6, a5
4200b260:	a06162        	s32i	a6, a1, 0x280
4200b263:	a02182        	l32i	a8, a1, 0x280
4200b266:	972152        	l32i	a5, a1, 0x25c
4200b269:	02e857        	bbsi	a8, 5, 4200b26f <_svfprintf_r+0x5c3>
4200b26c:	003206        	j	4200b338 <_svfprintf_r+0x68c>
4200b26f:	041416        	beqz	a4, 4200b2b4 <_svfprintf_r+0x608>
4200b272:	0fa257        	bge	a2, a5, 4200b285 <_svfprintf_r+0x5d9>
4200b275:	10c1a2        	addi	a10, a1, 16
4200b278:	b022a0        	addx8	a2, a2, a10
4200b27b:	0238      	l32i.n	a3, a2, 0
4200b27d:	1248      	l32i.n	a4, a2, 4
4200b27f:	9f2162        	l32i	a6, a1, 0x27c
4200b282:	00ddc6        	j	4200b5fd <_svfprintf_r+0x951>
4200b285:	58a2b2        	movi	a11, 0x258
4200b288:	10c1e2        	addi	a14, a1, 16
4200b28b:	41ba      	add.n	a4, a1, a11
4200b28d:	4ca2d2        	movi	a13, 0x24c
4200b290:	60a2c2        	movi	a12, 0x260
4200b293:	0149      	s32i.n	a4, a1, 0
4200b295:	03bd      	mov.n	a11, a3
4200b297:	01def2        	addmi	a15, a14, 0x100
4200b29a:	deda      	add.n	a13, a14, a13
4200b29c:	ceca      	add.n	a12, a14, a12
4200b29e:	02ad      	mov.n	a10, a2
4200b2a0:	b96192        	s32i	a9, a1, 0x2e4
4200b2a3:	ff5125        	call8	4200a7b4 <get_arg$constprop$0>
4200b2a6:	0a38      	l32i.n	a3, a10, 0
4200b2a8:	1a48      	l32i.n	a4, a10, 4
4200b2aa:	9f2162        	l32i	a6, a1, 0x27c
4200b2ad:	b92192        	l32i	a9, a1, 0x2e4
4200b2b0:	00d246        	j	4200b5fd <_svfprintf_r+0x951>
4200b2b3:	00          	.byte 00
4200b2b4:	9f2132        	l32i	a3, a1, 0x27c
4200b2b7:	10c142        	addi	a4, a1, 16
4200b2ba:	631b      	addi.n	a6, a3, 1
4200b2bc:	b02240        	addx8	a2, a2, a4
4200b2bf:	6d2357        	blt	a3, a5, 4200b330 <_svfprintf_r+0x684>
4200b2c2:	10c182        	addi	a8, a1, 16
4200b2c5:	9a2842        	l32i	a4, a8, 0x268
4200b2c8:	837c      	movi.n	a3, -8
4200b2ca:	447b      	addi.n	a4, a4, 7
4200b2cc:	02d822        	addmi	a2, a8, 0x200
4200b2cf:	104430        	and	a4, a4, a3
4200b2d2:	f81c      	movi.n	a8, 31
4200b2d4:	348b      	addi.n	a3, a4, 8
4200b2d6:	871c      	movi.n	a7, 24
4200b2d8:	342857        	blt	a8, a5, 4200b310 <_svfprintf_r+0x664>
4200b2db:	851b      	addi.n	a8, a5, 1
4200b2dd:	976182        	s32i	a8, a1, 0x25c
4200b2e0:	1a6232        	s32i	a3, a2, 104
4200b2e3:	052737        	blt	a7, a3, 4200b2ec <_svfprintf_r+0x640>
4200b2e6:	192222        	l32i	a2, a2, 100
4200b2e9:	000286        	j	4200b2f7 <_svfprintf_r+0x64b>
4200b2ec:	012747        	blt	a7, a4, 4200b2f1 <_svfprintf_r+0x645>
4200b2ef:	832c      	movi.n	a3, 40
4200b2f1:	9c2122        	l32i	a2, a1, 0x270
4200b2f4:	9e6132        	s32i	a3, a1, 0x278
4200b2f7:	9e2132        	l32i	a3, a1, 0x278
4200b2fa:	10c1b2        	addi	a11, a1, 16
4200b2fd:	223a      	add.n	a2, a2, a3
4200b2ff:	f8c222        	addi	a2, a2, -8
4200b302:	0238      	l32i.n	a3, a2, 0
4200b304:	1248      	l32i.n	a4, a2, 4
4200b306:	b025b0        	addx8	a2, a5, a11
4200b309:	0239      	s32i.n	a3, a2, 0
4200b30b:	1249      	s32i.n	a4, a2, 4
4200b30d:	00bb06        	j	4200b5fd <_svfprintf_r+0x951>
4200b310:	1a6232        	s32i	a3, a2, 104
4200b313:	052737        	blt	a7, a3, 4200b31c <_svfprintf_r+0x670>
4200b316:	192222        	l32i	a2, a2, 100
4200b319:	000286        	j	4200b327 <_svfprintf_r+0x67b>
4200b31c:	012747        	blt	a7, a4, 4200b321 <_svfprintf_r+0x675>
4200b31f:	832c      	movi.n	a3, 40
4200b321:	9c2122        	l32i	a2, a1, 0x270
4200b324:	9e6132        	s32i	a3, a1, 0x278
4200b327:	9e2132        	l32i	a3, a1, 0x278
4200b32a:	802230        	add	a2, a2, a3
4200b32d:	f8c222        	addi	a2, a2, -8
4200b330:	0238      	l32i.n	a3, a2, 0
4200b332:	1248      	l32i.n	a4, a2, 4
4200b334:	00b146        	j	4200b5fd <_svfprintf_r+0x951>
4200b337:	00          	.byte 00
4200b338:	a02162        	l32i	a6, a1, 0x280
4200b33b:	796647        	bbci	a6, 4, 4200b3b8 <_svfprintf_r+0x70c>
4200b33e:	f49c      	beqz.n	a4, 4200b361 <_svfprintf_r+0x6b5>
4200b340:	08a257        	bge	a2, a5, 4200b34c <_svfprintf_r+0x6a0>
4200b343:	10c182        	addi	a8, a1, 16
4200b346:	b02280        	addx8	a2, a2, a8
4200b349:	0080c6        	j	4200b550 <_svfprintf_r+0x8a4>
4200b34c:	58a2a2        	movi	a10, 0x258
4200b34f:	10c1b2        	addi	a11, a1, 16
4200b352:	41aa      	add.n	a4, a1, a10
4200b354:	0149      	s32i.n	a4, a1, 0
4200b356:	01dbf2        	addmi	a15, a11, 0x100
4200b359:	4ca2d2        	movi	a13, 0x24c
4200b35c:	0bed      	mov.n	a14, a11
4200b35e:	008246        	j	4200b56b <_svfprintf_r+0x8bf>
4200b361:	9f2132        	l32i	a3, a1, 0x27c
4200b364:	10c142        	addi	a4, a1, 16
4200b367:	631b      	addi.n	a6, a3, 1
4200b369:	b02240        	addx8	a2, a2, a4
4200b36c:	02a357        	bge	a3, a5, 4200b372 <_svfprintf_r+0x6c6>
4200b36f:	00a146        	j	4200b5f8 <_svfprintf_r+0x94c>
4200b372:	10c182        	addi	a8, a1, 16
4200b375:	9a2872        	l32i	a7, a8, 0x268
4200b378:	02d822        	addmi	a2, a8, 0x200
4200b37b:	f81c      	movi.n	a8, 31
4200b37d:	374b      	addi.n	a3, a7, 4
4200b37f:	841c      	movi.n	a4, 24
4200b381:	02a857        	bge	a8, a5, 4200b387 <_svfprintf_r+0x6db>
4200b384:	009446        	j	4200b5d9 <_svfprintf_r+0x92d>
4200b387:	851b      	addi.n	a8, a5, 1
4200b389:	976182        	s32i	a8, a1, 0x25c
4200b38c:	1a6232        	s32i	a3, a2, 104
4200b38f:	052437        	blt	a4, a3, 4200b398 <_svfprintf_r+0x6ec>
4200b392:	192222        	l32i	a2, a2, 100
4200b395:	000286        	j	4200b3a3 <_svfprintf_r+0x6f7>
4200b398:	012477        	blt	a4, a7, 4200b39d <_svfprintf_r+0x6f1>
4200b39b:	432c      	movi.n	a3, 36
4200b39d:	9c2122        	l32i	a2, a1, 0x270
4200b3a0:	9e6132        	s32i	a3, a1, 0x278
4200b3a3:	9e2132        	l32i	a3, a1, 0x278
4200b3a6:	10c1b2        	addi	a11, a1, 16
4200b3a9:	223a      	add.n	a2, a2, a3
4200b3ab:	fcc222        	addi	a2, a2, -4
4200b3ae:	0238      	l32i.n	a3, a2, 0
4200b3b0:	b025b0        	addx8	a2, a5, a11
4200b3b3:	0239      	s32i.n	a3, a2, 0
4200b3b5:	009046        	j	4200b5fa <_svfprintf_r+0x94e>
4200b3b8:	a02162        	l32i	a6, a1, 0x280
4200b3bb:	02e667        	bbsi	a6, 6, 4200b3c1 <_svfprintf_r+0x715>
4200b3be:	002e86        	j	4200b47c <_svfprintf_r+0x7d0>
4200b3c1:	b4bc      	beqz.n	a4, 4200b400 <_svfprintf_r+0x754>
4200b3c3:	0ea257        	bge	a2, a5, 4200b3d5 <_svfprintf_r+0x729>
4200b3c6:	10c182        	addi	a8, a1, 16
4200b3c9:	b02280        	addx8	a2, a2, a8
4200b3cc:	009232        	l16si	a3, a2, 0
4200b3cf:	005fc6        	j	4200b552 <_svfprintf_r+0x8a6>
4200b3d2:	00          	.byte 00
4200b3d3:	00          	.byte 00
4200b3d4:	00          	.byte 00
4200b3d5:	58a2a2        	movi	a10, 0x258
4200b3d8:	10c1b2        	addi	a11, a1, 16
4200b3db:	41aa      	add.n	a4, a1, a10
4200b3dd:	4ca2d2        	movi	a13, 0x24c
4200b3e0:	60a2c2        	movi	a12, 0x260
4200b3e3:	01dbf2        	addmi	a15, a11, 0x100
4200b3e6:	0bed      	mov.n	a14, a11
4200b3e8:	dbda      	add.n	a13, a11, a13
4200b3ea:	cbca      	add.n	a12, a11, a12
4200b3ec:	0149      	s32i.n	a4, a1, 0
4200b3ee:	03bd      	mov.n	a11, a3
4200b3f0:	02ad      	mov.n	a10, a2
4200b3f2:	b96192        	s32i	a9, a1, 0x2e4
4200b3f5:	ff3be5        	call8	4200a7b4 <get_arg$constprop$0>
4200b3f8:	009a32        	l16si	a3, a10, 0
4200b3fb:	005fc6        	j	4200b57e <_svfprintf_r+0x8d2>
4200b3fe:	00          	.byte 00
4200b3ff:	00          	.byte 00
4200b400:	9f2132        	l32i	a3, a1, 0x27c
4200b403:	10c142        	addi	a4, a1, 16
4200b406:	631b      	addi.n	a6, a3, 1
4200b408:	b02240        	addx8	a2, a2, a4
4200b40b:	652357        	blt	a3, a5, 4200b474 <_svfprintf_r+0x7c8>
4200b40e:	10c182        	addi	a8, a1, 16
4200b411:	9a2872        	l32i	a7, a8, 0x268
4200b414:	02d822        	addmi	a2, a8, 0x200
4200b417:	f81c      	movi.n	a8, 31
4200b419:	374b      	addi.n	a3, a7, 4
4200b41b:	841c      	movi.n	a4, 24
4200b41d:	332857        	blt	a8, a5, 4200b454 <_svfprintf_r+0x7a8>
4200b420:	851b      	addi.n	a8, a5, 1
4200b422:	976182        	s32i	a8, a1, 0x25c
4200b425:	1a6232        	s32i	a3, a2, 104
4200b428:	052437        	blt	a4, a3, 4200b431 <_svfprintf_r+0x785>
4200b42b:	192222        	l32i	a2, a2, 100
4200b42e:	000286        	j	4200b43c <_svfprintf_r+0x790>
4200b431:	012477        	blt	a4, a7, 4200b436 <_svfprintf_r+0x78a>
4200b434:	432c      	movi.n	a3, 36
4200b436:	9c2122        	l32i	a2, a1, 0x270
4200b439:	9e6132        	s32i	a3, a1, 0x278
4200b43c:	9e2132        	l32i	a3, a1, 0x278
4200b43f:	10c1b2        	addi	a11, a1, 16
4200b442:	223a      	add.n	a2, a2, a3
4200b444:	fcc222        	addi	a2, a2, -4
4200b447:	0238      	l32i.n	a3, a2, 0
4200b449:	b025b0        	addx8	a2, a5, a11
4200b44c:	0239      	s32i.n	a3, a2, 0
4200b44e:	233380        	sext	a3, a3, 15
4200b451:	006946        	j	4200b5fa <_svfprintf_r+0x94e>
4200b454:	1a6232        	s32i	a3, a2, 104
4200b457:	052437        	blt	a4, a3, 4200b460 <_svfprintf_r+0x7b4>
4200b45a:	192222        	l32i	a2, a2, 100
4200b45d:	000286        	j	4200b46b <_svfprintf_r+0x7bf>
4200b460:	012477        	blt	a4, a7, 4200b465 <_svfprintf_r+0x7b9>
4200b463:	432c      	movi.n	a3, 36
4200b465:	9c2122        	l32i	a2, a1, 0x270
4200b468:	9e6132        	s32i	a3, a1, 0x278
4200b46b:	9e2132        	l32i	a3, a1, 0x278
4200b46e:	802230        	add	a2, a2, a3
4200b471:	fcc222        	addi	a2, a2, -4
4200b474:	009232        	l16si	a3, a2, 0
4200b477:	005fc6        	j	4200b5fa <_svfprintf_r+0x94e>
4200b47a:	00          	.byte 00
4200b47b:	00          	.byte 00
4200b47c:	a02162        	l32i	a6, a1, 0x280
4200b47f:	02e697        	bbsi	a6, 9, 4200b485 <_svfprintf_r+0x7d9>
4200b482:	002fc6        	j	4200b545 <_svfprintf_r+0x899>
4200b485:	f4bc      	beqz.n	a4, 4200b4c8 <_svfprintf_r+0x81c>
4200b487:	0ea257        	bge	a2, a5, 4200b499 <_svfprintf_r+0x7ed>
4200b48a:	10c182        	addi	a8, a1, 16
4200b48d:	b02280        	addx8	a2, a2, a8
4200b490:	000232        	l8ui	a3, a2, 0
4200b493:	9f2162        	l32i	a6, a1, 0x27c
4200b496:	002946        	j	4200b53f <_svfprintf_r+0x893>
4200b499:	58a2a2        	movi	a10, 0x258
4200b49c:	10c1b2        	addi	a11, a1, 16
4200b49f:	41aa      	add.n	a4, a1, a10
4200b4a1:	4ca2d2        	movi	a13, 0x24c
4200b4a4:	60a2c2        	movi	a12, 0x260
4200b4a7:	01dbf2        	addmi	a15, a11, 0x100
4200b4aa:	0bed      	mov.n	a14, a11
4200b4ac:	dbda      	add.n	a13, a11, a13
4200b4ae:	cbca      	add.n	a12, a11, a12
4200b4b0:	0149      	s32i.n	a4, a1, 0
4200b4b2:	03bd      	mov.n	a11, a3
4200b4b4:	02ad      	mov.n	a10, a2
4200b4b6:	b96192        	s32i	a9, a1, 0x2e4
4200b4b9:	ff2fa5        	call8	4200a7b4 <get_arg$constprop$0>
4200b4bc:	000a32        	l8ui	a3, a10, 0
4200b4bf:	9f2162        	l32i	a6, a1, 0x27c
4200b4c2:	b92192        	l32i	a9, a1, 0x2e4
4200b4c5:	001d86        	j	4200b53f <_svfprintf_r+0x893>
4200b4c8:	9f2132        	l32i	a3, a1, 0x27c
4200b4cb:	10c142        	addi	a4, a1, 16
4200b4ce:	631b      	addi.n	a6, a3, 1
4200b4d0:	b02240        	addx8	a2, a2, a4
4200b4d3:	652357        	blt	a3, a5, 4200b53c <_svfprintf_r+0x890>
4200b4d6:	10c182        	addi	a8, a1, 16
4200b4d9:	9a2872        	l32i	a7, a8, 0x268
4200b4dc:	02d822        	addmi	a2, a8, 0x200
4200b4df:	f81c      	movi.n	a8, 31
4200b4e1:	374b      	addi.n	a3, a7, 4
4200b4e3:	841c      	movi.n	a4, 24
4200b4e5:	332857        	blt	a8, a5, 4200b51c <_svfprintf_r+0x870>
4200b4e8:	851b      	addi.n	a8, a5, 1
4200b4ea:	976182        	s32i	a8, a1, 0x25c
4200b4ed:	1a6232        	s32i	a3, a2, 104
4200b4f0:	052437        	blt	a4, a3, 4200b4f9 <_svfprintf_r+0x84d>
4200b4f3:	192222        	l32i	a2, a2, 100
4200b4f6:	000286        	j	4200b504 <_svfprintf_r+0x858>
4200b4f9:	012477        	blt	a4, a7, 4200b4fe <_svfprintf_r+0x852>
4200b4fc:	432c      	movi.n	a3, 36
4200b4fe:	9c2122        	l32i	a2, a1, 0x270
4200b501:	9e6132        	s32i	a3, a1, 0x278
4200b504:	9e2132        	l32i	a3, a1, 0x278
4200b507:	10c1b2        	addi	a11, a1, 16
4200b50a:	223a      	add.n	a2, a2, a3
4200b50c:	fcc222        	addi	a2, a2, -4
4200b50f:	0238      	l32i.n	a3, a2, 0
4200b511:	b025b0        	addx8	a2, a5, a11
4200b514:	0239      	s32i.n	a3, a2, 0
4200b516:	743030        	extui	a3, a3, 0, 8
4200b519:	000886        	j	4200b53f <_svfprintf_r+0x893>
4200b51c:	1a6232        	s32i	a3, a2, 104
4200b51f:	052437        	blt	a4, a3, 4200b528 <_svfprintf_r+0x87c>
4200b522:	192222        	l32i	a2, a2, 100
4200b525:	000286        	j	4200b533 <_svfprintf_r+0x887>
4200b528:	012477        	blt	a4, a7, 4200b52d <_svfprintf_r+0x881>
4200b52b:	432c      	movi.n	a3, 36
4200b52d:	9c2122        	l32i	a2, a1, 0x270
4200b530:	9e6132        	s32i	a3, a1, 0x278
4200b533:	9e2132        	l32i	a3, a1, 0x278
4200b536:	802230        	add	a2, a2, a3
4200b539:	fcc222        	addi	a2, a2, -4
4200b53c:	000232        	l8ui	a3, a2, 0
4200b53f:	233300        	sext	a3, a3, 7
4200b542:	002d06        	j	4200b5fa <_svfprintf_r+0x94e>
4200b545:	f4bc      	beqz.n	a4, 4200b588 <_svfprintf_r+0x8dc>
4200b547:	0ea257        	bge	a2, a5, 4200b559 <_svfprintf_r+0x8ad>
4200b54a:	10c132        	addi	a3, a1, 16
4200b54d:	b02230        	addx8	a2, a2, a3
4200b550:	0238      	l32i.n	a3, a2, 0
4200b552:	9f2162        	l32i	a6, a1, 0x27c
4200b555:	002846        	j	4200b5fa <_svfprintf_r+0x94e>
4200b558:	00          	.byte 00
4200b559:	58a252        	movi	a5, 0x258
4200b55c:	10c162        	addi	a6, a1, 16
4200b55f:	415a      	add.n	a4, a1, a5
4200b561:	0149      	s32i.n	a4, a1, 0
4200b563:	01d6f2        	addmi	a15, a6, 0x100
4200b566:	4ca2d2        	movi	a13, 0x24c
4200b569:	06ed      	mov.n	a14, a6
4200b56b:	60a2c2        	movi	a12, 0x260
4200b56e:	03bd      	mov.n	a11, a3
4200b570:	deda      	add.n	a13, a14, a13
4200b572:	ceca      	add.n	a12, a14, a12
4200b574:	02ad      	mov.n	a10, a2
4200b576:	b96192        	s32i	a9, a1, 0x2e4
4200b579:	ff23a5        	call8	4200a7b4 <get_arg$constprop$0>
4200b57c:	0a38      	l32i.n	a3, a10, 0
4200b57e:	9f2162        	l32i	a6, a1, 0x27c
4200b581:	b92192        	l32i	a9, a1, 0x2e4
4200b584:	001c86        	j	4200b5fa <_svfprintf_r+0x94e>
4200b587:	00          	.byte 00
4200b588:	9f2182        	l32i	a8, a1, 0x27c
4200b58b:	10c1a2        	addi	a10, a1, 16
4200b58e:	681b      	addi.n	a6, a8, 1
4200b590:	b022a0        	addx8	a2, a2, a10
4200b593:	612857        	blt	a8, a5, 4200b5f8 <_svfprintf_r+0x94c>
4200b596:	10c1b2        	addi	a11, a1, 16
4200b599:	9a2b72        	l32i	a7, a11, 0x268
4200b59c:	f81c      	movi.n	a8, 31
4200b59e:	02db22        	addmi	a2, a11, 0x200
4200b5a1:	374b      	addi.n	a3, a7, 4
4200b5a3:	841c      	movi.n	a4, 24
4200b5a5:	302857        	blt	a8, a5, 4200b5d9 <_svfprintf_r+0x92d>
4200b5a8:	851b      	addi.n	a8, a5, 1
4200b5aa:	976182        	s32i	a8, a1, 0x25c
4200b5ad:	1a6232        	s32i	a3, a2, 104
4200b5b0:	052437        	blt	a4, a3, 4200b5b9 <_svfprintf_r+0x90d>
4200b5b3:	192222        	l32i	a2, a2, 100
4200b5b6:	000286        	j	4200b5c4 <_svfprintf_r+0x918>
4200b5b9:	012477        	blt	a4, a7, 4200b5be <_svfprintf_r+0x912>
4200b5bc:	432c      	movi.n	a3, 36
4200b5be:	9c2122        	l32i	a2, a1, 0x270
4200b5c1:	9e6132        	s32i	a3, a1, 0x278
4200b5c4:	9e2132        	l32i	a3, a1, 0x278
4200b5c7:	223a      	add.n	a2, a2, a3
4200b5c9:	fcc222        	addi	a2, a2, -4
4200b5cc:	0238      	l32i.n	a3, a2, 0
4200b5ce:	10c122        	addi	a2, a1, 16
4200b5d1:	b05520        	addx8	a5, a5, a2
4200b5d4:	0539      	s32i.n	a3, a5, 0
4200b5d6:	000806        	j	4200b5fa <_svfprintf_r+0x94e>
4200b5d9:	1a6232        	s32i	a3, a2, 104
4200b5dc:	052437        	blt	a4, a3, 4200b5e5 <_svfprintf_r+0x939>
4200b5df:	192222        	l32i	a2, a2, 100
4200b5e2:	000286        	j	4200b5f0 <_svfprintf_r+0x944>
4200b5e5:	012477        	blt	a4, a7, 4200b5ea <_svfprintf_r+0x93e>
4200b5e8:	432c      	movi.n	a3, 36
4200b5ea:	9c2122        	l32i	a2, a1, 0x270
4200b5ed:	9e6132        	s32i	a3, a1, 0x278
4200b5f0:	9e2132        	l32i	a3, a1, 0x278
4200b5f3:	223a      	add.n	a2, a2, a3
4200b5f5:	fcc222        	addi	a2, a2, -4
4200b5f8:	0238      	l32i.n	a3, a2, 0
4200b5fa:	314f30        	srai	a4, a3, 31
4200b5fd:	9f6162        	s32i	a6, a1, 0x27c
4200b600:	002496        	bltz	a4, 4200b606 <_svfprintf_r+0x95a>
4200b603:	09a046        	j	4200dc88 <_svfprintf_r+0x2fdc>
4200b606:	603030        	neg	a3, a3
4200b609:	120c      	movi.n	a2, 1
4200b60b:	050c      	movi.n	a5, 0
4200b60d:	935230        	movnez	a5, a2, a3
4200b610:	604040        	neg	a4, a4
4200b613:	c04450        	sub	a4, a4, a5
4200b616:	d62c      	movi.n	a6, 45
4200b618:	0636c6        	j	4200cef7 <_svfprintf_r+0x224b>
4200b61b:	a02162        	l32i	a6, a1, 0x280
4200b61e:	972152        	l32i	a5, a1, 0x25c
4200b621:	786637        	bbci	a6, 3, 4200b69d <_svfprintf_r+0x9f1>
4200b624:	d48c      	beqz.n	a4, 4200b635 <_svfprintf_r+0x989>
4200b626:	022257        	blt	a2, a5, 4200b62c <_svfprintf_r+0x980>
4200b629:	002306        	j	4200b6b9 <_svfprintf_r+0xa0d>
4200b62c:	10c182        	addi	a8, a1, 16
4200b62f:	b02280        	addx8	a2, a2, a8
4200b632:	001cc6        	j	4200b6a9 <_svfprintf_r+0x9fd>
4200b635:	9f2132        	l32i	a3, a1, 0x27c
4200b638:	731b      	addi.n	a7, a3, 1
4200b63a:	02a357        	bge	a3, a5, 4200b640 <_svfprintf_r+0x994>
4200b63d:	002cc6        	j	4200b6f4 <_svfprintf_r+0xa48>
4200b640:	10c162        	addi	a6, a1, 16
4200b643:	9a2642        	l32i	a4, a6, 0x268
4200b646:	837c      	movi.n	a3, -8
4200b648:	447b      	addi.n	a4, a4, 7
4200b64a:	104430        	and	a4, a4, a3
4200b64d:	f81c      	movi.n	a8, 31
4200b64f:	02d622        	addmi	a2, a6, 0x200
4200b652:	348b      	addi.n	a3, a4, 8
4200b654:	861c      	movi.n	a6, 24
4200b656:	02a857        	bge	a8, a5, 4200b65c <_svfprintf_r+0x9b0>
4200b659:	003ec6        	j	4200b758 <_svfprintf_r+0xaac>
4200b65c:	851b      	addi.n	a8, a5, 1
4200b65e:	976182        	s32i	a8, a1, 0x25c
4200b661:	1a6232        	s32i	a3, a2, 104
4200b664:	052637        	blt	a6, a3, 4200b66d <_svfprintf_r+0x9c1>
4200b667:	192222        	l32i	a2, a2, 100
4200b66a:	000286        	j	4200b678 <_svfprintf_r+0x9cc>
4200b66d:	012647        	blt	a6, a4, 4200b672 <_svfprintf_r+0x9c6>
4200b670:	832c      	movi.n	a3, 40
4200b672:	9c2122        	l32i	a2, a1, 0x270
4200b675:	9e6132        	s32i	a3, a1, 0x278
4200b678:	9e2132        	l32i	a3, a1, 0x278
4200b67b:	223a      	add.n	a2, a2, a3
4200b67d:	f8c222        	addi	a2, a2, -8
4200b680:	12b8      	l32i.n	a11, a2, 4
4200b682:	02a8      	l32i.n	a10, a2, 0
4200b684:	a961b2        	s32i	a11, a1, 0x2a4
4200b687:	a861a2        	s32i	a10, a1, 0x2a0
4200b68a:	10c1b2        	addi	a11, a1, 16
4200b68d:	b025b0        	addx8	a2, a5, a11
4200b690:	a82142        	l32i	a4, a1, 0x2a0
4200b693:	a92152        	l32i	a5, a1, 0x2a4
4200b696:	0249      	s32i.n	a4, a2, 0
4200b698:	1259      	s32i.n	a5, a2, 4
4200b69a:	0038c6        	j	4200b781 <_svfprintf_r+0xad5>
4200b69d:	04b416        	beqz	a4, 4200b6ec <_svfprintf_r+0xa40>
4200b6a0:	15a257        	bge	a2, a5, 4200b6b9 <_svfprintf_r+0xa0d>
4200b6a3:	10c152        	addi	a5, a1, 16
4200b6a6:	b02250        	addx8	a2, a2, a5
4200b6a9:	0248      	l32i.n	a4, a2, 0
4200b6ab:	1258      	l32i.n	a5, a2, 4
4200b6ad:	a86142        	s32i	a4, a1, 0x2a0
4200b6b0:	a96152        	s32i	a5, a1, 0x2a4
4200b6b3:	003346        	j	4200b784 <_svfprintf_r+0xad8>
4200b6b6:	00          	.byte 00
4200b6b7:	00          	.byte 00
4200b6b8:	00          	.byte 00
4200b6b9:	58a252        	movi	a5, 0x258
4200b6bc:	10c162        	addi	a6, a1, 16
4200b6bf:	415a      	add.n	a4, a1, a5
4200b6c1:	4ca2d2        	movi	a13, 0x24c
4200b6c4:	60a2c2        	movi	a12, 0x260
4200b6c7:	03bd      	mov.n	a11, a3
4200b6c9:	02ad      	mov.n	a10, a2
4200b6cb:	0149      	s32i.n	a4, a1, 0
4200b6cd:	01d6f2        	addmi	a15, a6, 0x100
4200b6d0:	06ed      	mov.n	a14, a6
4200b6d2:	d6da      	add.n	a13, a6, a13
4200b6d4:	c6ca      	add.n	a12, a6, a12
4200b6d6:	b96192        	s32i	a9, a1, 0x2e4
4200b6d9:	ff0da5        	call8	4200a7b4 <get_arg$constprop$0>
4200b6dc:	0a28      	l32i.n	a2, a10, 0
4200b6de:	1a38      	l32i.n	a3, a10, 4
4200b6e0:	b92192        	l32i	a9, a1, 0x2e4
4200b6e3:	a86122        	s32i	a2, a1, 0x2a0
4200b6e6:	a96132        	s32i	a3, a1, 0x2a4
4200b6e9:	0025c6        	j	4200b784 <_svfprintf_r+0xad8>
4200b6ec:	9f2132        	l32i	a3, a1, 0x27c
4200b6ef:	731b      	addi.n	a7, a3, 1
4200b6f1:	08a357        	bge	a3, a5, 4200b6fd <_svfprintf_r+0xa51>
4200b6f4:	10c142        	addi	a4, a1, 16
4200b6f7:	b02240        	addx8	a2, a2, a4
4200b6fa:	001e46        	j	4200b777 <_svfprintf_r+0xacb>
4200b6fd:	10c162        	addi	a6, a1, 16
4200b700:	9a2642        	l32i	a4, a6, 0x268
4200b703:	837c      	movi.n	a3, -8
4200b705:	447b      	addi.n	a4, a4, 7
4200b707:	104430        	and	a4, a4, a3
4200b70a:	f81c      	movi.n	a8, 31
4200b70c:	02d622        	addmi	a2, a6, 0x200
4200b70f:	348b      	addi.n	a3, a4, 8
4200b711:	861c      	movi.n	a6, 24
4200b713:	412857        	blt	a8, a5, 4200b758 <_svfprintf_r+0xaac>
4200b716:	851b      	addi.n	a8, a5, 1
4200b718:	976182        	s32i	a8, a1, 0x25c
4200b71b:	1a6232        	s32i	a3, a2, 104
4200b71e:	052637        	blt	a6, a3, 4200b727 <_svfprintf_r+0xa7b>
4200b721:	192222        	l32i	a2, a2, 100
4200b724:	000286        	j	4200b732 <_svfprintf_r+0xa86>
4200b727:	012647        	blt	a6, a4, 4200b72c <_svfprintf_r+0xa80>
4200b72a:	832c      	movi.n	a3, 40
4200b72c:	9c2122        	l32i	a2, a1, 0x270
4200b72f:	9e6132        	s32i	a3, a1, 0x278
4200b732:	9e2132        	l32i	a3, a1, 0x278
4200b735:	223a      	add.n	a2, a2, a3
4200b737:	f8c222        	addi	a2, a2, -8
4200b73a:	12b8      	l32i.n	a11, a2, 4
4200b73c:	02a8      	l32i.n	a10, a2, 0
4200b73e:	a961b2        	s32i	a11, a1, 0x2a4
4200b741:	a861a2        	s32i	a10, a1, 0x2a0
4200b744:	a82122        	l32i	a2, a1, 0x2a0
4200b747:	a92132        	l32i	a3, a1, 0x2a4
4200b74a:	10c1b2        	addi	a11, a1, 16
4200b74d:	b055b0        	addx8	a5, a5, a11
4200b750:	0529      	s32i.n	a2, a5, 0
4200b752:	1539      	s32i.n	a3, a5, 4
4200b754:	000a46        	j	4200b781 <_svfprintf_r+0xad5>
4200b757:	00          	.byte 00
4200b758:	1a6232        	s32i	a3, a2, 104
4200b75b:	052637        	blt	a6, a3, 4200b764 <_svfprintf_r+0xab8>
4200b75e:	192222        	l32i	a2, a2, 100
4200b761:	000286        	j	4200b76f <_svfprintf_r+0xac3>
4200b764:	012647        	blt	a6, a4, 4200b769 <_svfprintf_r+0xabd>
4200b767:	832c      	movi.n	a3, 40
4200b769:	9c2122        	l32i	a2, a1, 0x270
4200b76c:	9e6132        	s32i	a3, a1, 0x278
4200b76f:	9e2132        	l32i	a3, a1, 0x278
4200b772:	223a      	add.n	a2, a2, a3
4200b774:	f8c222        	addi	a2, a2, -8
4200b777:	0248      	l32i.n	a4, a2, 0
4200b779:	1258      	l32i.n	a5, a2, 4
4200b77b:	a86142        	s32i	a4, a1, 0x2a0
4200b77e:	a96152        	s32i	a5, a1, 0x2a4
4200b781:	9f6172        	s32i	a7, a1, 0x27c
4200b784:	d31341        	l32r	a4, 420003d0 <_stext+0x3b0>
4200b787:	a92162        	l32i	a6, a1, 0x2a4
4200b78a:	a82152        	l32i	a5, a1, 0x2a0
4200b78d:	d51221        	l32r	a2, 42000bd8 <_stext+0xbb8>
4200b790:	d51331        	l32r	a3, 42000bdc <_stext+0xbbc>
4200b793:	104640        	and	a4, a6, a4
4200b796:	02cd      	mov.n	a12, a2
4200b798:	03dd      	mov.n	a13, a3
4200b79a:	05ad      	mov.n	a10, a5
4200b79c:	20b440        	or	a11, a4, a4
4200b79f:	b96192        	s32i	a9, a1, 0x2e4
4200b7a2:	d51581        	l32r	a8, 42000bf8 <_stext+0xbd8>
4200b7a5:	0008e0        	callx8	a8
4200b7a8:	b92192        	l32i	a9, a1, 0x2e4
4200b7ab:	eaec      	bnez.n	a10, 4200b7dd <_svfprintf_r+0xb31>
4200b7ad:	02cd      	mov.n	a12, a2
4200b7af:	03dd      	mov.n	a13, a3
4200b7b1:	05ad      	mov.n	a10, a5
4200b7b3:	20b440        	or	a11, a4, a4
4200b7b6:	d51181        	l32r	a8, 42000bfc <_stext+0xbdc>
4200b7b9:	0008e0        	callx8	a8
4200b7bc:	b92192        	l32i	a9, a1, 0x2e4
4200b7bf:	1a1aa6        	blti	a10, 1, 4200b7dd <_svfprintf_r+0xb31>
4200b7c2:	d40bc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200b7c5:	d40ad1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200b7c8:	a821a2        	l32i	a10, a1, 0x2a0
4200b7cb:	a921b2        	l32i	a11, a1, 0x2a4
4200b7ce:	d50c81        	l32r	a8, 42000c00 <_stext+0xbe0>
4200b7d1:	0008e0        	callx8	a8
4200b7d4:	b92192        	l32i	a9, a1, 0x2e4
4200b7d7:	029ad6        	bgez	a10, 4200b804 <_svfprintf_r+0xb58>
4200b7da:	0006c6        	j	4200b7f9 <_svfprintf_r+0xb4d>
4200b7dd:	a821c2        	l32i	a12, a1, 0x2a0
4200b7e0:	a921d2        	l32i	a13, a1, 0x2a4
4200b7e3:	0cad      	mov.n	a10, a12
4200b7e5:	0dbd      	mov.n	a11, a13
4200b7e7:	b96192        	s32i	a9, a1, 0x2e4
4200b7ea:	d50381        	l32r	a8, 42000bf8 <_stext+0xbd8>
4200b7ed:	0008e0        	callx8	a8
4200b7f0:	b92192        	l32i	a9, a1, 0x2e4
4200b7f3:	065a16        	beqz	a10, 4200b85c <_svfprintf_r+0xbb0>
4200b7f6:	000786        	j	4200b818 <_svfprintf_r+0xb6c>
4200b7f9:	10c182        	addi	a8, a1, 16
4200b7fc:	02d822        	addmi	a2, a8, 0x200
4200b7ff:	d32c      	movi.n	a3, 45
4200b801:	524232        	s8i	a3, a2, 82
4200b804:	d4ee31        	l32r	a3, 42000bbc <_stext+0xb9c>
4200b807:	a72142        	l32i	a4, a1, 0x29c
4200b80a:	724c      	movi.n	a2, 71
4200b80c:	a16132        	s32i	a3, a1, 0x284
4200b80f:	d4ec81        	l32r	a8, 42000bc0 <_stext+0xba0>
4200b812:	242247        	blt	a2, a4, 4200b83a <_svfprintf_r+0xb8e>
4200b815:	000906        	j	4200b83d <_svfprintf_r+0xb91>
4200b818:	a92162        	l32i	a6, a1, 0x2a4
4200b81b:	00a6d6        	bgez	a6, 4200b829 <_svfprintf_r+0xb7d>
4200b81e:	10c182        	addi	a8, a1, 16
4200b821:	02d822        	addmi	a2, a8, 0x200
4200b824:	d32c      	movi.n	a3, 45
4200b826:	524232        	s8i	a3, a2, 82
4200b829:	d4e631        	l32r	a3, 42000bc4 <_stext+0xba4>
4200b82c:	a72142        	l32i	a4, a1, 0x29c
4200b82f:	724c      	movi.n	a2, 71
4200b831:	a16132        	s32i	a3, a1, 0x284
4200b834:	05a247        	bge	a2, a4, 4200b83d <_svfprintf_r+0xb91>
4200b837:	d4e481        	l32r	a8, 42000bc8 <_stext+0xba8>
4200b83a:	a16182        	s32i	a8, a1, 0x284
4200b83d:	a02132        	l32i	a3, a1, 0x280
4200b840:	7faf22        	movi	a2, -129
4200b843:	040c      	movi.n	a4, 0
4200b845:	103320        	and	a3, a3, a2
4200b848:	350c      	movi.n	a5, 3
4200b84a:	a06132        	s32i	a3, a1, 0x280
4200b84d:	a26152        	s32i	a5, a1, 0x288
4200b850:	a36142        	s32i	a4, a1, 0x28c
4200b853:	045d      	mov.n	a5, a4
4200b855:	043d      	mov.n	a3, a4
4200b857:	0637c6        	j	4200d13a <_svfprintf_r+0x248e>
4200b85a:	00          	.byte 00
4200b85b:	00          	.byte 00
4200b85c:	a72162        	l32i	a6, a1, 0x29c
4200b85f:	dfaf22        	movi	a2, -33
4200b862:	107620        	and	a7, a6, a2
4200b865:	124c      	movi.n	a2, 65
4200b867:	559727        	bne	a7, a2, 4200b8c0 <_svfprintf_r+0xc14>
4200b86a:	10c182        	addi	a8, a1, 16
4200b86d:	02d842        	addmi	a4, a8, 0x200
4200b870:	023c      	movi.n	a2, 48
4200b872:	504422        	s8i	a2, a4, 80
4200b875:	9fc632        	addi	a3, a6, -97
4200b878:	78a022        	movi	a2, 120
4200b87b:	855c      	movi.n	a5, 88
4200b87d:	932530        	movnez	a2, a5, a3
4200b880:	a02132        	l32i	a3, a1, 0x280
4200b883:	514422        	s8i	a2, a4, 81
4200b886:	220c      	movi.n	a2, 2
4200b888:	203320        	or	a3, a3, a2
4200b88b:	a22142        	l32i	a4, a1, 0x288
4200b88e:	a06132        	s32i	a3, a1, 0x280
4200b891:	63a022        	movi	a2, 99
4200b894:	54a247        	bge	a2, a4, 4200b8ec <_svfprintf_r+0xc40>
4200b897:	a421a2        	l32i	a10, a1, 0x290
4200b89a:	b41b      	addi.n	a11, a4, 1
4200b89c:	b96192        	s32i	a9, a1, 0x2e4
4200b89f:	d4ad81        	l32r	a8, 42000b54 <_stext+0xb34>
4200b8a2:	0008e0        	callx8	a8
4200b8a5:	a161a2        	s32i	a10, a1, 0x284
4200b8a8:	b92192        	l32i	a9, a1, 0x2e4
4200b8ab:	04da56        	bnez	a10, 4200b8fc <_svfprintf_r+0xc50>
4200b8ae:	a52182        	l32i	a8, a1, 0x294
4200b8b1:	034c      	movi.n	a3, 64
4200b8b3:	061822        	l16ui	a2, a8, 12
4200b8b6:	202230        	or	a2, a2, a3
4200b8b9:	065822        	s16i	a2, a8, 12
4200b8bc:	08e306        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200b8bf:	00          	.byte 00
4200b8c0:	a22122        	l32i	a2, a1, 0x288
4200b8c3:	3e0226        	beqi	a2, -1, 4200b905 <_svfprintf_r+0xc59>
4200b8c6:	a22142        	l32i	a4, a1, 0x288
4200b8c9:	130c      	movi.n	a3, 1
4200b8cb:	0a2d      	mov.n	a2, a10
4200b8cd:	832340        	moveqz	a2, a3, a4
4200b8d0:	742020        	extui	a2, a2, 0, 8
4200b8d3:	b28c      	beqz.n	a2, 4200b8e2 <_svfprintf_r+0xc36>
4200b8d5:	b9c742        	addi	a4, a7, -71
4200b8d8:	0a2d      	mov.n	a2, a10
4200b8da:	832340        	moveqz	a2, a3, a4
4200b8dd:	742020        	extui	a2, a2, 0, 8
4200b8e0:	92ec      	bnez.n	a2, 4200b90d <_svfprintf_r+0xc61>
4200b8e2:	050c      	movi.n	a5, 0
4200b8e4:	a36152        	s32i	a5, a1, 0x28c
4200b8e7:	000a06        	j	4200b913 <_svfprintf_r+0xc67>
4200b8ea:	00          	.byte 00
4200b8eb:	00          	.byte 00
4200b8ec:	90a182        	movi	a8, 0x190
4200b8ef:	818a      	add.n	a8, a1, a8
4200b8f1:	a361a2        	s32i	a10, a1, 0x28c
4200b8f4:	a16182        	s32i	a8, a1, 0x284
4200b8f7:	000606        	j	4200b913 <_svfprintf_r+0xc67>
4200b8fa:	00          	.byte 00
4200b8fb:	00          	.byte 00
4200b8fc:	a12122        	l32i	a2, a1, 0x284
4200b8ff:	a36122        	s32i	a2, a1, 0x28c
4200b902:	000346        	j	4200b913 <_svfprintf_r+0xc67>
4200b905:	a361a2        	s32i	a10, a1, 0x28c
4200b908:	630c      	movi.n	a3, 6
4200b90a:	000086        	j	4200b910 <_svfprintf_r+0xc64>
4200b90d:	a361a2        	s32i	a10, a1, 0x28c
4200b910:	a26132        	s32i	a3, a1, 0x288
4200b913:	a02142        	l32i	a4, a1, 0x280
4200b916:	00a122        	movi	a2, 0x100
4200b919:	202420        	or	a2, a4, a2
4200b91c:	af6122        	s32i	a2, a1, 0x2bc
4200b91f:	a92122        	l32i	a2, a1, 0x2a4
4200b922:	a82132        	l32i	a3, a1, 0x2a0
4200b925:	0142d6        	bgez	a2, 4200b93d <_svfprintf_r+0xc91>
4200b928:	a92152        	l32i	a5, a1, 0x2a4
4200b92b:	f27c      	movi.n	a2, -1
4200b92d:	012210        	slli	a2, a2, 31
4200b930:	d62c      	movi.n	a6, 45
4200b932:	302520        	xor	a2, a5, a2
4200b935:	b16162        	s32i	a6, a1, 0x2c4
4200b938:	000186        	j	4200b942 <_svfprintf_r+0xc96>
4200b93b:	00          	.byte 00
4200b93c:	00          	.byte 00
4200b93d:	080c      	movi.n	a8, 0
4200b93f:	b16182        	s32i	a8, a1, 0x2c4
4200b942:	144c      	movi.n	a4, 65
4200b944:	021747        	beq	a7, a4, 4200b94a <_svfprintf_r+0xc9e>
4200b947:	005bc6        	j	4200baba <_svfprintf_r+0xe0e>
4200b94a:	54a2c2        	movi	a12, 0x254
4200b94d:	c1ca      	add.n	a12, a1, a12
4200b94f:	03ad      	mov.n	a10, a3
4200b951:	20b220        	or	a11, a2, a2
4200b954:	b96192        	s32i	a9, a1, 0x2e4
4200b957:	201110        	or	a1, a1, a1
4200b95a:	076da5        	call8	42013034 <frexp>
4200b95d:	d3a4c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200b960:	d4a0d1        	l32r	a13, 42000be0 <_stext+0xbc0>
4200b963:	d4a881        	l32r	a8, 42000c04 <_stext+0xbe4>
4200b966:	0008e0        	callx8	a8
4200b969:	d3a1c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200b96c:	d3a1d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200b96f:	0a2d      	mov.n	a2, a10
4200b971:	0b3d      	mov.n	a3, a11
4200b973:	d4a581        	l32r	a8, 42000c08 <_stext+0xbe8>
4200b976:	0008e0        	callx8	a8
4200b979:	b92192        	l32i	a9, a1, 0x2e4
4200b97c:	005a56        	bnez	a10, 4200b985 <_svfprintf_r+0xcd9>
4200b97f:	01a042        	movi	a4, 1
4200b982:	956142        	s32i	a4, a1, 0x254
4200b985:	a72152        	l32i	a5, a1, 0x29c
4200b988:	61a042        	movi	a4, 97
4200b98b:	d49061        	l32r	a6, 42000bcc <_stext+0xbac>
4200b98e:	021547        	beq	a5, a4, 4200b994 <_svfprintf_r+0xce8>
4200b991:	d48f61        	l32r	a6, 42000bd0 <_stext+0xbb0>
4200b994:	a22152        	l32i	a5, a1, 0x288
4200b997:	a12142        	l32i	a4, a1, 0x284
4200b99a:	850b      	addi.n	a8, a5, -1
4200b99c:	d395c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200b99f:	d491d1        	l32r	a13, 42000be4 <_stext+0xbc4>
4200b9a2:	02ad      	mov.n	a10, a2
4200b9a4:	03bd      	mov.n	a11, a3
4200b9a6:	b76182        	s32i	a8, a1, 0x2dc
4200b9a9:	b96192        	s32i	a9, a1, 0x2e4
4200b9ac:	d49681        	l32r	a8, 42000c04 <_stext+0xbe4>
4200b9af:	0008e0        	callx8	a8
4200b9b2:	0b3d      	mov.n	a3, a11
4200b9b4:	0a2d      	mov.n	a2, a10
4200b9b6:	d39381        	l32r	a8, 42000804 <_stext+0x7e4>
4200b9b9:	0008e0        	callx8	a8
4200b9bc:	0a5d      	mov.n	a5, a10
4200b9be:	d38f81        	l32r	a8, 420007fc <_stext+0x7dc>
4200b9c1:	0008e0        	callx8	a8
4200b9c4:	0acd      	mov.n	a12, a10
4200b9c6:	0bdd      	mov.n	a13, a11
4200b9c8:	02ad      	mov.n	a10, a2
4200b9ca:	03bd      	mov.n	a11, a3
4200b9cc:	d49081        	l32r	a8, 42000c0c <_stext+0xbec>
4200b9cf:	0008e0        	callx8	a8
4200b9d2:	0b3d      	mov.n	a3, a11
4200b9d4:	b65a      	add.n	a11, a6, a5
4200b9d6:	000bb2        	l8ui	a11, a11, 0
4200b9d9:	0a2d      	mov.n	a2, a10
4200b9db:	04ad      	mov.n	a10, a4
4200b9dd:	004ab2        	s8i	a11, a10, 0
4200b9e0:	b72182        	l32i	a8, a1, 0x2dc
4200b9e3:	441b      	addi.n	a4, a4, 1
4200b9e5:	b36142        	s32i	a4, a1, 0x2cc
4200b9e8:	a66182        	s32i	a8, a1, 0x298
4200b9eb:	b92192        	l32i	a9, a1, 0x2e4
4200b9ee:	1f0826        	beqi	a8, -1, 4200ba11 <_svfprintf_r+0xd65>
4200b9f1:	d37fc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200b9f4:	d37fd1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200b9f7:	ffc882        	addi	a8, a8, -1
4200b9fa:	20a220        	or	a10, a2, a2
4200b9fd:	03bd      	mov.n	a11, a3
4200b9ff:	b76182        	s32i	a8, a1, 0x2dc
4200ba02:	d48381        	l32r	a8, 42000c10 <_stext+0xbf0>
4200ba05:	0008e0        	callx8	a8
4200ba08:	b72182        	l32i	a8, a1, 0x2dc
4200ba0b:	b92192        	l32i	a9, a1, 0x2e4
4200ba0e:	f8aa56        	bnez	a10, 4200b99c <_svfprintf_r+0xcf0>
4200ba11:	d377e1        	l32r	a14, 420007f0 <_stext+0x7d0>
4200ba14:	d475f1        	l32r	a15, 42000be8 <_stext+0xbc8>
4200ba17:	0ecd      	mov.n	a12, a14
4200ba19:	0fdd      	mov.n	a13, a15
4200ba1b:	20a220        	or	a10, a2, a2
4200ba1e:	20b330        	or	a11, a3, a3
4200ba21:	b96192        	s32i	a9, a1, 0x2e4
4200ba24:	b761e2        	s32i	a14, a1, 0x2dc
4200ba27:	b861f2        	s32i	a15, a1, 0x2e0
4200ba2a:	d44181        	l32r	a8, 42000b30 <_stext+0xb10>
4200ba2d:	0008e0        	callx8	a8
4200ba30:	b92192        	l32i	a9, a1, 0x2e4
4200ba33:	b721e2        	l32i	a14, a1, 0x2dc
4200ba36:	b821f2        	l32i	a15, a1, 0x2e0
4200ba39:	171ae6        	bgei	a10, 1, 4200ba54 <_svfprintf_r+0xda8>
4200ba3c:	0ecd      	mov.n	a12, a14
4200ba3e:	0fdd      	mov.n	a13, a15
4200ba40:	20a220        	or	a10, a2, a2
4200ba43:	20b330        	or	a11, a3, a3
4200ba46:	d47081        	l32r	a8, 42000c08 <_stext+0xbe8>
4200ba49:	0008e0        	callx8	a8
4200ba4c:	b92192        	l32i	a9, a1, 0x2e4
4200ba4f:	dafc      	bnez.n	a10, 4200ba90 <_svfprintf_r+0xde4>
4200ba51:	3b6507        	bbci	a5, 0, 4200ba90 <_svfprintf_r+0xde4>
4200ba54:	906142        	s32i	a4, a1, 0x240
4200ba57:	0f0632        	l8ui	a3, a6, 15
4200ba5a:	043c      	movi.n	a4, 48
4200ba5c:	0000c6        	j	4200ba63 <_svfprintf_r+0xdb7>
4200ba5f:	00          	.byte 00
4200ba60:	004242        	s8i	a4, a2, 0
4200ba63:	902122        	l32i	a2, a1, 0x240
4200ba66:	220b      	addi.n	a2, a2, -1
4200ba68:	906122        	s32i	a2, a1, 0x240
4200ba6b:	000252        	l8ui	a5, a2, 0
4200ba6e:	ee1537        	beq	a5, a3, 4200ba60 <_svfprintf_r+0xdb4>
4200ba71:	01c532        	addi	a3, a5, 1
4200ba74:	39a042        	movi	a4, 57
4200ba77:	743030        	extui	a3, a3, 0, 8
4200ba7a:	029547        	bne	a5, a4, 4200ba80 <_svfprintf_r+0xdd4>
4200ba7d:	0a0632        	l8ui	a3, a6, 10
4200ba80:	004232        	s8i	a3, a2, 0
4200ba83:	0009c6        	j	4200baae <_svfprintf_r+0xe02>
4200ba86:	00          	.byte 00
4200ba87:	00          	.byte 00
4200ba88:	004262        	s8i	a6, a2, 0
4200ba8b:	221b      	addi.n	a2, a2, 1
4200ba8d:	000206        	j	4200ba99 <_svfprintf_r+0xded>
4200ba90:	a62162        	l32i	a6, a1, 0x298
4200ba93:	042d      	mov.n	a2, a4
4200ba95:	546a      	add.n	a5, a4, a6
4200ba97:	063c      	movi.n	a6, 48
4200ba99:	c03520        	sub	a3, a5, a2
4200ba9c:	fe83d6        	bgez	a3, 4200ba88 <_svfprintf_r+0xddc>
4200ba9f:	a62182        	l32i	a8, a1, 0x298
4200baa2:	020c      	movi.n	a2, 0
4200baa4:	0108a6        	blti	a8, -1, 4200baa9 <_svfprintf_r+0xdfd>
4200baa7:	281b      	addi.n	a2, a8, 1
4200baa9:	242a      	add.n	a2, a4, a2
4200baab:	b36122        	s32i	a2, a1, 0x2cc
4200baae:	b32122        	l32i	a2, a1, 0x2cc
4200bab1:	a12132        	l32i	a3, a1, 0x284
4200bab4:	c02230        	sub	a2, a2, a3
4200bab7:	0014c6        	j	4200bb0e <_svfprintf_r+0xe62>
4200baba:	654c      	movi.n	a5, 70
4200babc:	a22142        	l32i	a4, a1, 0x288
4200babf:	3e0c      	movi.n	a14, 3
4200bac1:	081757        	beq	a7, a5, 4200bacd <_svfprintf_r+0xe21>
4200bac4:	554c      	movi.n	a5, 69
4200bac6:	2e0c      	movi.n	a14, 2
4200bac8:	019757        	bne	a7, a5, 4200bacd <_svfprintf_r+0xe21>
4200bacb:	441b      	addi.n	a4, a4, 1
4200bacd:	40a262        	movi	a6, 0x240
4200bad0:	516a      	add.n	a5, a1, a6
4200bad2:	50a282        	movi	a8, 0x250
4200bad5:	2159      	s32i.n	a5, a1, 8
4200bad7:	54a2a2        	movi	a10, 0x254
4200bada:	518a      	add.n	a5, a1, a8
4200badc:	1159      	s32i.n	a5, a1, 4
4200bade:	51aa      	add.n	a5, a1, a10
4200bae0:	a421a2        	l32i	a10, a1, 0x290
4200bae3:	0159      	s32i.n	a5, a1, 0
4200bae5:	04fd      	mov.n	a15, a4
4200bae7:	03cd      	mov.n	a12, a3
4200bae9:	02dd      	mov.n	a13, a2
4200baeb:	b96192        	s32i	a9, a1, 0x2e4
4200baee:	201110        	or	a1, a1, a1
4200baf1:	05a8a5        	call8	4201157c <_dtoa_r>
4200baf4:	a161a2        	s32i	a10, a1, 0x284
4200baf7:	754c      	movi.n	a5, 71
4200baf9:	b92192        	l32i	a9, a1, 0x2e4
4200bafc:	149757        	bne	a7, a5, 4200bb14 <_svfprintf_r+0xe68>
4200baff:	a02152        	l32i	a5, a1, 0x280
4200bb02:	0ee507        	bbsi	a5, 0, 4200bb14 <_svfprintf_r+0xe68>
4200bb05:	902122        	l32i	a2, a1, 0x240
4200bb08:	a12182        	l32i	a8, a1, 0x284
4200bb0b:	c02280        	sub	a2, a2, a8
4200bb0e:	a66122        	s32i	a2, a1, 0x298
4200bb11:	001a46        	j	4200bb7e <_svfprintf_r+0xed2>
4200bb14:	a12182        	l32i	a8, a1, 0x284
4200bb17:	664c      	movi.n	a6, 70
4200bb19:	584a      	add.n	a5, a8, a4
4200bb1b:	2e9767        	bne	a7, a6, 4200bb4d <_svfprintf_r+0xea1>
4200bb1e:	000862        	l8ui	a6, a8, 0
4200bb21:	d0c662        	addi	a6, a6, -48
4200bb24:	06ec      	bnez.n	a6, 4200bb48 <_svfprintf_r+0xe9c>
4200bb26:	d332c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200bb29:	d331d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200bb2c:	03ad      	mov.n	a10, a3
4200bb2e:	02bd      	mov.n	a11, a2
4200bb30:	b96192        	s32i	a9, a1, 0x2e4
4200bb33:	d43781        	l32r	a8, 42000c10 <_stext+0xbf0>
4200bb36:	0008e0        	callx8	a8
4200bb39:	b92192        	l32i	a9, a1, 0x2e4
4200bb3c:	008a16        	beqz	a10, 4200bb48 <_svfprintf_r+0xe9c>
4200bb3f:	01a062        	movi	a6, 1
4200bb42:	c04640        	sub	a4, a6, a4
4200bb45:	956142        	s32i	a4, a1, 0x254
4200bb48:	952142        	l32i	a4, a1, 0x254
4200bb4b:	554a      	add.n	a5, a5, a4
4200bb4d:	d328c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200bb50:	d328d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200bb53:	03ad      	mov.n	a10, a3
4200bb55:	02bd      	mov.n	a11, a2
4200bb57:	b96192        	s32i	a9, a1, 0x2e4
4200bb5a:	d42b81        	l32r	a8, 42000c08 <_stext+0xbe8>
4200bb5d:	0008e0        	callx8	a8
4200bb60:	b92192        	l32i	a9, a1, 0x2e4
4200bb63:	1acc      	bnez.n	a10, 4200bb68 <_svfprintf_r+0xebc>
4200bb65:	906152        	s32i	a5, a1, 0x240
4200bb68:	033c      	movi.n	a3, 48
4200bb6a:	0001c6        	j	4200bb75 <_svfprintf_r+0xec9>
4200bb6d:	421b      	addi.n	a4, a2, 1
4200bb6f:	906142        	s32i	a4, a1, 0x240
4200bb72:	004232        	s8i	a3, a2, 0
4200bb75:	902122        	l32i	a2, a1, 0x240
4200bb78:	f13257        	bltu	a2, a5, 4200bb6d <_svfprintf_r+0xec1>
4200bb7b:	ffe186        	j	4200bb05 <_svfprintf_r+0xe59>
4200bb7e:	734c      	movi.n	a3, 71
4200bb80:	952122        	l32i	a2, a1, 0x254
4200bb83:	229737        	bne	a7, a3, 4200bba9 <_svfprintf_r+0xefd>
4200bb86:	d37c      	movi.n	a3, -3
4200bb88:	112237        	blt	a2, a3, 4200bb9d <_svfprintf_r+0xef1>
4200bb8b:	a22132        	l32i	a3, a1, 0x288
4200bb8e:	0b2327        	blt	a3, a2, 4200bb9d <_svfprintf_r+0xef1>
4200bb91:	a62142        	l32i	a4, a1, 0x298
4200bb94:	022247        	blt	a2, a4, 4200bb9a <_svfprintf_r+0xeee>
4200bb97:	005d46        	j	4200bd10 <_svfprintf_r+0x1064>
4200bb9a:	006306        	j	4200bd2a <_svfprintf_r+0x107e>
4200bb9d:	a72152        	l32i	a5, a1, 0x29c
4200bba0:	fec552        	addi	a5, a5, -2
4200bba3:	a76152        	s32i	a5, a1, 0x29c
4200bba6:	0001c6        	j	4200bbb1 <_svfprintf_r+0xf05>
4200bba9:	634c      	movi.n	a3, 70
4200bbab:	029737        	bne	a7, a3, 4200bbb1 <_svfprintf_r+0xf05>
4200bbae:	004786        	j	4200bcd0 <_svfprintf_r+0x1024>
4200bbb1:	a72162        	l32i	a6, a1, 0x29c
4200bbb4:	320b      	addi.n	a3, a2, -1
4200bbb6:	dfaf52        	movi	a5, -33
4200bbb9:	105650        	and	a5, a6, a5
4200bbbc:	744060        	extui	a4, a6, 0, 8
4200bbbf:	956132        	s32i	a3, a1, 0x254
4200bbc2:	164c      	movi.n	a6, 65
4200bbc4:	049567        	bne	a5, a6, 4200bbcc <_svfprintf_r+0xf20>
4200bbc7:	44fb      	addi.n	a4, a4, 15
4200bbc9:	744040        	extui	a4, a4, 0, 8
4200bbcc:	10c182        	addi	a8, a1, 16
4200bbcf:	02d862        	addmi	a6, a8, 0x200
4200bbd2:	374642        	s8i	a4, a6, 55
4200bbd5:	b42c      	movi.n	a4, 43
4200bbd7:	0063d6        	bgez	a3, 4200bbe1 <_svfprintf_r+0xf35>
4200bbda:	130c      	movi.n	a3, 1
4200bbdc:	c03320        	sub	a3, a3, a2
4200bbdf:	d42c      	movi.n	a4, 45
4200bbe1:	10c1a2        	addi	a10, a1, 16
4200bbe4:	02da62        	addmi	a6, a10, 0x200
4200bbe7:	384642        	s8i	a4, a6, 56
4200bbea:	09a022        	movi	a2, 9
4200bbed:	77a237        	bge	a2, a3, 4200bc68 <_svfprintf_r+0xfbc>
4200bbf0:	37a222        	movi	a2, 0x237
4200bbf3:	d1b981        	l32r	a8, 420002d8 <_stext+0x2b8>
4200bbf6:	802a20        	add	a2, a10, a2
4200bbf9:	63a072        	movi	a7, 99
4200bbfc:	b24380        	mulsh	a4, a3, a8
4200bbff:	315f30        	srai	a5, a3, 31
4200bc02:	214240        	srai	a4, a4, 2
4200bc05:	c04450        	sub	a4, a4, a5
4200bc08:	a05440        	addx4	a5, a4, a4
4200bc0b:	555a      	add.n	a5, a5, a5
4200bc0d:	c05350        	sub	a5, a3, a5
4200bc10:	30c552        	addi	a5, a5, 48
4200bc13:	026d      	mov.n	a6, a2
4200bc15:	220b      	addi.n	a2, a2, -1
4200bc17:	004252        	s8i	a5, a2, 0
4200bc1a:	035d      	mov.n	a5, a3
4200bc1c:	043d      	mov.n	a3, a4
4200bc1e:	da2757        	blt	a7, a5, 4200bbfc <_svfprintf_r+0xf50>
4200bc21:	40a2e2        	movi	a14, 0x240
4200bc24:	fec642        	addi	a4, a6, -2
4200bc27:	30c332        	addi	a3, a3, 48
4200bc2a:	39a222        	movi	a2, 0x239
4200bc2d:	10c1b2        	addi	a11, a1, 16
4200bc30:	ee1a      	add.n	a14, a14, a1
4200bc32:	004432        	s8i	a3, a4, 0
4200bc35:	2b2a      	add.n	a2, a11, a2
4200bc37:	043d      	mov.n	a3, a4
4200bc39:	5e7b      	addi.n	a5, a14, 7
4200bc3b:	000246        	j	4200bc48 <_svfprintf_r+0xf9c>
4200bc3e:	000372        	l8ui	a7, a3, 0
4200bc41:	331b      	addi.n	a3, a3, 1
4200bc43:	004272        	s8i	a7, a2, 0
4200bc46:	221b      	addi.n	a2, a2, 1
4200bc48:	f23357        	bltu	a3, a5, 4200bc3e <_svfprintf_r+0xf92>
4200bc4b:	10c132        	addi	a3, a1, 16
4200bc4e:	39a222        	movi	a2, 0x239
4200bc51:	232a      	add.n	a2, a3, a2
4200bc53:	030c      	movi.n	a3, 0
4200bc55:	093547        	bltu	a5, a4, 4200bc62 <_svfprintf_r+0xfb6>
4200bc58:	40a242        	movi	a4, 0x240
4200bc5b:	441a      	add.n	a4, a4, a1
4200bc5d:	349b      	addi.n	a3, a4, 9
4200bc5f:	c03360        	sub	a3, a3, a6
4200bc62:	223a      	add.n	a2, a2, a3
4200bc64:	000846        	j	4200bc89 <_svfprintf_r+0xfdd>
4200bc67:	00          	.byte 00
4200bc68:	37a222        	movi	a2, 0x237
4200bc6b:	10c182        	addi	a8, a1, 16
4200bc6e:	482a      	add.n	a4, a8, a2
4200bc70:	174c      	movi.n	a7, 65
4200bc72:	442b      	addi.n	a4, a4, 2
4200bc74:	091577        	beq	a5, a7, 4200bc81 <_svfprintf_r+0xfd5>
4200bc77:	043c      	movi.n	a4, 48
4200bc79:	282a      	add.n	a2, a8, a2
4200bc7b:	394642        	s8i	a4, a6, 57
4200bc7e:	03c242        	addi	a4, a2, 3
4200bc81:	30c332        	addi	a3, a3, 48
4200bc84:	241b      	addi.n	a2, a4, 1
4200bc86:	004432        	s8i	a3, a4, 0
4200bc89:	47a232        	movi	a3, 0x247
4200bc8c:	313a      	add.n	a3, a1, a3
4200bc8e:	c03230        	sub	a3, a2, a3
4200bc91:	a62122        	l32i	a2, a1, 0x298
4200bc94:	b66132        	s32i	a3, a1, 0x2d8
4200bc97:	802320        	add	a2, a3, a2
4200bc9a:	a62132        	l32i	a3, a1, 0x298
4200bc9d:	a26122        	s32i	a2, a1, 0x288
4200bca0:	0523e6        	bgei	a3, 2, 4200bca9 <_svfprintf_r+0xffd>
4200bca3:	a02142        	l32i	a4, a1, 0x280
4200bca6:	0a6407        	bbci	a4, 0, 4200bcb4 <_svfprintf_r+0x1008>
4200bca9:	a22152        	l32i	a5, a1, 0x288
4200bcac:	ae2162        	l32i	a6, a1, 0x2b8
4200bcaf:	556a      	add.n	a5, a5, a6
4200bcb1:	a26152        	s32i	a5, a1, 0x288
4200bcb4:	a02182        	l32i	a8, a1, 0x280
4200bcb7:	ffab22        	movi	a2, 0xfffffbff
4200bcba:	102820        	and	a2, a8, a2
4200bcbd:	00a132        	movi	a3, 0x100
4200bcc0:	203230        	or	a3, a2, a3
4200bcc3:	af6132        	s32i	a3, a1, 0x2bc
4200bcc6:	030c      	movi.n	a3, 0
4200bcc8:	034d      	mov.n	a4, a3
4200bcca:	032d      	mov.n	a2, a3
4200bccc:	003846        	j	4200bdb1 <_svfprintf_r+0x1105>
4200bccf:	00          	.byte 00
4200bcd0:	a02142        	l32i	a4, a1, 0x280
4200bcd3:	a22152        	l32i	a5, a1, 0x288
4200bcd6:	043040        	extui	a3, a4, 0, 1
4200bcd9:	203350        	or	a3, a3, a5
4200bcdc:	1512a6        	blti	a2, 1, 4200bcf5 <_svfprintf_r+0x1049>
4200bcdf:	066316        	beqz	a3, 4200bd49 <_svfprintf_r+0x109d>
4200bce2:	ae2162        	l32i	a6, a1, 0x2b8
4200bce5:	66a082        	movi	a8, 102
4200bce8:	326a      	add.n	a3, a2, a6
4200bcea:	553a      	add.n	a5, a5, a3
4200bcec:	a26152        	s32i	a5, a1, 0x288
4200bcef:	a76182        	s32i	a8, a1, 0x29c
4200bcf2:	001a86        	j	4200bd60 <_svfprintf_r+0x10b4>
4200bcf5:	05c316        	beqz	a3, 4200bd55 <_svfprintf_r+0x10a9>
4200bcf8:	ae2142        	l32i	a4, a1, 0x2b8
4200bcfb:	a22152        	l32i	a5, a1, 0x288
4200bcfe:	341b      	addi.n	a3, a4, 1
4200bd00:	553a      	add.n	a5, a5, a3
4200bd02:	66a062        	movi	a6, 102
4200bd05:	a26152        	s32i	a5, a1, 0x288
4200bd08:	a76162        	s32i	a6, a1, 0x29c
4200bd0b:	001446        	j	4200bd60 <_svfprintf_r+0x10b4>
4200bd0e:	00          	.byte 00
4200bd0f:	00          	.byte 00
4200bd10:	67a082        	movi	a8, 103
4200bd13:	a02132        	l32i	a3, a1, 0x280
4200bd16:	a26122        	s32i	a2, a1, 0x288
4200bd19:	a76182        	s32i	a8, a1, 0x29c
4200bd1c:	406307        	bbci	a3, 0, 4200bd60 <_svfprintf_r+0x10b4>
4200bd1f:	ae2142        	l32i	a4, a1, 0x2b8
4200bd22:	424a      	add.n	a4, a2, a4
4200bd24:	a26142        	s32i	a4, a1, 0x288
4200bd27:	000d46        	j	4200bd60 <_svfprintf_r+0x10b4>
4200bd2a:	a62162        	l32i	a6, a1, 0x298
4200bd2d:	ae2182        	l32i	a8, a1, 0x2b8
4200bd30:	67a032        	movi	a3, 103
4200bd33:	668a      	add.n	a6, a6, a8
4200bd35:	a26162        	s32i	a6, a1, 0x288
4200bd38:	a76132        	s32i	a3, a1, 0x29c
4200bd3b:	2112e6        	bgei	a2, 1, 4200bd60 <_svfprintf_r+0x10b4>
4200bd3e:	c03620        	sub	a3, a6, a2
4200bd41:	331b      	addi.n	a3, a3, 1
4200bd43:	a26132        	s32i	a3, a1, 0x288
4200bd46:	000586        	j	4200bd60 <_svfprintf_r+0x10b4>
4200bd49:	66a042        	movi	a4, 102
4200bd4c:	a26122        	s32i	a2, a1, 0x288
4200bd4f:	a76142        	s32i	a4, a1, 0x29c
4200bd52:	000286        	j	4200bd60 <_svfprintf_r+0x10b4>
4200bd55:	66a052        	movi	a5, 102
4200bd58:	160c      	movi.n	a6, 1
4200bd5a:	a76152        	s32i	a5, a1, 0x29c
4200bd5d:	a26162        	s32i	a6, a1, 0x288
4200bd60:	a02182        	l32i	a8, a1, 0x280
4200bd63:	00a442        	movi	a4, 0x400
4200bd66:	104840        	and	a4, a8, a4
4200bd69:	030c      	movi.n	a3, 0
4200bd6b:	421437        	beq	a4, a3, 4200bdb1 <_svfprintf_r+0x1105>
4200bd6e:	034d      	mov.n	a4, a3
4200bd70:	2112e6        	bgei	a2, 1, 4200bd95 <_svfprintf_r+0x10e9>
4200bd73:	000e86        	j	4200bdb1 <_svfprintf_r+0x1105>
4200bd76:	00          	.byte 00
4200bd77:	00          	.byte 00
4200bd78:	25a527        	bge	a5, a2, 4200bda1 <_svfprintf_r+0x10f5>
4200bd7b:	ac2182        	l32i	a8, a1, 0x2b0
4200bd7e:	c02250        	sub	a2, a2, a5
4200bd81:	010852        	l8ui	a5, a8, 1
4200bd84:	858c      	beqz.n	a5, 4200bd90 <_svfprintf_r+0x10e4>
4200bd86:	881b      	addi.n	a8, a8, 1
4200bd88:	441b      	addi.n	a4, a4, 1
4200bd8a:	ac6182        	s32i	a8, a1, 0x2b0
4200bd8d:	0001c6        	j	4200bd98 <_svfprintf_r+0x10ec>
4200bd90:	331b      	addi.n	a3, a3, 1
4200bd92:	000086        	j	4200bd98 <_svfprintf_r+0x10ec>
4200bd95:	ffa062        	movi	a6, 255
4200bd98:	ac2182        	l32i	a8, a1, 0x2b0
4200bd9b:	000852        	l8ui	a5, a8, 0
4200bd9e:	d69567        	bne	a5, a6, 4200bd78 <_svfprintf_r+0x10cc>
4200bda1:	b02162        	l32i	a6, a1, 0x2c0
4200bda4:	543a      	add.n	a5, a4, a3
4200bda6:	a22182        	l32i	a8, a1, 0x288
4200bda9:	825560        	mull	a5, a5, a6
4200bdac:	858a      	add.n	a8, a5, a8
4200bdae:	a26182        	s32i	a8, a1, 0x288
4200bdb1:	af2152        	l32i	a5, a1, 0x2bc
4200bdb4:	a06152        	s32i	a5, a1, 0x280
4200bdb7:	b12152        	l32i	a5, a1, 0x2c4
4200bdba:	15cc      	bnez.n	a5, 4200bdbf <_svfprintf_r+0x1113>
4200bdbc:	04df06        	j	4200d13c <_svfprintf_r+0x2490>
4200bdbf:	10c162        	addi	a6, a1, 16
4200bdc2:	02d652        	addmi	a5, a6, 0x200
4200bdc5:	d62c      	movi.n	a6, 45
4200bdc7:	524562        	s8i	a6, a5, 82
4200bdca:	050c      	movi.n	a5, 0
4200bdcc:	04db06        	j	4200d13c <_svfprintf_r+0x2490>
4200bdcf:	a02162        	l32i	a6, a1, 0x280
4200bdd2:	972152        	l32i	a5, a1, 0x25c
4200bdd5:	02e657        	bbsi	a6, 5, 4200bddb <_svfprintf_r+0x112f>
4200bdd8:	003106        	j	4200bea0 <_svfprintf_r+0x11f4>
4200bddb:	041416        	beqz	a4, 4200be20 <_svfprintf_r+0x1174>
4200bdde:	0fa257        	bge	a2, a5, 4200bdf1 <_svfprintf_r+0x1145>
4200bde1:	10c182        	addi	a8, a1, 16
4200bde4:	b02280        	addx8	a2, a2, a8
4200bde7:	0228      	l32i.n	a2, a2, 0
4200bde9:	9f2162        	l32i	a6, a1, 0x27c
4200bdec:	002886        	j	4200be92 <_svfprintf_r+0x11e6>
4200bdef:	00          	.byte 00
4200bdf0:	00          	.byte 00
4200bdf1:	58a2a2        	movi	a10, 0x258
4200bdf4:	10c1b2        	addi	a11, a1, 16
4200bdf7:	41aa      	add.n	a4, a1, a10
4200bdf9:	4ca2d2        	movi	a13, 0x24c
4200bdfc:	60a2c2        	movi	a12, 0x260
4200bdff:	01dbf2        	addmi	a15, a11, 0x100
4200be02:	0bed      	mov.n	a14, a11
4200be04:	dbda      	add.n	a13, a11, a13
4200be06:	cbca      	add.n	a12, a11, a12
4200be08:	02ad      	mov.n	a10, a2
4200be0a:	0149      	s32i.n	a4, a1, 0
4200be0c:	03bd      	mov.n	a11, a3
4200be0e:	b96192        	s32i	a9, a1, 0x2e4
4200be11:	fe9a25        	call8	4200a7b4 <get_arg$constprop$0>
4200be14:	0a28      	l32i.n	a2, a10, 0
4200be16:	9f2162        	l32i	a6, a1, 0x27c
4200be19:	b92192        	l32i	a9, a1, 0x2e4
4200be1c:	001c86        	j	4200be92 <_svfprintf_r+0x11e6>
4200be1f:	00          	.byte 00
4200be20:	9f2132        	l32i	a3, a1, 0x27c
4200be23:	10c142        	addi	a4, a1, 16
4200be26:	631b      	addi.n	a6, a3, 1
4200be28:	b02240        	addx8	a2, a2, a4
4200be2b:	612357        	blt	a3, a5, 4200be90 <_svfprintf_r+0x11e4>
4200be2e:	10c182        	addi	a8, a1, 16
4200be31:	9a2872        	l32i	a7, a8, 0x268
4200be34:	02d822        	addmi	a2, a8, 0x200
4200be37:	f81c      	movi.n	a8, 31
4200be39:	374b      	addi.n	a3, a7, 4
4200be3b:	841c      	movi.n	a4, 24
4200be3d:	302857        	blt	a8, a5, 4200be71 <_svfprintf_r+0x11c5>
4200be40:	851b      	addi.n	a8, a5, 1
4200be42:	976182        	s32i	a8, a1, 0x25c
4200be45:	1a6232        	s32i	a3, a2, 104
4200be48:	052437        	blt	a4, a3, 4200be51 <_svfprintf_r+0x11a5>
4200be4b:	192222        	l32i	a2, a2, 100
4200be4e:	000286        	j	4200be5c <_svfprintf_r+0x11b0>
4200be51:	012477        	blt	a4, a7, 4200be56 <_svfprintf_r+0x11aa>
4200be54:	432c      	movi.n	a3, 36
4200be56:	9c2122        	l32i	a2, a1, 0x270
4200be59:	9e6132        	s32i	a3, a1, 0x278
4200be5c:	9e2132        	l32i	a3, a1, 0x278
4200be5f:	10c1b2        	addi	a11, a1, 16
4200be62:	223a      	add.n	a2, a2, a3
4200be64:	fcc222        	addi	a2, a2, -4
4200be67:	0228      	l32i.n	a2, a2, 0
4200be69:	b035b0        	addx8	a3, a5, a11
4200be6c:	0329      	s32i.n	a2, a3, 0
4200be6e:	000806        	j	4200be92 <_svfprintf_r+0x11e6>
4200be71:	1a6232        	s32i	a3, a2, 104
4200be74:	052437        	blt	a4, a3, 4200be7d <_svfprintf_r+0x11d1>
4200be77:	192222        	l32i	a2, a2, 100
4200be7a:	000286        	j	4200be88 <_svfprintf_r+0x11dc>
4200be7d:	012477        	blt	a4, a7, 4200be82 <_svfprintf_r+0x11d6>
4200be80:	432c      	movi.n	a3, 36
4200be82:	9c2122        	l32i	a2, a1, 0x270
4200be85:	9e6132        	s32i	a3, a1, 0x278
4200be88:	9e2132        	l32i	a3, a1, 0x278
4200be8b:	223a      	add.n	a2, a2, a3
4200be8d:	fcc222        	addi	a2, a2, -4
4200be90:	0228      	l32i.n	a2, a2, 0
4200be92:	ad2132        	l32i	a3, a1, 0x2b4
4200be95:	0239      	s32i.n	a3, a2, 0
4200be97:	313f30        	srai	a3, a3, 31
4200be9a:	1239      	s32i.n	a3, a2, 4
4200be9c:	00c4c6        	j	4200c1b3 <_svfprintf_r+0x1507>
4200be9f:	00          	.byte 00
4200bea0:	a02162        	l32i	a6, a1, 0x280
4200bea3:	02e647        	bbsi	a6, 4, 4200bea9 <_svfprintf_r+0x11fd>
4200bea6:	002f86        	j	4200bf68 <_svfprintf_r+0x12bc>
4200bea9:	f4bc      	beqz.n	a4, 4200beec <_svfprintf_r+0x1240>
4200beab:	0ea257        	bge	a2, a5, 4200bebd <_svfprintf_r+0x1211>
4200beae:	10c182        	addi	a8, a1, 16
4200beb1:	b02280        	addx8	a2, a2, a8
4200beb4:	0228      	l32i.n	a2, a2, 0
4200beb6:	9f2162        	l32i	a6, a1, 0x27c
4200beb9:	002846        	j	4200bf5e <_svfprintf_r+0x12b2>
4200bebc:	00          	.byte 00
4200bebd:	58a2a2        	movi	a10, 0x258
4200bec0:	10c1b2        	addi	a11, a1, 16
4200bec3:	41aa      	add.n	a4, a1, a10
4200bec5:	4ca2d2        	movi	a13, 0x24c
4200bec8:	60a2c2        	movi	a12, 0x260
4200becb:	01dbf2        	addmi	a15, a11, 0x100
4200bece:	0bed      	mov.n	a14, a11
4200bed0:	dbda      	add.n	a13, a11, a13
4200bed2:	cbca      	add.n	a12, a11, a12
4200bed4:	02ad      	mov.n	a10, a2
4200bed6:	0149      	s32i.n	a4, a1, 0
4200bed8:	03bd      	mov.n	a11, a3
4200beda:	b96192        	s32i	a9, a1, 0x2e4
4200bedd:	fe8d65        	call8	4200a7b4 <get_arg$constprop$0>
4200bee0:	0a28      	l32i.n	a2, a10, 0
4200bee2:	9f2162        	l32i	a6, a1, 0x27c
4200bee5:	b92192        	l32i	a9, a1, 0x2e4
4200bee8:	001c86        	j	4200bf5e <_svfprintf_r+0x12b2>
4200beeb:	00          	.byte 00
4200beec:	9f2132        	l32i	a3, a1, 0x27c
4200beef:	10c142        	addi	a4, a1, 16
4200bef2:	631b      	addi.n	a6, a3, 1
4200bef4:	b02240        	addx8	a2, a2, a4
4200bef7:	612357        	blt	a3, a5, 4200bf5c <_svfprintf_r+0x12b0>
4200befa:	10c182        	addi	a8, a1, 16
4200befd:	9a2872        	l32i	a7, a8, 0x268
4200bf00:	02d822        	addmi	a2, a8, 0x200
4200bf03:	f81c      	movi.n	a8, 31
4200bf05:	374b      	addi.n	a3, a7, 4
4200bf07:	841c      	movi.n	a4, 24
4200bf09:	302857        	blt	a8, a5, 4200bf3d <_svfprintf_r+0x1291>
4200bf0c:	851b      	addi.n	a8, a5, 1
4200bf0e:	976182        	s32i	a8, a1, 0x25c
4200bf11:	1a6232        	s32i	a3, a2, 104
4200bf14:	052437        	blt	a4, a3, 4200bf1d <_svfprintf_r+0x1271>
4200bf17:	192222        	l32i	a2, a2, 100
4200bf1a:	000286        	j	4200bf28 <_svfprintf_r+0x127c>
4200bf1d:	012477        	blt	a4, a7, 4200bf22 <_svfprintf_r+0x1276>
4200bf20:	432c      	movi.n	a3, 36
4200bf22:	9c2122        	l32i	a2, a1, 0x270
4200bf25:	9e6132        	s32i	a3, a1, 0x278
4200bf28:	9e2132        	l32i	a3, a1, 0x278
4200bf2b:	10c1b2        	addi	a11, a1, 16
4200bf2e:	223a      	add.n	a2, a2, a3
4200bf30:	fcc222        	addi	a2, a2, -4
4200bf33:	0228      	l32i.n	a2, a2, 0
4200bf35:	b035b0        	addx8	a3, a5, a11
4200bf38:	0329      	s32i.n	a2, a3, 0
4200bf3a:	000806        	j	4200bf5e <_svfprintf_r+0x12b2>
4200bf3d:	1a6232        	s32i	a3, a2, 104
4200bf40:	052437        	blt	a4, a3, 4200bf49 <_svfprintf_r+0x129d>
4200bf43:	192222        	l32i	a2, a2, 100
4200bf46:	000286        	j	4200bf54 <_svfprintf_r+0x12a8>
4200bf49:	012477        	blt	a4, a7, 4200bf4e <_svfprintf_r+0x12a2>
4200bf4c:	432c      	movi.n	a3, 36
4200bf4e:	9c2122        	l32i	a2, a1, 0x270
4200bf51:	9e6132        	s32i	a3, a1, 0x278
4200bf54:	9e2132        	l32i	a3, a1, 0x278
4200bf57:	223a      	add.n	a2, a2, a3
4200bf59:	fcc222        	addi	a2, a2, -4
4200bf5c:	0228      	l32i.n	a2, a2, 0
4200bf5e:	ad2132        	l32i	a3, a1, 0x2b4
4200bf61:	0239      	s32i.n	a3, a2, 0
4200bf63:	009306        	j	4200c1b3 <_svfprintf_r+0x1507>
4200bf66:	00          	.byte 00
4200bf67:	00          	.byte 00
4200bf68:	a02162        	l32i	a6, a1, 0x280
4200bf6b:	02e667        	bbsi	a6, 6, 4200bf71 <_svfprintf_r+0x12c5>
4200bf6e:	002f86        	j	4200c030 <_svfprintf_r+0x1384>
4200bf71:	f4bc      	beqz.n	a4, 4200bfb4 <_svfprintf_r+0x1308>
4200bf73:	0ea257        	bge	a2, a5, 4200bf85 <_svfprintf_r+0x12d9>
4200bf76:	10c182        	addi	a8, a1, 16
4200bf79:	b02280        	addx8	a2, a2, a8
4200bf7c:	0228      	l32i.n	a2, a2, 0
4200bf7e:	9f2162        	l32i	a6, a1, 0x27c
4200bf81:	002846        	j	4200c026 <_svfprintf_r+0x137a>
4200bf84:	00          	.byte 00
4200bf85:	58a2a2        	movi	a10, 0x258
4200bf88:	10c1b2        	addi	a11, a1, 16
4200bf8b:	41aa      	add.n	a4, a1, a10
4200bf8d:	4ca2d2        	movi	a13, 0x24c
4200bf90:	60a2c2        	movi	a12, 0x260
4200bf93:	01dbf2        	addmi	a15, a11, 0x100
4200bf96:	0bed      	mov.n	a14, a11
4200bf98:	dbda      	add.n	a13, a11, a13
4200bf9a:	cbca      	add.n	a12, a11, a12
4200bf9c:	02ad      	mov.n	a10, a2
4200bf9e:	0149      	s32i.n	a4, a1, 0
4200bfa0:	03bd      	mov.n	a11, a3
4200bfa2:	b96192        	s32i	a9, a1, 0x2e4
4200bfa5:	fe80e5        	call8	4200a7b4 <get_arg$constprop$0>
4200bfa8:	0a28      	l32i.n	a2, a10, 0
4200bfaa:	9f2162        	l32i	a6, a1, 0x27c
4200bfad:	b92192        	l32i	a9, a1, 0x2e4
4200bfb0:	001c86        	j	4200c026 <_svfprintf_r+0x137a>
4200bfb3:	00          	.byte 00
4200bfb4:	9f2132        	l32i	a3, a1, 0x27c
4200bfb7:	10c142        	addi	a4, a1, 16
4200bfba:	631b      	addi.n	a6, a3, 1
4200bfbc:	b02240        	addx8	a2, a2, a4
4200bfbf:	612357        	blt	a3, a5, 4200c024 <_svfprintf_r+0x1378>
4200bfc2:	10c182        	addi	a8, a1, 16
4200bfc5:	9a2872        	l32i	a7, a8, 0x268
4200bfc8:	02d822        	addmi	a2, a8, 0x200
4200bfcb:	f81c      	movi.n	a8, 31
4200bfcd:	374b      	addi.n	a3, a7, 4
4200bfcf:	841c      	movi.n	a4, 24
4200bfd1:	302857        	blt	a8, a5, 4200c005 <_svfprintf_r+0x1359>
4200bfd4:	851b      	addi.n	a8, a5, 1
4200bfd6:	976182        	s32i	a8, a1, 0x25c
4200bfd9:	1a6232        	s32i	a3, a2, 104
4200bfdc:	052437        	blt	a4, a3, 4200bfe5 <_svfprintf_r+0x1339>
4200bfdf:	192222        	l32i	a2, a2, 100
4200bfe2:	000286        	j	4200bff0 <_svfprintf_r+0x1344>
4200bfe5:	012477        	blt	a4, a7, 4200bfea <_svfprintf_r+0x133e>
4200bfe8:	432c      	movi.n	a3, 36
4200bfea:	9c2122        	l32i	a2, a1, 0x270
4200bfed:	9e6132        	s32i	a3, a1, 0x278
4200bff0:	9e2132        	l32i	a3, a1, 0x278
4200bff3:	10c1b2        	addi	a11, a1, 16
4200bff6:	223a      	add.n	a2, a2, a3
4200bff8:	fcc222        	addi	a2, a2, -4
4200bffb:	0228      	l32i.n	a2, a2, 0
4200bffd:	b035b0        	addx8	a3, a5, a11
4200c000:	0329      	s32i.n	a2, a3, 0
4200c002:	000806        	j	4200c026 <_svfprintf_r+0x137a>
4200c005:	1a6232        	s32i	a3, a2, 104
4200c008:	052437        	blt	a4, a3, 4200c011 <_svfprintf_r+0x1365>
4200c00b:	192222        	l32i	a2, a2, 100
4200c00e:	000286        	j	4200c01c <_svfprintf_r+0x1370>
4200c011:	012477        	blt	a4, a7, 4200c016 <_svfprintf_r+0x136a>
4200c014:	432c      	movi.n	a3, 36
4200c016:	9c2122        	l32i	a2, a1, 0x270
4200c019:	9e6132        	s32i	a3, a1, 0x278
4200c01c:	9e2132        	l32i	a3, a1, 0x278
4200c01f:	223a      	add.n	a2, a2, a3
4200c021:	fcc222        	addi	a2, a2, -4
4200c024:	0228      	l32i.n	a2, a2, 0
4200c026:	ad2132        	l32i	a3, a1, 0x2b4
4200c029:	005232        	s16i	a3, a2, 0
4200c02c:	0060c6        	j	4200c1b3 <_svfprintf_r+0x1507>
4200c02f:	00          	.byte 00
4200c030:	a02162        	l32i	a6, a1, 0x280
4200c033:	02e697        	bbsi	a6, 9, 4200c039 <_svfprintf_r+0x138d>
4200c036:	002f86        	j	4200c0f8 <_svfprintf_r+0x144c>
4200c039:	f4bc      	beqz.n	a4, 4200c07c <_svfprintf_r+0x13d0>
4200c03b:	0ea257        	bge	a2, a5, 4200c04d <_svfprintf_r+0x13a1>
4200c03e:	10c182        	addi	a8, a1, 16
4200c041:	b02280        	addx8	a2, a2, a8
4200c044:	0228      	l32i.n	a2, a2, 0
4200c046:	9f2162        	l32i	a6, a1, 0x27c
4200c049:	002846        	j	4200c0ee <_svfprintf_r+0x1442>
4200c04c:	00          	.byte 00
4200c04d:	58a2a2        	movi	a10, 0x258
4200c050:	10c1b2        	addi	a11, a1, 16
4200c053:	41aa      	add.n	a4, a1, a10
4200c055:	4ca2d2        	movi	a13, 0x24c
4200c058:	60a2c2        	movi	a12, 0x260
4200c05b:	01dbf2        	addmi	a15, a11, 0x100
4200c05e:	0bed      	mov.n	a14, a11
4200c060:	dbda      	add.n	a13, a11, a13
4200c062:	cbca      	add.n	a12, a11, a12
4200c064:	02ad      	mov.n	a10, a2
4200c066:	0149      	s32i.n	a4, a1, 0
4200c068:	03bd      	mov.n	a11, a3
4200c06a:	b96192        	s32i	a9, a1, 0x2e4
4200c06d:	fe7465        	call8	4200a7b4 <get_arg$constprop$0>
4200c070:	0a28      	l32i.n	a2, a10, 0
4200c072:	9f2162        	l32i	a6, a1, 0x27c
4200c075:	b92192        	l32i	a9, a1, 0x2e4
4200c078:	001c86        	j	4200c0ee <_svfprintf_r+0x1442>
4200c07b:	00          	.byte 00
4200c07c:	9f2132        	l32i	a3, a1, 0x27c
4200c07f:	10c142        	addi	a4, a1, 16
4200c082:	631b      	addi.n	a6, a3, 1
4200c084:	b02240        	addx8	a2, a2, a4
4200c087:	612357        	blt	a3, a5, 4200c0ec <_svfprintf_r+0x1440>
4200c08a:	10c182        	addi	a8, a1, 16
4200c08d:	9a2872        	l32i	a7, a8, 0x268
4200c090:	02d822        	addmi	a2, a8, 0x200
4200c093:	f81c      	movi.n	a8, 31
4200c095:	374b      	addi.n	a3, a7, 4
4200c097:	841c      	movi.n	a4, 24
4200c099:	302857        	blt	a8, a5, 4200c0cd <_svfprintf_r+0x1421>
4200c09c:	851b      	addi.n	a8, a5, 1
4200c09e:	976182        	s32i	a8, a1, 0x25c
4200c0a1:	1a6232        	s32i	a3, a2, 104
4200c0a4:	052437        	blt	a4, a3, 4200c0ad <_svfprintf_r+0x1401>
4200c0a7:	192222        	l32i	a2, a2, 100
4200c0aa:	000286        	j	4200c0b8 <_svfprintf_r+0x140c>
4200c0ad:	012477        	blt	a4, a7, 4200c0b2 <_svfprintf_r+0x1406>
4200c0b0:	432c      	movi.n	a3, 36
4200c0b2:	9c2122        	l32i	a2, a1, 0x270
4200c0b5:	9e6132        	s32i	a3, a1, 0x278
4200c0b8:	9e2132        	l32i	a3, a1, 0x278
4200c0bb:	10c1b2        	addi	a11, a1, 16
4200c0be:	223a      	add.n	a2, a2, a3
4200c0c0:	fcc222        	addi	a2, a2, -4
4200c0c3:	0228      	l32i.n	a2, a2, 0
4200c0c5:	b035b0        	addx8	a3, a5, a11
4200c0c8:	0329      	s32i.n	a2, a3, 0
4200c0ca:	000806        	j	4200c0ee <_svfprintf_r+0x1442>
4200c0cd:	1a6232        	s32i	a3, a2, 104
4200c0d0:	052437        	blt	a4, a3, 4200c0d9 <_svfprintf_r+0x142d>
4200c0d3:	192222        	l32i	a2, a2, 100
4200c0d6:	000286        	j	4200c0e4 <_svfprintf_r+0x1438>
4200c0d9:	012477        	blt	a4, a7, 4200c0de <_svfprintf_r+0x1432>
4200c0dc:	432c      	movi.n	a3, 36
4200c0de:	9c2122        	l32i	a2, a1, 0x270
4200c0e1:	9e6132        	s32i	a3, a1, 0x278
4200c0e4:	9e2132        	l32i	a3, a1, 0x278
4200c0e7:	223a      	add.n	a2, a2, a3
4200c0e9:	fcc222        	addi	a2, a2, -4
4200c0ec:	0228      	l32i.n	a2, a2, 0
4200c0ee:	ad2132        	l32i	a3, a1, 0x2b4
4200c0f1:	004232        	s8i	a3, a2, 0
4200c0f4:	002ec6        	j	4200c1b3 <_svfprintf_r+0x1507>
4200c0f7:	00          	.byte 00
4200c0f8:	040416        	beqz	a4, 4200c13c <_svfprintf_r+0x1490>
4200c0fb:	0ea257        	bge	a2, a5, 4200c10d <_svfprintf_r+0x1461>
4200c0fe:	10c142        	addi	a4, a1, 16
4200c101:	b02240        	addx8	a2, a2, a4
4200c104:	0228      	l32i.n	a2, a2, 0
4200c106:	9f2162        	l32i	a6, a1, 0x27c
4200c109:	002846        	j	4200c1ae <_svfprintf_r+0x1502>
4200c10c:	00          	.byte 00
4200c10d:	58a252        	movi	a5, 0x258
4200c110:	10c162        	addi	a6, a1, 16
4200c113:	415a      	add.n	a4, a1, a5
4200c115:	4ca2d2        	movi	a13, 0x24c
4200c118:	60a2c2        	movi	a12, 0x260
4200c11b:	01d6f2        	addmi	a15, a6, 0x100
4200c11e:	06ed      	mov.n	a14, a6
4200c120:	d6da      	add.n	a13, a6, a13
4200c122:	c6ca      	add.n	a12, a6, a12
4200c124:	02ad      	mov.n	a10, a2
4200c126:	0149      	s32i.n	a4, a1, 0
4200c128:	03bd      	mov.n	a11, a3
4200c12a:	b96192        	s32i	a9, a1, 0x2e4
4200c12d:	fe6865        	call8	4200a7b4 <get_arg$constprop$0>
4200c130:	0a28      	l32i.n	a2, a10, 0
4200c132:	9f2162        	l32i	a6, a1, 0x27c
4200c135:	b92192        	l32i	a9, a1, 0x2e4
4200c138:	001c86        	j	4200c1ae <_svfprintf_r+0x1502>
4200c13b:	00          	.byte 00
4200c13c:	9f2182        	l32i	a8, a1, 0x27c
4200c13f:	10c1a2        	addi	a10, a1, 16
4200c142:	681b      	addi.n	a6, a8, 1
4200c144:	b022a0        	addx8	a2, a2, a10
4200c147:	612857        	blt	a8, a5, 4200c1ac <_svfprintf_r+0x1500>
4200c14a:	10c1b2        	addi	a11, a1, 16
4200c14d:	9a2b72        	l32i	a7, a11, 0x268
4200c150:	f81c      	movi.n	a8, 31
4200c152:	02db22        	addmi	a2, a11, 0x200
4200c155:	374b      	addi.n	a3, a7, 4
4200c157:	841c      	movi.n	a4, 24
4200c159:	302857        	blt	a8, a5, 4200c18d <_svfprintf_r+0x14e1>
4200c15c:	851b      	addi.n	a8, a5, 1
4200c15e:	976182        	s32i	a8, a1, 0x25c
4200c161:	1a6232        	s32i	a3, a2, 104
4200c164:	052437        	blt	a4, a3, 4200c16d <_svfprintf_r+0x14c1>
4200c167:	192222        	l32i	a2, a2, 100
4200c16a:	000286        	j	4200c178 <_svfprintf_r+0x14cc>
4200c16d:	012477        	blt	a4, a7, 4200c172 <_svfprintf_r+0x14c6>
4200c170:	432c      	movi.n	a3, 36
4200c172:	9c2122        	l32i	a2, a1, 0x270
4200c175:	9e6132        	s32i	a3, a1, 0x278
4200c178:	9e2132        	l32i	a3, a1, 0x278
4200c17b:	223a      	add.n	a2, a2, a3
4200c17d:	fcc222        	addi	a2, a2, -4
4200c180:	0228      	l32i.n	a2, a2, 0
4200c182:	10c132        	addi	a3, a1, 16
4200c185:	b05530        	addx8	a5, a5, a3
4200c188:	0529      	s32i.n	a2, a5, 0
4200c18a:	000806        	j	4200c1ae <_svfprintf_r+0x1502>
4200c18d:	1a6232        	s32i	a3, a2, 104
4200c190:	052437        	blt	a4, a3, 4200c199 <_svfprintf_r+0x14ed>
4200c193:	192222        	l32i	a2, a2, 100
4200c196:	000286        	j	4200c1a4 <_svfprintf_r+0x14f8>
4200c199:	012477        	blt	a4, a7, 4200c19e <_svfprintf_r+0x14f2>
4200c19c:	432c      	movi.n	a3, 36
4200c19e:	9c2122        	l32i	a2, a1, 0x270
4200c1a1:	9e6132        	s32i	a3, a1, 0x278
4200c1a4:	9e2132        	l32i	a3, a1, 0x278
4200c1a7:	223a      	add.n	a2, a2, a3
4200c1a9:	fcc222        	addi	a2, a2, -4
4200c1ac:	0228      	l32i.n	a2, a2, 0
4200c1ae:	ad2152        	l32i	a5, a1, 0x2b4
4200c1b1:	0259      	s32i.n	a5, a2, 0
4200c1b3:	9f6162        	s32i	a6, a1, 0x27c
4200c1b6:	fae886        	j	4200ad5c <_svfprintf_r+0xb0>
4200c1b9:	00          	.byte 00
4200c1ba:	00          	.byte 00
4200c1bb:	00          	.byte 00
4200c1bc:	a02162        	l32i	a6, a1, 0x280
4200c1bf:	051c      	movi.n	a5, 16
4200c1c1:	206650        	or	a6, a6, a5
4200c1c4:	a06162        	s32i	a6, a1, 0x280
4200c1c7:	a02182        	l32i	a8, a1, 0x280
4200c1ca:	972162        	l32i	a6, a1, 0x25c
4200c1cd:	02e857        	bbsi	a8, 5, 4200c1d3 <_svfprintf_r+0x1527>
4200c1d0:	003206        	j	4200c29c <_svfprintf_r+0x15f0>
4200c1d3:	041416        	beqz	a4, 4200c218 <_svfprintf_r+0x156c>
4200c1d6:	0fa267        	bge	a2, a6, 4200c1e9 <_svfprintf_r+0x153d>
4200c1d9:	10c1a2        	addi	a10, a1, 16
4200c1dc:	b022a0        	addx8	a2, a2, a10
4200c1df:	0238      	l32i.n	a3, a2, 0
4200c1e1:	1248      	l32i.n	a4, a2, 4
4200c1e3:	9f2152        	l32i	a5, a1, 0x27c
4200c1e6:	00db86        	j	4200c558 <_svfprintf_r+0x18ac>
4200c1e9:	58a2b2        	movi	a11, 0x258
4200c1ec:	10c1e2        	addi	a14, a1, 16
4200c1ef:	41ba      	add.n	a4, a1, a11
4200c1f1:	4ca2d2        	movi	a13, 0x24c
4200c1f4:	60a2c2        	movi	a12, 0x260
4200c1f7:	0149      	s32i.n	a4, a1, 0
4200c1f9:	03bd      	mov.n	a11, a3
4200c1fb:	01def2        	addmi	a15, a14, 0x100
4200c1fe:	deda      	add.n	a13, a14, a13
4200c200:	ceca      	add.n	a12, a14, a12
4200c202:	02ad      	mov.n	a10, a2
4200c204:	b96192        	s32i	a9, a1, 0x2e4
4200c207:	fe5ae5        	call8	4200a7b4 <get_arg$constprop$0>
4200c20a:	0a38      	l32i.n	a3, a10, 0
4200c20c:	1a48      	l32i.n	a4, a10, 4
4200c20e:	9f2152        	l32i	a5, a1, 0x27c
4200c211:	b92192        	l32i	a9, a1, 0x2e4
4200c214:	00d006        	j	4200c558 <_svfprintf_r+0x18ac>
4200c217:	00          	.byte 00
4200c218:	9f2132        	l32i	a3, a1, 0x27c
4200c21b:	10c142        	addi	a4, a1, 16
4200c21e:	531b      	addi.n	a5, a3, 1
4200c220:	b02240        	addx8	a2, a2, a4
4200c223:	6d2367        	blt	a3, a6, 4200c294 <_svfprintf_r+0x15e8>
4200c226:	10c182        	addi	a8, a1, 16
4200c229:	9a2842        	l32i	a4, a8, 0x268
4200c22c:	837c      	movi.n	a3, -8
4200c22e:	447b      	addi.n	a4, a4, 7
4200c230:	02d822        	addmi	a2, a8, 0x200
4200c233:	104430        	and	a4, a4, a3
4200c236:	f81c      	movi.n	a8, 31
4200c238:	348b      	addi.n	a3, a4, 8
4200c23a:	871c      	movi.n	a7, 24
4200c23c:	342867        	blt	a8, a6, 4200c274 <_svfprintf_r+0x15c8>
4200c23f:	861b      	addi.n	a8, a6, 1
4200c241:	976182        	s32i	a8, a1, 0x25c
4200c244:	1a6232        	s32i	a3, a2, 104
4200c247:	052737        	blt	a7, a3, 4200c250 <_svfprintf_r+0x15a4>
4200c24a:	192222        	l32i	a2, a2, 100
4200c24d:	000286        	j	4200c25b <_svfprintf_r+0x15af>
4200c250:	012747        	blt	a7, a4, 4200c255 <_svfprintf_r+0x15a9>
4200c253:	832c      	movi.n	a3, 40
4200c255:	9c2122        	l32i	a2, a1, 0x270
4200c258:	9e6132        	s32i	a3, a1, 0x278
4200c25b:	9e2132        	l32i	a3, a1, 0x278
4200c25e:	10c1b2        	addi	a11, a1, 16
4200c261:	223a      	add.n	a2, a2, a3
4200c263:	f8c222        	addi	a2, a2, -8
4200c266:	0238      	l32i.n	a3, a2, 0
4200c268:	1248      	l32i.n	a4, a2, 4
4200c26a:	b026b0        	addx8	a2, a6, a11
4200c26d:	0239      	s32i.n	a3, a2, 0
4200c26f:	1249      	s32i.n	a4, a2, 4
4200c271:	00b8c6        	j	4200c558 <_svfprintf_r+0x18ac>
4200c274:	1a6232        	s32i	a3, a2, 104
4200c277:	052737        	blt	a7, a3, 4200c280 <_svfprintf_r+0x15d4>
4200c27a:	192222        	l32i	a2, a2, 100
4200c27d:	000286        	j	4200c28b <_svfprintf_r+0x15df>
4200c280:	012747        	blt	a7, a4, 4200c285 <_svfprintf_r+0x15d9>
4200c283:	832c      	movi.n	a3, 40
4200c285:	9c2122        	l32i	a2, a1, 0x270
4200c288:	9e6132        	s32i	a3, a1, 0x278
4200c28b:	9e2132        	l32i	a3, a1, 0x278
4200c28e:	802230        	add	a2, a2, a3
4200c291:	f8c222        	addi	a2, a2, -8
4200c294:	0238      	l32i.n	a3, a2, 0
4200c296:	1248      	l32i.n	a4, a2, 4
4200c298:	00af06        	j	4200c558 <_svfprintf_r+0x18ac>
4200c29b:	00          	.byte 00
4200c29c:	a02152        	l32i	a5, a1, 0x280
4200c29f:	796547        	bbci	a5, 4, 4200c31c <_svfprintf_r+0x1670>
4200c2a2:	f49c      	beqz.n	a4, 4200c2c5 <_svfprintf_r+0x1619>
4200c2a4:	08a267        	bge	a2, a6, 4200c2b0 <_svfprintf_r+0x1604>
4200c2a7:	10c162        	addi	a6, a1, 16
4200c2aa:	b02260        	addx8	a2, a2, a6
4200c2ad:	007f06        	j	4200c4ad <_svfprintf_r+0x1801>
4200c2b0:	58a282        	movi	a8, 0x258
4200c2b3:	10c1a2        	addi	a10, a1, 16
4200c2b6:	418a      	add.n	a4, a1, a8
4200c2b8:	0149      	s32i.n	a4, a1, 0
4200c2ba:	01daf2        	addmi	a15, a10, 0x100
4200c2bd:	4ca2d2        	movi	a13, 0x24c
4200c2c0:	0aed      	mov.n	a14, a10
4200c2c2:	008046        	j	4200c4c7 <_svfprintf_r+0x181b>
4200c2c5:	9f2132        	l32i	a3, a1, 0x27c
4200c2c8:	10c142        	addi	a4, a1, 16
4200c2cb:	531b      	addi.n	a5, a3, 1
4200c2cd:	b02240        	addx8	a2, a2, a4
4200c2d0:	02a367        	bge	a3, a6, 4200c2d6 <_svfprintf_r+0x162a>
4200c2d3:	009f46        	j	4200c554 <_svfprintf_r+0x18a8>
4200c2d6:	10c182        	addi	a8, a1, 16
4200c2d9:	9a2872        	l32i	a7, a8, 0x268
4200c2dc:	02d822        	addmi	a2, a8, 0x200
4200c2df:	f81c      	movi.n	a8, 31
4200c2e1:	374b      	addi.n	a3, a7, 4
4200c2e3:	841c      	movi.n	a4, 24
4200c2e5:	02a867        	bge	a8, a6, 4200c2eb <_svfprintf_r+0x163f>
4200c2e8:	009246        	j	4200c535 <_svfprintf_r+0x1889>
4200c2eb:	861b      	addi.n	a8, a6, 1
4200c2ed:	976182        	s32i	a8, a1, 0x25c
4200c2f0:	1a6232        	s32i	a3, a2, 104
4200c2f3:	052437        	blt	a4, a3, 4200c2fc <_svfprintf_r+0x1650>
4200c2f6:	192222        	l32i	a2, a2, 100
4200c2f9:	000286        	j	4200c307 <_svfprintf_r+0x165b>
4200c2fc:	012477        	blt	a4, a7, 4200c301 <_svfprintf_r+0x1655>
4200c2ff:	432c      	movi.n	a3, 36
4200c301:	9c2122        	l32i	a2, a1, 0x270
4200c304:	9e6132        	s32i	a3, a1, 0x278
4200c307:	9e2132        	l32i	a3, a1, 0x278
4200c30a:	10c1b2        	addi	a11, a1, 16
4200c30d:	223a      	add.n	a2, a2, a3
4200c30f:	fcc222        	addi	a2, a2, -4
4200c312:	0238      	l32i.n	a3, a2, 0
4200c314:	b026b0        	addx8	a2, a6, a11
4200c317:	0239      	s32i.n	a3, a2, 0
4200c319:	008e46        	j	4200c556 <_svfprintf_r+0x18aa>
4200c31c:	a02152        	l32i	a5, a1, 0x280
4200c31f:	02e567        	bbsi	a5, 6, 4200c325 <_svfprintf_r+0x1679>
4200c322:	002e86        	j	4200c3e0 <_svfprintf_r+0x1734>
4200c325:	b4bc      	beqz.n	a4, 4200c364 <_svfprintf_r+0x16b8>
4200c327:	0ea267        	bge	a2, a6, 4200c339 <_svfprintf_r+0x168d>
4200c32a:	10c162        	addi	a6, a1, 16
4200c32d:	b02260        	addx8	a2, a2, a6
4200c330:	001232        	l16ui	a3, a2, 0
4200c333:	005e06        	j	4200c4af <_svfprintf_r+0x1803>
4200c336:	00          	.byte 00
4200c337:	00          	.byte 00
4200c338:	00          	.byte 00
4200c339:	58a282        	movi	a8, 0x258
4200c33c:	10c1a2        	addi	a10, a1, 16
4200c33f:	418a      	add.n	a4, a1, a8
4200c341:	4ca2d2        	movi	a13, 0x24c
4200c344:	60a2c2        	movi	a12, 0x260
4200c347:	01daf2        	addmi	a15, a10, 0x100
4200c34a:	0aed      	mov.n	a14, a10
4200c34c:	dada      	add.n	a13, a10, a13
4200c34e:	caca      	add.n	a12, a10, a12
4200c350:	03bd      	mov.n	a11, a3
4200c352:	0149      	s32i.n	a4, a1, 0
4200c354:	02ad      	mov.n	a10, a2
4200c356:	b96192        	s32i	a9, a1, 0x2e4
4200c359:	fe45a5        	call8	4200a7b4 <get_arg$constprop$0>
4200c35c:	001a32        	l16ui	a3, a10, 0
4200c35f:	005dc6        	j	4200c4da <_svfprintf_r+0x182e>
4200c362:	00          	.byte 00
4200c363:	00          	.byte 00
4200c364:	9f2132        	l32i	a3, a1, 0x27c
4200c367:	10c142        	addi	a4, a1, 16
4200c36a:	531b      	addi.n	a5, a3, 1
4200c36c:	b02240        	addx8	a2, a2, a4
4200c36f:	652367        	blt	a3, a6, 4200c3d8 <_svfprintf_r+0x172c>
4200c372:	10c182        	addi	a8, a1, 16
4200c375:	9a2872        	l32i	a7, a8, 0x268
4200c378:	02d822        	addmi	a2, a8, 0x200
4200c37b:	f81c      	movi.n	a8, 31
4200c37d:	374b      	addi.n	a3, a7, 4
4200c37f:	841c      	movi.n	a4, 24
4200c381:	332867        	blt	a8, a6, 4200c3b8 <_svfprintf_r+0x170c>
4200c384:	861b      	addi.n	a8, a6, 1
4200c386:	976182        	s32i	a8, a1, 0x25c
4200c389:	1a6232        	s32i	a3, a2, 104
4200c38c:	052437        	blt	a4, a3, 4200c395 <_svfprintf_r+0x16e9>
4200c38f:	192222        	l32i	a2, a2, 100
4200c392:	000286        	j	4200c3a0 <_svfprintf_r+0x16f4>
4200c395:	012477        	blt	a4, a7, 4200c39a <_svfprintf_r+0x16ee>
4200c398:	432c      	movi.n	a3, 36
4200c39a:	9c2122        	l32i	a2, a1, 0x270
4200c39d:	9e6132        	s32i	a3, a1, 0x278
4200c3a0:	9e2132        	l32i	a3, a1, 0x278
4200c3a3:	10c1b2        	addi	a11, a1, 16
4200c3a6:	223a      	add.n	a2, a2, a3
4200c3a8:	fcc222        	addi	a2, a2, -4
4200c3ab:	0238      	l32i.n	a3, a2, 0
4200c3ad:	b026b0        	addx8	a2, a6, a11
4200c3b0:	0239      	s32i.n	a3, a2, 0
4200c3b2:	f43030        	extui	a3, a3, 0, 16
4200c3b5:	006746        	j	4200c556 <_svfprintf_r+0x18aa>
4200c3b8:	1a6232        	s32i	a3, a2, 104
4200c3bb:	052437        	blt	a4, a3, 4200c3c4 <_svfprintf_r+0x1718>
4200c3be:	192222        	l32i	a2, a2, 100
4200c3c1:	000286        	j	4200c3cf <_svfprintf_r+0x1723>
4200c3c4:	012477        	blt	a4, a7, 4200c3c9 <_svfprintf_r+0x171d>
4200c3c7:	432c      	movi.n	a3, 36
4200c3c9:	9c2122        	l32i	a2, a1, 0x270
4200c3cc:	9e6132        	s32i	a3, a1, 0x278
4200c3cf:	9e2132        	l32i	a3, a1, 0x278
4200c3d2:	802230        	add	a2, a2, a3
4200c3d5:	fcc222        	addi	a2, a2, -4
4200c3d8:	001232        	l16ui	a3, a2, 0
4200c3db:	005dc6        	j	4200c556 <_svfprintf_r+0x18aa>
4200c3de:	00          	.byte 00
4200c3df:	00          	.byte 00
4200c3e0:	a02152        	l32i	a5, a1, 0x280
4200c3e3:	02e597        	bbsi	a5, 9, 4200c3e9 <_svfprintf_r+0x173d>
4200c3e6:	002e06        	j	4200c4a2 <_svfprintf_r+0x17f6>
4200c3e9:	b4bc      	beqz.n	a4, 4200c428 <_svfprintf_r+0x177c>
4200c3eb:	0ea267        	bge	a2, a6, 4200c3fd <_svfprintf_r+0x1751>
4200c3ee:	10c162        	addi	a6, a1, 16
4200c3f1:	b02260        	addx8	a2, a2, a6
4200c3f4:	000232        	l8ui	a3, a2, 0
4200c3f7:	002d06        	j	4200c4af <_svfprintf_r+0x1803>
4200c3fa:	00          	.byte 00
4200c3fb:	00          	.byte 00
4200c3fc:	00          	.byte 00
4200c3fd:	58a282        	movi	a8, 0x258
4200c400:	10c1a2        	addi	a10, a1, 16
4200c403:	418a      	add.n	a4, a1, a8
4200c405:	4ca2d2        	movi	a13, 0x24c
4200c408:	60a2c2        	movi	a12, 0x260
4200c40b:	01daf2        	addmi	a15, a10, 0x100
4200c40e:	0aed      	mov.n	a14, a10
4200c410:	dada      	add.n	a13, a10, a13
4200c412:	caca      	add.n	a12, a10, a12
4200c414:	03bd      	mov.n	a11, a3
4200c416:	0149      	s32i.n	a4, a1, 0
4200c418:	02ad      	mov.n	a10, a2
4200c41a:	b96192        	s32i	a9, a1, 0x2e4
4200c41d:	fe3965        	call8	4200a7b4 <get_arg$constprop$0>
4200c420:	000a32        	l8ui	a3, a10, 0
4200c423:	002cc6        	j	4200c4da <_svfprintf_r+0x182e>
4200c426:	00          	.byte 00
4200c427:	00          	.byte 00
4200c428:	9f2132        	l32i	a3, a1, 0x27c
4200c42b:	10c142        	addi	a4, a1, 16
4200c42e:	531b      	addi.n	a5, a3, 1
4200c430:	b02240        	addx8	a2, a2, a4
4200c433:	652367        	blt	a3, a6, 4200c49c <_svfprintf_r+0x17f0>
4200c436:	10c182        	addi	a8, a1, 16
4200c439:	9a2872        	l32i	a7, a8, 0x268
4200c43c:	02d822        	addmi	a2, a8, 0x200
4200c43f:	f81c      	movi.n	a8, 31
4200c441:	374b      	addi.n	a3, a7, 4
4200c443:	841c      	movi.n	a4, 24
4200c445:	332867        	blt	a8, a6, 4200c47c <_svfprintf_r+0x17d0>
4200c448:	861b      	addi.n	a8, a6, 1
4200c44a:	976182        	s32i	a8, a1, 0x25c
4200c44d:	1a6232        	s32i	a3, a2, 104
4200c450:	052437        	blt	a4, a3, 4200c459 <_svfprintf_r+0x17ad>
4200c453:	192222        	l32i	a2, a2, 100
4200c456:	000286        	j	4200c464 <_svfprintf_r+0x17b8>
4200c459:	012477        	blt	a4, a7, 4200c45e <_svfprintf_r+0x17b2>
4200c45c:	432c      	movi.n	a3, 36
4200c45e:	9c2122        	l32i	a2, a1, 0x270
4200c461:	9e6132        	s32i	a3, a1, 0x278
4200c464:	9e2132        	l32i	a3, a1, 0x278
4200c467:	10c1b2        	addi	a11, a1, 16
4200c46a:	223a      	add.n	a2, a2, a3
4200c46c:	fcc222        	addi	a2, a2, -4
4200c46f:	0238      	l32i.n	a3, a2, 0
4200c471:	b026b0        	addx8	a2, a6, a11
4200c474:	0239      	s32i.n	a3, a2, 0
4200c476:	743030        	extui	a3, a3, 0, 8
4200c479:	003646        	j	4200c556 <_svfprintf_r+0x18aa>
4200c47c:	1a6232        	s32i	a3, a2, 104
4200c47f:	052437        	blt	a4, a3, 4200c488 <_svfprintf_r+0x17dc>
4200c482:	192222        	l32i	a2, a2, 100
4200c485:	000286        	j	4200c493 <_svfprintf_r+0x17e7>
4200c488:	012477        	blt	a4, a7, 4200c48d <_svfprintf_r+0x17e1>
4200c48b:	432c      	movi.n	a3, 36
4200c48d:	9c2122        	l32i	a2, a1, 0x270
4200c490:	9e6132        	s32i	a3, a1, 0x278
4200c493:	9e2132        	l32i	a3, a1, 0x278
4200c496:	802230        	add	a2, a2, a3
4200c499:	fcc222        	addi	a2, a2, -4
4200c49c:	000232        	l8ui	a3, a2, 0
4200c49f:	002cc6        	j	4200c556 <_svfprintf_r+0x18aa>
4200c4a2:	e4bc      	beqz.n	a4, 4200c4e4 <_svfprintf_r+0x1838>
4200c4a4:	0da267        	bge	a2, a6, 4200c4b5 <_svfprintf_r+0x1809>
4200c4a7:	10c132        	addi	a3, a1, 16
4200c4aa:	b02230        	addx8	a2, a2, a3
4200c4ad:	0238      	l32i.n	a3, a2, 0
4200c4af:	9f2152        	l32i	a5, a1, 0x27c
4200c4b2:	002806        	j	4200c556 <_svfprintf_r+0x18aa>
4200c4b5:	58a252        	movi	a5, 0x258
4200c4b8:	10c162        	addi	a6, a1, 16
4200c4bb:	415a      	add.n	a4, a1, a5
4200c4bd:	0149      	s32i.n	a4, a1, 0
4200c4bf:	01d6f2        	addmi	a15, a6, 0x100
4200c4c2:	4ca2d2        	movi	a13, 0x24c
4200c4c5:	06ed      	mov.n	a14, a6
4200c4c7:	60a2c2        	movi	a12, 0x260
4200c4ca:	03bd      	mov.n	a11, a3
4200c4cc:	deda      	add.n	a13, a14, a13
4200c4ce:	ceca      	add.n	a12, a14, a12
4200c4d0:	02ad      	mov.n	a10, a2
4200c4d2:	b96192        	s32i	a9, a1, 0x2e4
4200c4d5:	fe2de5        	call8	4200a7b4 <get_arg$constprop$0>
4200c4d8:	0a38      	l32i.n	a3, a10, 0
4200c4da:	9f2152        	l32i	a5, a1, 0x27c
4200c4dd:	b92192        	l32i	a9, a1, 0x2e4
4200c4e0:	001c86        	j	4200c556 <_svfprintf_r+0x18aa>
4200c4e3:	00          	.byte 00
4200c4e4:	9f2182        	l32i	a8, a1, 0x27c
4200c4e7:	10c1a2        	addi	a10, a1, 16
4200c4ea:	581b      	addi.n	a5, a8, 1
4200c4ec:	b022a0        	addx8	a2, a2, a10
4200c4ef:	612867        	blt	a8, a6, 4200c554 <_svfprintf_r+0x18a8>
4200c4f2:	10c1b2        	addi	a11, a1, 16
4200c4f5:	9a2b72        	l32i	a7, a11, 0x268
4200c4f8:	f81c      	movi.n	a8, 31
4200c4fa:	02db22        	addmi	a2, a11, 0x200
4200c4fd:	374b      	addi.n	a3, a7, 4
4200c4ff:	841c      	movi.n	a4, 24
4200c501:	302867        	blt	a8, a6, 4200c535 <_svfprintf_r+0x1889>
4200c504:	861b      	addi.n	a8, a6, 1
4200c506:	976182        	s32i	a8, a1, 0x25c
4200c509:	1a6232        	s32i	a3, a2, 104
4200c50c:	052437        	blt	a4, a3, 4200c515 <_svfprintf_r+0x1869>
4200c50f:	192222        	l32i	a2, a2, 100
4200c512:	000286        	j	4200c520 <_svfprintf_r+0x1874>
4200c515:	012477        	blt	a4, a7, 4200c51a <_svfprintf_r+0x186e>
4200c518:	432c      	movi.n	a3, 36
4200c51a:	9c2122        	l32i	a2, a1, 0x270
4200c51d:	9e6132        	s32i	a3, a1, 0x278
4200c520:	9e2132        	l32i	a3, a1, 0x278
4200c523:	223a      	add.n	a2, a2, a3
4200c525:	fcc222        	addi	a2, a2, -4
4200c528:	0238      	l32i.n	a3, a2, 0
4200c52a:	10c122        	addi	a2, a1, 16
4200c52d:	b06620        	addx8	a6, a6, a2
4200c530:	0639      	s32i.n	a3, a6, 0
4200c532:	000806        	j	4200c556 <_svfprintf_r+0x18aa>
4200c535:	1a6232        	s32i	a3, a2, 104
4200c538:	052437        	blt	a4, a3, 4200c541 <_svfprintf_r+0x1895>
4200c53b:	192222        	l32i	a2, a2, 100
4200c53e:	000286        	j	4200c54c <_svfprintf_r+0x18a0>
4200c541:	012477        	blt	a4, a7, 4200c546 <_svfprintf_r+0x189a>
4200c544:	432c      	movi.n	a3, 36
4200c546:	9c2122        	l32i	a2, a1, 0x270
4200c549:	9e6132        	s32i	a3, a1, 0x278
4200c54c:	9e2132        	l32i	a3, a1, 0x278
4200c54f:	223a      	add.n	a2, a2, a3
4200c551:	fcc222        	addi	a2, a2, -4
4200c554:	0238      	l32i.n	a3, a2, 0
4200c556:	040c      	movi.n	a4, 0
4200c558:	a02162        	l32i	a6, a1, 0x280
4200c55b:	ffab22        	movi	a2, 0xfffffbff
4200c55e:	106620        	and	a6, a6, a2
4200c561:	a06162        	s32i	a6, a1, 0x280
4200c564:	020c      	movi.n	a2, 0
4200c566:	026206        	j	4200cef2 <_svfprintf_r+0x2246>
4200c569:	00          	.byte 00
4200c56a:	00          	.byte 00
4200c56b:	972162        	l32i	a6, a1, 0x25c
4200c56e:	e4bc      	beqz.n	a4, 4200c5b0 <_svfprintf_r+0x1904>
4200c570:	0da267        	bge	a2, a6, 4200c581 <_svfprintf_r+0x18d5>
4200c573:	10c182        	addi	a8, a1, 16
4200c576:	b02280        	addx8	a2, a2, a8
4200c579:	0238      	l32i.n	a3, a2, 0
4200c57b:	9f2152        	l32i	a5, a1, 0x27c
4200c57e:	002806        	j	4200c622 <_svfprintf_r+0x1976>
4200c581:	58a2a2        	movi	a10, 0x258
4200c584:	10c1b2        	addi	a11, a1, 16
4200c587:	41aa      	add.n	a4, a1, a10
4200c589:	4ca2d2        	movi	a13, 0x24c
4200c58c:	60a2c2        	movi	a12, 0x260
4200c58f:	01dbf2        	addmi	a15, a11, 0x100
4200c592:	0bed      	mov.n	a14, a11
4200c594:	dbda      	add.n	a13, a11, a13
4200c596:	cbca      	add.n	a12, a11, a12
4200c598:	0149      	s32i.n	a4, a1, 0
4200c59a:	03bd      	mov.n	a11, a3
4200c59c:	02ad      	mov.n	a10, a2
4200c59e:	b96192        	s32i	a9, a1, 0x2e4
4200c5a1:	fe2125        	call8	4200a7b4 <get_arg$constprop$0>
4200c5a4:	0a38      	l32i.n	a3, a10, 0
4200c5a6:	9f2152        	l32i	a5, a1, 0x27c
4200c5a9:	b92192        	l32i	a9, a1, 0x2e4
4200c5ac:	001c86        	j	4200c622 <_svfprintf_r+0x1976>
4200c5af:	00          	.byte 00
4200c5b0:	9f2132        	l32i	a3, a1, 0x27c
4200c5b3:	10c142        	addi	a4, a1, 16
4200c5b6:	531b      	addi.n	a5, a3, 1
4200c5b8:	b02240        	addx8	a2, a2, a4
4200c5bb:	612367        	blt	a3, a6, 4200c620 <_svfprintf_r+0x1974>
4200c5be:	10c182        	addi	a8, a1, 16
4200c5c1:	9a2872        	l32i	a7, a8, 0x268
4200c5c4:	02d822        	addmi	a2, a8, 0x200
4200c5c7:	f81c      	movi.n	a8, 31
4200c5c9:	374b      	addi.n	a3, a7, 4
4200c5cb:	841c      	movi.n	a4, 24
4200c5cd:	302867        	blt	a8, a6, 4200c601 <_svfprintf_r+0x1955>
4200c5d0:	861b      	addi.n	a8, a6, 1
4200c5d2:	976182        	s32i	a8, a1, 0x25c
4200c5d5:	1a6232        	s32i	a3, a2, 104
4200c5d8:	052437        	blt	a4, a3, 4200c5e1 <_svfprintf_r+0x1935>
4200c5db:	192222        	l32i	a2, a2, 100
4200c5de:	000286        	j	4200c5ec <_svfprintf_r+0x1940>
4200c5e1:	012477        	blt	a4, a7, 4200c5e6 <_svfprintf_r+0x193a>
4200c5e4:	432c      	movi.n	a3, 36
4200c5e6:	9c2122        	l32i	a2, a1, 0x270
4200c5e9:	9e6132        	s32i	a3, a1, 0x278
4200c5ec:	9e2132        	l32i	a3, a1, 0x278
4200c5ef:	10c1b2        	addi	a11, a1, 16
4200c5f2:	223a      	add.n	a2, a2, a3
4200c5f4:	fcc222        	addi	a2, a2, -4
4200c5f7:	0238      	l32i.n	a3, a2, 0
4200c5f9:	b066b0        	addx8	a6, a6, a11
4200c5fc:	0639      	s32i.n	a3, a6, 0
4200c5fe:	000806        	j	4200c622 <_svfprintf_r+0x1976>
4200c601:	1a6232        	s32i	a3, a2, 104
4200c604:	052437        	blt	a4, a3, 4200c60d <_svfprintf_r+0x1961>
4200c607:	192222        	l32i	a2, a2, 100
4200c60a:	000286        	j	4200c618 <_svfprintf_r+0x196c>
4200c60d:	012477        	blt	a4, a7, 4200c612 <_svfprintf_r+0x1966>
4200c610:	432c      	movi.n	a3, 36
4200c612:	9c2122        	l32i	a2, a1, 0x270
4200c615:	9e6132        	s32i	a3, a1, 0x278
4200c618:	9e2132        	l32i	a3, a1, 0x278
4200c61b:	223a      	add.n	a2, a2, a3
4200c61d:	fcc222        	addi	a2, a2, -4
4200c620:	0238      	l32i.n	a3, a2, 0
4200c622:	a02162        	l32i	a6, a1, 0x280
4200c625:	220c      	movi.n	a2, 2
4200c627:	206620        	or	a6, a6, a2
4200c62a:	10c182        	addi	a8, a1, 16
4200c62d:	073c      	movi.n	a7, 48
4200c62f:	a06162        	s32i	a6, a1, 0x280
4200c632:	02d862        	addmi	a6, a8, 0x200
4200c635:	504672        	s8i	a7, a6, 80
4200c638:	78a072        	movi	a7, 120
4200c63b:	514672        	s8i	a7, a6, 81
4200c63e:	d16361        	l32r	a6, 42000bcc <_stext+0xbac>
4200c641:	78a082        	movi	a8, 120
4200c644:	040c      	movi.n	a4, 0
4200c646:	b46162        	s32i	a6, a1, 0x2d0
4200c649:	a76182        	s32i	a8, a1, 0x29c
4200c64c:	022886        	j	4200cef2 <_svfprintf_r+0x2246>
4200c64f:	972152        	l32i	a5, a1, 0x25c
4200c652:	b4bc      	beqz.n	a4, 4200c691 <_svfprintf_r+0x19e5>
4200c654:	0da257        	bge	a2, a5, 4200c665 <_svfprintf_r+0x19b9>
4200c657:	10c1a2        	addi	a10, a1, 16
4200c65a:	b022a0        	addx8	a2, a2, a10
4200c65d:	0228      	l32i.n	a2, a2, 0
4200c65f:	a16122        	s32i	a2, a1, 0x284
4200c662:	002a86        	j	4200c710 <_svfprintf_r+0x1a64>
4200c665:	58a2b2        	movi	a11, 0x258
4200c668:	10c1e2        	addi	a14, a1, 16
4200c66b:	41ba      	add.n	a4, a1, a11
4200c66d:	4ca2d2        	movi	a13, 0x24c
4200c670:	60a2c2        	movi	a12, 0x260
4200c673:	0149      	s32i.n	a4, a1, 0
4200c675:	01def2        	addmi	a15, a14, 0x100
4200c678:	deda      	add.n	a13, a14, a13
4200c67a:	ceca      	add.n	a12, a14, a12
4200c67c:	03bd      	mov.n	a11, a3
4200c67e:	02ad      	mov.n	a10, a2
4200c680:	b96192        	s32i	a9, a1, 0x2e4
4200c683:	fe1325        	call8	4200a7b4 <get_arg$constprop$0>
4200c686:	0aa8      	l32i.n	a10, a10, 0
4200c688:	b92192        	l32i	a9, a1, 0x2e4
4200c68b:	a161a2        	s32i	a10, a1, 0x284
4200c68e:	001f86        	j	4200c710 <_svfprintf_r+0x1a64>
4200c691:	9f2132        	l32i	a3, a1, 0x27c
4200c694:	10c142        	addi	a4, a1, 16
4200c697:	631b      	addi.n	a6, a3, 1
4200c699:	b02240        	addx8	a2, a2, a4
4200c69c:	682357        	blt	a3, a5, 4200c708 <_svfprintf_r+0x1a5c>
4200c69f:	10c182        	addi	a8, a1, 16
4200c6a2:	9a2872        	l32i	a7, a8, 0x268
4200c6a5:	02d822        	addmi	a2, a8, 0x200
4200c6a8:	f81c      	movi.n	a8, 31
4200c6aa:	374b      	addi.n	a3, a7, 4
4200c6ac:	841c      	movi.n	a4, 24
4200c6ae:	362857        	blt	a8, a5, 4200c6e8 <_svfprintf_r+0x1a3c>
4200c6b1:	851b      	addi.n	a8, a5, 1
4200c6b3:	976182        	s32i	a8, a1, 0x25c
4200c6b6:	1a6232        	s32i	a3, a2, 104
4200c6b9:	072437        	blt	a4, a3, 4200c6c4 <_svfprintf_r+0x1a18>
4200c6bc:	192222        	l32i	a2, a2, 100
4200c6bf:	000306        	j	4200c6cf <_svfprintf_r+0x1a23>
4200c6c2:	00          	.byte 00
4200c6c3:	00          	.byte 00
4200c6c4:	012477        	blt	a4, a7, 4200c6c9 <_svfprintf_r+0x1a1d>
4200c6c7:	432c      	movi.n	a3, 36
4200c6c9:	9c2122        	l32i	a2, a1, 0x270
4200c6cc:	9e6132        	s32i	a3, a1, 0x278
4200c6cf:	9e2132        	l32i	a3, a1, 0x278
4200c6d2:	10c1b2        	addi	a11, a1, 16
4200c6d5:	223a      	add.n	a2, a2, a3
4200c6d7:	fcc222        	addi	a2, a2, -4
4200c6da:	0228      	l32i.n	a2, a2, 0
4200c6dc:	b055b0        	addx8	a5, a5, a11
4200c6df:	a16122        	s32i	a2, a1, 0x284
4200c6e2:	0529      	s32i.n	a2, a5, 0
4200c6e4:	000946        	j	4200c70d <_svfprintf_r+0x1a61>
4200c6e7:	00          	.byte 00
4200c6e8:	1a6232        	s32i	a3, a2, 104
4200c6eb:	052437        	blt	a4, a3, 4200c6f4 <_svfprintf_r+0x1a48>
4200c6ee:	192222        	l32i	a2, a2, 100
4200c6f1:	000286        	j	4200c6ff <_svfprintf_r+0x1a53>
4200c6f4:	012477        	blt	a4, a7, 4200c6f9 <_svfprintf_r+0x1a4d>
4200c6f7:	432c      	movi.n	a3, 36
4200c6f9:	9c2122        	l32i	a2, a1, 0x270
4200c6fc:	9e6132        	s32i	a3, a1, 0x278
4200c6ff:	9e2132        	l32i	a3, a1, 0x278
4200c702:	802230        	add	a2, a2, a3
4200c705:	fcc222        	addi	a2, a2, -4
4200c708:	0228      	l32i.n	a2, a2, 0
4200c70a:	a16122        	s32i	a2, a1, 0x284
4200c70d:	9f6162        	s32i	a6, a1, 0x27c
4200c710:	10c132        	addi	a3, a1, 16
4200c713:	02d322        	addmi	a2, a3, 0x200
4200c716:	a22142        	l32i	a4, a1, 0x288
4200c719:	030c      	movi.n	a3, 0
4200c71b:	524232        	s8i	a3, a2, 82
4200c71e:	320426        	beqi	a4, -1, 4200c754 <_svfprintf_r+0x1aa8>
4200c721:	a121a2        	l32i	a10, a1, 0x284
4200c724:	04cd      	mov.n	a12, a4
4200c726:	0b0c      	movi.n	a11, 0
4200c728:	b96192        	s32i	a9, a1, 0x2e4
4200c72b:	d11a81        	l32r	a8, 42000b94 <_stext+0xb74>
4200c72e:	0008e0        	callx8	a8
4200c731:	a361a2        	s32i	a10, a1, 0x28c
4200c734:	b92192        	l32i	a9, a1, 0x2e4
4200c737:	a32152        	l32i	a5, a1, 0x28c
4200c73a:	1acc      	bnez.n	a10, 4200c73f <_svfprintf_r+0x1a93>
4200c73c:	027d86        	j	4200d136 <_svfprintf_r+0x248a>
4200c73f:	a12152        	l32i	a5, a1, 0x284
4200c742:	060c      	movi.n	a6, 0
4200c744:	c05a50        	sub	a5, a10, a5
4200c747:	a26152        	s32i	a5, a1, 0x288
4200c74a:	a36162        	s32i	a6, a1, 0x28c
4200c74d:	065d      	mov.n	a5, a6
4200c74f:	0278c6        	j	4200d136 <_svfprintf_r+0x248a>
4200c752:	00          	.byte 00
4200c753:	00          	.byte 00
4200c754:	a121a2        	l32i	a10, a1, 0x284
4200c757:	b96192        	s32i	a9, a1, 0x2e4
4200c75a:	cfce81        	l32r	a8, 42000694 <_stext+0x674>
4200c75d:	0008e0        	callx8	a8
4200c760:	080c      	movi.n	a8, 0
4200c762:	b92192        	l32i	a9, a1, 0x2e4
4200c765:	a261a2        	s32i	a10, a1, 0x288
4200c768:	a36182        	s32i	a8, a1, 0x28c
4200c76b:	085d      	mov.n	a5, a8
4200c76d:	083d      	mov.n	a3, a8
4200c76f:	084d      	mov.n	a4, a8
4200c771:	082d      	mov.n	a2, a8
4200c773:	027146        	j	4200d13c <_svfprintf_r+0x2490>
4200c776:	00          	.byte 00
4200c777:	a02162        	l32i	a6, a1, 0x280
4200c77a:	051c      	movi.n	a5, 16
4200c77c:	206650        	or	a6, a6, a5
4200c77f:	a06162        	s32i	a6, a1, 0x280
4200c782:	a02182        	l32i	a8, a1, 0x280
4200c785:	972162        	l32i	a6, a1, 0x25c
4200c788:	02e857        	bbsi	a8, 5, 4200c78e <_svfprintf_r+0x1ae2>
4200c78b:	003206        	j	4200c857 <_svfprintf_r+0x1bab>
4200c78e:	042416        	beqz	a4, 4200c7d4 <_svfprintf_r+0x1b28>
4200c791:	0fa267        	bge	a2, a6, 4200c7a4 <_svfprintf_r+0x1af8>
4200c794:	10c1a2        	addi	a10, a1, 16
4200c797:	b022a0        	addx8	a2, a2, a10
4200c79a:	0238      	l32i.n	a3, a2, 0
4200c79c:	1248      	l32i.n	a4, a2, 4
4200c79e:	9f2152        	l32i	a5, a1, 0x27c
4200c7a1:	00af06        	j	4200ca61 <_svfprintf_r+0x1db5>
4200c7a4:	58a2b2        	movi	a11, 0x258
4200c7a7:	10c1e2        	addi	a14, a1, 16
4200c7aa:	41ba      	add.n	a4, a1, a11
4200c7ac:	4ca2d2        	movi	a13, 0x24c
4200c7af:	60a2c2        	movi	a12, 0x260
4200c7b2:	0149      	s32i.n	a4, a1, 0
4200c7b4:	03bd      	mov.n	a11, a3
4200c7b6:	02ad      	mov.n	a10, a2
4200c7b8:	01def2        	addmi	a15, a14, 0x100
4200c7bb:	deda      	add.n	a13, a14, a13
4200c7bd:	ceca      	add.n	a12, a14, a12
4200c7bf:	b96192        	s32i	a9, a1, 0x2e4
4200c7c2:	fdff25        	call8	4200a7b4 <get_arg$constprop$0>
4200c7c5:	0a38      	l32i.n	a3, a10, 0
4200c7c7:	1a48      	l32i.n	a4, a10, 4
4200c7c9:	9f2152        	l32i	a5, a1, 0x27c
4200c7cc:	b92192        	l32i	a9, a1, 0x2e4
4200c7cf:	120c      	movi.n	a2, 1
4200c7d1:	01c746        	j	4200cef2 <_svfprintf_r+0x2246>
4200c7d4:	9f2132        	l32i	a3, a1, 0x27c
4200c7d7:	10c142        	addi	a4, a1, 16
4200c7da:	531b      	addi.n	a5, a3, 1
4200c7dc:	b02240        	addx8	a2, a2, a4
4200c7df:	6d2367        	blt	a3, a6, 4200c850 <_svfprintf_r+0x1ba4>
4200c7e2:	10c182        	addi	a8, a1, 16
4200c7e5:	9a2842        	l32i	a4, a8, 0x268
4200c7e8:	837c      	movi.n	a3, -8
4200c7ea:	447b      	addi.n	a4, a4, 7
4200c7ec:	02d822        	addmi	a2, a8, 0x200
4200c7ef:	104430        	and	a4, a4, a3
4200c7f2:	f81c      	movi.n	a8, 31
4200c7f4:	348b      	addi.n	a3, a4, 8
4200c7f6:	871c      	movi.n	a7, 24
4200c7f8:	342867        	blt	a8, a6, 4200c830 <_svfprintf_r+0x1b84>
4200c7fb:	861b      	addi.n	a8, a6, 1
4200c7fd:	976182        	s32i	a8, a1, 0x25c
4200c800:	1a6232        	s32i	a3, a2, 104
4200c803:	052737        	blt	a7, a3, 4200c80c <_svfprintf_r+0x1b60>
4200c806:	192222        	l32i	a2, a2, 100
4200c809:	000286        	j	4200c817 <_svfprintf_r+0x1b6b>
4200c80c:	012747        	blt	a7, a4, 4200c811 <_svfprintf_r+0x1b65>
4200c80f:	832c      	movi.n	a3, 40
4200c811:	9c2122        	l32i	a2, a1, 0x270
4200c814:	9e6132        	s32i	a3, a1, 0x278
4200c817:	9e2132        	l32i	a3, a1, 0x278
4200c81a:	10c1b2        	addi	a11, a1, 16
4200c81d:	223a      	add.n	a2, a2, a3
4200c81f:	f8c222        	addi	a2, a2, -8
4200c822:	0238      	l32i.n	a3, a2, 0
4200c824:	1248      	l32i.n	a4, a2, 4
4200c826:	b026b0        	addx8	a2, a6, a11
4200c829:	0239      	s32i.n	a3, a2, 0
4200c82b:	1249      	s32i.n	a4, a2, 4
4200c82d:	008c06        	j	4200ca61 <_svfprintf_r+0x1db5>
4200c830:	1a6232        	s32i	a3, a2, 104
4200c833:	052737        	blt	a7, a3, 4200c83c <_svfprintf_r+0x1b90>
4200c836:	192222        	l32i	a2, a2, 100
4200c839:	000286        	j	4200c847 <_svfprintf_r+0x1b9b>
4200c83c:	012747        	blt	a7, a4, 4200c841 <_svfprintf_r+0x1b95>
4200c83f:	832c      	movi.n	a3, 40
4200c841:	9c2122        	l32i	a2, a1, 0x270
4200c844:	9e6132        	s32i	a3, a1, 0x278
4200c847:	9e2132        	l32i	a3, a1, 0x278
4200c84a:	802230        	add	a2, a2, a3
4200c84d:	f8c222        	addi	a2, a2, -8
4200c850:	0238      	l32i.n	a3, a2, 0
4200c852:	1248      	l32i.n	a4, a2, 4
4200c854:	008246        	j	4200ca61 <_svfprintf_r+0x1db5>
4200c857:	a02152        	l32i	a5, a1, 0x280
4200c85a:	7a6547        	bbci	a5, 4, 4200c8d8 <_svfprintf_r+0x1c2c>
4200c85d:	04ac      	beqz.n	a4, 4200c881 <_svfprintf_r+0x1bd5>
4200c85f:	09a267        	bge	a2, a6, 4200c86c <_svfprintf_r+0x1bc0>
4200c862:	10c162        	addi	a6, a1, 16
4200c865:	b02260        	addx8	a2, a2, a6
4200c868:	008146        	j	4200ca71 <_svfprintf_r+0x1dc5>
4200c86b:	00          	.byte 00
4200c86c:	58a282        	movi	a8, 0x258
4200c86f:	10c1a2        	addi	a10, a1, 16
4200c872:	418a      	add.n	a4, a1, a8
4200c874:	0149      	s32i.n	a4, a1, 0
4200c876:	01daf2        	addmi	a15, a10, 0x100
4200c879:	4ca2d2        	movi	a13, 0x24c
4200c87c:	0aed      	mov.n	a14, a10
4200c87e:	008246        	j	4200ca8b <_svfprintf_r+0x1ddf>
4200c881:	9f2132        	l32i	a3, a1, 0x27c
4200c884:	10c142        	addi	a4, a1, 16
4200c887:	531b      	addi.n	a5, a3, 1
4200c889:	b02240        	addx8	a2, a2, a4
4200c88c:	02a367        	bge	a3, a6, 4200c892 <_svfprintf_r+0x1be6>
4200c88f:	00a046        	j	4200cb14 <_svfprintf_r+0x1e68>
4200c892:	10c182        	addi	a8, a1, 16
4200c895:	9a2872        	l32i	a7, a8, 0x268
4200c898:	02d822        	addmi	a2, a8, 0x200
4200c89b:	f81c      	movi.n	a8, 31
4200c89d:	374b      	addi.n	a3, a7, 4
4200c89f:	841c      	movi.n	a4, 24
4200c8a1:	02a867        	bge	a8, a6, 4200c8a7 <_svfprintf_r+0x1bfb>
4200c8a4:	009306        	j	4200caf4 <_svfprintf_r+0x1e48>
4200c8a7:	861b      	addi.n	a8, a6, 1
4200c8a9:	976182        	s32i	a8, a1, 0x25c
4200c8ac:	1a6232        	s32i	a3, a2, 104
4200c8af:	052437        	blt	a4, a3, 4200c8b8 <_svfprintf_r+0x1c0c>
4200c8b2:	192222        	l32i	a2, a2, 100
4200c8b5:	000286        	j	4200c8c3 <_svfprintf_r+0x1c17>
4200c8b8:	012477        	blt	a4, a7, 4200c8bd <_svfprintf_r+0x1c11>
4200c8bb:	432c      	movi.n	a3, 36
4200c8bd:	9c2122        	l32i	a2, a1, 0x270
4200c8c0:	9e6132        	s32i	a3, a1, 0x278
4200c8c3:	9e2132        	l32i	a3, a1, 0x278
4200c8c6:	10c1b2        	addi	a11, a1, 16
4200c8c9:	223a      	add.n	a2, a2, a3
4200c8cb:	fcc222        	addi	a2, a2, -4
4200c8ce:	0238      	l32i.n	a3, a2, 0
4200c8d0:	b026b0        	addx8	a2, a6, a11
4200c8d3:	0239      	s32i.n	a3, a2, 0
4200c8d5:	006186        	j	4200ca5f <_svfprintf_r+0x1db3>
4200c8d8:	a02152        	l32i	a5, a1, 0x280
4200c8db:	02e567        	bbsi	a5, 6, 4200c8e1 <_svfprintf_r+0x1c35>
4200c8de:	002e86        	j	4200c99c <_svfprintf_r+0x1cf0>
4200c8e1:	b4bc      	beqz.n	a4, 4200c920 <_svfprintf_r+0x1c74>
4200c8e3:	0ea267        	bge	a2, a6, 4200c8f5 <_svfprintf_r+0x1c49>
4200c8e6:	10c162        	addi	a6, a1, 16
4200c8e9:	b02260        	addx8	a2, a2, a6
4200c8ec:	001232        	l16ui	a3, a2, 0
4200c8ef:	003006        	j	4200c9b3 <_svfprintf_r+0x1d07>
4200c8f2:	00          	.byte 00
4200c8f3:	00          	.byte 00
4200c8f4:	00          	.byte 00
4200c8f5:	58a282        	movi	a8, 0x258
4200c8f8:	10c1a2        	addi	a10, a1, 16
4200c8fb:	418a      	add.n	a4, a1, a8
4200c8fd:	4ca2d2        	movi	a13, 0x24c
4200c900:	60a2c2        	movi	a12, 0x260
4200c903:	01daf2        	addmi	a15, a10, 0x100
4200c906:	0aed      	mov.n	a14, a10
4200c908:	dada      	add.n	a13, a10, a13
4200c90a:	caca      	add.n	a12, a10, a12
4200c90c:	03bd      	mov.n	a11, a3
4200c90e:	0149      	s32i.n	a4, a1, 0
4200c910:	02ad      	mov.n	a10, a2
4200c912:	b96192        	s32i	a9, a1, 0x2e4
4200c915:	fde9e5        	call8	4200a7b4 <get_arg$constprop$0>
4200c918:	001a32        	l16ui	a3, a10, 0
4200c91b:	003006        	j	4200c9df <_svfprintf_r+0x1d33>
4200c91e:	00          	.byte 00
4200c91f:	00          	.byte 00
4200c920:	9f2132        	l32i	a3, a1, 0x27c
4200c923:	10c142        	addi	a4, a1, 16
4200c926:	531b      	addi.n	a5, a3, 1
4200c928:	b02240        	addx8	a2, a2, a4
4200c92b:	652367        	blt	a3, a6, 4200c994 <_svfprintf_r+0x1ce8>
4200c92e:	10c182        	addi	a8, a1, 16
4200c931:	9a2872        	l32i	a7, a8, 0x268
4200c934:	02d822        	addmi	a2, a8, 0x200
4200c937:	f81c      	movi.n	a8, 31
4200c939:	374b      	addi.n	a3, a7, 4
4200c93b:	841c      	movi.n	a4, 24
4200c93d:	332867        	blt	a8, a6, 4200c974 <_svfprintf_r+0x1cc8>
4200c940:	861b      	addi.n	a8, a6, 1
4200c942:	976182        	s32i	a8, a1, 0x25c
4200c945:	1a6232        	s32i	a3, a2, 104
4200c948:	052437        	blt	a4, a3, 4200c951 <_svfprintf_r+0x1ca5>
4200c94b:	192222        	l32i	a2, a2, 100
4200c94e:	000286        	j	4200c95c <_svfprintf_r+0x1cb0>
4200c951:	012477        	blt	a4, a7, 4200c956 <_svfprintf_r+0x1caa>
4200c954:	432c      	movi.n	a3, 36
4200c956:	9c2122        	l32i	a2, a1, 0x270
4200c959:	9e6132        	s32i	a3, a1, 0x278
4200c95c:	9e2132        	l32i	a3, a1, 0x278
4200c95f:	10c1b2        	addi	a11, a1, 16
4200c962:	223a      	add.n	a2, a2, a3
4200c964:	fcc222        	addi	a2, a2, -4
4200c967:	0238      	l32i.n	a3, a2, 0
4200c969:	b026b0        	addx8	a2, a6, a11
4200c96c:	0239      	s32i.n	a3, a2, 0
4200c96e:	f43030        	extui	a3, a3, 0, 16
4200c971:	003a86        	j	4200ca5f <_svfprintf_r+0x1db3>
4200c974:	1a6232        	s32i	a3, a2, 104
4200c977:	052437        	blt	a4, a3, 4200c980 <_svfprintf_r+0x1cd4>
4200c97a:	192222        	l32i	a2, a2, 100
4200c97d:	000286        	j	4200c98b <_svfprintf_r+0x1cdf>
4200c980:	012477        	blt	a4, a7, 4200c985 <_svfprintf_r+0x1cd9>
4200c983:	432c      	movi.n	a3, 36
4200c985:	9c2122        	l32i	a2, a1, 0x270
4200c988:	9e6132        	s32i	a3, a1, 0x278
4200c98b:	9e2132        	l32i	a3, a1, 0x278
4200c98e:	802230        	add	a2, a2, a3
4200c991:	fcc222        	addi	a2, a2, -4
4200c994:	001232        	l16ui	a3, a2, 0
4200c997:	003106        	j	4200ca5f <_svfprintf_r+0x1db3>
4200c99a:	00          	.byte 00
4200c99b:	00          	.byte 00
4200c99c:	a02152        	l32i	a5, a1, 0x280
4200c99f:	02e597        	bbsi	a5, 9, 4200c9a5 <_svfprintf_r+0x1cf9>
4200c9a2:	003006        	j	4200ca66 <_svfprintf_r+0x1dba>
4200c9a5:	f4bc      	beqz.n	a4, 4200c9e8 <_svfprintf_r+0x1d3c>
4200c9a7:	0ea267        	bge	a2, a6, 4200c9b9 <_svfprintf_r+0x1d0d>
4200c9aa:	10c162        	addi	a6, a1, 16
4200c9ad:	b02260        	addx8	a2, a2, a6
4200c9b0:	000232        	l8ui	a3, a2, 0
4200c9b3:	9f2152        	l32i	a5, a1, 0x27c
4200c9b6:	002946        	j	4200ca5f <_svfprintf_r+0x1db3>
4200c9b9:	58a282        	movi	a8, 0x258
4200c9bc:	10c1a2        	addi	a10, a1, 16
4200c9bf:	418a      	add.n	a4, a1, a8
4200c9c1:	4ca2d2        	movi	a13, 0x24c
4200c9c4:	60a2c2        	movi	a12, 0x260
4200c9c7:	01daf2        	addmi	a15, a10, 0x100
4200c9ca:	0aed      	mov.n	a14, a10
4200c9cc:	dada      	add.n	a13, a10, a13
4200c9ce:	caca      	add.n	a12, a10, a12
4200c9d0:	03bd      	mov.n	a11, a3
4200c9d2:	0149      	s32i.n	a4, a1, 0
4200c9d4:	02ad      	mov.n	a10, a2
4200c9d6:	b96192        	s32i	a9, a1, 0x2e4
4200c9d9:	fddda5        	call8	4200a7b4 <get_arg$constprop$0>
4200c9dc:	000a32        	l8ui	a3, a10, 0
4200c9df:	9f2152        	l32i	a5, a1, 0x27c
4200c9e2:	b92192        	l32i	a9, a1, 0x2e4
4200c9e5:	001d86        	j	4200ca5f <_svfprintf_r+0x1db3>
4200c9e8:	9f2132        	l32i	a3, a1, 0x27c
4200c9eb:	10c142        	addi	a4, a1, 16
4200c9ee:	531b      	addi.n	a5, a3, 1
4200c9f0:	b02240        	addx8	a2, a2, a4
4200c9f3:	652367        	blt	a3, a6, 4200ca5c <_svfprintf_r+0x1db0>
4200c9f6:	10c182        	addi	a8, a1, 16
4200c9f9:	9a2872        	l32i	a7, a8, 0x268
4200c9fc:	02d822        	addmi	a2, a8, 0x200
4200c9ff:	f81c      	movi.n	a8, 31
4200ca01:	374b      	addi.n	a3, a7, 4
4200ca03:	841c      	movi.n	a4, 24
4200ca05:	332867        	blt	a8, a6, 4200ca3c <_svfprintf_r+0x1d90>
4200ca08:	861b      	addi.n	a8, a6, 1
4200ca0a:	976182        	s32i	a8, a1, 0x25c
4200ca0d:	1a6232        	s32i	a3, a2, 104
4200ca10:	052437        	blt	a4, a3, 4200ca19 <_svfprintf_r+0x1d6d>
4200ca13:	192222        	l32i	a2, a2, 100
4200ca16:	000286        	j	4200ca24 <_svfprintf_r+0x1d78>
4200ca19:	012477        	blt	a4, a7, 4200ca1e <_svfprintf_r+0x1d72>
4200ca1c:	432c      	movi.n	a3, 36
4200ca1e:	9c2122        	l32i	a2, a1, 0x270
4200ca21:	9e6132        	s32i	a3, a1, 0x278
4200ca24:	9e2132        	l32i	a3, a1, 0x278
4200ca27:	10c1b2        	addi	a11, a1, 16
4200ca2a:	223a      	add.n	a2, a2, a3
4200ca2c:	fcc222        	addi	a2, a2, -4
4200ca2f:	0238      	l32i.n	a3, a2, 0
4200ca31:	b026b0        	addx8	a2, a6, a11
4200ca34:	0239      	s32i.n	a3, a2, 0
4200ca36:	743030        	extui	a3, a3, 0, 8
4200ca39:	000886        	j	4200ca5f <_svfprintf_r+0x1db3>
4200ca3c:	1a6232        	s32i	a3, a2, 104
4200ca3f:	052437        	blt	a4, a3, 4200ca48 <_svfprintf_r+0x1d9c>
4200ca42:	192222        	l32i	a2, a2, 100
4200ca45:	000286        	j	4200ca53 <_svfprintf_r+0x1da7>
4200ca48:	012477        	blt	a4, a7, 4200ca4d <_svfprintf_r+0x1da1>
4200ca4b:	432c      	movi.n	a3, 36
4200ca4d:	9c2122        	l32i	a2, a1, 0x270
4200ca50:	9e6132        	s32i	a3, a1, 0x278
4200ca53:	9e2132        	l32i	a3, a1, 0x278
4200ca56:	802230        	add	a2, a2, a3
4200ca59:	fcc222        	addi	a2, a2, -4
4200ca5c:	000232        	l8ui	a3, a2, 0
4200ca5f:	040c      	movi.n	a4, 0
4200ca61:	120c      	movi.n	a2, 1
4200ca63:	0122c6        	j	4200cef2 <_svfprintf_r+0x2246>
4200ca66:	74bc      	beqz.n	a4, 4200caa1 <_svfprintf_r+0x1df5>
4200ca68:	0da267        	bge	a2, a6, 4200ca79 <_svfprintf_r+0x1dcd>
4200ca6b:	10c132        	addi	a3, a1, 16
4200ca6e:	b02230        	addx8	a2, a2, a3
4200ca71:	0238      	l32i.n	a3, a2, 0
4200ca73:	ffcf06        	j	4200c9b3 <_svfprintf_r+0x1d07>
4200ca76:	00          	.byte 00
4200ca77:	00          	.byte 00
4200ca78:	00          	.byte 00
4200ca79:	58a252        	movi	a5, 0x258
4200ca7c:	10c162        	addi	a6, a1, 16
4200ca7f:	415a      	add.n	a4, a1, a5
4200ca81:	0149      	s32i.n	a4, a1, 0
4200ca83:	01d6f2        	addmi	a15, a6, 0x100
4200ca86:	4ca2d2        	movi	a13, 0x24c
4200ca89:	06ed      	mov.n	a14, a6
4200ca8b:	60a2c2        	movi	a12, 0x260
4200ca8e:	03bd      	mov.n	a11, a3
4200ca90:	deda      	add.n	a13, a14, a13
4200ca92:	ceca      	add.n	a12, a14, a12
4200ca94:	02ad      	mov.n	a10, a2
4200ca96:	b96192        	s32i	a9, a1, 0x2e4
4200ca99:	fdd1a5        	call8	4200a7b4 <get_arg$constprop$0>
4200ca9c:	0a38      	l32i.n	a3, a10, 0
4200ca9e:	ffcf46        	j	4200c9df <_svfprintf_r+0x1d33>
4200caa1:	9f2182        	l32i	a8, a1, 0x27c
4200caa4:	10c1a2        	addi	a10, a1, 16
4200caa7:	581b      	addi.n	a5, a8, 1
4200caa9:	b022a0        	addx8	a2, a2, a10
4200caac:	642867        	blt	a8, a6, 4200cb14 <_svfprintf_r+0x1e68>
4200caaf:	10c1b2        	addi	a11, a1, 16
4200cab2:	9a2b72        	l32i	a7, a11, 0x268
4200cab5:	f81c      	movi.n	a8, 31
4200cab7:	02db22        	addmi	a2, a11, 0x200
4200caba:	374b      	addi.n	a3, a7, 4
4200cabc:	841c      	movi.n	a4, 24
4200cabe:	322867        	blt	a8, a6, 4200caf4 <_svfprintf_r+0x1e48>
4200cac1:	861b      	addi.n	a8, a6, 1
4200cac3:	976182        	s32i	a8, a1, 0x25c
4200cac6:	1a6232        	s32i	a3, a2, 104
4200cac9:	072437        	blt	a4, a3, 4200cad4 <_svfprintf_r+0x1e28>
4200cacc:	192222        	l32i	a2, a2, 100
4200cacf:	000306        	j	4200cadf <_svfprintf_r+0x1e33>
4200cad2:	00          	.byte 00
4200cad3:	00          	.byte 00
4200cad4:	012477        	blt	a4, a7, 4200cad9 <_svfprintf_r+0x1e2d>
4200cad7:	432c      	movi.n	a3, 36
4200cad9:	9c2122        	l32i	a2, a1, 0x270
4200cadc:	9e6132        	s32i	a3, a1, 0x278
4200cadf:	9e2132        	l32i	a3, a1, 0x278
4200cae2:	223a      	add.n	a2, a2, a3
4200cae4:	fcc222        	addi	a2, a2, -4
4200cae7:	0238      	l32i.n	a3, a2, 0
4200cae9:	10c122        	addi	a2, a1, 16
4200caec:	b06620        	addx8	a6, a6, a2
4200caef:	0639      	s32i.n	a3, a6, 0
4200caf1:	ffda86        	j	4200ca5f <_svfprintf_r+0x1db3>
4200caf4:	1a6232        	s32i	a3, a2, 104
4200caf7:	052437        	blt	a4, a3, 4200cb00 <_svfprintf_r+0x1e54>
4200cafa:	192222        	l32i	a2, a2, 100
4200cafd:	000286        	j	4200cb0b <_svfprintf_r+0x1e5f>
4200cb00:	012477        	blt	a4, a7, 4200cb05 <_svfprintf_r+0x1e59>
4200cb03:	432c      	movi.n	a3, 36
4200cb05:	9c2122        	l32i	a2, a1, 0x270
4200cb08:	9e6132        	s32i	a3, a1, 0x278
4200cb0b:	9e2132        	l32i	a3, a1, 0x278
4200cb0e:	802230        	add	a2, a2, a3
4200cb11:	fcc222        	addi	a2, a2, -4
4200cb14:	0238      	l32i.n	a3, a2, 0
4200cb16:	ffd146        	j	4200ca5f <_svfprintf_r+0x1db3>
4200cb19:	d02d51        	l32r	a5, 42000bd0 <_stext+0xbb0>
4200cb1c:	b46152        	s32i	a5, a1, 0x2d0
4200cb1f:	000206        	j	4200cb2b <_svfprintf_r+0x1e7f>
4200cb22:	00          	.byte 00
4200cb23:	00          	.byte 00
4200cb24:	00          	.byte 00
4200cb25:	d02961        	l32r	a6, 42000bcc <_stext+0xbac>
4200cb28:	b46162        	s32i	a6, a1, 0x2d0
4200cb2b:	a02182        	l32i	a8, a1, 0x280
4200cb2e:	972162        	l32i	a6, a1, 0x25c
4200cb31:	02e857        	bbsi	a8, 5, 4200cb37 <_svfprintf_r+0x1e8b>
4200cb34:	003206        	j	4200cc00 <_svfprintf_r+0x1f54>
4200cb37:	041416        	beqz	a4, 4200cb7c <_svfprintf_r+0x1ed0>
4200cb3a:	0fa267        	bge	a2, a6, 4200cb4d <_svfprintf_r+0x1ea1>
4200cb3d:	10c1a2        	addi	a10, a1, 16
4200cb40:	b022a0        	addx8	a2, a2, a10
4200cb43:	0238      	l32i.n	a3, a2, 0
4200cb45:	1248      	l32i.n	a4, a2, 4
4200cb47:	9f2152        	l32i	a5, a1, 0x27c
4200cb4a:	00dbc6        	j	4200cebd <_svfprintf_r+0x2211>
4200cb4d:	58a2b2        	movi	a11, 0x258
4200cb50:	10c1e2        	addi	a14, a1, 16
4200cb53:	41ba      	add.n	a4, a1, a11
4200cb55:	4ca2d2        	movi	a13, 0x24c
4200cb58:	60a2c2        	movi	a12, 0x260
4200cb5b:	0149      	s32i.n	a4, a1, 0
4200cb5d:	03bd      	mov.n	a11, a3
4200cb5f:	01def2        	addmi	a15, a14, 0x100
4200cb62:	deda      	add.n	a13, a14, a13
4200cb64:	ceca      	add.n	a12, a14, a12
4200cb66:	02ad      	mov.n	a10, a2
4200cb68:	b96192        	s32i	a9, a1, 0x2e4
4200cb6b:	fdc4a5        	call8	4200a7b4 <get_arg$constprop$0>
4200cb6e:	0a38      	l32i.n	a3, a10, 0
4200cb70:	1a48      	l32i.n	a4, a10, 4
4200cb72:	9f2152        	l32i	a5, a1, 0x27c
4200cb75:	b92192        	l32i	a9, a1, 0x2e4
4200cb78:	00d046        	j	4200cebd <_svfprintf_r+0x2211>
4200cb7b:	00          	.byte 00
4200cb7c:	9f2132        	l32i	a3, a1, 0x27c
4200cb7f:	10c142        	addi	a4, a1, 16
4200cb82:	531b      	addi.n	a5, a3, 1
4200cb84:	b02240        	addx8	a2, a2, a4
4200cb87:	6d2367        	blt	a3, a6, 4200cbf8 <_svfprintf_r+0x1f4c>
4200cb8a:	10c182        	addi	a8, a1, 16
4200cb8d:	9a2842        	l32i	a4, a8, 0x268
4200cb90:	837c      	movi.n	a3, -8
4200cb92:	447b      	addi.n	a4, a4, 7
4200cb94:	02d822        	addmi	a2, a8, 0x200
4200cb97:	104430        	and	a4, a4, a3
4200cb9a:	f81c      	movi.n	a8, 31
4200cb9c:	348b      	addi.n	a3, a4, 8
4200cb9e:	871c      	movi.n	a7, 24
4200cba0:	342867        	blt	a8, a6, 4200cbd8 <_svfprintf_r+0x1f2c>
4200cba3:	861b      	addi.n	a8, a6, 1
4200cba5:	976182        	s32i	a8, a1, 0x25c
4200cba8:	1a6232        	s32i	a3, a2, 104
4200cbab:	052737        	blt	a7, a3, 4200cbb4 <_svfprintf_r+0x1f08>
4200cbae:	192222        	l32i	a2, a2, 100
4200cbb1:	000286        	j	4200cbbf <_svfprintf_r+0x1f13>
4200cbb4:	012747        	blt	a7, a4, 4200cbb9 <_svfprintf_r+0x1f0d>
4200cbb7:	832c      	movi.n	a3, 40
4200cbb9:	9c2122        	l32i	a2, a1, 0x270
4200cbbc:	9e6132        	s32i	a3, a1, 0x278
4200cbbf:	9e2132        	l32i	a3, a1, 0x278
4200cbc2:	10c1b2        	addi	a11, a1, 16
4200cbc5:	223a      	add.n	a2, a2, a3
4200cbc7:	f8c222        	addi	a2, a2, -8
4200cbca:	0238      	l32i.n	a3, a2, 0
4200cbcc:	1248      	l32i.n	a4, a2, 4
4200cbce:	b026b0        	addx8	a2, a6, a11
4200cbd1:	0239      	s32i.n	a3, a2, 0
4200cbd3:	1249      	s32i.n	a4, a2, 4
4200cbd5:	00b906        	j	4200cebd <_svfprintf_r+0x2211>
4200cbd8:	1a6232        	s32i	a3, a2, 104
4200cbdb:	052737        	blt	a7, a3, 4200cbe4 <_svfprintf_r+0x1f38>
4200cbde:	192222        	l32i	a2, a2, 100
4200cbe1:	000286        	j	4200cbef <_svfprintf_r+0x1f43>
4200cbe4:	012747        	blt	a7, a4, 4200cbe9 <_svfprintf_r+0x1f3d>
4200cbe7:	832c      	movi.n	a3, 40
4200cbe9:	9c2122        	l32i	a2, a1, 0x270
4200cbec:	9e6132        	s32i	a3, a1, 0x278
4200cbef:	9e2132        	l32i	a3, a1, 0x278
4200cbf2:	802230        	add	a2, a2, a3
4200cbf5:	f8c222        	addi	a2, a2, -8
4200cbf8:	0238      	l32i.n	a3, a2, 0
4200cbfa:	1248      	l32i.n	a4, a2, 4
4200cbfc:	00af46        	j	4200cebd <_svfprintf_r+0x2211>
4200cbff:	00          	.byte 00
4200cc00:	a02152        	l32i	a5, a1, 0x280
4200cc03:	796547        	bbci	a5, 4, 4200cc80 <_svfprintf_r+0x1fd4>
4200cc06:	f49c      	beqz.n	a4, 4200cc29 <_svfprintf_r+0x1f7d>
4200cc08:	08a267        	bge	a2, a6, 4200cc14 <_svfprintf_r+0x1f68>
4200cc0b:	10c162        	addi	a6, a1, 16
4200cc0e:	b02260        	addx8	a2, a2, a6
4200cc11:	007f06        	j	4200ce11 <_svfprintf_r+0x2165>
4200cc14:	58a282        	movi	a8, 0x258
4200cc17:	10c1a2        	addi	a10, a1, 16
4200cc1a:	418a      	add.n	a4, a1, a8
4200cc1c:	0149      	s32i.n	a4, a1, 0
4200cc1e:	01daf2        	addmi	a15, a10, 0x100
4200cc21:	4ca2d2        	movi	a13, 0x24c
4200cc24:	0aed      	mov.n	a14, a10
4200cc26:	008046        	j	4200ce2b <_svfprintf_r+0x217f>
4200cc29:	9f2132        	l32i	a3, a1, 0x27c
4200cc2c:	10c142        	addi	a4, a1, 16
4200cc2f:	531b      	addi.n	a5, a3, 1
4200cc31:	b02240        	addx8	a2, a2, a4
4200cc34:	02a367        	bge	a3, a6, 4200cc3a <_svfprintf_r+0x1f8e>
4200cc37:	009f86        	j	4200ceb9 <_svfprintf_r+0x220d>
4200cc3a:	10c182        	addi	a8, a1, 16
4200cc3d:	9a2872        	l32i	a7, a8, 0x268
4200cc40:	02d822        	addmi	a2, a8, 0x200
4200cc43:	f81c      	movi.n	a8, 31
4200cc45:	374b      	addi.n	a3, a7, 4
4200cc47:	841c      	movi.n	a4, 24
4200cc49:	02a867        	bge	a8, a6, 4200cc4f <_svfprintf_r+0x1fa3>
4200cc4c:	009246        	j	4200ce99 <_svfprintf_r+0x21ed>
4200cc4f:	861b      	addi.n	a8, a6, 1
4200cc51:	976182        	s32i	a8, a1, 0x25c
4200cc54:	1a6232        	s32i	a3, a2, 104
4200cc57:	052437        	blt	a4, a3, 4200cc60 <_svfprintf_r+0x1fb4>
4200cc5a:	192222        	l32i	a2, a2, 100
4200cc5d:	000286        	j	4200cc6b <_svfprintf_r+0x1fbf>
4200cc60:	012477        	blt	a4, a7, 4200cc65 <_svfprintf_r+0x1fb9>
4200cc63:	432c      	movi.n	a3, 36
4200cc65:	9c2122        	l32i	a2, a1, 0x270
4200cc68:	9e6132        	s32i	a3, a1, 0x278
4200cc6b:	9e2132        	l32i	a3, a1, 0x278
4200cc6e:	10c1b2        	addi	a11, a1, 16
4200cc71:	223a      	add.n	a2, a2, a3
4200cc73:	fcc222        	addi	a2, a2, -4
4200cc76:	0238      	l32i.n	a3, a2, 0
4200cc78:	b026b0        	addx8	a2, a6, a11
4200cc7b:	0239      	s32i.n	a3, a2, 0
4200cc7d:	008e86        	j	4200cebb <_svfprintf_r+0x220f>
4200cc80:	a02152        	l32i	a5, a1, 0x280
4200cc83:	02e567        	bbsi	a5, 6, 4200cc89 <_svfprintf_r+0x1fdd>
4200cc86:	002e86        	j	4200cd44 <_svfprintf_r+0x2098>
4200cc89:	b4bc      	beqz.n	a4, 4200ccc8 <_svfprintf_r+0x201c>
4200cc8b:	0ea267        	bge	a2, a6, 4200cc9d <_svfprintf_r+0x1ff1>
4200cc8e:	10c162        	addi	a6, a1, 16
4200cc91:	b02260        	addx8	a2, a2, a6
4200cc94:	001232        	l16ui	a3, a2, 0
4200cc97:	005e06        	j	4200ce13 <_svfprintf_r+0x2167>
4200cc9a:	00          	.byte 00
4200cc9b:	00          	.byte 00
4200cc9c:	00          	.byte 00
4200cc9d:	58a282        	movi	a8, 0x258
4200cca0:	10c1a2        	addi	a10, a1, 16
4200cca3:	418a      	add.n	a4, a1, a8
4200cca5:	4ca2d2        	movi	a13, 0x24c
4200cca8:	60a2c2        	movi	a12, 0x260
4200ccab:	01daf2        	addmi	a15, a10, 0x100
4200ccae:	0aed      	mov.n	a14, a10
4200ccb0:	dada      	add.n	a13, a10, a13
4200ccb2:	caca      	add.n	a12, a10, a12
4200ccb4:	03bd      	mov.n	a11, a3
4200ccb6:	0149      	s32i.n	a4, a1, 0
4200ccb8:	02ad      	mov.n	a10, a2
4200ccba:	b96192        	s32i	a9, a1, 0x2e4
4200ccbd:	fdaf65        	call8	4200a7b4 <get_arg$constprop$0>
4200ccc0:	001a32        	l16ui	a3, a10, 0
4200ccc3:	005dc6        	j	4200ce3e <_svfprintf_r+0x2192>
4200ccc6:	00          	.byte 00
4200ccc7:	00          	.byte 00
4200ccc8:	9f2132        	l32i	a3, a1, 0x27c
4200cccb:	10c142        	addi	a4, a1, 16
4200ccce:	531b      	addi.n	a5, a3, 1
4200ccd0:	b02240        	addx8	a2, a2, a4
4200ccd3:	652367        	blt	a3, a6, 4200cd3c <_svfprintf_r+0x2090>
4200ccd6:	10c182        	addi	a8, a1, 16
4200ccd9:	9a2872        	l32i	a7, a8, 0x268
4200ccdc:	02d822        	addmi	a2, a8, 0x200
4200ccdf:	f81c      	movi.n	a8, 31
4200cce1:	374b      	addi.n	a3, a7, 4
4200cce3:	841c      	movi.n	a4, 24
4200cce5:	332867        	blt	a8, a6, 4200cd1c <_svfprintf_r+0x2070>
4200cce8:	861b      	addi.n	a8, a6, 1
4200ccea:	976182        	s32i	a8, a1, 0x25c
4200cced:	1a6232        	s32i	a3, a2, 104
4200ccf0:	052437        	blt	a4, a3, 4200ccf9 <_svfprintf_r+0x204d>
4200ccf3:	192222        	l32i	a2, a2, 100
4200ccf6:	000286        	j	4200cd04 <_svfprintf_r+0x2058>
4200ccf9:	012477        	blt	a4, a7, 4200ccfe <_svfprintf_r+0x2052>
4200ccfc:	432c      	movi.n	a3, 36
4200ccfe:	9c2122        	l32i	a2, a1, 0x270
4200cd01:	9e6132        	s32i	a3, a1, 0x278
4200cd04:	9e2132        	l32i	a3, a1, 0x278
4200cd07:	10c1b2        	addi	a11, a1, 16
4200cd0a:	223a      	add.n	a2, a2, a3
4200cd0c:	fcc222        	addi	a2, a2, -4
4200cd0f:	0238      	l32i.n	a3, a2, 0
4200cd11:	b026b0        	addx8	a2, a6, a11
4200cd14:	0239      	s32i.n	a3, a2, 0
4200cd16:	f43030        	extui	a3, a3, 0, 16
4200cd19:	006786        	j	4200cebb <_svfprintf_r+0x220f>
4200cd1c:	1a6232        	s32i	a3, a2, 104
4200cd1f:	052437        	blt	a4, a3, 4200cd28 <_svfprintf_r+0x207c>
4200cd22:	192222        	l32i	a2, a2, 100
4200cd25:	000286        	j	4200cd33 <_svfprintf_r+0x2087>
4200cd28:	012477        	blt	a4, a7, 4200cd2d <_svfprintf_r+0x2081>
4200cd2b:	432c      	movi.n	a3, 36
4200cd2d:	9c2122        	l32i	a2, a1, 0x270
4200cd30:	9e6132        	s32i	a3, a1, 0x278
4200cd33:	9e2132        	l32i	a3, a1, 0x278
4200cd36:	802230        	add	a2, a2, a3
4200cd39:	fcc222        	addi	a2, a2, -4
4200cd3c:	001232        	l16ui	a3, a2, 0
4200cd3f:	005e06        	j	4200cebb <_svfprintf_r+0x220f>
4200cd42:	00          	.byte 00
4200cd43:	00          	.byte 00
4200cd44:	a02152        	l32i	a5, a1, 0x280
4200cd47:	02e597        	bbsi	a5, 9, 4200cd4d <_svfprintf_r+0x20a1>
4200cd4a:	002e06        	j	4200ce06 <_svfprintf_r+0x215a>
4200cd4d:	b4bc      	beqz.n	a4, 4200cd8c <_svfprintf_r+0x20e0>
4200cd4f:	0ea267        	bge	a2, a6, 4200cd61 <_svfprintf_r+0x20b5>
4200cd52:	10c162        	addi	a6, a1, 16
4200cd55:	b02260        	addx8	a2, a2, a6
4200cd58:	000232        	l8ui	a3, a2, 0
4200cd5b:	002d06        	j	4200ce13 <_svfprintf_r+0x2167>
4200cd5e:	00          	.byte 00
4200cd5f:	00          	.byte 00
4200cd60:	00          	.byte 00
4200cd61:	58a282        	movi	a8, 0x258
4200cd64:	10c1a2        	addi	a10, a1, 16
4200cd67:	418a      	add.n	a4, a1, a8
4200cd69:	4ca2d2        	movi	a13, 0x24c
4200cd6c:	60a2c2        	movi	a12, 0x260
4200cd6f:	01daf2        	addmi	a15, a10, 0x100
4200cd72:	0aed      	mov.n	a14, a10
4200cd74:	dada      	add.n	a13, a10, a13
4200cd76:	caca      	add.n	a12, a10, a12
4200cd78:	03bd      	mov.n	a11, a3
4200cd7a:	0149      	s32i.n	a4, a1, 0
4200cd7c:	02ad      	mov.n	a10, a2
4200cd7e:	b96192        	s32i	a9, a1, 0x2e4
4200cd81:	fda325        	call8	4200a7b4 <get_arg$constprop$0>
4200cd84:	000a32        	l8ui	a3, a10, 0
4200cd87:	002cc6        	j	4200ce3e <_svfprintf_r+0x2192>
4200cd8a:	00          	.byte 00
4200cd8b:	00          	.byte 00
4200cd8c:	9f2132        	l32i	a3, a1, 0x27c
4200cd8f:	10c142        	addi	a4, a1, 16
4200cd92:	531b      	addi.n	a5, a3, 1
4200cd94:	b02240        	addx8	a2, a2, a4
4200cd97:	652367        	blt	a3, a6, 4200ce00 <_svfprintf_r+0x2154>
4200cd9a:	10c182        	addi	a8, a1, 16
4200cd9d:	9a2872        	l32i	a7, a8, 0x268
4200cda0:	02d822        	addmi	a2, a8, 0x200
4200cda3:	f81c      	movi.n	a8, 31
4200cda5:	374b      	addi.n	a3, a7, 4
4200cda7:	841c      	movi.n	a4, 24
4200cda9:	332867        	blt	a8, a6, 4200cde0 <_svfprintf_r+0x2134>
4200cdac:	861b      	addi.n	a8, a6, 1
4200cdae:	976182        	s32i	a8, a1, 0x25c
4200cdb1:	1a6232        	s32i	a3, a2, 104
4200cdb4:	052437        	blt	a4, a3, 4200cdbd <_svfprintf_r+0x2111>
4200cdb7:	192222        	l32i	a2, a2, 100
4200cdba:	000286        	j	4200cdc8 <_svfprintf_r+0x211c>
4200cdbd:	012477        	blt	a4, a7, 4200cdc2 <_svfprintf_r+0x2116>
4200cdc0:	432c      	movi.n	a3, 36
4200cdc2:	9c2122        	l32i	a2, a1, 0x270
4200cdc5:	9e6132        	s32i	a3, a1, 0x278
4200cdc8:	9e2132        	l32i	a3, a1, 0x278
4200cdcb:	10c1b2        	addi	a11, a1, 16
4200cdce:	223a      	add.n	a2, a2, a3
4200cdd0:	fcc222        	addi	a2, a2, -4
4200cdd3:	0238      	l32i.n	a3, a2, 0
4200cdd5:	b026b0        	addx8	a2, a6, a11
4200cdd8:	0239      	s32i.n	a3, a2, 0
4200cdda:	743030        	extui	a3, a3, 0, 8
4200cddd:	003686        	j	4200cebb <_svfprintf_r+0x220f>
4200cde0:	1a6232        	s32i	a3, a2, 104
4200cde3:	052437        	blt	a4, a3, 4200cdec <_svfprintf_r+0x2140>
4200cde6:	192222        	l32i	a2, a2, 100
4200cde9:	000286        	j	4200cdf7 <_svfprintf_r+0x214b>
4200cdec:	012477        	blt	a4, a7, 4200cdf1 <_svfprintf_r+0x2145>
4200cdef:	432c      	movi.n	a3, 36
4200cdf1:	9c2122        	l32i	a2, a1, 0x270
4200cdf4:	9e6132        	s32i	a3, a1, 0x278
4200cdf7:	9e2132        	l32i	a3, a1, 0x278
4200cdfa:	802230        	add	a2, a2, a3
4200cdfd:	fcc222        	addi	a2, a2, -4
4200ce00:	000232        	l8ui	a3, a2, 0
4200ce03:	002d06        	j	4200cebb <_svfprintf_r+0x220f>
4200ce06:	e4bc      	beqz.n	a4, 4200ce48 <_svfprintf_r+0x219c>
4200ce08:	0da267        	bge	a2, a6, 4200ce19 <_svfprintf_r+0x216d>
4200ce0b:	10c132        	addi	a3, a1, 16
4200ce0e:	b02230        	addx8	a2, a2, a3
4200ce11:	0238      	l32i.n	a3, a2, 0
4200ce13:	9f2152        	l32i	a5, a1, 0x27c
4200ce16:	002846        	j	4200cebb <_svfprintf_r+0x220f>
4200ce19:	58a252        	movi	a5, 0x258
4200ce1c:	10c162        	addi	a6, a1, 16
4200ce1f:	415a      	add.n	a4, a1, a5
4200ce21:	0149      	s32i.n	a4, a1, 0
4200ce23:	01d6f2        	addmi	a15, a6, 0x100
4200ce26:	4ca2d2        	movi	a13, 0x24c
4200ce29:	06ed      	mov.n	a14, a6
4200ce2b:	60a2c2        	movi	a12, 0x260
4200ce2e:	03bd      	mov.n	a11, a3
4200ce30:	deda      	add.n	a13, a14, a13
4200ce32:	ceca      	add.n	a12, a14, a12
4200ce34:	02ad      	mov.n	a10, a2
4200ce36:	b96192        	s32i	a9, a1, 0x2e4
4200ce39:	fd97a5        	call8	4200a7b4 <get_arg$constprop$0>
4200ce3c:	0a38      	l32i.n	a3, a10, 0
4200ce3e:	9f2152        	l32i	a5, a1, 0x27c
4200ce41:	b92192        	l32i	a9, a1, 0x2e4
4200ce44:	001cc6        	j	4200cebb <_svfprintf_r+0x220f>
4200ce47:	00          	.byte 00
4200ce48:	9f2182        	l32i	a8, a1, 0x27c
4200ce4b:	10c1a2        	addi	a10, a1, 16
4200ce4e:	581b      	addi.n	a5, a8, 1
4200ce50:	b022a0        	addx8	a2, a2, a10
4200ce53:	622867        	blt	a8, a6, 4200ceb9 <_svfprintf_r+0x220d>
4200ce56:	10c1b2        	addi	a11, a1, 16
4200ce59:	9a2b72        	l32i	a7, a11, 0x268
4200ce5c:	f81c      	movi.n	a8, 31
4200ce5e:	02db22        	addmi	a2, a11, 0x200
4200ce61:	374b      	addi.n	a3, a7, 4
4200ce63:	841c      	movi.n	a4, 24
4200ce65:	302867        	blt	a8, a6, 4200ce99 <_svfprintf_r+0x21ed>
4200ce68:	861b      	addi.n	a8, a6, 1
4200ce6a:	976182        	s32i	a8, a1, 0x25c
4200ce6d:	1a6232        	s32i	a3, a2, 104
4200ce70:	052437        	blt	a4, a3, 4200ce79 <_svfprintf_r+0x21cd>
4200ce73:	192222        	l32i	a2, a2, 100
4200ce76:	000286        	j	4200ce84 <_svfprintf_r+0x21d8>
4200ce79:	012477        	blt	a4, a7, 4200ce7e <_svfprintf_r+0x21d2>
4200ce7c:	432c      	movi.n	a3, 36
4200ce7e:	9c2122        	l32i	a2, a1, 0x270
4200ce81:	9e6132        	s32i	a3, a1, 0x278
4200ce84:	9e2132        	l32i	a3, a1, 0x278
4200ce87:	223a      	add.n	a2, a2, a3
4200ce89:	fcc222        	addi	a2, a2, -4
4200ce8c:	0238      	l32i.n	a3, a2, 0
4200ce8e:	10c122        	addi	a2, a1, 16
4200ce91:	b06620        	addx8	a6, a6, a2
4200ce94:	0639      	s32i.n	a3, a6, 0
4200ce96:	000846        	j	4200cebb <_svfprintf_r+0x220f>
4200ce99:	1a6232        	s32i	a3, a2, 104
4200ce9c:	052437        	blt	a4, a3, 4200cea5 <_svfprintf_r+0x21f9>
4200ce9f:	192222        	l32i	a2, a2, 100
4200cea2:	000286        	j	4200ceb0 <_svfprintf_r+0x2204>
4200cea5:	012477        	blt	a4, a7, 4200ceaa <_svfprintf_r+0x21fe>
4200cea8:	432c      	movi.n	a3, 36
4200ceaa:	9c2122        	l32i	a2, a1, 0x270
4200cead:	9e6132        	s32i	a3, a1, 0x278
4200ceb0:	9e2132        	l32i	a3, a1, 0x278
4200ceb3:	802230        	add	a2, a2, a3
4200ceb6:	fcc222        	addi	a2, a2, -4
4200ceb9:	0238      	l32i.n	a3, a2, 0
4200cebb:	040c      	movi.n	a4, 0
4200cebd:	202340        	or	a2, a3, a4
4200cec0:	02ac      	beqz.n	a2, 4200cee4 <_svfprintf_r+0x2238>
4200cec2:	a02162        	l32i	a6, a1, 0x280
4200cec5:	1b6607        	bbci	a6, 0, 4200cee4 <_svfprintf_r+0x2238>
4200cec8:	10c182        	addi	a8, a1, 16
4200cecb:	02d822        	addmi	a2, a8, 0x200
4200cece:	063c      	movi.n	a6, 48
4200ced0:	504262        	s8i	a6, a2, 80
4200ced3:	a72162        	l32i	a6, a1, 0x29c
4200ced6:	a02182        	l32i	a8, a1, 0x280
4200ced9:	514262        	s8i	a6, a2, 81
4200cedc:	220c      	movi.n	a2, 2
4200cede:	208820        	or	a8, a8, a2
4200cee1:	a06182        	s32i	a8, a1, 0x280
4200cee4:	a02162        	l32i	a6, a1, 0x280
4200cee7:	ffab22        	movi	a2, 0xfffffbff
4200ceea:	106620        	and	a6, a6, a2
4200ceed:	a06162        	s32i	a6, a1, 0x280
4200cef0:	220c      	movi.n	a2, 2
4200cef2:	9f6152        	s32i	a5, a1, 0x27c
4200cef5:	060c      	movi.n	a6, 0
4200cef7:	10c182        	addi	a8, a1, 16
4200cefa:	02d852        	addmi	a5, a8, 0x200
4200cefd:	524562        	s8i	a6, a5, 82
4200cf00:	a22152        	l32i	a5, a1, 0x288
4200cf03:	260526        	beqi	a5, -1, 4200cf2d <_svfprintf_r+0x2281>
4200cf06:	a02172        	l32i	a7, a1, 0x280
4200cf09:	a02162        	l32i	a6, a1, 0x280
4200cf0c:	7faf52        	movi	a5, -129
4200cf0f:	106650        	and	a6, a6, a5
4200cf12:	208340        	or	a8, a3, a4
4200cf15:	a06162        	s32i	a6, a1, 0x280
4200cf18:	150c      	movi.n	a5, 1
4200cf1a:	060c      	movi.n	a6, 0
4200cf1c:	936580        	movnez	a6, a5, a8
4200cf1f:	748060        	extui	a8, a6, 0, 8
4200cf22:	76cc      	bnez.n	a6, 4200cf2d <_svfprintf_r+0x2281>
4200cf24:	a22162        	l32i	a6, a1, 0x288
4200cf27:	835860        	moveqz	a5, a8, a6
4200cf2a:	179516        	beqz	a5, 4200d0a7 <_svfprintf_r+0x23fb>
4200cf2d:	5d1226        	beqi	a2, 1, 4200cf8e <_svfprintf_r+0x22e2>
4200cf30:	022266        	bnei	a2, 2, 4200cf36 <_svfprintf_r+0x228a>
4200cf33:	004e86        	j	4200d071 <_svfprintf_r+0x23c5>
4200cf36:	90a182        	movi	a8, 0x190
4200cf39:	881a      	add.n	a8, a8, a1
4200cf3b:	64c882        	addi	a8, a8, 100
4200cf3e:	a16182        	s32i	a8, a1, 0x284
4200cf41:	a12152        	l32i	a5, a1, 0x284
4200cf44:	016430        	slli	a6, a4, 29
4200cf47:	250b      	addi.n	a2, a5, -1
4200cf49:	a16122        	s32i	a2, a1, 0x284
4200cf4c:	a12182        	l32i	a8, a1, 0x284
4200cf4f:	242030        	extui	a2, a3, 0, 3
4200cf52:	413330        	srli	a3, a3, 3
4200cf55:	30c222        	addi	a2, a2, 48
4200cf58:	203630        	or	a3, a6, a3
4200cf5b:	414340        	srli	a4, a4, 3
4200cf5e:	004822        	s8i	a2, a8, 0
4200cf61:	206340        	or	a6, a3, a4
4200cf64:	fd9656        	bnez	a6, 4200cf41 <_svfprintf_r+0x2295>
4200cf67:	d0c232        	addi	a3, a2, -48
4200cf6a:	120c      	movi.n	a2, 1
4200cf6c:	832630        	moveqz	a2, a6, a3
4200cf6f:	742020        	extui	a2, a2, 0, 8
4200cf72:	170216        	beqz	a2, 4200d0e6 <_svfprintf_r+0x243a>
4200cf75:	a02122        	l32i	a2, a1, 0x280
4200cf78:	02e207        	bbsi	a2, 0, 4200cf7e <_svfprintf_r+0x22d2>
4200cf7b:	0059c6        	j	4200d0e6 <_svfprintf_r+0x243a>
4200cf7e:	280b      	addi.n	a2, a8, -1
4200cf80:	033c      	movi.n	a3, 48
4200cf82:	fec552        	addi	a5, a5, -2
4200cf85:	004232        	s8i	a3, a2, 0
4200cf88:	a16152        	s32i	a5, a1, 0x284
4200cf8b:	0055c6        	j	4200d0e6 <_svfprintf_r+0x243a>
4200cf8e:	a4dc      	bnez.n	a4, 4200cfac <_svfprintf_r+0x2300>
4200cf90:	920c      	movi.n	a2, 9
4200cf92:	163237        	bltu	a2, a3, 4200cfac <_svfprintf_r+0x2300>
4200cf95:	10c142        	addi	a4, a1, 16
4200cf98:	01d422        	addmi	a2, a4, 0x100
4200cf9b:	30c332        	addi	a3, a3, 48
4200cf9e:	e34232        	s8i	a3, a2, 227
4200cfa1:	e3a122        	movi	a2, 0x1e3
4200cfa4:	842a      	add.n	a8, a4, a2
4200cfa6:	a16182        	s32i	a8, a1, 0x284
4200cfa9:	004e46        	j	4200d0e6 <_svfprintf_r+0x243a>
4200cfac:	020c      	movi.n	a2, 0
4200cfae:	a02162        	l32i	a6, a1, 0x280
4200cfb1:	a66122        	s32i	a2, a1, 0x298
4200cfb4:	f4a152        	movi	a5, 0x1f4
4200cfb7:	00a422        	movi	a2, 0x400
4200cfba:	515a      	add.n	a5, a1, a5
4200cfbc:	102620        	and	a2, a6, a2
4200cfbf:	000206        	j	4200cfcb <_svfprintf_r+0x231f>
4200cfc2:	00          	.byte 00
4200cfc3:	00          	.byte 00
4200cfc4:	a12152        	l32i	a5, a1, 0x284
4200cfc7:	0a3d      	mov.n	a3, a10
4200cfc9:	0b4d      	mov.n	a4, a11
4200cfcb:	550b      	addi.n	a5, a5, -1
4200cfcd:	ac0c      	movi.n	a12, 10
4200cfcf:	0d0c      	movi.n	a13, 0
4200cfd1:	03ad      	mov.n	a10, a3
4200cfd3:	04bd      	mov.n	a11, a4
4200cfd5:	b96192        	s32i	a9, a1, 0x2e4
4200cfd8:	a16152        	s32i	a5, a1, 0x284
4200cfdb:	cf0e81        	l32r	a8, 42000c14 <_stext+0xbf4>
4200cfde:	0008e0        	callx8	a8
4200cfe1:	a62182        	l32i	a8, a1, 0x298
4200cfe4:	30caa2        	addi	a10, a10, 48
4200cfe7:	881b      	addi.n	a8, a8, 1
4200cfe9:	0045a2        	s8i	a10, a5, 0
4200cfec:	a66182        	s32i	a8, a1, 0x298
4200cfef:	b92192        	l32i	a9, a1, 0x2e4
4200cff2:	056216        	beqz	a2, 4200d04c <_svfprintf_r+0x23a0>
4200cff5:	ac2152        	l32i	a5, a1, 0x2b0
4200cff8:	01af82        	movi	a8, -255
4200cffb:	000572        	l8ui	a7, a5, 0
4200cffe:	060c      	movi.n	a6, 0
4200d000:	878a      	add.n	a8, a7, a8
4200d002:	150c      	movi.n	a5, 1
4200d004:	936580        	movnez	a6, a5, a8
4200d007:	54cc      	bnez.n	a4, 4200d010 <_svfprintf_r+0x2364>
4200d009:	980c      	movi.n	a8, 9
4200d00b:	013837        	bltu	a8, a3, 4200d010 <_svfprintf_r+0x2364>
4200d00e:	045d      	mov.n	a5, a4
4200d010:	380657        	bnone	a6, a5, 4200d04c <_svfprintf_r+0x23a0>
4200d013:	a62162        	l32i	a6, a1, 0x298
4200d016:	329767        	bne	a7, a6, 4200d04c <_svfprintf_r+0x23a0>
4200d019:	b02152        	l32i	a5, a1, 0x2c0
4200d01c:	a12182        	l32i	a8, a1, 0x284
4200d01f:	b521b2        	l32i	a11, a1, 0x2d4
4200d022:	c08850        	sub	a8, a8, a5
4200d025:	05cd      	mov.n	a12, a5
4200d027:	08ad      	mov.n	a10, a8
4200d029:	a16182        	s32i	a8, a1, 0x284
4200d02c:	b96192        	s32i	a9, a1, 0x2e4
4200d02f:	ceb581        	l32r	a8, 42000b04 <_stext+0xae4>
4200d032:	0008e0        	callx8	a8
4200d035:	ac2162        	l32i	a6, a1, 0x2b0
4200d038:	080c      	movi.n	a8, 0
4200d03a:	010652        	l8ui	a5, a6, 1
4200d03d:	a66182        	s32i	a8, a1, 0x298
4200d040:	b92192        	l32i	a9, a1, 0x2e4
4200d043:	051587        	beq	a5, a8, 4200d04c <_svfprintf_r+0x23a0>
4200d046:	01c662        	addi	a6, a6, 1
4200d049:	ac6162        	s32i	a6, a1, 0x2b0
4200d04c:	ac0c      	movi.n	a12, 10
4200d04e:	0d0c      	movi.n	a13, 0
4200d050:	03ad      	mov.n	a10, a3
4200d052:	04bd      	mov.n	a11, a4
4200d054:	b96192        	s32i	a9, a1, 0x2e4
4200d057:	cc1281        	l32r	a8, 420000a0 <_stext+0x80>
4200d05a:	0008e0        	callx8	a8
4200d05d:	b92192        	l32i	a9, a1, 0x2e4
4200d060:	f60456        	bnez	a4, 4200cfc4 <_svfprintf_r+0x2318>
4200d063:	940c      	movi.n	a4, 9
4200d065:	02b437        	bgeu	a4, a3, 4200d06b <_svfprintf_r+0x23bf>
4200d068:	ffd606        	j	4200cfc4 <_svfprintf_r+0x2318>
4200d06b:	001dc6        	j	4200d0e6 <_svfprintf_r+0x243a>
4200d06e:	00          	.byte 00
4200d06f:	00          	.byte 00
4200d070:	00          	.byte 00
4200d071:	90a122        	movi	a2, 0x190
4200d074:	221a      	add.n	a2, a2, a1
4200d076:	64c222        	addi	a2, a2, 100
4200d079:	a16122        	s32i	a2, a1, 0x284
4200d07c:	b42152        	l32i	a5, a1, 0x2d0
4200d07f:	342030        	extui	a2, a3, 0, 4
4200d082:	a12182        	l32i	a8, a1, 0x284
4200d085:	252a      	add.n	a2, a5, a2
4200d087:	000222        	l8ui	a2, a2, 0
4200d08a:	880b      	addi.n	a8, a8, -1
4200d08c:	004822        	s8i	a2, a8, 0
4200d08f:	413430        	srli	a3, a3, 4
4200d092:	012440        	slli	a2, a4, 28
4200d095:	203230        	or	a3, a2, a3
4200d098:	414440        	srli	a4, a4, 4
4200d09b:	a16182        	s32i	a8, a1, 0x284
4200d09e:	202340        	or	a2, a3, a4
4200d0a1:	fd7256        	bnez	a2, 4200d07c <_svfprintf_r+0x23d0>
4200d0a4:	000f86        	j	4200d0e6 <_svfprintf_r+0x243a>
4200d0a7:	80a132        	movi	a3, 0x180
4200d0aa:	a2ec      	bnez.n	a2, 4200d0d8 <_svfprintf_r+0x242c>
4200d0ac:	10c182        	addi	a8, a1, 16
4200d0af:	483a      	add.n	a4, a8, a3
4200d0b1:	046070        	extui	a6, a7, 0, 1
4200d0b4:	64c442        	addi	a4, a4, 100
4200d0b7:	a26162        	s32i	a6, a1, 0x288
4200d0ba:	a16142        	s32i	a4, a1, 0x284
4200d0bd:	56ac      	beqz.n	a6, 4200d0e6 <_svfprintf_r+0x243a>
4200d0bf:	a26122        	s32i	a2, a1, 0x288
4200d0c2:	90a122        	movi	a2, 0x190
4200d0c5:	221a      	add.n	a2, a2, a1
4200d0c7:	01d842        	addmi	a4, a8, 0x100
4200d0ca:	053c      	movi.n	a5, 48
4200d0cc:	63c222        	addi	a2, a2, 99
4200d0cf:	e34452        	s8i	a5, a4, 227
4200d0d2:	a16122        	s32i	a2, a1, 0x284
4200d0d5:	000346        	j	4200d0e6 <_svfprintf_r+0x243a>
4200d0d8:	90a132        	movi	a3, 0x190
4200d0db:	331a      	add.n	a3, a3, a1
4200d0dd:	64c332        	addi	a3, a3, 100
4200d0e0:	a26152        	s32i	a5, a1, 0x288
4200d0e3:	a16132        	s32i	a3, a1, 0x284
4200d0e6:	a12142        	l32i	a4, a1, 0x284
4200d0e9:	f4a122        	movi	a2, 0x1f4
4200d0ec:	212a      	add.n	a2, a1, a2
4200d0ee:	060c      	movi.n	a6, 0
4200d0f0:	c02240        	sub	a2, a2, a4
4200d0f3:	a22152        	l32i	a5, a1, 0x288
4200d0f6:	a36162        	s32i	a6, a1, 0x28c
4200d0f9:	a26122        	s32i	a2, a1, 0x288
4200d0fc:	063d      	mov.n	a3, a6
4200d0fe:	000d86        	j	4200d138 <_svfprintf_r+0x248c>
4200d101:	a72182        	l32i	a8, a1, 0x29c
4200d104:	18cc      	bnez.n	a8, 4200d109 <_svfprintf_r+0x245d>
4200d106:	02c586        	j	4200dc20 <_svfprintf_r+0x2f74>
4200d109:	10c1a2        	addi	a10, a1, 16
4200d10c:	01da22        	addmi	a2, a10, 0x100
4200d10f:	030c      	movi.n	a3, 0
4200d111:	804282        	s8i	a8, a2, 128
4200d114:	02da22        	addmi	a2, a10, 0x200
4200d117:	524232        	s8i	a3, a2, 82
4200d11a:	020c      	movi.n	a2, 0
4200d11c:	130c      	movi.n	a3, 1
4200d11e:	a26132        	s32i	a3, a1, 0x288
4200d121:	a36122        	s32i	a2, a1, 0x28c
4200d124:	025d      	mov.n	a5, a2
4200d126:	023d      	mov.n	a3, a2
4200d128:	024d      	mov.n	a4, a2
4200d12a:	90a182        	movi	a8, 0x190
4200d12d:	818a      	add.n	a8, a1, a8
4200d12f:	a16182        	s32i	a8, a1, 0x284
4200d132:	000186        	j	4200d13c <_svfprintf_r+0x2490>
4200d135:	00          	.byte 00
4200d136:	053d      	mov.n	a3, a5
4200d138:	034d      	mov.n	a4, a3
4200d13a:	042d      	mov.n	a2, a4
4200d13c:	a221e2        	l32i	a14, a1, 0x288
4200d13f:	10c182        	addi	a8, a1, 16
4200d142:	02d862        	addmi	a6, a8, 0x200
4200d145:	53e5e0        	max	a14, a5, a14
4200d148:	520662        	l8ui	a6, a6, 82
4200d14b:	af61e2        	s32i	a14, a1, 0x2bc
4200d14e:	368c      	beqz.n	a6, 4200d155 <_svfprintf_r+0x24a9>
4200d150:	ee1b      	addi.n	a14, a14, 1
4200d152:	af61e2        	s32i	a14, a1, 0x2bc
4200d155:	a02182        	l32i	a8, a1, 0x280
4200d158:	260c      	movi.n	a6, 2
4200d15a:	106860        	and	a6, a8, a6
4200d15d:	b16162        	s32i	a6, a1, 0x2c4
4200d160:	008616        	beqz	a6, 4200d16c <_svfprintf_r+0x24c0>
4200d163:	af21e2        	l32i	a14, a1, 0x2bc
4200d166:	02cee2        	addi	a14, a14, 2
4200d169:	af61e2        	s32i	a14, a1, 0x2bc
4200d16c:	a02182        	l32i	a8, a1, 0x280
4200d16f:	84a062        	movi	a6, 132
4200d172:	106860        	and	a6, a8, a6
4200d175:	b36162        	s32i	a6, a1, 0x2cc
4200d178:	08a656        	bnez	a6, 4200d206 <_svfprintf_r+0x255a>
4200d17b:	ab2182        	l32i	a8, a1, 0x2ac
4200d17e:	af21e2        	l32i	a14, a1, 0x2bc
4200d181:	0d1c      	movi.n	a13, 16
4200d183:	c068e0        	sub	a6, a8, a14
4200d186:	3716e6        	bgei	a6, 1, 4200d1c1 <_svfprintf_r+0x2515>
4200d189:	001e46        	j	4200d206 <_svfprintf_r+0x255a>
4200d18c:	10cbb2        	addi	a11, a11, 16
4200d18f:	19d9      	s32i.n	a13, a9, 4
4200d191:	b8b9      	s32i.n	a11, a8, 44
4200d193:	a879      	s32i.n	a7, a8, 40
4200d195:	2387a6        	blti	a7, 8, 4200d1bc <_svfprintf_r+0x2510>
4200d198:	a521b2        	l32i	a11, a1, 0x294
4200d19b:	a421a2        	l32i	a10, a1, 0x290
4200d19e:	34a2c2        	movi	a12, 0x234
4200d1a1:	cc1a      	add.n	a12, a12, a1
4200d1a3:	b761d2        	s32i	a13, a1, 0x2dc
4200d1a6:	201110        	or	a1, a1, a1
4200d1a9:	063e65        	call8	42013590 <__ssprint_r>
4200d1ac:	b721d2        	l32i	a13, a1, 0x2dc
4200d1af:	1a8c      	beqz.n	a10, 4200d1b4 <_svfprintf_r+0x2508>
4200d1b1:	02a1c6        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d1b4:	e4a1a2        	movi	a10, 0x1e4
4200d1b7:	10c182        	addi	a8, a1, 16
4200d1ba:	a8aa      	add.n	a10, a8, a10
4200d1bc:	f0c662        	addi	a6, a6, -16
4200d1bf:	0a9d      	mov.n	a9, a10
4200d1c1:	10c1a2        	addi	a10, a1, 16
4200d1c4:	ce8ac1        	l32r	a12, 42000bec <_stext+0xbcc>
4200d1c7:	8a2a72        	l32i	a7, a10, 0x228
4200d1ca:	09c9      	s32i.n	a12, a9, 0
4200d1cc:	02da82        	addmi	a8, a10, 0x200
4200d1cf:	771b      	addi.n	a7, a7, 1
4200d1d1:	a98b      	addi.n	a10, a9, 8
4200d1d3:	b8b8      	l32i.n	a11, a8, 44
4200d1d5:	b32d67        	blt	a13, a6, 4200d18c <_svfprintf_r+0x24e0>
4200d1d8:	1969      	s32i.n	a6, a9, 4
4200d1da:	66ba      	add.n	a6, a6, a11
4200d1dc:	b869      	s32i.n	a6, a8, 44
4200d1de:	a879      	s32i.n	a7, a8, 40
4200d1e0:	0a9d      	mov.n	a9, a10
4200d1e2:	2087a6        	blti	a7, 8, 4200d206 <_svfprintf_r+0x255a>
4200d1e5:	10c1b2        	addi	a11, a1, 16
4200d1e8:	24a2c2        	movi	a12, 0x224
4200d1eb:	cbca      	add.n	a12, a11, a12
4200d1ed:	a421a2        	l32i	a10, a1, 0x290
4200d1f0:	a521b2        	l32i	a11, a1, 0x294
4200d1f3:	201110        	or	a1, a1, a1
4200d1f6:	0639a5        	call8	42013590 <__ssprint_r>
4200d1f9:	1a8c      	beqz.n	a10, 4200d1fe <_svfprintf_r+0x2552>
4200d1fb:	028f46        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d1fe:	e4a162        	movi	a6, 0x1e4
4200d201:	10c1e2        	addi	a14, a1, 16
4200d204:	9e6a      	add.n	a9, a14, a6
4200d206:	10c162        	addi	a6, a1, 16
4200d209:	02d672        	addmi	a7, a6, 0x200
4200d20c:	520782        	l8ui	a8, a7, 82
4200d20f:	8f2162        	l32i	a6, a1, 0x23c
4200d212:	88bc      	beqz.n	a8, 4200d24e <_svfprintf_r+0x25a2>
4200d214:	62a2a2        	movi	a10, 0x262
4200d217:	81aa      	add.n	a8, a1, a10
4200d219:	0989      	s32i.n	a8, a9, 0
4200d21b:	180c      	movi.n	a8, 1
4200d21d:	668a      	add.n	a6, a6, a8
4200d21f:	b769      	s32i.n	a6, a7, 44
4200d221:	a768      	l32i.n	a6, a7, 40
4200d223:	1989      	s32i.n	a8, a9, 4
4200d225:	668a      	add.n	a6, a6, a8
4200d227:	a769      	s32i.n	a6, a7, 40
4200d229:	08c992        	addi	a9, a9, 8
4200d22c:	1e86a6        	blti	a6, 8, 4200d24e <_svfprintf_r+0x25a2>
4200d22f:	10c1b2        	addi	a11, a1, 16
4200d232:	24a2c2        	movi	a12, 0x224
4200d235:	80cbc0        	add	a12, a11, a12
4200d238:	a421a2        	l32i	a10, a1, 0x290
4200d23b:	a521b2        	l32i	a11, a1, 0x294
4200d23e:	201110        	or	a1, a1, a1
4200d241:	0634e5        	call8	42013590 <__ssprint_r>
4200d244:	1a8c      	beqz.n	a10, 4200d249 <_svfprintf_r+0x259d>
4200d246:	027c86        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d249:	f4a1e2        	movi	a14, 0x1f4
4200d24c:	91ea      	add.n	a9, a1, a14
4200d24e:	b12182        	l32i	a8, a1, 0x2c4
4200d251:	10c162        	addi	a6, a1, 16
4200d254:	02d672        	addmi	a7, a6, 0x200
4200d257:	8f2162        	l32i	a6, a1, 0x23c
4200d25a:	88bc      	beqz.n	a8, 4200d296 <_svfprintf_r+0x25ea>
4200d25c:	60a2a2        	movi	a10, 0x260
4200d25f:	81aa      	add.n	a8, a1, a10
4200d261:	0989      	s32i.n	a8, a9, 0
4200d263:	280c      	movi.n	a8, 2
4200d265:	668a      	add.n	a6, a6, a8
4200d267:	b769      	s32i.n	a6, a7, 44
4200d269:	a768      	l32i.n	a6, a7, 40
4200d26b:	1989      	s32i.n	a8, a9, 4
4200d26d:	661b      	addi.n	a6, a6, 1
4200d26f:	a769      	s32i.n	a6, a7, 40
4200d271:	08c992        	addi	a9, a9, 8
4200d274:	1e86a6        	blti	a6, 8, 4200d296 <_svfprintf_r+0x25ea>
4200d277:	10c1b2        	addi	a11, a1, 16
4200d27a:	24a2c2        	movi	a12, 0x224
4200d27d:	80cbc0        	add	a12, a11, a12
4200d280:	a421a2        	l32i	a10, a1, 0x290
4200d283:	a521b2        	l32i	a11, a1, 0x294
4200d286:	201110        	or	a1, a1, a1
4200d289:	063065        	call8	42013590 <__ssprint_r>
4200d28c:	1a8c      	beqz.n	a10, 4200d291 <_svfprintf_r+0x25e5>
4200d28e:	026a86        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d291:	f4a1e2        	movi	a14, 0x1f4
4200d294:	91ea      	add.n	a9, a1, a14
4200d296:	b32162        	l32i	a6, a1, 0x2cc
4200d299:	02e626        	beqi	a6, 128, 4200d29f <_svfprintf_r+0x25f3>
4200d29c:	002286        	j	4200d32a <_svfprintf_r+0x267e>
4200d29f:	ab2182        	l32i	a8, a1, 0x2ac
4200d2a2:	af21e2        	l32i	a14, a1, 0x2bc
4200d2a5:	0d1c      	movi.n	a13, 16
4200d2a7:	c068e0        	sub	a6, a8, a14
4200d2aa:	3716e6        	bgei	a6, 1, 4200d2e5 <_svfprintf_r+0x2639>
4200d2ad:	001e46        	j	4200d32a <_svfprintf_r+0x267e>
4200d2b0:	10cbb2        	addi	a11, a11, 16
4200d2b3:	19d9      	s32i.n	a13, a9, 4
4200d2b5:	b8b9      	s32i.n	a11, a8, 44
4200d2b7:	a879      	s32i.n	a7, a8, 40
4200d2b9:	2387a6        	blti	a7, 8, 4200d2e0 <_svfprintf_r+0x2634>
4200d2bc:	a521b2        	l32i	a11, a1, 0x294
4200d2bf:	a421a2        	l32i	a10, a1, 0x290
4200d2c2:	34a2c2        	movi	a12, 0x234
4200d2c5:	cc1a      	add.n	a12, a12, a1
4200d2c7:	b761d2        	s32i	a13, a1, 0x2dc
4200d2ca:	201110        	or	a1, a1, a1
4200d2cd:	062c25        	call8	42013590 <__ssprint_r>
4200d2d0:	b721d2        	l32i	a13, a1, 0x2dc
4200d2d3:	1a8c      	beqz.n	a10, 4200d2d8 <_svfprintf_r+0x262c>
4200d2d5:	0258c6        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d2d8:	e4a1a2        	movi	a10, 0x1e4
4200d2db:	10c182        	addi	a8, a1, 16
4200d2de:	a8aa      	add.n	a10, a8, a10
4200d2e0:	f0c662        	addi	a6, a6, -16
4200d2e3:	0a9d      	mov.n	a9, a10
4200d2e5:	10c1a2        	addi	a10, a1, 16
4200d2e8:	ce42c1        	l32r	a12, 42000bf0 <_stext+0xbd0>
4200d2eb:	8a2a72        	l32i	a7, a10, 0x228
4200d2ee:	09c9      	s32i.n	a12, a9, 0
4200d2f0:	02da82        	addmi	a8, a10, 0x200
4200d2f3:	771b      	addi.n	a7, a7, 1
4200d2f5:	a98b      	addi.n	a10, a9, 8
4200d2f7:	b8b8      	l32i.n	a11, a8, 44
4200d2f9:	b32d67        	blt	a13, a6, 4200d2b0 <_svfprintf_r+0x2604>
4200d2fc:	1969      	s32i.n	a6, a9, 4
4200d2fe:	66ba      	add.n	a6, a6, a11
4200d300:	b869      	s32i.n	a6, a8, 44
4200d302:	a879      	s32i.n	a7, a8, 40
4200d304:	0a9d      	mov.n	a9, a10
4200d306:	2087a6        	blti	a7, 8, 4200d32a <_svfprintf_r+0x267e>
4200d309:	10c1b2        	addi	a11, a1, 16
4200d30c:	24a2c2        	movi	a12, 0x224
4200d30f:	cbca      	add.n	a12, a11, a12
4200d311:	a421a2        	l32i	a10, a1, 0x290
4200d314:	a521b2        	l32i	a11, a1, 0x294
4200d317:	201110        	or	a1, a1, a1
4200d31a:	062765        	call8	42013590 <__ssprint_r>
4200d31d:	1a8c      	beqz.n	a10, 4200d322 <_svfprintf_r+0x2676>
4200d31f:	024646        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d322:	e4a162        	movi	a6, 0x1e4
4200d325:	10c1e2        	addi	a14, a1, 16
4200d328:	9e6a      	add.n	a9, a14, a6
4200d32a:	a22162        	l32i	a6, a1, 0x288
4200d32d:	081c      	movi.n	a8, 16
4200d32f:	c05560        	sub	a5, a5, a6
4200d332:	3715e6        	bgei	a5, 1, 4200d36d <_svfprintf_r+0x26c1>
4200d335:	001e06        	j	4200d3b1 <_svfprintf_r+0x2705>
4200d338:	10caa2        	addi	a10, a10, 16
4200d33b:	1989      	s32i.n	a8, a9, 4
4200d33d:	b7a9      	s32i.n	a10, a7, 44
4200d33f:	a769      	s32i.n	a6, a7, 40
4200d341:	2386a6        	blti	a6, 8, 4200d368 <_svfprintf_r+0x26bc>
4200d344:	a521b2        	l32i	a11, a1, 0x294
4200d347:	a421a2        	l32i	a10, a1, 0x290
4200d34a:	34a2c2        	movi	a12, 0x234
4200d34d:	cc1a      	add.n	a12, a12, a1
4200d34f:	b76182        	s32i	a8, a1, 0x2dc
4200d352:	201110        	or	a1, a1, a1
4200d355:	0623a5        	call8	42013590 <__ssprint_r>
4200d358:	b72182        	l32i	a8, a1, 0x2dc
4200d35b:	1a8c      	beqz.n	a10, 4200d360 <_svfprintf_r+0x26b4>
4200d35d:	0236c6        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d360:	e4a192        	movi	a9, 0x1e4
4200d363:	10c1a2        	addi	a10, a1, 16
4200d366:	ca9a      	add.n	a12, a10, a9
4200d368:	f0c552        	addi	a5, a5, -16
4200d36b:	0c9d      	mov.n	a9, a12
4200d36d:	10c1b2        	addi	a11, a1, 16
4200d370:	02db72        	addmi	a7, a11, 0x200
4200d373:	ce1fb1        	l32r	a11, 42000bf0 <_stext+0xbd0>
4200d376:	a768      	l32i.n	a6, a7, 40
4200d378:	09b9      	s32i.n	a11, a9, 0
4200d37a:	661b      	addi.n	a6, a6, 1
4200d37c:	c98b      	addi.n	a12, a9, 8
4200d37e:	b7a8      	l32i.n	a10, a7, 44
4200d380:	b42857        	blt	a8, a5, 4200d338 <_svfprintf_r+0x268c>
4200d383:	1959      	s32i.n	a5, a9, 4
4200d385:	55aa      	add.n	a5, a5, a10
4200d387:	b759      	s32i.n	a5, a7, 44
4200d389:	a769      	s32i.n	a6, a7, 40
4200d38b:	0c9d      	mov.n	a9, a12
4200d38d:	2086a6        	blti	a6, 8, 4200d3b1 <_svfprintf_r+0x2705>
4200d390:	24a2c2        	movi	a12, 0x224
4200d393:	10c1e2        	addi	a14, a1, 16
4200d396:	a521b2        	l32i	a11, a1, 0x294
4200d399:	a421a2        	l32i	a10, a1, 0x290
4200d39c:	ceca      	add.n	a12, a14, a12
4200d39e:	201110        	or	a1, a1, a1
4200d3a1:	061ee5        	call8	42013590 <__ssprint_r>
4200d3a4:	1a8c      	beqz.n	a10, 4200d3a9 <_svfprintf_r+0x26fd>
4200d3a6:	022486        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d3a9:	e4a152        	movi	a5, 0x1e4
4200d3ac:	10c162        	addi	a6, a1, 16
4200d3af:	965a      	add.n	a9, a6, a5
4200d3b1:	10c182        	addi	a8, a1, 16
4200d3b4:	a02152        	l32i	a5, a1, 0x280
4200d3b7:	02d862        	addmi	a6, a8, 0x200
4200d3ba:	b678      	l32i.n	a7, a6, 44
4200d3bc:	3de587        	bbsi	a5, 8, 4200d3fd <_svfprintf_r+0x2751>
4200d3bf:	a22122        	l32i	a2, a1, 0x288
4200d3c2:	a12182        	l32i	a8, a1, 0x284
4200d3c5:	1929      	s32i.n	a2, a9, 4
4200d3c7:	727a      	add.n	a7, a2, a7
4200d3c9:	a628      	l32i.n	a2, a6, 40
4200d3cb:	0989      	s32i.n	a8, a9, 0
4200d3cd:	221b      	addi.n	a2, a2, 1
4200d3cf:	b679      	s32i.n	a7, a6, 44
4200d3d1:	a629      	s32i.n	a2, a6, 40
4200d3d3:	998b      	addi.n	a9, a9, 8
4200d3d5:	0282e6        	bgei	a2, 8, 4200d3db <_svfprintf_r+0x272f>
4200d3d8:	01da06        	j	4200db44 <_svfprintf_r+0x2e98>
4200d3db:	24a2c2        	movi	a12, 0x224
4200d3de:	10c132        	addi	a3, a1, 16
4200d3e1:	a521b2        	l32i	a11, a1, 0x294
4200d3e4:	a421a2        	l32i	a10, a1, 0x290
4200d3e7:	80c3c0        	add	a12, a3, a12
4200d3ea:	201110        	or	a1, a1, a1
4200d3ed:	061a25        	call8	42013590 <__ssprint_r>
4200d3f0:	1a8c      	beqz.n	a10, 4200d3f5 <_svfprintf_r+0x2749>
4200d3f2:	021186        	j	4200dc3c <_svfprintf_r+0x2f90>
4200d3f5:	f4a142        	movi	a4, 0x1f4
4200d3f8:	914a      	add.n	a9, a1, a4
4200d3fa:	01d186        	j	4200db44 <_svfprintf_r+0x2e98>
4200d3fd:	a72182        	l32i	a8, a1, 0x29c
4200d400:	65a052        	movi	a5, 101
4200d403:	022587        	blt	a5, a8, 4200d409 <_svfprintf_r+0x275d>
4200d406:	016586        	j	4200d9a0 <_svfprintf_r+0x2cf4>
4200d409:	ccf9c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200d40c:	ccf9d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200d40f:	a821a2        	l32i	a10, a1, 0x2a0
4200d412:	a921b2        	l32i	a11, a1, 0x2a4
4200d415:	b96192        	s32i	a9, a1, 0x2e4
4200d418:	cdfc81        	l32r	a8, 42000c08 <_stext+0xbe8>
4200d41b:	0008e0        	callx8	a8
4200d41e:	b92192        	l32i	a9, a1, 0x2e4
4200d421:	107a56        	bnez	a10, 4200d52c <_svfprintf_r+0x2880>
4200d424:	cdf421        	l32r	a2, 42000bf4 <_stext+0xbd4>
4200d427:	0929      	s32i.n	a2, a9, 0
4200d429:	120c      	movi.n	a2, 1
4200d42b:	1929      	s32i.n	a2, a9, 4
4200d42d:	772a      	add.n	a7, a7, a2
4200d42f:	a628      	l32i.n	a2, a6, 40
4200d431:	b679      	s32i.n	a7, a6, 44
4200d433:	221b      	addi.n	a2, a2, 1
4200d435:	a629      	s32i.n	a2, a6, 40
4200d437:	998b      	addi.n	a9, a9, 8
4200d439:	1b82a6        	blti	a2, 8, 4200d458 <_svfprintf_r+0x27ac>
4200d43c:	10c1a2        	addi	a10, a1, 16
4200d43f:	24a2c2        	movi	a12, 0x224
4200d442:	caca      	add.n	a12, a10, a12
4200d444:	a521b2        	l32i	a11, a1, 0x294
4200d447:	a421a2        	l32i	a10, a1, 0x290
4200d44a:	201110        	or	a1, a1, a1
4200d44d:	061425        	call8	42013590 <__ssprint_r>
4200d450:	7e8a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d453:	f4a1b2        	movi	a11, 0x1f4
4200d456:	91ba      	add.n	a9, a1, a11
4200d458:	952122        	l32i	a2, a1, 0x254
4200d45b:	a62132        	l32i	a3, a1, 0x298
4200d45e:	082237        	blt	a2, a3, 4200d46a <_svfprintf_r+0x27be>
4200d461:	a02142        	l32i	a4, a1, 0x280
4200d464:	02e407        	bbsi	a4, 0, 4200d46a <_svfprintf_r+0x27be>
4200d467:	01b646        	j	4200db44 <_svfprintf_r+0x2e98>
4200d46a:	ae2162        	l32i	a6, a1, 0x2b8
4200d46d:	8f2122        	l32i	a2, a1, 0x23c
4200d470:	b22152        	l32i	a5, a1, 0x2c8
4200d473:	226a      	add.n	a2, a2, a6
4200d475:	8f6122        	s32i	a2, a1, 0x23c
4200d478:	8e2122        	l32i	a2, a1, 0x238
4200d47b:	0959      	s32i.n	a5, a9, 0
4200d47d:	221b      	addi.n	a2, a2, 1
4200d47f:	1969      	s32i.n	a6, a9, 4
4200d481:	8e6122        	s32i	a2, a1, 0x238
4200d484:	998b      	addi.n	a9, a9, 8
4200d486:	1b82a6        	blti	a2, 8, 4200d4a5 <_svfprintf_r+0x27f9>
4200d489:	10c1a2        	addi	a10, a1, 16
4200d48c:	24a2c2        	movi	a12, 0x224
4200d48f:	caca      	add.n	a12, a10, a12
4200d491:	a521b2        	l32i	a11, a1, 0x294
4200d494:	a421a2        	l32i	a10, a1, 0x290
4200d497:	201110        	or	a1, a1, a1
4200d49a:	060f65        	call8	42013590 <__ssprint_r>
4200d49d:	79ba56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d4a0:	f4a1b2        	movi	a11, 0x1f4
4200d4a3:	91ba      	add.n	a9, a1, a11
4200d4a5:	a62132        	l32i	a3, a1, 0x298
4200d4a8:	051c      	movi.n	a5, 16
4200d4aa:	230b      	addi.n	a2, a3, -1
4200d4ac:	3112e6        	bgei	a2, 1, 4200d4e1 <_svfprintf_r+0x2835>
4200d4af:	01a446        	j	4200db44 <_svfprintf_r+0x2e98>
4200d4b2:	00          	.byte 00
4200d4b3:	00          	.byte 00
4200d4b4:	10c772        	addi	a7, a7, 16
4200d4b7:	1959      	s32i.n	a5, a9, 4
4200d4b9:	b479      	s32i.n	a7, a4, 44
4200d4bb:	a439      	s32i.n	a3, a4, 40
4200d4bd:	1b83a6        	blti	a3, 8, 4200d4dc <_svfprintf_r+0x2830>
4200d4c0:	34a2c2        	movi	a12, 0x234
4200d4c3:	a521b2        	l32i	a11, a1, 0x294
4200d4c6:	a421a2        	l32i	a10, a1, 0x290
4200d4c9:	cc1a      	add.n	a12, a12, a1
4200d4cb:	201110        	or	a1, a1, a1
4200d4ce:	060c25        	call8	42013590 <__ssprint_r>
4200d4d1:	767a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d4d4:	e4a162        	movi	a6, 0x1e4
4200d4d7:	10c142        	addi	a4, a1, 16
4200d4da:	646a      	add.n	a6, a4, a6
4200d4dc:	f0c222        	addi	a2, a2, -16
4200d4df:	069d      	mov.n	a9, a6
4200d4e1:	10c162        	addi	a6, a1, 16
4200d4e4:	cdc381        	l32r	a8, 42000bf0 <_stext+0xbd0>
4200d4e7:	8a2632        	l32i	a3, a6, 0x228
4200d4ea:	0989      	s32i.n	a8, a9, 0
4200d4ec:	02d642        	addmi	a4, a6, 0x200
4200d4ef:	331b      	addi.n	a3, a3, 1
4200d4f1:	698b      	addi.n	a6, a9, 8
4200d4f3:	b478      	l32i.n	a7, a4, 44
4200d4f5:	bb2527        	blt	a5, a2, 4200d4b4 <_svfprintf_r+0x2808>
4200d4f8:	1929      	s32i.n	a2, a9, 4
4200d4fa:	227a      	add.n	a2, a2, a7
4200d4fc:	b429      	s32i.n	a2, a4, 44
4200d4fe:	a439      	s32i.n	a3, a4, 40
4200d500:	069d      	mov.n	a9, a6
4200d502:	0283e6        	bgei	a3, 8, 4200d508 <_svfprintf_r+0x285c>
4200d505:	018ec6        	j	4200db44 <_svfprintf_r+0x2e98>
4200d508:	24a2c2        	movi	a12, 0x224
4200d50b:	10c182        	addi	a8, a1, 16
4200d50e:	a521b2        	l32i	a11, a1, 0x294
4200d511:	a421a2        	l32i	a10, a1, 0x290
4200d514:	c8ca      	add.n	a12, a8, a12
4200d516:	201110        	or	a1, a1, a1
4200d519:	060765        	call8	42013590 <__ssprint_r>
4200d51c:	71ca56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d51f:	e4a122        	movi	a2, 0x1e4
4200d522:	10c1a2        	addi	a10, a1, 16
4200d525:	9a2a      	add.n	a9, a10, a2
4200d527:	018646        	j	4200db44 <_svfprintf_r+0x2e98>
4200d52a:	00          	.byte 00
4200d52b:	00          	.byte 00
4200d52c:	952152        	l32i	a5, a1, 0x254
4200d52f:	0215a6        	blti	a5, 1, 4200d535 <_svfprintf_r+0x2889>
4200d532:	0048c6        	j	4200d659 <_svfprintf_r+0x29ad>
4200d535:	cdaf21        	l32r	a2, 42000bf4 <_stext+0xbd4>
4200d538:	0929      	s32i.n	a2, a9, 0
4200d53a:	120c      	movi.n	a2, 1
4200d53c:	1929      	s32i.n	a2, a9, 4
4200d53e:	772a      	add.n	a7, a7, a2
4200d540:	a628      	l32i.n	a2, a6, 40
4200d542:	b679      	s32i.n	a7, a6, 44
4200d544:	221b      	addi.n	a2, a2, 1
4200d546:	a629      	s32i.n	a2, a6, 40
4200d548:	998b      	addi.n	a9, a9, 8
4200d54a:	1b82a6        	blti	a2, 8, 4200d569 <_svfprintf_r+0x28bd>
4200d54d:	10c1b2        	addi	a11, a1, 16
4200d550:	24a2c2        	movi	a12, 0x224
4200d553:	cbca      	add.n	a12, a11, a12
4200d555:	a421a2        	l32i	a10, a1, 0x290
4200d558:	a521b2        	l32i	a11, a1, 0x294
4200d55b:	201110        	or	a1, a1, a1
4200d55e:	060325        	call8	42013590 <__ssprint_r>
4200d561:	6d7a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d564:	f4a1e2        	movi	a14, 0x1f4
4200d567:	91ea      	add.n	a9, a1, a14
4200d569:	10c122        	addi	a2, a1, 16
4200d56c:	a62152        	l32i	a5, a1, 0x298
4200d56f:	a02162        	l32i	a6, a1, 0x280
4200d572:	02d232        	addmi	a3, a2, 0x200
4200d575:	952122        	l32i	a2, a1, 0x254
4200d578:	8f2142        	l32i	a4, a1, 0x23c
4200d57b:	202520        	or	a2, a5, a2
4200d57e:	045060        	extui	a5, a6, 0, 1
4200d581:	202250        	or	a2, a2, a5
4200d584:	5bc216        	beqz	a2, 4200db44 <_svfprintf_r+0x2e98>
4200d587:	ae2122        	l32i	a2, a1, 0x2b8
4200d58a:	b22182        	l32i	a8, a1, 0x2c8
4200d58d:	1929      	s32i.n	a2, a9, 4
4200d58f:	025d      	mov.n	a5, a2
4200d591:	224a      	add.n	a2, a2, a4
4200d593:	b329      	s32i.n	a2, a3, 44
4200d595:	a328      	l32i.n	a2, a3, 40
4200d597:	0989      	s32i.n	a8, a9, 0
4200d599:	221b      	addi.n	a2, a2, 1
4200d59b:	a329      	s32i.n	a2, a3, 40
4200d59d:	0482e6        	bgei	a2, 8, 4200d5a5 <_svfprintf_r+0x28f9>
4200d5a0:	298b      	addi.n	a2, a9, 8
4200d5a2:	0006c6        	j	4200d5c1 <_svfprintf_r+0x2915>
4200d5a5:	24a2c2        	movi	a12, 0x224
4200d5a8:	10c162        	addi	a6, a1, 16
4200d5ab:	a521b2        	l32i	a11, a1, 0x294
4200d5ae:	a421a2        	l32i	a10, a1, 0x290
4200d5b1:	c6ca      	add.n	a12, a6, a12
4200d5b3:	201110        	or	a1, a1, a1
4200d5b6:	05fda5        	call8	42013590 <__ssprint_r>
4200d5b9:	67fa56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d5bc:	f4a182        	movi	a8, 0x1f4
4200d5bf:	218a      	add.n	a2, a1, a8
4200d5c1:	952132        	l32i	a3, a1, 0x254
4200d5c4:	0783d6        	bgez	a3, 4200d640 <_svfprintf_r+0x2994>
4200d5c7:	603030        	neg	a3, a3
4200d5ca:	027d      	mov.n	a7, a2
4200d5cc:	051c      	movi.n	a5, 16
4200d5ce:	000bc6        	j	4200d601 <_svfprintf_r+0x2955>
4200d5d1:	10c882        	addi	a8, a8, 16
4200d5d4:	1759      	s32i.n	a5, a7, 4
4200d5d6:	b689      	s32i.n	a8, a6, 44
4200d5d8:	0a6642        	s32i	a4, a6, 40
4200d5db:	1d84a6        	blti	a4, 8, 4200d5fc <_svfprintf_r+0x2950>
4200d5de:	34a2c2        	movi	a12, 0x234
4200d5e1:	a521b2        	l32i	a11, a1, 0x294
4200d5e4:	a421a2        	l32i	a10, a1, 0x290
4200d5e7:	80cc10        	add	a12, a12, a1
4200d5ea:	201110        	or	a1, a1, a1
4200d5ed:	05fa25        	call8	42013590 <__ssprint_r>
4200d5f0:	648a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d5f3:	e4a122        	movi	a2, 0x1e4
4200d5f6:	10c1a2        	addi	a10, a1, 16
4200d5f9:	802a20        	add	a2, a10, a2
4200d5fc:	f0c332        	addi	a3, a3, -16
4200d5ff:	027d      	mov.n	a7, a2
4200d601:	10c1b2        	addi	a11, a1, 16
4200d604:	cd7b91        	l32r	a9, 42000bf0 <_stext+0xbd0>
4200d607:	8a2b42        	l32i	a4, a11, 0x228
4200d60a:	0799      	s32i.n	a9, a7, 0
4200d60c:	02db62        	addmi	a6, a11, 0x200
4200d60f:	441b      	addi.n	a4, a4, 1
4200d611:	228b      	addi.n	a2, a2, 8
4200d613:	b688      	l32i.n	a8, a6, 44
4200d615:	b82537        	blt	a5, a3, 4200d5d1 <_svfprintf_r+0x2925>
4200d618:	1739      	s32i.n	a3, a7, 4
4200d61a:	338a      	add.n	a3, a3, a8
4200d61c:	b639      	s32i.n	a3, a6, 44
4200d61e:	a649      	s32i.n	a4, a6, 40
4200d620:	1c84a6        	blti	a4, 8, 4200d640 <_svfprintf_r+0x2994>
4200d623:	24a2c2        	movi	a12, 0x224
4200d626:	80cbc0        	add	a12, a11, a12
4200d629:	a421a2        	l32i	a10, a1, 0x290
4200d62c:	a521b2        	l32i	a11, a1, 0x294
4200d62f:	201110        	or	a1, a1, a1
4200d632:	05f5e5        	call8	42013590 <__ssprint_r>
4200d635:	603a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d638:	e4a122        	movi	a2, 0x1e4
4200d63b:	10c1e2        	addi	a14, a1, 16
4200d63e:	2e2a      	add.n	a2, a14, a2
4200d640:	a12132        	l32i	a3, a1, 0x284
4200d643:	a62142        	l32i	a4, a1, 0x298
4200d646:	0239      	s32i.n	a3, a2, 0
4200d648:	a62162        	l32i	a6, a1, 0x298
4200d64b:	8f2132        	l32i	a3, a1, 0x23c
4200d64e:	1249      	s32i.n	a4, a2, 4
4200d650:	10c152        	addi	a5, a1, 16
4200d653:	012fc6        	j	4200db16 <_svfprintf_r+0x2e6a>
4200d656:	00          	.byte 00
4200d657:	00          	.byte 00
4200d658:	00          	.byte 00
4200d659:	a62182        	l32i	a8, a1, 0x298
4200d65c:	435280        	min	a5, a2, a8
4200d65f:	3115a6        	blti	a5, 1, 4200d694 <_svfprintf_r+0x29e8>
4200d662:	757a      	add.n	a7, a5, a7
4200d664:	b679      	s32i.n	a7, a6, 44
4200d666:	a678      	l32i.n	a7, a6, 40
4200d668:	a12182        	l32i	a8, a1, 0x284
4200d66b:	771b      	addi.n	a7, a7, 1
4200d66d:	0989      	s32i.n	a8, a9, 0
4200d66f:	1959      	s32i.n	a5, a9, 4
4200d671:	a679      	s32i.n	a7, a6, 40
4200d673:	998b      	addi.n	a9, a9, 8
4200d675:	1b87a6        	blti	a7, 8, 4200d694 <_svfprintf_r+0x29e8>
4200d678:	10c1a2        	addi	a10, a1, 16
4200d67b:	24a2c2        	movi	a12, 0x224
4200d67e:	caca      	add.n	a12, a10, a12
4200d680:	a521b2        	l32i	a11, a1, 0x294
4200d683:	a421a2        	l32i	a10, a1, 0x290
4200d686:	201110        	or	a1, a1, a1
4200d689:	05f065        	call8	42013590 <__ssprint_r>
4200d68c:	5aca56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d68f:	f4a1b2        	movi	a11, 0x1f4
4200d692:	91ba      	add.n	a9, a1, a11
4200d694:	060c      	movi.n	a6, 0
4200d696:	535560        	max	a5, a5, a6
4200d699:	c05250        	sub	a5, a2, a5
4200d69c:	081c      	movi.n	a8, 16
4200d69e:	3715e6        	bgei	a5, 1, 4200d6d9 <_svfprintf_r+0x2a2d>
4200d6a1:	001dc6        	j	4200d71c <_svfprintf_r+0x2a70>
4200d6a4:	00          	.byte 00
4200d6a5:	10caa2        	addi	a10, a10, 16
4200d6a8:	1989      	s32i.n	a8, a9, 4
4200d6aa:	b7a9      	s32i.n	a10, a7, 44
4200d6ac:	a769      	s32i.n	a6, a7, 40
4200d6ae:	2286a6        	blti	a6, 8, 4200d6d4 <_svfprintf_r+0x2a28>
4200d6b1:	a521b2        	l32i	a11, a1, 0x294
4200d6b4:	a421a2        	l32i	a10, a1, 0x290
4200d6b7:	34a2c2        	movi	a12, 0x234
4200d6ba:	cc1a      	add.n	a12, a12, a1
4200d6bc:	b76182        	s32i	a8, a1, 0x2dc
4200d6bf:	201110        	or	a1, a1, a1
4200d6c2:	05ece5        	call8	42013590 <__ssprint_r>
4200d6c5:	b72182        	l32i	a8, a1, 0x2dc
4200d6c8:	570a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d6cb:	e4a192        	movi	a9, 0x1e4
4200d6ce:	10c1e2        	addi	a14, a1, 16
4200d6d1:	80ce90        	add	a12, a14, a9
4200d6d4:	f0c552        	addi	a5, a5, -16
4200d6d7:	0c9d      	mov.n	a9, a12
4200d6d9:	10c162        	addi	a6, a1, 16
4200d6dc:	02d672        	addmi	a7, a6, 0x200
4200d6df:	cd44b1        	l32r	a11, 42000bf0 <_stext+0xbd0>
4200d6e2:	a768      	l32i.n	a6, a7, 40
4200d6e4:	09b9      	s32i.n	a11, a9, 0
4200d6e6:	661b      	addi.n	a6, a6, 1
4200d6e8:	c98b      	addi.n	a12, a9, 8
4200d6ea:	b7a8      	l32i.n	a10, a7, 44
4200d6ec:	b52857        	blt	a8, a5, 4200d6a5 <_svfprintf_r+0x29f9>
4200d6ef:	1959      	s32i.n	a5, a9, 4
4200d6f1:	55aa      	add.n	a5, a5, a10
4200d6f3:	b759      	s32i.n	a5, a7, 44
4200d6f5:	a769      	s32i.n	a6, a7, 40
4200d6f7:	0c9d      	mov.n	a9, a12
4200d6f9:	1f86a6        	blti	a6, 8, 4200d71c <_svfprintf_r+0x2a70>
4200d6fc:	24a2c2        	movi	a12, 0x224
4200d6ff:	10c182        	addi	a8, a1, 16
4200d702:	a521b2        	l32i	a11, a1, 0x294
4200d705:	a421a2        	l32i	a10, a1, 0x290
4200d708:	80c8c0        	add	a12, a8, a12
4200d70b:	201110        	or	a1, a1, a1
4200d70e:	05e825        	call8	42013590 <__ssprint_r>
4200d711:	527a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d714:	e4a152        	movi	a5, 0x1e4
4200d717:	10c1a2        	addi	a10, a1, 16
4200d71a:	9a5a      	add.n	a9, a10, a5
4200d71c:	a12182        	l32i	a8, a1, 0x284
4200d71f:	a02152        	l32i	a5, a1, 0x280
4200d722:	282a      	add.n	a2, a8, a2
4200d724:	02e5a7        	bbsi	a5, 10, 4200d72a <_svfprintf_r+0x2a7e>
4200d727:	005286        	j	4200d875 <_svfprintf_r+0x2bc9>
4200d72a:	e4a152        	movi	a5, 0x1e4
4200d72d:	0049c6        	j	4200d858 <_svfprintf_r+0x2bac>
4200d730:	438c      	beqz.n	a3, 4200d738 <_svfprintf_r+0x2a8c>
4200d732:	330b      	addi.n	a3, a3, -1
4200d734:	000286        	j	4200d742 <_svfprintf_r+0x2a96>
4200d737:	00          	.byte 00
4200d738:	ac2162        	l32i	a6, a1, 0x2b0
4200d73b:	440b      	addi.n	a4, a4, -1
4200d73d:	660b      	addi.n	a6, a6, -1
4200d73f:	ac6162        	s32i	a6, a1, 0x2b0
4200d742:	b52182        	l32i	a8, a1, 0x2d4
4200d745:	b02162        	l32i	a6, a1, 0x2c0
4200d748:	0989      	s32i.n	a8, a9, 0
4200d74a:	10c182        	addi	a8, a1, 16
4200d74d:	02d872        	addmi	a7, a8, 0x200
4200d750:	1969      	s32i.n	a6, a9, 4
4200d752:	b02182        	l32i	a8, a1, 0x2c0
4200d755:	8f2162        	l32i	a6, a1, 0x23c
4200d758:	998b      	addi.n	a9, a9, 8
4200d75a:	668a      	add.n	a6, a6, a8
4200d75c:	b769      	s32i.n	a6, a7, 44
4200d75e:	a768      	l32i.n	a6, a7, 40
4200d760:	661b      	addi.n	a6, a6, 1
4200d762:	a769      	s32i.n	a6, a7, 40
4200d764:	1886a6        	blti	a6, 8, 4200d780 <_svfprintf_r+0x2ad4>
4200d767:	34a2c2        	movi	a12, 0x234
4200d76a:	a521b2        	l32i	a11, a1, 0x294
4200d76d:	a421a2        	l32i	a10, a1, 0x290
4200d770:	cc1a      	add.n	a12, a12, a1
4200d772:	201110        	or	a1, a1, a1
4200d775:	05e1a5        	call8	42013590 <__ssprint_r>
4200d778:	4c0a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d77b:	10c1a2        	addi	a10, a1, 16
4200d77e:	9a5a      	add.n	a9, a10, a5
4200d780:	a12182        	l32i	a8, a1, 0x284
4200d783:	a62162        	l32i	a6, a1, 0x298
4200d786:	786a      	add.n	a7, a8, a6
4200d788:	ac2182        	l32i	a8, a1, 0x2b0
4200d78b:	c07720        	sub	a7, a7, a2
4200d78e:	000862        	l8ui	a6, a8, 0
4200d791:	437760        	min	a7, a7, a6
4200d794:	8f2162        	l32i	a6, a1, 0x23c
4200d797:	2e17a6        	blti	a7, 1, 4200d7c9 <_svfprintf_r+0x2b1d>
4200d79a:	676a      	add.n	a6, a7, a6
4200d79c:	8f6162        	s32i	a6, a1, 0x23c
4200d79f:	8e2162        	l32i	a6, a1, 0x238
4200d7a2:	0929      	s32i.n	a2, a9, 0
4200d7a4:	661b      	addi.n	a6, a6, 1
4200d7a6:	1979      	s32i.n	a7, a9, 4
4200d7a8:	8e6162        	s32i	a6, a1, 0x238
4200d7ab:	998b      	addi.n	a9, a9, 8
4200d7ad:	1886a6        	blti	a6, 8, 4200d7c9 <_svfprintf_r+0x2b1d>
4200d7b0:	34a2c2        	movi	a12, 0x234
4200d7b3:	a521b2        	l32i	a11, a1, 0x294
4200d7b6:	a421a2        	l32i	a10, a1, 0x290
4200d7b9:	cc1a      	add.n	a12, a12, a1
4200d7bb:	201110        	or	a1, a1, a1
4200d7be:	05dd25        	call8	42013590 <__ssprint_r>
4200d7c1:	477a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d7c4:	10c1b2        	addi	a11, a1, 16
4200d7c7:	9b5a      	add.n	a9, a11, a5
4200d7c9:	ac2182        	l32i	a8, a1, 0x2b0
4200d7cc:	0d1c      	movi.n	a13, 16
4200d7ce:	000862        	l8ui	a6, a8, 0
4200d7d1:	080c      	movi.n	a8, 0
4200d7d3:	537780        	max	a7, a7, a8
4200d7d6:	c06670        	sub	a6, a6, a7
4200d7d9:	3416e6        	bgei	a6, 1, 4200d811 <_svfprintf_r+0x2b65>
4200d7dc:	001c06        	j	4200d850 <_svfprintf_r+0x2ba4>
4200d7df:	00          	.byte 00
4200d7e0:	10caa2        	addi	a10, a10, 16
4200d7e3:	19d9      	s32i.n	a13, a9, 4
4200d7e5:	b8a9      	s32i.n	a10, a8, 44
4200d7e7:	a879      	s32i.n	a7, a8, 40
4200d7e9:	1f87a6        	blti	a7, 8, 4200d80c <_svfprintf_r+0x2b60>
4200d7ec:	a521b2        	l32i	a11, a1, 0x294
4200d7ef:	a421a2        	l32i	a10, a1, 0x290
4200d7f2:	34a2c2        	movi	a12, 0x234
4200d7f5:	80cc10        	add	a12, a12, a1
4200d7f8:	b761d2        	s32i	a13, a1, 0x2dc
4200d7fb:	201110        	or	a1, a1, a1
4200d7fe:	05d925        	call8	42013590 <__ssprint_r>
4200d801:	b721d2        	l32i	a13, a1, 0x2dc
4200d804:	434a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d807:	10c1a2        	addi	a10, a1, 16
4200d80a:	ba5a      	add.n	a11, a10, a5
4200d80c:	f0c662        	addi	a6, a6, -16
4200d80f:	0b9d      	mov.n	a9, a11
4200d811:	10c1b2        	addi	a11, a1, 16
4200d814:	ccf7c1        	l32r	a12, 42000bf0 <_stext+0xbd0>
4200d817:	8a2b72        	l32i	a7, a11, 0x228
4200d81a:	09c9      	s32i.n	a12, a9, 0
4200d81c:	02db82        	addmi	a8, a11, 0x200
4200d81f:	771b      	addi.n	a7, a7, 1
4200d821:	b98b      	addi.n	a11, a9, 8
4200d823:	b8a8      	l32i.n	a10, a8, 44
4200d825:	b72d67        	blt	a13, a6, 4200d7e0 <_svfprintf_r+0x2b34>
4200d828:	1969      	s32i.n	a6, a9, 4
4200d82a:	66aa      	add.n	a6, a6, a10
4200d82c:	b869      	s32i.n	a6, a8, 44
4200d82e:	0a6872        	s32i	a7, a8, 40
4200d831:	0b9d      	mov.n	a9, a11
4200d833:	1987a6        	blti	a7, 8, 4200d850 <_svfprintf_r+0x2ba4>
4200d836:	34a2c2        	movi	a12, 0x234
4200d839:	a521b2        	l32i	a11, a1, 0x294
4200d83c:	a421a2        	l32i	a10, a1, 0x290
4200d83f:	80cc10        	add	a12, a12, a1
4200d842:	201110        	or	a1, a1, a1
4200d845:	05d4a5        	call8	42013590 <__ssprint_r>
4200d848:	3f0a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d84b:	10c1e2        	addi	a14, a1, 16
4200d84e:	9e5a      	add.n	a9, a14, a5
4200d850:	ac2182        	l32i	a8, a1, 0x2b0
4200d853:	000862        	l8ui	a6, a8, 0
4200d856:	226a      	add.n	a2, a2, a6
4200d858:	316f40        	srai	a6, a4, 31
4200d85b:	c06640        	sub	a6, a6, a4
4200d85e:	ece696        	bltz	a6, 4200d730 <_svfprintf_r+0x2a84>
4200d861:	316f30        	srai	a6, a3, 31
4200d864:	c06630        	sub	a6, a6, a3
4200d867:	ec5696        	bltz	a6, 4200d730 <_svfprintf_r+0x2a84>
4200d86a:	a12142        	l32i	a4, a1, 0x284
4200d86d:	a62152        	l32i	a5, a1, 0x298
4200d870:	345a      	add.n	a3, a4, a5
4200d872:	632230        	minu	a2, a2, a3
4200d875:	952132        	l32i	a3, a1, 0x254
4200d878:	a62162        	l32i	a6, a1, 0x298
4200d87b:	052367        	blt	a3, a6, 4200d884 <_svfprintf_r+0x2bd8>
4200d87e:	a02182        	l32i	a8, a1, 0x280
4200d881:	406807        	bbci	a8, 0, 4200d8c5 <_svfprintf_r+0x2c19>
4200d884:	b22132        	l32i	a3, a1, 0x2c8
4200d887:	ae2162        	l32i	a6, a1, 0x2b8
4200d88a:	0939      	s32i.n	a3, a9, 0
4200d88c:	8f2132        	l32i	a3, a1, 0x23c
4200d88f:	ae2142        	l32i	a4, a1, 0x2b8
4200d892:	336a      	add.n	a3, a3, a6
4200d894:	8f6132        	s32i	a3, a1, 0x23c
4200d897:	8e2132        	l32i	a3, a1, 0x238
4200d89a:	1949      	s32i.n	a4, a9, 4
4200d89c:	331b      	addi.n	a3, a3, 1
4200d89e:	8e6132        	s32i	a3, a1, 0x238
4200d8a1:	10c152        	addi	a5, a1, 16
4200d8a4:	998b      	addi.n	a9, a9, 8
4200d8a6:	1b83a6        	blti	a3, 8, 4200d8c5 <_svfprintf_r+0x2c19>
4200d8a9:	24a2c2        	movi	a12, 0x224
4200d8ac:	10c182        	addi	a8, a1, 16
4200d8af:	a521b2        	l32i	a11, a1, 0x294
4200d8b2:	a421a2        	l32i	a10, a1, 0x290
4200d8b5:	c8ca      	add.n	a12, a8, a12
4200d8b7:	201110        	or	a1, a1, a1
4200d8ba:	05cd65        	call8	42013590 <__ssprint_r>
4200d8bd:	37ba56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d8c0:	f4a1a2        	movi	a10, 0x1f4
4200d8c3:	91aa      	add.n	a9, a1, a10
4200d8c5:	a62142        	l32i	a4, a1, 0x298
4200d8c8:	952132        	l32i	a3, a1, 0x254
4200d8cb:	a12182        	l32i	a8, a1, 0x284
4200d8ce:	c03430        	sub	a3, a4, a3
4200d8d1:	484a      	add.n	a4, a8, a4
4200d8d3:	c04420        	sub	a4, a4, a2
4200d8d6:	433340        	min	a3, a3, a4
4200d8d9:	8f2152        	l32i	a5, a1, 0x23c
4200d8dc:	3113a6        	blti	a3, 1, 4200d911 <_svfprintf_r+0x2c65>
4200d8df:	0929      	s32i.n	a2, a9, 0
4200d8e1:	235a      	add.n	a2, a3, a5
4200d8e3:	8f6122        	s32i	a2, a1, 0x23c
4200d8e6:	8e2122        	l32i	a2, a1, 0x238
4200d8e9:	1939      	s32i.n	a3, a9, 4
4200d8eb:	221b      	addi.n	a2, a2, 1
4200d8ed:	8e6122        	s32i	a2, a1, 0x238
4200d8f0:	998b      	addi.n	a9, a9, 8
4200d8f2:	1b82a6        	blti	a2, 8, 4200d911 <_svfprintf_r+0x2c65>
4200d8f5:	10c1b2        	addi	a11, a1, 16
4200d8f8:	24a2c2        	movi	a12, 0x224
4200d8fb:	cbca      	add.n	a12, a11, a12
4200d8fd:	a421a2        	l32i	a10, a1, 0x290
4200d900:	a521b2        	l32i	a11, a1, 0x294
4200d903:	201110        	or	a1, a1, a1
4200d906:	05c8a5        	call8	42013590 <__ssprint_r>
4200d909:	32fa56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d90c:	f4a1e2        	movi	a14, 0x1f4
4200d90f:	91ea      	add.n	a9, a1, a14
4200d911:	a62142        	l32i	a4, a1, 0x298
4200d914:	952122        	l32i	a2, a1, 0x254
4200d917:	051c      	movi.n	a5, 16
4200d919:	c02420        	sub	a2, a4, a2
4200d91c:	040c      	movi.n	a4, 0
4200d91e:	533340        	max	a3, a3, a4
4200d921:	c02230        	sub	a2, a2, a3
4200d924:	3112e6        	bgei	a2, 1, 4200d959 <_svfprintf_r+0x2cad>
4200d927:	008646        	j	4200db44 <_svfprintf_r+0x2e98>
4200d92a:	00          	.byte 00
4200d92b:	00          	.byte 00
4200d92c:	10c772        	addi	a7, a7, 16
4200d92f:	1959      	s32i.n	a5, a9, 4
4200d931:	b479      	s32i.n	a7, a4, 44
4200d933:	a439      	s32i.n	a3, a4, 40
4200d935:	1b83a6        	blti	a3, 8, 4200d954 <_svfprintf_r+0x2ca8>
4200d938:	34a2c2        	movi	a12, 0x234
4200d93b:	a521b2        	l32i	a11, a1, 0x294
4200d93e:	a421a2        	l32i	a10, a1, 0x290
4200d941:	cc1a      	add.n	a12, a12, a1
4200d943:	201110        	or	a1, a1, a1
4200d946:	05c4a5        	call8	42013590 <__ssprint_r>
4200d949:	2efa56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d94c:	e4a162        	movi	a6, 0x1e4
4200d94f:	10c182        	addi	a8, a1, 16
4200d952:	686a      	add.n	a6, a8, a6
4200d954:	f0c222        	addi	a2, a2, -16
4200d957:	069d      	mov.n	a9, a6
4200d959:	10c1a2        	addi	a10, a1, 16
4200d95c:	cca581        	l32r	a8, 42000bf0 <_stext+0xbd0>
4200d95f:	8a2a32        	l32i	a3, a10, 0x228
4200d962:	0989      	s32i.n	a8, a9, 0
4200d964:	02da42        	addmi	a4, a10, 0x200
4200d967:	331b      	addi.n	a3, a3, 1
4200d969:	698b      	addi.n	a6, a9, 8
4200d96b:	b478      	l32i.n	a7, a4, 44
4200d96d:	bb2527        	blt	a5, a2, 4200d92c <_svfprintf_r+0x2c80>
4200d970:	1929      	s32i.n	a2, a9, 4
4200d972:	227a      	add.n	a2, a2, a7
4200d974:	b429      	s32i.n	a2, a4, 44
4200d976:	a439      	s32i.n	a3, a4, 40
4200d978:	069d      	mov.n	a9, a6
4200d97a:	0283e6        	bgei	a3, 8, 4200d980 <_svfprintf_r+0x2cd4>
4200d97d:	0070c6        	j	4200db44 <_svfprintf_r+0x2e98>
4200d980:	24a2c2        	movi	a12, 0x224
4200d983:	caca      	add.n	a12, a10, a12
4200d985:	a521b2        	l32i	a11, a1, 0x294
4200d988:	a421a2        	l32i	a10, a1, 0x290
4200d98b:	201110        	or	a1, a1, a1
4200d98e:	05c025        	call8	42013590 <__ssprint_r>
4200d991:	2a7a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d994:	e4a122        	movi	a2, 0x1e4
4200d997:	10c1b2        	addi	a11, a1, 16
4200d99a:	9b2a      	add.n	a9, a11, a2
4200d99c:	006906        	j	4200db44 <_svfprintf_r+0x2e98>
4200d99f:	00          	.byte 00
4200d9a0:	a638      	l32i.n	a3, a6, 40
4200d9a2:	a62152        	l32i	a5, a1, 0x298
4200d9a5:	771b      	addi.n	a7, a7, 1
4200d9a7:	331b      	addi.n	a3, a3, 1
4200d9a9:	298b      	addi.n	a2, a9, 8
4200d9ab:	140c      	movi.n	a4, 1
4200d9ad:	0825e6        	bgei	a5, 2, 4200d9b9 <_svfprintf_r+0x2d0d>
4200d9b0:	a02182        	l32i	a8, a1, 0x280
4200d9b3:	02e807        	bbsi	a8, 0, 4200d9b9 <_svfprintf_r+0x2d0d>
4200d9b6:	004b86        	j	4200dae8 <_svfprintf_r+0x2e3c>
4200d9b9:	a12182        	l32i	a8, a1, 0x284
4200d9bc:	1949      	s32i.n	a4, a9, 4
4200d9be:	0989      	s32i.n	a8, a9, 0
4200d9c0:	8f6172        	s32i	a7, a1, 0x23c
4200d9c3:	8e6132        	s32i	a3, a1, 0x238
4200d9c6:	10c1a2        	addi	a10, a1, 16
4200d9c9:	1883a6        	blti	a3, 8, 4200d9e5 <_svfprintf_r+0x2d39>
4200d9cc:	24a2c2        	movi	a12, 0x224
4200d9cf:	caca      	add.n	a12, a10, a12
4200d9d1:	a521b2        	l32i	a11, a1, 0x294
4200d9d4:	a421a2        	l32i	a10, a1, 0x290
4200d9d7:	201110        	or	a1, a1, a1
4200d9da:	05bb65        	call8	42013590 <__ssprint_r>
4200d9dd:	25ba56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200d9e0:	f4a1b2        	movi	a11, 0x1f4
4200d9e3:	21ba      	add.n	a2, a1, a11
4200d9e5:	b22132        	l32i	a3, a1, 0x2c8
4200d9e8:	ae2162        	l32i	a6, a1, 0x2b8
4200d9eb:	0239      	s32i.n	a3, a2, 0
4200d9ed:	8f2132        	l32i	a3, a1, 0x23c
4200d9f0:	ae2142        	l32i	a4, a1, 0x2b8
4200d9f3:	336a      	add.n	a3, a3, a6
4200d9f5:	8f6132        	s32i	a3, a1, 0x23c
4200d9f8:	8e2132        	l32i	a3, a1, 0x238
4200d9fb:	1249      	s32i.n	a4, a2, 4
4200d9fd:	331b      	addi.n	a3, a3, 1
4200d9ff:	8e6132        	s32i	a3, a1, 0x238
4200da02:	10c152        	addi	a5, a1, 16
4200da05:	08c222        	addi	a2, a2, 8
4200da08:	1d83a6        	blti	a3, 8, 4200da29 <_svfprintf_r+0x2d7d>
4200da0b:	24a2c2        	movi	a12, 0x224
4200da0e:	10c182        	addi	a8, a1, 16
4200da11:	a521b2        	l32i	a11, a1, 0x294
4200da14:	a421a2        	l32i	a10, a1, 0x290
4200da17:	80c8c0        	add	a12, a8, a12
4200da1a:	201110        	or	a1, a1, a1
4200da1d:	05b725        	call8	42013590 <__ssprint_r>
4200da20:	218a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200da23:	f4a1a2        	movi	a10, 0x1f4
4200da26:	8021a0        	add	a2, a1, a10
4200da29:	10c1b2        	addi	a11, a1, 16
4200da2c:	a62182        	l32i	a8, a1, 0x298
4200da2f:	02db62        	addmi	a6, a11, 0x200
4200da32:	cb6fc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200da35:	cb6ed1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200da38:	a821a2        	l32i	a10, a1, 0x2a0
4200da3b:	a921b2        	l32i	a11, a1, 0x2a4
4200da3e:	8f2142        	l32i	a4, a1, 0x23c
4200da41:	8e2152        	l32i	a5, a1, 0x238
4200da44:	380b      	addi.n	a3, a8, -1
4200da46:	cc7281        	l32r	a8, 42000c10 <_stext+0xbf0>
4200da49:	0008e0        	callx8	a8
4200da4c:	cabc      	beqz.n	a10, 4200da8c <_svfprintf_r+0x2de0>
4200da4e:	1239      	s32i.n	a3, a2, 4
4200da50:	a12182        	l32i	a8, a1, 0x284
4200da53:	a62132        	l32i	a3, a1, 0x298
4200da56:	440b      	addi.n	a4, a4, -1
4200da58:	551b      	addi.n	a5, a5, 1
4200da5a:	781b      	addi.n	a7, a8, 1
4200da5c:	443a      	add.n	a4, a4, a3
4200da5e:	0279      	s32i.n	a7, a2, 0
4200da60:	b649      	s32i.n	a4, a6, 44
4200da62:	a659      	s32i.n	a5, a6, 40
4200da64:	228b      	addi.n	a2, a2, 8
4200da66:	0285e6        	bgei	a5, 8, 4200da6c <_svfprintf_r+0x2dc0>
4200da69:	002506        	j	4200db01 <_svfprintf_r+0x2e55>
4200da6c:	24a2c2        	movi	a12, 0x224
4200da6f:	10c142        	addi	a4, a1, 16
4200da72:	c4ca      	add.n	a12, a4, a12
4200da74:	a521b2        	l32i	a11, a1, 0x294
4200da77:	a421a2        	l32i	a10, a1, 0x290
4200da7a:	201110        	or	a1, a1, a1
4200da7d:	05b125        	call8	42013590 <__ssprint_r>
4200da80:	1b8a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200da83:	f4a122        	movi	a2, 0x1f4
4200da86:	212a      	add.n	a2, a1, a2
4200da88:	001d46        	j	4200db01 <_svfprintf_r+0x2e55>
4200da8b:	00          	.byte 00
4200da8c:	061c      	movi.n	a6, 16
4200da8e:	2f13e6        	bgei	a3, 1, 4200dac1 <_svfprintf_r+0x2e15>
4200da91:	001b06        	j	4200db01 <_svfprintf_r+0x2e55>
4200da94:	10c882        	addi	a8, a8, 16
4200da97:	1269      	s32i.n	a6, a2, 4
4200da99:	b589      	s32i.n	a8, a5, 44
4200da9b:	a549      	s32i.n	a4, a5, 40
4200da9d:	1b84a6        	blti	a4, 8, 4200dabc <_svfprintf_r+0x2e10>
4200daa0:	34a2c2        	movi	a12, 0x234
4200daa3:	a521b2        	l32i	a11, a1, 0x294
4200daa6:	a421a2        	l32i	a10, a1, 0x290
4200daa9:	cc1a      	add.n	a12, a12, a1
4200daab:	201110        	or	a1, a1, a1
4200daae:	05ae25        	call8	42013590 <__ssprint_r>
4200dab1:	187a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200dab4:	e4a172        	movi	a7, 0x1e4
4200dab7:	10c152        	addi	a5, a1, 16
4200daba:	757a      	add.n	a7, a5, a7
4200dabc:	f0c332        	addi	a3, a3, -16
4200dabf:	072d      	mov.n	a2, a7
4200dac1:	10c182        	addi	a8, a1, 16
4200dac4:	cc4b91        	l32r	a9, 42000bf0 <_stext+0xbd0>
4200dac7:	8a2842        	l32i	a4, a8, 0x228
4200daca:	02d852        	addmi	a5, a8, 0x200
4200dacd:	0299      	s32i.n	a9, a2, 0
4200dacf:	b588      	l32i.n	a8, a5, 44
4200dad1:	441b      	addi.n	a4, a4, 1
4200dad3:	728b      	addi.n	a7, a2, 8
4200dad5:	bb2637        	blt	a6, a3, 4200da94 <_svfprintf_r+0x2de8>
4200dad8:	1239      	s32i.n	a3, a2, 4
4200dada:	338a      	add.n	a3, a3, a8
4200dadc:	b539      	s32i.n	a3, a5, 44
4200dade:	a549      	s32i.n	a4, a5, 40
4200dae0:	072d      	mov.n	a2, a7
4200dae2:	1b84a6        	blti	a4, 8, 4200db01 <_svfprintf_r+0x2e55>
4200dae5:	000346        	j	4200daf6 <_svfprintf_r+0x2e4a>
4200dae8:	a12182        	l32i	a8, a1, 0x284
4200daeb:	1949      	s32i.n	a4, a9, 4
4200daed:	0989      	s32i.n	a8, a9, 0
4200daef:	b679      	s32i.n	a7, a6, 44
4200daf1:	a639      	s32i.n	a3, a6, 40
4200daf3:	0a83a6        	blti	a3, 8, 4200db01 <_svfprintf_r+0x2e55>
4200daf6:	24a2c2        	movi	a12, 0x224
4200daf9:	10c1a2        	addi	a10, a1, 16
4200dafc:	caca      	add.n	a12, a10, a12
4200dafe:	ffdc86        	j	4200da74 <_svfprintf_r+0x2dc8>
4200db01:	47a2b2        	movi	a11, 0x247
4200db04:	31ba      	add.n	a3, a1, a11
4200db06:	0239      	s32i.n	a3, a2, 0
4200db08:	b62132        	l32i	a3, a1, 0x2d8
4200db0b:	b62162        	l32i	a6, a1, 0x2d8
4200db0e:	1239      	s32i.n	a3, a2, 4
4200db10:	8f2132        	l32i	a3, a1, 0x23c
4200db13:	10c152        	addi	a5, a1, 16
4200db16:	336a      	add.n	a3, a3, a6
4200db18:	8f6132        	s32i	a3, a1, 0x23c
4200db1b:	8e2132        	l32i	a3, a1, 0x238
4200db1e:	928b      	addi.n	a9, a2, 8
4200db20:	331b      	addi.n	a3, a3, 1
4200db22:	8e6132        	s32i	a3, a1, 0x238
4200db25:	1b83a6        	blti	a3, 8, 4200db44 <_svfprintf_r+0x2e98>
4200db28:	24a2c2        	movi	a12, 0x224
4200db2b:	10c182        	addi	a8, a1, 16
4200db2e:	a521b2        	l32i	a11, a1, 0x294
4200db31:	a421a2        	l32i	a10, a1, 0x290
4200db34:	c8ca      	add.n	a12, a8, a12
4200db36:	201110        	or	a1, a1, a1
4200db39:	05a565        	call8	42013590 <__ssprint_r>
4200db3c:	0fca56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200db3f:	f4a1a2        	movi	a10, 0x1f4
4200db42:	91aa      	add.n	a9, a1, a10
4200db44:	a02122        	l32i	a2, a1, 0x280
4200db47:	19e227        	bbsi	a2, 2, 4200db64 <_svfprintf_r+0x2eb8>
4200db4a:	ab2132        	l32i	a3, a1, 0x2ac
4200db4d:	af2142        	l32i	a4, a1, 0x2bc
4200db50:	ad2152        	l32i	a5, a1, 0x2b4
4200db53:	532340        	max	a2, a3, a4
4200db56:	552a      	add.n	a5, a5, a2
4200db58:	8f2122        	l32i	a2, a1, 0x23c
4200db5b:	ad6152        	s32i	a5, a1, 0x2b4
4200db5e:	07a216        	beqz	a2, 4200dbdc <_svfprintf_r+0x2f30>
4200db61:	002306        	j	4200dbf1 <_svfprintf_r+0x2f45>
4200db64:	ab2162        	l32i	a6, a1, 0x2ac
4200db67:	af2182        	l32i	a8, a1, 0x2bc
4200db6a:	041c      	movi.n	a4, 16
4200db6c:	c02680        	sub	a2, a6, a8
4200db6f:	3112e6        	bgei	a2, 1, 4200dba4 <_svfprintf_r+0x2ef8>
4200db72:	fff506        	j	4200db4a <_svfprintf_r+0x2e9e>
4200db75:	10c662        	addi	a6, a6, 16
4200db78:	1949      	s32i.n	a4, a9, 4
4200db7a:	b569      	s32i.n	a6, a5, 44
4200db7c:	a539      	s32i.n	a3, a5, 40
4200db7e:	998b      	addi.n	a9, a9, 8
4200db80:	1d83a6        	blti	a3, 8, 4200dba1 <_svfprintf_r+0x2ef5>
4200db83:	34a2c2        	movi	a12, 0x234
4200db86:	a521b2        	l32i	a11, a1, 0x294
4200db89:	a421a2        	l32i	a10, a1, 0x290
4200db8c:	80cc10        	add	a12, a12, a1
4200db8f:	201110        	or	a1, a1, a1
4200db92:	059fe5        	call8	42013590 <__ssprint_r>
4200db95:	0a3a56        	bnez	a10, 4200dc3c <_svfprintf_r+0x2f90>
4200db98:	e4a132        	movi	a3, 0x1e4
4200db9b:	10c1a2        	addi	a10, a1, 16
4200db9e:	809a30        	add	a9, a10, a3
4200dba1:	f0c222        	addi	a2, a2, -16
4200dba4:	10c1b2        	addi	a11, a1, 16
4200dba7:	cc1171        	l32r	a7, 42000bec <_stext+0xbcc>
4200dbaa:	8a2b32        	l32i	a3, a11, 0x228
4200dbad:	0979      	s32i.n	a7, a9, 0
4200dbaf:	02db52        	addmi	a5, a11, 0x200
4200dbb2:	331b      	addi.n	a3, a3, 1
4200dbb4:	b568      	l32i.n	a6, a5, 44
4200dbb6:	bb2427        	blt	a4, a2, 4200db75 <_svfprintf_r+0x2ec9>
4200dbb9:	1929      	s32i.n	a2, a9, 4
4200dbbb:	226a      	add.n	a2, a2, a6
4200dbbd:	b529      	s32i.n	a2, a5, 44
4200dbbf:	a539      	s32i.n	a3, a5, 40
4200dbc1:	8583a6        	blti	a3, 8, 4200db4a <_svfprintf_r+0x2e9e>
4200dbc4:	24a2c2        	movi	a12, 0x224
4200dbc7:	cbca      	add.n	a12, a11, a12
4200dbc9:	a421a2        	l32i	a10, a1, 0x290
4200dbcc:	a521b2        	l32i	a11, a1, 0x294
4200dbcf:	201110        	or	a1, a1, a1
4200dbd2:	059be5        	call8	42013590 <__ssprint_r>
4200dbd5:	f71a16        	beqz	a10, 4200db4a <_svfprintf_r+0x2e9e>
4200dbd8:	001806        	j	4200dc3c <_svfprintf_r+0x2f90>
4200dbdb:	00          	.byte 00
4200dbdc:	030c      	movi.n	a3, 0
4200dbde:	8e6132        	s32i	a3, a1, 0x238
4200dbe1:	a32132        	l32i	a3, a1, 0x28c
4200dbe4:	f4a142        	movi	a4, 0x1f4
4200dbe7:	914a      	add.n	a9, a1, a4
4200dbe9:	13cc      	bnez.n	a3, 4200dbee <_svfprintf_r+0x2f42>
4200dbeb:	f45b46        	j	4200ad5c <_svfprintf_r+0xb0>
4200dbee:	000646        	j	4200dc0b <_svfprintf_r+0x2f5f>
4200dbf1:	24a2c2        	movi	a12, 0x224
4200dbf4:	10c152        	addi	a5, a1, 16
4200dbf7:	a521b2        	l32i	a11, a1, 0x294
4200dbfa:	a421a2        	l32i	a10, a1, 0x290
4200dbfd:	c5ca      	add.n	a12, a5, a12
4200dbff:	201110        	or	a1, a1, a1
4200dc02:	0598e5        	call8	42013590 <__ssprint_r>
4200dc05:	fd3a16        	beqz	a10, 4200dbdc <_svfprintf_r+0x2f30>
4200dc08:	000c06        	j	4200dc3c <_svfprintf_r+0x2f90>
4200dc0b:	a321b2        	l32i	a11, a1, 0x28c
4200dc0e:	a421a2        	l32i	a10, a1, 0x290
4200dc11:	f4a162        	movi	a6, 0x1f4
4200dc14:	cbdb81        	l32r	a8, 42000b80 <_stext+0xb60>
4200dc17:	0008e0        	callx8	a8
4200dc1a:	916a      	add.n	a9, a1, a6
4200dc1c:	f44f06        	j	4200ad5c <_svfprintf_r+0xb0>
4200dc1f:	00          	.byte 00
4200dc20:	8f2122        	l32i	a2, a1, 0x23c
4200dc23:	52ac      	beqz.n	a2, 4200dc4c <_svfprintf_r+0x2fa0>
4200dc25:	10c182        	addi	a8, a1, 16
4200dc28:	a521b2        	l32i	a11, a1, 0x294
4200dc2b:	a421a2        	l32i	a10, a1, 0x290
4200dc2e:	24a2c2        	movi	a12, 0x224
4200dc31:	c8ca      	add.n	a12, a8, a12
4200dc33:	201110        	or	a1, a1, a1
4200dc36:	0595a5        	call8	42013590 <__ssprint_r>
4200dc39:	0003c6        	j	4200dc4c <_svfprintf_r+0x2fa0>
4200dc3c:	a32122        	l32i	a2, a1, 0x28c
4200dc3f:	928c      	beqz.n	a2, 4200dc4c <_svfprintf_r+0x2fa0>
4200dc41:	a421a2        	l32i	a10, a1, 0x290
4200dc44:	02bd      	mov.n	a11, a2
4200dc46:	cbce81        	l32r	a8, 42000b80 <_stext+0xb60>
4200dc49:	0008e0        	callx8	a8
4200dc4c:	a52132        	l32i	a3, a1, 0x294
4200dc4f:	ad2142        	l32i	a4, a1, 0x2b4
4200dc52:	061322        	l16ui	a2, a3, 12
4200dc55:	f37c      	movi.n	a3, -1
4200dc57:	042620        	extui	a2, a2, 6, 1
4200dc5a:	934320        	movnez	a4, a3, a2
4200dc5d:	ad6142        	s32i	a4, a1, 0x2b4
4200dc60:	000d46        	j	4200dc99 <_svfprintf_r+0x2fed>
4200dc63:	00          	.byte 00
4200dc64:	9f2152        	l32i	a5, a1, 0x27c
4200dc67:	972162        	l32i	a6, a1, 0x25c
4200dc6a:	c51b      	addi.n	a12, a5, 1
4200dc6c:	02a567        	bge	a5, a6, 4200dc72 <_svfprintf_r+0x2fc6>
4200dc6f:	f4a586        	j	4200af09 <_svfprintf_r+0x25d>
4200dc72:	f4a706        	j	4200af12 <_svfprintf_r+0x266>
4200dc75:	9f2162        	l32i	a6, a1, 0x27c
4200dc78:	972172        	l32i	a7, a1, 0x25c
4200dc7b:	c61b      	addi.n	a12, a6, 1
4200dc7d:	02a677        	bge	a6, a7, 4200dc83 <_svfprintf_r+0x2fd7>
4200dc80:	f4ec46        	j	4200b035 <_svfprintf_r+0x389>
4200dc83:	f4edc6        	j	4200b03e <_svfprintf_r+0x392>
4200dc86:	00          	.byte 00
4200dc87:	00          	.byte 00
4200dc88:	a22182        	l32i	a8, a1, 0x288
4200dc8b:	a02172        	l32i	a7, a1, 0x280
4200dc8e:	120c      	movi.n	a2, 1
4200dc90:	020826        	beqi	a8, -1, 4200dc96 <_svfprintf_r+0x2fea>
4200dc93:	fc9c86        	j	4200cf09 <_svfprintf_r+0x225d>
4200dc96:	fcbd06        	j	4200cf8e <_svfprintf_r+0x22e2>
4200dc99:	ad2122        	l32i	a2, a1, 0x2b4
4200dc9c:	f01d      	retw.n
	...

4200dca0 <gettimeofday>:
4200dca0:	004136        	entry	a1, 32
4200dca3:	cba481        	l32r	a8, 42000b34 <_stext+0xb14>
4200dca6:	0008e0        	callx8	a8
4200dca9:	02bd      	mov.n	a11, a2
4200dcab:	20c330        	or	a12, a3, a3
4200dcae:	cbda81        	l32r	a8, 42000c18 <_stext+0xbf8>
4200dcb1:	0008e0        	callx8	a8
4200dcb4:	0a2d      	mov.n	a2, a10
4200dcb6:	f01d      	retw.n

4200dcb8 <get_arg$constprop$0>:
4200dcb8:	008136        	entry	a1, 64
4200dcbb:	102182        	l32i	a8, a1, 64
4200dcbe:	2129      	s32i.n	a2, a1, 8
4200dcc0:	2198      	l32i.n	a9, a1, 8
4200dcc2:	0528      	l32i.n	a2, a5, 0
4200dcc4:	3159      	s32i.n	a5, a1, 12
4200dcc6:	0858      	l32i.n	a5, a8, 0
4200dcc8:	933550        	movnez	a3, a5, a5
4200dccb:	0199      	s32i.n	a9, a1, 0
4200dccd:	00ea46        	j	4200e07a <get_arg$constprop$0+0x3c2>
4200dcd0:	00          	.byte 00
4200dcd1:	00          	.byte 00
4200dcd2:	331b      	addi.n	a3, a3, 1
4200dcd4:	000352        	l8ui	a5, a3, 0
4200dcd7:	180c      	movi.n	a8, 1
4200dcd9:	838950        	moveqz	a8, a9, a5
4200dcdc:	748080        	extui	a8, a8, 0, 8
4200dcdf:	d88c      	beqz.n	a8, 4200dcf0 <get_arg$constprop$0+0x38>
4200dce1:	dbc5a2        	addi	a10, a5, -37
4200dce4:	01a082        	movi	a8, 1
4200dce7:	8389a0        	moveqz	a8, a9, a10
4200dcea:	748080        	extui	a8, a8, 0, 8
4200dced:	fe1856        	bnez	a8, 4200dcd2 <get_arg$constprop$0+0x1a>
4200dcf0:	43c516        	beqz	a5, 4200e130 <get_arg$constprop$0+0x478>
4200dcf3:	050c      	movi.n	a5, 0
4200dcf5:	a31b      	addi.n	a10, a3, 1
4200dcf7:	05ed      	mov.n	a14, a5
4200dcf9:	f97c      	movi.n	a9, -1
4200dcfb:	05dd      	mov.n	a13, a5
4200dcfd:	1159      	s32i.n	a5, a1, 4
4200dcff:	000046        	j	4200dd04 <get_arg$constprop$0+0x4c>
4200dd02:	03ad      	mov.n	a10, a3
4200dd04:	cba6c1        	l32r	a12, 42000b9c <_stext+0xb7c>
4200dd07:	000a82        	l8ui	a8, a10, 0
4200dd0a:	3a1b      	addi.n	a3, a10, 1
4200dd0c:	bc8a      	add.n	a11, a12, a8
4200dd0e:	000bc2        	l8ui	a12, a11, 0
4200dd11:	11b8      	l32i.n	a11, a1, 4
4200dd13:	b0fbb0        	addx8	a15, a11, a11
4200dd16:	cba2b1        	l32r	a11, 42000ba0 <_stext+0xb80>
4200dd19:	bbfa      	add.n	a11, a11, a15
4200dd1b:	bbca      	add.n	a11, a11, a12
4200dd1d:	000bb2        	l8ui	a11, a11, 0
4200dd20:	11b9      	s32i.n	a11, a1, 4
4200dd22:	cba0b1        	l32r	a11, 42000ba4 <_stext+0xb84>
4200dd25:	bbfa      	add.n	a11, a11, a15
4200dd27:	bbca      	add.n	a11, a11, a12
4200dd29:	000bb2        	l8ui	a11, a11, 0
4200dd2c:	bb0b      	addi.n	a11, a11, -1
4200dd2e:	74b0b0        	extui	a11, a11, 0, 8
4200dd31:	028bb6        	bltui	a11, 8, 4200dd37 <get_arg$constprop$0+0x7f>
4200dd34:	00ce06        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dd37:	cbb9c1        	l32r	a12, 42000c1c <_stext+0xbfc>
4200dd3a:	a0bbc0        	addx4	a11, a11, a12
4200dd3d:	0bb8      	l32i.n	a11, a11, 0
4200dd3f:	000ba0        	jx	a11
4200dd42:	00          	.byte 00
4200dd43:	9a0c      	movi.n	a10, 9
4200dd45:	00c586        	j	4200e05f <get_arg$constprop$0+0x3a7>
4200dd48:	6aa0b2        	movi	a11, 106
4200dd4b:	3318b7        	beq	a8, a11, 4200dd82 <get_arg$constprop$0+0xca>
4200dd4e:	0a3b87        	bltu	a11, a8, 4200dd5c <get_arg$constprop$0+0xa4>
4200dd51:	cb4c      	movi.n	a11, 76
4200dd53:	2618b7        	beq	a8, a11, 4200dd7d <get_arg$constprop$0+0xc5>
4200dd56:	68a0b2        	movi	a11, 104
4200dd59:	0005c6        	j	4200dd74 <get_arg$constprop$0+0xbc>
4200dd5c:	71a0b2        	movi	a11, 113
4200dd5f:	1f18b7        	beq	a8, a11, 4200dd82 <get_arg$constprop$0+0xca>
4200dd62:	70a0b2        	movi	a11, 112
4200dd65:	1fbb87        	bgeu	a11, a8, 4200dd88 <get_arg$constprop$0+0xd0>
4200dd68:	74a0b2        	movi	a11, 116
4200dd6b:	0298b7        	bne	a8, a11, 4200dd71 <get_arg$constprop$0+0xb9>
4200dd6e:	00bf86        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dd71:	7aa0b2        	movi	a11, 122
4200dd74:	0298b7        	bne	a8, a11, 4200dd7a <get_arg$constprop$0+0xc2>
4200dd77:	00bd46        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dd7a:	000286        	j	4200dd88 <get_arg$constprop$0+0xd0>
4200dd7d:	880c      	movi.n	a8, 8
4200dd7f:	0006c6        	j	4200dd9e <get_arg$constprop$0+0xe6>
4200dd82:	082c      	movi.n	a8, 32
4200dd84:	000586        	j	4200dd9e <get_arg$constprop$0+0xe6>
4200dd87:	00          	.byte 00
4200dd88:	010ab2        	l8ui	a11, a10, 1
4200dd8b:	6ca082        	movi	a8, 108
4200dd8e:	0a9b87        	bne	a11, a8, 4200dd9c <get_arg$constprop$0+0xe4>
4200dd91:	032c      	movi.n	a3, 32
4200dd93:	20dd30        	or	a13, a13, a3
4200dd96:	3a2b      	addi.n	a3, a10, 2
4200dd98:	00b506        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dd9b:	00          	.byte 00
4200dd9c:	081c      	movi.n	a8, 16
4200dd9e:	20dd80        	or	a13, a13, a8
4200dda1:	00b2c6        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dda4:	61a0a2        	movi	a10, 97
4200dda7:	442020        	extui	a2, a2, 0, 5
4200ddaa:	0298a7        	bne	a8, a10, 4200ddb0 <get_arg$constprop$0+0xf8>
4200ddad:	00f806        	j	4200e191 <get_arg$constprop$0+0x4d9>
4200ddb0:	3c3a87        	bltu	a10, a8, 4200ddf0 <get_arg$constprop$0+0x138>
4200ddb3:	bfc882        	addi	a8, a8, -65
4200ddb6:	748080        	extui	a8, a8, 0, 8
4200ddb9:	7a1c      	movi.n	a10, 23
4200ddbb:	25ba87        	bgeu	a10, a8, 4200dde4 <get_arg$constprop$0+0x12c>
4200ddbe:	0016c6        	j	4200de1d <get_arg$constprop$0+0x165>
4200ddc1:	1c0c      	movi.n	a12, 1
4200ddc3:	cb7aa1        	l32r	a10, 42000bac <_stext+0xb8c>
4200ddc6:	401800        	ssl	a8
4200ddc9:	a18c00        	sll	a8, a12
4200ddcc:	3488a7        	bany	a8, a10, 4200de04 <get_arg$constprop$0+0x14c>
4200ddcf:	5a2c      	movi.n	a10, 37
4200ddd1:	11aa60        	slli	a10, a10, 10
4200ddd4:	0208a7        	bnone	a8, a10, 4200ddda <get_arg$constprop$0+0x122>
4200ddd7:	00eac6        	j	4200e186 <get_arg$constprop$0+0x4ce>
4200ddda:	ea0c      	movi.n	a10, 14
4200dddc:	3d08a7        	bnone	a8, a10, 4200de1d <get_arg$constprop$0+0x165>
4200dddf:	00eb86        	j	4200e191 <get_arg$constprop$0+0x4d9>
4200dde2:	00          	.byte 00
4200dde3:	00          	.byte 00
4200dde4:	cb8fa1        	l32r	a10, 42000c20 <_stext+0xc00>
4200dde7:	a088a0        	addx4	a8, a8, a10
4200ddea:	0888      	l32i.n	a8, a8, 0
4200ddec:	0008a0        	jx	a8
4200ddef:	00          	.byte 00
4200ddf0:	63a0a2        	movi	a10, 99
4200ddf3:	1d18a7        	beq	a8, a10, 4200de14 <get_arg$constprop$0+0x15c>
4200ddf6:	9cc882        	addi	a8, a8, -100
4200ddf9:	748080        	extui	a8, a8, 0, 8
4200ddfc:	4a1c      	movi.n	a10, 20
4200ddfe:	bfba87        	bgeu	a10, a8, 4200ddc1 <get_arg$constprop$0+0x109>
4200de01:	000606        	j	4200de1d <get_arg$constprop$0+0x165>
4200de04:	026d47        	bbci	a13, 4, 4200de0a <get_arg$constprop$0+0x152>
4200de07:	00d346        	j	4200e158 <get_arg$constprop$0+0x4a0>
4200de0a:	026d57        	bbci	a13, 5, 4200de10 <get_arg$constprop$0+0x158>
4200de0d:	00d4c6        	j	4200e164 <get_arg$constprop$0+0x4ac>
4200de10:	00d9c6        	j	4200e17b <get_arg$constprop$0+0x4c3>
4200de13:	00          	.byte 00
4200de14:	026d47        	bbci	a13, 4, 4200de1a <get_arg$constprop$0+0x162>
4200de17:	00d546        	j	4200e170 <get_arg$constprop$0+0x4b8>
4200de1a:	00d746        	j	4200e17b <get_arg$constprop$0+0x4c3>
4200de1d:	070926        	beqi	a9, -1, 4200de28 <get_arg$constprop$0+0x170>
4200de20:	a08970        	addx4	a8, a9, a7
4200de23:	0859      	s32i.n	a5, a8, 0
4200de25:	0091c6        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200de28:	850b      	addi.n	a8, a5, -1
4200de2a:	0268b6        	bltui	a8, 6, 4200de30 <get_arg$constprop$0+0x178>
4200de2d:	002b06        	j	4200dedd <get_arg$constprop$0+0x225>
4200de30:	cb7da1        	l32r	a10, 42000c24 <_stext+0xc04>
4200de33:	a088a0        	addx4	a8, a8, a10
4200de36:	0888      	l32i.n	a8, a8, 0
4200de38:	0008a0        	jx	a8
4200de3b:	2488      	l32i.n	a8, a4, 8
4200de3d:	891c      	movi.n	a9, 24
4200de3f:	584b      	addi.n	a5, a8, 4
4200de41:	2459      	s32i.n	a5, a4, 8
4200de43:	a21b      	addi.n	a10, a2, 1
4200de45:	b02260        	addx8	a2, a2, a6
4200de48:	042957        	blt	a9, a5, 4200de50 <get_arg$constprop$0+0x198>
4200de4b:	1458      	l32i.n	a5, a4, 4
4200de4d:	000206        	j	4200de59 <get_arg$constprop$0+0x1a1>
4200de50:	012987        	blt	a9, a8, 4200de55 <get_arg$constprop$0+0x19d>
4200de53:	452c      	movi.n	a5, 36
4200de55:	2459      	s32i.n	a5, a4, 8
4200de57:	0458      	l32i.n	a5, a4, 0
4200de59:	2488      	l32i.n	a8, a4, 8
4200de5b:	f97c      	movi.n	a9, -1
4200de5d:	558a      	add.n	a5, a5, a8
4200de5f:	fcc552        	addi	a5, a5, -4
4200de62:	0558      	l32i.n	a5, a5, 0
4200de64:	0259      	s32i.n	a5, a2, 0
4200de66:	0a2d      	mov.n	a2, a10
4200de68:	150c      	movi.n	a5, 1
4200de6a:	008086        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200de6d:	2458      	l32i.n	a5, a4, 8
4200de6f:	887c      	movi.n	a8, -8
4200de71:	557b      	addi.n	a5, a5, 7
4200de73:	105580        	and	a5, a5, a8
4200de76:	858b      	addi.n	a8, a5, 8
4200de78:	2489      	s32i.n	a8, a4, 8
4200de7a:	891c      	movi.n	a9, 24
4200de7c:	a21b      	addi.n	a10, a2, 1
4200de7e:	b02260        	addx8	a2, a2, a6
4200de81:	042987        	blt	a9, a8, 4200de89 <get_arg$constprop$0+0x1d1>
4200de84:	1458      	l32i.n	a5, a4, 4
4200de86:	000206        	j	4200de92 <get_arg$constprop$0+0x1da>
4200de89:	012957        	blt	a9, a5, 4200de8e <get_arg$constprop$0+0x1d6>
4200de8c:	882c      	movi.n	a8, 40
4200de8e:	0458      	l32i.n	a5, a4, 0
4200de90:	2489      	s32i.n	a8, a4, 8
4200de92:	2488      	l32i.n	a8, a4, 8
4200de94:	558a      	add.n	a5, a5, a8
4200de96:	f8c552        	addi	a5, a5, -8
4200de99:	1598      	l32i.n	a9, a5, 4
4200de9b:	0588      	l32i.n	a8, a5, 0
4200de9d:	1299      	s32i.n	a9, a2, 4
4200de9f:	0289      	s32i.n	a8, a2, 0
4200dea1:	f97c      	movi.n	a9, -1
4200dea3:	0a2d      	mov.n	a2, a10
4200dea5:	250c      	movi.n	a5, 2
4200dea7:	007146        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200deaa:	2488      	l32i.n	a8, a4, 8
4200deac:	891c      	movi.n	a9, 24
4200deae:	584b      	addi.n	a5, a8, 4
4200deb0:	2459      	s32i.n	a5, a4, 8
4200deb2:	a21b      	addi.n	a10, a2, 1
4200deb4:	b02260        	addx8	a2, a2, a6
4200deb7:	052957        	blt	a9, a5, 4200dec0 <get_arg$constprop$0+0x208>
4200deba:	1458      	l32i.n	a5, a4, 4
4200debc:	000246        	j	4200dec9 <get_arg$constprop$0+0x211>
4200debf:	00          	.byte 00
4200dec0:	012987        	blt	a9, a8, 4200dec5 <get_arg$constprop$0+0x20d>
4200dec3:	452c      	movi.n	a5, 36
4200dec5:	2459      	s32i.n	a5, a4, 8
4200dec7:	0458      	l32i.n	a5, a4, 0
4200dec9:	2488      	l32i.n	a8, a4, 8
4200decb:	f97c      	movi.n	a9, -1
4200decd:	558a      	add.n	a5, a5, a8
4200decf:	fcc552        	addi	a5, a5, -4
4200ded2:	0558      	l32i.n	a5, a5, 0
4200ded4:	0259      	s32i.n	a5, a2, 0
4200ded6:	0a2d      	mov.n	a2, a10
4200ded8:	650c      	movi.n	a5, 6
4200deda:	006486        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dedd:	2488      	l32i.n	a8, a4, 8
4200dedf:	891c      	movi.n	a9, 24
4200dee1:	584b      	addi.n	a5, a8, 4
4200dee3:	2459      	s32i.n	a5, a4, 8
4200dee5:	a21b      	addi.n	a10, a2, 1
4200dee7:	b02260        	addx8	a2, a2, a6
4200deea:	062957        	blt	a9, a5, 4200def4 <get_arg$constprop$0+0x23c>
4200deed:	1458      	l32i.n	a5, a4, 4
4200deef:	000286        	j	4200defd <get_arg$constprop$0+0x245>
4200def2:	00          	.byte 00
4200def3:	00          	.byte 00
4200def4:	012987        	blt	a9, a8, 4200def9 <get_arg$constprop$0+0x241>
4200def7:	452c      	movi.n	a5, 36
4200def9:	2459      	s32i.n	a5, a4, 8
4200defb:	0458      	l32i.n	a5, a4, 0
4200defd:	2488      	l32i.n	a8, a4, 8
4200deff:	f97c      	movi.n	a9, -1
4200df01:	558a      	add.n	a5, a5, a8
4200df03:	fcc552        	addi	a5, a5, -4
4200df06:	0558      	l32i.n	a5, a5, 0
4200df08:	0259      	s32i.n	a5, a2, 0
4200df0a:	0a2d      	mov.n	a2, a10
4200df0c:	050c      	movi.n	a5, 0
4200df0e:	005786        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200df11:	2488      	l32i.n	a8, a4, 8
4200df13:	891c      	movi.n	a9, 24
4200df15:	584b      	addi.n	a5, a8, 4
4200df17:	2459      	s32i.n	a5, a4, 8
4200df19:	a21b      	addi.n	a10, a2, 1
4200df1b:	b02260        	addx8	a2, a2, a6
4200df1e:	062957        	blt	a9, a5, 4200df28 <get_arg$constprop$0+0x270>
4200df21:	1458      	l32i.n	a5, a4, 4
4200df23:	000286        	j	4200df31 <get_arg$constprop$0+0x279>
4200df26:	00          	.byte 00
4200df27:	00          	.byte 00
4200df28:	012987        	blt	a9, a8, 4200df2d <get_arg$constprop$0+0x275>
4200df2b:	452c      	movi.n	a5, 36
4200df2d:	2459      	s32i.n	a5, a4, 8
4200df2f:	0458      	l32i.n	a5, a4, 0
4200df31:	2488      	l32i.n	a8, a4, 8
4200df33:	f97c      	movi.n	a9, -1
4200df35:	558a      	add.n	a5, a5, a8
4200df37:	fcc552        	addi	a5, a5, -4
4200df3a:	0558      	l32i.n	a5, a5, 0
4200df3c:	0259      	s32i.n	a5, a2, 0
4200df3e:	0a2d      	mov.n	a2, a10
4200df40:	350c      	movi.n	a5, 3
4200df42:	004a86        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200df45:	2458      	l32i.n	a5, a4, 8
4200df47:	887c      	movi.n	a8, -8
4200df49:	557b      	addi.n	a5, a5, 7
4200df4b:	105580        	and	a5, a5, a8
4200df4e:	858b      	addi.n	a8, a5, 8
4200df50:	2489      	s32i.n	a8, a4, 8
4200df52:	891c      	movi.n	a9, 24
4200df54:	a21b      	addi.n	a10, a2, 1
4200df56:	b02260        	addx8	a2, a2, a6
4200df59:	042987        	blt	a9, a8, 4200df61 <get_arg$constprop$0+0x2a9>
4200df5c:	1458      	l32i.n	a5, a4, 4
4200df5e:	000206        	j	4200df6a <get_arg$constprop$0+0x2b2>
4200df61:	012957        	blt	a9, a5, 4200df66 <get_arg$constprop$0+0x2ae>
4200df64:	882c      	movi.n	a8, 40
4200df66:	0458      	l32i.n	a5, a4, 0
4200df68:	2489      	s32i.n	a8, a4, 8
4200df6a:	2488      	l32i.n	a8, a4, 8
4200df6c:	558a      	add.n	a5, a5, a8
4200df6e:	f8c552        	addi	a5, a5, -8
4200df71:	1598      	l32i.n	a9, a5, 4
4200df73:	0588      	l32i.n	a8, a5, 0
4200df75:	1299      	s32i.n	a9, a2, 4
4200df77:	0289      	s32i.n	a8, a2, 0
4200df79:	f97c      	movi.n	a9, -1
4200df7b:	0a2d      	mov.n	a2, a10
4200df7d:	450c      	movi.n	a5, 4
4200df7f:	003b46        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200df82:	2488      	l32i.n	a8, a4, 8
4200df84:	8a7c      	movi.n	a10, -8
4200df86:	887b      	addi.n	a8, a8, 7
4200df88:	1088a0        	and	a8, a8, a10
4200df8b:	a88b      	addi.n	a10, a8, 8
4200df8d:	24a9      	s32i.n	a10, a4, 8
4200df8f:	8b1c      	movi.n	a11, 24
4200df91:	b0c260        	addx8	a12, a2, a6
4200df94:	052ba7        	blt	a11, a10, 4200df9d <get_arg$constprop$0+0x2e5>
4200df97:	1488      	l32i.n	a8, a4, 4
4200df99:	000246        	j	4200dfa6 <get_arg$constprop$0+0x2ee>
4200df9c:	00          	.byte 00
4200df9d:	012b87        	blt	a11, a8, 4200dfa2 <get_arg$constprop$0+0x2ea>
4200dfa0:	8a2c      	movi.n	a10, 40
4200dfa2:	0488      	l32i.n	a8, a4, 0
4200dfa4:	24a9      	s32i.n	a10, a4, 8
4200dfa6:	24a8      	l32i.n	a10, a4, 8
4200dfa8:	221b      	addi.n	a2, a2, 1
4200dfaa:	88aa      	add.n	a8, a8, a10
4200dfac:	f8c882        	addi	a8, a8, -8
4200dfaf:	08a8      	l32i.n	a10, a8, 0
4200dfb1:	18b8      	l32i.n	a11, a8, 4
4200dfb3:	0ca9      	s32i.n	a10, a12, 0
4200dfb5:	1cb9      	s32i.n	a11, a12, 4
4200dfb7:	002d46        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200dfba:	0788      	l32i.n	a8, a7, 0
4200dfbc:	140866        	bnei	a8, -1, 4200dfd4 <get_arg$constprop$0+0x31c>
4200dfbf:	80a0c2        	movi	a12, 128
4200dfc2:	0b0c      	movi.n	a11, 0
4200dfc4:	07ad      	mov.n	a10, a7
4200dfc6:	51d9      	s32i.n	a13, a1, 20
4200dfc8:	61e9      	s32i.n	a14, a1, 24
4200dfca:	c87381        	l32r	a8, 42000198 <_stext+0x178>
4200dfcd:	0008e0        	callx8	a8
4200dfd0:	61e8      	l32i.n	a14, a1, 24
4200dfd2:	51d8      	l32i.n	a13, a1, 20
4200dfd4:	0188      	l32i.n	a8, a1, 0
4200dfd6:	9e0b      	addi.n	a9, a14, -1
4200dfd8:	538890        	max	a8, a8, a9
4200dfdb:	000ac6        	j	4200e00a <get_arg$constprop$0+0x352>
4200dfde:	0788      	l32i.n	a8, a7, 0
4200dfe0:	180866        	bnei	a8, -1, 4200dffc <get_arg$constprop$0+0x344>
4200dfe3:	80a0c2        	movi	a12, 128
4200dfe6:	0b0c      	movi.n	a11, 0
4200dfe8:	07ad      	mov.n	a10, a7
4200dfea:	4199      	s32i.n	a9, a1, 16
4200dfec:	51d9      	s32i.n	a13, a1, 20
4200dfee:	61e9      	s32i.n	a14, a1, 24
4200dff0:	c86a81        	l32r	a8, 42000198 <_stext+0x178>
4200dff3:	0008e0        	callx8	a8
4200dff6:	61e8      	l32i.n	a14, a1, 24
4200dff8:	51d8      	l32i.n	a13, a1, 20
4200dffa:	4198      	l32i.n	a9, a1, 16
4200dffc:	ee0b      	addi.n	a14, a14, -1
4200dffe:	a08e70        	addx4	a8, a14, a7
4200e001:	0a0c      	movi.n	a10, 0
4200e003:	08a9      	s32i.n	a10, a8, 0
4200e005:	0188      	l32i.n	a8, a1, 0
4200e007:	5388e0        	max	a8, a8, a14
4200e00a:	0189      	s32i.n	a8, a1, 0
4200e00c:	001806        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200e00f:	0a3d      	mov.n	a3, a10
4200e011:	24a8      	l32i.n	a10, a4, 8
4200e013:	8b1c      	movi.n	a11, 24
4200e015:	8a4b      	addi.n	a8, a10, 4
4200e017:	2489      	s32i.n	a8, a4, 8
4200e019:	c21b      	addi.n	a12, a2, 1
4200e01b:	b02260        	addx8	a2, a2, a6
4200e01e:	062b87        	blt	a11, a8, 4200e028 <get_arg$constprop$0+0x370>
4200e021:	1488      	l32i.n	a8, a4, 4
4200e023:	000286        	j	4200e031 <get_arg$constprop$0+0x379>
4200e026:	00          	.byte 00
4200e027:	00          	.byte 00
4200e028:	012ba7        	blt	a11, a10, 4200e02d <get_arg$constprop$0+0x375>
4200e02b:	482c      	movi.n	a8, 36
4200e02d:	2489      	s32i.n	a8, a4, 8
4200e02f:	0488      	l32i.n	a8, a4, 0
4200e031:	24a8      	l32i.n	a10, a4, 8
4200e033:	88aa      	add.n	a8, a8, a10
4200e035:	fcc882        	addi	a8, a8, -4
4200e038:	0888      	l32i.n	a8, a8, 0
4200e03a:	0289      	s32i.n	a8, a2, 0
4200e03c:	0c2d      	mov.n	a2, a12
4200e03e:	000b86        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200e041:	d0c8e2        	addi	a14, a8, -48
4200e044:	9a0c      	movi.n	a10, 9
4200e046:	0001c6        	j	4200e051 <get_arg$constprop$0+0x399>
4200e049:	a0eee0        	addx4	a14, a14, a14
4200e04c:	90ee80        	addx2	a14, a14, a8
4200e04f:	331b      	addi.n	a3, a3, 1
4200e051:	000382        	l8ui	a8, a3, 0
4200e054:	889c      	beqz.n	a8, 4200e070 <get_arg$constprop$0+0x3b8>
4200e056:	d0c882        	addi	a8, a8, -48
4200e059:	ecba87        	bgeu	a10, a8, 4200e049 <get_arg$constprop$0+0x391>
4200e05c:	000406        	j	4200e070 <get_arg$constprop$0+0x3b8>
4200e05f:	000382        	l8ui	a8, a3, 0
4200e062:	d0c882        	addi	a8, a8, -48
4200e065:	748080        	extui	a8, a8, 0, 8
4200e068:	043a87        	bltu	a10, a8, 4200e070 <get_arg$constprop$0+0x3b8>
4200e06b:	331b      	addi.n	a3, a3, 1
4200e06d:	fffb86        	j	4200e05f <get_arg$constprop$0+0x3a7>
4200e070:	11a8      	l32i.n	a10, a1, 4
4200e072:	b80c      	movi.n	a8, 11
4200e074:	021a87        	beq	a10, a8, 4200e07a <get_arg$constprop$0+0x3c2>
4200e077:	ff21c6        	j	4200dd02 <get_arg$constprop$0+0x4a>
4200e07a:	2188      	l32i.n	a8, a1, 8
4200e07c:	000352        	l8ui	a5, a3, 0
4200e07f:	072827        	blt	a8, a2, 4200e08a <get_arg$constprop$0+0x3d2>
4200e082:	090c      	movi.n	a9, 0
4200e084:	021597        	beq	a5, a9, 4200e08a <get_arg$constprop$0+0x3d2>
4200e087:	ff1246        	j	4200dcd4 <get_arg$constprop$0+0x1c>
4200e08a:	0188      	l32i.n	a8, a1, 0
4200e08c:	2198      	l32i.n	a9, a1, 8
4200e08e:	839850        	moveqz	a9, a8, a5
4200e091:	0199      	s32i.n	a9, a1, 0
4200e093:	002646        	j	4200e130 <get_arg$constprop$0+0x478>
4200e096:	00          	.byte 00
4200e097:	00          	.byte 00
4200e098:	a05c70        	addx4	a5, a12, a7
4200e09b:	0588      	l32i.n	a8, a5, 0
4200e09d:	cc1b      	addi.n	a12, a12, 1
4200e09f:	880b      	addi.n	a8, a8, -1
4200e0a1:	2458      	l32i.n	a5, a4, 8
4200e0a3:	6568f6        	bgeui	a8, 6, 4200e10c <get_arg$constprop$0+0x454>
4200e0a6:	cae091        	l32r	a9, 42000c28 <_stext+0xc08>
4200e0a9:	a08890        	addx4	a8, a8, a9
4200e0ac:	0888      	l32i.n	a8, a8, 0
4200e0ae:	0008a0        	jx	a8
4200e0b1:	557b      	addi.n	a5, a5, 7
4200e0b3:	1055f0        	and	a5, a5, a15
4200e0b6:	858b      	addi.n	a8, a5, 8
4200e0b8:	2489      	s32i.n	a8, a4, 8
4200e0ba:	062a87        	blt	a10, a8, 4200e0c4 <get_arg$constprop$0+0x40c>
4200e0bd:	1458      	l32i.n	a5, a4, 4
4200e0bf:	000286        	j	4200e0cd <get_arg$constprop$0+0x415>
4200e0c2:	00          	.byte 00
4200e0c3:	00          	.byte 00
4200e0c4:	012a57        	blt	a10, a5, 4200e0c9 <get_arg$constprop$0+0x411>
4200e0c7:	0e8d      	mov.n	a8, a14
4200e0c9:	0458      	l32i.n	a5, a4, 0
4200e0cb:	2489      	s32i.n	a8, a4, 8
4200e0cd:	2488      	l32i.n	a8, a4, 8
4200e0cf:	558a      	add.n	a5, a5, a8
4200e0d1:	f8c552        	addi	a5, a5, -8
4200e0d4:	0588      	l32i.n	a8, a5, 0
4200e0d6:	1598      	l32i.n	a9, a5, 4
4200e0d8:	0b89      	s32i.n	a8, a11, 0
4200e0da:	1b99      	s32i.n	a9, a11, 4
4200e0dc:	001806        	j	4200e140 <get_arg$constprop$0+0x488>
4200e0df:	557b      	addi.n	a5, a5, 7
4200e0e1:	1055f0        	and	a5, a5, a15
4200e0e4:	858b      	addi.n	a8, a5, 8
4200e0e6:	2489      	s32i.n	a8, a4, 8
4200e0e8:	042a87        	blt	a10, a8, 4200e0f0 <get_arg$constprop$0+0x438>
4200e0eb:	1458      	l32i.n	a5, a4, 4
4200e0ed:	000206        	j	4200e0f9 <get_arg$constprop$0+0x441>
4200e0f0:	012a57        	blt	a10, a5, 4200e0f5 <get_arg$constprop$0+0x43d>
4200e0f3:	0e8d      	mov.n	a8, a14
4200e0f5:	0458      	l32i.n	a5, a4, 0
4200e0f7:	2489      	s32i.n	a8, a4, 8
4200e0f9:	2488      	l32i.n	a8, a4, 8
4200e0fb:	558a      	add.n	a5, a5, a8
4200e0fd:	f8c552        	addi	a5, a5, -8
4200e100:	0588      	l32i.n	a8, a5, 0
4200e102:	1598      	l32i.n	a9, a5, 4
4200e104:	0b89      	s32i.n	a8, a11, 0
4200e106:	1b99      	s32i.n	a9, a11, 4
4200e108:	000d06        	j	4200e140 <get_arg$constprop$0+0x488>
4200e10b:	00          	.byte 00
4200e10c:	854b      	addi.n	a8, a5, 4
4200e10e:	2489      	s32i.n	a8, a4, 8
4200e110:	042a87        	blt	a10, a8, 4200e118 <get_arg$constprop$0+0x460>
4200e113:	1458      	l32i.n	a5, a4, 4
4200e115:	000206        	j	4200e121 <get_arg$constprop$0+0x469>
4200e118:	012a57        	blt	a10, a5, 4200e11d <get_arg$constprop$0+0x465>
4200e11b:	0d8d      	mov.n	a8, a13
4200e11d:	0458      	l32i.n	a5, a4, 0
4200e11f:	2489      	s32i.n	a8, a4, 8
4200e121:	2488      	l32i.n	a8, a4, 8
4200e123:	558a      	add.n	a5, a5, a8
4200e125:	fcc552        	addi	a5, a5, -4
4200e128:	0558      	l32i.n	a5, a5, 0
4200e12a:	0b59      	s32i.n	a5, a11, 0
4200e12c:	000406        	j	4200e140 <get_arg$constprop$0+0x488>
4200e12f:	00          	.byte 00
4200e130:	b0b260        	addx8	a11, a2, a6
4200e133:	02cd      	mov.n	a12, a2
4200e135:	8a1c      	movi.n	a10, 24
4200e137:	4d2c      	movi.n	a13, 36
4200e139:	8f7c      	movi.n	a15, -8
4200e13b:	8e2c      	movi.n	a14, 40
4200e13d:	000046        	j	4200e142 <get_arg$constprop$0+0x48a>
4200e140:	bb8b      	addi.n	a11, a11, 8
4200e142:	0158      	l32i.n	a5, a1, 0
4200e144:	0225c7        	blt	a5, a12, 4200e14a <get_arg$constprop$0+0x492>
4200e147:	ffd346        	j	4200e098 <get_arg$constprop$0+0x3e0>
4200e14a:	551b      	addi.n	a5, a5, 1
4200e14c:	040c      	movi.n	a4, 0
4200e14e:	4a2527        	blt	a5, a2, 4200e19c <get_arg$constprop$0+0x4e4>
4200e151:	c04520        	sub	a4, a5, a2
4200e154:	001106        	j	4200e19c <get_arg$constprop$0+0x4e4>
4200e157:	00          	.byte 00
4200e158:	150c      	movi.n	a5, 1
4200e15a:	020926        	beqi	a9, -1, 4200e160 <get_arg$constprop$0+0x4a8>
4200e15d:	ff2fc6        	j	4200de20 <get_arg$constprop$0+0x168>
4200e160:	ff35c6        	j	4200de3b <get_arg$constprop$0+0x183>
4200e163:	00          	.byte 00
4200e164:	250c      	movi.n	a5, 2
4200e166:	020926        	beqi	a9, -1, 4200e16c <get_arg$constprop$0+0x4b4>
4200e169:	ff2cc6        	j	4200de20 <get_arg$constprop$0+0x168>
4200e16c:	ff3f46        	j	4200de6d <get_arg$constprop$0+0x1b5>
4200e16f:	00          	.byte 00
4200e170:	650c      	movi.n	a5, 6
4200e172:	020926        	beqi	a9, -1, 4200e178 <get_arg$constprop$0+0x4c0>
4200e175:	ff29c6        	j	4200de20 <get_arg$constprop$0+0x168>
4200e178:	ff4b86        	j	4200deaa <get_arg$constprop$0+0x1f2>
4200e17b:	050c      	movi.n	a5, 0
4200e17d:	020926        	beqi	a9, -1, 4200e183 <get_arg$constprop$0+0x4cb>
4200e180:	ff2706        	j	4200de20 <get_arg$constprop$0+0x168>
4200e183:	ff5586        	j	4200dedd <get_arg$constprop$0+0x225>
4200e186:	350c      	movi.n	a5, 3
4200e188:	020926        	beqi	a9, -1, 4200e18e <get_arg$constprop$0+0x4d6>
4200e18b:	ff2446        	j	4200de20 <get_arg$constprop$0+0x168>
4200e18e:	ff5fc6        	j	4200df11 <get_arg$constprop$0+0x259>
4200e191:	450c      	movi.n	a5, 4
4200e193:	020926        	beqi	a9, -1, 4200e199 <get_arg$constprop$0+0x4e1>
4200e196:	ff2186        	j	4200de20 <get_arg$constprop$0+0x168>
4200e199:	ff6a06        	j	4200df45 <get_arg$constprop$0+0x28d>
4200e19c:	3188      	l32i.n	a8, a1, 12
4200e19e:	424a      	add.n	a4, a2, a4
4200e1a0:	0849      	s32i.n	a4, a8, 0
4200e1a2:	102192        	l32i	a9, a1, 64
4200e1a5:	2188      	l32i.n	a8, a1, 8
4200e1a7:	0939      	s32i.n	a3, a9, 0
4200e1a9:	b02860        	addx8	a2, a8, a6
4200e1ac:	f01d      	retw.n
	...

4200e1b0 <_vfprintf_r>:
4200e1b0:	062136        	entry	a1, 0x310
4200e1b3:	a36122        	s32i	a2, a1, 0x28c
4200e1b6:	a321a2        	l32i	a10, a1, 0x28c
4200e1b9:	a16132        	s32i	a3, a1, 0x284
4200e1bc:	a26142        	s32i	a4, a1, 0x288
4200e1bf:	9c6152        	s32i	a5, a1, 0x270
4200e1c2:	9d6162        	s32i	a6, a1, 0x274
4200e1c5:	9e6172        	s32i	a7, a1, 0x278
4200e1c8:	201110        	or	a1, a1, a1
4200e1cb:	0441a5        	call8	420125e4 <_localeconv_r>
4200e1ce:	0aa8      	l32i.n	a10, a10, 0
4200e1d0:	b261a2        	s32i	a10, a1, 0x2c8
4200e1d3:	c93081        	l32r	a8, 42000694 <_stext+0x674>
4200e1d6:	0008e0        	callx8	a8
4200e1d9:	a32182        	l32i	a8, a1, 0x28c
4200e1dc:	ae61a2        	s32i	a10, a1, 0x2b8
4200e1df:	a88c      	beqz.n	a8, 4200e1ed <_vfprintf_r+0x3d>
4200e1e1:	6828      	l32i.n	a2, a8, 24
4200e1e3:	62cc      	bnez.n	a2, 4200e1ed <_vfprintf_r+0x3d>
4200e1e5:	08ad      	mov.n	a10, a8
4200e1e7:	201110        	or	a1, a1, a1
4200e1ea:	fb7ca5        	call8	420099b4 <__sinit>
4200e1ed:	ca6021        	l32r	a2, 42000b70 <_stext+0xb50>
4200e1f0:	a12132        	l32i	a3, a1, 0x284
4200e1f3:	099327        	bne	a3, a2, 4200e200 <_vfprintf_r+0x50>
4200e1f6:	a32182        	l32i	a8, a1, 0x28c
4200e1f9:	1888      	l32i.n	a8, a8, 4
4200e1fb:	000806        	j	4200e21f <_vfprintf_r+0x6f>
4200e1fe:	00          	.byte 00
4200e1ff:	00          	.byte 00
4200e200:	ca5d21        	l32r	a2, 42000b74 <_stext+0xb54>
4200e203:	a12132        	l32i	a3, a1, 0x284
4200e206:	079327        	bne	a3, a2, 4200e211 <_vfprintf_r+0x61>
4200e209:	a32182        	l32i	a8, a1, 0x28c
4200e20c:	2888      	l32i.n	a8, a8, 8
4200e20e:	000346        	j	4200e21f <_vfprintf_r+0x6f>
4200e211:	ca5921        	l32r	a2, 42000b78 <_stext+0xb58>
4200e214:	a12132        	l32i	a3, a1, 0x284
4200e217:	079327        	bne	a3, a2, 4200e222 <_vfprintf_r+0x72>
4200e21a:	a32182        	l32i	a8, a1, 0x28c
4200e21d:	3888      	l32i.n	a8, a8, 12
4200e21f:	a16182        	s32i	a8, a1, 0x284
4200e222:	10c1a2        	addi	a10, a1, 16
4200e225:	44a2b2        	movi	a11, 0x244
4200e228:	80bab0        	add	a11, a10, a11
4200e22b:	01a0a2        	movi	a10, 1
4200e22e:	201110        	or	a1, a1, a1
4200e231:	09ce25        	call8	42017f14 <pthread_setcancelstate>
4200e234:	a12132        	l32i	a3, a1, 0x284
4200e237:	192322        	l32i	a2, a3, 100
4200e23a:	0ee207        	bbsi	a2, 0, 4200e24c <_vfprintf_r+0x9c>
4200e23d:	061322        	l16ui	a2, a3, 12
4200e240:	08e297        	bbsi	a2, 9, 4200e24c <_vfprintf_r+0x9c>
4200e243:	1623a2        	l32i	a10, a3, 88
4200e246:	ca4181        	l32r	a8, 42000b4c <_stext+0xb2c>
4200e249:	0008e0        	callx8	a8
4200e24c:	a12182        	l32i	a8, a1, 0x284
4200e24f:	061822        	l16ui	a2, a8, 12
4200e252:	046237        	bbci	a2, 3, 4200e25a <_vfprintf_r+0xaa>
4200e255:	4828      	l32i.n	a2, a8, 16
4200e257:	042256        	bnez	a2, 4200e29d <_vfprintf_r+0xed>
4200e25a:	a121b2        	l32i	a11, a1, 0x284
4200e25d:	a321a2        	l32i	a10, a1, 0x28c
4200e260:	201110        	or	a1, a1, a1
4200e263:	030fe5        	call8	42011360 <__swsetup_r>
4200e266:	3abc      	beqz.n	a10, 4200e29d <_vfprintf_r+0xed>
4200e268:	a12132        	l32i	a3, a1, 0x284
4200e26b:	192322        	l32i	a2, a3, 100
4200e26e:	0ee207        	bbsi	a2, 0, 4200e280 <_vfprintf_r+0xd0>
4200e271:	061322        	l16ui	a2, a3, 12
4200e274:	08e297        	bbsi	a2, 9, 4200e280 <_vfprintf_r+0xd0>
4200e277:	1623a2        	l32i	a10, a3, 88
4200e27a:	ca3581        	l32r	a8, 42000b50 <_stext+0xb30>
4200e27d:	0008e0        	callx8	a8
4200e280:	9521a2        	l32i	a10, a1, 0x254
4200e283:	44a2b2        	movi	a11, 0x244
4200e286:	10c142        	addi	a4, a1, 16
4200e289:	b4ba      	add.n	a11, a4, a11
4200e28b:	ffaf52        	movi	a5, -1
4200e28e:	201110        	or	a1, a1, a1
4200e291:	09c825        	call8	42017f14 <pthread_setcancelstate>
4200e294:	ad6152        	s32i	a5, a1, 0x2b4
4200e297:	0c00c6        	j	4201129e <_vfprintf_r+0x30ee>
4200e29a:	00          	.byte 00
4200e29b:	00          	.byte 00
4200e29c:	00          	.byte 00
4200e29d:	a12182        	l32i	a8, a1, 0x284
4200e2a0:	1aa022        	movi	a2, 26
4200e2a3:	061832        	l16ui	a3, a8, 12
4200e2a6:	102320        	and	a2, a3, a2
4200e2a9:	479266        	bnei	a2, 10, 4200e2f4 <_vfprintf_r+0x144>
4200e2ac:	079822        	l16si	a2, a8, 14
4200e2af:	041296        	bltz	a2, 4200e2f4 <_vfprintf_r+0x144>
4200e2b2:	192822        	l32i	a2, a8, 100
4200e2b5:	0be207        	bbsi	a2, 0, 4200e2c4 <_vfprintf_r+0x114>
4200e2b8:	08e397        	bbsi	a3, 9, 4200e2c4 <_vfprintf_r+0x114>
4200e2bb:	1628a2        	l32i	a10, a8, 88
4200e2be:	ca2481        	l32r	a8, 42000b50 <_stext+0xb30>
4200e2c1:	0008e0        	callx8	a8
4200e2c4:	10c1a2        	addi	a10, a1, 16
4200e2c7:	44a2b2        	movi	a11, 0x244
4200e2ca:	baba      	add.n	a11, a10, a11
4200e2cc:	9521a2        	l32i	a10, a1, 0x254
4200e2cf:	201110        	or	a1, a1, a1
4200e2d2:	09c425        	call8	42017f14 <pthread_setcancelstate>
4200e2d5:	9c21d2        	l32i	a13, a1, 0x270
4200e2d8:	9d21e2        	l32i	a14, a1, 0x274
4200e2db:	9e21f2        	l32i	a15, a1, 0x278
4200e2de:	a221c2        	l32i	a12, a1, 0x288
4200e2e1:	a121b2        	l32i	a11, a1, 0x284
4200e2e4:	a321a2        	l32i	a10, a1, 0x28c
4200e2e7:	201110        	or	a1, a1, a1
4200e2ea:	02fde5        	call8	420112c8 <__sbprintf>
4200e2ed:	ad61a2        	s32i	a10, a1, 0x2b4
4200e2f0:	0bea86        	j	4201129e <_vfprintf_r+0x30ee>
4200e2f3:	00          	.byte 00
4200e2f4:	f47c      	movi.n	a4, -1
4200e2f6:	c93e51        	l32r	a5, 420007f0 <_stext+0x7d0>
4200e2f9:	10c1e2        	addi	a14, a1, 16
4200e2fc:	e4a132        	movi	a3, 0x1e4
4200e2ff:	446142        	s32i	a4, a1, 0x110
4200e302:	c93b41        	l32r	a4, 420007f0 <_stext+0x7d0>
4200e305:	020c      	movi.n	a2, 0
4200e307:	3e3a      	add.n	a3, a14, a3
4200e309:	8d6132        	s32i	a3, a1, 0x234
4200e30c:	8f6122        	s32i	a2, a1, 0x23c
4200e30f:	8e6122        	s32i	a2, a1, 0x238
4200e312:	976122        	s32i	a2, a1, 0x25c
4200e315:	986122        	s32i	a2, a1, 0x260
4200e318:	a66122        	s32i	a2, a1, 0x298
4200e31b:	a86142        	s32i	a4, a1, 0x2a0
4200e31e:	a96152        	s32i	a5, a1, 0x2a4
4200e321:	039d      	mov.n	a9, a3
4200e323:	b46122        	s32i	a2, a1, 0x2d0
4200e326:	b66122        	s32i	a2, a1, 0x2d8
4200e329:	ac6122        	s32i	a2, a1, 0x2b0
4200e32c:	b06122        	s32i	a2, a1, 0x2c0
4200e32f:	b56122        	s32i	a2, a1, 0x2d4
4200e332:	ad6122        	s32i	a2, a1, 0x2b4
4200e335:	9f6122        	s32i	a2, a1, 0x27c
4200e338:	000186        	j	4200e342 <_vfprintf_r+0x192>
4200e33b:	00          	.byte 00
4200e33c:	aa2152        	l32i	a5, a1, 0x2a8
4200e33f:	a26152        	s32i	a5, a1, 0x288
4200e342:	a22132        	l32i	a3, a1, 0x288
4200e345:	000046        	j	4200e34a <_vfprintf_r+0x19a>
4200e348:	331b      	addi.n	a3, a3, 1
4200e34a:	000322        	l8ui	a2, a3, 0
4200e34d:	428c      	beqz.n	a2, 4200e355 <_vfprintf_r+0x1a5>
4200e34f:	dbc222        	addi	a2, a2, -37
4200e352:	ff2256        	bnez	a2, 4200e348 <_vfprintf_r+0x198>
4200e355:	a22182        	l32i	a8, a1, 0x288
4200e358:	c04380        	sub	a4, a3, a8
4200e35b:	451387        	beq	a3, a8, 4200e3a4 <_vfprintf_r+0x1f4>
4200e35e:	8f2122        	l32i	a2, a1, 0x23c
4200e361:	0989      	s32i.n	a8, a9, 0
4200e363:	224a      	add.n	a2, a2, a4
4200e365:	8f6122        	s32i	a2, a1, 0x23c
4200e368:	8e2122        	l32i	a2, a1, 0x238
4200e36b:	1949      	s32i.n	a4, a9, 4
4200e36d:	221b      	addi.n	a2, a2, 1
4200e36f:	10c1a2        	addi	a10, a1, 16
4200e372:	8e6122        	s32i	a2, a1, 0x238
4200e375:	02da52        	addmi	a5, a10, 0x200
4200e378:	998b      	addi.n	a9, a9, 8
4200e37a:	1e82a6        	blti	a2, 8, 4200e39c <_vfprintf_r+0x1ec>
4200e37d:	10c1b2        	addi	a11, a1, 16
4200e380:	24a2c2        	movi	a12, 0x224
4200e383:	cbca      	add.n	a12, a11, a12
4200e385:	a321a2        	l32i	a10, a1, 0x28c
4200e388:	a121b2        	l32i	a11, a1, 0x284
4200e38b:	201110        	or	a1, a1, a1
4200e38e:	0770e5        	call8	42015a9c <__sprint_r>
4200e391:	1a8c      	beqz.n	a10, 4200e396 <_vfprintf_r+0x1e6>
4200e393:	0ba546        	j	4201122c <_vfprintf_r+0x307c>
4200e396:	f4a1e2        	movi	a14, 0x1f4
4200e399:	8091e0        	add	a9, a1, a14
4200e39c:	ad2122        	l32i	a2, a1, 0x2b4
4200e39f:	224a      	add.n	a2, a2, a4
4200e3a1:	ad6122        	s32i	a2, a1, 0x2b4
4200e3a4:	000322        	l8ui	a2, a3, 0
4200e3a7:	12cc      	bnez.n	a2, 4200e3ac <_vfprintf_r+0x1fc>
4200e3a9:	0b91c6        	j	420111f4 <_vfprintf_r+0x3044>
4200e3ac:	10c142        	addi	a4, a1, 16
4200e3af:	02d422        	addmi	a2, a4, 0x200
4200e3b2:	080c      	movi.n	a8, 0
4200e3b4:	040c      	movi.n	a4, 0
4200e3b6:	f67c      	movi.n	a6, -1
4200e3b8:	564242        	s8i	a4, a2, 86
4200e3bb:	531b      	addi.n	a5, a3, 1
4200e3bd:	9f2122        	l32i	a2, a1, 0x27c
4200e3c0:	a46162        	s32i	a6, a1, 0x290
4200e3c3:	ab6182        	s32i	a8, a1, 0x2ac
4200e3c6:	084d      	mov.n	a4, a8
4200e3c8:	a06182        	s32i	a8, a1, 0x280
4200e3cb:	000286        	j	4200e3d9 <_vfprintf_r+0x229>
4200e3ce:	00          	.byte 00
4200e3cf:	00          	.byte 00
4200e3d0:	00          	.byte 00
4200e3d1:	aa6152        	s32i	a5, a1, 0x2a8
4200e3d4:	040c      	movi.n	a4, 0
4200e3d6:	aa2152        	l32i	a5, a1, 0x2a8
4200e3d9:	651b      	addi.n	a6, a5, 1
4200e3db:	000552        	l8ui	a5, a5, 0
4200e3de:	aa6162        	s32i	a6, a1, 0x2a8
4200e3e1:	ca18d1        	l32r	a13, 42000c44 <_stext+0xc24>
4200e3e4:	a76152        	s32i	a5, a1, 0x29c
4200e3e7:	ac5c      	movi.n	a12, 90
4200e3e9:	960c      	movi.n	a6, 9
4200e3eb:	482c      	movi.n	a8, 36
4200e3ed:	aa2c      	movi.n	a10, 42
4200e3ef:	000106        	j	4200e3f7 <_vfprintf_r+0x247>
4200e3f2:	00          	.byte 00
4200e3f3:	00          	.byte 00
4200e3f4:	ab6152        	s32i	a5, a1, 0x2ac
4200e3f7:	a721b2        	l32i	a11, a1, 0x29c
4200e3fa:	e0cb52        	addi	a5, a11, -32
4200e3fd:	02bc57        	bgeu	a12, a5, 4200e403 <_vfprintf_r+0x253>
4200e400:	08b406        	j	420106d4 <_vfprintf_r+0x2524>
4200e403:	a055d0        	addx4	a5, a5, a13
4200e406:	0558      	l32i.n	a5, a5, 0
4200e408:	0005a0        	jx	a5
4200e40b:	00          	.byte 00
4200e40c:	00          	.byte 00
4200e40d:	a321a2        	l32i	a10, a1, 0x28c
4200e410:	b96192        	s32i	a9, a1, 0x2e4
4200e413:	201110        	or	a1, a1, a1
4200e416:	041ce5        	call8	420125e4 <_localeconv_r>
4200e419:	1aa8      	l32i.n	a10, a10, 4
4200e41b:	b561a2        	s32i	a10, a1, 0x2d4
4200e41e:	c89d81        	l32r	a8, 42000694 <_stext+0x674>
4200e421:	0008e0        	callx8	a8
4200e424:	b061a2        	s32i	a10, a1, 0x2c0
4200e427:	a321a2        	l32i	a10, a1, 0x28c
4200e42a:	201110        	or	a1, a1, a1
4200e42d:	041b65        	call8	420125e4 <_localeconv_r>
4200e430:	2aa8      	l32i.n	a10, a10, 8
4200e432:	b02152        	l32i	a5, a1, 0x2c0
4200e435:	ac61a2        	s32i	a10, a1, 0x2b0
4200e438:	b92192        	l32i	a9, a1, 0x2e4
4200e43b:	f97516        	beqz	a5, 4200e3d6 <_vfprintf_r+0x226>
4200e43e:	f94a16        	beqz	a10, 4200e3d6 <_vfprintf_r+0x226>
4200e441:	000a52        	l8ui	a5, a10, 0
4200e444:	f8e516        	beqz	a5, 4200e3d6 <_vfprintf_r+0x226>
4200e447:	00a452        	movi	a5, 0x400
4200e44a:	00ba46        	j	4200e737 <_vfprintf_r+0x587>
4200e44d:	10c182        	addi	a8, a1, 16
4200e450:	02d852        	addmi	a5, a8, 0x200
4200e453:	560562        	l8ui	a6, a5, 86
4200e456:	f7c656        	bnez	a6, 4200e3d6 <_vfprintf_r+0x226>
4200e459:	062c      	movi.n	a6, 32
4200e45b:	004646        	j	4200e578 <_vfprintf_r+0x3c8>
4200e45e:	150c      	movi.n	a5, 1
4200e460:	00b4c6        	j	4200e737 <_vfprintf_r+0x587>
4200e463:	aa2182        	l32i	a8, a1, 0x2a8
4200e466:	970c      	movi.n	a7, 9
4200e468:	000862        	l8ui	a6, a8, 0
4200e46b:	d0c652        	addi	a5, a6, -48
4200e46e:	02b757        	bgeu	a7, a5, 4200e474 <_vfprintf_r+0x2c4>
4200e471:	0b7d06        	j	42011269 <_vfprintf_r+0x30b9>
4200e474:	581b      	addi.n	a5, a8, 1
4200e476:	0a0c      	movi.n	a10, 0
4200e478:	d0c662        	addi	a6, a6, -48
4200e47b:	a0aaa0        	addx4	a10, a10, a10
4200e47e:	90aa60        	addx2	a10, a10, a6
4200e481:	000562        	l8ui	a6, a5, 0
4200e484:	551b      	addi.n	a5, a5, 1
4200e486:	d0c682        	addi	a8, a6, -48
4200e489:	ebb787        	bgeu	a7, a8, 4200e478 <_vfprintf_r+0x2c8>
4200e48c:	472c      	movi.n	a7, 36
4200e48e:	021677        	beq	a6, a7, 4200e494 <_vfprintf_r+0x2e4>
4200e491:	ffcfc6        	j	4200e3d4 <_vfprintf_r+0x224>
4200e494:	062c      	movi.n	a6, 32
4200e496:	02a6a7        	bge	a6, a10, 4200e49c <_vfprintf_r+0x2ec>
4200e499:	0b63c6        	j	4201122c <_vfprintf_r+0x307c>
4200e49c:	982162        	l32i	a6, a1, 0x260
4200e49f:	aa0b      	addi.n	a10, a10, -1
4200e4a1:	14aa67        	bge	a10, a6, 4200e4b9 <_vfprintf_r+0x309>
4200e4a4:	10c1b2        	addi	a11, a1, 16
4200e4a7:	b0aab0        	addx8	a10, a10, a11
4200e4aa:	0aa8      	l32i.n	a10, a10, 0
4200e4ac:	9f21c2        	l32i	a12, a1, 0x27c
4200e4af:	ab61a2        	s32i	a10, a1, 0x2ac
4200e4b2:	aa6152        	s32i	a5, a1, 0x2a8
4200e4b5:	0028c6        	j	4200e55c <_vfprintf_r+0x3ac>
4200e4b8:	00          	.byte 00
4200e4b9:	10c1e2        	addi	a14, a1, 16
4200e4bc:	4ca262        	movi	a6, 0x24c
4200e4bf:	6e6a      	add.n	a6, a14, a6
4200e4c1:	60a2d2        	movi	a13, 0x260
4200e4c4:	60a2c2        	movi	a12, 0x260
4200e4c7:	ceca      	add.n	a12, a14, a12
4200e4c9:	0169      	s32i.n	a6, a1, 0
4200e4cb:	01def2        	addmi	a15, a14, 0x100
4200e4ce:	dd1a      	add.n	a13, a13, a1
4200e4d0:	03bd      	mov.n	a11, a3
4200e4d2:	b96192        	s32i	a9, a1, 0x2e4
4200e4d5:	ff7e25        	call8	4200dcb8 <get_arg$constprop$0>
4200e4d8:	0aa8      	l32i.n	a10, a10, 0
4200e4da:	9f21c2        	l32i	a12, a1, 0x27c
4200e4dd:	b92192        	l32i	a9, a1, 0x2e4
4200e4e0:	ab61a2        	s32i	a10, a1, 0x2ac
4200e4e3:	aa6152        	s32i	a5, a1, 0x2a8
4200e4e6:	001c86        	j	4200e55c <_vfprintf_r+0x3ac>
4200e4e9:	10c162        	addi	a6, a1, 16
4200e4ec:	b05260        	addx8	a5, a2, a6
4200e4ef:	001906        	j	4200e557 <_vfprintf_r+0x3a7>
4200e4f2:	10c182        	addi	a8, a1, 16
4200e4f5:	9a28a2        	l32i	a10, a8, 0x268
4200e4f8:	fb1c      	movi.n	a11, 31
4200e4fa:	02d872        	addmi	a7, a8, 0x200
4200e4fd:	5a4b      	addi.n	a5, a10, 4
4200e4ff:	881c      	movi.n	a8, 24
4200e501:	332b67        	blt	a11, a6, 4200e538 <_vfprintf_r+0x388>
4200e504:	b61b      	addi.n	a11, a6, 1
4200e506:	9861b2        	s32i	a11, a1, 0x260
4200e509:	1a6752        	s32i	a5, a7, 104
4200e50c:	052857        	blt	a8, a5, 4200e515 <_vfprintf_r+0x365>
4200e50f:	192752        	l32i	a5, a7, 100
4200e512:	000286        	j	4200e520 <_vfprintf_r+0x370>
4200e515:	0128a7        	blt	a8, a10, 4200e51a <_vfprintf_r+0x36a>
4200e518:	452c      	movi.n	a5, 36
4200e51a:	9e6152        	s32i	a5, a1, 0x278
4200e51d:	9c2152        	l32i	a5, a1, 0x270
4200e520:	9e2172        	l32i	a7, a1, 0x278
4200e523:	10c1b2        	addi	a11, a1, 16
4200e526:	557a      	add.n	a5, a5, a7
4200e528:	fcc552        	addi	a5, a5, -4
4200e52b:	0558      	l32i.n	a5, a5, 0
4200e52d:	b066b0        	addx8	a6, a6, a11
4200e530:	ab6152        	s32i	a5, a1, 0x2ac
4200e533:	0659      	s32i.n	a5, a6, 0
4200e535:	0008c6        	j	4200e55c <_vfprintf_r+0x3ac>
4200e538:	1a6752        	s32i	a5, a7, 104
4200e53b:	052857        	blt	a8, a5, 4200e544 <_vfprintf_r+0x394>
4200e53e:	192752        	l32i	a5, a7, 100
4200e541:	000286        	j	4200e54f <_vfprintf_r+0x39f>
4200e544:	0128a7        	blt	a8, a10, 4200e549 <_vfprintf_r+0x399>
4200e547:	452c      	movi.n	a5, 36
4200e549:	9e6152        	s32i	a5, a1, 0x278
4200e54c:	9c2152        	l32i	a5, a1, 0x270
4200e54f:	9e2162        	l32i	a6, a1, 0x278
4200e552:	556a      	add.n	a5, a5, a6
4200e554:	fcc552        	addi	a5, a5, -4
4200e557:	0558      	l32i.n	a5, a5, 0
4200e559:	ab6152        	s32i	a5, a1, 0x2ac
4200e55c:	ab2152        	l32i	a5, a1, 0x2ac
4200e55f:	9f61c2        	s32i	a12, a1, 0x27c
4200e562:	e705d6        	bgez	a5, 4200e3d6 <_vfprintf_r+0x226>
4200e565:	605050        	neg	a5, a5
4200e568:	ab6152        	s32i	a5, a1, 0x2ac
4200e56b:	450c      	movi.n	a5, 4
4200e56d:	007186        	j	4200e737 <_vfprintf_r+0x587>
4200e570:	10c182        	addi	a8, a1, 16
4200e573:	b62c      	movi.n	a6, 43
4200e575:	02d852        	addmi	a5, a8, 0x200
4200e578:	564562        	s8i	a6, a5, 86
4200e57b:	ff95c6        	j	4200e3d6 <_vfprintf_r+0x226>
4200e57e:	aa21b2        	l32i	a11, a1, 0x2a8
4200e581:	000be2        	l8ui	a14, a11, 0
4200e584:	5b1b      	addi.n	a5, a11, 1
4200e586:	a761e2        	s32i	a14, a1, 0x29c
4200e589:	071ea7        	beq	a14, a10, 4200e594 <_vfprintf_r+0x3e4>
4200e58c:	0b0c      	movi.n	a11, 0
4200e58e:	a461b2        	s32i	a11, a1, 0x290
4200e591:	0045c6        	j	4200e6ac <_vfprintf_r+0x4fc>
4200e594:	aa2162        	l32i	a6, a1, 0x2a8
4200e597:	980c      	movi.n	a8, 9
4200e599:	010672        	l8ui	a7, a6, 1
4200e59c:	d0c762        	addi	a6, a7, -48
4200e59f:	02b867        	bgeu	a8, a6, 4200e5a5 <_vfprintf_r+0x3f5>
4200e5a2:	0b3586        	j	4201127c <_vfprintf_r+0x30cc>
4200e5a5:	aa21a2        	l32i	a10, a1, 0x2a8
4200e5a8:	6a2b      	addi.n	a6, a10, 2
4200e5aa:	0a0c      	movi.n	a10, 0
4200e5ac:	d0c772        	addi	a7, a7, -48
4200e5af:	a0aaa0        	addx4	a10, a10, a10
4200e5b2:	90aa70        	addx2	a10, a10, a7
4200e5b5:	000672        	l8ui	a7, a6, 0
4200e5b8:	661b      	addi.n	a6, a6, 1
4200e5ba:	d0c7b2        	addi	a11, a7, -48
4200e5bd:	ebb8b7        	bgeu	a8, a11, 4200e5ac <_vfprintf_r+0x3fc>
4200e5c0:	482c      	movi.n	a8, 36
4200e5c2:	021787        	beq	a7, a8, 4200e5c8 <_vfprintf_r+0x418>
4200e5c5:	ff8206        	j	4200e3d1 <_vfprintf_r+0x221>
4200e5c8:	052c      	movi.n	a5, 32
4200e5ca:	02a5a7        	bge	a5, a10, 4200e5d0 <_vfprintf_r+0x420>
4200e5cd:	0b16c6        	j	4201122c <_vfprintf_r+0x307c>
4200e5d0:	982152        	l32i	a5, a1, 0x260
4200e5d3:	aa0b      	addi.n	a10, a10, -1
4200e5d5:	10aa57        	bge	a10, a5, 4200e5e9 <_vfprintf_r+0x439>
4200e5d8:	10c1b2        	addi	a11, a1, 16
4200e5db:	b0aab0        	addx8	a10, a10, a11
4200e5de:	0a88      	l32i.n	a8, a10, 0
4200e5e0:	9f21c2        	l32i	a12, a1, 0x27c
4200e5e3:	065d      	mov.n	a5, a6
4200e5e5:	002706        	j	4200e685 <_vfprintf_r+0x4d5>
4200e5e8:	00          	.byte 00
4200e5e9:	10c1e2        	addi	a14, a1, 16
4200e5ec:	4ca252        	movi	a5, 0x24c
4200e5ef:	5e5a      	add.n	a5, a14, a5
4200e5f1:	60a2d2        	movi	a13, 0x260
4200e5f4:	60a2c2        	movi	a12, 0x260
4200e5f7:	0159      	s32i.n	a5, a1, 0
4200e5f9:	ceca      	add.n	a12, a14, a12
4200e5fb:	01def2        	addmi	a15, a14, 0x100
4200e5fe:	dd1a      	add.n	a13, a13, a1
4200e600:	03bd      	mov.n	a11, a3
4200e602:	b96192        	s32i	a9, a1, 0x2e4
4200e605:	ff6b25        	call8	4200dcb8 <get_arg$constprop$0>
4200e608:	0a88      	l32i.n	a8, a10, 0
4200e60a:	9f21c2        	l32i	a12, a1, 0x27c
4200e60d:	b92192        	l32i	a9, a1, 0x2e4
4200e610:	065d      	mov.n	a5, a6
4200e612:	001bc6        	j	4200e685 <_vfprintf_r+0x4d5>
4200e615:	10c182        	addi	a8, a1, 16
4200e618:	b06280        	addx8	a6, a2, a8
4200e61b:	001906        	j	4200e683 <_vfprintf_r+0x4d3>
4200e61e:	10c1a2        	addi	a10, a1, 16
4200e621:	02da82        	addmi	a8, a10, 0x200
4200e624:	1a28a2        	l32i	a10, a8, 104
4200e627:	fb1c      	movi.n	a11, 31
4200e629:	6a4b      	addi.n	a6, a10, 4
4200e62b:	322b77        	blt	a11, a7, 4200e661 <_vfprintf_r+0x4b1>
4200e62e:	b71b      	addi.n	a11, a7, 1
4200e630:	9861b2        	s32i	a11, a1, 0x260
4200e633:	1a6862        	s32i	a6, a8, 104
4200e636:	8b1c      	movi.n	a11, 24
4200e638:	052b67        	blt	a11, a6, 4200e641 <_vfprintf_r+0x491>
4200e63b:	192862        	l32i	a6, a8, 100
4200e63e:	000286        	j	4200e64c <_vfprintf_r+0x49c>
4200e641:	012ba7        	blt	a11, a10, 4200e646 <_vfprintf_r+0x496>
4200e644:	462c      	movi.n	a6, 36
4200e646:	9e6162        	s32i	a6, a1, 0x278
4200e649:	9c2162        	l32i	a6, a1, 0x270
4200e64c:	9e2182        	l32i	a8, a1, 0x278
4200e64f:	10c1e2        	addi	a14, a1, 16
4200e652:	668a      	add.n	a6, a6, a8
4200e654:	fcc662        	addi	a6, a6, -4
4200e657:	0688      	l32i.n	a8, a6, 0
4200e659:	b077e0        	addx8	a7, a7, a14
4200e65c:	0789      	s32i.n	a8, a7, 0
4200e65e:	0008c6        	j	4200e685 <_vfprintf_r+0x4d5>
4200e661:	1a6862        	s32i	a6, a8, 104
4200e664:	871c      	movi.n	a7, 24
4200e666:	062767        	blt	a7, a6, 4200e670 <_vfprintf_r+0x4c0>
4200e669:	192862        	l32i	a6, a8, 100
4200e66c:	0002c6        	j	4200e67b <_vfprintf_r+0x4cb>
4200e66f:	00          	.byte 00
4200e670:	0127a7        	blt	a7, a10, 4200e675 <_vfprintf_r+0x4c5>
4200e673:	462c      	movi.n	a6, 36
4200e675:	9e6162        	s32i	a6, a1, 0x278
4200e678:	9c2162        	l32i	a6, a1, 0x270
4200e67b:	9e2172        	l32i	a7, a1, 0x278
4200e67e:	667a      	add.n	a6, a6, a7
4200e680:	fcc662        	addi	a6, a6, -4
4200e683:	0688      	l32i.n	a8, a6, 0
4200e685:	f67c      	movi.n	a6, -1
4200e687:	536860        	max	a6, a8, a6
4200e68a:	a46162        	s32i	a6, a1, 0x290
4200e68d:	9f61c2        	s32i	a12, a1, 0x27c
4200e690:	aa6152        	s32i	a5, a1, 0x2a8
4200e693:	ff4fc6        	j	4200e3d6 <_vfprintf_r+0x226>
4200e696:	00          	.byte 00
4200e697:	00          	.byte 00
4200e698:	a421e2        	l32i	a14, a1, 0x290
4200e69b:	a0bee0        	addx4	a11, a14, a14
4200e69e:	90bb70        	addx2	a11, a11, a7
4200e6a1:	a461b2        	s32i	a11, a1, 0x290
4200e6a4:	0005b2        	l8ui	a11, a5, 0
4200e6a7:	551b      	addi.n	a5, a5, 1
4200e6a9:	a761b2        	s32i	a11, a1, 0x29c
4200e6ac:	a721e2        	l32i	a14, a1, 0x29c
4200e6af:	aa6152        	s32i	a5, a1, 0x2a8
4200e6b2:	d0ce72        	addi	a7, a14, -48
4200e6b5:	dfb677        	bgeu	a6, a7, 4200e698 <_vfprintf_r+0x4e8>
4200e6b8:	ab2152        	l32i	a5, a1, 0x2ac
4200e6bb:	ff4d46        	j	4200e3f4 <_vfprintf_r+0x244>
4200e6be:	00          	.byte 00
4200e6bf:	00          	.byte 00
4200e6c0:	80a052        	movi	a5, 128
4200e6c3:	001c06        	j	4200e737 <_vfprintf_r+0x587>
4200e6c6:	050c      	movi.n	a5, 0
4200e6c8:	a721b2        	l32i	a11, a1, 0x29c
4200e6cb:	a05550        	addx4	a5, a5, a5
4200e6ce:	d0cb72        	addi	a7, a11, -48
4200e6d1:	905570        	addx2	a5, a5, a7
4200e6d4:	aa2172        	l32i	a7, a1, 0x2a8
4200e6d7:	0007e2        	l8ui	a14, a7, 0
4200e6da:	b71b      	addi.n	a11, a7, 1
4200e6dc:	a761e2        	s32i	a14, a1, 0x29c
4200e6df:	aa61b2        	s32i	a11, a1, 0x2a8
4200e6e2:	d0ce72        	addi	a7, a14, -48
4200e6e5:	dfb677        	bgeu	a6, a7, 4200e6c8 <_vfprintf_r+0x518>
4200e6e8:	021e87        	beq	a14, a8, 4200e6ee <_vfprintf_r+0x53e>
4200e6eb:	ff4146        	j	4200e3f4 <_vfprintf_r+0x244>
4200e6ee:	022c      	movi.n	a2, 32
4200e6f0:	02a257        	bge	a2, a5, 4200e6f6 <_vfprintf_r+0x546>
4200e6f3:	0acd46        	j	4201122c <_vfprintf_r+0x307c>
4200e6f6:	250b      	addi.n	a2, a5, -1
4200e6f8:	140c      	movi.n	a4, 1
4200e6fa:	ff3606        	j	4200e3d6 <_vfprintf_r+0x226>
4200e6fd:	850c      	movi.n	a5, 8
4200e6ff:	000d06        	j	4200e737 <_vfprintf_r+0x587>
4200e702:	aa2182        	l32i	a8, a1, 0x2a8
4200e705:	68a052        	movi	a5, 104
4200e708:	000862        	l8ui	a6, a8, 0
4200e70b:	0a9657        	bne	a6, a5, 4200e719 <_vfprintf_r+0x569>
4200e70e:	881b      	addi.n	a8, a8, 1
4200e710:	aa6182        	s32i	a8, a1, 0x2a8
4200e713:	00a252        	movi	a5, 0x200
4200e716:	000746        	j	4200e737 <_vfprintf_r+0x587>
4200e719:	054c      	movi.n	a5, 64
4200e71b:	000986        	j	4200e745 <_vfprintf_r+0x595>
4200e71e:	aa2152        	l32i	a5, a1, 0x2a8
4200e721:	000562        	l8ui	a6, a5, 0
4200e724:	6ca052        	movi	a5, 108
4200e727:	0a9657        	bne	a6, a5, 4200e735 <_vfprintf_r+0x585>
4200e72a:	aa2162        	l32i	a6, a1, 0x2a8
4200e72d:	661b      	addi.n	a6, a6, 1
4200e72f:	aa6162        	s32i	a6, a1, 0x2a8
4200e732:	000346        	j	4200e743 <_vfprintf_r+0x593>
4200e735:	051c      	movi.n	a5, 16
4200e737:	a02162        	l32i	a6, a1, 0x280
4200e73a:	206650        	or	a6, a6, a5
4200e73d:	a06162        	s32i	a6, a1, 0x280
4200e740:	ff2486        	j	4200e3d6 <_vfprintf_r+0x226>
4200e743:	052c      	movi.n	a5, 32
4200e745:	a02182        	l32i	a8, a1, 0x280
4200e748:	208850        	or	a8, a8, a5
4200e74b:	a06182        	s32i	a8, a1, 0x280
4200e74e:	ff2106        	j	4200e3d6 <_vfprintf_r+0x226>
4200e751:	982152        	l32i	a5, a1, 0x260
4200e754:	d4bc      	beqz.n	a4, 4200e795 <_vfprintf_r+0x5e5>
4200e756:	0ea257        	bge	a2, a5, 4200e768 <_vfprintf_r+0x5b8>
4200e759:	10c1a2        	addi	a10, a1, 16
4200e75c:	b022a0        	addx8	a2, a2, a10
4200e75f:	000222        	l8ui	a2, a2, 0
4200e762:	9f2162        	l32i	a6, a1, 0x27c
4200e765:	002986        	j	4200e80f <_vfprintf_r+0x65f>
4200e768:	5ca2b2        	movi	a11, 0x25c
4200e76b:	10c1e2        	addi	a14, a1, 16
4200e76e:	41ba      	add.n	a4, a1, a11
4200e770:	50a2d2        	movi	a13, 0x250
4200e773:	60a2c2        	movi	a12, 0x260
4200e776:	02ad      	mov.n	a10, a2
4200e778:	0149      	s32i.n	a4, a1, 0
4200e77a:	01def2        	addmi	a15, a14, 0x100
4200e77d:	deda      	add.n	a13, a14, a13
4200e77f:	ceca      	add.n	a12, a14, a12
4200e781:	03bd      	mov.n	a11, a3
4200e783:	b96192        	s32i	a9, a1, 0x2e4
4200e786:	ff5325        	call8	4200dcb8 <get_arg$constprop$0>
4200e789:	000a22        	l8ui	a2, a10, 0
4200e78c:	9f2162        	l32i	a6, a1, 0x27c
4200e78f:	b92192        	l32i	a9, a1, 0x2e4
4200e792:	001e46        	j	4200e80f <_vfprintf_r+0x65f>
4200e795:	9f2132        	l32i	a3, a1, 0x27c
4200e798:	10c142        	addi	a4, a1, 16
4200e79b:	631b      	addi.n	a6, a3, 1
4200e79d:	b02240        	addx8	a2, a2, a4
4200e7a0:	682357        	blt	a3, a5, 4200e80c <_vfprintf_r+0x65c>
4200e7a3:	10c182        	addi	a8, a1, 16
4200e7a6:	9a2872        	l32i	a7, a8, 0x268
4200e7a9:	02d822        	addmi	a2, a8, 0x200
4200e7ac:	f81c      	movi.n	a8, 31
4200e7ae:	374b      	addi.n	a3, a7, 4
4200e7b0:	841c      	movi.n	a4, 24
4200e7b2:	362857        	blt	a8, a5, 4200e7ec <_vfprintf_r+0x63c>
4200e7b5:	851b      	addi.n	a8, a5, 1
4200e7b7:	986182        	s32i	a8, a1, 0x260
4200e7ba:	1a6232        	s32i	a3, a2, 104
4200e7bd:	072437        	blt	a4, a3, 4200e7c8 <_vfprintf_r+0x618>
4200e7c0:	192222        	l32i	a2, a2, 100
4200e7c3:	000306        	j	4200e7d3 <_vfprintf_r+0x623>
4200e7c6:	00          	.byte 00
4200e7c7:	00          	.byte 00
4200e7c8:	012477        	blt	a4, a7, 4200e7cd <_vfprintf_r+0x61d>
4200e7cb:	432c      	movi.n	a3, 36
4200e7cd:	9c2122        	l32i	a2, a1, 0x270
4200e7d0:	9e6132        	s32i	a3, a1, 0x278
4200e7d3:	9e2132        	l32i	a3, a1, 0x278
4200e7d6:	10c1b2        	addi	a11, a1, 16
4200e7d9:	223a      	add.n	a2, a2, a3
4200e7db:	fcc222        	addi	a2, a2, -4
4200e7de:	0228      	l32i.n	a2, a2, 0
4200e7e0:	b055b0        	addx8	a5, a5, a11
4200e7e3:	0529      	s32i.n	a2, a5, 0
4200e7e5:	742020        	extui	a2, a2, 0, 8
4200e7e8:	0008c6        	j	4200e80f <_vfprintf_r+0x65f>
4200e7eb:	00          	.byte 00
4200e7ec:	1a6232        	s32i	a3, a2, 104
4200e7ef:	052437        	blt	a4, a3, 4200e7f8 <_vfprintf_r+0x648>
4200e7f2:	192222        	l32i	a2, a2, 100
4200e7f5:	000286        	j	4200e803 <_vfprintf_r+0x653>
4200e7f8:	012477        	blt	a4, a7, 4200e7fd <_vfprintf_r+0x64d>
4200e7fb:	432c      	movi.n	a3, 36
4200e7fd:	9c2122        	l32i	a2, a1, 0x270
4200e800:	9e6132        	s32i	a3, a1, 0x278
4200e803:	9e2132        	l32i	a3, a1, 0x278
4200e806:	802230        	add	a2, a2, a3
4200e809:	fcc222        	addi	a2, a2, -4
4200e80c:	000222        	l8ui	a2, a2, 0
4200e80f:	10c142        	addi	a4, a1, 16
4200e812:	01d432        	addmi	a3, a4, 0x100
4200e815:	050c      	movi.n	a5, 0
4200e817:	804322        	s8i	a2, a3, 128
4200e81a:	9f6162        	s32i	a6, a1, 0x27c
4200e81d:	02d422        	addmi	a2, a4, 0x200
4200e820:	030c      	movi.n	a3, 0
4200e822:	160c      	movi.n	a6, 1
4200e824:	564232        	s8i	a3, a2, 86
4200e827:	a56152        	s32i	a5, a1, 0x294
4200e82a:	a46162        	s32i	a6, a1, 0x290
4200e82d:	053d      	mov.n	a3, a5
4200e82f:	054d      	mov.n	a4, a5
4200e831:	052d      	mov.n	a2, a5
4200e833:	07b186        	j	420106fd <_vfprintf_r+0x254d>
4200e836:	a02162        	l32i	a6, a1, 0x280
4200e839:	051c      	movi.n	a5, 16
4200e83b:	206650        	or	a6, a6, a5
4200e83e:	a06162        	s32i	a6, a1, 0x280
4200e841:	a02182        	l32i	a8, a1, 0x280
4200e844:	982152        	l32i	a5, a1, 0x260
4200e847:	02e857        	bbsi	a8, 5, 4200e84d <_vfprintf_r+0x69d>
4200e84a:	003286        	j	4200e918 <_vfprintf_r+0x768>
4200e84d:	043416        	beqz	a4, 4200e894 <_vfprintf_r+0x6e4>
4200e850:	10a257        	bge	a2, a5, 4200e864 <_vfprintf_r+0x6b4>
4200e853:	10c1a2        	addi	a10, a1, 16
4200e856:	b022a0        	addx8	a2, a2, a10
4200e859:	0238      	l32i.n	a3, a2, 0
4200e85b:	1248      	l32i.n	a4, a2, 4
4200e85d:	9f2162        	l32i	a6, a1, 0x27c
4200e860:	00dd46        	j	4200ebd9 <_vfprintf_r+0xa29>
4200e863:	00          	.byte 00
4200e864:	5ca2b2        	movi	a11, 0x25c
4200e867:	10c1e2        	addi	a14, a1, 16
4200e86a:	41ba      	add.n	a4, a1, a11
4200e86c:	50a2d2        	movi	a13, 0x250
4200e86f:	60a2c2        	movi	a12, 0x260
4200e872:	0149      	s32i.n	a4, a1, 0
4200e874:	03bd      	mov.n	a11, a3
4200e876:	01def2        	addmi	a15, a14, 0x100
4200e879:	deda      	add.n	a13, a14, a13
4200e87b:	ceca      	add.n	a12, a14, a12
4200e87d:	02ad      	mov.n	a10, a2
4200e87f:	b96192        	s32i	a9, a1, 0x2e4
4200e882:	ff4365        	call8	4200dcb8 <get_arg$constprop$0>
4200e885:	0a38      	l32i.n	a3, a10, 0
4200e887:	1a48      	l32i.n	a4, a10, 4
4200e889:	9f2162        	l32i	a6, a1, 0x27c
4200e88c:	b92192        	l32i	a9, a1, 0x2e4
4200e88f:	00d186        	j	4200ebd9 <_vfprintf_r+0xa29>
4200e892:	00          	.byte 00
4200e893:	00          	.byte 00
4200e894:	9f2132        	l32i	a3, a1, 0x27c
4200e897:	10c142        	addi	a4, a1, 16
4200e89a:	631b      	addi.n	a6, a3, 1
4200e89c:	b02240        	addx8	a2, a2, a4
4200e89f:	6d2357        	blt	a3, a5, 4200e910 <_vfprintf_r+0x760>
4200e8a2:	10c182        	addi	a8, a1, 16
4200e8a5:	9a2842        	l32i	a4, a8, 0x268
4200e8a8:	837c      	movi.n	a3, -8
4200e8aa:	447b      	addi.n	a4, a4, 7
4200e8ac:	02d822        	addmi	a2, a8, 0x200
4200e8af:	104430        	and	a4, a4, a3
4200e8b2:	f81c      	movi.n	a8, 31
4200e8b4:	348b      	addi.n	a3, a4, 8
4200e8b6:	871c      	movi.n	a7, 24
4200e8b8:	342857        	blt	a8, a5, 4200e8f0 <_vfprintf_r+0x740>
4200e8bb:	851b      	addi.n	a8, a5, 1
4200e8bd:	986182        	s32i	a8, a1, 0x260
4200e8c0:	1a6232        	s32i	a3, a2, 104
4200e8c3:	052737        	blt	a7, a3, 4200e8cc <_vfprintf_r+0x71c>
4200e8c6:	192222        	l32i	a2, a2, 100
4200e8c9:	000286        	j	4200e8d7 <_vfprintf_r+0x727>
4200e8cc:	012747        	blt	a7, a4, 4200e8d1 <_vfprintf_r+0x721>
4200e8cf:	832c      	movi.n	a3, 40
4200e8d1:	9c2122        	l32i	a2, a1, 0x270
4200e8d4:	9e6132        	s32i	a3, a1, 0x278
4200e8d7:	9e2132        	l32i	a3, a1, 0x278
4200e8da:	10c1b2        	addi	a11, a1, 16
4200e8dd:	223a      	add.n	a2, a2, a3
4200e8df:	f8c222        	addi	a2, a2, -8
4200e8e2:	0238      	l32i.n	a3, a2, 0
4200e8e4:	1248      	l32i.n	a4, a2, 4
4200e8e6:	b025b0        	addx8	a2, a5, a11
4200e8e9:	0239      	s32i.n	a3, a2, 0
4200e8eb:	1249      	s32i.n	a4, a2, 4
4200e8ed:	00ba06        	j	4200ebd9 <_vfprintf_r+0xa29>
4200e8f0:	1a6232        	s32i	a3, a2, 104
4200e8f3:	052737        	blt	a7, a3, 4200e8fc <_vfprintf_r+0x74c>
4200e8f6:	192222        	l32i	a2, a2, 100
4200e8f9:	000286        	j	4200e907 <_vfprintf_r+0x757>
4200e8fc:	012747        	blt	a7, a4, 4200e901 <_vfprintf_r+0x751>
4200e8ff:	832c      	movi.n	a3, 40
4200e901:	9c2122        	l32i	a2, a1, 0x270
4200e904:	9e6132        	s32i	a3, a1, 0x278
4200e907:	9e2132        	l32i	a3, a1, 0x278
4200e90a:	802230        	add	a2, a2, a3
4200e90d:	f8c222        	addi	a2, a2, -8
4200e910:	0238      	l32i.n	a3, a2, 0
4200e912:	1248      	l32i.n	a4, a2, 4
4200e914:	00b046        	j	4200ebd9 <_vfprintf_r+0xa29>
4200e917:	00          	.byte 00
4200e918:	a02162        	l32i	a6, a1, 0x280
4200e91b:	796647        	bbci	a6, 4, 4200e998 <_vfprintf_r+0x7e8>
4200e91e:	f49c      	beqz.n	a4, 4200e941 <_vfprintf_r+0x791>
4200e920:	08a257        	bge	a2, a5, 4200e92c <_vfprintf_r+0x77c>
4200e923:	10c182        	addi	a8, a1, 16
4200e926:	b02280        	addx8	a2, a2, a8
4200e929:	007fc6        	j	4200eb2c <_vfprintf_r+0x97c>
4200e92c:	5ca2a2        	movi	a10, 0x25c
4200e92f:	10c1b2        	addi	a11, a1, 16
4200e932:	41aa      	add.n	a4, a1, a10
4200e934:	0149      	s32i.n	a4, a1, 0
4200e936:	01dbf2        	addmi	a15, a11, 0x100
4200e939:	50a2d2        	movi	a13, 0x250
4200e93c:	0bed      	mov.n	a14, a11
4200e93e:	008146        	j	4200eb47 <_vfprintf_r+0x997>
4200e941:	9f2132        	l32i	a3, a1, 0x27c
4200e944:	10c142        	addi	a4, a1, 16
4200e947:	631b      	addi.n	a6, a3, 1
4200e949:	b02240        	addx8	a2, a2, a4
4200e94c:	02a357        	bge	a3, a5, 4200e952 <_vfprintf_r+0x7a2>
4200e94f:	00a046        	j	4200ebd4 <_vfprintf_r+0xa24>
4200e952:	10c182        	addi	a8, a1, 16
4200e955:	9a2872        	l32i	a7, a8, 0x268
4200e958:	02d822        	addmi	a2, a8, 0x200
4200e95b:	f81c      	movi.n	a8, 31
4200e95d:	374b      	addi.n	a3, a7, 4
4200e95f:	841c      	movi.n	a4, 24
4200e961:	02a857        	bge	a8, a5, 4200e967 <_vfprintf_r+0x7b7>
4200e964:	009346        	j	4200ebb5 <_vfprintf_r+0xa05>
4200e967:	851b      	addi.n	a8, a5, 1
4200e969:	986182        	s32i	a8, a1, 0x260
4200e96c:	1a6232        	s32i	a3, a2, 104
4200e96f:	052437        	blt	a4, a3, 4200e978 <_vfprintf_r+0x7c8>
4200e972:	192222        	l32i	a2, a2, 100
4200e975:	000286        	j	4200e983 <_vfprintf_r+0x7d3>
4200e978:	012477        	blt	a4, a7, 4200e97d <_vfprintf_r+0x7cd>
4200e97b:	432c      	movi.n	a3, 36
4200e97d:	9c2122        	l32i	a2, a1, 0x270
4200e980:	9e6132        	s32i	a3, a1, 0x278
4200e983:	9e2132        	l32i	a3, a1, 0x278
4200e986:	10c1b2        	addi	a11, a1, 16
4200e989:	223a      	add.n	a2, a2, a3
4200e98b:	fcc222        	addi	a2, a2, -4
4200e98e:	0238      	l32i.n	a3, a2, 0
4200e990:	b025b0        	addx8	a2, a5, a11
4200e993:	0239      	s32i.n	a3, a2, 0
4200e995:	008f46        	j	4200ebd6 <_vfprintf_r+0xa26>
4200e998:	a02162        	l32i	a6, a1, 0x280
4200e99b:	02e667        	bbsi	a6, 6, 4200e9a1 <_vfprintf_r+0x7f1>
4200e99e:	002d86        	j	4200ea58 <_vfprintf_r+0x8a8>
4200e9a1:	74bc      	beqz.n	a4, 4200e9dc <_vfprintf_r+0x82c>
4200e9a3:	0ba257        	bge	a2, a5, 4200e9b2 <_vfprintf_r+0x802>
4200e9a6:	10c182        	addi	a8, a1, 16
4200e9a9:	b02280        	addx8	a2, a2, a8
4200e9ac:	009232        	l16si	a3, a2, 0
4200e9af:	005ec6        	j	4200eb2e <_vfprintf_r+0x97e>
4200e9b2:	5ca2a2        	movi	a10, 0x25c
4200e9b5:	10c1b2        	addi	a11, a1, 16
4200e9b8:	41aa      	add.n	a4, a1, a10
4200e9ba:	50a2d2        	movi	a13, 0x250
4200e9bd:	60a2c2        	movi	a12, 0x260
4200e9c0:	01dbf2        	addmi	a15, a11, 0x100
4200e9c3:	0bed      	mov.n	a14, a11
4200e9c5:	dbda      	add.n	a13, a11, a13
4200e9c7:	cbca      	add.n	a12, a11, a12
4200e9c9:	0149      	s32i.n	a4, a1, 0
4200e9cb:	03bd      	mov.n	a11, a3
4200e9cd:	02ad      	mov.n	a10, a2
4200e9cf:	b96192        	s32i	a9, a1, 0x2e4
4200e9d2:	ff2e65        	call8	4200dcb8 <get_arg$constprop$0>
4200e9d5:	009a32        	l16si	a3, a10, 0
4200e9d8:	005f86        	j	4200eb5a <_vfprintf_r+0x9aa>
4200e9db:	00          	.byte 00
4200e9dc:	9f2132        	l32i	a3, a1, 0x27c
4200e9df:	10c142        	addi	a4, a1, 16
4200e9e2:	631b      	addi.n	a6, a3, 1
4200e9e4:	b02240        	addx8	a2, a2, a4
4200e9e7:	652357        	blt	a3, a5, 4200ea50 <_vfprintf_r+0x8a0>
4200e9ea:	10c182        	addi	a8, a1, 16
4200e9ed:	9a2872        	l32i	a7, a8, 0x268
4200e9f0:	02d822        	addmi	a2, a8, 0x200
4200e9f3:	f81c      	movi.n	a8, 31
4200e9f5:	374b      	addi.n	a3, a7, 4
4200e9f7:	841c      	movi.n	a4, 24
4200e9f9:	332857        	blt	a8, a5, 4200ea30 <_vfprintf_r+0x880>
4200e9fc:	851b      	addi.n	a8, a5, 1
4200e9fe:	986182        	s32i	a8, a1, 0x260
4200ea01:	1a6232        	s32i	a3, a2, 104
4200ea04:	052437        	blt	a4, a3, 4200ea0d <_vfprintf_r+0x85d>
4200ea07:	192222        	l32i	a2, a2, 100
4200ea0a:	000286        	j	4200ea18 <_vfprintf_r+0x868>
4200ea0d:	012477        	blt	a4, a7, 4200ea12 <_vfprintf_r+0x862>
4200ea10:	432c      	movi.n	a3, 36
4200ea12:	9c2122        	l32i	a2, a1, 0x270
4200ea15:	9e6132        	s32i	a3, a1, 0x278
4200ea18:	9e2132        	l32i	a3, a1, 0x278
4200ea1b:	10c1b2        	addi	a11, a1, 16
4200ea1e:	223a      	add.n	a2, a2, a3
4200ea20:	fcc222        	addi	a2, a2, -4
4200ea23:	0238      	l32i.n	a3, a2, 0
4200ea25:	b025b0        	addx8	a2, a5, a11
4200ea28:	0239      	s32i.n	a3, a2, 0
4200ea2a:	233380        	sext	a3, a3, 15
4200ea2d:	006946        	j	4200ebd6 <_vfprintf_r+0xa26>
4200ea30:	1a6232        	s32i	a3, a2, 104
4200ea33:	052437        	blt	a4, a3, 4200ea3c <_vfprintf_r+0x88c>
4200ea36:	192222        	l32i	a2, a2, 100
4200ea39:	000286        	j	4200ea47 <_vfprintf_r+0x897>
4200ea3c:	012477        	blt	a4, a7, 4200ea41 <_vfprintf_r+0x891>
4200ea3f:	432c      	movi.n	a3, 36
4200ea41:	9c2122        	l32i	a2, a1, 0x270
4200ea44:	9e6132        	s32i	a3, a1, 0x278
4200ea47:	9e2132        	l32i	a3, a1, 0x278
4200ea4a:	802230        	add	a2, a2, a3
4200ea4d:	fcc222        	addi	a2, a2, -4
4200ea50:	009232        	l16si	a3, a2, 0
4200ea53:	005fc6        	j	4200ebd6 <_vfprintf_r+0xa26>
4200ea56:	00          	.byte 00
4200ea57:	00          	.byte 00
4200ea58:	a02162        	l32i	a6, a1, 0x280
4200ea5b:	02e697        	bbsi	a6, 9, 4200ea61 <_vfprintf_r+0x8b1>
4200ea5e:	002fc6        	j	4200eb21 <_vfprintf_r+0x971>
4200ea61:	f4bc      	beqz.n	a4, 4200eaa4 <_vfprintf_r+0x8f4>
4200ea63:	0ea257        	bge	a2, a5, 4200ea75 <_vfprintf_r+0x8c5>
4200ea66:	10c182        	addi	a8, a1, 16
4200ea69:	b02280        	addx8	a2, a2, a8
4200ea6c:	000232        	l8ui	a3, a2, 0
4200ea6f:	9f2162        	l32i	a6, a1, 0x27c
4200ea72:	002946        	j	4200eb1b <_vfprintf_r+0x96b>
4200ea75:	5ca2a2        	movi	a10, 0x25c
4200ea78:	10c1b2        	addi	a11, a1, 16
4200ea7b:	41aa      	add.n	a4, a1, a10
4200ea7d:	50a2d2        	movi	a13, 0x250
4200ea80:	60a2c2        	movi	a12, 0x260
4200ea83:	01dbf2        	addmi	a15, a11, 0x100
4200ea86:	0bed      	mov.n	a14, a11
4200ea88:	dbda      	add.n	a13, a11, a13
4200ea8a:	cbca      	add.n	a12, a11, a12
4200ea8c:	0149      	s32i.n	a4, a1, 0
4200ea8e:	03bd      	mov.n	a11, a3
4200ea90:	02ad      	mov.n	a10, a2
4200ea92:	b96192        	s32i	a9, a1, 0x2e4
4200ea95:	ff2225        	call8	4200dcb8 <get_arg$constprop$0>
4200ea98:	000a32        	l8ui	a3, a10, 0
4200ea9b:	9f2162        	l32i	a6, a1, 0x27c
4200ea9e:	b92192        	l32i	a9, a1, 0x2e4
4200eaa1:	001d86        	j	4200eb1b <_vfprintf_r+0x96b>
4200eaa4:	9f2132        	l32i	a3, a1, 0x27c
4200eaa7:	10c142        	addi	a4, a1, 16
4200eaaa:	631b      	addi.n	a6, a3, 1
4200eaac:	b02240        	addx8	a2, a2, a4
4200eaaf:	652357        	blt	a3, a5, 4200eb18 <_vfprintf_r+0x968>
4200eab2:	10c182        	addi	a8, a1, 16
4200eab5:	9a2872        	l32i	a7, a8, 0x268
4200eab8:	02d822        	addmi	a2, a8, 0x200
4200eabb:	f81c      	movi.n	a8, 31
4200eabd:	374b      	addi.n	a3, a7, 4
4200eabf:	841c      	movi.n	a4, 24
4200eac1:	332857        	blt	a8, a5, 4200eaf8 <_vfprintf_r+0x948>
4200eac4:	851b      	addi.n	a8, a5, 1
4200eac6:	986182        	s32i	a8, a1, 0x260
4200eac9:	1a6232        	s32i	a3, a2, 104
4200eacc:	052437        	blt	a4, a3, 4200ead5 <_vfprintf_r+0x925>
4200eacf:	192222        	l32i	a2, a2, 100
4200ead2:	000286        	j	4200eae0 <_vfprintf_r+0x930>
4200ead5:	012477        	blt	a4, a7, 4200eada <_vfprintf_r+0x92a>
4200ead8:	432c      	movi.n	a3, 36
4200eada:	9c2122        	l32i	a2, a1, 0x270
4200eadd:	9e6132        	s32i	a3, a1, 0x278
4200eae0:	9e2132        	l32i	a3, a1, 0x278
4200eae3:	10c1b2        	addi	a11, a1, 16
4200eae6:	223a      	add.n	a2, a2, a3
4200eae8:	fcc222        	addi	a2, a2, -4
4200eaeb:	0238      	l32i.n	a3, a2, 0
4200eaed:	b025b0        	addx8	a2, a5, a11
4200eaf0:	0239      	s32i.n	a3, a2, 0
4200eaf2:	743030        	extui	a3, a3, 0, 8
4200eaf5:	000886        	j	4200eb1b <_vfprintf_r+0x96b>
4200eaf8:	1a6232        	s32i	a3, a2, 104
4200eafb:	052437        	blt	a4, a3, 4200eb04 <_vfprintf_r+0x954>
4200eafe:	192222        	l32i	a2, a2, 100
4200eb01:	000286        	j	4200eb0f <_vfprintf_r+0x95f>
4200eb04:	012477        	blt	a4, a7, 4200eb09 <_vfprintf_r+0x959>
4200eb07:	432c      	movi.n	a3, 36
4200eb09:	9c2122        	l32i	a2, a1, 0x270
4200eb0c:	9e6132        	s32i	a3, a1, 0x278
4200eb0f:	9e2132        	l32i	a3, a1, 0x278
4200eb12:	802230        	add	a2, a2, a3
4200eb15:	fcc222        	addi	a2, a2, -4
4200eb18:	000232        	l8ui	a3, a2, 0
4200eb1b:	233300        	sext	a3, a3, 7
4200eb1e:	002d06        	j	4200ebd6 <_vfprintf_r+0xa26>
4200eb21:	f4bc      	beqz.n	a4, 4200eb64 <_vfprintf_r+0x9b4>
4200eb23:	0ea257        	bge	a2, a5, 4200eb35 <_vfprintf_r+0x985>
4200eb26:	10c132        	addi	a3, a1, 16
4200eb29:	b02230        	addx8	a2, a2, a3
4200eb2c:	0238      	l32i.n	a3, a2, 0
4200eb2e:	9f2162        	l32i	a6, a1, 0x27c
4200eb31:	002846        	j	4200ebd6 <_vfprintf_r+0xa26>
4200eb34:	00          	.byte 00
4200eb35:	5ca252        	movi	a5, 0x25c
4200eb38:	10c162        	addi	a6, a1, 16
4200eb3b:	415a      	add.n	a4, a1, a5
4200eb3d:	0149      	s32i.n	a4, a1, 0
4200eb3f:	01d6f2        	addmi	a15, a6, 0x100
4200eb42:	50a2d2        	movi	a13, 0x250
4200eb45:	06ed      	mov.n	a14, a6
4200eb47:	60a2c2        	movi	a12, 0x260
4200eb4a:	03bd      	mov.n	a11, a3
4200eb4c:	deda      	add.n	a13, a14, a13
4200eb4e:	ceca      	add.n	a12, a14, a12
4200eb50:	02ad      	mov.n	a10, a2
4200eb52:	b96192        	s32i	a9, a1, 0x2e4
4200eb55:	ff1625        	call8	4200dcb8 <get_arg$constprop$0>
4200eb58:	0a38      	l32i.n	a3, a10, 0
4200eb5a:	9f2162        	l32i	a6, a1, 0x27c
4200eb5d:	b92192        	l32i	a9, a1, 0x2e4
4200eb60:	001c86        	j	4200ebd6 <_vfprintf_r+0xa26>
4200eb63:	00          	.byte 00
4200eb64:	9f2182        	l32i	a8, a1, 0x27c
4200eb67:	10c1a2        	addi	a10, a1, 16
4200eb6a:	681b      	addi.n	a6, a8, 1
4200eb6c:	b022a0        	addx8	a2, a2, a10
4200eb6f:	612857        	blt	a8, a5, 4200ebd4 <_vfprintf_r+0xa24>
4200eb72:	10c1b2        	addi	a11, a1, 16
4200eb75:	9a2b72        	l32i	a7, a11, 0x268
4200eb78:	f81c      	movi.n	a8, 31
4200eb7a:	02db22        	addmi	a2, a11, 0x200
4200eb7d:	374b      	addi.n	a3, a7, 4
4200eb7f:	841c      	movi.n	a4, 24
4200eb81:	302857        	blt	a8, a5, 4200ebb5 <_vfprintf_r+0xa05>
4200eb84:	851b      	addi.n	a8, a5, 1
4200eb86:	986182        	s32i	a8, a1, 0x260
4200eb89:	1a6232        	s32i	a3, a2, 104
4200eb8c:	052437        	blt	a4, a3, 4200eb95 <_vfprintf_r+0x9e5>
4200eb8f:	192222        	l32i	a2, a2, 100
4200eb92:	000286        	j	4200eba0 <_vfprintf_r+0x9f0>
4200eb95:	012477        	blt	a4, a7, 4200eb9a <_vfprintf_r+0x9ea>
4200eb98:	432c      	movi.n	a3, 36
4200eb9a:	9c2122        	l32i	a2, a1, 0x270
4200eb9d:	9e6132        	s32i	a3, a1, 0x278
4200eba0:	9e2132        	l32i	a3, a1, 0x278
4200eba3:	223a      	add.n	a2, a2, a3
4200eba5:	fcc222        	addi	a2, a2, -4
4200eba8:	0238      	l32i.n	a3, a2, 0
4200ebaa:	10c122        	addi	a2, a1, 16
4200ebad:	b05520        	addx8	a5, a5, a2
4200ebb0:	0539      	s32i.n	a3, a5, 0
4200ebb2:	000806        	j	4200ebd6 <_vfprintf_r+0xa26>
4200ebb5:	1a6232        	s32i	a3, a2, 104
4200ebb8:	052437        	blt	a4, a3, 4200ebc1 <_vfprintf_r+0xa11>
4200ebbb:	192222        	l32i	a2, a2, 100
4200ebbe:	000286        	j	4200ebcc <_vfprintf_r+0xa1c>
4200ebc1:	012477        	blt	a4, a7, 4200ebc6 <_vfprintf_r+0xa16>
4200ebc4:	432c      	movi.n	a3, 36
4200ebc6:	9c2122        	l32i	a2, a1, 0x270
4200ebc9:	9e6132        	s32i	a3, a1, 0x278
4200ebcc:	9e2132        	l32i	a3, a1, 0x278
4200ebcf:	223a      	add.n	a2, a2, a3
4200ebd1:	fcc222        	addi	a2, a2, -4
4200ebd4:	0238      	l32i.n	a3, a2, 0
4200ebd6:	314f30        	srai	a4, a3, 31
4200ebd9:	9f6162        	s32i	a6, a1, 0x27c
4200ebdc:	002496        	bltz	a4, 4200ebe2 <_vfprintf_r+0xa32>
4200ebdf:	09aa86        	j	4201128d <_vfprintf_r+0x30dd>
4200ebe2:	603030        	neg	a3, a3
4200ebe5:	120c      	movi.n	a2, 1
4200ebe7:	050c      	movi.n	a5, 0
4200ebe9:	935230        	movnez	a5, a2, a3
4200ebec:	604040        	neg	a4, a4
4200ebef:	c04450        	sub	a4, a4, a5
4200ebf2:	d62c      	movi.n	a6, 45
4200ebf4:	0633c6        	j	420104c7 <_vfprintf_r+0x2317>
4200ebf7:	a02162        	l32i	a6, a1, 0x280
4200ebfa:	982152        	l32i	a5, a1, 0x260
4200ebfd:	786637        	bbci	a6, 3, 4200ec79 <_vfprintf_r+0xac9>
4200ec00:	d48c      	beqz.n	a4, 4200ec11 <_vfprintf_r+0xa61>
4200ec02:	022257        	blt	a2, a5, 4200ec08 <_vfprintf_r+0xa58>
4200ec05:	002246        	j	4200ec92 <_vfprintf_r+0xae2>
4200ec08:	10c182        	addi	a8, a1, 16
4200ec0b:	b02280        	addx8	a2, a2, a8
4200ec0e:	001cc6        	j	4200ec85 <_vfprintf_r+0xad5>
4200ec11:	9f2132        	l32i	a3, a1, 0x27c
4200ec14:	731b      	addi.n	a7, a3, 1
4200ec16:	02a357        	bge	a3, a5, 4200ec1c <_vfprintf_r+0xa6c>
4200ec19:	002c06        	j	4200eccd <_vfprintf_r+0xb1d>
4200ec1c:	10c162        	addi	a6, a1, 16
4200ec1f:	9a2642        	l32i	a4, a6, 0x268
4200ec22:	837c      	movi.n	a3, -8
4200ec24:	447b      	addi.n	a4, a4, 7
4200ec26:	104430        	and	a4, a4, a3
4200ec29:	f81c      	movi.n	a8, 31
4200ec2b:	02d622        	addmi	a2, a6, 0x200
4200ec2e:	348b      	addi.n	a3, a4, 8
4200ec30:	861c      	movi.n	a6, 24
4200ec32:	02a857        	bge	a8, a5, 4200ec38 <_vfprintf_r+0xa88>
4200ec35:	003ec6        	j	4200ed34 <_vfprintf_r+0xb84>
4200ec38:	851b      	addi.n	a8, a5, 1
4200ec3a:	986182        	s32i	a8, a1, 0x260
4200ec3d:	1a6232        	s32i	a3, a2, 104
4200ec40:	052637        	blt	a6, a3, 4200ec49 <_vfprintf_r+0xa99>
4200ec43:	192222        	l32i	a2, a2, 100
4200ec46:	000286        	j	4200ec54 <_vfprintf_r+0xaa4>
4200ec49:	012647        	blt	a6, a4, 4200ec4e <_vfprintf_r+0xa9e>
4200ec4c:	832c      	movi.n	a3, 40
4200ec4e:	9c2122        	l32i	a2, a1, 0x270
4200ec51:	9e6132        	s32i	a3, a1, 0x278
4200ec54:	9e2132        	l32i	a3, a1, 0x278
4200ec57:	223a      	add.n	a2, a2, a3
4200ec59:	f8c222        	addi	a2, a2, -8
4200ec5c:	12b8      	l32i.n	a11, a2, 4
4200ec5e:	02a8      	l32i.n	a10, a2, 0
4200ec60:	a961b2        	s32i	a11, a1, 0x2a4
4200ec63:	a861a2        	s32i	a10, a1, 0x2a0
4200ec66:	10c1b2        	addi	a11, a1, 16
4200ec69:	b025b0        	addx8	a2, a5, a11
4200ec6c:	a82142        	l32i	a4, a1, 0x2a0
4200ec6f:	a92152        	l32i	a5, a1, 0x2a4
4200ec72:	0249      	s32i.n	a4, a2, 0
4200ec74:	1259      	s32i.n	a5, a2, 4
4200ec76:	0038c6        	j	4200ed5d <_vfprintf_r+0xbad>
4200ec79:	048416        	beqz	a4, 4200ecc5 <_vfprintf_r+0xb15>
4200ec7c:	12a257        	bge	a2, a5, 4200ec92 <_vfprintf_r+0xae2>
4200ec7f:	10c152        	addi	a5, a1, 16
4200ec82:	b02250        	addx8	a2, a2, a5
4200ec85:	0248      	l32i.n	a4, a2, 0
4200ec87:	1258      	l32i.n	a5, a2, 4
4200ec89:	a86142        	s32i	a4, a1, 0x2a0
4200ec8c:	a96152        	s32i	a5, a1, 0x2a4
4200ec8f:	003346        	j	4200ed60 <_vfprintf_r+0xbb0>
4200ec92:	5ca252        	movi	a5, 0x25c
4200ec95:	10c162        	addi	a6, a1, 16
4200ec98:	415a      	add.n	a4, a1, a5
4200ec9a:	50a2d2        	movi	a13, 0x250
4200ec9d:	60a2c2        	movi	a12, 0x260
4200eca0:	03bd      	mov.n	a11, a3
4200eca2:	02ad      	mov.n	a10, a2
4200eca4:	0149      	s32i.n	a4, a1, 0
4200eca6:	01d6f2        	addmi	a15, a6, 0x100
4200eca9:	06ed      	mov.n	a14, a6
4200ecab:	d6da      	add.n	a13, a6, a13
4200ecad:	c6ca      	add.n	a12, a6, a12
4200ecaf:	b96192        	s32i	a9, a1, 0x2e4
4200ecb2:	ff0065        	call8	4200dcb8 <get_arg$constprop$0>
4200ecb5:	0a28      	l32i.n	a2, a10, 0
4200ecb7:	1a38      	l32i.n	a3, a10, 4
4200ecb9:	b92192        	l32i	a9, a1, 0x2e4
4200ecbc:	a86122        	s32i	a2, a1, 0x2a0
4200ecbf:	a96132        	s32i	a3, a1, 0x2a4
4200ecc2:	002686        	j	4200ed60 <_vfprintf_r+0xbb0>
4200ecc5:	9f2132        	l32i	a3, a1, 0x27c
4200ecc8:	731b      	addi.n	a7, a3, 1
4200ecca:	0aa357        	bge	a3, a5, 4200ecd8 <_vfprintf_r+0xb28>
4200eccd:	10c142        	addi	a4, a1, 16
4200ecd0:	b02240        	addx8	a2, a2, a4
4200ecd3:	001f06        	j	4200ed53 <_vfprintf_r+0xba3>
4200ecd6:	00          	.byte 00
4200ecd7:	00          	.byte 00
4200ecd8:	10c162        	addi	a6, a1, 16
4200ecdb:	9a2642        	l32i	a4, a6, 0x268
4200ecde:	837c      	movi.n	a3, -8
4200ece0:	447b      	addi.n	a4, a4, 7
4200ece2:	104430        	and	a4, a4, a3
4200ece5:	f81c      	movi.n	a8, 31
4200ece7:	02d622        	addmi	a2, a6, 0x200
4200ecea:	348b      	addi.n	a3, a4, 8
4200ecec:	861c      	movi.n	a6, 24
4200ecee:	422857        	blt	a8, a5, 4200ed34 <_vfprintf_r+0xb84>
4200ecf1:	851b      	addi.n	a8, a5, 1
4200ecf3:	986182        	s32i	a8, a1, 0x260
4200ecf6:	1a6232        	s32i	a3, a2, 104
4200ecf9:	072637        	blt	a6, a3, 4200ed04 <_vfprintf_r+0xb54>
4200ecfc:	192222        	l32i	a2, a2, 100
4200ecff:	000306        	j	4200ed0f <_vfprintf_r+0xb5f>
4200ed02:	00          	.byte 00
4200ed03:	00          	.byte 00
4200ed04:	012647        	blt	a6, a4, 4200ed09 <_vfprintf_r+0xb59>
4200ed07:	832c      	movi.n	a3, 40
4200ed09:	9c2122        	l32i	a2, a1, 0x270
4200ed0c:	9e6132        	s32i	a3, a1, 0x278
4200ed0f:	9e2132        	l32i	a3, a1, 0x278
4200ed12:	223a      	add.n	a2, a2, a3
4200ed14:	f8c222        	addi	a2, a2, -8
4200ed17:	12b8      	l32i.n	a11, a2, 4
4200ed19:	02a8      	l32i.n	a10, a2, 0
4200ed1b:	a961b2        	s32i	a11, a1, 0x2a4
4200ed1e:	a861a2        	s32i	a10, a1, 0x2a0
4200ed21:	a82122        	l32i	a2, a1, 0x2a0
4200ed24:	a92132        	l32i	a3, a1, 0x2a4
4200ed27:	10c1b2        	addi	a11, a1, 16
4200ed2a:	b055b0        	addx8	a5, a5, a11
4200ed2d:	0529      	s32i.n	a2, a5, 0
4200ed2f:	1539      	s32i.n	a3, a5, 4
4200ed31:	000a06        	j	4200ed5d <_vfprintf_r+0xbad>
4200ed34:	1a6232        	s32i	a3, a2, 104
4200ed37:	052637        	blt	a6, a3, 4200ed40 <_vfprintf_r+0xb90>
4200ed3a:	192222        	l32i	a2, a2, 100
4200ed3d:	000286        	j	4200ed4b <_vfprintf_r+0xb9b>
4200ed40:	012647        	blt	a6, a4, 4200ed45 <_vfprintf_r+0xb95>
4200ed43:	832c      	movi.n	a3, 40
4200ed45:	9c2122        	l32i	a2, a1, 0x270
4200ed48:	9e6132        	s32i	a3, a1, 0x278
4200ed4b:	9e2132        	l32i	a3, a1, 0x278
4200ed4e:	223a      	add.n	a2, a2, a3
4200ed50:	f8c222        	addi	a2, a2, -8
4200ed53:	0248      	l32i.n	a4, a2, 0
4200ed55:	1258      	l32i.n	a5, a2, 4
4200ed57:	a86142        	s32i	a4, a1, 0x2a0
4200ed5a:	a96152        	s32i	a5, a1, 0x2a4
4200ed5d:	9f6172        	s32i	a7, a1, 0x27c
4200ed60:	c59c41        	l32r	a4, 420003d0 <_stext+0x3b0>
4200ed63:	a92162        	l32i	a6, a1, 0x2a4
4200ed66:	a82152        	l32i	a5, a1, 0x2a0
4200ed69:	c79b21        	l32r	a2, 42000bd8 <_stext+0xbb8>
4200ed6c:	c79c31        	l32r	a3, 42000bdc <_stext+0xbbc>
4200ed6f:	104640        	and	a4, a6, a4
4200ed72:	02cd      	mov.n	a12, a2
4200ed74:	03dd      	mov.n	a13, a3
4200ed76:	05ad      	mov.n	a10, a5
4200ed78:	20b440        	or	a11, a4, a4
4200ed7b:	b96192        	s32i	a9, a1, 0x2e4
4200ed7e:	c79e81        	l32r	a8, 42000bf8 <_stext+0xbd8>
4200ed81:	0008e0        	callx8	a8
4200ed84:	b92192        	l32i	a9, a1, 0x2e4
4200ed87:	eaec      	bnez.n	a10, 4200edb9 <_vfprintf_r+0xc09>
4200ed89:	02cd      	mov.n	a12, a2
4200ed8b:	03dd      	mov.n	a13, a3
4200ed8d:	05ad      	mov.n	a10, a5
4200ed8f:	20b440        	or	a11, a4, a4
4200ed92:	c79a81        	l32r	a8, 42000bfc <_stext+0xbdc>
4200ed95:	0008e0        	callx8	a8
4200ed98:	b92192        	l32i	a9, a1, 0x2e4
4200ed9b:	1a1aa6        	blti	a10, 1, 4200edb9 <_vfprintf_r+0xc09>
4200ed9e:	c694c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200eda1:	c693d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200eda4:	a821a2        	l32i	a10, a1, 0x2a0
4200eda7:	a921b2        	l32i	a11, a1, 0x2a4
4200edaa:	c79581        	l32r	a8, 42000c00 <_stext+0xbe0>
4200edad:	0008e0        	callx8	a8
4200edb0:	b92192        	l32i	a9, a1, 0x2e4
4200edb3:	029ad6        	bgez	a10, 4200ede0 <_vfprintf_r+0xc30>
4200edb6:	0006c6        	j	4200edd5 <_vfprintf_r+0xc25>
4200edb9:	a821c2        	l32i	a12, a1, 0x2a0
4200edbc:	a921d2        	l32i	a13, a1, 0x2a4
4200edbf:	0cad      	mov.n	a10, a12
4200edc1:	0dbd      	mov.n	a11, a13
4200edc3:	b96192        	s32i	a9, a1, 0x2e4
4200edc6:	c78c81        	l32r	a8, 42000bf8 <_stext+0xbd8>
4200edc9:	0008e0        	callx8	a8
4200edcc:	b92192        	l32i	a9, a1, 0x2e4
4200edcf:	065a16        	beqz	a10, 4200ee38 <_vfprintf_r+0xc88>
4200edd2:	000786        	j	4200edf4 <_vfprintf_r+0xc44>
4200edd5:	10c182        	addi	a8, a1, 16
4200edd8:	02d822        	addmi	a2, a8, 0x200
4200eddb:	d32c      	movi.n	a3, 45
4200eddd:	564232        	s8i	a3, a2, 86
4200ede0:	c79331        	l32r	a3, 42000c2c <_stext+0xc0c>
4200ede3:	a72142        	l32i	a4, a1, 0x29c
4200ede6:	724c      	movi.n	a2, 71
4200ede8:	a26132        	s32i	a3, a1, 0x288
4200edeb:	c79181        	l32r	a8, 42000c30 <_stext+0xc10>
4200edee:	242247        	blt	a2, a4, 4200ee16 <_vfprintf_r+0xc66>
4200edf1:	000906        	j	4200ee19 <_vfprintf_r+0xc69>
4200edf4:	a92162        	l32i	a6, a1, 0x2a4
4200edf7:	00a6d6        	bgez	a6, 4200ee05 <_vfprintf_r+0xc55>
4200edfa:	10c182        	addi	a8, a1, 16
4200edfd:	02d822        	addmi	a2, a8, 0x200
4200ee00:	d32c      	movi.n	a3, 45
4200ee02:	564232        	s8i	a3, a2, 86
4200ee05:	c78b31        	l32r	a3, 42000c34 <_stext+0xc14>
4200ee08:	a72142        	l32i	a4, a1, 0x29c
4200ee0b:	724c      	movi.n	a2, 71
4200ee0d:	a26132        	s32i	a3, a1, 0x288
4200ee10:	05a247        	bge	a2, a4, 4200ee19 <_vfprintf_r+0xc69>
4200ee13:	c78981        	l32r	a8, 42000c38 <_stext+0xc18>
4200ee16:	a26182        	s32i	a8, a1, 0x288
4200ee19:	a02132        	l32i	a3, a1, 0x280
4200ee1c:	7faf22        	movi	a2, -129
4200ee1f:	040c      	movi.n	a4, 0
4200ee21:	103320        	and	a3, a3, a2
4200ee24:	350c      	movi.n	a5, 3
4200ee26:	a06132        	s32i	a3, a1, 0x280
4200ee29:	a46152        	s32i	a5, a1, 0x290
4200ee2c:	a56142        	s32i	a4, a1, 0x294
4200ee2f:	045d      	mov.n	a5, a4
4200ee31:	043d      	mov.n	a3, a4
4200ee33:	0635c6        	j	4201070e <_vfprintf_r+0x255e>
4200ee36:	00          	.byte 00
4200ee37:	00          	.byte 00
4200ee38:	a72162        	l32i	a6, a1, 0x29c
4200ee3b:	dfaf22        	movi	a2, -33
4200ee3e:	107620        	and	a7, a6, a2
4200ee41:	124c      	movi.n	a2, 65
4200ee43:	559727        	bne	a7, a2, 4200ee9c <_vfprintf_r+0xcec>
4200ee46:	10c182        	addi	a8, a1, 16
4200ee49:	02d842        	addmi	a4, a8, 0x200
4200ee4c:	023c      	movi.n	a2, 48
4200ee4e:	544422        	s8i	a2, a4, 84
4200ee51:	9fc632        	addi	a3, a6, -97
4200ee54:	78a022        	movi	a2, 120
4200ee57:	855c      	movi.n	a5, 88
4200ee59:	932530        	movnez	a2, a5, a3
4200ee5c:	a02132        	l32i	a3, a1, 0x280
4200ee5f:	554422        	s8i	a2, a4, 85
4200ee62:	220c      	movi.n	a2, 2
4200ee64:	203320        	or	a3, a3, a2
4200ee67:	a42142        	l32i	a4, a1, 0x290
4200ee6a:	a06132        	s32i	a3, a1, 0x280
4200ee6d:	63a022        	movi	a2, 99
4200ee70:	52a247        	bge	a2, a4, 4200eec6 <_vfprintf_r+0xd16>
4200ee73:	a321a2        	l32i	a10, a1, 0x28c
4200ee76:	b41b      	addi.n	a11, a4, 1
4200ee78:	b96192        	s32i	a9, a1, 0x2e4
4200ee7b:	c73681        	l32r	a8, 42000b54 <_stext+0xb34>
4200ee7e:	0008e0        	callx8	a8
4200ee81:	a261a2        	s32i	a10, a1, 0x288
4200ee84:	b92192        	l32i	a9, a1, 0x2e4
4200ee87:	049a56        	bnez	a10, 4200eed4 <_vfprintf_r+0xd24>
4200ee8a:	a12182        	l32i	a8, a1, 0x284
4200ee8d:	034c      	movi.n	a3, 64
4200ee8f:	061822        	l16ui	a2, a8, 12
4200ee92:	202230        	or	a2, a2, a3
4200ee95:	065822        	s16i	a2, a8, 12
4200ee98:	08e406        	j	4201122c <_vfprintf_r+0x307c>
4200ee9b:	00          	.byte 00
4200ee9c:	a42122        	l32i	a2, a1, 0x290
4200ee9f:	3a0226        	beqi	a2, -1, 4200eedd <_vfprintf_r+0xd2d>
4200eea2:	a42142        	l32i	a4, a1, 0x290
4200eea5:	130c      	movi.n	a3, 1
4200eea7:	0a2d      	mov.n	a2, a10
4200eea9:	832340        	moveqz	a2, a3, a4
4200eeac:	742020        	extui	a2, a2, 0, 8
4200eeaf:	b28c      	beqz.n	a2, 4200eebe <_vfprintf_r+0xd0e>
4200eeb1:	b9c742        	addi	a4, a7, -71
4200eeb4:	0a2d      	mov.n	a2, a10
4200eeb6:	832340        	moveqz	a2, a3, a4
4200eeb9:	742020        	extui	a2, a2, 0, 8
4200eebc:	52ec      	bnez.n	a2, 4200eee5 <_vfprintf_r+0xd35>
4200eebe:	050c      	movi.n	a5, 0
4200eec0:	a56152        	s32i	a5, a1, 0x294
4200eec3:	000906        	j	4200eeeb <_vfprintf_r+0xd3b>
4200eec6:	90a182        	movi	a8, 0x190
4200eec9:	818a      	add.n	a8, a1, a8
4200eecb:	a561a2        	s32i	a10, a1, 0x294
4200eece:	a26182        	s32i	a8, a1, 0x288
4200eed1:	000586        	j	4200eeeb <_vfprintf_r+0xd3b>
4200eed4:	a22122        	l32i	a2, a1, 0x288
4200eed7:	a56122        	s32i	a2, a1, 0x294
4200eeda:	000346        	j	4200eeeb <_vfprintf_r+0xd3b>
4200eedd:	a561a2        	s32i	a10, a1, 0x294
4200eee0:	630c      	movi.n	a3, 6
4200eee2:	000086        	j	4200eee8 <_vfprintf_r+0xd38>
4200eee5:	a561a2        	s32i	a10, a1, 0x294
4200eee8:	a46132        	s32i	a3, a1, 0x290
4200eeeb:	a02142        	l32i	a4, a1, 0x280
4200eeee:	00a122        	movi	a2, 0x100
4200eef1:	202420        	or	a2, a4, a2
4200eef4:	af6122        	s32i	a2, a1, 0x2bc
4200eef7:	a92122        	l32i	a2, a1, 0x2a4
4200eefa:	a82132        	l32i	a3, a1, 0x2a0
4200eefd:	0142d6        	bgez	a2, 4200ef15 <_vfprintf_r+0xd65>
4200ef00:	a92152        	l32i	a5, a1, 0x2a4
4200ef03:	f27c      	movi.n	a2, -1
4200ef05:	012210        	slli	a2, a2, 31
4200ef08:	d62c      	movi.n	a6, 45
4200ef0a:	302520        	xor	a2, a5, a2
4200ef0d:	b16162        	s32i	a6, a1, 0x2c4
4200ef10:	000186        	j	4200ef1a <_vfprintf_r+0xd6a>
4200ef13:	00          	.byte 00
4200ef14:	00          	.byte 00
4200ef15:	080c      	movi.n	a8, 0
4200ef17:	b16182        	s32i	a8, a1, 0x2c4
4200ef1a:	144c      	movi.n	a4, 65
4200ef1c:	021747        	beq	a7, a4, 4200ef22 <_vfprintf_r+0xd72>
4200ef1f:	005bc6        	j	4200f092 <_vfprintf_r+0xee2>
4200ef22:	58a2c2        	movi	a12, 0x258
4200ef25:	c1ca      	add.n	a12, a1, a12
4200ef27:	03ad      	mov.n	a10, a3
4200ef29:	20b220        	or	a11, a2, a2
4200ef2c:	b96192        	s32i	a9, a1, 0x2e4
4200ef2f:	201110        	or	a1, a1, a1
4200ef32:	041025        	call8	42013034 <frexp>
4200ef35:	c62ec1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200ef38:	c72ad1        	l32r	a13, 42000be0 <_stext+0xbc0>
4200ef3b:	c73281        	l32r	a8, 42000c04 <_stext+0xbe4>
4200ef3e:	0008e0        	callx8	a8
4200ef41:	c62bc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200ef44:	c62bd1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200ef47:	0a2d      	mov.n	a2, a10
4200ef49:	0b3d      	mov.n	a3, a11
4200ef4b:	c72f81        	l32r	a8, 42000c08 <_stext+0xbe8>
4200ef4e:	0008e0        	callx8	a8
4200ef51:	b92192        	l32i	a9, a1, 0x2e4
4200ef54:	005a56        	bnez	a10, 4200ef5d <_vfprintf_r+0xdad>
4200ef57:	01a042        	movi	a4, 1
4200ef5a:	966142        	s32i	a4, a1, 0x258
4200ef5d:	a72152        	l32i	a5, a1, 0x29c
4200ef60:	61a042        	movi	a4, 97
4200ef63:	c73661        	l32r	a6, 42000c3c <_stext+0xc1c>
4200ef66:	021547        	beq	a5, a4, 4200ef6c <_vfprintf_r+0xdbc>
4200ef69:	c73561        	l32r	a6, 42000c40 <_stext+0xc20>
4200ef6c:	a42152        	l32i	a5, a1, 0x290
4200ef6f:	a22142        	l32i	a4, a1, 0x288
4200ef72:	850b      	addi.n	a8, a5, -1
4200ef74:	c61fc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200ef77:	c71bd1        	l32r	a13, 42000be4 <_stext+0xbc4>
4200ef7a:	02ad      	mov.n	a10, a2
4200ef7c:	03bd      	mov.n	a11, a3
4200ef7e:	b76182        	s32i	a8, a1, 0x2dc
4200ef81:	b96192        	s32i	a9, a1, 0x2e4
4200ef84:	c72081        	l32r	a8, 42000c04 <_stext+0xbe4>
4200ef87:	0008e0        	callx8	a8
4200ef8a:	0b3d      	mov.n	a3, a11
4200ef8c:	0a2d      	mov.n	a2, a10
4200ef8e:	c61d81        	l32r	a8, 42000804 <_stext+0x7e4>
4200ef91:	0008e0        	callx8	a8
4200ef94:	0a5d      	mov.n	a5, a10
4200ef96:	c61981        	l32r	a8, 420007fc <_stext+0x7dc>
4200ef99:	0008e0        	callx8	a8
4200ef9c:	0acd      	mov.n	a12, a10
4200ef9e:	0bdd      	mov.n	a13, a11
4200efa0:	02ad      	mov.n	a10, a2
4200efa2:	03bd      	mov.n	a11, a3
4200efa4:	c71a81        	l32r	a8, 42000c0c <_stext+0xbec>
4200efa7:	0008e0        	callx8	a8
4200efaa:	0b3d      	mov.n	a3, a11
4200efac:	b65a      	add.n	a11, a6, a5
4200efae:	000bb2        	l8ui	a11, a11, 0
4200efb1:	0a2d      	mov.n	a2, a10
4200efb3:	04ad      	mov.n	a10, a4
4200efb5:	004ab2        	s8i	a11, a10, 0
4200efb8:	b72182        	l32i	a8, a1, 0x2dc
4200efbb:	441b      	addi.n	a4, a4, 1
4200efbd:	b36142        	s32i	a4, a1, 0x2cc
4200efc0:	a66182        	s32i	a8, a1, 0x298
4200efc3:	b92192        	l32i	a9, a1, 0x2e4
4200efc6:	1f0826        	beqi	a8, -1, 4200efe9 <_vfprintf_r+0xe39>
4200efc9:	c609c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200efcc:	c609d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200efcf:	ffc882        	addi	a8, a8, -1
4200efd2:	20a220        	or	a10, a2, a2
4200efd5:	03bd      	mov.n	a11, a3
4200efd7:	b76182        	s32i	a8, a1, 0x2dc
4200efda:	c70d81        	l32r	a8, 42000c10 <_stext+0xbf0>
4200efdd:	0008e0        	callx8	a8
4200efe0:	b72182        	l32i	a8, a1, 0x2dc
4200efe3:	b92192        	l32i	a9, a1, 0x2e4
4200efe6:	f8aa56        	bnez	a10, 4200ef74 <_vfprintf_r+0xdc4>
4200efe9:	c601e1        	l32r	a14, 420007f0 <_stext+0x7d0>
4200efec:	c6fff1        	l32r	a15, 42000be8 <_stext+0xbc8>
4200efef:	0ecd      	mov.n	a12, a14
4200eff1:	0fdd      	mov.n	a13, a15
4200eff3:	20a220        	or	a10, a2, a2
4200eff6:	20b330        	or	a11, a3, a3
4200eff9:	b96192        	s32i	a9, a1, 0x2e4
4200effc:	b761e2        	s32i	a14, a1, 0x2dc
4200efff:	b861f2        	s32i	a15, a1, 0x2e0
4200f002:	c6cb81        	l32r	a8, 42000b30 <_stext+0xb10>
4200f005:	0008e0        	callx8	a8
4200f008:	b92192        	l32i	a9, a1, 0x2e4
4200f00b:	b721e2        	l32i	a14, a1, 0x2dc
4200f00e:	b821f2        	l32i	a15, a1, 0x2e0
4200f011:	171ae6        	bgei	a10, 1, 4200f02c <_vfprintf_r+0xe7c>
4200f014:	0ecd      	mov.n	a12, a14
4200f016:	0fdd      	mov.n	a13, a15
4200f018:	20a220        	or	a10, a2, a2
4200f01b:	20b330        	or	a11, a3, a3
4200f01e:	c6fa81        	l32r	a8, 42000c08 <_stext+0xbe8>
4200f021:	0008e0        	callx8	a8
4200f024:	b92192        	l32i	a9, a1, 0x2e4
4200f027:	dafc      	bnez.n	a10, 4200f068 <_vfprintf_r+0xeb8>
4200f029:	3b6507        	bbci	a5, 0, 4200f068 <_vfprintf_r+0xeb8>
4200f02c:	906142        	s32i	a4, a1, 0x240
4200f02f:	0f0632        	l8ui	a3, a6, 15
4200f032:	043c      	movi.n	a4, 48
4200f034:	0000c6        	j	4200f03b <_vfprintf_r+0xe8b>
4200f037:	00          	.byte 00
4200f038:	004242        	s8i	a4, a2, 0
4200f03b:	902122        	l32i	a2, a1, 0x240
4200f03e:	220b      	addi.n	a2, a2, -1
4200f040:	906122        	s32i	a2, a1, 0x240
4200f043:	000252        	l8ui	a5, a2, 0
4200f046:	ee1537        	beq	a5, a3, 4200f038 <_vfprintf_r+0xe88>
4200f049:	01c532        	addi	a3, a5, 1
4200f04c:	39a042        	movi	a4, 57
4200f04f:	743030        	extui	a3, a3, 0, 8
4200f052:	029547        	bne	a5, a4, 4200f058 <_vfprintf_r+0xea8>
4200f055:	0a0632        	l8ui	a3, a6, 10
4200f058:	004232        	s8i	a3, a2, 0
4200f05b:	0009c6        	j	4200f086 <_vfprintf_r+0xed6>
4200f05e:	00          	.byte 00
4200f05f:	00          	.byte 00
4200f060:	004262        	s8i	a6, a2, 0
4200f063:	221b      	addi.n	a2, a2, 1
4200f065:	000206        	j	4200f071 <_vfprintf_r+0xec1>
4200f068:	a62162        	l32i	a6, a1, 0x298
4200f06b:	042d      	mov.n	a2, a4
4200f06d:	546a      	add.n	a5, a4, a6
4200f06f:	063c      	movi.n	a6, 48
4200f071:	c03520        	sub	a3, a5, a2
4200f074:	fe83d6        	bgez	a3, 4200f060 <_vfprintf_r+0xeb0>
4200f077:	a62182        	l32i	a8, a1, 0x298
4200f07a:	020c      	movi.n	a2, 0
4200f07c:	0108a6        	blti	a8, -1, 4200f081 <_vfprintf_r+0xed1>
4200f07f:	281b      	addi.n	a2, a8, 1
4200f081:	242a      	add.n	a2, a4, a2
4200f083:	b36122        	s32i	a2, a1, 0x2cc
4200f086:	b32122        	l32i	a2, a1, 0x2cc
4200f089:	a22132        	l32i	a3, a1, 0x288
4200f08c:	c02230        	sub	a2, a2, a3
4200f08f:	0014c6        	j	4200f0e6 <_vfprintf_r+0xf36>
4200f092:	654c      	movi.n	a5, 70
4200f094:	a42142        	l32i	a4, a1, 0x290
4200f097:	3e0c      	movi.n	a14, 3
4200f099:	081757        	beq	a7, a5, 4200f0a5 <_vfprintf_r+0xef5>
4200f09c:	554c      	movi.n	a5, 69
4200f09e:	2e0c      	movi.n	a14, 2
4200f0a0:	019757        	bne	a7, a5, 4200f0a5 <_vfprintf_r+0xef5>
4200f0a3:	441b      	addi.n	a4, a4, 1
4200f0a5:	40a262        	movi	a6, 0x240
4200f0a8:	516a      	add.n	a5, a1, a6
4200f0aa:	50a282        	movi	a8, 0x250
4200f0ad:	2159      	s32i.n	a5, a1, 8
4200f0af:	58a2a2        	movi	a10, 0x258
4200f0b2:	518a      	add.n	a5, a1, a8
4200f0b4:	1159      	s32i.n	a5, a1, 4
4200f0b6:	51aa      	add.n	a5, a1, a10
4200f0b8:	a321a2        	l32i	a10, a1, 0x28c
4200f0bb:	0159      	s32i.n	a5, a1, 0
4200f0bd:	04fd      	mov.n	a15, a4
4200f0bf:	03cd      	mov.n	a12, a3
4200f0c1:	02dd      	mov.n	a13, a2
4200f0c3:	b96192        	s32i	a9, a1, 0x2e4
4200f0c6:	201110        	or	a1, a1, a1
4200f0c9:	024b25        	call8	4201157c <_dtoa_r>
4200f0cc:	a261a2        	s32i	a10, a1, 0x288
4200f0cf:	754c      	movi.n	a5, 71
4200f0d1:	b92192        	l32i	a9, a1, 0x2e4
4200f0d4:	149757        	bne	a7, a5, 4200f0ec <_vfprintf_r+0xf3c>
4200f0d7:	a02152        	l32i	a5, a1, 0x280
4200f0da:	0ee507        	bbsi	a5, 0, 4200f0ec <_vfprintf_r+0xf3c>
4200f0dd:	902122        	l32i	a2, a1, 0x240
4200f0e0:	a22182        	l32i	a8, a1, 0x288
4200f0e3:	c02280        	sub	a2, a2, a8
4200f0e6:	a66122        	s32i	a2, a1, 0x298
4200f0e9:	001a46        	j	4200f156 <_vfprintf_r+0xfa6>
4200f0ec:	a22182        	l32i	a8, a1, 0x288
4200f0ef:	664c      	movi.n	a6, 70
4200f0f1:	584a      	add.n	a5, a8, a4
4200f0f3:	2e9767        	bne	a7, a6, 4200f125 <_vfprintf_r+0xf75>
4200f0f6:	000862        	l8ui	a6, a8, 0
4200f0f9:	d0c662        	addi	a6, a6, -48
4200f0fc:	06ec      	bnez.n	a6, 4200f120 <_vfprintf_r+0xf70>
4200f0fe:	c5bcc1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200f101:	c5bbd1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200f104:	03ad      	mov.n	a10, a3
4200f106:	02bd      	mov.n	a11, a2
4200f108:	b96192        	s32i	a9, a1, 0x2e4
4200f10b:	c6c181        	l32r	a8, 42000c10 <_stext+0xbf0>
4200f10e:	0008e0        	callx8	a8
4200f111:	b92192        	l32i	a9, a1, 0x2e4
4200f114:	008a16        	beqz	a10, 4200f120 <_vfprintf_r+0xf70>
4200f117:	01a062        	movi	a6, 1
4200f11a:	c04640        	sub	a4, a6, a4
4200f11d:	966142        	s32i	a4, a1, 0x258
4200f120:	962142        	l32i	a4, a1, 0x258
4200f123:	554a      	add.n	a5, a5, a4
4200f125:	c5b2c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4200f128:	c5b2d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4200f12b:	03ad      	mov.n	a10, a3
4200f12d:	02bd      	mov.n	a11, a2
4200f12f:	b96192        	s32i	a9, a1, 0x2e4
4200f132:	c6b581        	l32r	a8, 42000c08 <_stext+0xbe8>
4200f135:	0008e0        	callx8	a8
4200f138:	b92192        	l32i	a9, a1, 0x2e4
4200f13b:	1acc      	bnez.n	a10, 4200f140 <_vfprintf_r+0xf90>
4200f13d:	906152        	s32i	a5, a1, 0x240
4200f140:	033c      	movi.n	a3, 48
4200f142:	0001c6        	j	4200f14d <_vfprintf_r+0xf9d>
4200f145:	421b      	addi.n	a4, a2, 1
4200f147:	906142        	s32i	a4, a1, 0x240
4200f14a:	004232        	s8i	a3, a2, 0
4200f14d:	902122        	l32i	a2, a1, 0x240
4200f150:	f13257        	bltu	a2, a5, 4200f145 <_vfprintf_r+0xf95>
4200f153:	ffe186        	j	4200f0dd <_vfprintf_r+0xf2d>
4200f156:	734c      	movi.n	a3, 71
4200f158:	962122        	l32i	a2, a1, 0x258
4200f15b:	229737        	bne	a7, a3, 4200f181 <_vfprintf_r+0xfd1>
4200f15e:	a42132        	l32i	a3, a1, 0x290
4200f161:	102327        	blt	a3, a2, 4200f175 <_vfprintf_r+0xfc5>
4200f164:	d37c      	movi.n	a3, -3
4200f166:	0b2237        	blt	a2, a3, 4200f175 <_vfprintf_r+0xfc5>
4200f169:	a62142        	l32i	a4, a1, 0x298
4200f16c:	022247        	blt	a2, a4, 4200f172 <_vfprintf_r+0xfc2>
4200f16f:	005d46        	j	4200f2e8 <_vfprintf_r+0x1138>
4200f172:	006306        	j	4200f302 <_vfprintf_r+0x1152>
4200f175:	a72152        	l32i	a5, a1, 0x29c
4200f178:	fec552        	addi	a5, a5, -2
4200f17b:	a76152        	s32i	a5, a1, 0x29c
4200f17e:	0001c6        	j	4200f189 <_vfprintf_r+0xfd9>
4200f181:	634c      	movi.n	a3, 70
4200f183:	029737        	bne	a7, a3, 4200f189 <_vfprintf_r+0xfd9>
4200f186:	004786        	j	4200f2a8 <_vfprintf_r+0x10f8>
4200f189:	a72162        	l32i	a6, a1, 0x29c
4200f18c:	320b      	addi.n	a3, a2, -1
4200f18e:	dfaf52        	movi	a5, -33
4200f191:	105650        	and	a5, a6, a5
4200f194:	744060        	extui	a4, a6, 0, 8
4200f197:	966132        	s32i	a3, a1, 0x258
4200f19a:	164c      	movi.n	a6, 65
4200f19c:	049567        	bne	a5, a6, 4200f1a4 <_vfprintf_r+0xff4>
4200f19f:	44fb      	addi.n	a4, a4, 15
4200f1a1:	744040        	extui	a4, a4, 0, 8
4200f1a4:	10c182        	addi	a8, a1, 16
4200f1a7:	02d862        	addmi	a6, a8, 0x200
4200f1aa:	374642        	s8i	a4, a6, 55
4200f1ad:	b42c      	movi.n	a4, 43
4200f1af:	0063d6        	bgez	a3, 4200f1b9 <_vfprintf_r+0x1009>
4200f1b2:	130c      	movi.n	a3, 1
4200f1b4:	c03320        	sub	a3, a3, a2
4200f1b7:	d42c      	movi.n	a4, 45
4200f1b9:	10c1a2        	addi	a10, a1, 16
4200f1bc:	02da62        	addmi	a6, a10, 0x200
4200f1bf:	384642        	s8i	a4, a6, 56
4200f1c2:	09a022        	movi	a2, 9
4200f1c5:	78a237        	bge	a2, a3, 4200f241 <_vfprintf_r+0x1091>
4200f1c8:	37a222        	movi	a2, 0x237
4200f1cb:	c44381        	l32r	a8, 420002d8 <_stext+0x2b8>
4200f1ce:	802a20        	add	a2, a10, a2
4200f1d1:	63a072        	movi	a7, 99
4200f1d4:	b24380        	mulsh	a4, a3, a8
4200f1d7:	315f30        	srai	a5, a3, 31
4200f1da:	214240        	srai	a4, a4, 2
4200f1dd:	c04450        	sub	a4, a4, a5
4200f1e0:	a05440        	addx4	a5, a4, a4
4200f1e3:	555a      	add.n	a5, a5, a5
4200f1e5:	c05350        	sub	a5, a3, a5
4200f1e8:	30c552        	addi	a5, a5, 48
4200f1eb:	026d      	mov.n	a6, a2
4200f1ed:	220b      	addi.n	a2, a2, -1
4200f1ef:	004252        	s8i	a5, a2, 0
4200f1f2:	035d      	mov.n	a5, a3
4200f1f4:	043d      	mov.n	a3, a4
4200f1f6:	da2757        	blt	a7, a5, 4200f1d4 <_vfprintf_r+0x1024>
4200f1f9:	40a2e2        	movi	a14, 0x240
4200f1fc:	fec642        	addi	a4, a6, -2
4200f1ff:	30c332        	addi	a3, a3, 48
4200f202:	39a222        	movi	a2, 0x239
4200f205:	10c1b2        	addi	a11, a1, 16
4200f208:	ee1a      	add.n	a14, a14, a1
4200f20a:	004432        	s8i	a3, a4, 0
4200f20d:	2b2a      	add.n	a2, a11, a2
4200f20f:	043d      	mov.n	a3, a4
4200f211:	5e7b      	addi.n	a5, a14, 7
4200f213:	0002c6        	j	4200f222 <_vfprintf_r+0x1072>
4200f216:	00          	.byte 00
4200f217:	00          	.byte 00
4200f218:	000372        	l8ui	a7, a3, 0
4200f21b:	331b      	addi.n	a3, a3, 1
4200f21d:	004272        	s8i	a7, a2, 0
4200f220:	221b      	addi.n	a2, a2, 1
4200f222:	f23357        	bltu	a3, a5, 4200f218 <_vfprintf_r+0x1068>
4200f225:	10c132        	addi	a3, a1, 16
4200f228:	39a222        	movi	a2, 0x239
4200f22b:	232a      	add.n	a2, a3, a2
4200f22d:	030c      	movi.n	a3, 0
4200f22f:	093547        	bltu	a5, a4, 4200f23c <_vfprintf_r+0x108c>
4200f232:	40a242        	movi	a4, 0x240
4200f235:	441a      	add.n	a4, a4, a1
4200f237:	349b      	addi.n	a3, a4, 9
4200f239:	c03360        	sub	a3, a3, a6
4200f23c:	223a      	add.n	a2, a2, a3
4200f23e:	0007c6        	j	4200f261 <_vfprintf_r+0x10b1>
4200f241:	37a222        	movi	a2, 0x237
4200f244:	10c182        	addi	a8, a1, 16
4200f247:	482a      	add.n	a4, a8, a2
4200f249:	174c      	movi.n	a7, 65
4200f24b:	442b      	addi.n	a4, a4, 2
4200f24d:	081577        	beq	a5, a7, 4200f259 <_vfprintf_r+0x10a9>
4200f250:	043c      	movi.n	a4, 48
4200f252:	282a      	add.n	a2, a8, a2
4200f254:	394642        	s8i	a4, a6, 57
4200f257:	423b      	addi.n	a4, a2, 3
4200f259:	30c332        	addi	a3, a3, 48
4200f25c:	241b      	addi.n	a2, a4, 1
4200f25e:	004432        	s8i	a3, a4, 0
4200f261:	47a232        	movi	a3, 0x247
4200f264:	313a      	add.n	a3, a1, a3
4200f266:	c03230        	sub	a3, a2, a3
4200f269:	a62122        	l32i	a2, a1, 0x298
4200f26c:	b66132        	s32i	a3, a1, 0x2d8
4200f26f:	802320        	add	a2, a3, a2
4200f272:	a62132        	l32i	a3, a1, 0x298
4200f275:	a46122        	s32i	a2, a1, 0x290
4200f278:	0523e6        	bgei	a3, 2, 4200f281 <_vfprintf_r+0x10d1>
4200f27b:	a02142        	l32i	a4, a1, 0x280
4200f27e:	0a6407        	bbci	a4, 0, 4200f28c <_vfprintf_r+0x10dc>
4200f281:	a42152        	l32i	a5, a1, 0x290
4200f284:	ae2162        	l32i	a6, a1, 0x2b8
4200f287:	556a      	add.n	a5, a5, a6
4200f289:	a46152        	s32i	a5, a1, 0x290
4200f28c:	a02182        	l32i	a8, a1, 0x280
4200f28f:	ffab22        	movi	a2, 0xfffffbff
4200f292:	102820        	and	a2, a8, a2
4200f295:	00a132        	movi	a3, 0x100
4200f298:	203230        	or	a3, a2, a3
4200f29b:	af6132        	s32i	a3, a1, 0x2bc
4200f29e:	030c      	movi.n	a3, 0
4200f2a0:	034d      	mov.n	a4, a3
4200f2a2:	032d      	mov.n	a2, a3
4200f2a4:	003806        	j	4200f388 <_vfprintf_r+0x11d8>
4200f2a7:	00          	.byte 00
4200f2a8:	a02142        	l32i	a4, a1, 0x280
4200f2ab:	a42152        	l32i	a5, a1, 0x290
4200f2ae:	043040        	extui	a3, a4, 0, 1
4200f2b1:	203350        	or	a3, a3, a5
4200f2b4:	1512a6        	blti	a2, 1, 4200f2cd <_vfprintf_r+0x111d>
4200f2b7:	066316        	beqz	a3, 4200f321 <_vfprintf_r+0x1171>
4200f2ba:	ae2162        	l32i	a6, a1, 0x2b8
4200f2bd:	66a082        	movi	a8, 102
4200f2c0:	326a      	add.n	a3, a2, a6
4200f2c2:	553a      	add.n	a5, a5, a3
4200f2c4:	a46152        	s32i	a5, a1, 0x290
4200f2c7:	a76182        	s32i	a8, a1, 0x29c
4200f2ca:	001a86        	j	4200f338 <_vfprintf_r+0x1188>
4200f2cd:	05c316        	beqz	a3, 4200f32d <_vfprintf_r+0x117d>
4200f2d0:	ae2142        	l32i	a4, a1, 0x2b8
4200f2d3:	a42152        	l32i	a5, a1, 0x290
4200f2d6:	341b      	addi.n	a3, a4, 1
4200f2d8:	553a      	add.n	a5, a5, a3
4200f2da:	66a062        	movi	a6, 102
4200f2dd:	a46152        	s32i	a5, a1, 0x290
4200f2e0:	a76162        	s32i	a6, a1, 0x29c
4200f2e3:	001446        	j	4200f338 <_vfprintf_r+0x1188>
4200f2e6:	00          	.byte 00
4200f2e7:	00          	.byte 00
4200f2e8:	67a082        	movi	a8, 103
4200f2eb:	a02132        	l32i	a3, a1, 0x280
4200f2ee:	a46122        	s32i	a2, a1, 0x290
4200f2f1:	a76182        	s32i	a8, a1, 0x29c
4200f2f4:	406307        	bbci	a3, 0, 4200f338 <_vfprintf_r+0x1188>
4200f2f7:	ae2142        	l32i	a4, a1, 0x2b8
4200f2fa:	424a      	add.n	a4, a2, a4
4200f2fc:	a46142        	s32i	a4, a1, 0x290
4200f2ff:	000d46        	j	4200f338 <_vfprintf_r+0x1188>
4200f302:	a62162        	l32i	a6, a1, 0x298
4200f305:	ae2182        	l32i	a8, a1, 0x2b8
4200f308:	67a032        	movi	a3, 103
4200f30b:	668a      	add.n	a6, a6, a8
4200f30d:	a46162        	s32i	a6, a1, 0x290
4200f310:	a76132        	s32i	a3, a1, 0x29c
4200f313:	2112e6        	bgei	a2, 1, 4200f338 <_vfprintf_r+0x1188>
4200f316:	c03620        	sub	a3, a6, a2
4200f319:	331b      	addi.n	a3, a3, 1
4200f31b:	a46132        	s32i	a3, a1, 0x290
4200f31e:	000586        	j	4200f338 <_vfprintf_r+0x1188>
4200f321:	66a042        	movi	a4, 102
4200f324:	a46122        	s32i	a2, a1, 0x290
4200f327:	a76142        	s32i	a4, a1, 0x29c
4200f32a:	000286        	j	4200f338 <_vfprintf_r+0x1188>
4200f32d:	66a052        	movi	a5, 102
4200f330:	160c      	movi.n	a6, 1
4200f332:	a76152        	s32i	a5, a1, 0x29c
4200f335:	a46162        	s32i	a6, a1, 0x290
4200f338:	a02182        	l32i	a8, a1, 0x280
4200f33b:	00a442        	movi	a4, 0x400
4200f33e:	104840        	and	a4, a8, a4
4200f341:	030c      	movi.n	a3, 0
4200f343:	411437        	beq	a4, a3, 4200f388 <_vfprintf_r+0x11d8>
4200f346:	034d      	mov.n	a4, a3
4200f348:	2012e6        	bgei	a2, 1, 4200f36c <_vfprintf_r+0x11bc>
4200f34b:	000e46        	j	4200f388 <_vfprintf_r+0x11d8>
4200f34e:	26a527        	bge	a5, a2, 4200f378 <_vfprintf_r+0x11c8>
4200f351:	ac2182        	l32i	a8, a1, 0x2b0
4200f354:	c02250        	sub	a2, a2, a5
4200f357:	010852        	l8ui	a5, a8, 1
4200f35a:	858c      	beqz.n	a5, 4200f366 <_vfprintf_r+0x11b6>
4200f35c:	881b      	addi.n	a8, a8, 1
4200f35e:	441b      	addi.n	a4, a4, 1
4200f360:	ac6182        	s32i	a8, a1, 0x2b0
4200f363:	000206        	j	4200f36f <_vfprintf_r+0x11bf>
4200f366:	331b      	addi.n	a3, a3, 1
4200f368:	0000c6        	j	4200f36f <_vfprintf_r+0x11bf>
4200f36b:	00          	.byte 00
4200f36c:	ffa062        	movi	a6, 255
4200f36f:	ac2182        	l32i	a8, a1, 0x2b0
4200f372:	000852        	l8ui	a5, a8, 0
4200f375:	d59567        	bne	a5, a6, 4200f34e <_vfprintf_r+0x119e>
4200f378:	b02162        	l32i	a6, a1, 0x2c0
4200f37b:	543a      	add.n	a5, a4, a3
4200f37d:	a42182        	l32i	a8, a1, 0x290
4200f380:	825560        	mull	a5, a5, a6
4200f383:	858a      	add.n	a8, a5, a8
4200f385:	a46182        	s32i	a8, a1, 0x290
4200f388:	af2152        	l32i	a5, a1, 0x2bc
4200f38b:	a06152        	s32i	a5, a1, 0x280
4200f38e:	b12152        	l32i	a5, a1, 0x2c4
4200f391:	15cc      	bnez.n	a5, 4200f396 <_vfprintf_r+0x11e6>
4200f393:	04de46        	j	42010710 <_vfprintf_r+0x2560>
4200f396:	10c162        	addi	a6, a1, 16
4200f399:	02d652        	addmi	a5, a6, 0x200
4200f39c:	d62c      	movi.n	a6, 45
4200f39e:	564562        	s8i	a6, a5, 86
4200f3a1:	050c      	movi.n	a5, 0
4200f3a3:	04da46        	j	42010710 <_vfprintf_r+0x2560>
4200f3a6:	a02162        	l32i	a6, a1, 0x280
4200f3a9:	982152        	l32i	a5, a1, 0x260
4200f3ac:	02e657        	bbsi	a6, 5, 4200f3b2 <_vfprintf_r+0x1202>
4200f3af:	003046        	j	4200f474 <_vfprintf_r+0x12c4>
4200f3b2:	e4bc      	beqz.n	a4, 4200f3f4 <_vfprintf_r+0x1244>
4200f3b4:	0da257        	bge	a2, a5, 4200f3c5 <_vfprintf_r+0x1215>
4200f3b7:	10c182        	addi	a8, a1, 16
4200f3ba:	b02280        	addx8	a2, a2, a8
4200f3bd:	0228      	l32i.n	a2, a2, 0
4200f3bf:	9f2162        	l32i	a6, a1, 0x27c
4200f3c2:	002806        	j	4200f466 <_vfprintf_r+0x12b6>
4200f3c5:	5ca2a2        	movi	a10, 0x25c
4200f3c8:	10c1b2        	addi	a11, a1, 16
4200f3cb:	41aa      	add.n	a4, a1, a10
4200f3cd:	50a2d2        	movi	a13, 0x250
4200f3d0:	60a2c2        	movi	a12, 0x260
4200f3d3:	01dbf2        	addmi	a15, a11, 0x100
4200f3d6:	0bed      	mov.n	a14, a11
4200f3d8:	dbda      	add.n	a13, a11, a13
4200f3da:	cbca      	add.n	a12, a11, a12
4200f3dc:	02ad      	mov.n	a10, a2
4200f3de:	0149      	s32i.n	a4, a1, 0
4200f3e0:	03bd      	mov.n	a11, a3
4200f3e2:	b96192        	s32i	a9, a1, 0x2e4
4200f3e5:	fe8d25        	call8	4200dcb8 <get_arg$constprop$0>
4200f3e8:	0a28      	l32i.n	a2, a10, 0
4200f3ea:	9f2162        	l32i	a6, a1, 0x27c
4200f3ed:	b92192        	l32i	a9, a1, 0x2e4
4200f3f0:	001c86        	j	4200f466 <_vfprintf_r+0x12b6>
4200f3f3:	00          	.byte 00
4200f3f4:	9f2132        	l32i	a3, a1, 0x27c
4200f3f7:	10c142        	addi	a4, a1, 16
4200f3fa:	631b      	addi.n	a6, a3, 1
4200f3fc:	b02240        	addx8	a2, a2, a4
4200f3ff:	612357        	blt	a3, a5, 4200f464 <_vfprintf_r+0x12b4>
4200f402:	10c182        	addi	a8, a1, 16
4200f405:	9a2872        	l32i	a7, a8, 0x268
4200f408:	02d822        	addmi	a2, a8, 0x200
4200f40b:	f81c      	movi.n	a8, 31
4200f40d:	374b      	addi.n	a3, a7, 4
4200f40f:	841c      	movi.n	a4, 24
4200f411:	302857        	blt	a8, a5, 4200f445 <_vfprintf_r+0x1295>
4200f414:	851b      	addi.n	a8, a5, 1
4200f416:	986182        	s32i	a8, a1, 0x260
4200f419:	1a6232        	s32i	a3, a2, 104
4200f41c:	052437        	blt	a4, a3, 4200f425 <_vfprintf_r+0x1275>
4200f41f:	192222        	l32i	a2, a2, 100
4200f422:	000286        	j	4200f430 <_vfprintf_r+0x1280>
4200f425:	012477        	blt	a4, a7, 4200f42a <_vfprintf_r+0x127a>
4200f428:	432c      	movi.n	a3, 36
4200f42a:	9c2122        	l32i	a2, a1, 0x270
4200f42d:	9e6132        	s32i	a3, a1, 0x278
4200f430:	9e2132        	l32i	a3, a1, 0x278
4200f433:	10c1b2        	addi	a11, a1, 16
4200f436:	223a      	add.n	a2, a2, a3
4200f438:	fcc222        	addi	a2, a2, -4
4200f43b:	0228      	l32i.n	a2, a2, 0
4200f43d:	b035b0        	addx8	a3, a5, a11
4200f440:	0329      	s32i.n	a2, a3, 0
4200f442:	000806        	j	4200f466 <_vfprintf_r+0x12b6>
4200f445:	1a6232        	s32i	a3, a2, 104
4200f448:	052437        	blt	a4, a3, 4200f451 <_vfprintf_r+0x12a1>
4200f44b:	192222        	l32i	a2, a2, 100
4200f44e:	000286        	j	4200f45c <_vfprintf_r+0x12ac>
4200f451:	012477        	blt	a4, a7, 4200f456 <_vfprintf_r+0x12a6>
4200f454:	432c      	movi.n	a3, 36
4200f456:	9c2122        	l32i	a2, a1, 0x270
4200f459:	9e6132        	s32i	a3, a1, 0x278
4200f45c:	9e2132        	l32i	a3, a1, 0x278
4200f45f:	223a      	add.n	a2, a2, a3
4200f461:	fcc222        	addi	a2, a2, -4
4200f464:	0228      	l32i.n	a2, a2, 0
4200f466:	ad2132        	l32i	a3, a1, 0x2b4
4200f469:	0239      	s32i.n	a3, a2, 0
4200f46b:	313f30        	srai	a3, a3, 31
4200f46e:	1239      	s32i.n	a3, a2, 4
4200f470:	00c4c6        	j	4200f787 <_vfprintf_r+0x15d7>
4200f473:	00          	.byte 00
4200f474:	a02162        	l32i	a6, a1, 0x280
4200f477:	02e647        	bbsi	a6, 4, 4200f47d <_vfprintf_r+0x12cd>
4200f47a:	002f86        	j	4200f53c <_vfprintf_r+0x138c>
4200f47d:	e4bc      	beqz.n	a4, 4200f4bf <_vfprintf_r+0x130f>
4200f47f:	0ea257        	bge	a2, a5, 4200f491 <_vfprintf_r+0x12e1>
4200f482:	10c182        	addi	a8, a1, 16
4200f485:	b02280        	addx8	a2, a2, a8
4200f488:	0228      	l32i.n	a2, a2, 0
4200f48a:	9f2162        	l32i	a6, a1, 0x27c
4200f48d:	002846        	j	4200f532 <_vfprintf_r+0x1382>
4200f490:	00          	.byte 00
4200f491:	5ca2a2        	movi	a10, 0x25c
4200f494:	10c1b2        	addi	a11, a1, 16
4200f497:	41aa      	add.n	a4, a1, a10
4200f499:	50a2d2        	movi	a13, 0x250
4200f49c:	60a2c2        	movi	a12, 0x260
4200f49f:	01dbf2        	addmi	a15, a11, 0x100
4200f4a2:	0bed      	mov.n	a14, a11
4200f4a4:	dbda      	add.n	a13, a11, a13
4200f4a6:	cbca      	add.n	a12, a11, a12
4200f4a8:	02ad      	mov.n	a10, a2
4200f4aa:	0149      	s32i.n	a4, a1, 0
4200f4ac:	03bd      	mov.n	a11, a3
4200f4ae:	b96192        	s32i	a9, a1, 0x2e4
4200f4b1:	fe8065        	call8	4200dcb8 <get_arg$constprop$0>
4200f4b4:	0a28      	l32i.n	a2, a10, 0
4200f4b6:	9f2162        	l32i	a6, a1, 0x27c
4200f4b9:	b92192        	l32i	a9, a1, 0x2e4
4200f4bc:	001c86        	j	4200f532 <_vfprintf_r+0x1382>
4200f4bf:	9f2132        	l32i	a3, a1, 0x27c
4200f4c2:	10c142        	addi	a4, a1, 16
4200f4c5:	631b      	addi.n	a6, a3, 1
4200f4c7:	b02240        	addx8	a2, a2, a4
4200f4ca:	622357        	blt	a3, a5, 4200f530 <_vfprintf_r+0x1380>
4200f4cd:	10c182        	addi	a8, a1, 16
4200f4d0:	9a2872        	l32i	a7, a8, 0x268
4200f4d3:	02d822        	addmi	a2, a8, 0x200
4200f4d6:	f81c      	movi.n	a8, 31
4200f4d8:	374b      	addi.n	a3, a7, 4
4200f4da:	841c      	movi.n	a4, 24
4200f4dc:	302857        	blt	a8, a5, 4200f510 <_vfprintf_r+0x1360>
4200f4df:	851b      	addi.n	a8, a5, 1
4200f4e1:	986182        	s32i	a8, a1, 0x260
4200f4e4:	1a6232        	s32i	a3, a2, 104
4200f4e7:	052437        	blt	a4, a3, 4200f4f0 <_vfprintf_r+0x1340>
4200f4ea:	192222        	l32i	a2, a2, 100
4200f4ed:	000286        	j	4200f4fb <_vfprintf_r+0x134b>
4200f4f0:	012477        	blt	a4, a7, 4200f4f5 <_vfprintf_r+0x1345>
4200f4f3:	432c      	movi.n	a3, 36
4200f4f5:	9c2122        	l32i	a2, a1, 0x270
4200f4f8:	9e6132        	s32i	a3, a1, 0x278
4200f4fb:	9e2132        	l32i	a3, a1, 0x278
4200f4fe:	10c1b2        	addi	a11, a1, 16
4200f501:	223a      	add.n	a2, a2, a3
4200f503:	fcc222        	addi	a2, a2, -4
4200f506:	0228      	l32i.n	a2, a2, 0
4200f508:	b035b0        	addx8	a3, a5, a11
4200f50b:	0329      	s32i.n	a2, a3, 0
4200f50d:	000846        	j	4200f532 <_vfprintf_r+0x1382>
4200f510:	1a6232        	s32i	a3, a2, 104
4200f513:	052437        	blt	a4, a3, 4200f51c <_vfprintf_r+0x136c>
4200f516:	192222        	l32i	a2, a2, 100
4200f519:	000286        	j	4200f527 <_vfprintf_r+0x1377>
4200f51c:	012477        	blt	a4, a7, 4200f521 <_vfprintf_r+0x1371>
4200f51f:	432c      	movi.n	a3, 36
4200f521:	9c2122        	l32i	a2, a1, 0x270
4200f524:	9e6132        	s32i	a3, a1, 0x278
4200f527:	9e2132        	l32i	a3, a1, 0x278
4200f52a:	802230        	add	a2, a2, a3
4200f52d:	fcc222        	addi	a2, a2, -4
4200f530:	0228      	l32i.n	a2, a2, 0
4200f532:	ad2132        	l32i	a3, a1, 0x2b4
4200f535:	0239      	s32i.n	a3, a2, 0
4200f537:	009306        	j	4200f787 <_vfprintf_r+0x15d7>
4200f53a:	00          	.byte 00
4200f53b:	00          	.byte 00
4200f53c:	a02162        	l32i	a6, a1, 0x280
4200f53f:	02e667        	bbsi	a6, 6, 4200f545 <_vfprintf_r+0x1395>
4200f542:	002f86        	j	4200f604 <_vfprintf_r+0x1454>
4200f545:	f4bc      	beqz.n	a4, 4200f588 <_vfprintf_r+0x13d8>
4200f547:	0ea257        	bge	a2, a5, 4200f559 <_vfprintf_r+0x13a9>
4200f54a:	10c182        	addi	a8, a1, 16
4200f54d:	b02280        	addx8	a2, a2, a8
4200f550:	0228      	l32i.n	a2, a2, 0
4200f552:	9f2162        	l32i	a6, a1, 0x27c
4200f555:	002846        	j	4200f5fa <_vfprintf_r+0x144a>
4200f558:	00          	.byte 00
4200f559:	5ca2a2        	movi	a10, 0x25c
4200f55c:	10c1b2        	addi	a11, a1, 16
4200f55f:	41aa      	add.n	a4, a1, a10
4200f561:	50a2d2        	movi	a13, 0x250
4200f564:	60a2c2        	movi	a12, 0x260
4200f567:	01dbf2        	addmi	a15, a11, 0x100
4200f56a:	0bed      	mov.n	a14, a11
4200f56c:	dbda      	add.n	a13, a11, a13
4200f56e:	cbca      	add.n	a12, a11, a12
4200f570:	02ad      	mov.n	a10, a2
4200f572:	0149      	s32i.n	a4, a1, 0
4200f574:	03bd      	mov.n	a11, a3
4200f576:	b96192        	s32i	a9, a1, 0x2e4
4200f579:	fe73e5        	call8	4200dcb8 <get_arg$constprop$0>
4200f57c:	0a28      	l32i.n	a2, a10, 0
4200f57e:	9f2162        	l32i	a6, a1, 0x27c
4200f581:	b92192        	l32i	a9, a1, 0x2e4
4200f584:	001c86        	j	4200f5fa <_vfprintf_r+0x144a>
4200f587:	00          	.byte 00
4200f588:	9f2132        	l32i	a3, a1, 0x27c
4200f58b:	10c142        	addi	a4, a1, 16
4200f58e:	631b      	addi.n	a6, a3, 1
4200f590:	b02240        	addx8	a2, a2, a4
4200f593:	612357        	blt	a3, a5, 4200f5f8 <_vfprintf_r+0x1448>
4200f596:	10c182        	addi	a8, a1, 16
4200f599:	9a2872        	l32i	a7, a8, 0x268
4200f59c:	02d822        	addmi	a2, a8, 0x200
4200f59f:	f81c      	movi.n	a8, 31
4200f5a1:	374b      	addi.n	a3, a7, 4
4200f5a3:	841c      	movi.n	a4, 24
4200f5a5:	302857        	blt	a8, a5, 4200f5d9 <_vfprintf_r+0x1429>
4200f5a8:	851b      	addi.n	a8, a5, 1
4200f5aa:	986182        	s32i	a8, a1, 0x260
4200f5ad:	1a6232        	s32i	a3, a2, 104
4200f5b0:	052437        	blt	a4, a3, 4200f5b9 <_vfprintf_r+0x1409>
4200f5b3:	192222        	l32i	a2, a2, 100
4200f5b6:	000286        	j	4200f5c4 <_vfprintf_r+0x1414>
4200f5b9:	012477        	blt	a4, a7, 4200f5be <_vfprintf_r+0x140e>
4200f5bc:	432c      	movi.n	a3, 36
4200f5be:	9c2122        	l32i	a2, a1, 0x270
4200f5c1:	9e6132        	s32i	a3, a1, 0x278
4200f5c4:	9e2132        	l32i	a3, a1, 0x278
4200f5c7:	10c1b2        	addi	a11, a1, 16
4200f5ca:	223a      	add.n	a2, a2, a3
4200f5cc:	fcc222        	addi	a2, a2, -4
4200f5cf:	0228      	l32i.n	a2, a2, 0
4200f5d1:	b035b0        	addx8	a3, a5, a11
4200f5d4:	0329      	s32i.n	a2, a3, 0
4200f5d6:	000806        	j	4200f5fa <_vfprintf_r+0x144a>
4200f5d9:	1a6232        	s32i	a3, a2, 104
4200f5dc:	052437        	blt	a4, a3, 4200f5e5 <_vfprintf_r+0x1435>
4200f5df:	192222        	l32i	a2, a2, 100
4200f5e2:	000286        	j	4200f5f0 <_vfprintf_r+0x1440>
4200f5e5:	012477        	blt	a4, a7, 4200f5ea <_vfprintf_r+0x143a>
4200f5e8:	432c      	movi.n	a3, 36
4200f5ea:	9c2122        	l32i	a2, a1, 0x270
4200f5ed:	9e6132        	s32i	a3, a1, 0x278
4200f5f0:	9e2132        	l32i	a3, a1, 0x278
4200f5f3:	223a      	add.n	a2, a2, a3
4200f5f5:	fcc222        	addi	a2, a2, -4
4200f5f8:	0228      	l32i.n	a2, a2, 0
4200f5fa:	ad2132        	l32i	a3, a1, 0x2b4
4200f5fd:	005232        	s16i	a3, a2, 0
4200f600:	0060c6        	j	4200f787 <_vfprintf_r+0x15d7>
4200f603:	00          	.byte 00
4200f604:	a02162        	l32i	a6, a1, 0x280
4200f607:	02e697        	bbsi	a6, 9, 4200f60d <_vfprintf_r+0x145d>
4200f60a:	002f86        	j	4200f6cc <_vfprintf_r+0x151c>
4200f60d:	f4bc      	beqz.n	a4, 4200f650 <_vfprintf_r+0x14a0>
4200f60f:	0da257        	bge	a2, a5, 4200f620 <_vfprintf_r+0x1470>
4200f612:	10c182        	addi	a8, a1, 16
4200f615:	b02280        	addx8	a2, a2, a8
4200f618:	0228      	l32i.n	a2, a2, 0
4200f61a:	9f2162        	l32i	a6, a1, 0x27c
4200f61d:	002846        	j	4200f6c2 <_vfprintf_r+0x1512>
4200f620:	5ca2a2        	movi	a10, 0x25c
4200f623:	10c1b2        	addi	a11, a1, 16
4200f626:	41aa      	add.n	a4, a1, a10
4200f628:	50a2d2        	movi	a13, 0x250
4200f62b:	60a2c2        	movi	a12, 0x260
4200f62e:	01dbf2        	addmi	a15, a11, 0x100
4200f631:	0bed      	mov.n	a14, a11
4200f633:	dbda      	add.n	a13, a11, a13
4200f635:	cbca      	add.n	a12, a11, a12
4200f637:	02ad      	mov.n	a10, a2
4200f639:	0149      	s32i.n	a4, a1, 0
4200f63b:	20b330        	or	a11, a3, a3
4200f63e:	b96192        	s32i	a9, a1, 0x2e4
4200f641:	fe6765        	call8	4200dcb8 <get_arg$constprop$0>
4200f644:	0a28      	l32i.n	a2, a10, 0
4200f646:	9f2162        	l32i	a6, a1, 0x27c
4200f649:	b92192        	l32i	a9, a1, 0x2e4
4200f64c:	001c86        	j	4200f6c2 <_vfprintf_r+0x1512>
4200f64f:	00          	.byte 00
4200f650:	9f2132        	l32i	a3, a1, 0x27c
4200f653:	10c142        	addi	a4, a1, 16
4200f656:	631b      	addi.n	a6, a3, 1
4200f658:	b02240        	addx8	a2, a2, a4
4200f65b:	612357        	blt	a3, a5, 4200f6c0 <_vfprintf_r+0x1510>
4200f65e:	10c182        	addi	a8, a1, 16
4200f661:	9a2872        	l32i	a7, a8, 0x268
4200f664:	02d822        	addmi	a2, a8, 0x200
4200f667:	f81c      	movi.n	a8, 31
4200f669:	374b      	addi.n	a3, a7, 4
4200f66b:	841c      	movi.n	a4, 24
4200f66d:	302857        	blt	a8, a5, 4200f6a1 <_vfprintf_r+0x14f1>
4200f670:	851b      	addi.n	a8, a5, 1
4200f672:	986182        	s32i	a8, a1, 0x260
4200f675:	1a6232        	s32i	a3, a2, 104
4200f678:	052437        	blt	a4, a3, 4200f681 <_vfprintf_r+0x14d1>
4200f67b:	192222        	l32i	a2, a2, 100
4200f67e:	000286        	j	4200f68c <_vfprintf_r+0x14dc>
4200f681:	012477        	blt	a4, a7, 4200f686 <_vfprintf_r+0x14d6>
4200f684:	432c      	movi.n	a3, 36
4200f686:	9c2122        	l32i	a2, a1, 0x270
4200f689:	9e6132        	s32i	a3, a1, 0x278
4200f68c:	9e2132        	l32i	a3, a1, 0x278
4200f68f:	10c1b2        	addi	a11, a1, 16
4200f692:	223a      	add.n	a2, a2, a3
4200f694:	fcc222        	addi	a2, a2, -4
4200f697:	0228      	l32i.n	a2, a2, 0
4200f699:	b035b0        	addx8	a3, a5, a11
4200f69c:	0329      	s32i.n	a2, a3, 0
4200f69e:	000806        	j	4200f6c2 <_vfprintf_r+0x1512>
4200f6a1:	1a6232        	s32i	a3, a2, 104
4200f6a4:	052437        	blt	a4, a3, 4200f6ad <_vfprintf_r+0x14fd>
4200f6a7:	192222        	l32i	a2, a2, 100
4200f6aa:	000286        	j	4200f6b8 <_vfprintf_r+0x1508>
4200f6ad:	012477        	blt	a4, a7, 4200f6b2 <_vfprintf_r+0x1502>
4200f6b0:	432c      	movi.n	a3, 36
4200f6b2:	9c2122        	l32i	a2, a1, 0x270
4200f6b5:	9e6132        	s32i	a3, a1, 0x278
4200f6b8:	9e2132        	l32i	a3, a1, 0x278
4200f6bb:	223a      	add.n	a2, a2, a3
4200f6bd:	fcc222        	addi	a2, a2, -4
4200f6c0:	0228      	l32i.n	a2, a2, 0
4200f6c2:	ad2132        	l32i	a3, a1, 0x2b4
4200f6c5:	004232        	s8i	a3, a2, 0
4200f6c8:	002ec6        	j	4200f787 <_vfprintf_r+0x15d7>
4200f6cb:	00          	.byte 00
4200f6cc:	040416        	beqz	a4, 4200f710 <_vfprintf_r+0x1560>
4200f6cf:	0ea257        	bge	a2, a5, 4200f6e1 <_vfprintf_r+0x1531>
4200f6d2:	10c142        	addi	a4, a1, 16
4200f6d5:	b02240        	addx8	a2, a2, a4
4200f6d8:	0228      	l32i.n	a2, a2, 0
4200f6da:	9f2162        	l32i	a6, a1, 0x27c
4200f6dd:	002846        	j	4200f782 <_vfprintf_r+0x15d2>
4200f6e0:	00          	.byte 00
4200f6e1:	5ca252        	movi	a5, 0x25c
4200f6e4:	10c162        	addi	a6, a1, 16
4200f6e7:	415a      	add.n	a4, a1, a5
4200f6e9:	50a2d2        	movi	a13, 0x250
4200f6ec:	60a2c2        	movi	a12, 0x260
4200f6ef:	01d6f2        	addmi	a15, a6, 0x100
4200f6f2:	06ed      	mov.n	a14, a6
4200f6f4:	d6da      	add.n	a13, a6, a13
4200f6f6:	c6ca      	add.n	a12, a6, a12
4200f6f8:	02ad      	mov.n	a10, a2
4200f6fa:	0149      	s32i.n	a4, a1, 0
4200f6fc:	03bd      	mov.n	a11, a3
4200f6fe:	b96192        	s32i	a9, a1, 0x2e4
4200f701:	fe5b65        	call8	4200dcb8 <get_arg$constprop$0>
4200f704:	0a28      	l32i.n	a2, a10, 0
4200f706:	9f2162        	l32i	a6, a1, 0x27c
4200f709:	b92192        	l32i	a9, a1, 0x2e4
4200f70c:	001c86        	j	4200f782 <_vfprintf_r+0x15d2>
4200f70f:	00          	.byte 00
4200f710:	9f2182        	l32i	a8, a1, 0x27c
4200f713:	10c1a2        	addi	a10, a1, 16
4200f716:	681b      	addi.n	a6, a8, 1
4200f718:	b022a0        	addx8	a2, a2, a10
4200f71b:	612857        	blt	a8, a5, 4200f780 <_vfprintf_r+0x15d0>
4200f71e:	10c1b2        	addi	a11, a1, 16
4200f721:	9a2b72        	l32i	a7, a11, 0x268
4200f724:	f81c      	movi.n	a8, 31
4200f726:	02db22        	addmi	a2, a11, 0x200
4200f729:	374b      	addi.n	a3, a7, 4
4200f72b:	841c      	movi.n	a4, 24
4200f72d:	302857        	blt	a8, a5, 4200f761 <_vfprintf_r+0x15b1>
4200f730:	851b      	addi.n	a8, a5, 1
4200f732:	986182        	s32i	a8, a1, 0x260
4200f735:	1a6232        	s32i	a3, a2, 104
4200f738:	052437        	blt	a4, a3, 4200f741 <_vfprintf_r+0x1591>
4200f73b:	192222        	l32i	a2, a2, 100
4200f73e:	000286        	j	4200f74c <_vfprintf_r+0x159c>
4200f741:	012477        	blt	a4, a7, 4200f746 <_vfprintf_r+0x1596>
4200f744:	432c      	movi.n	a3, 36
4200f746:	9c2122        	l32i	a2, a1, 0x270
4200f749:	9e6132        	s32i	a3, a1, 0x278
4200f74c:	9e2132        	l32i	a3, a1, 0x278
4200f74f:	223a      	add.n	a2, a2, a3
4200f751:	fcc222        	addi	a2, a2, -4
4200f754:	0228      	l32i.n	a2, a2, 0
4200f756:	10c132        	addi	a3, a1, 16
4200f759:	b05530        	addx8	a5, a5, a3
4200f75c:	0529      	s32i.n	a2, a5, 0
4200f75e:	000806        	j	4200f782 <_vfprintf_r+0x15d2>
4200f761:	1a6232        	s32i	a3, a2, 104
4200f764:	052437        	blt	a4, a3, 4200f76d <_vfprintf_r+0x15bd>
4200f767:	192222        	l32i	a2, a2, 100
4200f76a:	000286        	j	4200f778 <_vfprintf_r+0x15c8>
4200f76d:	012477        	blt	a4, a7, 4200f772 <_vfprintf_r+0x15c2>
4200f770:	432c      	movi.n	a3, 36
4200f772:	9c2122        	l32i	a2, a1, 0x270
4200f775:	9e6132        	s32i	a3, a1, 0x278
4200f778:	9e2132        	l32i	a3, a1, 0x278
4200f77b:	223a      	add.n	a2, a2, a3
4200f77d:	fcc222        	addi	a2, a2, -4
4200f780:	0228      	l32i.n	a2, a2, 0
4200f782:	ad2152        	l32i	a5, a1, 0x2b4
4200f785:	0259      	s32i.n	a5, a2, 0
4200f787:	9f6162        	s32i	a6, a1, 0x27c
4200f78a:	faeb86        	j	4200e33c <_vfprintf_r+0x18c>
4200f78d:	a02162        	l32i	a6, a1, 0x280
4200f790:	051c      	movi.n	a5, 16
4200f792:	206650        	or	a6, a6, a5
4200f795:	a06162        	s32i	a6, a1, 0x280
4200f798:	a02182        	l32i	a8, a1, 0x280
4200f79b:	982162        	l32i	a6, a1, 0x260
4200f79e:	02e857        	bbsi	a8, 5, 4200f7a4 <_vfprintf_r+0x15f4>
4200f7a1:	0032c6        	j	4200f870 <_vfprintf_r+0x16c0>
4200f7a4:	044416        	beqz	a4, 4200f7ec <_vfprintf_r+0x163c>
4200f7a7:	11a267        	bge	a2, a6, 4200f7bc <_vfprintf_r+0x160c>
4200f7aa:	10c1a2        	addi	a10, a1, 16
4200f7ad:	b022a0        	addx8	a2, a2, a10
4200f7b0:	0238      	l32i.n	a3, a2, 0
4200f7b2:	1248      	l32i.n	a4, a2, 4
4200f7b4:	9f2152        	l32i	a5, a1, 0x27c
4200f7b7:	00db46        	j	4200fb28 <_vfprintf_r+0x1978>
4200f7ba:	00          	.byte 00
4200f7bb:	00          	.byte 00
4200f7bc:	5ca2b2        	movi	a11, 0x25c
4200f7bf:	10c1e2        	addi	a14, a1, 16
4200f7c2:	41ba      	add.n	a4, a1, a11
4200f7c4:	50a2d2        	movi	a13, 0x250
4200f7c7:	60a2c2        	movi	a12, 0x260
4200f7ca:	0149      	s32i.n	a4, a1, 0
4200f7cc:	03bd      	mov.n	a11, a3
4200f7ce:	01def2        	addmi	a15, a14, 0x100
4200f7d1:	deda      	add.n	a13, a14, a13
4200f7d3:	ceca      	add.n	a12, a14, a12
4200f7d5:	02ad      	mov.n	a10, a2
4200f7d7:	b96192        	s32i	a9, a1, 0x2e4
4200f7da:	fe4de5        	call8	4200dcb8 <get_arg$constprop$0>
4200f7dd:	0a38      	l32i.n	a3, a10, 0
4200f7df:	1a48      	l32i.n	a4, a10, 4
4200f7e1:	9f2152        	l32i	a5, a1, 0x27c
4200f7e4:	b92192        	l32i	a9, a1, 0x2e4
4200f7e7:	00cf46        	j	4200fb28 <_vfprintf_r+0x1978>
4200f7ea:	00          	.byte 00
4200f7eb:	00          	.byte 00
4200f7ec:	9f2132        	l32i	a3, a1, 0x27c
4200f7ef:	10c142        	addi	a4, a1, 16
4200f7f2:	531b      	addi.n	a5, a3, 1
4200f7f4:	b02240        	addx8	a2, a2, a4
4200f7f7:	6d2367        	blt	a3, a6, 4200f868 <_vfprintf_r+0x16b8>
4200f7fa:	10c182        	addi	a8, a1, 16
4200f7fd:	9a2842        	l32i	a4, a8, 0x268
4200f800:	837c      	movi.n	a3, -8
4200f802:	447b      	addi.n	a4, a4, 7
4200f804:	02d822        	addmi	a2, a8, 0x200
4200f807:	104430        	and	a4, a4, a3
4200f80a:	f81c      	movi.n	a8, 31
4200f80c:	348b      	addi.n	a3, a4, 8
4200f80e:	871c      	movi.n	a7, 24
4200f810:	342867        	blt	a8, a6, 4200f848 <_vfprintf_r+0x1698>
4200f813:	861b      	addi.n	a8, a6, 1
4200f815:	986182        	s32i	a8, a1, 0x260
4200f818:	1a6232        	s32i	a3, a2, 104
4200f81b:	052737        	blt	a7, a3, 4200f824 <_vfprintf_r+0x1674>
4200f81e:	192222        	l32i	a2, a2, 100
4200f821:	000286        	j	4200f82f <_vfprintf_r+0x167f>
4200f824:	012747        	blt	a7, a4, 4200f829 <_vfprintf_r+0x1679>
4200f827:	832c      	movi.n	a3, 40
4200f829:	9c2122        	l32i	a2, a1, 0x270
4200f82c:	9e6132        	s32i	a3, a1, 0x278
4200f82f:	9e2132        	l32i	a3, a1, 0x278
4200f832:	10c1b2        	addi	a11, a1, 16
4200f835:	223a      	add.n	a2, a2, a3
4200f837:	f8c222        	addi	a2, a2, -8
4200f83a:	0238      	l32i.n	a3, a2, 0
4200f83c:	1248      	l32i.n	a4, a2, 4
4200f83e:	b026b0        	addx8	a2, a6, a11
4200f841:	0239      	s32i.n	a3, a2, 0
4200f843:	1249      	s32i.n	a4, a2, 4
4200f845:	00b7c6        	j	4200fb28 <_vfprintf_r+0x1978>
4200f848:	1a6232        	s32i	a3, a2, 104
4200f84b:	052737        	blt	a7, a3, 4200f854 <_vfprintf_r+0x16a4>
4200f84e:	192222        	l32i	a2, a2, 100
4200f851:	000286        	j	4200f85f <_vfprintf_r+0x16af>
4200f854:	012747        	blt	a7, a4, 4200f859 <_vfprintf_r+0x16a9>
4200f857:	832c      	movi.n	a3, 40
4200f859:	9c2122        	l32i	a2, a1, 0x270
4200f85c:	9e6132        	s32i	a3, a1, 0x278
4200f85f:	9e2132        	l32i	a3, a1, 0x278
4200f862:	802230        	add	a2, a2, a3
4200f865:	f8c222        	addi	a2, a2, -8
4200f868:	0238      	l32i.n	a3, a2, 0
4200f86a:	1248      	l32i.n	a4, a2, 4
4200f86c:	00ae06        	j	4200fb28 <_vfprintf_r+0x1978>
4200f86f:	00          	.byte 00
4200f870:	a02152        	l32i	a5, a1, 0x280
4200f873:	796547        	bbci	a5, 4, 4200f8f0 <_vfprintf_r+0x1740>
4200f876:	f49c      	beqz.n	a4, 4200f899 <_vfprintf_r+0x16e9>
4200f878:	08a267        	bge	a2, a6, 4200f884 <_vfprintf_r+0x16d4>
4200f87b:	10c162        	addi	a6, a1, 16
4200f87e:	b02260        	addx8	a2, a2, a6
4200f881:	007e06        	j	4200fa7d <_vfprintf_r+0x18cd>
4200f884:	5ca282        	movi	a8, 0x25c
4200f887:	10c1a2        	addi	a10, a1, 16
4200f88a:	418a      	add.n	a4, a1, a8
4200f88c:	0149      	s32i.n	a4, a1, 0
4200f88e:	01daf2        	addmi	a15, a10, 0x100
4200f891:	50a2d2        	movi	a13, 0x250
4200f894:	0aed      	mov.n	a14, a10
4200f896:	007f46        	j	4200fa97 <_vfprintf_r+0x18e7>
4200f899:	9f2132        	l32i	a3, a1, 0x27c
4200f89c:	10c142        	addi	a4, a1, 16
4200f89f:	531b      	addi.n	a5, a3, 1
4200f8a1:	b02240        	addx8	a2, a2, a4
4200f8a4:	02a367        	bge	a3, a6, 4200f8aa <_vfprintf_r+0x16fa>
4200f8a7:	009e46        	j	4200fb24 <_vfprintf_r+0x1974>
4200f8aa:	10c182        	addi	a8, a1, 16
4200f8ad:	9a2872        	l32i	a7, a8, 0x268
4200f8b0:	02d822        	addmi	a2, a8, 0x200
4200f8b3:	f81c      	movi.n	a8, 31
4200f8b5:	374b      	addi.n	a3, a7, 4
4200f8b7:	841c      	movi.n	a4, 24
4200f8b9:	02a867        	bge	a8, a6, 4200f8bf <_vfprintf_r+0x170f>
4200f8bc:	009146        	j	4200fb05 <_vfprintf_r+0x1955>
4200f8bf:	861b      	addi.n	a8, a6, 1
4200f8c1:	986182        	s32i	a8, a1, 0x260
4200f8c4:	1a6232        	s32i	a3, a2, 104
4200f8c7:	052437        	blt	a4, a3, 4200f8d0 <_vfprintf_r+0x1720>
4200f8ca:	192222        	l32i	a2, a2, 100
4200f8cd:	000286        	j	4200f8db <_vfprintf_r+0x172b>
4200f8d0:	012477        	blt	a4, a7, 4200f8d5 <_vfprintf_r+0x1725>
4200f8d3:	432c      	movi.n	a3, 36
4200f8d5:	9c2122        	l32i	a2, a1, 0x270
4200f8d8:	9e6132        	s32i	a3, a1, 0x278
4200f8db:	9e2132        	l32i	a3, a1, 0x278
4200f8de:	10c1b2        	addi	a11, a1, 16
4200f8e1:	223a      	add.n	a2, a2, a3
4200f8e3:	fcc222        	addi	a2, a2, -4
4200f8e6:	0238      	l32i.n	a3, a2, 0
4200f8e8:	b026b0        	addx8	a2, a6, a11
4200f8eb:	0239      	s32i.n	a3, a2, 0
4200f8ed:	008d46        	j	4200fb26 <_vfprintf_r+0x1976>
4200f8f0:	a02152        	l32i	a5, a1, 0x280
4200f8f3:	02e567        	bbsi	a5, 6, 4200f8f9 <_vfprintf_r+0x1749>
4200f8f6:	002d86        	j	4200f9b0 <_vfprintf_r+0x1800>
4200f8f9:	74bc      	beqz.n	a4, 4200f934 <_vfprintf_r+0x1784>
4200f8fb:	0ba267        	bge	a2, a6, 4200f90a <_vfprintf_r+0x175a>
4200f8fe:	10c162        	addi	a6, a1, 16
4200f901:	b02260        	addx8	a2, a2, a6
4200f904:	001232        	l16ui	a3, a2, 0
4200f907:	005d06        	j	4200fa7f <_vfprintf_r+0x18cf>
4200f90a:	5ca282        	movi	a8, 0x25c
4200f90d:	10c1a2        	addi	a10, a1, 16
4200f910:	418a      	add.n	a4, a1, a8
4200f912:	50a2d2        	movi	a13, 0x250
4200f915:	60a2c2        	movi	a12, 0x260
4200f918:	01daf2        	addmi	a15, a10, 0x100
4200f91b:	0aed      	mov.n	a14, a10
4200f91d:	dada      	add.n	a13, a10, a13
4200f91f:	caca      	add.n	a12, a10, a12
4200f921:	03bd      	mov.n	a11, a3
4200f923:	0149      	s32i.n	a4, a1, 0
4200f925:	02ad      	mov.n	a10, a2
4200f927:	b96192        	s32i	a9, a1, 0x2e4
4200f92a:	fe38e5        	call8	4200dcb8 <get_arg$constprop$0>
4200f92d:	001a32        	l16ui	a3, a10, 0
4200f930:	005d86        	j	4200faaa <_vfprintf_r+0x18fa>
4200f933:	00          	.byte 00
4200f934:	9f2132        	l32i	a3, a1, 0x27c
4200f937:	10c142        	addi	a4, a1, 16
4200f93a:	531b      	addi.n	a5, a3, 1
4200f93c:	b02240        	addx8	a2, a2, a4
4200f93f:	652367        	blt	a3, a6, 4200f9a8 <_vfprintf_r+0x17f8>
4200f942:	10c182        	addi	a8, a1, 16
4200f945:	9a2872        	l32i	a7, a8, 0x268
4200f948:	02d822        	addmi	a2, a8, 0x200
4200f94b:	f81c      	movi.n	a8, 31
4200f94d:	374b      	addi.n	a3, a7, 4
4200f94f:	841c      	movi.n	a4, 24
4200f951:	332867        	blt	a8, a6, 4200f988 <_vfprintf_r+0x17d8>
4200f954:	861b      	addi.n	a8, a6, 1
4200f956:	986182        	s32i	a8, a1, 0x260
4200f959:	1a6232        	s32i	a3, a2, 104
4200f95c:	052437        	blt	a4, a3, 4200f965 <_vfprintf_r+0x17b5>
4200f95f:	192222        	l32i	a2, a2, 100
4200f962:	000286        	j	4200f970 <_vfprintf_r+0x17c0>
4200f965:	012477        	blt	a4, a7, 4200f96a <_vfprintf_r+0x17ba>
4200f968:	432c      	movi.n	a3, 36
4200f96a:	9c2122        	l32i	a2, a1, 0x270
4200f96d:	9e6132        	s32i	a3, a1, 0x278
4200f970:	9e2132        	l32i	a3, a1, 0x278
4200f973:	10c1b2        	addi	a11, a1, 16
4200f976:	223a      	add.n	a2, a2, a3
4200f978:	fcc222        	addi	a2, a2, -4
4200f97b:	0238      	l32i.n	a3, a2, 0
4200f97d:	b026b0        	addx8	a2, a6, a11
4200f980:	0239      	s32i.n	a3, a2, 0
4200f982:	f43030        	extui	a3, a3, 0, 16
4200f985:	006746        	j	4200fb26 <_vfprintf_r+0x1976>
4200f988:	1a6232        	s32i	a3, a2, 104
4200f98b:	052437        	blt	a4, a3, 4200f994 <_vfprintf_r+0x17e4>
4200f98e:	192222        	l32i	a2, a2, 100
4200f991:	000286        	j	4200f99f <_vfprintf_r+0x17ef>
4200f994:	012477        	blt	a4, a7, 4200f999 <_vfprintf_r+0x17e9>
4200f997:	432c      	movi.n	a3, 36
4200f999:	9c2122        	l32i	a2, a1, 0x270
4200f99c:	9e6132        	s32i	a3, a1, 0x278
4200f99f:	9e2132        	l32i	a3, a1, 0x278
4200f9a2:	802230        	add	a2, a2, a3
4200f9a5:	fcc222        	addi	a2, a2, -4
4200f9a8:	001232        	l16ui	a3, a2, 0
4200f9ab:	005dc6        	j	4200fb26 <_vfprintf_r+0x1976>
4200f9ae:	00          	.byte 00
4200f9af:	00          	.byte 00
4200f9b0:	a02152        	l32i	a5, a1, 0x280
4200f9b3:	02e597        	bbsi	a5, 9, 4200f9b9 <_vfprintf_r+0x1809>
4200f9b6:	002e06        	j	4200fa72 <_vfprintf_r+0x18c2>
4200f9b9:	b4bc      	beqz.n	a4, 4200f9f8 <_vfprintf_r+0x1848>
4200f9bb:	0ea267        	bge	a2, a6, 4200f9cd <_vfprintf_r+0x181d>
4200f9be:	10c162        	addi	a6, a1, 16
4200f9c1:	b02260        	addx8	a2, a2, a6
4200f9c4:	000232        	l8ui	a3, a2, 0
4200f9c7:	002d06        	j	4200fa7f <_vfprintf_r+0x18cf>
4200f9ca:	00          	.byte 00
4200f9cb:	00          	.byte 00
4200f9cc:	00          	.byte 00
4200f9cd:	5ca282        	movi	a8, 0x25c
4200f9d0:	10c1a2        	addi	a10, a1, 16
4200f9d3:	418a      	add.n	a4, a1, a8
4200f9d5:	50a2d2        	movi	a13, 0x250
4200f9d8:	60a2c2        	movi	a12, 0x260
4200f9db:	01daf2        	addmi	a15, a10, 0x100
4200f9de:	0aed      	mov.n	a14, a10
4200f9e0:	dada      	add.n	a13, a10, a13
4200f9e2:	caca      	add.n	a12, a10, a12
4200f9e4:	03bd      	mov.n	a11, a3
4200f9e6:	0149      	s32i.n	a4, a1, 0
4200f9e8:	02ad      	mov.n	a10, a2
4200f9ea:	b96192        	s32i	a9, a1, 0x2e4
4200f9ed:	fe2ca5        	call8	4200dcb8 <get_arg$constprop$0>
4200f9f0:	000a32        	l8ui	a3, a10, 0
4200f9f3:	002cc6        	j	4200faaa <_vfprintf_r+0x18fa>
4200f9f6:	00          	.byte 00
4200f9f7:	00          	.byte 00
4200f9f8:	9f2132        	l32i	a3, a1, 0x27c
4200f9fb:	10c142        	addi	a4, a1, 16
4200f9fe:	531b      	addi.n	a5, a3, 1
4200fa00:	b02240        	addx8	a2, a2, a4
4200fa03:	652367        	blt	a3, a6, 4200fa6c <_vfprintf_r+0x18bc>
4200fa06:	10c182        	addi	a8, a1, 16
4200fa09:	9a2872        	l32i	a7, a8, 0x268
4200fa0c:	02d822        	addmi	a2, a8, 0x200
4200fa0f:	f81c      	movi.n	a8, 31
4200fa11:	374b      	addi.n	a3, a7, 4
4200fa13:	841c      	movi.n	a4, 24
4200fa15:	332867        	blt	a8, a6, 4200fa4c <_vfprintf_r+0x189c>
4200fa18:	861b      	addi.n	a8, a6, 1
4200fa1a:	986182        	s32i	a8, a1, 0x260
4200fa1d:	1a6232        	s32i	a3, a2, 104
4200fa20:	052437        	blt	a4, a3, 4200fa29 <_vfprintf_r+0x1879>
4200fa23:	192222        	l32i	a2, a2, 100
4200fa26:	000286        	j	4200fa34 <_vfprintf_r+0x1884>
4200fa29:	012477        	blt	a4, a7, 4200fa2e <_vfprintf_r+0x187e>
4200fa2c:	432c      	movi.n	a3, 36
4200fa2e:	9c2122        	l32i	a2, a1, 0x270
4200fa31:	9e6132        	s32i	a3, a1, 0x278
4200fa34:	9e2132        	l32i	a3, a1, 0x278
4200fa37:	10c1b2        	addi	a11, a1, 16
4200fa3a:	223a      	add.n	a2, a2, a3
4200fa3c:	fcc222        	addi	a2, a2, -4
4200fa3f:	0238      	l32i.n	a3, a2, 0
4200fa41:	b026b0        	addx8	a2, a6, a11
4200fa44:	0239      	s32i.n	a3, a2, 0
4200fa46:	743030        	extui	a3, a3, 0, 8
4200fa49:	003646        	j	4200fb26 <_vfprintf_r+0x1976>
4200fa4c:	1a6232        	s32i	a3, a2, 104
4200fa4f:	052437        	blt	a4, a3, 4200fa58 <_vfprintf_r+0x18a8>
4200fa52:	192222        	l32i	a2, a2, 100
4200fa55:	000286        	j	4200fa63 <_vfprintf_r+0x18b3>
4200fa58:	012477        	blt	a4, a7, 4200fa5d <_vfprintf_r+0x18ad>
4200fa5b:	432c      	movi.n	a3, 36
4200fa5d:	9c2122        	l32i	a2, a1, 0x270
4200fa60:	9e6132        	s32i	a3, a1, 0x278
4200fa63:	9e2132        	l32i	a3, a1, 0x278
4200fa66:	802230        	add	a2, a2, a3
4200fa69:	fcc222        	addi	a2, a2, -4
4200fa6c:	000232        	l8ui	a3, a2, 0
4200fa6f:	002cc6        	j	4200fb26 <_vfprintf_r+0x1976>
4200fa72:	e4bc      	beqz.n	a4, 4200fab4 <_vfprintf_r+0x1904>
4200fa74:	0da267        	bge	a2, a6, 4200fa85 <_vfprintf_r+0x18d5>
4200fa77:	10c132        	addi	a3, a1, 16
4200fa7a:	b02230        	addx8	a2, a2, a3
4200fa7d:	0238      	l32i.n	a3, a2, 0
4200fa7f:	9f2152        	l32i	a5, a1, 0x27c
4200fa82:	002806        	j	4200fb26 <_vfprintf_r+0x1976>
4200fa85:	5ca252        	movi	a5, 0x25c
4200fa88:	10c162        	addi	a6, a1, 16
4200fa8b:	415a      	add.n	a4, a1, a5
4200fa8d:	0149      	s32i.n	a4, a1, 0
4200fa8f:	01d6f2        	addmi	a15, a6, 0x100
4200fa92:	50a2d2        	movi	a13, 0x250
4200fa95:	06ed      	mov.n	a14, a6
4200fa97:	60a2c2        	movi	a12, 0x260
4200fa9a:	03bd      	mov.n	a11, a3
4200fa9c:	deda      	add.n	a13, a14, a13
4200fa9e:	ceca      	add.n	a12, a14, a12
4200faa0:	02ad      	mov.n	a10, a2
4200faa2:	b96192        	s32i	a9, a1, 0x2e4
4200faa5:	fe2125        	call8	4200dcb8 <get_arg$constprop$0>
4200faa8:	0a38      	l32i.n	a3, a10, 0
4200faaa:	9f2152        	l32i	a5, a1, 0x27c
4200faad:	b92192        	l32i	a9, a1, 0x2e4
4200fab0:	001c86        	j	4200fb26 <_vfprintf_r+0x1976>
4200fab3:	00          	.byte 00
4200fab4:	9f2182        	l32i	a8, a1, 0x27c
4200fab7:	10c1a2        	addi	a10, a1, 16
4200faba:	581b      	addi.n	a5, a8, 1
4200fabc:	b022a0        	addx8	a2, a2, a10
4200fabf:	612867        	blt	a8, a6, 4200fb24 <_vfprintf_r+0x1974>
4200fac2:	10c1b2        	addi	a11, a1, 16
4200fac5:	9a2b72        	l32i	a7, a11, 0x268
4200fac8:	f81c      	movi.n	a8, 31
4200faca:	02db22        	addmi	a2, a11, 0x200
4200facd:	374b      	addi.n	a3, a7, 4
4200facf:	841c      	movi.n	a4, 24
4200fad1:	302867        	blt	a8, a6, 4200fb05 <_vfprintf_r+0x1955>
4200fad4:	861b      	addi.n	a8, a6, 1
4200fad6:	986182        	s32i	a8, a1, 0x260
4200fad9:	1a6232        	s32i	a3, a2, 104
4200fadc:	052437        	blt	a4, a3, 4200fae5 <_vfprintf_r+0x1935>
4200fadf:	192222        	l32i	a2, a2, 100
4200fae2:	000286        	j	4200faf0 <_vfprintf_r+0x1940>
4200fae5:	012477        	blt	a4, a7, 4200faea <_vfprintf_r+0x193a>
4200fae8:	432c      	movi.n	a3, 36
4200faea:	9c2122        	l32i	a2, a1, 0x270
4200faed:	9e6132        	s32i	a3, a1, 0x278
4200faf0:	9e2132        	l32i	a3, a1, 0x278
4200faf3:	223a      	add.n	a2, a2, a3
4200faf5:	fcc222        	addi	a2, a2, -4
4200faf8:	0238      	l32i.n	a3, a2, 0
4200fafa:	10c122        	addi	a2, a1, 16
4200fafd:	b06620        	addx8	a6, a6, a2
4200fb00:	0639      	s32i.n	a3, a6, 0
4200fb02:	000806        	j	4200fb26 <_vfprintf_r+0x1976>
4200fb05:	1a6232        	s32i	a3, a2, 104
4200fb08:	052437        	blt	a4, a3, 4200fb11 <_vfprintf_r+0x1961>
4200fb0b:	192222        	l32i	a2, a2, 100
4200fb0e:	000286        	j	4200fb1c <_vfprintf_r+0x196c>
4200fb11:	012477        	blt	a4, a7, 4200fb16 <_vfprintf_r+0x1966>
4200fb14:	432c      	movi.n	a3, 36
4200fb16:	9c2122        	l32i	a2, a1, 0x270
4200fb19:	9e6132        	s32i	a3, a1, 0x278
4200fb1c:	9e2132        	l32i	a3, a1, 0x278
4200fb1f:	223a      	add.n	a2, a2, a3
4200fb21:	fcc222        	addi	a2, a2, -4
4200fb24:	0238      	l32i.n	a3, a2, 0
4200fb26:	040c      	movi.n	a4, 0
4200fb28:	a02162        	l32i	a6, a1, 0x280
4200fb2b:	ffab22        	movi	a2, 0xfffffbff
4200fb2e:	106620        	and	a6, a6, a2
4200fb31:	a06162        	s32i	a6, a1, 0x280
4200fb34:	020c      	movi.n	a2, 0
4200fb36:	026206        	j	420104c2 <_vfprintf_r+0x2312>
4200fb39:	00          	.byte 00
4200fb3a:	00          	.byte 00
4200fb3b:	982162        	l32i	a6, a1, 0x260
4200fb3e:	e4bc      	beqz.n	a4, 4200fb80 <_vfprintf_r+0x19d0>
4200fb40:	0da267        	bge	a2, a6, 4200fb51 <_vfprintf_r+0x19a1>
4200fb43:	10c182        	addi	a8, a1, 16
4200fb46:	b02280        	addx8	a2, a2, a8
4200fb49:	0238      	l32i.n	a3, a2, 0
4200fb4b:	9f2152        	l32i	a5, a1, 0x27c
4200fb4e:	002806        	j	4200fbf2 <_vfprintf_r+0x1a42>
4200fb51:	5ca2a2        	movi	a10, 0x25c
4200fb54:	10c1b2        	addi	a11, a1, 16
4200fb57:	41aa      	add.n	a4, a1, a10
4200fb59:	50a2d2        	movi	a13, 0x250
4200fb5c:	60a2c2        	movi	a12, 0x260
4200fb5f:	01dbf2        	addmi	a15, a11, 0x100
4200fb62:	0bed      	mov.n	a14, a11
4200fb64:	dbda      	add.n	a13, a11, a13
4200fb66:	cbca      	add.n	a12, a11, a12
4200fb68:	0149      	s32i.n	a4, a1, 0
4200fb6a:	03bd      	mov.n	a11, a3
4200fb6c:	02ad      	mov.n	a10, a2
4200fb6e:	b96192        	s32i	a9, a1, 0x2e4
4200fb71:	fe1465        	call8	4200dcb8 <get_arg$constprop$0>
4200fb74:	0a38      	l32i.n	a3, a10, 0
4200fb76:	9f2152        	l32i	a5, a1, 0x27c
4200fb79:	b92192        	l32i	a9, a1, 0x2e4
4200fb7c:	001c86        	j	4200fbf2 <_vfprintf_r+0x1a42>
4200fb7f:	00          	.byte 00
4200fb80:	9f2132        	l32i	a3, a1, 0x27c
4200fb83:	10c142        	addi	a4, a1, 16
4200fb86:	531b      	addi.n	a5, a3, 1
4200fb88:	b02240        	addx8	a2, a2, a4
4200fb8b:	612367        	blt	a3, a6, 4200fbf0 <_vfprintf_r+0x1a40>
4200fb8e:	10c182        	addi	a8, a1, 16
4200fb91:	9a2872        	l32i	a7, a8, 0x268
4200fb94:	02d822        	addmi	a2, a8, 0x200
4200fb97:	f81c      	movi.n	a8, 31
4200fb99:	374b      	addi.n	a3, a7, 4
4200fb9b:	841c      	movi.n	a4, 24
4200fb9d:	302867        	blt	a8, a6, 4200fbd1 <_vfprintf_r+0x1a21>
4200fba0:	861b      	addi.n	a8, a6, 1
4200fba2:	986182        	s32i	a8, a1, 0x260
4200fba5:	1a6232        	s32i	a3, a2, 104
4200fba8:	052437        	blt	a4, a3, 4200fbb1 <_vfprintf_r+0x1a01>
4200fbab:	192222        	l32i	a2, a2, 100
4200fbae:	000286        	j	4200fbbc <_vfprintf_r+0x1a0c>
4200fbb1:	012477        	blt	a4, a7, 4200fbb6 <_vfprintf_r+0x1a06>
4200fbb4:	432c      	movi.n	a3, 36
4200fbb6:	9c2122        	l32i	a2, a1, 0x270
4200fbb9:	9e6132        	s32i	a3, a1, 0x278
4200fbbc:	9e2132        	l32i	a3, a1, 0x278
4200fbbf:	10c1b2        	addi	a11, a1, 16
4200fbc2:	223a      	add.n	a2, a2, a3
4200fbc4:	fcc222        	addi	a2, a2, -4
4200fbc7:	0238      	l32i.n	a3, a2, 0
4200fbc9:	b066b0        	addx8	a6, a6, a11
4200fbcc:	0639      	s32i.n	a3, a6, 0
4200fbce:	000806        	j	4200fbf2 <_vfprintf_r+0x1a42>
4200fbd1:	1a6232        	s32i	a3, a2, 104
4200fbd4:	052437        	blt	a4, a3, 4200fbdd <_vfprintf_r+0x1a2d>
4200fbd7:	192222        	l32i	a2, a2, 100
4200fbda:	000286        	j	4200fbe8 <_vfprintf_r+0x1a38>
4200fbdd:	012477        	blt	a4, a7, 4200fbe2 <_vfprintf_r+0x1a32>
4200fbe0:	432c      	movi.n	a3, 36
4200fbe2:	9c2122        	l32i	a2, a1, 0x270
4200fbe5:	9e6132        	s32i	a3, a1, 0x278
4200fbe8:	9e2132        	l32i	a3, a1, 0x278
4200fbeb:	223a      	add.n	a2, a2, a3
4200fbed:	fcc222        	addi	a2, a2, -4
4200fbf0:	0238      	l32i.n	a3, a2, 0
4200fbf2:	a02162        	l32i	a6, a1, 0x280
4200fbf5:	220c      	movi.n	a2, 2
4200fbf7:	206620        	or	a6, a6, a2
4200fbfa:	10c182        	addi	a8, a1, 16
4200fbfd:	073c      	movi.n	a7, 48
4200fbff:	a06162        	s32i	a6, a1, 0x280
4200fc02:	02d862        	addmi	a6, a8, 0x200
4200fc05:	544672        	s8i	a7, a6, 84
4200fc08:	78a072        	movi	a7, 120
4200fc0b:	554672        	s8i	a7, a6, 85
4200fc0e:	c40b61        	l32r	a6, 42000c3c <_stext+0xc1c>
4200fc11:	78a082        	movi	a8, 120
4200fc14:	040c      	movi.n	a4, 0
4200fc16:	b46162        	s32i	a6, a1, 0x2d0
4200fc19:	a76182        	s32i	a8, a1, 0x29c
4200fc1c:	022886        	j	420104c2 <_vfprintf_r+0x2312>
4200fc1f:	982152        	l32i	a5, a1, 0x260
4200fc22:	b4bc      	beqz.n	a4, 4200fc61 <_vfprintf_r+0x1ab1>
4200fc24:	0da257        	bge	a2, a5, 4200fc35 <_vfprintf_r+0x1a85>
4200fc27:	10c1a2        	addi	a10, a1, 16
4200fc2a:	b022a0        	addx8	a2, a2, a10
4200fc2d:	0228      	l32i.n	a2, a2, 0
4200fc2f:	a26122        	s32i	a2, a1, 0x288
4200fc32:	002a86        	j	4200fce0 <_vfprintf_r+0x1b30>
4200fc35:	5ca2b2        	movi	a11, 0x25c
4200fc38:	10c1e2        	addi	a14, a1, 16
4200fc3b:	41ba      	add.n	a4, a1, a11
4200fc3d:	50a2d2        	movi	a13, 0x250
4200fc40:	60a2c2        	movi	a12, 0x260
4200fc43:	0149      	s32i.n	a4, a1, 0
4200fc45:	01def2        	addmi	a15, a14, 0x100
4200fc48:	deda      	add.n	a13, a14, a13
4200fc4a:	ceca      	add.n	a12, a14, a12
4200fc4c:	03bd      	mov.n	a11, a3
4200fc4e:	02ad      	mov.n	a10, a2
4200fc50:	b96192        	s32i	a9, a1, 0x2e4
4200fc53:	fe0665        	call8	4200dcb8 <get_arg$constprop$0>
4200fc56:	0aa8      	l32i.n	a10, a10, 0
4200fc58:	b92192        	l32i	a9, a1, 0x2e4
4200fc5b:	a261a2        	s32i	a10, a1, 0x288
4200fc5e:	001f86        	j	4200fce0 <_vfprintf_r+0x1b30>
4200fc61:	9f2132        	l32i	a3, a1, 0x27c
4200fc64:	10c142        	addi	a4, a1, 16
4200fc67:	631b      	addi.n	a6, a3, 1
4200fc69:	b02240        	addx8	a2, a2, a4
4200fc6c:	682357        	blt	a3, a5, 4200fcd8 <_vfprintf_r+0x1b28>
4200fc6f:	10c182        	addi	a8, a1, 16
4200fc72:	9a2872        	l32i	a7, a8, 0x268
4200fc75:	02d822        	addmi	a2, a8, 0x200
4200fc78:	f81c      	movi.n	a8, 31
4200fc7a:	374b      	addi.n	a3, a7, 4
4200fc7c:	841c      	movi.n	a4, 24
4200fc7e:	362857        	blt	a8, a5, 4200fcb8 <_vfprintf_r+0x1b08>
4200fc81:	851b      	addi.n	a8, a5, 1
4200fc83:	986182        	s32i	a8, a1, 0x260
4200fc86:	1a6232        	s32i	a3, a2, 104
4200fc89:	072437        	blt	a4, a3, 4200fc94 <_vfprintf_r+0x1ae4>
4200fc8c:	192222        	l32i	a2, a2, 100
4200fc8f:	000306        	j	4200fc9f <_vfprintf_r+0x1aef>
4200fc92:	00          	.byte 00
4200fc93:	00          	.byte 00
4200fc94:	012477        	blt	a4, a7, 4200fc99 <_vfprintf_r+0x1ae9>
4200fc97:	432c      	movi.n	a3, 36
4200fc99:	9c2122        	l32i	a2, a1, 0x270
4200fc9c:	9e6132        	s32i	a3, a1, 0x278
4200fc9f:	9e2132        	l32i	a3, a1, 0x278
4200fca2:	10c1b2        	addi	a11, a1, 16
4200fca5:	223a      	add.n	a2, a2, a3
4200fca7:	fcc222        	addi	a2, a2, -4
4200fcaa:	0228      	l32i.n	a2, a2, 0
4200fcac:	b055b0        	addx8	a5, a5, a11
4200fcaf:	a26122        	s32i	a2, a1, 0x288
4200fcb2:	0529      	s32i.n	a2, a5, 0
4200fcb4:	000946        	j	4200fcdd <_vfprintf_r+0x1b2d>
4200fcb7:	00          	.byte 00
4200fcb8:	1a6232        	s32i	a3, a2, 104
4200fcbb:	052437        	blt	a4, a3, 4200fcc4 <_vfprintf_r+0x1b14>
4200fcbe:	192222        	l32i	a2, a2, 100
4200fcc1:	000286        	j	4200fccf <_vfprintf_r+0x1b1f>
4200fcc4:	012477        	blt	a4, a7, 4200fcc9 <_vfprintf_r+0x1b19>
4200fcc7:	432c      	movi.n	a3, 36
4200fcc9:	9c2122        	l32i	a2, a1, 0x270
4200fccc:	9e6132        	s32i	a3, a1, 0x278
4200fccf:	9e2132        	l32i	a3, a1, 0x278
4200fcd2:	802230        	add	a2, a2, a3
4200fcd5:	fcc222        	addi	a2, a2, -4
4200fcd8:	0228      	l32i.n	a2, a2, 0
4200fcda:	a26122        	s32i	a2, a1, 0x288
4200fcdd:	9f6162        	s32i	a6, a1, 0x27c
4200fce0:	10c132        	addi	a3, a1, 16
4200fce3:	02d322        	addmi	a2, a3, 0x200
4200fce6:	a42142        	l32i	a4, a1, 0x290
4200fce9:	030c      	movi.n	a3, 0
4200fceb:	564232        	s8i	a3, a2, 86
4200fcee:	320426        	beqi	a4, -1, 4200fd24 <_vfprintf_r+0x1b74>
4200fcf1:	a221a2        	l32i	a10, a1, 0x288
4200fcf4:	04cd      	mov.n	a12, a4
4200fcf6:	0b0c      	movi.n	a11, 0
4200fcf8:	b96192        	s32i	a9, a1, 0x2e4
4200fcfb:	c3a681        	l32r	a8, 42000b94 <_stext+0xb74>
4200fcfe:	0008e0        	callx8	a8
4200fd01:	a561a2        	s32i	a10, a1, 0x294
4200fd04:	b92192        	l32i	a9, a1, 0x2e4
4200fd07:	a52152        	l32i	a5, a1, 0x294
4200fd0a:	1acc      	bnez.n	a10, 4200fd0f <_vfprintf_r+0x1b5f>
4200fd0c:	027e86        	j	4201070a <_vfprintf_r+0x255a>
4200fd0f:	a22152        	l32i	a5, a1, 0x288
4200fd12:	060c      	movi.n	a6, 0
4200fd14:	c05a50        	sub	a5, a10, a5
4200fd17:	a46152        	s32i	a5, a1, 0x290
4200fd1a:	a56162        	s32i	a6, a1, 0x294
4200fd1d:	065d      	mov.n	a5, a6
4200fd1f:	0279c6        	j	4201070a <_vfprintf_r+0x255a>
4200fd22:	00          	.byte 00
4200fd23:	00          	.byte 00
4200fd24:	a221a2        	l32i	a10, a1, 0x288
4200fd27:	b96192        	s32i	a9, a1, 0x2e4
4200fd2a:	c25a81        	l32r	a8, 42000694 <_stext+0x674>
4200fd2d:	0008e0        	callx8	a8
4200fd30:	080c      	movi.n	a8, 0
4200fd32:	b92192        	l32i	a9, a1, 0x2e4
4200fd35:	a461a2        	s32i	a10, a1, 0x290
4200fd38:	a56182        	s32i	a8, a1, 0x294
4200fd3b:	085d      	mov.n	a5, a8
4200fd3d:	083d      	mov.n	a3, a8
4200fd3f:	084d      	mov.n	a4, a8
4200fd41:	082d      	mov.n	a2, a8
4200fd43:	027246        	j	42010710 <_vfprintf_r+0x2560>
4200fd46:	00          	.byte 00
4200fd47:	a02162        	l32i	a6, a1, 0x280
4200fd4a:	051c      	movi.n	a5, 16
4200fd4c:	206650        	or	a6, a6, a5
4200fd4f:	a06162        	s32i	a6, a1, 0x280
4200fd52:	a02182        	l32i	a8, a1, 0x280
4200fd55:	982162        	l32i	a6, a1, 0x260
4200fd58:	02e857        	bbsi	a8, 5, 4200fd5e <_vfprintf_r+0x1bae>
4200fd5b:	003246        	j	4200fe28 <_vfprintf_r+0x1c78>
4200fd5e:	042416        	beqz	a4, 4200fda4 <_vfprintf_r+0x1bf4>
4200fd61:	0fa267        	bge	a2, a6, 4200fd74 <_vfprintf_r+0x1bc4>
4200fd64:	10c1a2        	addi	a10, a1, 16
4200fd67:	b022a0        	addx8	a2, a2, a10
4200fd6a:	0238      	l32i.n	a3, a2, 0
4200fd6c:	1248      	l32i.n	a4, a2, 4
4200fd6e:	9f2152        	l32i	a5, a1, 0x27c
4200fd71:	00af06        	j	42010031 <_vfprintf_r+0x1e81>
4200fd74:	5ca2b2        	movi	a11, 0x25c
4200fd77:	10c1e2        	addi	a14, a1, 16
4200fd7a:	41ba      	add.n	a4, a1, a11
4200fd7c:	50a2d2        	movi	a13, 0x250
4200fd7f:	60a2c2        	movi	a12, 0x260
4200fd82:	0149      	s32i.n	a4, a1, 0
4200fd84:	03bd      	mov.n	a11, a3
4200fd86:	02ad      	mov.n	a10, a2
4200fd88:	01def2        	addmi	a15, a14, 0x100
4200fd8b:	deda      	add.n	a13, a14, a13
4200fd8d:	ceca      	add.n	a12, a14, a12
4200fd8f:	b96192        	s32i	a9, a1, 0x2e4
4200fd92:	fdf265        	call8	4200dcb8 <get_arg$constprop$0>
4200fd95:	0a38      	l32i.n	a3, a10, 0
4200fd97:	1a48      	l32i.n	a4, a10, 4
4200fd99:	9f2152        	l32i	a5, a1, 0x27c
4200fd9c:	b92192        	l32i	a9, a1, 0x2e4
4200fd9f:	120c      	movi.n	a2, 1
4200fda1:	01c746        	j	420104c2 <_vfprintf_r+0x2312>
4200fda4:	9f2132        	l32i	a3, a1, 0x27c
4200fda7:	10c142        	addi	a4, a1, 16
4200fdaa:	531b      	addi.n	a5, a3, 1
4200fdac:	b02240        	addx8	a2, a2, a4
4200fdaf:	6d2367        	blt	a3, a6, 4200fe20 <_vfprintf_r+0x1c70>
4200fdb2:	10c182        	addi	a8, a1, 16
4200fdb5:	9a2842        	l32i	a4, a8, 0x268
4200fdb8:	837c      	movi.n	a3, -8
4200fdba:	447b      	addi.n	a4, a4, 7
4200fdbc:	02d822        	addmi	a2, a8, 0x200
4200fdbf:	104430        	and	a4, a4, a3
4200fdc2:	f81c      	movi.n	a8, 31
4200fdc4:	348b      	addi.n	a3, a4, 8
4200fdc6:	871c      	movi.n	a7, 24
4200fdc8:	342867        	blt	a8, a6, 4200fe00 <_vfprintf_r+0x1c50>
4200fdcb:	861b      	addi.n	a8, a6, 1
4200fdcd:	986182        	s32i	a8, a1, 0x260
4200fdd0:	1a6232        	s32i	a3, a2, 104
4200fdd3:	052737        	blt	a7, a3, 4200fddc <_vfprintf_r+0x1c2c>
4200fdd6:	192222        	l32i	a2, a2, 100
4200fdd9:	000286        	j	4200fde7 <_vfprintf_r+0x1c37>
4200fddc:	012747        	blt	a7, a4, 4200fde1 <_vfprintf_r+0x1c31>
4200fddf:	832c      	movi.n	a3, 40
4200fde1:	9c2122        	l32i	a2, a1, 0x270
4200fde4:	9e6132        	s32i	a3, a1, 0x278
4200fde7:	9e2132        	l32i	a3, a1, 0x278
4200fdea:	10c1b2        	addi	a11, a1, 16
4200fded:	223a      	add.n	a2, a2, a3
4200fdef:	f8c222        	addi	a2, a2, -8
4200fdf2:	0238      	l32i.n	a3, a2, 0
4200fdf4:	1248      	l32i.n	a4, a2, 4
4200fdf6:	b026b0        	addx8	a2, a6, a11
4200fdf9:	0239      	s32i.n	a3, a2, 0
4200fdfb:	1249      	s32i.n	a4, a2, 4
4200fdfd:	008c06        	j	42010031 <_vfprintf_r+0x1e81>
4200fe00:	1a6232        	s32i	a3, a2, 104
4200fe03:	052737        	blt	a7, a3, 4200fe0c <_vfprintf_r+0x1c5c>
4200fe06:	192222        	l32i	a2, a2, 100
4200fe09:	000286        	j	4200fe17 <_vfprintf_r+0x1c67>
4200fe0c:	012747        	blt	a7, a4, 4200fe11 <_vfprintf_r+0x1c61>
4200fe0f:	832c      	movi.n	a3, 40
4200fe11:	9c2122        	l32i	a2, a1, 0x270
4200fe14:	9e6132        	s32i	a3, a1, 0x278
4200fe17:	9e2132        	l32i	a3, a1, 0x278
4200fe1a:	802230        	add	a2, a2, a3
4200fe1d:	f8c222        	addi	a2, a2, -8
4200fe20:	0238      	l32i.n	a3, a2, 0
4200fe22:	1248      	l32i.n	a4, a2, 4
4200fe24:	008246        	j	42010031 <_vfprintf_r+0x1e81>
4200fe27:	00          	.byte 00
4200fe28:	a02152        	l32i	a5, a1, 0x280
4200fe2b:	796547        	bbci	a5, 4, 4200fea8 <_vfprintf_r+0x1cf8>
4200fe2e:	f49c      	beqz.n	a4, 4200fe51 <_vfprintf_r+0x1ca1>
4200fe30:	08a267        	bge	a2, a6, 4200fe3c <_vfprintf_r+0x1c8c>
4200fe33:	10c162        	addi	a6, a1, 16
4200fe36:	b02260        	addx8	a2, a2, a6
4200fe39:	008106        	j	42010041 <_vfprintf_r+0x1e91>
4200fe3c:	5ca282        	movi	a8, 0x25c
4200fe3f:	10c1a2        	addi	a10, a1, 16
4200fe42:	418a      	add.n	a4, a1, a8
4200fe44:	0149      	s32i.n	a4, a1, 0
4200fe46:	01daf2        	addmi	a15, a10, 0x100
4200fe49:	50a2d2        	movi	a13, 0x250
4200fe4c:	0aed      	mov.n	a14, a10
4200fe4e:	008246        	j	4201005b <_vfprintf_r+0x1eab>
4200fe51:	9f2132        	l32i	a3, a1, 0x27c
4200fe54:	10c142        	addi	a4, a1, 16
4200fe57:	531b      	addi.n	a5, a3, 1
4200fe59:	b02240        	addx8	a2, a2, a4
4200fe5c:	02a367        	bge	a3, a6, 4200fe62 <_vfprintf_r+0x1cb2>
4200fe5f:	00a046        	j	420100e4 <_vfprintf_r+0x1f34>
4200fe62:	10c182        	addi	a8, a1, 16
4200fe65:	9a2872        	l32i	a7, a8, 0x268
4200fe68:	02d822        	addmi	a2, a8, 0x200
4200fe6b:	f81c      	movi.n	a8, 31
4200fe6d:	374b      	addi.n	a3, a7, 4
4200fe6f:	841c      	movi.n	a4, 24
4200fe71:	02a867        	bge	a8, a6, 4200fe77 <_vfprintf_r+0x1cc7>
4200fe74:	009306        	j	420100c4 <_vfprintf_r+0x1f14>
4200fe77:	861b      	addi.n	a8, a6, 1
4200fe79:	986182        	s32i	a8, a1, 0x260
4200fe7c:	1a6232        	s32i	a3, a2, 104
4200fe7f:	052437        	blt	a4, a3, 4200fe88 <_vfprintf_r+0x1cd8>
4200fe82:	192222        	l32i	a2, a2, 100
4200fe85:	000286        	j	4200fe93 <_vfprintf_r+0x1ce3>
4200fe88:	012477        	blt	a4, a7, 4200fe8d <_vfprintf_r+0x1cdd>
4200fe8b:	432c      	movi.n	a3, 36
4200fe8d:	9c2122        	l32i	a2, a1, 0x270
4200fe90:	9e6132        	s32i	a3, a1, 0x278
4200fe93:	9e2132        	l32i	a3, a1, 0x278
4200fe96:	10c1b2        	addi	a11, a1, 16
4200fe99:	223a      	add.n	a2, a2, a3
4200fe9b:	fcc222        	addi	a2, a2, -4
4200fe9e:	0238      	l32i.n	a3, a2, 0
4200fea0:	b026b0        	addx8	a2, a6, a11
4200fea3:	0239      	s32i.n	a3, a2, 0
4200fea5:	006186        	j	4201002f <_vfprintf_r+0x1e7f>
4200fea8:	a02152        	l32i	a5, a1, 0x280
4200feab:	02e567        	bbsi	a5, 6, 4200feb1 <_vfprintf_r+0x1d01>
4200feae:	002e86        	j	4200ff6c <_vfprintf_r+0x1dbc>
4200feb1:	b4bc      	beqz.n	a4, 4200fef0 <_vfprintf_r+0x1d40>
4200feb3:	0ea267        	bge	a2, a6, 4200fec5 <_vfprintf_r+0x1d15>
4200feb6:	10c162        	addi	a6, a1, 16
4200feb9:	b02260        	addx8	a2, a2, a6
4200febc:	001232        	l16ui	a3, a2, 0
4200febf:	003006        	j	4200ff83 <_vfprintf_r+0x1dd3>
4200fec2:	00          	.byte 00
4200fec3:	00          	.byte 00
4200fec4:	00          	.byte 00
4200fec5:	5ca282        	movi	a8, 0x25c
4200fec8:	10c1a2        	addi	a10, a1, 16
4200fecb:	418a      	add.n	a4, a1, a8
4200fecd:	50a2d2        	movi	a13, 0x250
4200fed0:	60a2c2        	movi	a12, 0x260
4200fed3:	01daf2        	addmi	a15, a10, 0x100
4200fed6:	0aed      	mov.n	a14, a10
4200fed8:	dada      	add.n	a13, a10, a13
4200feda:	caca      	add.n	a12, a10, a12
4200fedc:	03bd      	mov.n	a11, a3
4200fede:	0149      	s32i.n	a4, a1, 0
4200fee0:	02ad      	mov.n	a10, a2
4200fee2:	b96192        	s32i	a9, a1, 0x2e4
4200fee5:	fddd25        	call8	4200dcb8 <get_arg$constprop$0>
4200fee8:	001a32        	l16ui	a3, a10, 0
4200feeb:	003006        	j	4200ffaf <_vfprintf_r+0x1dff>
4200feee:	00          	.byte 00
4200feef:	00          	.byte 00
4200fef0:	9f2132        	l32i	a3, a1, 0x27c
4200fef3:	10c142        	addi	a4, a1, 16
4200fef6:	531b      	addi.n	a5, a3, 1
4200fef8:	b02240        	addx8	a2, a2, a4
4200fefb:	652367        	blt	a3, a6, 4200ff64 <_vfprintf_r+0x1db4>
4200fefe:	10c182        	addi	a8, a1, 16
4200ff01:	9a2872        	l32i	a7, a8, 0x268
4200ff04:	02d822        	addmi	a2, a8, 0x200
4200ff07:	f81c      	movi.n	a8, 31
4200ff09:	374b      	addi.n	a3, a7, 4
4200ff0b:	841c      	movi.n	a4, 24
4200ff0d:	332867        	blt	a8, a6, 4200ff44 <_vfprintf_r+0x1d94>
4200ff10:	861b      	addi.n	a8, a6, 1
4200ff12:	986182        	s32i	a8, a1, 0x260
4200ff15:	1a6232        	s32i	a3, a2, 104
4200ff18:	052437        	blt	a4, a3, 4200ff21 <_vfprintf_r+0x1d71>
4200ff1b:	192222        	l32i	a2, a2, 100
4200ff1e:	000286        	j	4200ff2c <_vfprintf_r+0x1d7c>
4200ff21:	012477        	blt	a4, a7, 4200ff26 <_vfprintf_r+0x1d76>
4200ff24:	432c      	movi.n	a3, 36
4200ff26:	9c2122        	l32i	a2, a1, 0x270
4200ff29:	9e6132        	s32i	a3, a1, 0x278
4200ff2c:	9e2132        	l32i	a3, a1, 0x278
4200ff2f:	10c1b2        	addi	a11, a1, 16
4200ff32:	223a      	add.n	a2, a2, a3
4200ff34:	fcc222        	addi	a2, a2, -4
4200ff37:	0238      	l32i.n	a3, a2, 0
4200ff39:	b026b0        	addx8	a2, a6, a11
4200ff3c:	0239      	s32i.n	a3, a2, 0
4200ff3e:	f43030        	extui	a3, a3, 0, 16
4200ff41:	003a86        	j	4201002f <_vfprintf_r+0x1e7f>
4200ff44:	1a6232        	s32i	a3, a2, 104
4200ff47:	052437        	blt	a4, a3, 4200ff50 <_vfprintf_r+0x1da0>
4200ff4a:	192222        	l32i	a2, a2, 100
4200ff4d:	000286        	j	4200ff5b <_vfprintf_r+0x1dab>
4200ff50:	012477        	blt	a4, a7, 4200ff55 <_vfprintf_r+0x1da5>
4200ff53:	432c      	movi.n	a3, 36
4200ff55:	9c2122        	l32i	a2, a1, 0x270
4200ff58:	9e6132        	s32i	a3, a1, 0x278
4200ff5b:	9e2132        	l32i	a3, a1, 0x278
4200ff5e:	802230        	add	a2, a2, a3
4200ff61:	fcc222        	addi	a2, a2, -4
4200ff64:	001232        	l16ui	a3, a2, 0
4200ff67:	003106        	j	4201002f <_vfprintf_r+0x1e7f>
4200ff6a:	00          	.byte 00
4200ff6b:	00          	.byte 00
4200ff6c:	a02152        	l32i	a5, a1, 0x280
4200ff6f:	02e597        	bbsi	a5, 9, 4200ff75 <_vfprintf_r+0x1dc5>
4200ff72:	003006        	j	42010036 <_vfprintf_r+0x1e86>
4200ff75:	f4bc      	beqz.n	a4, 4200ffb8 <_vfprintf_r+0x1e08>
4200ff77:	0ea267        	bge	a2, a6, 4200ff89 <_vfprintf_r+0x1dd9>
4200ff7a:	10c162        	addi	a6, a1, 16
4200ff7d:	b02260        	addx8	a2, a2, a6
4200ff80:	000232        	l8ui	a3, a2, 0
4200ff83:	9f2152        	l32i	a5, a1, 0x27c
4200ff86:	002946        	j	4201002f <_vfprintf_r+0x1e7f>
4200ff89:	5ca282        	movi	a8, 0x25c
4200ff8c:	10c1a2        	addi	a10, a1, 16
4200ff8f:	418a      	add.n	a4, a1, a8
4200ff91:	50a2d2        	movi	a13, 0x250
4200ff94:	60a2c2        	movi	a12, 0x260
4200ff97:	01daf2        	addmi	a15, a10, 0x100
4200ff9a:	0aed      	mov.n	a14, a10
4200ff9c:	dada      	add.n	a13, a10, a13
4200ff9e:	caca      	add.n	a12, a10, a12
4200ffa0:	03bd      	mov.n	a11, a3
4200ffa2:	0149      	s32i.n	a4, a1, 0
4200ffa4:	02ad      	mov.n	a10, a2
4200ffa6:	b96192        	s32i	a9, a1, 0x2e4
4200ffa9:	fdd0e5        	call8	4200dcb8 <get_arg$constprop$0>
4200ffac:	000a32        	l8ui	a3, a10, 0
4200ffaf:	9f2152        	l32i	a5, a1, 0x27c
4200ffb2:	b92192        	l32i	a9, a1, 0x2e4
4200ffb5:	001d86        	j	4201002f <_vfprintf_r+0x1e7f>
4200ffb8:	9f2132        	l32i	a3, a1, 0x27c
4200ffbb:	10c142        	addi	a4, a1, 16
4200ffbe:	531b      	addi.n	a5, a3, 1
4200ffc0:	b02240        	addx8	a2, a2, a4
4200ffc3:	652367        	blt	a3, a6, 4201002c <_vfprintf_r+0x1e7c>
4200ffc6:	10c182        	addi	a8, a1, 16
4200ffc9:	9a2872        	l32i	a7, a8, 0x268
4200ffcc:	02d822        	addmi	a2, a8, 0x200
4200ffcf:	f81c      	movi.n	a8, 31
4200ffd1:	374b      	addi.n	a3, a7, 4
4200ffd3:	841c      	movi.n	a4, 24
4200ffd5:	332867        	blt	a8, a6, 4201000c <_vfprintf_r+0x1e5c>
4200ffd8:	861b      	addi.n	a8, a6, 1
4200ffda:	986182        	s32i	a8, a1, 0x260
4200ffdd:	1a6232        	s32i	a3, a2, 104
4200ffe0:	052437        	blt	a4, a3, 4200ffe9 <_vfprintf_r+0x1e39>
4200ffe3:	192222        	l32i	a2, a2, 100
4200ffe6:	000286        	j	4200fff4 <_vfprintf_r+0x1e44>
4200ffe9:	012477        	blt	a4, a7, 4200ffee <_vfprintf_r+0x1e3e>
4200ffec:	432c      	movi.n	a3, 36
4200ffee:	9c2122        	l32i	a2, a1, 0x270
4200fff1:	9e6132        	s32i	a3, a1, 0x278
4200fff4:	9e2132        	l32i	a3, a1, 0x278
4200fff7:	10c1b2        	addi	a11, a1, 16
4200fffa:	223a      	add.n	a2, a2, a3
4200fffc:	fcc222        	addi	a2, a2, -4
4200ffff:	0238      	l32i.n	a3, a2, 0
42010001:	b026b0        	addx8	a2, a6, a11
42010004:	0239      	s32i.n	a3, a2, 0
42010006:	743030        	extui	a3, a3, 0, 8
42010009:	000886        	j	4201002f <_vfprintf_r+0x1e7f>
4201000c:	1a6232        	s32i	a3, a2, 104
4201000f:	052437        	blt	a4, a3, 42010018 <_vfprintf_r+0x1e68>
42010012:	192222        	l32i	a2, a2, 100
42010015:	000286        	j	42010023 <_vfprintf_r+0x1e73>
42010018:	012477        	blt	a4, a7, 4201001d <_vfprintf_r+0x1e6d>
4201001b:	432c      	movi.n	a3, 36
4201001d:	9c2122        	l32i	a2, a1, 0x270
42010020:	9e6132        	s32i	a3, a1, 0x278
42010023:	9e2132        	l32i	a3, a1, 0x278
42010026:	802230        	add	a2, a2, a3
42010029:	fcc222        	addi	a2, a2, -4
4201002c:	000232        	l8ui	a3, a2, 0
4201002f:	040c      	movi.n	a4, 0
42010031:	120c      	movi.n	a2, 1
42010033:	0122c6        	j	420104c2 <_vfprintf_r+0x2312>
42010036:	74bc      	beqz.n	a4, 42010071 <_vfprintf_r+0x1ec1>
42010038:	0da267        	bge	a2, a6, 42010049 <_vfprintf_r+0x1e99>
4201003b:	10c132        	addi	a3, a1, 16
4201003e:	b02230        	addx8	a2, a2, a3
42010041:	0238      	l32i.n	a3, a2, 0
42010043:	ffcf06        	j	4200ff83 <_vfprintf_r+0x1dd3>
42010046:	00          	.byte 00
42010047:	00          	.byte 00
42010048:	00          	.byte 00
42010049:	5ca252        	movi	a5, 0x25c
4201004c:	10c162        	addi	a6, a1, 16
4201004f:	415a      	add.n	a4, a1, a5
42010051:	0149      	s32i.n	a4, a1, 0
42010053:	01d6f2        	addmi	a15, a6, 0x100
42010056:	50a2d2        	movi	a13, 0x250
42010059:	06ed      	mov.n	a14, a6
4201005b:	60a2c2        	movi	a12, 0x260
4201005e:	03bd      	mov.n	a11, a3
42010060:	deda      	add.n	a13, a14, a13
42010062:	ceca      	add.n	a12, a14, a12
42010064:	02ad      	mov.n	a10, a2
42010066:	b96192        	s32i	a9, a1, 0x2e4
42010069:	fdc4e5        	call8	4200dcb8 <get_arg$constprop$0>
4201006c:	0a38      	l32i.n	a3, a10, 0
4201006e:	ffcf46        	j	4200ffaf <_vfprintf_r+0x1dff>
42010071:	9f2182        	l32i	a8, a1, 0x27c
42010074:	10c1a2        	addi	a10, a1, 16
42010077:	581b      	addi.n	a5, a8, 1
42010079:	b022a0        	addx8	a2, a2, a10
4201007c:	642867        	blt	a8, a6, 420100e4 <_vfprintf_r+0x1f34>
4201007f:	10c1b2        	addi	a11, a1, 16
42010082:	9a2b72        	l32i	a7, a11, 0x268
42010085:	f81c      	movi.n	a8, 31
42010087:	02db22        	addmi	a2, a11, 0x200
4201008a:	374b      	addi.n	a3, a7, 4
4201008c:	841c      	movi.n	a4, 24
4201008e:	322867        	blt	a8, a6, 420100c4 <_vfprintf_r+0x1f14>
42010091:	861b      	addi.n	a8, a6, 1
42010093:	986182        	s32i	a8, a1, 0x260
42010096:	1a6232        	s32i	a3, a2, 104
42010099:	052437        	blt	a4, a3, 420100a2 <_vfprintf_r+0x1ef2>
4201009c:	192222        	l32i	a2, a2, 100
4201009f:	0002c6        	j	420100ae <_vfprintf_r+0x1efe>
420100a2:	022477        	blt	a4, a7, 420100a8 <_vfprintf_r+0x1ef8>
420100a5:	24a032        	movi	a3, 36
420100a8:	9c2122        	l32i	a2, a1, 0x270
420100ab:	9e6132        	s32i	a3, a1, 0x278
420100ae:	9e2132        	l32i	a3, a1, 0x278
420100b1:	223a      	add.n	a2, a2, a3
420100b3:	fcc222        	addi	a2, a2, -4
420100b6:	0238      	l32i.n	a3, a2, 0
420100b8:	10c122        	addi	a2, a1, 16
420100bb:	b06620        	addx8	a6, a6, a2
420100be:	0639      	s32i.n	a3, a6, 0
420100c0:	ffdac6        	j	4201002f <_vfprintf_r+0x1e7f>
420100c3:	00          	.byte 00
420100c4:	1a6232        	s32i	a3, a2, 104
420100c7:	052437        	blt	a4, a3, 420100d0 <_vfprintf_r+0x1f20>
420100ca:	192222        	l32i	a2, a2, 100
420100cd:	000286        	j	420100db <_vfprintf_r+0x1f2b>
420100d0:	012477        	blt	a4, a7, 420100d5 <_vfprintf_r+0x1f25>
420100d3:	432c      	movi.n	a3, 36
420100d5:	9c2122        	l32i	a2, a1, 0x270
420100d8:	9e6132        	s32i	a3, a1, 0x278
420100db:	9e2132        	l32i	a3, a1, 0x278
420100de:	802230        	add	a2, a2, a3
420100e1:	fcc222        	addi	a2, a2, -4
420100e4:	0238      	l32i.n	a3, a2, 0
420100e6:	ffd146        	j	4201002f <_vfprintf_r+0x1e7f>
420100e9:	00          	.byte 00
420100ea:	00          	.byte 00
420100eb:	00          	.byte 00
420100ec:	c2d551        	l32r	a5, 42000c40 <_stext+0xc20>
420100ef:	b46152        	s32i	a5, a1, 0x2d0
420100f2:	000146        	j	420100fb <_vfprintf_r+0x1f4b>
420100f5:	c2d161        	l32r	a6, 42000c3c <_stext+0xc1c>
420100f8:	b46162        	s32i	a6, a1, 0x2d0
420100fb:	a02182        	l32i	a8, a1, 0x280
420100fe:	982162        	l32i	a6, a1, 0x260
42010101:	02e857        	bbsi	a8, 5, 42010107 <_vfprintf_r+0x1f57>
42010104:	003206        	j	420101d0 <_vfprintf_r+0x2020>
42010107:	041416        	beqz	a4, 4201014c <_vfprintf_r+0x1f9c>
4201010a:	0fa267        	bge	a2, a6, 4201011d <_vfprintf_r+0x1f6d>
4201010d:	10c1a2        	addi	a10, a1, 16
42010110:	b022a0        	addx8	a2, a2, a10
42010113:	0238      	l32i.n	a3, a2, 0
42010115:	1248      	l32i.n	a4, a2, 4
42010117:	9f2152        	l32i	a5, a1, 0x27c
4201011a:	00dbc6        	j	4201048d <_vfprintf_r+0x22dd>
4201011d:	5ca2b2        	movi	a11, 0x25c
42010120:	10c1e2        	addi	a14, a1, 16
42010123:	41ba      	add.n	a4, a1, a11
42010125:	50a2d2        	movi	a13, 0x250
42010128:	60a2c2        	movi	a12, 0x260
4201012b:	0149      	s32i.n	a4, a1, 0
4201012d:	03bd      	mov.n	a11, a3
4201012f:	01def2        	addmi	a15, a14, 0x100
42010132:	deda      	add.n	a13, a14, a13
42010134:	ceca      	add.n	a12, a14, a12
42010136:	02ad      	mov.n	a10, a2
42010138:	b96192        	s32i	a9, a1, 0x2e4
4201013b:	fdb7e5        	call8	4200dcb8 <get_arg$constprop$0>
4201013e:	0a38      	l32i.n	a3, a10, 0
42010140:	1a48      	l32i.n	a4, a10, 4
42010142:	9f2152        	l32i	a5, a1, 0x27c
42010145:	b92192        	l32i	a9, a1, 0x2e4
42010148:	00d046        	j	4201048d <_vfprintf_r+0x22dd>
4201014b:	00          	.byte 00
4201014c:	9f2132        	l32i	a3, a1, 0x27c
4201014f:	10c142        	addi	a4, a1, 16
42010152:	531b      	addi.n	a5, a3, 1
42010154:	b02240        	addx8	a2, a2, a4
42010157:	6d2367        	blt	a3, a6, 420101c8 <_vfprintf_r+0x2018>
4201015a:	10c182        	addi	a8, a1, 16
4201015d:	9a2842        	l32i	a4, a8, 0x268
42010160:	837c      	movi.n	a3, -8
42010162:	447b      	addi.n	a4, a4, 7
42010164:	02d822        	addmi	a2, a8, 0x200
42010167:	104430        	and	a4, a4, a3
4201016a:	f81c      	movi.n	a8, 31
4201016c:	348b      	addi.n	a3, a4, 8
4201016e:	871c      	movi.n	a7, 24
42010170:	342867        	blt	a8, a6, 420101a8 <_vfprintf_r+0x1ff8>
42010173:	861b      	addi.n	a8, a6, 1
42010175:	986182        	s32i	a8, a1, 0x260
42010178:	1a6232        	s32i	a3, a2, 104
4201017b:	052737        	blt	a7, a3, 42010184 <_vfprintf_r+0x1fd4>
4201017e:	192222        	l32i	a2, a2, 100
42010181:	000286        	j	4201018f <_vfprintf_r+0x1fdf>
42010184:	012747        	blt	a7, a4, 42010189 <_vfprintf_r+0x1fd9>
42010187:	832c      	movi.n	a3, 40
42010189:	9c2122        	l32i	a2, a1, 0x270
4201018c:	9e6132        	s32i	a3, a1, 0x278
4201018f:	9e2132        	l32i	a3, a1, 0x278
42010192:	10c1b2        	addi	a11, a1, 16
42010195:	223a      	add.n	a2, a2, a3
42010197:	f8c222        	addi	a2, a2, -8
4201019a:	0238      	l32i.n	a3, a2, 0
4201019c:	1248      	l32i.n	a4, a2, 4
4201019e:	b026b0        	addx8	a2, a6, a11
420101a1:	0239      	s32i.n	a3, a2, 0
420101a3:	1249      	s32i.n	a4, a2, 4
420101a5:	00b906        	j	4201048d <_vfprintf_r+0x22dd>
420101a8:	1a6232        	s32i	a3, a2, 104
420101ab:	052737        	blt	a7, a3, 420101b4 <_vfprintf_r+0x2004>
420101ae:	192222        	l32i	a2, a2, 100
420101b1:	000286        	j	420101bf <_vfprintf_r+0x200f>
420101b4:	012747        	blt	a7, a4, 420101b9 <_vfprintf_r+0x2009>
420101b7:	832c      	movi.n	a3, 40
420101b9:	9c2122        	l32i	a2, a1, 0x270
420101bc:	9e6132        	s32i	a3, a1, 0x278
420101bf:	9e2132        	l32i	a3, a1, 0x278
420101c2:	802230        	add	a2, a2, a3
420101c5:	f8c222        	addi	a2, a2, -8
420101c8:	0238      	l32i.n	a3, a2, 0
420101ca:	1248      	l32i.n	a4, a2, 4
420101cc:	00af46        	j	4201048d <_vfprintf_r+0x22dd>
420101cf:	00          	.byte 00
420101d0:	a02152        	l32i	a5, a1, 0x280
420101d3:	796547        	bbci	a5, 4, 42010250 <_vfprintf_r+0x20a0>
420101d6:	f49c      	beqz.n	a4, 420101f9 <_vfprintf_r+0x2049>
420101d8:	08a267        	bge	a2, a6, 420101e4 <_vfprintf_r+0x2034>
420101db:	10c162        	addi	a6, a1, 16
420101de:	b02260        	addx8	a2, a2, a6
420101e1:	007f06        	j	420103e1 <_vfprintf_r+0x2231>
420101e4:	5ca282        	movi	a8, 0x25c
420101e7:	10c1a2        	addi	a10, a1, 16
420101ea:	418a      	add.n	a4, a1, a8
420101ec:	0149      	s32i.n	a4, a1, 0
420101ee:	01daf2        	addmi	a15, a10, 0x100
420101f1:	50a2d2        	movi	a13, 0x250
420101f4:	0aed      	mov.n	a14, a10
420101f6:	008046        	j	420103fb <_vfprintf_r+0x224b>
420101f9:	9f2132        	l32i	a3, a1, 0x27c
420101fc:	10c142        	addi	a4, a1, 16
420101ff:	531b      	addi.n	a5, a3, 1
42010201:	b02240        	addx8	a2, a2, a4
42010204:	02a367        	bge	a3, a6, 4201020a <_vfprintf_r+0x205a>
42010207:	009f86        	j	42010489 <_vfprintf_r+0x22d9>
4201020a:	10c182        	addi	a8, a1, 16
4201020d:	9a2872        	l32i	a7, a8, 0x268
42010210:	02d822        	addmi	a2, a8, 0x200
42010213:	f81c      	movi.n	a8, 31
42010215:	374b      	addi.n	a3, a7, 4
42010217:	841c      	movi.n	a4, 24
42010219:	02a867        	bge	a8, a6, 4201021f <_vfprintf_r+0x206f>
4201021c:	009246        	j	42010469 <_vfprintf_r+0x22b9>
4201021f:	861b      	addi.n	a8, a6, 1
42010221:	986182        	s32i	a8, a1, 0x260
42010224:	1a6232        	s32i	a3, a2, 104
42010227:	052437        	blt	a4, a3, 42010230 <_vfprintf_r+0x2080>
4201022a:	192222        	l32i	a2, a2, 100
4201022d:	000286        	j	4201023b <_vfprintf_r+0x208b>
42010230:	012477        	blt	a4, a7, 42010235 <_vfprintf_r+0x2085>
42010233:	432c      	movi.n	a3, 36
42010235:	9c2122        	l32i	a2, a1, 0x270
42010238:	9e6132        	s32i	a3, a1, 0x278
4201023b:	9e2132        	l32i	a3, a1, 0x278
4201023e:	10c1b2        	addi	a11, a1, 16
42010241:	223a      	add.n	a2, a2, a3
42010243:	fcc222        	addi	a2, a2, -4
42010246:	0238      	l32i.n	a3, a2, 0
42010248:	b026b0        	addx8	a2, a6, a11
4201024b:	0239      	s32i.n	a3, a2, 0
4201024d:	008e86        	j	4201048b <_vfprintf_r+0x22db>
42010250:	a02152        	l32i	a5, a1, 0x280
42010253:	02e567        	bbsi	a5, 6, 42010259 <_vfprintf_r+0x20a9>
42010256:	002e86        	j	42010314 <_vfprintf_r+0x2164>
42010259:	b4bc      	beqz.n	a4, 42010298 <_vfprintf_r+0x20e8>
4201025b:	0ea267        	bge	a2, a6, 4201026d <_vfprintf_r+0x20bd>
4201025e:	10c162        	addi	a6, a1, 16
42010261:	b02260        	addx8	a2, a2, a6
42010264:	001232        	l16ui	a3, a2, 0
42010267:	005e06        	j	420103e3 <_vfprintf_r+0x2233>
4201026a:	00          	.byte 00
4201026b:	00          	.byte 00
4201026c:	00          	.byte 00
4201026d:	5ca282        	movi	a8, 0x25c
42010270:	10c1a2        	addi	a10, a1, 16
42010273:	418a      	add.n	a4, a1, a8
42010275:	50a2d2        	movi	a13, 0x250
42010278:	60a2c2        	movi	a12, 0x260
4201027b:	01daf2        	addmi	a15, a10, 0x100
4201027e:	0aed      	mov.n	a14, a10
42010280:	dada      	add.n	a13, a10, a13
42010282:	caca      	add.n	a12, a10, a12
42010284:	03bd      	mov.n	a11, a3
42010286:	0149      	s32i.n	a4, a1, 0
42010288:	02ad      	mov.n	a10, a2
4201028a:	b96192        	s32i	a9, a1, 0x2e4
4201028d:	fda2a5        	call8	4200dcb8 <get_arg$constprop$0>
42010290:	001a32        	l16ui	a3, a10, 0
42010293:	005dc6        	j	4201040e <_vfprintf_r+0x225e>
42010296:	00          	.byte 00
42010297:	00          	.byte 00
42010298:	9f2132        	l32i	a3, a1, 0x27c
4201029b:	10c142        	addi	a4, a1, 16
4201029e:	531b      	addi.n	a5, a3, 1
420102a0:	b02240        	addx8	a2, a2, a4
420102a3:	652367        	blt	a3, a6, 4201030c <_vfprintf_r+0x215c>
420102a6:	10c182        	addi	a8, a1, 16
420102a9:	9a2872        	l32i	a7, a8, 0x268
420102ac:	02d822        	addmi	a2, a8, 0x200
420102af:	f81c      	movi.n	a8, 31
420102b1:	374b      	addi.n	a3, a7, 4
420102b3:	841c      	movi.n	a4, 24
420102b5:	332867        	blt	a8, a6, 420102ec <_vfprintf_r+0x213c>
420102b8:	861b      	addi.n	a8, a6, 1
420102ba:	986182        	s32i	a8, a1, 0x260
420102bd:	1a6232        	s32i	a3, a2, 104
420102c0:	052437        	blt	a4, a3, 420102c9 <_vfprintf_r+0x2119>
420102c3:	192222        	l32i	a2, a2, 100
420102c6:	000286        	j	420102d4 <_vfprintf_r+0x2124>
420102c9:	012477        	blt	a4, a7, 420102ce <_vfprintf_r+0x211e>
420102cc:	432c      	movi.n	a3, 36
420102ce:	9c2122        	l32i	a2, a1, 0x270
420102d1:	9e6132        	s32i	a3, a1, 0x278
420102d4:	9e2132        	l32i	a3, a1, 0x278
420102d7:	10c1b2        	addi	a11, a1, 16
420102da:	223a      	add.n	a2, a2, a3
420102dc:	fcc222        	addi	a2, a2, -4
420102df:	0238      	l32i.n	a3, a2, 0
420102e1:	b026b0        	addx8	a2, a6, a11
420102e4:	0239      	s32i.n	a3, a2, 0
420102e6:	f43030        	extui	a3, a3, 0, 16
420102e9:	006786        	j	4201048b <_vfprintf_r+0x22db>
420102ec:	1a6232        	s32i	a3, a2, 104
420102ef:	052437        	blt	a4, a3, 420102f8 <_vfprintf_r+0x2148>
420102f2:	192222        	l32i	a2, a2, 100
420102f5:	000286        	j	42010303 <_vfprintf_r+0x2153>
420102f8:	012477        	blt	a4, a7, 420102fd <_vfprintf_r+0x214d>
420102fb:	432c      	movi.n	a3, 36
420102fd:	9c2122        	l32i	a2, a1, 0x270
42010300:	9e6132        	s32i	a3, a1, 0x278
42010303:	9e2132        	l32i	a3, a1, 0x278
42010306:	802230        	add	a2, a2, a3
42010309:	fcc222        	addi	a2, a2, -4
4201030c:	001232        	l16ui	a3, a2, 0
4201030f:	005e06        	j	4201048b <_vfprintf_r+0x22db>
42010312:	00          	.byte 00
42010313:	00          	.byte 00
42010314:	a02152        	l32i	a5, a1, 0x280
42010317:	02e597        	bbsi	a5, 9, 4201031d <_vfprintf_r+0x216d>
4201031a:	002e06        	j	420103d6 <_vfprintf_r+0x2226>
4201031d:	94bc      	beqz.n	a4, 4201035a <_vfprintf_r+0x21aa>
4201031f:	0ea267        	bge	a2, a6, 42010331 <_vfprintf_r+0x2181>
42010322:	10c162        	addi	a6, a1, 16
42010325:	b02260        	addx8	a2, a2, a6
42010328:	000232        	l8ui	a3, a2, 0
4201032b:	002d06        	j	420103e3 <_vfprintf_r+0x2233>
4201032e:	00          	.byte 00
4201032f:	00          	.byte 00
42010330:	00          	.byte 00
42010331:	5ca282        	movi	a8, 0x25c
42010334:	10c1a2        	addi	a10, a1, 16
42010337:	418a      	add.n	a4, a1, a8
42010339:	50a2d2        	movi	a13, 0x250
4201033c:	60a2c2        	movi	a12, 0x260
4201033f:	01daf2        	addmi	a15, a10, 0x100
42010342:	0aed      	mov.n	a14, a10
42010344:	dada      	add.n	a13, a10, a13
42010346:	caca      	add.n	a12, a10, a12
42010348:	03bd      	mov.n	a11, a3
4201034a:	0149      	s32i.n	a4, a1, 0
4201034c:	02ad      	mov.n	a10, a2
4201034e:	b96192        	s32i	a9, a1, 0x2e4
42010351:	fd9665        	call8	4200dcb8 <get_arg$constprop$0>
42010354:	000a32        	l8ui	a3, a10, 0
42010357:	002cc6        	j	4201040e <_vfprintf_r+0x225e>
4201035a:	9f2132        	l32i	a3, a1, 0x27c
4201035d:	10c142        	addi	a4, a1, 16
42010360:	531b      	addi.n	a5, a3, 1
42010362:	b02240        	addx8	a2, a2, a4
42010365:	672367        	blt	a3, a6, 420103d0 <_vfprintf_r+0x2220>
42010368:	10c182        	addi	a8, a1, 16
4201036b:	9a2872        	l32i	a7, a8, 0x268
4201036e:	02d822        	addmi	a2, a8, 0x200
42010371:	f81c      	movi.n	a8, 31
42010373:	374b      	addi.n	a3, a7, 4
42010375:	841c      	movi.n	a4, 24
42010377:	352867        	blt	a8, a6, 420103b0 <_vfprintf_r+0x2200>
4201037a:	861b      	addi.n	a8, a6, 1
4201037c:	986182        	s32i	a8, a1, 0x260
4201037f:	1a6232        	s32i	a3, a2, 104
42010382:	062437        	blt	a4, a3, 4201038c <_vfprintf_r+0x21dc>
42010385:	192222        	l32i	a2, a2, 100
42010388:	0002c6        	j	42010397 <_vfprintf_r+0x21e7>
4201038b:	00          	.byte 00
4201038c:	012477        	blt	a4, a7, 42010391 <_vfprintf_r+0x21e1>
4201038f:	432c      	movi.n	a3, 36
42010391:	9c2122        	l32i	a2, a1, 0x270
42010394:	9e6132        	s32i	a3, a1, 0x278
42010397:	9e2132        	l32i	a3, a1, 0x278
4201039a:	10c1b2        	addi	a11, a1, 16
4201039d:	223a      	add.n	a2, a2, a3
4201039f:	fcc222        	addi	a2, a2, -4
420103a2:	0238      	l32i.n	a3, a2, 0
420103a4:	b026b0        	addx8	a2, a6, a11
420103a7:	0239      	s32i.n	a3, a2, 0
420103a9:	743030        	extui	a3, a3, 0, 8
420103ac:	0036c6        	j	4201048b <_vfprintf_r+0x22db>
420103af:	00          	.byte 00
420103b0:	1a6232        	s32i	a3, a2, 104
420103b3:	052437        	blt	a4, a3, 420103bc <_vfprintf_r+0x220c>
420103b6:	192222        	l32i	a2, a2, 100
420103b9:	000286        	j	420103c7 <_vfprintf_r+0x2217>
420103bc:	012477        	blt	a4, a7, 420103c1 <_vfprintf_r+0x2211>
420103bf:	432c      	movi.n	a3, 36
420103c1:	9c2122        	l32i	a2, a1, 0x270
420103c4:	9e6132        	s32i	a3, a1, 0x278
420103c7:	9e2132        	l32i	a3, a1, 0x278
420103ca:	802230        	add	a2, a2, a3
420103cd:	fcc222        	addi	a2, a2, -4
420103d0:	000232        	l8ui	a3, a2, 0
420103d3:	002d06        	j	4201048b <_vfprintf_r+0x22db>
420103d6:	e4bc      	beqz.n	a4, 42010418 <_vfprintf_r+0x2268>
420103d8:	0da267        	bge	a2, a6, 420103e9 <_vfprintf_r+0x2239>
420103db:	10c132        	addi	a3, a1, 16
420103de:	b02230        	addx8	a2, a2, a3
420103e1:	0238      	l32i.n	a3, a2, 0
420103e3:	9f2152        	l32i	a5, a1, 0x27c
420103e6:	002846        	j	4201048b <_vfprintf_r+0x22db>
420103e9:	5ca252        	movi	a5, 0x25c
420103ec:	10c162        	addi	a6, a1, 16
420103ef:	415a      	add.n	a4, a1, a5
420103f1:	0149      	s32i.n	a4, a1, 0
420103f3:	01d6f2        	addmi	a15, a6, 0x100
420103f6:	50a2d2        	movi	a13, 0x250
420103f9:	06ed      	mov.n	a14, a6
420103fb:	60a2c2        	movi	a12, 0x260
420103fe:	03bd      	mov.n	a11, a3
42010400:	deda      	add.n	a13, a14, a13
42010402:	ceca      	add.n	a12, a14, a12
42010404:	02ad      	mov.n	a10, a2
42010406:	b96192        	s32i	a9, a1, 0x2e4
42010409:	fd8ae5        	call8	4200dcb8 <get_arg$constprop$0>
4201040c:	0a38      	l32i.n	a3, a10, 0
4201040e:	9f2152        	l32i	a5, a1, 0x27c
42010411:	b92192        	l32i	a9, a1, 0x2e4
42010414:	001cc6        	j	4201048b <_vfprintf_r+0x22db>
42010417:	00          	.byte 00
42010418:	9f2182        	l32i	a8, a1, 0x27c
4201041b:	10c1a2        	addi	a10, a1, 16
4201041e:	581b      	addi.n	a5, a8, 1
42010420:	b022a0        	addx8	a2, a2, a10
42010423:	622867        	blt	a8, a6, 42010489 <_vfprintf_r+0x22d9>
42010426:	10c1b2        	addi	a11, a1, 16
42010429:	9a2b72        	l32i	a7, a11, 0x268
4201042c:	f81c      	movi.n	a8, 31
4201042e:	02db22        	addmi	a2, a11, 0x200
42010431:	374b      	addi.n	a3, a7, 4
42010433:	841c      	movi.n	a4, 24
42010435:	302867        	blt	a8, a6, 42010469 <_vfprintf_r+0x22b9>
42010438:	861b      	addi.n	a8, a6, 1
4201043a:	986182        	s32i	a8, a1, 0x260
4201043d:	1a6232        	s32i	a3, a2, 104
42010440:	052437        	blt	a4, a3, 42010449 <_vfprintf_r+0x2299>
42010443:	192222        	l32i	a2, a2, 100
42010446:	000286        	j	42010454 <_vfprintf_r+0x22a4>
42010449:	012477        	blt	a4, a7, 4201044e <_vfprintf_r+0x229e>
4201044c:	432c      	movi.n	a3, 36
4201044e:	9c2122        	l32i	a2, a1, 0x270
42010451:	9e6132        	s32i	a3, a1, 0x278
42010454:	9e2132        	l32i	a3, a1, 0x278
42010457:	223a      	add.n	a2, a2, a3
42010459:	fcc222        	addi	a2, a2, -4
4201045c:	0238      	l32i.n	a3, a2, 0
4201045e:	10c122        	addi	a2, a1, 16
42010461:	b06620        	addx8	a6, a6, a2
42010464:	0639      	s32i.n	a3, a6, 0
42010466:	000846        	j	4201048b <_vfprintf_r+0x22db>
42010469:	1a6232        	s32i	a3, a2, 104
4201046c:	052437        	blt	a4, a3, 42010475 <_vfprintf_r+0x22c5>
4201046f:	192222        	l32i	a2, a2, 100
42010472:	000286        	j	42010480 <_vfprintf_r+0x22d0>
42010475:	012477        	blt	a4, a7, 4201047a <_vfprintf_r+0x22ca>
42010478:	432c      	movi.n	a3, 36
4201047a:	9c2122        	l32i	a2, a1, 0x270
4201047d:	9e6132        	s32i	a3, a1, 0x278
42010480:	9e2132        	l32i	a3, a1, 0x278
42010483:	802230        	add	a2, a2, a3
42010486:	fcc222        	addi	a2, a2, -4
42010489:	0238      	l32i.n	a3, a2, 0
4201048b:	040c      	movi.n	a4, 0
4201048d:	202340        	or	a2, a3, a4
42010490:	02ac      	beqz.n	a2, 420104b4 <_vfprintf_r+0x2304>
42010492:	a02162        	l32i	a6, a1, 0x280
42010495:	1b6607        	bbci	a6, 0, 420104b4 <_vfprintf_r+0x2304>
42010498:	10c182        	addi	a8, a1, 16
4201049b:	02d822        	addmi	a2, a8, 0x200
4201049e:	063c      	movi.n	a6, 48
420104a0:	544262        	s8i	a6, a2, 84
420104a3:	a72162        	l32i	a6, a1, 0x29c
420104a6:	a02182        	l32i	a8, a1, 0x280
420104a9:	554262        	s8i	a6, a2, 85
420104ac:	220c      	movi.n	a2, 2
420104ae:	208820        	or	a8, a8, a2
420104b1:	a06182        	s32i	a8, a1, 0x280
420104b4:	a02162        	l32i	a6, a1, 0x280
420104b7:	ffab22        	movi	a2, 0xfffffbff
420104ba:	106620        	and	a6, a6, a2
420104bd:	a06162        	s32i	a6, a1, 0x280
420104c0:	220c      	movi.n	a2, 2
420104c2:	9f6152        	s32i	a5, a1, 0x27c
420104c5:	060c      	movi.n	a6, 0
420104c7:	10c182        	addi	a8, a1, 16
420104ca:	02d852        	addmi	a5, a8, 0x200
420104cd:	564562        	s8i	a6, a5, 86
420104d0:	a42152        	l32i	a5, a1, 0x290
420104d3:	260526        	beqi	a5, -1, 420104fd <_vfprintf_r+0x234d>
420104d6:	a02172        	l32i	a7, a1, 0x280
420104d9:	a02162        	l32i	a6, a1, 0x280
420104dc:	7faf52        	movi	a5, -129
420104df:	106650        	and	a6, a6, a5
420104e2:	208340        	or	a8, a3, a4
420104e5:	a06162        	s32i	a6, a1, 0x280
420104e8:	150c      	movi.n	a5, 1
420104ea:	060c      	movi.n	a6, 0
420104ec:	936580        	movnez	a6, a5, a8
420104ef:	748060        	extui	a8, a6, 0, 8
420104f2:	76cc      	bnez.n	a6, 420104fd <_vfprintf_r+0x234d>
420104f4:	a42162        	l32i	a6, a1, 0x290
420104f7:	835860        	moveqz	a5, a8, a6
420104fa:	17a516        	beqz	a5, 42010678 <_vfprintf_r+0x24c8>
420104fd:	5d1226        	beqi	a2, 1, 4201055e <_vfprintf_r+0x23ae>
42010500:	022266        	bnei	a2, 2, 42010506 <_vfprintf_r+0x2356>
42010503:	004e86        	j	42010641 <_vfprintf_r+0x2491>
42010506:	90a182        	movi	a8, 0x190
42010509:	881a      	add.n	a8, a8, a1
4201050b:	64c882        	addi	a8, a8, 100
4201050e:	a26182        	s32i	a8, a1, 0x288
42010511:	a22152        	l32i	a5, a1, 0x288
42010514:	016430        	slli	a6, a4, 29
42010517:	250b      	addi.n	a2, a5, -1
42010519:	a26122        	s32i	a2, a1, 0x288
4201051c:	a22182        	l32i	a8, a1, 0x288
4201051f:	242030        	extui	a2, a3, 0, 3
42010522:	413330        	srli	a3, a3, 3
42010525:	30c222        	addi	a2, a2, 48
42010528:	203630        	or	a3, a6, a3
4201052b:	414340        	srli	a4, a4, 3
4201052e:	004822        	s8i	a2, a8, 0
42010531:	206340        	or	a6, a3, a4
42010534:	fd9656        	bnez	a6, 42010511 <_vfprintf_r+0x2361>
42010537:	d0c232        	addi	a3, a2, -48
4201053a:	120c      	movi.n	a2, 1
4201053c:	832630        	moveqz	a2, a6, a3
4201053f:	742020        	extui	a2, a2, 0, 8
42010542:	172216        	beqz	a2, 420106b8 <_vfprintf_r+0x2508>
42010545:	a02122        	l32i	a2, a1, 0x280
42010548:	02e207        	bbsi	a2, 0, 4201054e <_vfprintf_r+0x239e>
4201054b:	005a46        	j	420106b8 <_vfprintf_r+0x2508>
4201054e:	280b      	addi.n	a2, a8, -1
42010550:	033c      	movi.n	a3, 48
42010552:	fec552        	addi	a5, a5, -2
42010555:	004232        	s8i	a3, a2, 0
42010558:	a26152        	s32i	a5, a1, 0x288
4201055b:	005646        	j	420106b8 <_vfprintf_r+0x2508>
4201055e:	a4dc      	bnez.n	a4, 4201057c <_vfprintf_r+0x23cc>
42010560:	920c      	movi.n	a2, 9
42010562:	163237        	bltu	a2, a3, 4201057c <_vfprintf_r+0x23cc>
42010565:	10c142        	addi	a4, a1, 16
42010568:	01d422        	addmi	a2, a4, 0x100
4201056b:	30c332        	addi	a3, a3, 48
4201056e:	e34232        	s8i	a3, a2, 227
42010571:	e3a122        	movi	a2, 0x1e3
42010574:	842a      	add.n	a8, a4, a2
42010576:	a26182        	s32i	a8, a1, 0x288
42010579:	004ec6        	j	420106b8 <_vfprintf_r+0x2508>
4201057c:	020c      	movi.n	a2, 0
4201057e:	a02162        	l32i	a6, a1, 0x280
42010581:	a66122        	s32i	a2, a1, 0x298
42010584:	f4a152        	movi	a5, 0x1f4
42010587:	00a422        	movi	a2, 0x400
4201058a:	515a      	add.n	a5, a1, a5
4201058c:	102620        	and	a2, a6, a2
4201058f:	000206        	j	4201059b <_vfprintf_r+0x23eb>
42010592:	00          	.byte 00
42010593:	00          	.byte 00
42010594:	a22152        	l32i	a5, a1, 0x288
42010597:	0a3d      	mov.n	a3, a10
42010599:	0b4d      	mov.n	a4, a11
4201059b:	550b      	addi.n	a5, a5, -1
4201059d:	ac0c      	movi.n	a12, 10
4201059f:	0d0c      	movi.n	a13, 0
420105a1:	03ad      	mov.n	a10, a3
420105a3:	04bd      	mov.n	a11, a4
420105a5:	b96192        	s32i	a9, a1, 0x2e4
420105a8:	a26152        	s32i	a5, a1, 0x288
420105ab:	c19a81        	l32r	a8, 42000c14 <_stext+0xbf4>
420105ae:	0008e0        	callx8	a8
420105b1:	a62182        	l32i	a8, a1, 0x298
420105b4:	30caa2        	addi	a10, a10, 48
420105b7:	881b      	addi.n	a8, a8, 1
420105b9:	0045a2        	s8i	a10, a5, 0
420105bc:	a66182        	s32i	a8, a1, 0x298
420105bf:	b92192        	l32i	a9, a1, 0x2e4
420105c2:	056216        	beqz	a2, 4201061c <_vfprintf_r+0x246c>
420105c5:	ac2152        	l32i	a5, a1, 0x2b0
420105c8:	01af82        	movi	a8, -255
420105cb:	000572        	l8ui	a7, a5, 0
420105ce:	060c      	movi.n	a6, 0
420105d0:	878a      	add.n	a8, a7, a8
420105d2:	150c      	movi.n	a5, 1
420105d4:	936580        	movnez	a6, a5, a8
420105d7:	54cc      	bnez.n	a4, 420105e0 <_vfprintf_r+0x2430>
420105d9:	980c      	movi.n	a8, 9
420105db:	013837        	bltu	a8, a3, 420105e0 <_vfprintf_r+0x2430>
420105de:	045d      	mov.n	a5, a4
420105e0:	380657        	bnone	a6, a5, 4201061c <_vfprintf_r+0x246c>
420105e3:	a62162        	l32i	a6, a1, 0x298
420105e6:	329767        	bne	a7, a6, 4201061c <_vfprintf_r+0x246c>
420105e9:	b02152        	l32i	a5, a1, 0x2c0
420105ec:	a22182        	l32i	a8, a1, 0x288
420105ef:	b521b2        	l32i	a11, a1, 0x2d4
420105f2:	c08850        	sub	a8, a8, a5
420105f5:	05cd      	mov.n	a12, a5
420105f7:	08ad      	mov.n	a10, a8
420105f9:	a26182        	s32i	a8, a1, 0x288
420105fc:	b96192        	s32i	a9, a1, 0x2e4
420105ff:	c14181        	l32r	a8, 42000b04 <_stext+0xae4>
42010602:	0008e0        	callx8	a8
42010605:	ac2162        	l32i	a6, a1, 0x2b0
42010608:	080c      	movi.n	a8, 0
4201060a:	010652        	l8ui	a5, a6, 1
4201060d:	a66182        	s32i	a8, a1, 0x298
42010610:	b92192        	l32i	a9, a1, 0x2e4
42010613:	051587        	beq	a5, a8, 4201061c <_vfprintf_r+0x246c>
42010616:	01c662        	addi	a6, a6, 1
42010619:	ac6162        	s32i	a6, a1, 0x2b0
4201061c:	ac0c      	movi.n	a12, 10
4201061e:	0d0c      	movi.n	a13, 0
42010620:	03ad      	mov.n	a10, a3
42010622:	04bd      	mov.n	a11, a4
42010624:	b96192        	s32i	a9, a1, 0x2e4
42010627:	be9e81        	l32r	a8, 420000a0 <_stext+0x80>
4201062a:	0008e0        	callx8	a8
4201062d:	b92192        	l32i	a9, a1, 0x2e4
42010630:	f60456        	bnez	a4, 42010594 <_vfprintf_r+0x23e4>
42010633:	940c      	movi.n	a4, 9
42010635:	02b437        	bgeu	a4, a3, 4201063b <_vfprintf_r+0x248b>
42010638:	ffd606        	j	42010594 <_vfprintf_r+0x23e4>
4201063b:	001e46        	j	420106b8 <_vfprintf_r+0x2508>
4201063e:	00          	.byte 00
4201063f:	00          	.byte 00
42010640:	00          	.byte 00
42010641:	90a122        	movi	a2, 0x190
42010644:	221a      	add.n	a2, a2, a1
42010646:	64c222        	addi	a2, a2, 100
42010649:	a26122        	s32i	a2, a1, 0x288
4201064c:	b42152        	l32i	a5, a1, 0x2d0
4201064f:	342030        	extui	a2, a3, 0, 4
42010652:	a22182        	l32i	a8, a1, 0x288
42010655:	252a      	add.n	a2, a5, a2
42010657:	000222        	l8ui	a2, a2, 0
4201065a:	880b      	addi.n	a8, a8, -1
4201065c:	004822        	s8i	a2, a8, 0
4201065f:	413430        	srli	a3, a3, 4
42010662:	012440        	slli	a2, a4, 28
42010665:	203230        	or	a3, a2, a3
42010668:	414440        	srli	a4, a4, 4
4201066b:	a26182        	s32i	a8, a1, 0x288
4201066e:	202340        	or	a2, a3, a4
42010671:	fd7256        	bnez	a2, 4201064c <_vfprintf_r+0x249c>
42010674:	001006        	j	420106b8 <_vfprintf_r+0x2508>
42010677:	00          	.byte 00
42010678:	80a132        	movi	a3, 0x180
4201067b:	a2ec      	bnez.n	a2, 420106a9 <_vfprintf_r+0x24f9>
4201067d:	10c182        	addi	a8, a1, 16
42010680:	483a      	add.n	a4, a8, a3
42010682:	046070        	extui	a6, a7, 0, 1
42010685:	64c442        	addi	a4, a4, 100
42010688:	a46162        	s32i	a6, a1, 0x290
4201068b:	a26142        	s32i	a4, a1, 0x288
4201068e:	66ac      	beqz.n	a6, 420106b8 <_vfprintf_r+0x2508>
42010690:	a46122        	s32i	a2, a1, 0x290
42010693:	90a122        	movi	a2, 0x190
42010696:	221a      	add.n	a2, a2, a1
42010698:	01d842        	addmi	a4, a8, 0x100
4201069b:	053c      	movi.n	a5, 48
4201069d:	63c222        	addi	a2, a2, 99
420106a0:	e34452        	s8i	a5, a4, 227
420106a3:	a26122        	s32i	a2, a1, 0x288
420106a6:	000386        	j	420106b8 <_vfprintf_r+0x2508>
420106a9:	90a132        	movi	a3, 0x190
420106ac:	803310        	add	a3, a3, a1
420106af:	64c332        	addi	a3, a3, 100
420106b2:	a46152        	s32i	a5, a1, 0x290
420106b5:	a26132        	s32i	a3, a1, 0x288
420106b8:	a22142        	l32i	a4, a1, 0x288
420106bb:	f4a122        	movi	a2, 0x1f4
420106be:	212a      	add.n	a2, a1, a2
420106c0:	060c      	movi.n	a6, 0
420106c2:	c02240        	sub	a2, a2, a4
420106c5:	a42152        	l32i	a5, a1, 0x290
420106c8:	a56162        	s32i	a6, a1, 0x294
420106cb:	a46122        	s32i	a2, a1, 0x290
420106ce:	063d      	mov.n	a3, a6
420106d0:	000e06        	j	4201070c <_vfprintf_r+0x255c>
420106d3:	00          	.byte 00
420106d4:	a72182        	l32i	a8, a1, 0x29c
420106d7:	18cc      	bnez.n	a8, 420106dc <_vfprintf_r+0x252c>
420106d9:	02c5c6        	j	420111f4 <_vfprintf_r+0x3044>
420106dc:	10c1a2        	addi	a10, a1, 16
420106df:	01da22        	addmi	a2, a10, 0x100
420106e2:	030c      	movi.n	a3, 0
420106e4:	804282        	s8i	a8, a2, 128
420106e7:	02da22        	addmi	a2, a10, 0x200
420106ea:	564232        	s8i	a3, a2, 86
420106ed:	020c      	movi.n	a2, 0
420106ef:	130c      	movi.n	a3, 1
420106f1:	a46132        	s32i	a3, a1, 0x290
420106f4:	a56122        	s32i	a2, a1, 0x294
420106f7:	025d      	mov.n	a5, a2
420106f9:	023d      	mov.n	a3, a2
420106fb:	024d      	mov.n	a4, a2
420106fd:	90a182        	movi	a8, 0x190
42010700:	818a      	add.n	a8, a1, a8
42010702:	a26182        	s32i	a8, a1, 0x288
42010705:	0001c6        	j	42010710 <_vfprintf_r+0x2560>
42010708:	00          	.byte 00
42010709:	00          	.byte 00
4201070a:	053d      	mov.n	a3, a5
4201070c:	034d      	mov.n	a4, a3
4201070e:	042d      	mov.n	a2, a4
42010710:	a421e2        	l32i	a14, a1, 0x290
42010713:	10c182        	addi	a8, a1, 16
42010716:	02d862        	addmi	a6, a8, 0x200
42010719:	53e5e0        	max	a14, a5, a14
4201071c:	560662        	l8ui	a6, a6, 86
4201071f:	af61e2        	s32i	a14, a1, 0x2bc
42010722:	368c      	beqz.n	a6, 42010729 <_vfprintf_r+0x2579>
42010724:	ee1b      	addi.n	a14, a14, 1
42010726:	af61e2        	s32i	a14, a1, 0x2bc
42010729:	a02182        	l32i	a8, a1, 0x280
4201072c:	260c      	movi.n	a6, 2
4201072e:	106860        	and	a6, a8, a6
42010731:	b16162        	s32i	a6, a1, 0x2c4
42010734:	008616        	beqz	a6, 42010740 <_vfprintf_r+0x2590>
42010737:	af21e2        	l32i	a14, a1, 0x2bc
4201073a:	02cee2        	addi	a14, a14, 2
4201073d:	af61e2        	s32i	a14, a1, 0x2bc
42010740:	a02182        	l32i	a8, a1, 0x280
42010743:	84a062        	movi	a6, 132
42010746:	106860        	and	a6, a8, a6
42010749:	b36162        	s32i	a6, a1, 0x2cc
4201074c:	08a656        	bnez	a6, 420107da <_vfprintf_r+0x262a>
4201074f:	ab2182        	l32i	a8, a1, 0x2ac
42010752:	af21e2        	l32i	a14, a1, 0x2bc
42010755:	0d1c      	movi.n	a13, 16
42010757:	c068e0        	sub	a6, a8, a14
4201075a:	3716e6        	bgei	a6, 1, 42010795 <_vfprintf_r+0x25e5>
4201075d:	001e46        	j	420107da <_vfprintf_r+0x262a>
42010760:	10cbb2        	addi	a11, a11, 16
42010763:	19d9      	s32i.n	a13, a9, 4
42010765:	b8b9      	s32i.n	a11, a8, 44
42010767:	a879      	s32i.n	a7, a8, 40
42010769:	2387a6        	blti	a7, 8, 42010790 <_vfprintf_r+0x25e0>
4201076c:	a121b2        	l32i	a11, a1, 0x284
4201076f:	a321a2        	l32i	a10, a1, 0x28c
42010772:	34a2c2        	movi	a12, 0x234
42010775:	cc1a      	add.n	a12, a12, a1
42010777:	b761d2        	s32i	a13, a1, 0x2dc
4201077a:	201110        	or	a1, a1, a1
4201077d:	0531e5        	call8	42015a9c <__sprint_r>
42010780:	b721d2        	l32i	a13, a1, 0x2dc
42010783:	1a8c      	beqz.n	a10, 42010788 <_vfprintf_r+0x25d8>
42010785:	02a486        	j	4201121b <_vfprintf_r+0x306b>
42010788:	e4a1a2        	movi	a10, 0x1e4
4201078b:	10c182        	addi	a8, a1, 16
4201078e:	a8aa      	add.n	a10, a8, a10
42010790:	f0c662        	addi	a6, a6, -16
42010793:	0a9d      	mov.n	a9, a10
42010795:	10c1a2        	addi	a10, a1, 16
42010798:	c12cc1        	l32r	a12, 42000c48 <_stext+0xc28>
4201079b:	8a2a72        	l32i	a7, a10, 0x228
4201079e:	09c9      	s32i.n	a12, a9, 0
420107a0:	02da82        	addmi	a8, a10, 0x200
420107a3:	771b      	addi.n	a7, a7, 1
420107a5:	a98b      	addi.n	a10, a9, 8
420107a7:	b8b8      	l32i.n	a11, a8, 44
420107a9:	b32d67        	blt	a13, a6, 42010760 <_vfprintf_r+0x25b0>
420107ac:	1969      	s32i.n	a6, a9, 4
420107ae:	66ba      	add.n	a6, a6, a11
420107b0:	b869      	s32i.n	a6, a8, 44
420107b2:	a879      	s32i.n	a7, a8, 40
420107b4:	0a9d      	mov.n	a9, a10
420107b6:	2087a6        	blti	a7, 8, 420107da <_vfprintf_r+0x262a>
420107b9:	10c1b2        	addi	a11, a1, 16
420107bc:	24a2c2        	movi	a12, 0x224
420107bf:	cbca      	add.n	a12, a11, a12
420107c1:	a321a2        	l32i	a10, a1, 0x28c
420107c4:	a121b2        	l32i	a11, a1, 0x284
420107c7:	201110        	or	a1, a1, a1
420107ca:	052d25        	call8	42015a9c <__sprint_r>
420107cd:	1a8c      	beqz.n	a10, 420107d2 <_vfprintf_r+0x2622>
420107cf:	029206        	j	4201121b <_vfprintf_r+0x306b>
420107d2:	e4a162        	movi	a6, 0x1e4
420107d5:	10c1e2        	addi	a14, a1, 16
420107d8:	9e6a      	add.n	a9, a14, a6
420107da:	10c162        	addi	a6, a1, 16
420107dd:	02d672        	addmi	a7, a6, 0x200
420107e0:	560782        	l8ui	a8, a7, 86
420107e3:	8f2162        	l32i	a6, a1, 0x23c
420107e6:	88bc      	beqz.n	a8, 42010822 <_vfprintf_r+0x2672>
420107e8:	66a2a2        	movi	a10, 0x266
420107eb:	81aa      	add.n	a8, a1, a10
420107ed:	0989      	s32i.n	a8, a9, 0
420107ef:	180c      	movi.n	a8, 1
420107f1:	668a      	add.n	a6, a6, a8
420107f3:	b769      	s32i.n	a6, a7, 44
420107f5:	a768      	l32i.n	a6, a7, 40
420107f7:	1989      	s32i.n	a8, a9, 4
420107f9:	668a      	add.n	a6, a6, a8
420107fb:	a769      	s32i.n	a6, a7, 40
420107fd:	08c992        	addi	a9, a9, 8
42010800:	1e86a6        	blti	a6, 8, 42010822 <_vfprintf_r+0x2672>
42010803:	10c1b2        	addi	a11, a1, 16
42010806:	24a2c2        	movi	a12, 0x224
42010809:	80cbc0        	add	a12, a11, a12
4201080c:	a321a2        	l32i	a10, a1, 0x28c
4201080f:	a121b2        	l32i	a11, a1, 0x284
42010812:	201110        	or	a1, a1, a1
42010815:	052865        	call8	42015a9c <__sprint_r>
42010818:	1a8c      	beqz.n	a10, 4201081d <_vfprintf_r+0x266d>
4201081a:	027f46        	j	4201121b <_vfprintf_r+0x306b>
4201081d:	f4a1e2        	movi	a14, 0x1f4
42010820:	91ea      	add.n	a9, a1, a14
42010822:	b12182        	l32i	a8, a1, 0x2c4
42010825:	10c162        	addi	a6, a1, 16
42010828:	02d672        	addmi	a7, a6, 0x200
4201082b:	8f2162        	l32i	a6, a1, 0x23c
4201082e:	88bc      	beqz.n	a8, 4201086a <_vfprintf_r+0x26ba>
42010830:	64a2a2        	movi	a10, 0x264
42010833:	81aa      	add.n	a8, a1, a10
42010835:	0989      	s32i.n	a8, a9, 0
42010837:	280c      	movi.n	a8, 2
42010839:	668a      	add.n	a6, a6, a8
4201083b:	b769      	s32i.n	a6, a7, 44
4201083d:	a768      	l32i.n	a6, a7, 40
4201083f:	1989      	s32i.n	a8, a9, 4
42010841:	661b      	addi.n	a6, a6, 1
42010843:	a769      	s32i.n	a6, a7, 40
42010845:	08c992        	addi	a9, a9, 8
42010848:	1e86a6        	blti	a6, 8, 4201086a <_vfprintf_r+0x26ba>
4201084b:	10c1b2        	addi	a11, a1, 16
4201084e:	24a2c2        	movi	a12, 0x224
42010851:	80cbc0        	add	a12, a11, a12
42010854:	a321a2        	l32i	a10, a1, 0x28c
42010857:	a121b2        	l32i	a11, a1, 0x284
4201085a:	201110        	or	a1, a1, a1
4201085d:	0523e5        	call8	42015a9c <__sprint_r>
42010860:	1a8c      	beqz.n	a10, 42010865 <_vfprintf_r+0x26b5>
42010862:	026d46        	j	4201121b <_vfprintf_r+0x306b>
42010865:	f4a1e2        	movi	a14, 0x1f4
42010868:	91ea      	add.n	a9, a1, a14
4201086a:	b32162        	l32i	a6, a1, 0x2cc
4201086d:	02e626        	beqi	a6, 128, 42010873 <_vfprintf_r+0x26c3>
42010870:	002286        	j	420108fe <_vfprintf_r+0x274e>
42010873:	ab2182        	l32i	a8, a1, 0x2ac
42010876:	af21e2        	l32i	a14, a1, 0x2bc
42010879:	0d1c      	movi.n	a13, 16
4201087b:	c068e0        	sub	a6, a8, a14
4201087e:	3716e6        	bgei	a6, 1, 420108b9 <_vfprintf_r+0x2709>
42010881:	001e46        	j	420108fe <_vfprintf_r+0x274e>
42010884:	10cbb2        	addi	a11, a11, 16
42010887:	19d9      	s32i.n	a13, a9, 4
42010889:	b8b9      	s32i.n	a11, a8, 44
4201088b:	a879      	s32i.n	a7, a8, 40
4201088d:	2387a6        	blti	a7, 8, 420108b4 <_vfprintf_r+0x2704>
42010890:	a121b2        	l32i	a11, a1, 0x284
42010893:	a321a2        	l32i	a10, a1, 0x28c
42010896:	34a2c2        	movi	a12, 0x234
42010899:	cc1a      	add.n	a12, a12, a1
4201089b:	b761d2        	s32i	a13, a1, 0x2dc
4201089e:	201110        	or	a1, a1, a1
420108a1:	051fa5        	call8	42015a9c <__sprint_r>
420108a4:	b721d2        	l32i	a13, a1, 0x2dc
420108a7:	1a8c      	beqz.n	a10, 420108ac <_vfprintf_r+0x26fc>
420108a9:	025b86        	j	4201121b <_vfprintf_r+0x306b>
420108ac:	e4a1a2        	movi	a10, 0x1e4
420108af:	10c182        	addi	a8, a1, 16
420108b2:	a8aa      	add.n	a10, a8, a10
420108b4:	f0c662        	addi	a6, a6, -16
420108b7:	0a9d      	mov.n	a9, a10
420108b9:	10c1a2        	addi	a10, a1, 16
420108bc:	c0e4c1        	l32r	a12, 42000c4c <_stext+0xc2c>
420108bf:	8a2a72        	l32i	a7, a10, 0x228
420108c2:	09c9      	s32i.n	a12, a9, 0
420108c4:	02da82        	addmi	a8, a10, 0x200
420108c7:	771b      	addi.n	a7, a7, 1
420108c9:	a98b      	addi.n	a10, a9, 8
420108cb:	b8b8      	l32i.n	a11, a8, 44
420108cd:	b32d67        	blt	a13, a6, 42010884 <_vfprintf_r+0x26d4>
420108d0:	1969      	s32i.n	a6, a9, 4
420108d2:	66ba      	add.n	a6, a6, a11
420108d4:	b869      	s32i.n	a6, a8, 44
420108d6:	a879      	s32i.n	a7, a8, 40
420108d8:	0a9d      	mov.n	a9, a10
420108da:	2087a6        	blti	a7, 8, 420108fe <_vfprintf_r+0x274e>
420108dd:	10c1b2        	addi	a11, a1, 16
420108e0:	24a2c2        	movi	a12, 0x224
420108e3:	cbca      	add.n	a12, a11, a12
420108e5:	a321a2        	l32i	a10, a1, 0x28c
420108e8:	a121b2        	l32i	a11, a1, 0x284
420108eb:	201110        	or	a1, a1, a1
420108ee:	051ae5        	call8	42015a9c <__sprint_r>
420108f1:	1a8c      	beqz.n	a10, 420108f6 <_vfprintf_r+0x2746>
420108f3:	024906        	j	4201121b <_vfprintf_r+0x306b>
420108f6:	e4a162        	movi	a6, 0x1e4
420108f9:	10c1e2        	addi	a14, a1, 16
420108fc:	9e6a      	add.n	a9, a14, a6
420108fe:	a42162        	l32i	a6, a1, 0x290
42010901:	081c      	movi.n	a8, 16
42010903:	c05560        	sub	a5, a5, a6
42010906:	3715e6        	bgei	a5, 1, 42010941 <_vfprintf_r+0x2791>
42010909:	001e06        	j	42010985 <_vfprintf_r+0x27d5>
4201090c:	10caa2        	addi	a10, a10, 16
4201090f:	1989      	s32i.n	a8, a9, 4
42010911:	b7a9      	s32i.n	a10, a7, 44
42010913:	a769      	s32i.n	a6, a7, 40
42010915:	2386a6        	blti	a6, 8, 4201093c <_vfprintf_r+0x278c>
42010918:	a121b2        	l32i	a11, a1, 0x284
4201091b:	a321a2        	l32i	a10, a1, 0x28c
4201091e:	34a2c2        	movi	a12, 0x234
42010921:	cc1a      	add.n	a12, a12, a1
42010923:	b76182        	s32i	a8, a1, 0x2dc
42010926:	201110        	or	a1, a1, a1
42010929:	051725        	call8	42015a9c <__sprint_r>
4201092c:	b72182        	l32i	a8, a1, 0x2dc
4201092f:	1a8c      	beqz.n	a10, 42010934 <_vfprintf_r+0x2784>
42010931:	023986        	j	4201121b <_vfprintf_r+0x306b>
42010934:	e4a192        	movi	a9, 0x1e4
42010937:	10c1a2        	addi	a10, a1, 16
4201093a:	ca9a      	add.n	a12, a10, a9
4201093c:	f0c552        	addi	a5, a5, -16
4201093f:	0c9d      	mov.n	a9, a12
42010941:	10c1b2        	addi	a11, a1, 16
42010944:	02db72        	addmi	a7, a11, 0x200
42010947:	c0c1b1        	l32r	a11, 42000c4c <_stext+0xc2c>
4201094a:	a768      	l32i.n	a6, a7, 40
4201094c:	09b9      	s32i.n	a11, a9, 0
4201094e:	661b      	addi.n	a6, a6, 1
42010950:	c98b      	addi.n	a12, a9, 8
42010952:	b7a8      	l32i.n	a10, a7, 44
42010954:	b42857        	blt	a8, a5, 4201090c <_vfprintf_r+0x275c>
42010957:	1959      	s32i.n	a5, a9, 4
42010959:	55aa      	add.n	a5, a5, a10
4201095b:	b759      	s32i.n	a5, a7, 44
4201095d:	a769      	s32i.n	a6, a7, 40
4201095f:	0c9d      	mov.n	a9, a12
42010961:	2086a6        	blti	a6, 8, 42010985 <_vfprintf_r+0x27d5>
42010964:	24a2c2        	movi	a12, 0x224
42010967:	10c1e2        	addi	a14, a1, 16
4201096a:	a121b2        	l32i	a11, a1, 0x284
4201096d:	a321a2        	l32i	a10, a1, 0x28c
42010970:	ceca      	add.n	a12, a14, a12
42010972:	201110        	or	a1, a1, a1
42010975:	051265        	call8	42015a9c <__sprint_r>
42010978:	1a8c      	beqz.n	a10, 4201097d <_vfprintf_r+0x27cd>
4201097a:	022746        	j	4201121b <_vfprintf_r+0x306b>
4201097d:	e4a152        	movi	a5, 0x1e4
42010980:	10c162        	addi	a6, a1, 16
42010983:	965a      	add.n	a9, a6, a5
42010985:	10c182        	addi	a8, a1, 16
42010988:	a02152        	l32i	a5, a1, 0x280
4201098b:	02d862        	addmi	a6, a8, 0x200
4201098e:	b678      	l32i.n	a7, a6, 44
42010990:	3de587        	bbsi	a5, 8, 420109d1 <_vfprintf_r+0x2821>
42010993:	a42122        	l32i	a2, a1, 0x290
42010996:	a22182        	l32i	a8, a1, 0x288
42010999:	1929      	s32i.n	a2, a9, 4
4201099b:	727a      	add.n	a7, a2, a7
4201099d:	a628      	l32i.n	a2, a6, 40
4201099f:	0989      	s32i.n	a8, a9, 0
420109a1:	221b      	addi.n	a2, a2, 1
420109a3:	b679      	s32i.n	a7, a6, 44
420109a5:	a629      	s32i.n	a2, a6, 40
420109a7:	998b      	addi.n	a9, a9, 8
420109a9:	0282e6        	bgei	a2, 8, 420109af <_vfprintf_r+0x27ff>
420109ac:	01da06        	j	42011118 <_vfprintf_r+0x2f68>
420109af:	24a2c2        	movi	a12, 0x224
420109b2:	10c132        	addi	a3, a1, 16
420109b5:	a121b2        	l32i	a11, a1, 0x284
420109b8:	a321a2        	l32i	a10, a1, 0x28c
420109bb:	80c3c0        	add	a12, a3, a12
420109be:	201110        	or	a1, a1, a1
420109c1:	050da5        	call8	42015a9c <__sprint_r>
420109c4:	1a8c      	beqz.n	a10, 420109c9 <_vfprintf_r+0x2819>
420109c6:	021446        	j	4201121b <_vfprintf_r+0x306b>
420109c9:	f4a142        	movi	a4, 0x1f4
420109cc:	914a      	add.n	a9, a1, a4
420109ce:	01d186        	j	42011118 <_vfprintf_r+0x2f68>
420109d1:	a72182        	l32i	a8, a1, 0x29c
420109d4:	65a052        	movi	a5, 101
420109d7:	022587        	blt	a5, a8, 420109dd <_vfprintf_r+0x282d>
420109da:	016586        	j	42010f74 <_vfprintf_r+0x2dc4>
420109dd:	bf84c1        	l32r	a12, 420007f0 <_stext+0x7d0>
420109e0:	bf84d1        	l32r	a13, 420007f0 <_stext+0x7d0>
420109e3:	a821a2        	l32i	a10, a1, 0x2a0
420109e6:	a921b2        	l32i	a11, a1, 0x2a4
420109e9:	b96192        	s32i	a9, a1, 0x2e4
420109ec:	c08781        	l32r	a8, 42000c08 <_stext+0xbe8>
420109ef:	0008e0        	callx8	a8
420109f2:	b92192        	l32i	a9, a1, 0x2e4
420109f5:	107a56        	bnez	a10, 42010b00 <_vfprintf_r+0x2950>
420109f8:	c09621        	l32r	a2, 42000c50 <_stext+0xc30>
420109fb:	0929      	s32i.n	a2, a9, 0
420109fd:	120c      	movi.n	a2, 1
420109ff:	1929      	s32i.n	a2, a9, 4
42010a01:	772a      	add.n	a7, a7, a2
42010a03:	a628      	l32i.n	a2, a6, 40
42010a05:	b679      	s32i.n	a7, a6, 44
42010a07:	221b      	addi.n	a2, a2, 1
42010a09:	a629      	s32i.n	a2, a6, 40
42010a0b:	998b      	addi.n	a9, a9, 8
42010a0d:	1b82a6        	blti	a2, 8, 42010a2c <_vfprintf_r+0x287c>
42010a10:	10c1a2        	addi	a10, a1, 16
42010a13:	24a2c2        	movi	a12, 0x224
42010a16:	caca      	add.n	a12, a10, a12
42010a18:	a121b2        	l32i	a11, a1, 0x284
42010a1b:	a321a2        	l32i	a10, a1, 0x28c
42010a1e:	201110        	or	a1, a1, a1
42010a21:	0507a5        	call8	42015a9c <__sprint_r>
42010a24:	7f3a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010a27:	f4a1b2        	movi	a11, 0x1f4
42010a2a:	91ba      	add.n	a9, a1, a11
42010a2c:	962122        	l32i	a2, a1, 0x258
42010a2f:	a62132        	l32i	a3, a1, 0x298
42010a32:	082237        	blt	a2, a3, 42010a3e <_vfprintf_r+0x288e>
42010a35:	a02142        	l32i	a4, a1, 0x280
42010a38:	02e407        	bbsi	a4, 0, 42010a3e <_vfprintf_r+0x288e>
42010a3b:	01b646        	j	42011118 <_vfprintf_r+0x2f68>
42010a3e:	ae2162        	l32i	a6, a1, 0x2b8
42010a41:	8f2122        	l32i	a2, a1, 0x23c
42010a44:	b22152        	l32i	a5, a1, 0x2c8
42010a47:	226a      	add.n	a2, a2, a6
42010a49:	8f6122        	s32i	a2, a1, 0x23c
42010a4c:	8e2122        	l32i	a2, a1, 0x238
42010a4f:	0959      	s32i.n	a5, a9, 0
42010a51:	221b      	addi.n	a2, a2, 1
42010a53:	1969      	s32i.n	a6, a9, 4
42010a55:	8e6122        	s32i	a2, a1, 0x238
42010a58:	998b      	addi.n	a9, a9, 8
42010a5a:	1b82a6        	blti	a2, 8, 42010a79 <_vfprintf_r+0x28c9>
42010a5d:	10c1a2        	addi	a10, a1, 16
42010a60:	24a2c2        	movi	a12, 0x224
42010a63:	caca      	add.n	a12, a10, a12
42010a65:	a121b2        	l32i	a11, a1, 0x284
42010a68:	a321a2        	l32i	a10, a1, 0x28c
42010a6b:	201110        	or	a1, a1, a1
42010a6e:	0502e5        	call8	42015a9c <__sprint_r>
42010a71:	7a6a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010a74:	f4a1b2        	movi	a11, 0x1f4
42010a77:	91ba      	add.n	a9, a1, a11
42010a79:	a62132        	l32i	a3, a1, 0x298
42010a7c:	051c      	movi.n	a5, 16
42010a7e:	230b      	addi.n	a2, a3, -1
42010a80:	3112e6        	bgei	a2, 1, 42010ab5 <_vfprintf_r+0x2905>
42010a83:	01a446        	j	42011118 <_vfprintf_r+0x2f68>
42010a86:	10c772        	addi	a7, a7, 16
42010a89:	1959      	s32i.n	a5, a9, 4
42010a8b:	b479      	s32i.n	a7, a4, 44
42010a8d:	a439      	s32i.n	a3, a4, 40
42010a8f:	1d83a6        	blti	a3, 8, 42010ab0 <_vfprintf_r+0x2900>
42010a92:	34a2c2        	movi	a12, 0x234
42010a95:	a121b2        	l32i	a11, a1, 0x284
42010a98:	a321a2        	l32i	a10, a1, 0x28c
42010a9b:	80cc10        	add	a12, a12, a1
42010a9e:	201110        	or	a1, a1, a1
42010aa1:	04ffa5        	call8	42015a9c <__sprint_r>
42010aa4:	773a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010aa7:	e4a162        	movi	a6, 0x1e4
42010aaa:	10c142        	addi	a4, a1, 16
42010aad:	806460        	add	a6, a4, a6
42010ab0:	f0c222        	addi	a2, a2, -16
42010ab3:	069d      	mov.n	a9, a6
42010ab5:	10c162        	addi	a6, a1, 16
42010ab8:	c06581        	l32r	a8, 42000c4c <_stext+0xc2c>
42010abb:	8a2632        	l32i	a3, a6, 0x228
42010abe:	0989      	s32i.n	a8, a9, 0
42010ac0:	02d642        	addmi	a4, a6, 0x200
42010ac3:	331b      	addi.n	a3, a3, 1
42010ac5:	698b      	addi.n	a6, a9, 8
42010ac7:	b478      	l32i.n	a7, a4, 44
42010ac9:	b92527        	blt	a5, a2, 42010a86 <_vfprintf_r+0x28d6>
42010acc:	1929      	s32i.n	a2, a9, 4
42010ace:	227a      	add.n	a2, a2, a7
42010ad0:	b429      	s32i.n	a2, a4, 44
42010ad2:	a439      	s32i.n	a3, a4, 40
42010ad4:	069d      	mov.n	a9, a6
42010ad6:	0283e6        	bgei	a3, 8, 42010adc <_vfprintf_r+0x292c>
42010ad9:	018ec6        	j	42011118 <_vfprintf_r+0x2f68>
42010adc:	24a2c2        	movi	a12, 0x224
42010adf:	10c182        	addi	a8, a1, 16
42010ae2:	a121b2        	l32i	a11, a1, 0x284
42010ae5:	a321a2        	l32i	a10, a1, 0x28c
42010ae8:	c8ca      	add.n	a12, a8, a12
42010aea:	201110        	or	a1, a1, a1
42010aed:	04fae5        	call8	42015a9c <__sprint_r>
42010af0:	727a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010af3:	e4a122        	movi	a2, 0x1e4
42010af6:	10c1a2        	addi	a10, a1, 16
42010af9:	9a2a      	add.n	a9, a10, a2
42010afb:	018646        	j	42011118 <_vfprintf_r+0x2f68>
42010afe:	00          	.byte 00
42010aff:	00          	.byte 00
42010b00:	962152        	l32i	a5, a1, 0x258
42010b03:	0215a6        	blti	a5, 1, 42010b09 <_vfprintf_r+0x2959>
42010b06:	0048c6        	j	42010c2d <_vfprintf_r+0x2a7d>
42010b09:	c05121        	l32r	a2, 42000c50 <_stext+0xc30>
42010b0c:	0929      	s32i.n	a2, a9, 0
42010b0e:	120c      	movi.n	a2, 1
42010b10:	1929      	s32i.n	a2, a9, 4
42010b12:	772a      	add.n	a7, a7, a2
42010b14:	a628      	l32i.n	a2, a6, 40
42010b16:	b679      	s32i.n	a7, a6, 44
42010b18:	221b      	addi.n	a2, a2, 1
42010b1a:	a629      	s32i.n	a2, a6, 40
42010b1c:	998b      	addi.n	a9, a9, 8
42010b1e:	1b82a6        	blti	a2, 8, 42010b3d <_vfprintf_r+0x298d>
42010b21:	10c1b2        	addi	a11, a1, 16
42010b24:	24a2c2        	movi	a12, 0x224
42010b27:	cbca      	add.n	a12, a11, a12
42010b29:	a321a2        	l32i	a10, a1, 0x28c
42010b2c:	a121b2        	l32i	a11, a1, 0x284
42010b2f:	201110        	or	a1, a1, a1
42010b32:	04f6a5        	call8	42015a9c <__sprint_r>
42010b35:	6e2a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010b38:	f4a1e2        	movi	a14, 0x1f4
42010b3b:	91ea      	add.n	a9, a1, a14
42010b3d:	10c122        	addi	a2, a1, 16
42010b40:	a62152        	l32i	a5, a1, 0x298
42010b43:	a02162        	l32i	a6, a1, 0x280
42010b46:	02d232        	addmi	a3, a2, 0x200
42010b49:	962122        	l32i	a2, a1, 0x258
42010b4c:	8f2142        	l32i	a4, a1, 0x23c
42010b4f:	202520        	or	a2, a5, a2
42010b52:	045060        	extui	a5, a6, 0, 1
42010b55:	202250        	or	a2, a2, a5
42010b58:	5bc216        	beqz	a2, 42011118 <_vfprintf_r+0x2f68>
42010b5b:	ae2122        	l32i	a2, a1, 0x2b8
42010b5e:	b22182        	l32i	a8, a1, 0x2c8
42010b61:	1929      	s32i.n	a2, a9, 4
42010b63:	025d      	mov.n	a5, a2
42010b65:	224a      	add.n	a2, a2, a4
42010b67:	b329      	s32i.n	a2, a3, 44
42010b69:	a328      	l32i.n	a2, a3, 40
42010b6b:	0989      	s32i.n	a8, a9, 0
42010b6d:	221b      	addi.n	a2, a2, 1
42010b6f:	a329      	s32i.n	a2, a3, 40
42010b71:	0482e6        	bgei	a2, 8, 42010b79 <_vfprintf_r+0x29c9>
42010b74:	298b      	addi.n	a2, a9, 8
42010b76:	0006c6        	j	42010b95 <_vfprintf_r+0x29e5>
42010b79:	24a2c2        	movi	a12, 0x224
42010b7c:	10c162        	addi	a6, a1, 16
42010b7f:	a121b2        	l32i	a11, a1, 0x284
42010b82:	a321a2        	l32i	a10, a1, 0x28c
42010b85:	c6ca      	add.n	a12, a6, a12
42010b87:	201110        	or	a1, a1, a1
42010b8a:	04f125        	call8	42015a9c <__sprint_r>
42010b8d:	68aa56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010b90:	f4a182        	movi	a8, 0x1f4
42010b93:	218a      	add.n	a2, a1, a8
42010b95:	962132        	l32i	a3, a1, 0x258
42010b98:	0783d6        	bgez	a3, 42010c14 <_vfprintf_r+0x2a64>
42010b9b:	603030        	neg	a3, a3
42010b9e:	027d      	mov.n	a7, a2
42010ba0:	051c      	movi.n	a5, 16
42010ba2:	000bc6        	j	42010bd5 <_vfprintf_r+0x2a25>
42010ba5:	10c882        	addi	a8, a8, 16
42010ba8:	1759      	s32i.n	a5, a7, 4
42010baa:	b689      	s32i.n	a8, a6, 44
42010bac:	0a6642        	s32i	a4, a6, 40
42010baf:	1d84a6        	blti	a4, 8, 42010bd0 <_vfprintf_r+0x2a20>
42010bb2:	34a2c2        	movi	a12, 0x234
42010bb5:	a121b2        	l32i	a11, a1, 0x284
42010bb8:	a321a2        	l32i	a10, a1, 0x28c
42010bbb:	80cc10        	add	a12, a12, a1
42010bbe:	201110        	or	a1, a1, a1
42010bc1:	04eda5        	call8	42015a9c <__sprint_r>
42010bc4:	653a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010bc7:	e4a122        	movi	a2, 0x1e4
42010bca:	10c1a2        	addi	a10, a1, 16
42010bcd:	802a20        	add	a2, a10, a2
42010bd0:	f0c332        	addi	a3, a3, -16
42010bd3:	027d      	mov.n	a7, a2
42010bd5:	10c1b2        	addi	a11, a1, 16
42010bd8:	c01d91        	l32r	a9, 42000c4c <_stext+0xc2c>
42010bdb:	8a2b42        	l32i	a4, a11, 0x228
42010bde:	0799      	s32i.n	a9, a7, 0
42010be0:	02db62        	addmi	a6, a11, 0x200
42010be3:	441b      	addi.n	a4, a4, 1
42010be5:	228b      	addi.n	a2, a2, 8
42010be7:	b688      	l32i.n	a8, a6, 44
42010be9:	b82537        	blt	a5, a3, 42010ba5 <_vfprintf_r+0x29f5>
42010bec:	1739      	s32i.n	a3, a7, 4
42010bee:	338a      	add.n	a3, a3, a8
42010bf0:	b639      	s32i.n	a3, a6, 44
42010bf2:	a649      	s32i.n	a4, a6, 40
42010bf4:	1c84a6        	blti	a4, 8, 42010c14 <_vfprintf_r+0x2a64>
42010bf7:	24a2c2        	movi	a12, 0x224
42010bfa:	80cbc0        	add	a12, a11, a12
42010bfd:	a321a2        	l32i	a10, a1, 0x28c
42010c00:	a121b2        	l32i	a11, a1, 0x284
42010c03:	201110        	or	a1, a1, a1
42010c06:	04e965        	call8	42015a9c <__sprint_r>
42010c09:	60ea56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010c0c:	e4a122        	movi	a2, 0x1e4
42010c0f:	10c1e2        	addi	a14, a1, 16
42010c12:	2e2a      	add.n	a2, a14, a2
42010c14:	a22132        	l32i	a3, a1, 0x288
42010c17:	a62142        	l32i	a4, a1, 0x298
42010c1a:	0239      	s32i.n	a3, a2, 0
42010c1c:	a62162        	l32i	a6, a1, 0x298
42010c1f:	8f2132        	l32i	a3, a1, 0x23c
42010c22:	1249      	s32i.n	a4, a2, 4
42010c24:	10c152        	addi	a5, a1, 16
42010c27:	012fc6        	j	420110ea <_vfprintf_r+0x2f3a>
42010c2a:	00          	.byte 00
42010c2b:	00          	.byte 00
42010c2c:	00          	.byte 00
42010c2d:	a62182        	l32i	a8, a1, 0x298
42010c30:	435280        	min	a5, a2, a8
42010c33:	3115a6        	blti	a5, 1, 42010c68 <_vfprintf_r+0x2ab8>
42010c36:	757a      	add.n	a7, a5, a7
42010c38:	b679      	s32i.n	a7, a6, 44
42010c3a:	a678      	l32i.n	a7, a6, 40
42010c3c:	a22182        	l32i	a8, a1, 0x288
42010c3f:	771b      	addi.n	a7, a7, 1
42010c41:	0989      	s32i.n	a8, a9, 0
42010c43:	1959      	s32i.n	a5, a9, 4
42010c45:	a679      	s32i.n	a7, a6, 40
42010c47:	998b      	addi.n	a9, a9, 8
42010c49:	1b87a6        	blti	a7, 8, 42010c68 <_vfprintf_r+0x2ab8>
42010c4c:	10c1a2        	addi	a10, a1, 16
42010c4f:	24a2c2        	movi	a12, 0x224
42010c52:	caca      	add.n	a12, a10, a12
42010c54:	a121b2        	l32i	a11, a1, 0x284
42010c57:	a321a2        	l32i	a10, a1, 0x28c
42010c5a:	201110        	or	a1, a1, a1
42010c5d:	04e3e5        	call8	42015a9c <__sprint_r>
42010c60:	5b7a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010c63:	f4a1b2        	movi	a11, 0x1f4
42010c66:	91ba      	add.n	a9, a1, a11
42010c68:	060c      	movi.n	a6, 0
42010c6a:	535560        	max	a5, a5, a6
42010c6d:	c05250        	sub	a5, a2, a5
42010c70:	081c      	movi.n	a8, 16
42010c72:	3715e6        	bgei	a5, 1, 42010cad <_vfprintf_r+0x2afd>
42010c75:	001dc6        	j	42010cf0 <_vfprintf_r+0x2b40>
42010c78:	00          	.byte 00
42010c79:	10caa2        	addi	a10, a10, 16
42010c7c:	1989      	s32i.n	a8, a9, 4
42010c7e:	b7a9      	s32i.n	a10, a7, 44
42010c80:	a769      	s32i.n	a6, a7, 40
42010c82:	2286a6        	blti	a6, 8, 42010ca8 <_vfprintf_r+0x2af8>
42010c85:	a121b2        	l32i	a11, a1, 0x284
42010c88:	a321a2        	l32i	a10, a1, 0x28c
42010c8b:	34a2c2        	movi	a12, 0x234
42010c8e:	cc1a      	add.n	a12, a12, a1
42010c90:	b76182        	s32i	a8, a1, 0x2dc
42010c93:	201110        	or	a1, a1, a1
42010c96:	04e065        	call8	42015a9c <__sprint_r>
42010c99:	b72182        	l32i	a8, a1, 0x2dc
42010c9c:	57ba56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010c9f:	e4a192        	movi	a9, 0x1e4
42010ca2:	10c1e2        	addi	a14, a1, 16
42010ca5:	80ce90        	add	a12, a14, a9
42010ca8:	f0c552        	addi	a5, a5, -16
42010cab:	0c9d      	mov.n	a9, a12
42010cad:	10c162        	addi	a6, a1, 16
42010cb0:	02d672        	addmi	a7, a6, 0x200
42010cb3:	bfe6b1        	l32r	a11, 42000c4c <_stext+0xc2c>
42010cb6:	a768      	l32i.n	a6, a7, 40
42010cb8:	09b9      	s32i.n	a11, a9, 0
42010cba:	661b      	addi.n	a6, a6, 1
42010cbc:	c98b      	addi.n	a12, a9, 8
42010cbe:	b7a8      	l32i.n	a10, a7, 44
42010cc0:	b52857        	blt	a8, a5, 42010c79 <_vfprintf_r+0x2ac9>
42010cc3:	1959      	s32i.n	a5, a9, 4
42010cc5:	55aa      	add.n	a5, a5, a10
42010cc7:	b759      	s32i.n	a5, a7, 44
42010cc9:	a769      	s32i.n	a6, a7, 40
42010ccb:	0c9d      	mov.n	a9, a12
42010ccd:	1f86a6        	blti	a6, 8, 42010cf0 <_vfprintf_r+0x2b40>
42010cd0:	24a2c2        	movi	a12, 0x224
42010cd3:	10c182        	addi	a8, a1, 16
42010cd6:	a121b2        	l32i	a11, a1, 0x284
42010cd9:	a321a2        	l32i	a10, a1, 0x28c
42010cdc:	80c8c0        	add	a12, a8, a12
42010cdf:	201110        	or	a1, a1, a1
42010ce2:	04dba5        	call8	42015a9c <__sprint_r>
42010ce5:	532a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010ce8:	e4a152        	movi	a5, 0x1e4
42010ceb:	10c1a2        	addi	a10, a1, 16
42010cee:	9a5a      	add.n	a9, a10, a5
42010cf0:	a22182        	l32i	a8, a1, 0x288
42010cf3:	a02152        	l32i	a5, a1, 0x280
42010cf6:	282a      	add.n	a2, a8, a2
42010cf8:	02e5a7        	bbsi	a5, 10, 42010cfe <_vfprintf_r+0x2b4e>
42010cfb:	005286        	j	42010e49 <_vfprintf_r+0x2c99>
42010cfe:	e4a152        	movi	a5, 0x1e4
42010d01:	0049c6        	j	42010e2c <_vfprintf_r+0x2c7c>
42010d04:	438c      	beqz.n	a3, 42010d0c <_vfprintf_r+0x2b5c>
42010d06:	330b      	addi.n	a3, a3, -1
42010d08:	000286        	j	42010d16 <_vfprintf_r+0x2b66>
42010d0b:	00          	.byte 00
42010d0c:	ac2162        	l32i	a6, a1, 0x2b0
42010d0f:	440b      	addi.n	a4, a4, -1
42010d11:	660b      	addi.n	a6, a6, -1
42010d13:	ac6162        	s32i	a6, a1, 0x2b0
42010d16:	b52182        	l32i	a8, a1, 0x2d4
42010d19:	b02162        	l32i	a6, a1, 0x2c0
42010d1c:	0989      	s32i.n	a8, a9, 0
42010d1e:	10c182        	addi	a8, a1, 16
42010d21:	02d872        	addmi	a7, a8, 0x200
42010d24:	1969      	s32i.n	a6, a9, 4
42010d26:	b02182        	l32i	a8, a1, 0x2c0
42010d29:	8f2162        	l32i	a6, a1, 0x23c
42010d2c:	998b      	addi.n	a9, a9, 8
42010d2e:	668a      	add.n	a6, a6, a8
42010d30:	b769      	s32i.n	a6, a7, 44
42010d32:	a768      	l32i.n	a6, a7, 40
42010d34:	661b      	addi.n	a6, a6, 1
42010d36:	a769      	s32i.n	a6, a7, 40
42010d38:	1886a6        	blti	a6, 8, 42010d54 <_vfprintf_r+0x2ba4>
42010d3b:	34a2c2        	movi	a12, 0x234
42010d3e:	a121b2        	l32i	a11, a1, 0x284
42010d41:	a321a2        	l32i	a10, a1, 0x28c
42010d44:	cc1a      	add.n	a12, a12, a1
42010d46:	201110        	or	a1, a1, a1
42010d49:	04d525        	call8	42015a9c <__sprint_r>
42010d4c:	4cba56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010d4f:	10c1a2        	addi	a10, a1, 16
42010d52:	9a5a      	add.n	a9, a10, a5
42010d54:	a22182        	l32i	a8, a1, 0x288
42010d57:	a62162        	l32i	a6, a1, 0x298
42010d5a:	786a      	add.n	a7, a8, a6
42010d5c:	ac2182        	l32i	a8, a1, 0x2b0
42010d5f:	c07720        	sub	a7, a7, a2
42010d62:	000862        	l8ui	a6, a8, 0
42010d65:	437760        	min	a7, a7, a6
42010d68:	8f2162        	l32i	a6, a1, 0x23c
42010d6b:	2e17a6        	blti	a7, 1, 42010d9d <_vfprintf_r+0x2bed>
42010d6e:	676a      	add.n	a6, a7, a6
42010d70:	8f6162        	s32i	a6, a1, 0x23c
42010d73:	8e2162        	l32i	a6, a1, 0x238
42010d76:	0929      	s32i.n	a2, a9, 0
42010d78:	661b      	addi.n	a6, a6, 1
42010d7a:	1979      	s32i.n	a7, a9, 4
42010d7c:	8e6162        	s32i	a6, a1, 0x238
42010d7f:	998b      	addi.n	a9, a9, 8
42010d81:	1886a6        	blti	a6, 8, 42010d9d <_vfprintf_r+0x2bed>
42010d84:	34a2c2        	movi	a12, 0x234
42010d87:	a121b2        	l32i	a11, a1, 0x284
42010d8a:	a321a2        	l32i	a10, a1, 0x28c
42010d8d:	cc1a      	add.n	a12, a12, a1
42010d8f:	201110        	or	a1, a1, a1
42010d92:	04d0a5        	call8	42015a9c <__sprint_r>
42010d95:	482a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010d98:	10c1b2        	addi	a11, a1, 16
42010d9b:	9b5a      	add.n	a9, a11, a5
42010d9d:	ac2182        	l32i	a8, a1, 0x2b0
42010da0:	0d1c      	movi.n	a13, 16
42010da2:	000862        	l8ui	a6, a8, 0
42010da5:	080c      	movi.n	a8, 0
42010da7:	537780        	max	a7, a7, a8
42010daa:	c06670        	sub	a6, a6, a7
42010dad:	3416e6        	bgei	a6, 1, 42010de5 <_vfprintf_r+0x2c35>
42010db0:	001c06        	j	42010e24 <_vfprintf_r+0x2c74>
42010db3:	00          	.byte 00
42010db4:	10caa2        	addi	a10, a10, 16
42010db7:	19d9      	s32i.n	a13, a9, 4
42010db9:	b8a9      	s32i.n	a10, a8, 44
42010dbb:	a879      	s32i.n	a7, a8, 40
42010dbd:	1f87a6        	blti	a7, 8, 42010de0 <_vfprintf_r+0x2c30>
42010dc0:	a121b2        	l32i	a11, a1, 0x284
42010dc3:	a321a2        	l32i	a10, a1, 0x28c
42010dc6:	34a2c2        	movi	a12, 0x234
42010dc9:	80cc10        	add	a12, a12, a1
42010dcc:	b761d2        	s32i	a13, a1, 0x2dc
42010dcf:	201110        	or	a1, a1, a1
42010dd2:	04cca5        	call8	42015a9c <__sprint_r>
42010dd5:	b721d2        	l32i	a13, a1, 0x2dc
42010dd8:	43fa56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010ddb:	10c1a2        	addi	a10, a1, 16
42010dde:	ba5a      	add.n	a11, a10, a5
42010de0:	f0c662        	addi	a6, a6, -16
42010de3:	0b9d      	mov.n	a9, a11
42010de5:	10c1b2        	addi	a11, a1, 16
42010de8:	bf99c1        	l32r	a12, 42000c4c <_stext+0xc2c>
42010deb:	8a2b72        	l32i	a7, a11, 0x228
42010dee:	09c9      	s32i.n	a12, a9, 0
42010df0:	02db82        	addmi	a8, a11, 0x200
42010df3:	771b      	addi.n	a7, a7, 1
42010df5:	b98b      	addi.n	a11, a9, 8
42010df7:	b8a8      	l32i.n	a10, a8, 44
42010df9:	b72d67        	blt	a13, a6, 42010db4 <_vfprintf_r+0x2c04>
42010dfc:	1969      	s32i.n	a6, a9, 4
42010dfe:	66aa      	add.n	a6, a6, a10
42010e00:	b869      	s32i.n	a6, a8, 44
42010e02:	0a6872        	s32i	a7, a8, 40
42010e05:	0b9d      	mov.n	a9, a11
42010e07:	1987a6        	blti	a7, 8, 42010e24 <_vfprintf_r+0x2c74>
42010e0a:	34a2c2        	movi	a12, 0x234
42010e0d:	a121b2        	l32i	a11, a1, 0x284
42010e10:	a321a2        	l32i	a10, a1, 0x28c
42010e13:	80cc10        	add	a12, a12, a1
42010e16:	201110        	or	a1, a1, a1
42010e19:	04c825        	call8	42015a9c <__sprint_r>
42010e1c:	3fba56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010e1f:	10c1e2        	addi	a14, a1, 16
42010e22:	9e5a      	add.n	a9, a14, a5
42010e24:	ac2182        	l32i	a8, a1, 0x2b0
42010e27:	000862        	l8ui	a6, a8, 0
42010e2a:	226a      	add.n	a2, a2, a6
42010e2c:	316f40        	srai	a6, a4, 31
42010e2f:	c06640        	sub	a6, a6, a4
42010e32:	ece696        	bltz	a6, 42010d04 <_vfprintf_r+0x2b54>
42010e35:	316f30        	srai	a6, a3, 31
42010e38:	c06630        	sub	a6, a6, a3
42010e3b:	ec5696        	bltz	a6, 42010d04 <_vfprintf_r+0x2b54>
42010e3e:	a22142        	l32i	a4, a1, 0x288
42010e41:	a62152        	l32i	a5, a1, 0x298
42010e44:	345a      	add.n	a3, a4, a5
42010e46:	632230        	minu	a2, a2, a3
42010e49:	962132        	l32i	a3, a1, 0x258
42010e4c:	a62162        	l32i	a6, a1, 0x298
42010e4f:	052367        	blt	a3, a6, 42010e58 <_vfprintf_r+0x2ca8>
42010e52:	a02182        	l32i	a8, a1, 0x280
42010e55:	406807        	bbci	a8, 0, 42010e99 <_vfprintf_r+0x2ce9>
42010e58:	b22132        	l32i	a3, a1, 0x2c8
42010e5b:	ae2162        	l32i	a6, a1, 0x2b8
42010e5e:	0939      	s32i.n	a3, a9, 0
42010e60:	8f2132        	l32i	a3, a1, 0x23c
42010e63:	ae2142        	l32i	a4, a1, 0x2b8
42010e66:	336a      	add.n	a3, a3, a6
42010e68:	8f6132        	s32i	a3, a1, 0x23c
42010e6b:	8e2132        	l32i	a3, a1, 0x238
42010e6e:	1949      	s32i.n	a4, a9, 4
42010e70:	331b      	addi.n	a3, a3, 1
42010e72:	8e6132        	s32i	a3, a1, 0x238
42010e75:	10c152        	addi	a5, a1, 16
42010e78:	998b      	addi.n	a9, a9, 8
42010e7a:	1b83a6        	blti	a3, 8, 42010e99 <_vfprintf_r+0x2ce9>
42010e7d:	24a2c2        	movi	a12, 0x224
42010e80:	10c182        	addi	a8, a1, 16
42010e83:	a121b2        	l32i	a11, a1, 0x284
42010e86:	a321a2        	l32i	a10, a1, 0x28c
42010e89:	c8ca      	add.n	a12, a8, a12
42010e8b:	201110        	or	a1, a1, a1
42010e8e:	04c0e5        	call8	42015a9c <__sprint_r>
42010e91:	386a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010e94:	f4a1a2        	movi	a10, 0x1f4
42010e97:	91aa      	add.n	a9, a1, a10
42010e99:	a62142        	l32i	a4, a1, 0x298
42010e9c:	962132        	l32i	a3, a1, 0x258
42010e9f:	a22182        	l32i	a8, a1, 0x288
42010ea2:	c03430        	sub	a3, a4, a3
42010ea5:	484a      	add.n	a4, a8, a4
42010ea7:	c04420        	sub	a4, a4, a2
42010eaa:	433340        	min	a3, a3, a4
42010ead:	8f2152        	l32i	a5, a1, 0x23c
42010eb0:	3113a6        	blti	a3, 1, 42010ee5 <_vfprintf_r+0x2d35>
42010eb3:	0929      	s32i.n	a2, a9, 0
42010eb5:	235a      	add.n	a2, a3, a5
42010eb7:	8f6122        	s32i	a2, a1, 0x23c
42010eba:	8e2122        	l32i	a2, a1, 0x238
42010ebd:	1939      	s32i.n	a3, a9, 4
42010ebf:	221b      	addi.n	a2, a2, 1
42010ec1:	8e6122        	s32i	a2, a1, 0x238
42010ec4:	998b      	addi.n	a9, a9, 8
42010ec6:	1b82a6        	blti	a2, 8, 42010ee5 <_vfprintf_r+0x2d35>
42010ec9:	10c1b2        	addi	a11, a1, 16
42010ecc:	24a2c2        	movi	a12, 0x224
42010ecf:	cbca      	add.n	a12, a11, a12
42010ed1:	a321a2        	l32i	a10, a1, 0x28c
42010ed4:	a121b2        	l32i	a11, a1, 0x284
42010ed7:	201110        	or	a1, a1, a1
42010eda:	04bc25        	call8	42015a9c <__sprint_r>
42010edd:	33aa56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010ee0:	f4a1e2        	movi	a14, 0x1f4
42010ee3:	91ea      	add.n	a9, a1, a14
42010ee5:	a62142        	l32i	a4, a1, 0x298
42010ee8:	962122        	l32i	a2, a1, 0x258
42010eeb:	051c      	movi.n	a5, 16
42010eed:	c02420        	sub	a2, a4, a2
42010ef0:	040c      	movi.n	a4, 0
42010ef2:	533340        	max	a3, a3, a4
42010ef5:	c02230        	sub	a2, a2, a3
42010ef8:	3112e6        	bgei	a2, 1, 42010f2d <_vfprintf_r+0x2d7d>
42010efb:	008646        	j	42011118 <_vfprintf_r+0x2f68>
42010efe:	00          	.byte 00
42010eff:	00          	.byte 00
42010f00:	10c772        	addi	a7, a7, 16
42010f03:	1959      	s32i.n	a5, a9, 4
42010f05:	b479      	s32i.n	a7, a4, 44
42010f07:	a439      	s32i.n	a3, a4, 40
42010f09:	1b83a6        	blti	a3, 8, 42010f28 <_vfprintf_r+0x2d78>
42010f0c:	34a2c2        	movi	a12, 0x234
42010f0f:	a121b2        	l32i	a11, a1, 0x284
42010f12:	a321a2        	l32i	a10, a1, 0x28c
42010f15:	cc1a      	add.n	a12, a12, a1
42010f17:	201110        	or	a1, a1, a1
42010f1a:	04b825        	call8	42015a9c <__sprint_r>
42010f1d:	2faa56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010f20:	e4a162        	movi	a6, 0x1e4
42010f23:	10c182        	addi	a8, a1, 16
42010f26:	686a      	add.n	a6, a8, a6
42010f28:	f0c222        	addi	a2, a2, -16
42010f2b:	069d      	mov.n	a9, a6
42010f2d:	10c1a2        	addi	a10, a1, 16
42010f30:	bf4781        	l32r	a8, 42000c4c <_stext+0xc2c>
42010f33:	8a2a32        	l32i	a3, a10, 0x228
42010f36:	0989      	s32i.n	a8, a9, 0
42010f38:	02da42        	addmi	a4, a10, 0x200
42010f3b:	331b      	addi.n	a3, a3, 1
42010f3d:	698b      	addi.n	a6, a9, 8
42010f3f:	b478      	l32i.n	a7, a4, 44
42010f41:	bb2527        	blt	a5, a2, 42010f00 <_vfprintf_r+0x2d50>
42010f44:	1929      	s32i.n	a2, a9, 4
42010f46:	227a      	add.n	a2, a2, a7
42010f48:	b429      	s32i.n	a2, a4, 44
42010f4a:	a439      	s32i.n	a3, a4, 40
42010f4c:	069d      	mov.n	a9, a6
42010f4e:	0283e6        	bgei	a3, 8, 42010f54 <_vfprintf_r+0x2da4>
42010f51:	0070c6        	j	42011118 <_vfprintf_r+0x2f68>
42010f54:	24a2c2        	movi	a12, 0x224
42010f57:	caca      	add.n	a12, a10, a12
42010f59:	a121b2        	l32i	a11, a1, 0x284
42010f5c:	a321a2        	l32i	a10, a1, 0x28c
42010f5f:	201110        	or	a1, a1, a1
42010f62:	04b3a5        	call8	42015a9c <__sprint_r>
42010f65:	2b2a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010f68:	e4a122        	movi	a2, 0x1e4
42010f6b:	10c1b2        	addi	a11, a1, 16
42010f6e:	9b2a      	add.n	a9, a11, a2
42010f70:	006906        	j	42011118 <_vfprintf_r+0x2f68>
42010f73:	00          	.byte 00
42010f74:	a638      	l32i.n	a3, a6, 40
42010f76:	a62152        	l32i	a5, a1, 0x298
42010f79:	771b      	addi.n	a7, a7, 1
42010f7b:	331b      	addi.n	a3, a3, 1
42010f7d:	298b      	addi.n	a2, a9, 8
42010f7f:	140c      	movi.n	a4, 1
42010f81:	0825e6        	bgei	a5, 2, 42010f8d <_vfprintf_r+0x2ddd>
42010f84:	a02182        	l32i	a8, a1, 0x280
42010f87:	02e807        	bbsi	a8, 0, 42010f8d <_vfprintf_r+0x2ddd>
42010f8a:	004b86        	j	420110bc <_vfprintf_r+0x2f0c>
42010f8d:	a22182        	l32i	a8, a1, 0x288
42010f90:	1949      	s32i.n	a4, a9, 4
42010f92:	0989      	s32i.n	a8, a9, 0
42010f94:	8f6172        	s32i	a7, a1, 0x23c
42010f97:	8e6132        	s32i	a3, a1, 0x238
42010f9a:	10c1a2        	addi	a10, a1, 16
42010f9d:	1883a6        	blti	a3, 8, 42010fb9 <_vfprintf_r+0x2e09>
42010fa0:	24a2c2        	movi	a12, 0x224
42010fa3:	caca      	add.n	a12, a10, a12
42010fa5:	a121b2        	l32i	a11, a1, 0x284
42010fa8:	a321a2        	l32i	a10, a1, 0x28c
42010fab:	201110        	or	a1, a1, a1
42010fae:	04aee5        	call8	42015a9c <__sprint_r>
42010fb1:	266a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010fb4:	f4a1b2        	movi	a11, 0x1f4
42010fb7:	21ba      	add.n	a2, a1, a11
42010fb9:	b22132        	l32i	a3, a1, 0x2c8
42010fbc:	ae2162        	l32i	a6, a1, 0x2b8
42010fbf:	0239      	s32i.n	a3, a2, 0
42010fc1:	8f2132        	l32i	a3, a1, 0x23c
42010fc4:	ae2142        	l32i	a4, a1, 0x2b8
42010fc7:	336a      	add.n	a3, a3, a6
42010fc9:	8f6132        	s32i	a3, a1, 0x23c
42010fcc:	8e2132        	l32i	a3, a1, 0x238
42010fcf:	1249      	s32i.n	a4, a2, 4
42010fd1:	331b      	addi.n	a3, a3, 1
42010fd3:	8e6132        	s32i	a3, a1, 0x238
42010fd6:	10c152        	addi	a5, a1, 16
42010fd9:	08c222        	addi	a2, a2, 8
42010fdc:	1d83a6        	blti	a3, 8, 42010ffd <_vfprintf_r+0x2e4d>
42010fdf:	24a2c2        	movi	a12, 0x224
42010fe2:	10c182        	addi	a8, a1, 16
42010fe5:	a121b2        	l32i	a11, a1, 0x284
42010fe8:	a321a2        	l32i	a10, a1, 0x28c
42010feb:	80c8c0        	add	a12, a8, a12
42010fee:	201110        	or	a1, a1, a1
42010ff1:	04aaa5        	call8	42015a9c <__sprint_r>
42010ff4:	223a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42010ff7:	f4a1a2        	movi	a10, 0x1f4
42010ffa:	8021a0        	add	a2, a1, a10
42010ffd:	10c1b2        	addi	a11, a1, 16
42011000:	a62182        	l32i	a8, a1, 0x298
42011003:	02db62        	addmi	a6, a11, 0x200
42011006:	bdfac1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011009:	bdf9d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4201100c:	a821a2        	l32i	a10, a1, 0x2a0
4201100f:	a921b2        	l32i	a11, a1, 0x2a4
42011012:	8f2142        	l32i	a4, a1, 0x23c
42011015:	8e2152        	l32i	a5, a1, 0x238
42011018:	380b      	addi.n	a3, a8, -1
4201101a:	befd81        	l32r	a8, 42000c10 <_stext+0xbf0>
4201101d:	0008e0        	callx8	a8
42011020:	babc      	beqz.n	a10, 4201105f <_vfprintf_r+0x2eaf>
42011022:	1239      	s32i.n	a3, a2, 4
42011024:	a22182        	l32i	a8, a1, 0x288
42011027:	a62132        	l32i	a3, a1, 0x298
4201102a:	440b      	addi.n	a4, a4, -1
4201102c:	551b      	addi.n	a5, a5, 1
4201102e:	781b      	addi.n	a7, a8, 1
42011030:	443a      	add.n	a4, a4, a3
42011032:	0279      	s32i.n	a7, a2, 0
42011034:	b649      	s32i.n	a4, a6, 44
42011036:	a659      	s32i.n	a5, a6, 40
42011038:	228b      	addi.n	a2, a2, 8
4201103a:	0285e6        	bgei	a5, 8, 42011040 <_vfprintf_r+0x2e90>
4201103d:	002506        	j	420110d5 <_vfprintf_r+0x2f25>
42011040:	24a2c2        	movi	a12, 0x224
42011043:	10c142        	addi	a4, a1, 16
42011046:	c4ca      	add.n	a12, a4, a12
42011048:	a121b2        	l32i	a11, a1, 0x284
4201104b:	a321a2        	l32i	a10, a1, 0x28c
4201104e:	201110        	or	a1, a1, a1
42011051:	04a4a5        	call8	42015a9c <__sprint_r>
42011054:	1c3a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42011057:	f4a122        	movi	a2, 0x1f4
4201105a:	212a      	add.n	a2, a1, a2
4201105c:	001d46        	j	420110d5 <_vfprintf_r+0x2f25>
4201105f:	061c      	movi.n	a6, 16
42011061:	3013e6        	bgei	a3, 1, 42011095 <_vfprintf_r+0x2ee5>
42011064:	001b46        	j	420110d5 <_vfprintf_r+0x2f25>
42011067:	00          	.byte 00
42011068:	10c882        	addi	a8, a8, 16
4201106b:	1269      	s32i.n	a6, a2, 4
4201106d:	b589      	s32i.n	a8, a5, 44
4201106f:	a549      	s32i.n	a4, a5, 40
42011071:	1b84a6        	blti	a4, 8, 42011090 <_vfprintf_r+0x2ee0>
42011074:	34a2c2        	movi	a12, 0x234
42011077:	a121b2        	l32i	a11, a1, 0x284
4201107a:	a321a2        	l32i	a10, a1, 0x28c
4201107d:	cc1a      	add.n	a12, a12, a1
4201107f:	201110        	or	a1, a1, a1
42011082:	04a1a5        	call8	42015a9c <__sprint_r>
42011085:	192a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42011088:	e4a172        	movi	a7, 0x1e4
4201108b:	10c152        	addi	a5, a1, 16
4201108e:	757a      	add.n	a7, a5, a7
42011090:	f0c332        	addi	a3, a3, -16
42011093:	072d      	mov.n	a2, a7
42011095:	10c182        	addi	a8, a1, 16
42011098:	beed91        	l32r	a9, 42000c4c <_stext+0xc2c>
4201109b:	8a2842        	l32i	a4, a8, 0x228
4201109e:	02d852        	addmi	a5, a8, 0x200
420110a1:	0299      	s32i.n	a9, a2, 0
420110a3:	b588      	l32i.n	a8, a5, 44
420110a5:	441b      	addi.n	a4, a4, 1
420110a7:	728b      	addi.n	a7, a2, 8
420110a9:	bb2637        	blt	a6, a3, 42011068 <_vfprintf_r+0x2eb8>
420110ac:	1239      	s32i.n	a3, a2, 4
420110ae:	338a      	add.n	a3, a3, a8
420110b0:	b539      	s32i.n	a3, a5, 44
420110b2:	a549      	s32i.n	a4, a5, 40
420110b4:	072d      	mov.n	a2, a7
420110b6:	1b84a6        	blti	a4, 8, 420110d5 <_vfprintf_r+0x2f25>
420110b9:	000346        	j	420110ca <_vfprintf_r+0x2f1a>
420110bc:	a22182        	l32i	a8, a1, 0x288
420110bf:	1949      	s32i.n	a4, a9, 4
420110c1:	0989      	s32i.n	a8, a9, 0
420110c3:	b679      	s32i.n	a7, a6, 44
420110c5:	a639      	s32i.n	a3, a6, 40
420110c7:	0a83a6        	blti	a3, 8, 420110d5 <_vfprintf_r+0x2f25>
420110ca:	24a2c2        	movi	a12, 0x224
420110cd:	10c1a2        	addi	a10, a1, 16
420110d0:	caca      	add.n	a12, a10, a12
420110d2:	ffdc86        	j	42011048 <_vfprintf_r+0x2e98>
420110d5:	47a2b2        	movi	a11, 0x247
420110d8:	31ba      	add.n	a3, a1, a11
420110da:	0239      	s32i.n	a3, a2, 0
420110dc:	b62132        	l32i	a3, a1, 0x2d8
420110df:	b62162        	l32i	a6, a1, 0x2d8
420110e2:	1239      	s32i.n	a3, a2, 4
420110e4:	8f2132        	l32i	a3, a1, 0x23c
420110e7:	10c152        	addi	a5, a1, 16
420110ea:	336a      	add.n	a3, a3, a6
420110ec:	8f6132        	s32i	a3, a1, 0x23c
420110ef:	8e2132        	l32i	a3, a1, 0x238
420110f2:	928b      	addi.n	a9, a2, 8
420110f4:	331b      	addi.n	a3, a3, 1
420110f6:	8e6132        	s32i	a3, a1, 0x238
420110f9:	1b83a6        	blti	a3, 8, 42011118 <_vfprintf_r+0x2f68>
420110fc:	24a2c2        	movi	a12, 0x224
420110ff:	10c182        	addi	a8, a1, 16
42011102:	a121b2        	l32i	a11, a1, 0x284
42011105:	a321a2        	l32i	a10, a1, 0x28c
42011108:	c8ca      	add.n	a12, a8, a12
4201110a:	201110        	or	a1, a1, a1
4201110d:	0498e5        	call8	42015a9c <__sprint_r>
42011110:	107a56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
42011113:	f4a1a2        	movi	a10, 0x1f4
42011116:	91aa      	add.n	a9, a1, a10
42011118:	a02122        	l32i	a2, a1, 0x280
4201111b:	19e227        	bbsi	a2, 2, 42011138 <_vfprintf_r+0x2f88>
4201111e:	ab2132        	l32i	a3, a1, 0x2ac
42011121:	af2142        	l32i	a4, a1, 0x2bc
42011124:	ad2152        	l32i	a5, a1, 0x2b4
42011127:	532340        	max	a2, a3, a4
4201112a:	552a      	add.n	a5, a5, a2
4201112c:	8f2122        	l32i	a2, a1, 0x23c
4201112f:	ad6152        	s32i	a5, a1, 0x2b4
42011132:	07a216        	beqz	a2, 420111b0 <_vfprintf_r+0x3000>
42011135:	002306        	j	420111c5 <_vfprintf_r+0x3015>
42011138:	ab2162        	l32i	a6, a1, 0x2ac
4201113b:	af2182        	l32i	a8, a1, 0x2bc
4201113e:	041c      	movi.n	a4, 16
42011140:	c02680        	sub	a2, a6, a8
42011143:	3112e6        	bgei	a2, 1, 42011178 <_vfprintf_r+0x2fc8>
42011146:	fff506        	j	4201111e <_vfprintf_r+0x2f6e>
42011149:	10c662        	addi	a6, a6, 16
4201114c:	1949      	s32i.n	a4, a9, 4
4201114e:	b569      	s32i.n	a6, a5, 44
42011150:	a539      	s32i.n	a3, a5, 40
42011152:	998b      	addi.n	a9, a9, 8
42011154:	1d83a6        	blti	a3, 8, 42011175 <_vfprintf_r+0x2fc5>
42011157:	34a2c2        	movi	a12, 0x234
4201115a:	a121b2        	l32i	a11, a1, 0x284
4201115d:	a321a2        	l32i	a10, a1, 0x28c
42011160:	80cc10        	add	a12, a12, a1
42011163:	201110        	or	a1, a1, a1
42011166:	049365        	call8	42015a9c <__sprint_r>
42011169:	0aea56        	bnez	a10, 4201121b <_vfprintf_r+0x306b>
4201116c:	e4a132        	movi	a3, 0x1e4
4201116f:	10c1a2        	addi	a10, a1, 16
42011172:	809a30        	add	a9, a10, a3
42011175:	f0c222        	addi	a2, a2, -16
42011178:	10c1b2        	addi	a11, a1, 16
4201117b:	beb371        	l32r	a7, 42000c48 <_stext+0xc28>
4201117e:	8a2b32        	l32i	a3, a11, 0x228
42011181:	0979      	s32i.n	a7, a9, 0
42011183:	02db52        	addmi	a5, a11, 0x200
42011186:	331b      	addi.n	a3, a3, 1
42011188:	b568      	l32i.n	a6, a5, 44
4201118a:	bb2427        	blt	a4, a2, 42011149 <_vfprintf_r+0x2f99>
4201118d:	1929      	s32i.n	a2, a9, 4
4201118f:	226a      	add.n	a2, a2, a6
42011191:	b529      	s32i.n	a2, a5, 44
42011193:	a539      	s32i.n	a3, a5, 40
42011195:	8583a6        	blti	a3, 8, 4201111e <_vfprintf_r+0x2f6e>
42011198:	24a2c2        	movi	a12, 0x224
4201119b:	cbca      	add.n	a12, a11, a12
4201119d:	a321a2        	l32i	a10, a1, 0x28c
420111a0:	a121b2        	l32i	a11, a1, 0x284
420111a3:	201110        	or	a1, a1, a1
420111a6:	048f65        	call8	42015a9c <__sprint_r>
420111a9:	f71a16        	beqz	a10, 4201111e <_vfprintf_r+0x2f6e>
420111ac:	001ac6        	j	4201121b <_vfprintf_r+0x306b>
420111af:	00          	.byte 00
420111b0:	030c      	movi.n	a3, 0
420111b2:	8e6132        	s32i	a3, a1, 0x238
420111b5:	a52132        	l32i	a3, a1, 0x294
420111b8:	f4a142        	movi	a4, 0x1f4
420111bb:	914a      	add.n	a9, a1, a4
420111bd:	13cc      	bnez.n	a3, 420111c2 <_vfprintf_r+0x3012>
420111bf:	f45e46        	j	4200e33c <_vfprintf_r+0x18c>
420111c2:	000646        	j	420111df <_vfprintf_r+0x302f>
420111c5:	24a2c2        	movi	a12, 0x224
420111c8:	10c152        	addi	a5, a1, 16
420111cb:	a121b2        	l32i	a11, a1, 0x284
420111ce:	a321a2        	l32i	a10, a1, 0x28c
420111d1:	c5ca      	add.n	a12, a5, a12
420111d3:	201110        	or	a1, a1, a1
420111d6:	048c65        	call8	42015a9c <__sprint_r>
420111d9:	fd3a16        	beqz	a10, 420111b0 <_vfprintf_r+0x3000>
420111dc:	000ec6        	j	4201121b <_vfprintf_r+0x306b>
420111df:	a521b2        	l32i	a11, a1, 0x294
420111e2:	a321a2        	l32i	a10, a1, 0x28c
420111e5:	f4a162        	movi	a6, 0x1f4
420111e8:	be6681        	l32r	a8, 42000b80 <_stext+0xb60>
420111eb:	0008e0        	callx8	a8
420111ee:	916a      	add.n	a9, a1, a6
420111f0:	f45206        	j	4200e33c <_vfprintf_r+0x18c>
420111f3:	00          	.byte 00
420111f4:	8f2122        	l32i	a2, a1, 0x23c
420111f7:	62cc      	bnez.n	a2, 42011201 <_vfprintf_r+0x3051>
420111f9:	030c      	movi.n	a3, 0
420111fb:	8e6132        	s32i	a3, a1, 0x238
420111fe:	000a86        	j	4201122c <_vfprintf_r+0x307c>
42011201:	10c1a2        	addi	a10, a1, 16
42011204:	24a2c2        	movi	a12, 0x224
42011207:	caca      	add.n	a12, a10, a12
42011209:	a121b2        	l32i	a11, a1, 0x284
4201120c:	a321a2        	l32i	a10, a1, 0x28c
4201120f:	201110        	or	a1, a1, a1
42011212:	0488a5        	call8	42015a9c <__sprint_r>
42011215:	fe0a16        	beqz	a10, 420111f9 <_vfprintf_r+0x3049>
42011218:	000406        	j	4201122c <_vfprintf_r+0x307c>
4201121b:	a52122        	l32i	a2, a1, 0x294
4201121e:	a28c      	beqz.n	a2, 4201122c <_vfprintf_r+0x307c>
42011220:	a321a2        	l32i	a10, a1, 0x28c
42011223:	20b220        	or	a11, a2, a2
42011226:	be5681        	l32r	a8, 42000b80 <_stext+0xb60>
42011229:	0008e0        	callx8	a8
4201122c:	a12132        	l32i	a3, a1, 0x284
4201122f:	192322        	l32i	a2, a3, 100
42011232:	0ee207        	bbsi	a2, 0, 42011244 <_vfprintf_r+0x3094>
42011235:	061322        	l16ui	a2, a3, 12
42011238:	08e297        	bbsi	a2, 9, 42011244 <_vfprintf_r+0x3094>
4201123b:	1623a2        	l32i	a10, a3, 88
4201123e:	be4481        	l32r	a8, 42000b50 <_stext+0xb30>
42011241:	0008e0        	callx8	a8
42011244:	9521a2        	l32i	a10, a1, 0x254
42011247:	54a2b2        	movi	a11, 0x254
4201124a:	b1ba      	add.n	a11, a1, a11
4201124c:	201110        	or	a1, a1, a1
4201124f:	06cc65        	call8	42017f14 <pthread_setcancelstate>
42011252:	a12182        	l32i	a8, a1, 0x284
42011255:	ad2142        	l32i	a4, a1, 0x2b4
42011258:	061822        	l16ui	a2, a8, 12
4201125b:	f37c      	movi.n	a3, -1
4201125d:	042620        	extui	a2, a2, 6, 1
42011260:	934320        	movnez	a4, a3, a2
42011263:	ad6142        	s32i	a4, a1, 0x2b4
42011266:	000d06        	j	4201129e <_vfprintf_r+0x30ee>
42011269:	9f2152        	l32i	a5, a1, 0x27c
4201126c:	982162        	l32i	a6, a1, 0x260
4201126f:	c51b      	addi.n	a12, a5, 1
42011271:	02a567        	bge	a5, a6, 42011277 <_vfprintf_r+0x30c7>
42011274:	f49c46        	j	4200e4e9 <_vfprintf_r+0x339>
42011277:	f49dc6        	j	4200e4f2 <_vfprintf_r+0x342>
4201127a:	00          	.byte 00
4201127b:	00          	.byte 00
4201127c:	9f2162        	l32i	a6, a1, 0x27c
4201127f:	982172        	l32i	a7, a1, 0x260
42011282:	c61b      	addi.n	a12, a6, 1
42011284:	02a677        	bge	a6, a7, 4201128a <_vfprintf_r+0x30da>
42011287:	f4e286        	j	4200e615 <_vfprintf_r+0x465>
4201128a:	f4e406        	j	4200e61e <_vfprintf_r+0x46e>
4201128d:	a42182        	l32i	a8, a1, 0x290
42011290:	a02172        	l32i	a7, a1, 0x280
42011293:	120c      	movi.n	a2, 1
42011295:	020826        	beqi	a8, -1, 4201129b <_vfprintf_r+0x30eb>
42011298:	fc8f46        	j	420104d9 <_vfprintf_r+0x2329>
4201129b:	fcafc6        	j	4201055e <_vfprintf_r+0x23ae>
4201129e:	ad2122        	l32i	a2, a1, 0x2b4
420112a1:	f01d      	retw.n
	...

420112a4 <vfprintf>:
420112a4:	006136        	entry	a1, 48
420112a7:	0149      	s32i.n	a4, a1, 0
420112a9:	1159      	s32i.n	a5, a1, 4
420112ab:	026162        	s32i	a6, a1, 8
420112ae:	be2181        	l32r	a8, 42000b34 <_stext+0xb14>
420112b1:	0008e0        	callx8	a8
420112b4:	01d8      	l32i.n	a13, a1, 0
420112b6:	11e8      	l32i.n	a14, a1, 4
420112b8:	21f8      	l32i.n	a15, a1, 8
420112ba:	02bd      	mov.n	a11, a2
420112bc:	03cd      	mov.n	a12, a3
420112be:	fcef25        	call8	4200e1b0 <_vfprintf_r>
420112c1:	0a2d      	mov.n	a2, a10
420112c3:	f01d      	retw.n
420112c5:	000000        	ill

420112c8 <__sbprintf>:
420112c8:	024136        	entry	a1, 0x120
420112cb:	078d      	mov.n	a8, a7
420112cd:	027d      	mov.n	a7, a2
420112cf:	061322        	l16ui	a2, a3, 12
420112d2:	3e6182        	s32i	a8, a1, 248
420112d5:	d87c      	movi.n	a8, -3
420112d7:	102280        	and	a2, a2, a8
420112da:	465122        	s16i	a2, a1, 140
420112dd:	192322        	l32i	a2, a3, 100
420112e0:	80a082        	movi	a8, 128
420112e3:	396122        	s32i	a2, a1, 228
420112e6:	071322        	l16ui	a2, a3, 14
420112e9:	226182        	s32i	a8, a1, 136
420112ec:	475122        	s16i	a2, a1, 142
420112ef:	8328      	l32i.n	a2, a3, 32
420112f1:	256182        	s32i	a8, a1, 148
420112f4:	286122        	s32i	a2, a1, 160
420112f7:	a328      	l32i.n	a2, a3, 40
420112f9:	3c6152        	s32i	a5, a1, 240
420112fc:	2a6122        	s32i	a2, a1, 168
420112ff:	020c      	movi.n	a2, 0
42011301:	266122        	s32i	a2, a1, 152
42011304:	281a      	add.n	a2, a8, a1
42011306:	58c2a2        	addi	a10, a2, 88
42011309:	3d6162        	s32i	a6, a1, 244
4201130c:	206112        	s32i	a1, a1, 128
4201130f:	246112        	s32i	a1, a1, 144
42011312:	be1381        	l32r	a8, 42000b60 <_stext+0xb40>
42011315:	0008e0        	callx8	a8
42011318:	3c21d2        	l32i	a13, a1, 240
4201131b:	3d21e2        	l32i	a14, a1, 244
4201131e:	3e21f2        	l32i	a15, a1, 248
42011321:	02bd      	mov.n	a11, a2
42011323:	04cd      	mov.n	a12, a4
42011325:	07ad      	mov.n	a10, a7
42011327:	fce8a5        	call8	4200e1b0 <_vfprintf_r>
4201132a:	0a2d      	mov.n	a2, a10
4201132c:	011a96        	bltz	a10, 42011341 <__sbprintf+0x79>
4201132f:	80a0b2        	movi	a11, 128
42011332:	07ad      	mov.n	a10, a7
42011334:	bb1a      	add.n	a11, a11, a1
42011336:	201110        	or	a1, a1, a1
42011339:	011ea5        	call8	42012524 <_fflush_r>
4201133c:	f77c      	movi.n	a7, -1
4201133e:	9327a0        	movnez	a2, a7, a10
42011341:	461182        	l16ui	a8, a1, 140
42011344:	074c      	movi.n	a7, 64
42011346:	080877        	bnone	a8, a7, 42011352 <__sbprintf+0x8a>
42011349:	061382        	l16ui	a8, a3, 12
4201134c:	208870        	or	a8, a8, a7
4201134f:	065382        	s16i	a8, a3, 12
42011352:	3621a2        	l32i	a10, a1, 216
42011355:	be0581        	l32r	a8, 42000b6c <_stext+0xb4c>
42011358:	0008e0        	callx8	a8
4201135b:	f01d      	retw.n
4201135d:	000000        	ill

42011360 <__swsetup_r>:
42011360:	004136        	entry	a1, 32
42011363:	bdf481        	l32r	a8, 42000b34 <_stext+0xb14>
42011366:	0008e0        	callx8	a8
42011369:	0a4d      	mov.n	a4, a10
4201136b:	9a8c      	beqz.n	a10, 42011378 <__swsetup_r+0x18>
4201136d:	6a88      	l32i.n	a8, a10, 24
4201136f:	005856        	bnez	a8, 42011378 <__swsetup_r+0x18>
42011372:	201110        	or	a1, a1, a1
42011375:	f863e5        	call8	420099b4 <__sinit>
42011378:	bdfe81        	l32r	a8, 42000b70 <_stext+0xb50>
4201137b:	059387        	bne	a3, a8, 42011384 <__swsetup_r+0x24>
4201137e:	1438      	l32i.n	a3, a4, 4
42011380:	000506        	j	42011398 <__swsetup_r+0x38>
42011383:	00          	.byte 00
42011384:	bdfc81        	l32r	a8, 42000b74 <_stext+0xb54>
42011387:	059387        	bne	a3, a8, 42011390 <__swsetup_r+0x30>
4201138a:	2438      	l32i.n	a3, a4, 8
4201138c:	000206        	j	42011398 <__swsetup_r+0x38>
4201138f:	00          	.byte 00
42011390:	bdfa81        	l32r	a8, 42000b78 <_stext+0xb58>
42011393:	019387        	bne	a3, a8, 42011398 <__swsetup_r+0x38>
42011396:	3438      	l32i.n	a3, a4, 12
42011398:	061382        	l16ui	a8, a3, 12
4201139b:	234880        	sext	a4, a8, 15
4201139e:	f49080        	extui	a9, a8, 0, 16
420113a1:	43e837        	bbsi	a8, 3, 420113e8 <__swsetup_r+0x88>
420113a4:	08e947        	bbsi	a9, 4, 420113b0 <__swsetup_r+0x50>
420113a7:	980c      	movi.n	a8, 9
420113a9:	0289      	s32i.n	a8, a2, 0
420113ab:	0020c6        	j	42011432 <__swsetup_r+0xd2>
420113ae:	00          	.byte 00
420113af:	00          	.byte 00
420113b0:	296927        	bbci	a9, 2, 420113dd <__swsetup_r+0x7d>
420113b3:	d3b8      	l32i.n	a11, a3, 52
420113b5:	0b9c      	beqz.n	a11, 420113c9 <__swsetup_r+0x69>
420113b7:	44c342        	addi	a4, a3, 68
420113ba:	071b47        	beq	a11, a4, 420113c5 <__swsetup_r+0x65>
420113bd:	02ad      	mov.n	a10, a2
420113bf:	bdf081        	l32r	a8, 42000b80 <_stext+0xb60>
420113c2:	0008e0        	callx8	a8
420113c5:	040c      	movi.n	a4, 0
420113c7:	d349      	s32i.n	a4, a3, 52
420113c9:	061342        	l16ui	a4, a3, 12
420113cc:	dbaf82        	movi	a8, -37
420113cf:	104480        	and	a4, a4, a8
420113d2:	065342        	s16i	a4, a3, 12
420113d5:	040c      	movi.n	a4, 0
420113d7:	1349      	s32i.n	a4, a3, 4
420113d9:	4348      	l32i.n	a4, a3, 16
420113db:	0349      	s32i.n	a4, a3, 0
420113dd:	061342        	l16ui	a4, a3, 12
420113e0:	880c      	movi.n	a8, 8
420113e2:	204480        	or	a4, a4, a8
420113e5:	065342        	s16i	a4, a3, 12
420113e8:	4348      	l32i.n	a4, a3, 16
420113ea:	74dc      	bnez.n	a4, 42011405 <__swsetup_r+0xa5>
420113ec:	061342        	l16ui	a4, a3, 12
420113ef:	80a282        	movi	a8, 0x280
420113f2:	104480        	and	a4, a4, a8
420113f5:	00a282        	movi	a8, 0x200
420113f8:	091487        	beq	a4, a8, 42011405 <__swsetup_r+0xa5>
420113fb:	03bd      	mov.n	a11, a3
420113fd:	02ad      	mov.n	a10, a2
420113ff:	201110        	or	a1, a1, a1
42011402:	f8ed25        	call8	4200a2d4 <__smakebuf_r>
42011405:	061382        	l16ui	a8, a3, 12
42011408:	234880        	sext	a4, a8, 15
4201140b:	f49080        	extui	a9, a8, 0, 16
4201140e:	048080        	extui	a8, a8, 0, 1
42011411:	c88c      	beqz.n	a8, 42011421 <__swsetup_r+0xc1>
42011413:	020c      	movi.n	a2, 0
42011415:	2329      	s32i.n	a2, a3, 8
42011417:	5328      	l32i.n	a2, a3, 20
42011419:	602020        	neg	a2, a2
4201141c:	6329      	s32i.n	a2, a3, 24
4201141e:	000186        	j	42011428 <__swsetup_r+0xc8>
42011421:	01e917        	bbsi	a9, 1, 42011426 <__swsetup_r+0xc6>
42011424:	5388      	l32i.n	a8, a3, 20
42011426:	2389      	s32i.n	a8, a3, 8
42011428:	4388      	l32i.n	a8, a3, 16
4201142a:	020c      	movi.n	a2, 0
4201142c:	0c9827        	bne	a8, a2, 4201143c <__swsetup_r+0xdc>
4201142f:	096977        	bbci	a9, 7, 4201143c <__swsetup_r+0xdc>
42011432:	024c      	movi.n	a2, 64
42011434:	204420        	or	a4, a4, a2
42011437:	065342        	s16i	a4, a3, 12
4201143a:	f27c      	movi.n	a2, -1
4201143c:	f01d      	retw.n
	...

42011440 <quorem>:
42011440:	006136        	entry	a1, 48
42011443:	4348      	l32i.n	a4, a3, 16
42011445:	4258      	l32i.n	a5, a2, 16
42011447:	0a0c      	movi.n	a10, 0
42011449:	02a547        	bge	a5, a4, 4201144f <quorem+0xf>
4201144c:	004986        	j	42011576 <quorem+0x136>
4201144f:	440b      	addi.n	a4, a4, -1
42011451:	14c3b2        	addi	a11, a3, 20
42011454:	a054b0        	addx4	a5, a4, a11
42011457:	14c272        	addi	a7, a2, 20
4201145a:	0598      	l32i.n	a9, a5, 0
4201145c:	a0c470        	addx4	a12, a4, a7
4201145f:	0cd8      	l32i.n	a13, a12, 0
42011461:	991b      	addi.n	a9, a9, 1
42011463:	1184e0        	slli	a8, a4, 2
42011466:	c26d90        	quou	a6, a13, a9
42011469:	02bd97        	bgeu	a13, a9, 4201146f <quorem+0x2f>
4201146c:	002186        	j	420114f6 <quorem+0xb6>
4201146f:	c095b0        	sub	a9, a5, a11
42011472:	838a      	add.n	a8, a3, a8
42011474:	419290        	srli	a9, a9, 2
42011477:	18c3f2        	addi	a15, a3, 24
4201147a:	18c882        	addi	a8, a8, 24
4201147d:	07dd      	mov.n	a13, a7
4201147f:	0aed      	mov.n	a14, a10
42011481:	991b      	addi.n	a9, a9, 1
42011483:	02b8f7        	bgeu	a8, a15, 42011489 <quorem+0x49>
42011486:	01a092        	movi	a9, 1
42011489:	4a8976        	loop	a9, 420114d7 <quorem+0x97>
4201148c:	0bf8      	l32i.n	a15, a11, 0
4201148e:	bb4b      	addi.n	a11, a11, 4
42011490:	f480f0        	extui	a8, a15, 0, 16
42011493:	828860        	mull	a8, a8, a6
42011496:	f5f0f0        	extui	a15, a15, 16, 16
42011499:	82ff60        	mull	a15, a15, a6
4201149c:	88aa      	add.n	a8, a8, a10
4201149e:	f5a080        	extui	a10, a8, 16, 16
420114a1:	afaa      	add.n	a10, a15, a10
420114a3:	0df8      	l32i.n	a15, a13, 0
420114a5:	f48080        	extui	a8, a8, 0, 16
420114a8:	f4f0f0        	extui	a15, a15, 0, 16
420114ab:	efea      	add.n	a14, a15, a14
420114ad:	c08e80        	sub	a8, a14, a8
420114b0:	0de8      	l32i.n	a14, a13, 0
420114b2:	01a9      	s32i.n	a10, a1, 0
420114b4:	f5f0e0        	extui	a15, a14, 16, 16
420114b7:	01e8      	l32i.n	a14, a1, 0
420114b9:	f5a0a0        	extui	a10, a10, 16, 16
420114bc:	f4e0e0        	extui	a14, a14, 0, 16
420114bf:	c0ffe0        	sub	a15, a15, a14
420114c2:	31e080        	srai	a14, a8, 16
420114c5:	ffea      	add.n	a15, a15, a14
420114c7:	31e0f0        	srai	a14, a15, 16
420114ca:	f48080        	extui	a8, a8, 0, 16
420114cd:	11ff00        	slli	a15, a15, 16
420114d0:	20ff80        	or	a15, a15, a8
420114d3:	0df9      	s32i.n	a15, a13, 0
420114d5:	dd4b      	addi.n	a13, a13, 4
420114d7:	0c88      	l32i.n	a8, a12, 0
420114d9:	388c      	beqz.n	a8, 420114e0 <quorem+0xa0>
420114db:	0005c6        	j	420114f6 <quorem+0xb6>
420114de:	440b      	addi.n	a4, a4, -1
420114e0:	fcccc2        	addi	a12, a12, -4
420114e3:	0537c7        	bltu	a7, a12, 420114ec <quorem+0xac>
420114e6:	4249      	s32i.n	a4, a2, 16
420114e8:	000286        	j	420114f6 <quorem+0xb6>
420114eb:	00          	.byte 00
420114ec:	0c88      	l32i.n	a8, a12, 0
420114ee:	fec816        	beqz	a8, 420114de <quorem+0x9e>
420114f1:	fffc46        	j	420114e6 <quorem+0xa6>
420114f4:	00          	.byte 00
420114f5:	00          	.byte 00
420114f6:	03bd      	mov.n	a11, a3
420114f8:	20a220        	or	a10, a2, a2
420114fb:	201110        	or	a1, a1, a1
420114fe:	017025        	call8	42012c00 <__mcmp>
42011501:	06fa96        	bltz	a10, 42011574 <quorem+0x134>
42011504:	14c392        	addi	a9, a3, 20
42011507:	c08590        	sub	a8, a5, a9
4201150a:	418280        	srli	a8, a8, 2
4201150d:	18c332        	addi	a3, a3, 24
42011510:	554b      	addi.n	a5, a5, 4
42011512:	661b      	addi.n	a6, a6, 1
42011514:	14c2a2        	addi	a10, a2, 20
42011517:	0b0c      	movi.n	a11, 0
42011519:	881b      	addi.n	a8, a8, 1
4201151b:	02b537        	bgeu	a5, a3, 42011521 <quorem+0xe1>
4201151e:	01a082        	movi	a8, 1
42011521:	2e8876        	loop	a8, 42011553 <quorem+0x113>
42011524:	0a38      	l32i.n	a3, a10, 0
42011526:	09c8      	l32i.n	a12, a9, 0
42011528:	f45030        	extui	a5, a3, 0, 16
4201152b:	55ba      	add.n	a5, a5, a11
4201152d:	f4b0c0        	extui	a11, a12, 0, 16
42011530:	c055b0        	sub	a5, a5, a11
42011533:	f53030        	extui	a3, a3, 16, 16
42011536:	f5c0c0        	extui	a12, a12, 16, 16
42011539:	31b050        	srai	a11, a5, 16
4201153c:	c033c0        	sub	a3, a3, a12
4201153f:	33ba      	add.n	a3, a3, a11
42011541:	31b030        	srai	a11, a3, 16
42011544:	f45050        	extui	a5, a5, 0, 16
42011547:	113300        	slli	a3, a3, 16
4201154a:	203350        	or	a3, a3, a5
4201154d:	0a39      	s32i.n	a3, a10, 0
4201154f:	994b      	addi.n	a9, a9, 4
42011551:	aa4b      	addi.n	a10, a10, 4
42011553:	a03470        	addx4	a3, a4, a7
42011556:	0358      	l32i.n	a5, a3, 0
42011558:	458c      	beqz.n	a5, 42011560 <quorem+0x120>
4201155a:	000586        	j	42011574 <quorem+0x134>
4201155d:	00          	.byte 00
4201155e:	440b      	addi.n	a4, a4, -1
42011560:	fcc332        	addi	a3, a3, -4
42011563:	053737        	bltu	a7, a3, 4201156c <quorem+0x12c>
42011566:	4249      	s32i.n	a4, a2, 16
42011568:	000206        	j	42011574 <quorem+0x134>
4201156b:	00          	.byte 00
4201156c:	0358      	l32i.n	a5, a3, 0
4201156e:	fec516        	beqz	a5, 4201155e <quorem+0x11e>
42011571:	fffc46        	j	42011566 <quorem+0x126>
42011574:	06ad      	mov.n	a10, a6
42011576:	0a2d      	mov.n	a2, a10
42011578:	f01d      	retw.n
	...

4201157c <_dtoa_r>:
4201157c:	012136        	entry	a1, 144
4201157f:	a179      	s32i.n	a7, a1, 40
42011581:	a138      	l32i.n	a3, a1, 40
42011583:	027d      	mov.n	a7, a2
42011585:	136132        	s32i	a3, a1, 76
42011588:	9738      	l32i.n	a3, a7, 36
4201158a:	d169      	s32i.n	a6, a1, 52
4201158c:	6149      	s32i.n	a4, a1, 24
4201158e:	7159      	s32i.n	a5, a1, 28
42011590:	252122        	l32i	a2, a1, 148
42011593:	d3dc      	bnez.n	a3, 420115b4 <_dtoa_r+0x38>
42011595:	0a1c      	movi.n	a10, 16
42011597:	baac81        	l32r	a8, 42000048 <_stext+0x28>
4201159a:	0008e0        	callx8	a8
4201159d:	97a9      	s32i.n	a10, a7, 36
4201159f:	9acc      	bnez.n	a10, 420115ac <_dtoa_r+0x30>
420115a1:	bdb1d1        	l32r	a13, 42000c68 <_stext+0xc48>
420115a4:	0acd      	mov.n	a12, a10
420115a6:	eaa0b2        	movi	a11, 234
420115a9:	00ba06        	j	42011895 <_dtoa_r+0x319>
420115ac:	1a39      	s32i.n	a3, a10, 4
420115ae:	2a39      	s32i.n	a3, a10, 8
420115b0:	0a39      	s32i.n	a3, a10, 0
420115b2:	3a39      	s32i.n	a3, a10, 12
420115b4:	9738      	l32i.n	a3, a7, 36
420115b6:	03b8      	l32i.n	a11, a3, 0
420115b8:	cb9c      	beqz.n	a11, 420115d8 <_dtoa_r+0x5c>
420115ba:	1368      	l32i.n	a6, a3, 4
420115bc:	130c      	movi.n	a3, 1
420115be:	401600        	ssl	a6
420115c1:	a13300        	sll	a3, a3
420115c4:	1b69      	s32i.n	a6, a11, 4
420115c6:	026b32        	s32i	a3, a11, 8
420115c9:	20a770        	or	a10, a7, a7
420115cc:	201110        	or	a1, a1, a1
420115cf:	010c25        	call8	42012690 <_Bfree>
420115d2:	9738      	l32i.n	a3, a7, 36
420115d4:	060c      	movi.n	a6, 0
420115d6:	0369      	s32i.n	a6, a3, 0
420115d8:	00e5d6        	bgez	a5, 420115ea <_dtoa_r+0x6e>
420115db:	130c      	movi.n	a3, 1
420115dd:	0239      	s32i.n	a3, a2, 0
420115df:	bb7c21        	l32r	a2, 420003d0 <_stext+0x3b0>
420115e2:	102250        	and	a2, a2, a5
420115e5:	7129      	s32i.n	a2, a1, 28
420115e7:	0000c6        	j	420115ee <_dtoa_r+0x72>
420115ea:	030c      	movi.n	a3, 0
420115ec:	0239      	s32i.n	a3, a2, 0
420115ee:	7128      	l32i.n	a2, a1, 28
420115f0:	ffa732        	movi	a3, 0x7ff
420115f3:	0133c0        	slli	a3, a3, 20
420115f6:	106320        	and	a6, a3, a2
420115f9:	279637        	bne	a6, a3, 42011624 <_dtoa_r+0xa8>
420115fc:	bd9d21        	l32r	a2, 42000c70 <_stext+0xc50>
420115ff:	242162        	l32i	a6, a1, 144
42011602:	7188      	l32i.n	a8, a1, 28
42011604:	0629      	s32i.n	a2, a6, 0
42011606:	bd4921        	l32r	a2, 42000b2c <_stext+0xb0c>
42011609:	102280        	and	a2, a2, a8
4201160c:	202240        	or	a2, a2, a4
4201160f:	12cc      	bnez.n	a2, 42011614 <_dtoa_r+0x98>
42011611:	031dc6        	j	4201228c <_dtoa_r+0xd10>
42011614:	0321c6        	j	4201229f <_dtoa_r+0xd23>
42011617:	00          	.byte 00
42011618:	00          	.byte 00
42011619:	bd9121        	l32r	a2, 42000c60 <_stext+0xc40>
4201161c:	262192        	l32i	a9, a1, 152
4201161f:	0929      	s32i.n	a2, a9, 0
42011621:	0321c6        	j	420122ac <_dtoa_r+0xd30>
42011624:	6188      	l32i.n	a8, a1, 24
42011626:	7198      	l32i.n	a9, a1, 28
42011628:	bc72c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4201162b:	bc71d1        	l32r	a13, 420007f0 <_stext+0x7d0>
4201162e:	08ad      	mov.n	a10, a8
42011630:	09bd      	mov.n	a11, a9
42011632:	106182        	s32i	a8, a1, 64
42011635:	116192        	s32i	a9, a1, 68
42011638:	bd7481        	l32r	a8, 42000c08 <_stext+0xbe8>
4201163b:	0008e0        	callx8	a8
4201163e:	aadc      	bnez.n	a10, 4201165c <_dtoa_r+0xe0>
42011640:	242192        	l32i	a9, a1, 144
42011643:	120c      	movi.n	a2, 1
42011645:	0929      	s32i.n	a2, a9, 0
42011647:	bd8721        	l32r	a2, 42000c64 <_stext+0xc44>
4201164a:	262132        	l32i	a3, a1, 152
4201164d:	9129      	s32i.n	a2, a1, 36
4201164f:	13cc      	bnez.n	a3, 42011654 <_dtoa_r+0xd8>
42011651:	0315c6        	j	420122ac <_dtoa_r+0xd30>
42011654:	bd8821        	l32r	a2, 42000c74 <_stext+0xc54>
42011657:	0329      	s32i.n	a2, a3, 0
42011659:	0313c6        	j	420122ac <_dtoa_r+0xd30>
4201165c:	1021c2        	l32i	a12, a1, 64
4201165f:	1121d2        	l32i	a13, a1, 68
42011662:	f14b      	addi.n	a15, a1, 4
42011664:	01ed      	mov.n	a14, a1
42011666:	07ad      	mov.n	a10, a7
42011668:	201110        	or	a1, a1, a1
4201166b:	017fa5        	call8	42012e64 <__d2b>
4201166e:	81a9      	s32i.n	a10, a1, 32
42011670:	a56420        	extui	a6, a2, 20, 11
42011673:	36ac      	beqz.n	a6, 4201169a <_dtoa_r+0x11e>
42011675:	bd2d41        	l32r	a4, 42000b2c <_stext+0xb0c>
42011678:	112152        	l32i	a5, a1, 68
4201167b:	ffa332        	movi	a3, 0x3ff
4201167e:	01ac22        	movi	a2, 0xfffffc01
42011681:	104450        	and	a4, a4, a5
42011684:	0133c0        	slli	a3, a3, 20
42011687:	262a      	add.n	a2, a6, a2
42011689:	060c      	movi.n	a6, 0
4201168b:	1021a2        	l32i	a10, a1, 64
4201168e:	204430        	or	a4, a4, a3
42011691:	156162        	s32i	a6, a1, 84
42011694:	001146        	j	420116dd <_dtoa_r+0x161>
42011697:	00          	.byte 00
42011698:	00          	.byte 00
42011699:	00          	.byte 00
4201169a:	0168      	l32i.n	a6, a1, 0
4201169c:	1138      	l32i.n	a3, a1, 4
4201169e:	32a4a2        	movi	a10, 0x432
420116a1:	336a      	add.n	a3, a3, a6
420116a3:	63aa      	add.n	a6, a3, a10
420116a5:	082c      	movi.n	a8, 32
420116a7:	c0a860        	sub	a10, a8, a6
420116aa:	401a00        	ssl	a10
420116ad:	a1a400        	sll	a10, a4
420116b0:	14a867        	bge	a8, a6, 420116c8 <_dtoa_r+0x14c>
420116b3:	60a060        	neg	a10, a6
420116b6:	12c352        	addi	a5, a3, 18
420116b9:	401a00        	ssl	a10
420116bc:	a12200        	sll	a2, a2
420116bf:	400500        	ssr	a5
420116c2:	914040        	srl	a4, a4
420116c5:	20a240        	or	a10, a2, a4
420116c8:	bd7a81        	l32r	a8, 42000cb0 <_stext+0xc90>
420116cb:	0008e0        	callx8	a8
420116ce:	146c      	movi.n	a4, -31
420116d0:	0144c0        	slli	a4, a4, 20
420116d3:	180c      	movi.n	a8, 1
420116d5:	44ba      	add.n	a4, a4, a11
420116d7:	ffc322        	addi	a2, a3, -1
420116da:	156182        	s32i	a8, a1, 84
420116dd:	bc44c1        	l32r	a12, 420007f0 <_stext+0x7d0>
420116e0:	bd66d1        	l32r	a13, 42000c78 <_stext+0xc58>
420116e3:	20b440        	or	a11, a4, a4
420116e6:	bd4981        	l32r	a8, 42000c0c <_stext+0xbec>
420116e9:	0008e0        	callx8	a8
420116ec:	bd64c1        	l32r	a12, 42000c7c <_stext+0xc5c>
420116ef:	bd64d1        	l32r	a13, 42000c80 <_stext+0xc60>
420116f2:	bd4481        	l32r	a8, 42000c04 <_stext+0xbe4>
420116f5:	0008e0        	callx8	a8
420116f8:	bd63c1        	l32r	a12, 42000c84 <_stext+0xc64>
420116fb:	bd63d1        	l32r	a13, 42000c88 <_stext+0xc68>
420116fe:	bc4081        	l32r	a8, 42000800 <_stext+0x7e0>
42011701:	0008e0        	callx8	a8
42011704:	0a4d      	mov.n	a4, a10
42011706:	02ad      	mov.n	a10, a2
42011708:	0b5d      	mov.n	a5, a11
4201170a:	bc3c81        	l32r	a8, 420007fc <_stext+0x7dc>
4201170d:	0008e0        	callx8	a8
42011710:	bd5fc1        	l32r	a12, 42000c8c <_stext+0xc6c>
42011713:	bd5fd1        	l32r	a13, 42000c90 <_stext+0xc70>
42011716:	bd3b81        	l32r	a8, 42000c04 <_stext+0xbe4>
42011719:	0008e0        	callx8	a8
4201171c:	0acd      	mov.n	a12, a10
4201171e:	0bdd      	mov.n	a13, a11
42011720:	04ad      	mov.n	a10, a4
42011722:	05bd      	mov.n	a11, a5
42011724:	bc3781        	l32r	a8, 42000800 <_stext+0x7e0>
42011727:	0008e0        	callx8	a8
4201172a:	0a4d      	mov.n	a4, a10
4201172c:	205bb0        	or	a5, a11, a11
4201172f:	bc3581        	l32r	a8, 42000804 <_stext+0x7e4>
42011732:	0008e0        	callx8	a8
42011735:	bc2ec1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011738:	bc2ed1        	l32r	a13, 420007f0 <_stext+0x7d0>
4201173b:	41a9      	s32i.n	a10, a1, 16
4201173d:	20b550        	or	a11, a5, a5
42011740:	20a440        	or	a10, a4, a4
42011743:	bd2f81        	l32r	a8, 42000c00 <_stext+0xbe0>
42011746:	0008e0        	callx8	a8
42011749:	019ad6        	bgez	a10, 42011766 <_dtoa_r+0x1ea>
4201174c:	41a8      	l32i.n	a10, a1, 16
4201174e:	bc2b81        	l32r	a8, 420007fc <_stext+0x7dc>
42011751:	0008e0        	callx8	a8
42011754:	04cd      	mov.n	a12, a4
42011756:	05dd      	mov.n	a13, a5
42011758:	bd2e81        	l32r	a8, 42000c10 <_stext+0xbf0>
4201175b:	0008e0        	callx8	a8
4201175e:	4a8c      	beqz.n	a10, 42011766 <_dtoa_r+0x1ea>
42011760:	4198      	l32i.n	a9, a1, 16
42011762:	990b      	addi.n	a9, a9, -1
42011764:	4199      	s32i.n	a9, a1, 16
42011766:	140c      	movi.n	a4, 1
42011768:	4158      	l32i.n	a5, a1, 16
4201176a:	631c      	movi.n	a3, 22
4201176c:	146142        	s32i	a4, a1, 80
4201176f:	2a3357        	bltu	a3, a5, 4201179d <_dtoa_r+0x221>
42011772:	bd4831        	l32r	a3, 42000c94 <_stext+0xc74>
42011775:	1021a2        	l32i	a10, a1, 64
42011778:	b03530        	addx8	a3, a5, a3
4201177b:	03c8      	l32i.n	a12, a3, 0
4201177d:	13d8      	l32i.n	a13, a3, 4
4201177f:	1121b2        	l32i	a11, a1, 68
42011782:	bd1f81        	l32r	a8, 42000c00 <_stext+0xbe0>
42011785:	0008e0        	callx8	a8
42011788:	00cad6        	bgez	a10, 42011798 <_dtoa_r+0x21c>
4201178b:	550b      	addi.n	a5, a5, -1
4201178d:	060c      	movi.n	a6, 0
4201178f:	4159      	s32i.n	a5, a1, 16
42011791:	146162        	s32i	a6, a1, 80
42011794:	000146        	j	4201179d <_dtoa_r+0x221>
42011797:	00          	.byte 00
42011798:	080c      	movi.n	a8, 0
4201179a:	146182        	s32i	a8, a1, 80
4201179d:	1138      	l32i.n	a3, a1, 4
4201179f:	c02320        	sub	a2, a3, a2
420117a2:	920b      	addi.n	a9, a2, -1
420117a4:	030c      	movi.n	a3, 0
420117a6:	c199      	s32i.n	a9, a1, 48
420117a8:	b139      	s32i.n	a3, a1, 44
420117aa:	0aa937        	bge	a9, a3, 420117b8 <_dtoa_r+0x23c>
420117ad:	130c      	movi.n	a3, 1
420117af:	c03320        	sub	a3, a3, a2
420117b2:	040c      	movi.n	a4, 0
420117b4:	b139      	s32i.n	a3, a1, 44
420117b6:	c149      	s32i.n	a4, a1, 48
420117b8:	4158      	l32i.n	a5, a1, 16
420117ba:	010596        	bltz	a5, 420117ce <_dtoa_r+0x252>
420117bd:	c168      	l32i.n	a6, a1, 48
420117bf:	080c      	movi.n	a8, 0
420117c1:	665a      	add.n	a6, a6, a5
420117c3:	c169      	s32i.n	a6, a1, 48
420117c5:	126152        	s32i	a5, a1, 72
420117c8:	f189      	s32i.n	a8, a1, 60
420117ca:	0004c6        	j	420117e1 <_dtoa_r+0x265>
420117cd:	00          	.byte 00
420117ce:	b198      	l32i.n	a9, a1, 44
420117d0:	4128      	l32i.n	a2, a1, 16
420117d2:	040c      	movi.n	a4, 0
420117d4:	c09920        	sub	a9, a9, a2
420117d7:	603020        	neg	a3, a2
420117da:	b199      	s32i.n	a9, a1, 44
420117dc:	f139      	s32i.n	a3, a1, 60
420117de:	126142        	s32i	a4, a1, 72
420117e1:	d158      	l32i.n	a5, a1, 52
420117e3:	920c      	movi.n	a2, 9
420117e5:	130c      	movi.n	a3, 1
420117e7:	653257        	bltu	a2, a5, 42011850 <_dtoa_r+0x2d4>
420117ea:	0665a6        	blti	a5, 6, 420117f4 <_dtoa_r+0x278>
420117ed:	fcc552        	addi	a5, a5, -4
420117f0:	d159      	s32i.n	a5, a1, 52
420117f2:	030c      	movi.n	a3, 0
420117f4:	d168      	l32i.n	a6, a1, 52
420117f6:	1e4626        	beqi	a6, 4, 42011818 <_dtoa_r+0x29c>
420117f9:	3b5626        	beqi	a6, 5, 42011838 <_dtoa_r+0x2bc>
420117fc:	202626        	beqi	a6, 2, 42011820 <_dtoa_r+0x2a4>
420117ff:	080c      	movi.n	a8, 0
42011801:	e189      	s32i.n	a8, a1, 56
42011803:	353626        	beqi	a6, 3, 4201183c <_dtoa_r+0x2c0>
42011806:	f27c      	movi.n	a2, -1
42011808:	190c      	movi.n	a9, 1
4201180a:	a129      	s32i.n	a2, a1, 40
4201180c:	5129      	s32i.n	a2, a1, 20
4201180e:	e199      	s32i.n	a9, a1, 56
42011810:	221c      	movi.n	a2, 18
42011812:	136182        	s32i	a8, a1, 76
42011815:	0014c6        	j	4201186c <_dtoa_r+0x2f0>
42011818:	150c      	movi.n	a5, 1
4201181a:	e159      	s32i.n	a5, a1, 56
4201181c:	000106        	j	42011824 <_dtoa_r+0x2a8>
4201181f:	00          	.byte 00
42011820:	060c      	movi.n	a6, 0
42011822:	e169      	s32i.n	a6, a1, 56
42011824:	a188      	l32i.n	a8, a1, 40
42011826:	3c18e6        	bgei	a8, 1, 42011866 <_dtoa_r+0x2ea>
42011829:	190c      	movi.n	a9, 1
4201182b:	a199      	s32i.n	a9, a1, 40
4201182d:	5199      	s32i.n	a9, a1, 20
4201182f:	092d      	mov.n	a2, a9
42011831:	136192        	s32i	a9, a1, 76
42011834:	000d06        	j	4201186c <_dtoa_r+0x2f0>
42011837:	00          	.byte 00
42011838:	120c      	movi.n	a2, 1
4201183a:	e129      	s32i.n	a2, a1, 56
4201183c:	a188      	l32i.n	a8, a1, 40
4201183e:	4148      	l32i.n	a4, a1, 16
42011840:	120c      	movi.n	a2, 1
42011842:	448a      	add.n	a4, a4, a8
42011844:	941b      	addi.n	a9, a4, 1
42011846:	a149      	s32i.n	a4, a1, 40
42011848:	5199      	s32i.n	a9, a1, 20
4201184a:	532920        	max	a2, a9, a2
4201184d:	0006c6        	j	4201186c <_dtoa_r+0x2f0>
42011850:	020c      	movi.n	a2, 0
42011852:	d129      	s32i.n	a2, a1, 52
42011854:	d158      	l32i.n	a5, a1, 52
42011856:	f47c      	movi.n	a4, -1
42011858:	e139      	s32i.n	a3, a1, 56
4201185a:	a149      	s32i.n	a4, a1, 40
4201185c:	5149      	s32i.n	a4, a1, 20
4201185e:	221c      	movi.n	a2, 18
42011860:	136152        	s32i	a5, a1, 76
42011863:	000146        	j	4201186c <_dtoa_r+0x2f0>
42011866:	a168      	l32i.n	a6, a1, 40
42011868:	5169      	s32i.n	a6, a1, 20
4201186a:	062d      	mov.n	a2, a6
4201186c:	9758      	l32i.n	a5, a7, 36
4201186e:	0b0c      	movi.n	a11, 0
42011870:	440c      	movi.n	a4, 4
42011872:	0000c6        	j	42011879 <_dtoa_r+0x2fd>
42011875:	bb1b      	addi.n	a11, a11, 1
42011877:	444a      	add.n	a4, a4, a4
42011879:	14c462        	addi	a6, a4, 20
4201187c:	f5b267        	bgeu	a2, a6, 42011875 <_dtoa_r+0x2f9>
4201187f:	15b9      	s32i.n	a11, a5, 4
42011881:	07ad      	mov.n	a10, a7
42011883:	201110        	or	a1, a1, a1
42011886:	00d7e5        	call8	42012604 <_Balloc>
42011889:	91a9      	s32i.n	a10, a1, 36
4201188b:	facc      	bnez.n	a10, 4201189e <_dtoa_r+0x322>
4201188d:	bd02d1        	l32r	a13, 42000c98 <_stext+0xc78>
42011890:	0acd      	mov.n	a12, a10
42011892:	aaa1b2        	movi	a11, 0x1aa
42011895:	bcf5a1        	l32r	a10, 42000c6c <_stext+0xc4c>
42011898:	b9fb81        	l32r	a8, 42000084 <_stext+0x64>
4201189b:	0008e0        	callx8	a8
4201189e:	9728      	l32i.n	a2, a7, 36
420118a0:	9188      	l32i.n	a8, a1, 36
420118a2:	5198      	l32i.n	a9, a1, 20
420118a4:	0289      	s32i.n	a8, a2, 0
420118a6:	e40c      	movi.n	a4, 14
420118a8:	120c      	movi.n	a2, 1
420118aa:	02b497        	bgeu	a4, a9, 420118b0 <_dtoa_r+0x334>
420118ad:	00a022        	movi	a2, 0
420118b0:	103320        	and	a3, a3, a2
420118b3:	38f316        	beqz	a3, 42011c46 <_dtoa_r+0x6ca>
420118b6:	4128      	l32i.n	a2, a1, 16
420118b8:	7012a6        	blti	a2, 1, 4201192c <_dtoa_r+0x3b0>
420118bb:	bcf631        	l32r	a3, 42000c94 <_stext+0xc74>
420118be:	4168      	l32i.n	a6, a1, 16
420118c0:	342020        	extui	a2, a2, 0, 4
420118c3:	b02230        	addx8	a2, a2, a3
420118c6:	0248      	l32i.n	a4, a2, 0
420118c8:	1258      	l32i.n	a5, a2, 4
420118ca:	213460        	srai	a3, a6, 4
420118cd:	220c      	movi.n	a2, 2
420118cf:	1d6687        	bbci	a6, 8, 420118f0 <_dtoa_r+0x374>
420118d2:	bcf221        	l32r	a2, 42000c9c <_stext+0xc7c>
420118d5:	1021a2        	l32i	a10, a1, 64
420118d8:	0822c2        	l32i	a12, a2, 32
420118db:	0922d2        	l32i	a13, a2, 36
420118de:	1121b2        	l32i	a11, a1, 68
420118e1:	343030        	extui	a3, a3, 0, 4
420118e4:	bc6b81        	l32r	a8, 42000a90 <_stext+0xa70>
420118e7:	0008e0        	callx8	a8
420118ea:	61a9      	s32i.n	a10, a1, 24
420118ec:	71b9      	s32i.n	a11, a1, 28
420118ee:	320c      	movi.n	a2, 3
420118f0:	bceb61        	l32r	a6, 42000c9c <_stext+0xc7c>
420118f3:	000786        	j	42011915 <_dtoa_r+0x399>
420118f6:	166307        	bbci	a3, 0, 42011910 <_dtoa_r+0x394>
420118f9:	06c8      	l32i.n	a12, a6, 0
420118fb:	0126d2        	l32i	a13, a6, 4
420118fe:	20a440        	or	a10, a4, a4
42011901:	20b550        	or	a11, a5, a5
42011904:	bcc081        	l32r	a8, 42000c04 <_stext+0xbe4>
42011907:	0008e0        	callx8	a8
4201190a:	221b      	addi.n	a2, a2, 1
4201190c:	0a4d      	mov.n	a4, a10
4201190e:	0b5d      	mov.n	a5, a11
42011910:	213130        	srai	a3, a3, 1
42011913:	668b      	addi.n	a6, a6, 8
42011915:	fdd356        	bnez	a3, 420118f6 <_dtoa_r+0x37a>
42011918:	61a8      	l32i.n	a10, a1, 24
4201191a:	71b8      	l32i.n	a11, a1, 28
4201191c:	20c440        	or	a12, a4, a4
4201191f:	20d550        	or	a13, a5, a5
42011922:	bc5b81        	l32r	a8, 42000a90 <_stext+0xa70>
42011925:	0008e0        	callx8	a8
42011928:	0014c6        	j	4201197f <_dtoa_r+0x403>
4201192b:	00          	.byte 00
4201192c:	4188      	l32i.n	a8, a1, 16
4201192e:	220c      	movi.n	a2, 2
42011930:	050816        	beqz	a8, 42011984 <_dtoa_r+0x408>
42011933:	604080        	neg	a4, a8
42011936:	bcd761        	l32r	a6, 42000c94 <_stext+0xc74>
42011939:	345040        	extui	a5, a4, 0, 4
4201193c:	b05560        	addx8	a5, a5, a6
4201193f:	05c8      	l32i.n	a12, a5, 0
42011941:	15d8      	l32i.n	a13, a5, 4
42011943:	1021a2        	l32i	a10, a1, 64
42011946:	1121b2        	l32i	a11, a1, 68
42011949:	214440        	srai	a4, a4, 4
4201194c:	bcae81        	l32r	a8, 42000c04 <_stext+0xbe4>
4201194f:	0008e0        	callx8	a8
42011952:	61a9      	s32i.n	a10, a1, 24
42011954:	bcd251        	l32r	a5, 42000c9c <_stext+0xc7c>
42011957:	71b9      	s32i.n	a11, a1, 28
42011959:	060c      	movi.n	a6, 0
4201195b:	0006c6        	j	4201197a <_dtoa_r+0x3fe>
4201195e:	00          	.byte 00
4201195f:	00          	.byte 00
42011960:	00          	.byte 00
42011961:	106407        	bbci	a4, 0, 42011975 <_dtoa_r+0x3f9>
42011964:	05c8      	l32i.n	a12, a5, 0
42011966:	0125d2        	l32i	a13, a5, 4
42011969:	01c222        	addi	a2, a2, 1
4201196c:	bca681        	l32r	a8, 42000c04 <_stext+0xbe4>
4201196f:	0008e0        	callx8	a8
42011972:	206330        	or	a6, a3, a3
42011975:	214140        	srai	a4, a4, 1
42011978:	558b      	addi.n	a5, a5, 8
4201197a:	fe3456        	bnez	a4, 42011961 <_dtoa_r+0x3e5>
4201197d:	368c      	beqz.n	a6, 42011984 <_dtoa_r+0x408>
4201197f:	61a9      	s32i.n	a10, a1, 24
42011981:	0761b2        	s32i	a11, a1, 28
42011984:	142132        	l32i	a3, a1, 80
42011987:	6188      	l32i.n	a8, a1, 24
42011989:	7198      	l32i.n	a9, a1, 28
4201198b:	04b316        	beqz	a3, 420119da <_dtoa_r+0x45e>
4201198e:	bb98c1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011991:	bcc3d1        	l32r	a13, 42000ca0 <_stext+0xc80>
42011994:	08ad      	mov.n	a10, a8
42011996:	20b990        	or	a11, a9, a9
42011999:	196182        	s32i	a8, a1, 100
4201199c:	186192        	s32i	a9, a1, 96
4201199f:	bc9881        	l32r	a8, 42000c00 <_stext+0xbe0>
420119a2:	0008e0        	callx8	a8
420119a5:	192182        	l32i	a8, a1, 100
420119a8:	182192        	l32i	a9, a1, 96
420119ab:	02bad6        	bgez	a10, 420119da <_dtoa_r+0x45e>
420119ae:	5148      	l32i.n	a4, a1, 20
420119b0:	64ac      	beqz.n	a4, 420119da <_dtoa_r+0x45e>
420119b2:	a158      	l32i.n	a5, a1, 40
420119b4:	0215e6        	bgei	a5, 1, 420119ba <_dtoa_r+0x43e>
420119b7:	00a046        	j	42011c3c <_dtoa_r+0x6c0>
420119ba:	bb8dc1        	l32r	a12, 420007f0 <_stext+0x7d0>
420119bd:	bcb9d1        	l32r	a13, 42000ca4 <_stext+0xc84>
420119c0:	4168      	l32i.n	a6, a1, 16
420119c2:	08ad      	mov.n	a10, a8
420119c4:	09bd      	mov.n	a11, a9
420119c6:	bc8f81        	l32r	a8, 42000c04 <_stext+0xbe4>
420119c9:	0008e0        	callx8	a8
420119cc:	460b      	addi.n	a4, a6, -1
420119ce:	61a9      	s32i.n	a10, a1, 24
420119d0:	71b9      	s32i.n	a11, a1, 28
420119d2:	221b      	addi.n	a2, a2, 1
420119d4:	053d      	mov.n	a3, a5
420119d6:	000106        	j	420119de <_dtoa_r+0x462>
420119d9:	00          	.byte 00
420119da:	4148      	l32i.n	a4, a1, 16
420119dc:	5138      	l32i.n	a3, a1, 20
420119de:	61e8      	l32i.n	a14, a1, 24
420119e0:	71f8      	l32i.n	a15, a1, 28
420119e2:	02ad      	mov.n	a10, a2
420119e4:	1661e2        	s32i	a14, a1, 88
420119e7:	1761f2        	s32i	a15, a1, 92
420119ea:	bb8481        	l32r	a8, 420007fc <_stext+0x7dc>
420119ed:	0008e0        	callx8	a8
420119f0:	1621e2        	l32i	a14, a1, 88
420119f3:	1721f2        	l32i	a15, a1, 92
420119f6:	0ecd      	mov.n	a12, a14
420119f8:	0fdd      	mov.n	a13, a15
420119fa:	bc8281        	l32r	a8, 42000c04 <_stext+0xbe4>
420119fd:	0008e0        	callx8	a8
42011a00:	bb7cc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011a03:	bca9d1        	l32r	a13, 42000ca8 <_stext+0xc88>
42011a06:	327c      	movi.n	a2, -13
42011a08:	bb7e81        	l32r	a8, 42000800 <_stext+0x7e0>
42011a0b:	0008e0        	callx8	a8
42011a0e:	0122a0        	slli	a2, a2, 22
42011a11:	22ba      	add.n	a2, a2, a11
42011a13:	61a9      	s32i.n	a10, a1, 24
42011a15:	7129      	s32i.n	a2, a1, 28
42011a17:	1621e2        	l32i	a14, a1, 88
42011a1a:	1721f2        	l32i	a15, a1, 92
42011a1d:	047356        	bnez	a3, 42011a68 <_dtoa_r+0x4ec>
42011a20:	bb74c1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011a23:	bca2d1        	l32r	a13, 42000cac <_stext+0xc8c>
42011a26:	0ead      	mov.n	a10, a14
42011a28:	0fbd      	mov.n	a11, a15
42011a2a:	bc7881        	l32r	a8, 42000c0c <_stext+0xbec>
42011a2d:	0008e0        	callx8	a8
42011a30:	61c8      	l32i.n	a12, a1, 24
42011a32:	02dd      	mov.n	a13, a2
42011a34:	1961a2        	s32i	a10, a1, 100
42011a37:	1861b2        	s32i	a11, a1, 96
42011a3a:	bc3d81        	l32r	a8, 42000b30 <_stext+0xb10>
42011a3d:	0008e0        	callx8	a8
42011a40:	192182        	l32i	a8, a1, 100
42011a43:	182192        	l32i	a9, a1, 96
42011a46:	021aa6        	blti	a10, 1, 42011a4c <_dtoa_r+0x4d0>
42011a49:	016486        	j	42011fdf <_dtoa_r+0xa63>
42011a4c:	f47c      	movi.n	a4, -1
42011a4e:	014410        	slli	a4, a4, 31
42011a51:	61c8      	l32i.n	a12, a1, 24
42011a53:	30d240        	xor	a13, a2, a4
42011a56:	08ad      	mov.n	a10, a8
42011a58:	09bd      	mov.n	a11, a9
42011a5a:	bc6981        	l32r	a8, 42000c00 <_stext+0xbe0>
42011a5d:	0008e0        	callx8	a8
42011a60:	56aa96        	bltz	a10, 42011fce <_dtoa_r+0xa52>
42011a63:	007546        	j	42011c3c <_dtoa_r+0x6c0>
42011a66:	00          	.byte 00
42011a67:	00          	.byte 00
42011a68:	bc8b51        	l32r	a5, 42000c94 <_stext+0xc74>
42011a6b:	230b      	addi.n	a2, a3, -1
42011a6d:	b02250        	addx8	a2, a2, a5
42011a70:	02c8      	l32i.n	a12, a2, 0
42011a72:	12d8      	l32i.n	a13, a2, 4
42011a74:	e128      	l32i.n	a2, a1, 56
42011a76:	6188      	l32i.n	a8, a1, 24
42011a78:	7198      	l32i.n	a9, a1, 28
42011a7a:	0e0216        	beqz	a2, 42011b5e <_dtoa_r+0x5e2>
42011a7d:	bb5ca1        	l32r	a10, 420007f0 <_stext+0x7d0>
42011a80:	bc5ab1        	l32r	a11, 42000be8 <_stext+0xbc8>
42011a83:	1661e2        	s32i	a14, a1, 88
42011a86:	1761f2        	s32i	a15, a1, 92
42011a89:	196182        	s32i	a8, a1, 100
42011a8c:	186192        	s32i	a9, a1, 96
42011a8f:	bc0081        	l32r	a8, 42000a90 <_stext+0xa70>
42011a92:	0008e0        	callx8	a8
42011a95:	192182        	l32i	a8, a1, 100
42011a98:	182192        	l32i	a9, a1, 96
42011a9b:	08cd      	mov.n	a12, a8
42011a9d:	20d990        	or	a13, a9, a9
42011aa0:	bc5b81        	l32r	a8, 42000c0c <_stext+0xbec>
42011aa3:	0008e0        	callx8	a8
42011aa6:	9158      	l32i.n	a5, a1, 36
42011aa8:	1721f2        	l32i	a15, a1, 92
42011aab:	1621e2        	l32i	a14, a1, 88
42011aae:	61a9      	s32i.n	a10, a1, 24
42011ab0:	71b9      	s32i.n	a11, a1, 28
42011ab2:	635a      	add.n	a6, a3, a5
42011ab4:	0ead      	mov.n	a10, a14
42011ab6:	0fbd      	mov.n	a11, a15
42011ab8:	1661e2        	s32i	a14, a1, 88
42011abb:	1761f2        	s32i	a15, a1, 92
42011abe:	bb5181        	l32r	a8, 42000804 <_stext+0x7e4>
42011ac1:	0008e0        	callx8	a8
42011ac4:	0a3d      	mov.n	a3, a10
42011ac6:	bb4d81        	l32r	a8, 420007fc <_stext+0x7dc>
42011ac9:	0008e0        	callx8	a8
42011acc:	1621e2        	l32i	a14, a1, 88
42011acf:	1721f2        	l32i	a15, a1, 92
42011ad2:	0acd      	mov.n	a12, a10
42011ad4:	0bdd      	mov.n	a13, a11
42011ad6:	20aee0        	or	a10, a14, a14
42011ad9:	20bff0        	or	a11, a15, a15
42011adc:	bc4c81        	l32r	a8, 42000c0c <_stext+0xbec>
42011adf:	0008e0        	callx8	a8
42011ae2:	61c8      	l32i.n	a12, a1, 24
42011ae4:	0721d2        	l32i	a13, a1, 28
42011ae7:	30c332        	addi	a3, a3, 48
42011aea:	004532        	s8i	a3, a5, 0
42011aed:	1961a2        	s32i	a10, a1, 100
42011af0:	1861b2        	s32i	a11, a1, 96
42011af3:	bc4381        	l32r	a8, 42000c00 <_stext+0xbe0>
42011af6:	0008e0        	callx8	a8
42011af9:	192182        	l32i	a8, a1, 100
42011afc:	182192        	l32i	a9, a1, 96
42011aff:	251b      	addi.n	a2, a5, 1
42011b01:	761a96        	bltz	a10, 42012266 <_dtoa_r+0xcea>
42011b04:	bb3ba1        	l32r	a10, 420007f0 <_stext+0x7d0>
42011b07:	bc66b1        	l32r	a11, 42000ca0 <_stext+0xc80>
42011b0a:	20c880        	or	a12, a8, a8
42011b0d:	20d990        	or	a13, a9, a9
42011b10:	bc3f81        	l32r	a8, 42000c0c <_stext+0xbec>
42011b13:	0008e0        	callx8	a8
42011b16:	61c8      	l32i.n	a12, a1, 24
42011b18:	0721d2        	l32i	a13, a1, 28
42011b1b:	bc3981        	l32r	a8, 42000c00 <_stext+0xbe0>
42011b1e:	0008e0        	callx8	a8
42011b21:	222a96        	bltz	a10, 42011d47 <_dtoa_r+0x7cb>
42011b24:	029627        	bne	a6, a2, 42011b2a <_dtoa_r+0x5ae>
42011b27:	004446        	j	42011c3c <_dtoa_r+0x6c0>
42011b2a:	bb31c1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011b2d:	bc5dd1        	l32r	a13, 42000ca4 <_stext+0xc84>
42011b30:	61a8      	l32i.n	a10, a1, 24
42011b32:	71b8      	l32i.n	a11, a1, 28
42011b34:	025d      	mov.n	a5, a2
42011b36:	bc3381        	l32r	a8, 42000c04 <_stext+0xbe4>
42011b39:	0008e0        	callx8	a8
42011b3c:	192182        	l32i	a8, a1, 100
42011b3f:	182192        	l32i	a9, a1, 96
42011b42:	bb2bc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011b45:	bc57d1        	l32r	a13, 42000ca4 <_stext+0xc84>
42011b48:	61a9      	s32i.n	a10, a1, 24
42011b4a:	71b9      	s32i.n	a11, a1, 28
42011b4c:	08ad      	mov.n	a10, a8
42011b4e:	09bd      	mov.n	a11, a9
42011b50:	bc2d81        	l32r	a8, 42000c04 <_stext+0xbe4>
42011b53:	0008e0        	callx8	a8
42011b56:	0aed      	mov.n	a14, a10
42011b58:	0bfd      	mov.n	a15, a11
42011b5a:	ffd586        	j	42011ab4 <_dtoa_r+0x538>
42011b5d:	00          	.byte 00
42011b5e:	08ad      	mov.n	a10, a8
42011b60:	09bd      	mov.n	a11, a9
42011b62:	1661e2        	s32i	a14, a1, 88
42011b65:	1761f2        	s32i	a15, a1, 92
42011b68:	bc2781        	l32r	a8, 42000c04 <_stext+0xbe4>
42011b6b:	0008e0        	callx8	a8
42011b6e:	9128      	l32i.n	a2, a1, 36
42011b70:	1721f2        	l32i	a15, a1, 92
42011b73:	1621e2        	l32i	a14, a1, 88
42011b76:	61a9      	s32i.n	a10, a1, 24
42011b78:	71b9      	s32i.n	a11, a1, 28
42011b7a:	523a      	add.n	a5, a2, a3
42011b7c:	0ead      	mov.n	a10, a14
42011b7e:	20bff0        	or	a11, a15, a15
42011b81:	1661e2        	s32i	a14, a1, 88
42011b84:	1761f2        	s32i	a15, a1, 92
42011b87:	bb1f81        	l32r	a8, 42000804 <_stext+0x7e4>
42011b8a:	0008e0        	callx8	a8
42011b8d:	0a6d      	mov.n	a6, a10
42011b8f:	bb1b81        	l32r	a8, 420007fc <_stext+0x7dc>
42011b92:	0008e0        	callx8	a8
42011b95:	1621e2        	l32i	a14, a1, 88
42011b98:	1721f2        	l32i	a15, a1, 92
42011b9b:	0acd      	mov.n	a12, a10
42011b9d:	0bdd      	mov.n	a13, a11
42011b9f:	0ead      	mov.n	a10, a14
42011ba1:	0fbd      	mov.n	a11, a15
42011ba3:	30c662        	addi	a6, a6, 48
42011ba6:	bc1981        	l32r	a8, 42000c0c <_stext+0xbec>
42011ba9:	0008e0        	callx8	a8
42011bac:	004262        	s8i	a6, a2, 0
42011baf:	221b      	addi.n	a2, a2, 1
42011bb1:	0a8d      	mov.n	a8, a10
42011bb3:	209bb0        	or	a9, a11, a11
42011bb6:	6e9527        	bne	a5, a2, 42011c28 <_dtoa_r+0x6ac>
42011bb9:	bb0dc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011bbc:	bc0bd1        	l32r	a13, 42000be8 <_stext+0xbc8>
42011bbf:	61a8      	l32i.n	a10, a1, 24
42011bc1:	0721b2        	l32i	a11, a1, 28
42011bc4:	196182        	s32i	a8, a1, 100
42011bc7:	186192        	s32i	a9, a1, 96
42011bca:	bb0d81        	l32r	a8, 42000800 <_stext+0x7e0>
42011bcd:	0008e0        	callx8	a8
42011bd0:	192182        	l32i	a8, a1, 100
42011bd3:	182192        	l32i	a9, a1, 96
42011bd6:	9158      	l32i.n	a5, a1, 36
42011bd8:	0acd      	mov.n	a12, a10
42011bda:	0bdd      	mov.n	a13, a11
42011bdc:	08ad      	mov.n	a10, a8
42011bde:	09bd      	mov.n	a11, a9
42011be0:	253a      	add.n	a2, a5, a3
42011be2:	bbd381        	l32r	a8, 42000b30 <_stext+0xb10>
42011be5:	0008e0        	callx8	a8
42011be8:	021aa6        	blti	a10, 1, 42011bee <_dtoa_r+0x672>
42011beb:	005606        	j	42011d47 <_dtoa_r+0x7cb>
42011bee:	0621c2        	l32i	a12, a1, 24
42011bf1:	0721d2        	l32i	a13, a1, 28
42011bf4:	baffa1        	l32r	a10, 420007f0 <_stext+0x7d0>
42011bf7:	bbfcb1        	l32r	a11, 42000be8 <_stext+0xbc8>
42011bfa:	bc0481        	l32r	a8, 42000c0c <_stext+0xbec>
42011bfd:	0008e0        	callx8	a8
42011c00:	192182        	l32i	a8, a1, 100
42011c03:	182192        	l32i	a9, a1, 96
42011c06:	0acd      	mov.n	a12, a10
42011c08:	0bdd      	mov.n	a13, a11
42011c0a:	08ad      	mov.n	a10, a8
42011c0c:	09bd      	mov.n	a11, a9
42011c0e:	bbfc81        	l32r	a8, 42000c00 <_stext+0xbe0>
42011c11:	0008e0        	callx8	a8
42011c14:	024ad6        	bgez	a10, 42011c3c <_dtoa_r+0x6c0>
42011c17:	053c      	movi.n	a5, 48
42011c19:	023d      	mov.n	a3, a2
42011c1b:	220b      	addi.n	a2, a2, -1
42011c1d:	000262        	l8ui	a6, a2, 0
42011c20:	f51657        	beq	a6, a5, 42011c19 <_dtoa_r+0x69d>
42011c23:	032d      	mov.n	a2, a3
42011c25:	018f46        	j	42012266 <_dtoa_r+0xcea>
42011c28:	baf2c1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011c2b:	bc1ed1        	l32r	a13, 42000ca4 <_stext+0xc84>
42011c2e:	bbf581        	l32r	a8, 42000c04 <_stext+0xbe4>
42011c31:	0008e0        	callx8	a8
42011c34:	0aed      	mov.n	a14, a10
42011c36:	0bfd      	mov.n	a15, a11
42011c38:	ffd006        	j	42011b7c <_dtoa_r+0x600>
42011c3b:	00          	.byte 00
42011c3c:	102182        	l32i	a8, a1, 64
42011c3f:	112192        	l32i	a9, a1, 68
42011c42:	6189      	s32i.n	a8, a1, 24
42011c44:	7199      	s32i.n	a9, a1, 28
42011c46:	0148      	l32i.n	a4, a1, 0
42011c48:	145496        	bltz	a4, 42011d91 <_dtoa_r+0x815>
42011c4b:	4198      	l32i.n	a9, a1, 16
42011c4d:	e20c      	movi.n	a2, 14
42011c4f:	02a297        	bge	a2, a9, 42011c55 <_dtoa_r+0x6d9>
42011c52:	004ec6        	j	42011d91 <_dtoa_r+0x815>
42011c55:	bc0f21        	l32r	a2, 42000c94 <_stext+0xc74>
42011c58:	5138      	l32i.n	a3, a1, 20
42011c5a:	132162        	l32i	a6, a1, 76
42011c5d:	b02920        	addx8	a2, a9, a2
42011c60:	0248      	l32i.n	a4, a2, 0
42011c62:	1258      	l32i.n	a5, a2, 4
42011c64:	ffc322        	addi	a2, a3, -1
42011c67:	0056d6        	bgez	a6, 42011c70 <_dtoa_r+0x6f4>
42011c6a:	203320        	or	a3, a3, a2
42011c6d:	00c396        	bltz	a3, 42011c7d <_dtoa_r+0x701>
42011c70:	9168      	l32i.n	a6, a1, 36
42011c72:	6188      	l32i.n	a8, a1, 24
42011c74:	262a      	add.n	a2, a6, a2
42011c76:	7198      	l32i.n	a9, a1, 28
42011c78:	5129      	s32i.n	a2, a1, 20
42011c7a:	000a06        	j	42011ca6 <_dtoa_r+0x72a>
42011c7d:	5188      	l32i.n	a8, a1, 20
42011c7f:	349856        	bnez	a8, 42011fcc <_dtoa_r+0xa50>
42011c82:	badbc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011c85:	bc09d1        	l32r	a13, 42000cac <_stext+0xc8c>
42011c88:	04ad      	mov.n	a10, a4
42011c8a:	05bd      	mov.n	a11, a5
42011c8c:	bbde81        	l32r	a8, 42000c04 <_stext+0xbe4>
42011c8f:	0008e0        	callx8	a8
42011c92:	61c8      	l32i.n	a12, a1, 24
42011c94:	71d8      	l32i.n	a13, a1, 28
42011c96:	bc0781        	l32r	a8, 42000cb4 <_stext+0xc94>
42011c99:	0008e0        	callx8	a8
42011c9c:	5138      	l32i.n	a3, a1, 20
42011c9e:	034d      	mov.n	a4, a3
42011ca0:	32cad6        	bgez	a10, 42011fd0 <_dtoa_r+0xa54>
42011ca3:	00cf46        	j	42011fe4 <_dtoa_r+0xa68>
42011ca6:	08ad      	mov.n	a10, a8
42011ca8:	20b990        	or	a11, a9, a9
42011cab:	20c440        	or	a12, a4, a4
42011cae:	05dd      	mov.n	a13, a5
42011cb0:	196182        	s32i	a8, a1, 100
42011cb3:	186192        	s32i	a9, a1, 96
42011cb6:	bb7681        	l32r	a8, 42000a90 <_stext+0xa70>
42011cb9:	0008e0        	callx8	a8
42011cbc:	bad281        	l32r	a8, 42000804 <_stext+0x7e4>
42011cbf:	0008e0        	callx8	a8
42011cc2:	0a3d      	mov.n	a3, a10
42011cc4:	bace81        	l32r	a8, 420007fc <_stext+0x7dc>
42011cc7:	0008e0        	callx8	a8
42011cca:	04cd      	mov.n	a12, a4
42011ccc:	20d550        	or	a13, a5, a5
42011ccf:	bbcd81        	l32r	a8, 42000c04 <_stext+0xbe4>
42011cd2:	0008e0        	callx8	a8
42011cd5:	192182        	l32i	a8, a1, 100
42011cd8:	182192        	l32i	a9, a1, 96
42011cdb:	0acd      	mov.n	a12, a10
42011cdd:	0bdd      	mov.n	a13, a11
42011cdf:	08ad      	mov.n	a10, a8
42011ce1:	09bd      	mov.n	a11, a9
42011ce3:	bbca81        	l32r	a8, 42000c0c <_stext+0xbec>
42011ce6:	0008e0        	callx8	a8
42011ce9:	068d      	mov.n	a8, a6
42011ceb:	30c392        	addi	a9, a3, 48
42011cee:	004892        	s8i	a9, a8, 0
42011cf1:	5198      	l32i.n	a9, a1, 20
42011cf3:	661b      	addi.n	a6, a6, 1
42011cf5:	062d      	mov.n	a2, a6
42011cf7:	6a9987        	bne	a9, a8, 42011d65 <_dtoa_r+0x7e9>
42011cfa:	0acd      	mov.n	a12, a10
42011cfc:	20dbb0        	or	a13, a11, a11
42011cff:	bac081        	l32r	a8, 42000800 <_stext+0x7e0>
42011d02:	0008e0        	callx8	a8
42011d05:	04cd      	mov.n	a12, a4
42011d07:	05dd      	mov.n	a13, a5
42011d09:	1961a2        	s32i	a10, a1, 100
42011d0c:	1861b2        	s32i	a11, a1, 96
42011d0f:	bb8881        	l32r	a8, 42000b30 <_stext+0xb10>
42011d12:	0008e0        	callx8	a8
42011d15:	192182        	l32i	a8, a1, 100
42011d18:	182192        	l32i	a9, a1, 96
42011d1b:	261ae6        	bgei	a10, 1, 42011d45 <_dtoa_r+0x7c9>
42011d1e:	04cd      	mov.n	a12, a4
42011d20:	05dd      	mov.n	a13, a5
42011d22:	08ad      	mov.n	a10, a8
42011d24:	09bd      	mov.n	a11, a9
42011d26:	bbb881        	l32r	a8, 42000c08 <_stext+0xbe8>
42011d29:	0008e0        	callx8	a8
42011d2c:	538a56        	bnez	a10, 42012268 <_dtoa_r+0xcec>
42011d2f:	12e307        	bbsi	a3, 0, 42011d45 <_dtoa_r+0x7c9>
42011d32:	014c86        	j	42012268 <_dtoa_r+0xcec>
42011d35:	550b      	addi.n	a5, a5, -1
42011d37:	55dc      	bnez.n	a5, 42011d50 <_dtoa_r+0x7d4>
42011d39:	9168      	l32i.n	a6, a1, 36
42011d3b:	053c      	movi.n	a5, 48
42011d3d:	441b      	addi.n	a4, a4, 1
42011d3f:	004652        	s8i	a5, a6, 0
42011d42:	000506        	j	42011d5a <_dtoa_r+0x7de>
42011d45:	4148      	l32i.n	a4, a1, 16
42011d47:	9188      	l32i.n	a8, a1, 36
42011d49:	023d      	mov.n	a3, a2
42011d4b:	963c      	movi.n	a6, 57
42011d4d:	c05280        	sub	a5, a2, a8
42011d50:	032d      	mov.n	a2, a3
42011d52:	330b      	addi.n	a3, a3, -1
42011d54:	000382        	l8ui	a8, a3, 0
42011d57:	da1867        	beq	a8, a6, 42011d35 <_dtoa_r+0x7b9>
42011d5a:	000352        	l8ui	a5, a3, 0
42011d5d:	551b      	addi.n	a5, a5, 1
42011d5f:	004352        	s8i	a5, a3, 0
42011d62:	014006        	j	42012266 <_dtoa_r+0xcea>
42011d65:	baa2c1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011d68:	bbcfd1        	l32r	a13, 42000ca4 <_stext+0xc84>
42011d6b:	bba681        	l32r	a8, 42000c04 <_stext+0xbe4>
42011d6e:	0008e0        	callx8	a8
42011d71:	ba9fc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42011d74:	ba9fd1        	l32r	a13, 420007f0 <_stext+0x7d0>
42011d77:	1961a2        	s32i	a10, a1, 100
42011d7a:	1861b2        	s32i	a11, a1, 96
42011d7d:	bba281        	l32r	a8, 42000c08 <_stext+0xbe8>
42011d80:	0008e0        	callx8	a8
42011d83:	192182        	l32i	a8, a1, 100
42011d86:	182192        	l32i	a9, a1, 96
42011d89:	f19a56        	bnez	a10, 42011ca6 <_dtoa_r+0x72a>
42011d8c:	013606        	j	42012268 <_dtoa_r+0xcec>
42011d8f:	00          	.byte 00
42011d90:	00          	.byte 00
42011d91:	e198      	l32i.n	a9, a1, 56
42011d93:	067916        	beqz	a9, 42011dfe <_dtoa_r+0x882>
42011d96:	d128      	l32i.n	a2, a1, 52
42011d98:	1822e6        	bgei	a2, 2, 42011db4 <_dtoa_r+0x838>
42011d9b:	152132        	l32i	a3, a1, 84
42011d9e:	33a422        	movi	a2, 0x433
42011da1:	442a      	add.n	a4, a4, a2
42011da3:	53cc      	bnez.n	a3, 42011dac <_dtoa_r+0x830>
42011da5:	1128      	l32i.n	a2, a1, 4
42011da7:	643c      	movi.n	a4, 54
42011da9:	c04420        	sub	a4, a4, a2
42011dac:	f138      	l32i.n	a3, a1, 60
42011dae:	b128      	l32i.n	a2, a1, 44
42011db0:	000b86        	j	42011de2 <_dtoa_r+0x866>
42011db3:	00          	.byte 00
42011db4:	5148      	l32i.n	a4, a1, 20
42011db6:	f158      	l32i.n	a5, a1, 60
42011db8:	340b      	addi.n	a3, a4, -1
42011dba:	072537        	blt	a5, a3, 42011dc5 <_dtoa_r+0x849>
42011dbd:	c03530        	sub	a3, a5, a3
42011dc0:	000486        	j	42011dd6 <_dtoa_r+0x85a>
42011dc3:	00          	.byte 00
42011dc4:	00          	.byte 00
42011dc5:	f168      	l32i.n	a6, a1, 60
42011dc7:	122182        	l32i	a8, a1, 72
42011dca:	c02360        	sub	a2, a3, a6
42011dcd:	882a      	add.n	a8, a8, a2
42011dcf:	f139      	s32i.n	a3, a1, 60
42011dd1:	126182        	s32i	a8, a1, 72
42011dd4:	030c      	movi.n	a3, 0
42011dd6:	5148      	l32i.n	a4, a1, 20
42011dd8:	b128      	l32i.n	a2, a1, 44
42011dda:	0044d6        	bgez	a4, 42011de2 <_dtoa_r+0x866>
42011ddd:	c02240        	sub	a2, a2, a4
42011de0:	040c      	movi.n	a4, 0
42011de2:	b198      	l32i.n	a9, a1, 44
42011de4:	c158      	l32i.n	a5, a1, 48
42011de6:	994a      	add.n	a9, a9, a4
42011de8:	554a      	add.n	a5, a5, a4
42011dea:	1b0c      	movi.n	a11, 1
42011dec:	07ad      	mov.n	a10, a7
42011dee:	b199      	s32i.n	a9, a1, 44
42011df0:	c159      	s32i.n	a5, a1, 48
42011df2:	201110        	or	a1, a1, a1
42011df5:	00abe5        	call8	420128b4 <__i2b>
42011df8:	0a4d      	mov.n	a4, a10
42011dfa:	000186        	j	42011e04 <_dtoa_r+0x888>
42011dfd:	00          	.byte 00
42011dfe:	f138      	l32i.n	a3, a1, 60
42011e00:	b128      	l32i.n	a2, a1, 44
42011e02:	e148      	l32i.n	a4, a1, 56
42011e04:	315f20        	srai	a5, a2, 31
42011e07:	c05520        	sub	a5, a5, a2
42011e0a:	01c5d6        	bgez	a5, 42011e2a <_dtoa_r+0x8ae>
42011e0d:	c168      	l32i.n	a6, a1, 48
42011e0f:	315f60        	srai	a5, a6, 31
42011e12:	c05560        	sub	a5, a5, a6
42011e15:	0115d6        	bgez	a5, 42011e2a <_dtoa_r+0x8ae>
42011e18:	b188      	l32i.n	a8, a1, 44
42011e1a:	435260        	min	a5, a2, a6
42011e1d:	c08850        	sub	a8, a8, a5
42011e20:	c06650        	sub	a6, a6, a5
42011e23:	b189      	s32i.n	a8, a1, 44
42011e25:	c02250        	sub	a2, a2, a5
42011e28:	c169      	s32i.n	a6, a1, 48
42011e2a:	f198      	l32i.n	a9, a1, 60
42011e2c:	048916        	beqz	a9, 42011e78 <_dtoa_r+0x8fc>
42011e2f:	e158      	l32i.n	a5, a1, 56
42011e31:	55bc      	beqz.n	a5, 42011e6a <_dtoa_r+0x8ee>
42011e33:	2713a6        	blti	a3, 1, 42011e5e <_dtoa_r+0x8e2>
42011e36:	04bd      	mov.n	a11, a4
42011e38:	03cd      	mov.n	a12, a3
42011e3a:	07ad      	mov.n	a10, a7
42011e3c:	201110        	or	a1, a1, a1
42011e3f:	00c165        	call8	42012a54 <__pow5mult>
42011e42:	81c8      	l32i.n	a12, a1, 32
42011e44:	0abd      	mov.n	a11, a10
42011e46:	0a4d      	mov.n	a4, a10
42011e48:	07ad      	mov.n	a10, a7
42011e4a:	201110        	or	a1, a1, a1
42011e4d:	00a8e5        	call8	420128dc <__multiply>
42011e50:	81b8      	l32i.n	a11, a1, 32
42011e52:	0a5d      	mov.n	a5, a10
42011e54:	07ad      	mov.n	a10, a7
42011e56:	201110        	or	a1, a1, a1
42011e59:	008365        	call8	42012690 <_Bfree>
42011e5c:	8159      	s32i.n	a5, a1, 32
42011e5e:	f168      	l32i.n	a6, a1, 60
42011e60:	c0c630        	sub	a12, a6, a3
42011e63:	111637        	beq	a6, a3, 42011e78 <_dtoa_r+0x8fc>
42011e66:	000086        	j	42011e6c <_dtoa_r+0x8f0>
42011e69:	00          	.byte 00
42011e6a:	f1c8      	l32i.n	a12, a1, 60
42011e6c:	81b8      	l32i.n	a11, a1, 32
42011e6e:	07ad      	mov.n	a10, a7
42011e70:	201110        	or	a1, a1, a1
42011e73:	00be25        	call8	42012a54 <__pow5mult>
42011e76:	81a9      	s32i.n	a10, a1, 32
42011e78:	1b0c      	movi.n	a11, 1
42011e7a:	07ad      	mov.n	a10, a7
42011e7c:	201110        	or	a1, a1, a1
42011e7f:	00a365        	call8	420128b4 <__i2b>
42011e82:	122182        	l32i	a8, a1, 72
42011e85:	0a3d      	mov.n	a3, a10
42011e87:	1718a6        	blti	a8, 1, 42011ea2 <_dtoa_r+0x926>
42011e8a:	0abd      	mov.n	a11, a10
42011e8c:	08cd      	mov.n	a12, a8
42011e8e:	07ad      	mov.n	a10, a7
42011e90:	201110        	or	a1, a1, a1
42011e93:	00bc25        	call8	42012a54 <__pow5mult>
42011e96:	d198      	l32i.n	a9, a1, 52
42011e98:	0a3d      	mov.n	a3, a10
42011e9a:	050c      	movi.n	a5, 0
42011e9c:	3a29e6        	bgei	a9, 2, 42011eda <_dtoa_r+0x95e>
42011e9f:	000186        	j	42011ea9 <_dtoa_r+0x92d>
42011ea2:	d168      	l32i.n	a6, a1, 52
42011ea4:	050c      	movi.n	a5, 0
42011ea6:	2726e6        	bgei	a6, 2, 42011ed1 <_dtoa_r+0x955>
42011ea9:	6188      	l32i.n	a8, a1, 24
42011eab:	050c      	movi.n	a5, 0
42011ead:	209857        	bne	a8, a5, 42011ed1 <_dtoa_r+0x955>
42011eb0:	bb1f61        	l32r	a6, 42000b2c <_stext+0xb0c>
42011eb3:	7198      	l32i.n	a9, a1, 28
42011eb5:	188697        	bany	a6, a9, 42011ed1 <_dtoa_r+0x955>
42011eb8:	ffa762        	movi	a6, 0x7ff
42011ebb:	0166c0        	slli	a6, a6, 20
42011ebe:	0f0697        	bnone	a6, a9, 42011ed1 <_dtoa_r+0x955>
42011ec1:	b158      	l32i.n	a5, a1, 44
42011ec3:	c168      	l32i.n	a6, a1, 48
42011ec5:	551b      	addi.n	a5, a5, 1
42011ec7:	661b      	addi.n	a6, a6, 1
42011ec9:	b159      	s32i.n	a5, a1, 44
42011ecb:	0c6162        	s32i	a6, a1, 48
42011ece:	01a052        	movi	a5, 1
42011ed1:	122182        	l32i	a8, a1, 72
42011ed4:	01a0a2        	movi	a10, 1
42011ed7:	011816        	beqz	a8, 42011eec <_dtoa_r+0x970>
42011eda:	4368      	l32i.n	a6, a3, 16
42011edc:	a06630        	addx4	a6, a6, a3
42011edf:	46a8      	l32i.n	a10, a6, 16
42011ee1:	062c      	movi.n	a6, 32
42011ee3:	201110        	or	a1, a1, a1
42011ee6:	009125        	call8	420127f8 <__hi0bits>
42011ee9:	c0a6a0        	sub	a10, a6, a10
42011eec:	c198      	l32i.n	a9, a1, 48
42011eee:	aa9a      	add.n	a10, a10, a9
42011ef0:	44a0a0        	extui	a10, a10, 0, 5
42011ef3:	3aac      	beqz.n	a10, 42011f1a <_dtoa_r+0x99e>
42011ef5:	062c      	movi.n	a6, 32
42011ef7:	c066a0        	sub	a6, a6, a10
42011efa:	1356a6        	blti	a6, 5, 42011f11 <_dtoa_r+0x995>
42011efd:	b188      	l32i.n	a8, a1, 44
42011eff:	c61c      	movi.n	a6, 28
42011f01:	c066a0        	sub	a6, a6, a10
42011f04:	886a      	add.n	a8, a8, a6
42011f06:	996a      	add.n	a9, a9, a6
42011f08:	b189      	s32i.n	a8, a1, 44
42011f0a:	226a      	add.n	a2, a2, a6
42011f0c:	c199      	s32i.n	a9, a1, 48
42011f0e:	000706        	j	42011f2e <_dtoa_r+0x9b2>
42011f11:	194626        	beqi	a6, 4, 42011f2e <_dtoa_r+0x9b2>
42011f14:	000106        	j	42011f1c <_dtoa_r+0x9a0>
42011f17:	00          	.byte 00
42011f18:	00          	.byte 00
42011f19:	00          	.byte 00
42011f1a:	0a6d      	mov.n	a6, a10
42011f1c:	b198      	l32i.n	a9, a1, 44
42011f1e:	c188      	l32i.n	a8, a1, 48
42011f20:	1cc662        	addi	a6, a6, 28
42011f23:	996a      	add.n	a9, a9, a6
42011f25:	886a      	add.n	a8, a8, a6
42011f27:	b199      	s32i.n	a9, a1, 44
42011f29:	226a      	add.n	a2, a2, a6
42011f2b:	0c6182        	s32i	a8, a1, 48
42011f2e:	b198      	l32i.n	a9, a1, 44
42011f30:	1119a6        	blti	a9, 1, 42011f45 <_dtoa_r+0x9c9>
42011f33:	0821b2        	l32i	a11, a1, 32
42011f36:	20c990        	or	a12, a9, a9
42011f39:	20a770        	or	a10, a7, a7
42011f3c:	201110        	or	a1, a1, a1
42011f3f:	00bbe5        	call8	42012afc <__lshift>
42011f42:	0861a2        	s32i	a10, a1, 32
42011f45:	c168      	l32i.n	a6, a1, 48
42011f47:	0f16a6        	blti	a6, 1, 42011f5a <_dtoa_r+0x9de>
42011f4a:	03bd      	mov.n	a11, a3
42011f4c:	20c660        	or	a12, a6, a6
42011f4f:	20a770        	or	a10, a7, a7
42011f52:	201110        	or	a1, a1, a1
42011f55:	00ba65        	call8	42012afc <__lshift>
42011f58:	0a3d      	mov.n	a3, a10
42011f5a:	142182        	l32i	a8, a1, 80
42011f5d:	98bc      	beqz.n	a8, 42011f9a <_dtoa_r+0xa1e>
42011f5f:	81a8      	l32i.n	a10, a1, 32
42011f61:	03bd      	mov.n	a11, a3
42011f63:	201110        	or	a1, a1, a1
42011f66:	00c9a5        	call8	42012c00 <__mcmp>
42011f69:	02dad6        	bgez	a10, 42011f9a <_dtoa_r+0xa1e>
42011f6c:	4198      	l32i.n	a9, a1, 16
42011f6e:	81b8      	l32i.n	a11, a1, 32
42011f70:	990b      	addi.n	a9, a9, -1
42011f72:	0d0c      	movi.n	a13, 0
42011f74:	ac0c      	movi.n	a12, 10
42011f76:	07ad      	mov.n	a10, a7
42011f78:	4199      	s32i.n	a9, a1, 16
42011f7a:	201110        	or	a1, a1, a1
42011f7d:	007525        	call8	420126d0 <__multadd>
42011f80:	a168      	l32i.n	a6, a1, 40
42011f82:	e188      	l32i.n	a8, a1, 56
42011f84:	81a9      	s32i.n	a10, a1, 32
42011f86:	5169      	s32i.n	a6, a1, 20
42011f88:	e88c      	beqz.n	a8, 42011f9a <_dtoa_r+0xa1e>
42011f8a:	04bd      	mov.n	a11, a4
42011f8c:	0d0c      	movi.n	a13, 0
42011f8e:	ac0c      	movi.n	a12, 10
42011f90:	07ad      	mov.n	a10, a7
42011f92:	201110        	or	a1, a1, a1
42011f95:	0073a5        	call8	420126d0 <__multadd>
42011f98:	0a4d      	mov.n	a4, a10
42011f9a:	5198      	l32i.n	a9, a1, 20
42011f9c:	690b      	addi.n	a6, a9, -1
42011f9e:	206960        	or	a6, a9, a6
42011fa1:	0536d6        	bgez	a6, 42011ff8 <_dtoa_r+0xa7c>
42011fa4:	d168      	l32i.n	a6, a1, 52
42011fa6:	4e36a6        	blti	a6, 3, 42011ff8 <_dtoa_r+0xa7c>
42011fa9:	39ec      	bnez.n	a9, 42011fd0 <_dtoa_r+0xa54>
42011fab:	03bd      	mov.n	a11, a3
42011fad:	09dd      	mov.n	a13, a9
42011faf:	5c0c      	movi.n	a12, 5
42011fb1:	07ad      	mov.n	a10, a7
42011fb3:	201110        	or	a1, a1, a1
42011fb6:	0071a5        	call8	420126d0 <__multadd>
42011fb9:	0a3d      	mov.n	a3, a10
42011fbb:	0abd      	mov.n	a11, a10
42011fbd:	81a8      	l32i.n	a10, a1, 32
42011fbf:	201110        	or	a1, a1, a1
42011fc2:	00c3e5        	call8	42012c00 <__mcmp>
42011fc5:	1b1ae6        	bgei	a10, 1, 42011fe4 <_dtoa_r+0xa68>
42011fc8:	000106        	j	42011fd0 <_dtoa_r+0xa54>
42011fcb:	00          	.byte 00
42011fcc:	030c      	movi.n	a3, 0
42011fce:	034d      	mov.n	a4, a3
42011fd0:	132182        	l32i	a8, a1, 76
42011fd3:	f27c      	movi.n	a2, -1
42011fd5:	302280        	xor	a2, a2, a8
42011fd8:	4129      	s32i.n	a2, a1, 16
42011fda:	9128      	l32i.n	a2, a1, 36
42011fdc:	0004c6        	j	42011ff3 <_dtoa_r+0xa77>
42011fdf:	4149      	s32i.n	a4, a1, 16
42011fe1:	204330        	or	a4, a3, a3
42011fe4:	9198      	l32i.n	a9, a1, 36
42011fe6:	153c      	movi.n	a5, 49
42011fe8:	004952        	s8i	a5, a9, 0
42011feb:	4158      	l32i.n	a5, a1, 16
42011fed:	291b      	addi.n	a2, a9, 1
42011fef:	551b      	addi.n	a5, a5, 1
42011ff1:	4159      	s32i.n	a5, a1, 16
42011ff3:	050c      	movi.n	a5, 0
42011ff5:	0090c6        	j	4201223c <_dtoa_r+0xcc0>
42011ff8:	e168      	l32i.n	a6, a1, 56
42011ffa:	19c616        	beqz	a6, 4201219a <_dtoa_r+0xc1e>
42011ffd:	0d12a6        	blti	a2, 1, 4201200e <_dtoa_r+0xa92>
42012000:	04bd      	mov.n	a11, a4
42012002:	02cd      	mov.n	a12, a2
42012004:	07ad      	mov.n	a10, a7
42012006:	201110        	or	a1, a1, a1
42012009:	00af25        	call8	42012afc <__lshift>
4201200c:	0a4d      	mov.n	a4, a10
4201200e:	04ad      	mov.n	a10, a4
42012010:	55bc      	beqz.n	a5, 42012049 <_dtoa_r+0xacd>
42012012:	14b8      	l32i.n	a11, a4, 4
42012014:	07ad      	mov.n	a10, a7
42012016:	201110        	or	a1, a1, a1
42012019:	005ea5        	call8	42012604 <_Balloc>
4201201c:	0a2d      	mov.n	a2, a10
4201201e:	aacc      	bnez.n	a10, 4201202c <_dtoa_r+0xab0>
42012020:	bb1ed1        	l32r	a13, 42000c98 <_stext+0xc78>
42012023:	0acd      	mov.n	a12, a10
42012025:	eaa2b2        	movi	a11, 0x2ea
42012028:	fe1a46        	j	42011895 <_dtoa_r+0x319>
4201202b:	00          	.byte 00
4201202c:	44c8      	l32i.n	a12, a4, 16
4201202e:	b4cb      	addi.n	a11, a4, 12
42012030:	cc2b      	addi.n	a12, a12, 2
42012032:	11cce0        	slli	a12, a12, 2
42012035:	aacb      	addi.n	a10, a10, 12
42012037:	b86581        	l32r	a8, 420001cc <_stext+0x1ac>
4201203a:	0008e0        	callx8	a8
4201203d:	1c0c      	movi.n	a12, 1
4201203f:	02bd      	mov.n	a11, a2
42012041:	07ad      	mov.n	a10, a7
42012043:	201110        	or	a1, a1, a1
42012046:	00ab65        	call8	42012afc <__lshift>
42012049:	9198      	l32i.n	a9, a1, 36
4201204b:	5188      	l32i.n	a8, a1, 20
4201204d:	290b      	addi.n	a2, a9, -1
4201204f:	228a      	add.n	a2, a2, a8
42012051:	b129      	s32i.n	a2, a1, 44
42012053:	6128      	l32i.n	a2, a1, 24
42012055:	045d      	mov.n	a5, a4
42012057:	042020        	extui	a2, a2, 0, 1
4201205a:	0a4d      	mov.n	a4, a10
4201205c:	a129      	s32i.n	a2, a1, 40
4201205e:	81a8      	l32i.n	a10, a1, 32
42012060:	03bd      	mov.n	a11, a3
42012062:	186192        	s32i	a9, a1, 96
42012065:	ff3da5        	call8	42011440 <quorem>
42012068:	30ca82        	addi	a8, a10, 48
4201206b:	51a9      	s32i.n	a10, a1, 20
4201206d:	81a8      	l32i.n	a10, a1, 32
4201206f:	05bd      	mov.n	a11, a5
42012071:	196182        	s32i	a8, a1, 100
42012074:	201110        	or	a1, a1, a1
42012077:	00b8a5        	call8	42012c00 <__mcmp>
4201207a:	04cd      	mov.n	a12, a4
4201207c:	0a6d      	mov.n	a6, a10
4201207e:	03bd      	mov.n	a11, a3
42012080:	07ad      	mov.n	a10, a7
42012082:	201110        	or	a1, a1, a1
42012085:	00bb65        	call8	42012c3c <__mdiff>
42012088:	0a2d      	mov.n	a2, a10
4201208a:	3aa8      	l32i.n	a10, a10, 12
4201208c:	e1c8      	l32i.n	a12, a1, 56
4201208e:	192182        	l32i	a8, a1, 100
42012091:	182192        	l32i	a9, a1, 96
42012094:	1adc      	bnez.n	a10, 420120a9 <_dtoa_r+0xb2d>
42012096:	81a8      	l32i.n	a10, a1, 32
42012098:	20b220        	or	a11, a2, a2
4201209b:	201110        	or	a1, a1, a1
4201209e:	00b625        	call8	42012c00 <__mcmp>
420120a1:	182192        	l32i	a9, a1, 96
420120a4:	192182        	l32i	a8, a1, 100
420120a7:	0acd      	mov.n	a12, a10
420120a9:	02bd      	mov.n	a11, a2
420120ab:	07ad      	mov.n	a10, a7
420120ad:	196182        	s32i	a8, a1, 100
420120b0:	186192        	s32i	a9, a1, 96
420120b3:	1661c2        	s32i	a12, a1, 88
420120b6:	201110        	or	a1, a1, a1
420120b9:	005d65        	call8	42012690 <_Bfree>
420120bc:	d1b8      	l32i.n	a11, a1, 52
420120be:	1621c2        	l32i	a12, a1, 88
420120c1:	182192        	l32i	a9, a1, 96
420120c4:	20abc0        	or	a10, a11, a12
420120c7:	a1b8      	l32i.n	a11, a1, 40
420120c9:	192182        	l32i	a8, a1, 100
420120cc:	20aab0        	or	a10, a10, a11
420120cf:	291b      	addi.n	a2, a9, 1
420120d1:	cacc      	bnez.n	a10, 420120e1 <_dtoa_r+0xb65>
420120d3:	9a3c      	movi.n	a10, 57
420120d5:	5b18a7        	beq	a8, a10, 42012134 <_dtoa_r+0xbb8>
420120d8:	6416a6        	blti	a6, 1, 42012140 <_dtoa_r+0xbc4>
420120db:	001106        	j	42012123 <_dtoa_r+0xba7>
420120de:	00          	.byte 00
420120df:	00          	.byte 00
420120e0:	00          	.byte 00
420120e1:	00c696        	bltz	a6, 420120f1 <_dtoa_r+0xb75>
420120e4:	d1a8      	l32i.n	a10, a1, 52
420120e6:	0a21b2        	l32i	a11, a1, 40
420120e9:	206a60        	or	a6, a10, a6
420120ec:	2066b0        	or	a6, a6, a11
420120ef:	96fc      	bnez.n	a6, 4201212c <_dtoa_r+0xbb0>
420120f1:	4b1ca6        	blti	a12, 1, 42012140 <_dtoa_r+0xbc4>
420120f4:	81b8      	l32i.n	a11, a1, 32
420120f6:	1c0c      	movi.n	a12, 1
420120f8:	07ad      	mov.n	a10, a7
420120fa:	196182        	s32i	a8, a1, 100
420120fd:	186192        	s32i	a9, a1, 96
42012100:	201110        	or	a1, a1, a1
42012103:	009fa5        	call8	42012afc <__lshift>
42012106:	03bd      	mov.n	a11, a3
42012108:	81a9      	s32i.n	a10, a1, 32
4201210a:	201110        	or	a1, a1, a1
4201210d:	00af25        	call8	42012c00 <__mcmp>
42012110:	192182        	l32i	a8, a1, 100
42012113:	182192        	l32i	a9, a1, 96
42012116:	041ae6        	bgei	a10, 1, 4201211e <_dtoa_r+0xba2>
42012119:	3aec      	bnez.n	a10, 42012140 <_dtoa_r+0xbc4>
4201211b:	216807        	bbci	a8, 0, 42012140 <_dtoa_r+0xbc4>
4201211e:	963c      	movi.n	a6, 57
42012120:	101867        	beq	a8, a6, 42012134 <_dtoa_r+0xbb8>
42012123:	5168      	l32i.n	a6, a1, 20
42012125:	31c682        	addi	a8, a6, 49
42012128:	000506        	j	42012140 <_dtoa_r+0xbc4>
4201212b:	00          	.byte 00
4201212c:	161ca6        	blti	a12, 1, 42012146 <_dtoa_r+0xbca>
4201212f:	963c      	movi.n	a6, 57
42012131:	099867        	bne	a8, a6, 4201213e <_dtoa_r+0xbc2>
42012134:	963c      	movi.n	a6, 57
42012136:	004962        	s8i	a6, a9, 0
42012139:	003546        	j	42012212 <_dtoa_r+0xc96>
4201213c:	00          	.byte 00
4201213d:	00          	.byte 00
4201213e:	881b      	addi.n	a8, a8, 1
42012140:	004982        	s8i	a8, a9, 0
42012143:	003d46        	j	4201223c <_dtoa_r+0xcc0>
42012146:	b168      	l32i.n	a6, a1, 44
42012148:	004982        	s8i	a8, a9, 0
4201214b:	029697        	bne	a6, a9, 42012151 <_dtoa_r+0xbd5>
4201214e:	002106        	j	420121d6 <_dtoa_r+0xc5a>
42012151:	81b8      	l32i.n	a11, a1, 32
42012153:	0d0c      	movi.n	a13, 0
42012155:	ac0c      	movi.n	a12, 10
42012157:	20a770        	or	a10, a7, a7
4201215a:	201110        	or	a1, a1, a1
4201215d:	005725        	call8	420126d0 <__multadd>
42012160:	81a9      	s32i.n	a10, a1, 32
42012162:	0d0c      	movi.n	a13, 0
42012164:	ac0c      	movi.n	a12, 10
42012166:	05bd      	mov.n	a11, a5
42012168:	20a770        	or	a10, a7, a7
4201216b:	0d9547        	bne	a5, a4, 4201217c <_dtoa_r+0xc00>
4201216e:	201110        	or	a1, a1, a1
42012171:	0055e5        	call8	420126d0 <__multadd>
42012174:	0a5d      	mov.n	a5, a10
42012176:	0a4d      	mov.n	a4, a10
42012178:	000606        	j	42012194 <_dtoa_r+0xc18>
4201217b:	00          	.byte 00
4201217c:	201110        	or	a1, a1, a1
4201217f:	005525        	call8	420126d0 <__multadd>
42012182:	04bd      	mov.n	a11, a4
42012184:	0a5d      	mov.n	a5, a10
42012186:	0d0c      	movi.n	a13, 0
42012188:	ac0c      	movi.n	a12, 10
4201218a:	07ad      	mov.n	a10, a7
4201218c:	201110        	or	a1, a1, a1
4201218f:	005425        	call8	420126d0 <__multadd>
42012192:	0a4d      	mov.n	a4, a10
42012194:	029d      	mov.n	a9, a2
42012196:	ffb106        	j	4201205e <_dtoa_r+0xae2>
42012199:	00          	.byte 00
4201219a:	e158      	l32i.n	a5, a1, 56
4201219c:	052d      	mov.n	a2, a5
4201219e:	81a8      	l32i.n	a10, a1, 32
420121a0:	03bd      	mov.n	a11, a3
420121a2:	ff29e5        	call8	42011440 <quorem>
420121a5:	9198      	l32i.n	a9, a1, 36
420121a7:	30ca82        	addi	a8, a10, 48
420121aa:	695a      	add.n	a6, a9, a5
420121ac:	004682        	s8i	a8, a6, 0
420121af:	5168      	l32i.n	a6, a1, 20
420121b1:	551b      	addi.n	a5, a5, 1
420121b3:	12a567        	bge	a5, a6, 420121c9 <_dtoa_r+0xc4d>
420121b6:	81b8      	l32i.n	a11, a1, 32
420121b8:	02dd      	mov.n	a13, a2
420121ba:	ac0c      	movi.n	a12, 10
420121bc:	07ad      	mov.n	a10, a7
420121be:	201110        	or	a1, a1, a1
420121c1:	0050e5        	call8	420126d0 <__multadd>
420121c4:	81a9      	s32i.n	a10, a1, 32
420121c6:	fff506        	j	4201219e <_dtoa_r+0xc22>
420121c9:	5198      	l32i.n	a9, a1, 20
420121cb:	9158      	l32i.n	a5, a1, 36
420121cd:	120c      	movi.n	a2, 1
420121cf:	532920        	max	a2, a9, a2
420121d2:	252a      	add.n	a2, a5, a2
420121d4:	050c      	movi.n	a5, 0
420121d6:	81b8      	l32i.n	a11, a1, 32
420121d8:	1c0c      	movi.n	a12, 1
420121da:	20a770        	or	a10, a7, a7
420121dd:	196182        	s32i	a8, a1, 100
420121e0:	201110        	or	a1, a1, a1
420121e3:	0091a5        	call8	42012afc <__lshift>
420121e6:	03bd      	mov.n	a11, a3
420121e8:	81a9      	s32i.n	a10, a1, 32
420121ea:	201110        	or	a1, a1, a1
420121ed:	00a125        	call8	42012c00 <__mcmp>
420121f0:	192182        	l32i	a8, a1, 100
420121f3:	1b1ae6        	bgei	a10, 1, 42012212 <_dtoa_r+0xc96>
420121f6:	4afc      	bnez.n	a10, 4201222e <_dtoa_r+0xcb2>
420121f8:	16e807        	bbsi	a8, 0, 42012212 <_dtoa_r+0xc96>
420121fb:	000bc6        	j	4201222e <_dtoa_r+0xcb2>
420121fe:	880b      	addi.n	a8, a8, -1
42012200:	88dc      	bnez.n	a8, 4201221c <_dtoa_r+0xca0>
42012202:	4168      	l32i.n	a6, a1, 16
42012204:	9188      	l32i.n	a8, a1, 36
42012206:	661b      	addi.n	a6, a6, 1
42012208:	4169      	s32i.n	a6, a1, 16
4201220a:	163c      	movi.n	a6, 49
4201220c:	004862        	s8i	a6, a8, 0
4201220f:	000a46        	j	4201223c <_dtoa_r+0xcc0>
42012212:	026d      	mov.n	a6, a2
42012214:	9128      	l32i.n	a2, a1, 36
42012216:	39a092        	movi	a9, 57
42012219:	c08620        	sub	a8, a6, a2
4201221c:	062d      	mov.n	a2, a6
4201221e:	660b      	addi.n	a6, a6, -1
42012220:	0006a2        	l8ui	a10, a6, 0
42012223:	d71a97        	beq	a10, a9, 420121fe <_dtoa_r+0xc82>
42012226:	8a1b      	addi.n	a8, a10, 1
42012228:	004682        	s8i	a8, a6, 0
4201222b:	000346        	j	4201223c <_dtoa_r+0xcc0>
4201222e:	093c      	movi.n	a9, 48
42012230:	026d      	mov.n	a6, a2
42012232:	220b      	addi.n	a2, a2, -1
42012234:	000282        	l8ui	a8, a2, 0
42012237:	f51897        	beq	a8, a9, 42012230 <_dtoa_r+0xcb4>
4201223a:	062d      	mov.n	a2, a6
4201223c:	03bd      	mov.n	a11, a3
4201223e:	07ad      	mov.n	a10, a7
42012240:	201110        	or	a1, a1, a1
42012243:	0044e5        	call8	42012690 <_Bfree>
42012246:	e49c      	beqz.n	a4, 42012268 <_dtoa_r+0xcec>
42012248:	c58c      	beqz.n	a5, 42012258 <_dtoa_r+0xcdc>
4201224a:	0a1547        	beq	a5, a4, 42012258 <_dtoa_r+0xcdc>
4201224d:	20b550        	or	a11, a5, a5
42012250:	07ad      	mov.n	a10, a7
42012252:	201110        	or	a1, a1, a1
42012255:	0043a5        	call8	42012690 <_Bfree>
42012258:	04bd      	mov.n	a11, a4
4201225a:	07ad      	mov.n	a10, a7
4201225c:	201110        	or	a1, a1, a1
4201225f:	004325        	call8	42012690 <_Bfree>
42012262:	000086        	j	42012268 <_dtoa_r+0xcec>
42012265:	00          	.byte 00
42012266:	4149      	s32i.n	a4, a1, 16
42012268:	81b8      	l32i.n	a11, a1, 32
4201226a:	07ad      	mov.n	a10, a7
4201226c:	201110        	or	a1, a1, a1
4201226f:	004225        	call8	42012690 <_Bfree>
42012272:	4148      	l32i.n	a4, a1, 16
42012274:	030c      	movi.n	a3, 0
42012276:	242152        	l32i	a5, a1, 144
42012279:	004232        	s8i	a3, a2, 0
4201227c:	262162        	l32i	a6, a1, 152
4201227f:	341b      	addi.n	a3, a4, 1
42012281:	0539      	s32i.n	a3, a5, 0
42012283:	56ac      	beqz.n	a6, 420122ac <_dtoa_r+0xd30>
42012285:	0629      	s32i.n	a2, a6, 0
42012287:	000846        	j	420122ac <_dtoa_r+0xd30>
4201228a:	00          	.byte 00
4201228b:	00          	.byte 00
4201228c:	ba7281        	l32r	a8, 42000c54 <_stext+0xc34>
4201228f:	262192        	l32i	a9, a1, 152
42012292:	9189      	s32i.n	a8, a1, 36
42012294:	ba7121        	l32r	a2, 42000c58 <_stext+0xc38>
42012297:	198c      	beqz.n	a9, 4201229c <_dtoa_r+0xd20>
42012299:	fcdfc6        	j	4201161c <_dtoa_r+0xa0>
4201229c:	000306        	j	420122ac <_dtoa_r+0xd30>
4201229f:	ba6f21        	l32r	a2, 42000c5c <_stext+0xc3c>
420122a2:	262132        	l32i	a3, a1, 152
420122a5:	9129      	s32i.n	a2, a1, 36
420122a7:	138c      	beqz.n	a3, 420122ac <_dtoa_r+0xd30>
420122a9:	fcdb06        	j	42011619 <_dtoa_r+0x9d>
420122ac:	9128      	l32i.n	a2, a1, 36
420122ae:	f01d      	retw.n

420122b0 <_fclose_r>:
420122b0:	006136        	entry	a1, 48
420122b3:	034d      	mov.n	a4, a3
420122b5:	0ff316        	beqz	a3, 420123b8 <_fclose_r+0x108>
420122b8:	c28c      	beqz.n	a2, 420122c8 <_fclose_r+0x18>
420122ba:	6248      	l32i.n	a4, a2, 24
420122bc:	008456        	bnez	a4, 420122c8 <_fclose_r+0x18>
420122bf:	20a220        	or	a10, a2, a2
420122c2:	201110        	or	a1, a1, a1
420122c5:	f76ee5        	call8	420099b4 <__sinit>
420122c8:	ba2a41        	l32r	a4, 42000b70 <_stext+0xb50>
420122cb:	059347        	bne	a3, a4, 420122d4 <_fclose_r+0x24>
420122ce:	1238      	l32i.n	a3, a2, 4
420122d0:	000586        	j	420122ea <_fclose_r+0x3a>
420122d3:	00          	.byte 00
420122d4:	ba2841        	l32r	a4, 42000b74 <_stext+0xb54>
420122d7:	069347        	bne	a3, a4, 420122e1 <_fclose_r+0x31>
420122da:	2238      	l32i.n	a3, a2, 8
420122dc:	000286        	j	420122ea <_fclose_r+0x3a>
420122df:	00          	.byte 00
420122e0:	00          	.byte 00
420122e1:	ba2541        	l32r	a4, 42000b78 <_stext+0xb58>
420122e4:	029347        	bne	a3, a4, 420122ea <_fclose_r+0x3a>
420122e7:	032232        	l32i	a3, a2, 12
420122ea:	01bd      	mov.n	a11, a1
420122ec:	1a0c      	movi.n	a10, 1
420122ee:	201110        	or	a1, a1, a1
420122f1:	05c225        	call8	42017f14 <pthread_setcancelstate>
420122f4:	192342        	l32i	a4, a3, 100
420122f7:	0ee407        	bbsi	a4, 0, 42012309 <_fclose_r+0x59>
420122fa:	061342        	l16ui	a4, a3, 12
420122fd:	08e497        	bbsi	a4, 9, 42012309 <_fclose_r+0x59>
42012300:	1623a2        	l32i	a10, a3, 88
42012303:	ba1281        	l32r	a8, 42000b4c <_stext+0xb2c>
42012306:	0008e0        	callx8	a8
42012309:	069342        	l16si	a4, a3, 12
4201230c:	01e456        	bnez	a4, 4201232e <_fclose_r+0x7e>
4201230f:	192322        	l32i	a2, a3, 100
42012312:	08e207        	bbsi	a2, 0, 4201231e <_fclose_r+0x6e>
42012315:	1623a2        	l32i	a10, a3, 88
42012318:	ba0e81        	l32r	a8, 42000b50 <_stext+0xb30>
4201231b:	0008e0        	callx8	a8
4201231e:	01a8      	l32i.n	a10, a1, 0
42012320:	01bd      	mov.n	a11, a1
42012322:	201110        	or	a1, a1, a1
42012325:	05bee5        	call8	42017f14 <pthread_setcancelstate>
42012328:	040c      	movi.n	a4, 0
4201232a:	002286        	j	420123b8 <_fclose_r+0x108>
4201232d:	00          	.byte 00
4201232e:	03bd      	mov.n	a11, a3
42012330:	02ad      	mov.n	a10, a2
42012332:	201110        	or	a1, a1, a1
42012335:	0009a5        	call8	420123d0 <__sflush_r>
42012338:	c388      	l32i.n	a8, a3, 48
4201233a:	0a4d      	mov.n	a4, a10
4201233c:	a88c      	beqz.n	a8, 4201234a <_fclose_r+0x9a>
4201233e:	83b8      	l32i.n	a11, a3, 32
42012340:	02ad      	mov.n	a10, a2
42012342:	0008e0        	callx8	a8
42012345:	f87c      	movi.n	a8, -1
42012347:	a348a0        	movltz	a4, a8, a10
4201234a:	061382        	l16ui	a8, a3, 12
4201234d:	096877        	bbci	a8, 7, 4201235a <_fclose_r+0xaa>
42012350:	43b8      	l32i.n	a11, a3, 16
42012352:	02ad      	mov.n	a10, a2
42012354:	ba0b81        	l32r	a8, 42000b80 <_stext+0xb60>
42012357:	0008e0        	callx8	a8
4201235a:	d3b8      	l32i.n	a11, a3, 52
4201235c:	1b9c      	beqz.n	a11, 42012371 <_fclose_r+0xc1>
4201235e:	44c382        	addi	a8, a3, 68
42012361:	081b87        	beq	a11, a8, 4201236d <_fclose_r+0xbd>
42012364:	20a220        	or	a10, a2, a2
42012367:	ba0681        	l32r	a8, 42000b80 <_stext+0xb60>
4201236a:	0008e0        	callx8	a8
4201236d:	080c      	movi.n	a8, 0
4201236f:	d389      	s32i.n	a8, a3, 52
42012371:	1223b2        	l32i	a11, a3, 72
42012374:	cb8c      	beqz.n	a11, 42012384 <_fclose_r+0xd4>
42012376:	02ad      	mov.n	a10, a2
42012378:	00a022        	movi	a2, 0
4201237b:	ba0181        	l32r	a8, 42000b80 <_stext+0xb60>
4201237e:	0008e0        	callx8	a8
42012381:	126322        	s32i	a2, a3, 72
42012384:	020c      	movi.n	a2, 0
42012386:	201110        	or	a1, a1, a1
42012389:	f75ea5        	call8	42009974 <__sfp_lock_acquire>
4201238c:	065322        	s16i	a2, a3, 12
4201238f:	192322        	l32i	a2, a3, 100
42012392:	08e207        	bbsi	a2, 0, 4201239e <_fclose_r+0xee>
42012395:	1623a2        	l32i	a10, a3, 88
42012398:	b9ee81        	l32r	a8, 42000b50 <_stext+0xb30>
4201239b:	0008e0        	callx8	a8
4201239e:	1623a2        	l32i	a10, a3, 88
420123a1:	b9f281        	l32r	a8, 42000b6c <_stext+0xb4c>
420123a4:	0008e0        	callx8	a8
420123a7:	201110        	or	a1, a1, a1
420123aa:	f75da5        	call8	42009984 <__sfp_lock_release>
420123ad:	01a8      	l32i.n	a10, a1, 0
420123af:	20b110        	or	a11, a1, a1
420123b2:	201110        	or	a1, a1, a1
420123b5:	05b5e5        	call8	42017f14 <pthread_setcancelstate>
420123b8:	042d      	mov.n	a2, a4
420123ba:	f01d      	retw.n

420123bc <fclose>:
420123bc:	004136        	entry	a1, 32
420123bf:	b9dd81        	l32r	a8, 42000b34 <_stext+0xb14>
420123c2:	0008e0        	callx8	a8
420123c5:	02bd      	mov.n	a11, a2
420123c7:	ffeea5        	call8	420122b0 <_fclose_r>
420123ca:	0a2d      	mov.n	a2, a10
420123cc:	f01d      	retw.n
	...

420123d0 <__sflush_r>:
420123d0:	004136        	entry	a1, 32
420123d3:	061352        	l16ui	a5, a3, 12
420123d6:	234580        	sext	a4, a5, 15
420123d9:	f48050        	extui	a8, a5, 0, 16
420123dc:	026537        	bbci	a5, 3, 420123e2 <__sflush_r+0x12>
420123df:	003d46        	j	420124d8 <__sflush_r+0x108>
420123e2:	150c      	movi.n	a5, 1
420123e4:	115550        	slli	a5, a5, 11
420123e7:	204450        	or	a4, a4, a5
420123ea:	1358      	l32i.n	a5, a3, 4
420123ec:	065342        	s16i	a4, a3, 12
420123ef:	0915e6        	bgei	a5, 1, 420123fc <__sflush_r+0x2c>
420123f2:	102352        	l32i	a5, a3, 64
420123f5:	0315e6        	bgei	a5, 1, 420123fc <__sflush_r+0x2c>
420123f8:	001106        	j	42012440 <__sflush_r+0x70>
420123fb:	00          	.byte 00
420123fc:	b398      	l32i.n	a9, a3, 44
420123fe:	e9bc      	beqz.n	a9, 42012440 <__sflush_r+0x70>
42012400:	080c      	movi.n	a8, 0
42012402:	0258      	l32i.n	a5, a2, 0
42012404:	0289      	s32i.n	a8, a2, 0
42012406:	180c      	movi.n	a8, 1
42012408:	118840        	slli	a8, a8, 12
4201240b:	104480        	and	a4, a4, a8
4201240e:	83b8      	l32i.n	a11, a3, 32
42012410:	448c      	beqz.n	a4, 42012418 <__sflush_r+0x48>
42012412:	1523a2        	l32i	a10, a3, 84
42012415:	000ec6        	j	42012454 <__sflush_r+0x84>
42012418:	1d0c      	movi.n	a13, 1
4201241a:	04cd      	mov.n	a12, a4
4201241c:	02ad      	mov.n	a10, a2
4201241e:	0009e0        	callx8	a9
42012421:	2f0a66        	bnei	a10, -1, 42012454 <__sflush_r+0x84>
42012424:	0288      	l32i.n	a8, a2, 0
42012426:	a8ac      	beqz.n	a8, 42012454 <__sflush_r+0x84>
42012428:	e3c8b2        	addi	a11, a8, -29
4201242b:	190c      	movi.n	a9, 1
4201242d:	8349b0        	moveqz	a4, a9, a11
42012430:	744040        	extui	a4, a4, 0, 8
42012433:	74cc      	bnez.n	a4, 4201243e <__sflush_r+0x6e>
42012435:	eac882        	addi	a8, a8, -22
42012438:	939480        	movnez	a9, a4, a8
4201243b:	006916        	beqz	a9, 42012445 <__sflush_r+0x75>
4201243e:	0259      	s32i.n	a5, a2, 0
42012440:	0a0c      	movi.n	a10, 0
42012442:	003646        	j	4201251f <__sflush_r+0x14f>
42012445:	061322        	l16ui	a2, a3, 12
42012448:	044c      	movi.n	a4, 64
4201244a:	202240        	or	a2, a2, a4
4201244d:	065322        	s16i	a2, a3, 12
42012450:	0032c6        	j	4201251f <__sflush_r+0x14f>
42012453:	00          	.byte 00
42012454:	061342        	l16ui	a4, a3, 12
42012457:	0e6427        	bbci	a4, 2, 42012469 <__sflush_r+0x99>
4201245a:	1348      	l32i.n	a4, a3, 4
4201245c:	c0aa40        	sub	a10, a10, a4
4201245f:	d348      	l32i.n	a4, a3, 52
42012461:	448c      	beqz.n	a4, 42012469 <__sflush_r+0x99>
42012463:	102342        	l32i	a4, a3, 64
42012466:	c0aa40        	sub	a10, a10, a4
42012469:	b348      	l32i.n	a4, a3, 44
4201246b:	83b8      	l32i.n	a11, a3, 32
4201246d:	20caa0        	or	a12, a10, a10
42012470:	00a0d2        	movi	a13, 0
42012473:	20a220        	or	a10, a2, a2
42012476:	0004e0        	callx8	a4
42012479:	061382        	l16ui	a8, a3, 12
4201247c:	0c0a66        	bnei	a10, -1, 4201248c <__sflush_r+0xbc>
4201247f:	0248      	l32i.n	a4, a2, 0
42012481:	d91c      	movi.n	a9, 29
42012483:	453947        	bltu	a9, a4, 420124cc <__sflush_r+0xfc>
42012486:	ba0c91        	l32r	a9, 42000cb8 <_stext+0xc98>
42012489:	3fd947        	bbs	a9, a4, 420124cc <__sflush_r+0xfc>
4201248c:	b8fe41        	l32r	a4, 42000884 <_stext+0x864>
4201248f:	104480        	and	a4, a4, a8
42012492:	080c      	movi.n	a8, 0
42012494:	1389      	s32i.n	a8, a3, 4
42012496:	4388      	l32i.n	a8, a3, 16
42012498:	234480        	sext	a4, a4, 15
4201249b:	065342        	s16i	a4, a3, 12
4201249e:	006382        	s32i	a8, a3, 0
420124a1:	0b64c7        	bbci	a4, 12, 420124b0 <__sflush_r+0xe0>
420124a4:	050a66        	bnei	a10, -1, 420124ad <__sflush_r+0xdd>
420124a7:	002242        	l32i	a4, a2, 0
420124aa:	002456        	bnez	a4, 420124b0 <__sflush_r+0xe0>
420124ad:	1563a2        	s32i	a10, a3, 84
420124b0:	d3b8      	l32i.n	a11, a3, 52
420124b2:	0259      	s32i.n	a5, a2, 0
420124b4:	f88b16        	beqz	a11, 42012440 <__sflush_r+0x70>
420124b7:	44c342        	addi	a4, a3, 68
420124ba:	071b47        	beq	a11, a4, 420124c5 <__sflush_r+0xf5>
420124bd:	02ad      	mov.n	a10, a2
420124bf:	b9b081        	l32r	a8, 42000b80 <_stext+0xb60>
420124c2:	0008e0        	callx8	a8
420124c5:	0a0c      	movi.n	a10, 0
420124c7:	d3a9      	s32i.n	a10, a3, 52
420124c9:	001486        	j	4201251f <__sflush_r+0x14f>
420124cc:	024c      	movi.n	a2, 64
420124ce:	208820        	or	a8, a8, a2
420124d1:	065382        	s16i	a8, a3, 12
420124d4:	0011c6        	j	4201251f <__sflush_r+0x14f>
420124d7:	00          	.byte 00
420124d8:	4358      	l32i.n	a5, a3, 16
420124da:	f62516        	beqz	a5, 42012440 <__sflush_r+0x70>
420124dd:	0348      	l32i.n	a4, a3, 0
420124df:	148080        	extui	a8, a8, 0, 2
420124e2:	0359      	s32i.n	a5, a3, 0
420124e4:	090c      	movi.n	a9, 0
420124e6:	c04450        	sub	a4, a4, a5
420124e9:	019897        	bne	a8, a9, 420124ee <__sflush_r+0x11e>
420124ec:	5398      	l32i.n	a9, a3, 20
420124ee:	2399      	s32i.n	a9, a3, 8
420124f0:	000946        	j	42012519 <__sflush_r+0x149>
420124f3:	00          	.byte 00
420124f4:	a388      	l32i.n	a8, a3, 40
420124f6:	83b8      	l32i.n	a11, a3, 32
420124f8:	04dd      	mov.n	a13, a4
420124fa:	05cd      	mov.n	a12, a5
420124fc:	02ad      	mov.n	a10, a2
420124fe:	0008e0        	callx8	a8
42012501:	0f1ae6        	bgei	a10, 1, 42012514 <__sflush_r+0x144>
42012504:	061322        	l16ui	a2, a3, 12
42012507:	044c      	movi.n	a4, 64
42012509:	202240        	or	a2, a2, a4
4201250c:	065322        	s16i	a2, a3, 12
4201250f:	fa7c      	movi.n	a10, -1
42012511:	000286        	j	4201251f <__sflush_r+0x14f>
42012514:	55aa      	add.n	a5, a5, a10
42012516:	c044a0        	sub	a4, a4, a10
42012519:	d714e6        	bgei	a4, 1, 420124f4 <__sflush_r+0x124>
4201251c:	ffc806        	j	42012440 <__sflush_r+0x70>
4201251f:	0a2d      	mov.n	a2, a10
42012521:	f01d      	retw.n
	...

42012524 <_fflush_r>:
42012524:	006136        	entry	a1, 48
42012527:	042382        	l32i	a8, a3, 16
4201252a:	38cc      	bnez.n	a8, 42012531 <_fflush_r+0xd>
4201252c:	020c      	movi.n	a2, 0
4201252e:	001f06        	j	420125ae <_fflush_r+0x8a>
42012531:	b28c      	beqz.n	a2, 42012540 <_fflush_r+0x1c>
42012533:	6288      	l32i.n	a8, a2, 24
42012535:	78cc      	bnez.n	a8, 42012540 <_fflush_r+0x1c>
42012537:	20a220        	or	a10, a2, a2
4201253a:	201110        	or	a1, a1, a1
4201253d:	f74765        	call8	420099b4 <__sinit>
42012540:	b98c81        	l32r	a8, 42000b70 <_stext+0xb50>
42012543:	059387        	bne	a3, a8, 4201254c <_fflush_r+0x28>
42012546:	1238      	l32i.n	a3, a2, 4
42012548:	000546        	j	42012561 <_fflush_r+0x3d>
4201254b:	00          	.byte 00
4201254c:	b98a81        	l32r	a8, 42000b74 <_stext+0xb54>
4201254f:	069387        	bne	a3, a8, 42012559 <_fflush_r+0x35>
42012552:	2238      	l32i.n	a3, a2, 8
42012554:	000246        	j	42012561 <_fflush_r+0x3d>
42012557:	00          	.byte 00
42012558:	00          	.byte 00
42012559:	b98781        	l32r	a8, 42000b78 <_stext+0xb58>
4201255c:	019387        	bne	a3, a8, 42012561 <_fflush_r+0x3d>
4201255f:	3238      	l32i.n	a3, a2, 12
42012561:	069382        	l16si	a8, a3, 12
42012564:	fc4816        	beqz	a8, 4201252c <_fflush_r+0x8>
42012567:	01bd      	mov.n	a11, a1
42012569:	1a0c      	movi.n	a10, 1
4201256b:	201110        	or	a1, a1, a1
4201256e:	059a65        	call8	42017f14 <pthread_setcancelstate>
42012571:	192382        	l32i	a8, a3, 100
42012574:	0ee807        	bbsi	a8, 0, 42012586 <_fflush_r+0x62>
42012577:	061382        	l16ui	a8, a3, 12
4201257a:	08e897        	bbsi	a8, 9, 42012586 <_fflush_r+0x62>
4201257d:	1623a2        	l32i	a10, a3, 88
42012580:	b97381        	l32r	a8, 42000b4c <_stext+0xb2c>
42012583:	0008e0        	callx8	a8
42012586:	02ad      	mov.n	a10, a2
42012588:	03bd      	mov.n	a11, a3
4201258a:	ffe465        	call8	420123d0 <__sflush_r>
4201258d:	192382        	l32i	a8, a3, 100
42012590:	0a2d      	mov.n	a2, a10
42012592:	0ee807        	bbsi	a8, 0, 420125a4 <_fflush_r+0x80>
42012595:	061382        	l16ui	a8, a3, 12
42012598:	08e897        	bbsi	a8, 9, 420125a4 <_fflush_r+0x80>
4201259b:	1623a2        	l32i	a10, a3, 88
4201259e:	b96c81        	l32r	a8, 42000b50 <_stext+0xb30>
420125a1:	0008e0        	callx8	a8
420125a4:	01a8      	l32i.n	a10, a1, 0
420125a6:	01bd      	mov.n	a11, a1
420125a8:	201110        	or	a1, a1, a1
420125ab:	0596a5        	call8	42017f14 <pthread_setcancelstate>
420125ae:	f01d      	retw.n

420125b0 <fflush>:
420125b0:	004136        	entry	a1, 32
420125b3:	22dc      	bnez.n	a2, 420125c9 <fflush+0x19>
420125b5:	b6dd21        	l32r	a2, 4200012c <_stext+0x10c>
420125b8:	b9c1b1        	l32r	a11, 42000cbc <_stext+0xc9c>
420125bb:	0022a2        	l32i	a10, a2, 0
420125be:	201110        	or	a1, a1, a1
420125c1:	05c465        	call8	42018208 <_fwalk_reent>
420125c4:	000306        	j	420125d4 <fflush+0x24>
420125c7:	00          	.byte 00
420125c8:	00          	.byte 00
420125c9:	b95a81        	l32r	a8, 42000b34 <_stext+0xb14>
420125cc:	0008e0        	callx8	a8
420125cf:	02bd      	mov.n	a11, a2
420125d1:	fff525        	call8	42012524 <_fflush_r>
420125d4:	0a2d      	mov.n	a2, a10
420125d6:	f01d      	retw.n

420125d8 <__localeconv_l>:
420125d8:	004136        	entry	a1, 32
420125db:	f0a082        	movi	a8, 240
420125de:	228a      	add.n	a2, a2, a8
420125e0:	f01d      	retw.n
	...

420125e4 <_localeconv_r>:
420125e4:	004136        	entry	a1, 32
420125e7:	b9b621        	l32r	a2, 42000cc0 <_stext+0xca0>
420125ea:	f0a082        	movi	a8, 240
420125ed:	0228      	l32i.n	a2, a2, 0
420125ef:	228a      	add.n	a2, a2, a8
420125f1:	f01d      	retw.n
	...

420125f4 <localeconv>:
420125f4:	004136        	entry	a1, 32
420125f7:	b9b221        	l32r	a2, 42000cc0 <_stext+0xca0>
420125fa:	f0a082        	movi	a8, 240
420125fd:	0228      	l32i.n	a2, a2, 0
420125ff:	228a      	add.n	a2, a2, a8
42012601:	f01d      	retw.n
	...

42012604 <_Balloc>:
42012604:	004136        	entry	a1, 32
42012607:	9248      	l32i.n	a4, a2, 36
42012609:	54ec      	bnez.n	a4, 42012632 <_Balloc+0x2e>
4201260b:	10a0a2        	movi	a10, 16
4201260e:	b68e81        	l32r	a8, 42000048 <_stext+0x28>
42012611:	0008e0        	callx8	a8
42012614:	92a9      	s32i.n	a10, a2, 36
42012616:	facc      	bnez.n	a10, 42012629 <_Balloc+0x25>
42012618:	0acd      	mov.n	a12, a10
4201261a:	b9aad1        	l32r	a13, 42000cc4 <_stext+0xca4>
4201261d:	b9aaa1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012620:	66a0b2        	movi	a11, 102
42012623:	b69881        	l32r	a8, 42000084 <_stext+0x64>
42012626:	0008e0        	callx8	a8
42012629:	1a49      	s32i.n	a4, a10, 4
4201262b:	2a49      	s32i.n	a4, a10, 8
4201262d:	0a49      	s32i.n	a4, a10, 0
4201262f:	036a42        	s32i	a4, a10, 12
42012632:	9248      	l32i.n	a4, a2, 36
42012634:	3488      	l32i.n	a8, a4, 12
42012636:	c88c      	beqz.n	a8, 42012646 <_Balloc+0x42>
42012638:	9248      	l32i.n	a4, a2, 36
4201263a:	3448      	l32i.n	a4, a4, 12
4201263c:	a04340        	addx4	a4, a3, a4
4201263f:	04a8      	l32i.n	a10, a4, 0
42012641:	cadc      	bnez.n	a10, 42012661 <_Balloc+0x5d>
42012643:	000846        	j	42012668 <_Balloc+0x64>
42012646:	1c2c      	movi.n	a12, 33
42012648:	4b0c      	movi.n	a11, 4
4201264a:	02ad      	mov.n	a10, a2
4201264c:	b9a081        	l32r	a8, 42000ccc <_stext+0xcac>
4201264f:	0008e0        	callx8	a8
42012652:	34a9      	s32i.n	a10, a4, 12
42012654:	9248      	l32i.n	a4, a2, 36
42012656:	032442        	l32i	a4, a4, 12
42012659:	fdb456        	bnez	a4, 42012638 <_Balloc+0x34>
4201265c:	0a0c      	movi.n	a10, 0
4201265e:	000a06        	j	4201268a <_Balloc+0x86>
42012661:	0a28      	l32i.n	a2, a10, 0
42012663:	0429      	s32i.n	a2, a4, 0
42012665:	0006c6        	j	42012684 <_Balloc+0x80>
42012668:	1b0c      	movi.n	a11, 1
4201266a:	401300        	ssl	a3
4201266d:	a14b00        	sll	a4, a11
42012670:	c45b      	addi.n	a12, a4, 5
42012672:	11cce0        	slli	a12, a12, 2
42012675:	02ad      	mov.n	a10, a2
42012677:	b99581        	l32r	a8, 42000ccc <_stext+0xcac>
4201267a:	0008e0        	callx8	a8
4201267d:	fdba16        	beqz	a10, 4201265c <_Balloc+0x58>
42012680:	1a39      	s32i.n	a3, a10, 4
42012682:	2a49      	s32i.n	a4, a10, 8
42012684:	020c      	movi.n	a2, 0
42012686:	4a29      	s32i.n	a2, a10, 16
42012688:	3a29      	s32i.n	a2, a10, 12
4201268a:	0a2d      	mov.n	a2, a10
4201268c:	f01d      	retw.n
	...

42012690 <_Bfree>:
42012690:	004136        	entry	a1, 32
42012693:	9248      	l32i.n	a4, a2, 36
42012695:	44ec      	bnez.n	a4, 420126bd <_Bfree+0x2d>
42012697:	10a0a2        	movi	a10, 16
4201269a:	b66b81        	l32r	a8, 42000048 <_stext+0x28>
4201269d:	0008e0        	callx8	a8
420126a0:	92a9      	s32i.n	a10, a2, 36
420126a2:	facc      	bnez.n	a10, 420126b5 <_Bfree+0x25>
420126a4:	0acd      	mov.n	a12, a10
420126a6:	b987d1        	l32r	a13, 42000cc4 <_stext+0xca4>
420126a9:	b987a1        	l32r	a10, 42000cc8 <_stext+0xca8>
420126ac:	8aa0b2        	movi	a11, 138
420126af:	b67581        	l32r	a8, 42000084 <_stext+0x64>
420126b2:	0008e0        	callx8	a8
420126b5:	1a49      	s32i.n	a4, a10, 4
420126b7:	2a49      	s32i.n	a4, a10, 8
420126b9:	0a49      	s32i.n	a4, a10, 0
420126bb:	3a49      	s32i.n	a4, a10, 12
420126bd:	d38c      	beqz.n	a3, 420126ce <_Bfree+0x3e>
420126bf:	9228      	l32i.n	a2, a2, 36
420126c1:	1348      	l32i.n	a4, a3, 4
420126c3:	3228      	l32i.n	a2, a2, 12
420126c5:	a04420        	addx4	a4, a4, a2
420126c8:	0428      	l32i.n	a2, a4, 0
420126ca:	0329      	s32i.n	a2, a3, 0
420126cc:	0439      	s32i.n	a3, a4, 0
420126ce:	f01d      	retw.n

420126d0 <__multadd>:
420126d0:	004136        	entry	a1, 32
420126d3:	4368      	l32i.n	a6, a3, 16
420126d5:	1a0c      	movi.n	a10, 1
420126d7:	14c3b2        	addi	a11, a3, 20
420126da:	53aa60        	max	a10, a10, a6
420126dd:	238a76        	loop	a10, 42012704 <__multadd+0x34>
420126e0:	0b88      	l32i.n	a8, a11, 0
420126e2:	f49080        	extui	a9, a8, 0, 16
420126e5:	829940        	mull	a9, a9, a4
420126e8:	f58080        	extui	a8, a8, 16, 16
420126eb:	995a      	add.n	a9, a9, a5
420126ed:	828840        	mull	a8, a8, a4
420126f0:	f55090        	extui	a5, a9, 16, 16
420126f3:	885a      	add.n	a8, a8, a5
420126f5:	f55080        	extui	a5, a8, 16, 16
420126f8:	f49090        	extui	a9, a9, 0, 16
420126fb:	118800        	slli	a8, a8, 16
420126fe:	889a      	add.n	a8, a8, a9
42012700:	0b89      	s32i.n	a8, a11, 0
42012702:	bb4b      	addi.n	a11, a11, 4
42012704:	049516        	beqz	a5, 42012751 <__multadd+0x81>
42012707:	2348      	l32i.n	a4, a3, 8
42012709:	3b2647        	blt	a6, a4, 42012748 <__multadd+0x78>
4201270c:	13b8      	l32i.n	a11, a3, 4
4201270e:	02ad      	mov.n	a10, a2
42012710:	bb1b      	addi.n	a11, a11, 1
42012712:	ffef25        	call8	42012604 <_Balloc>
42012715:	0a4d      	mov.n	a4, a10
42012717:	facc      	bnez.n	a10, 4201272a <__multadd+0x5a>
42012719:	0acd      	mov.n	a12, a10
4201271b:	b96dd1        	l32r	a13, 42000cd0 <_stext+0xcb0>
4201271e:	b96aa1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012721:	b5a0b2        	movi	a11, 181
42012724:	b65881        	l32r	a8, 42000084 <_stext+0x64>
42012727:	0008e0        	callx8	a8
4201272a:	43c8      	l32i.n	a12, a3, 16
4201272c:	0cc3b2        	addi	a11, a3, 12
4201272f:	02ccc2        	addi	a12, a12, 2
42012732:	11cce0        	slli	a12, a12, 2
42012735:	0ccaa2        	addi	a10, a10, 12
42012738:	b6a581        	l32r	a8, 420001cc <_stext+0x1ac>
4201273b:	0008e0        	callx8	a8
4201273e:	03bd      	mov.n	a11, a3
42012740:	20a220        	or	a10, a2, a2
42012743:	fff4e5        	call8	42012690 <_Bfree>
42012746:	043d      	mov.n	a3, a4
42012748:	a02630        	addx4	a2, a6, a3
4201274b:	5259      	s32i.n	a5, a2, 20
4201274d:	661b      	addi.n	a6, a6, 1
4201274f:	4369      	s32i.n	a6, a3, 16
42012751:	032d      	mov.n	a2, a3
42012753:	f01d      	retw.n
42012755:	000000        	ill

42012758 <__s2b>:
42012758:	006136        	entry	a1, 48
4201275b:	b95e81        	l32r	a8, 42000cd4 <_stext+0xcb4>
4201275e:	958b      	addi.n	a9, a5, 8
42012760:	b28980        	mulsh	a8, a9, a8
42012763:	319f90        	srai	a9, a9, 31
42012766:	218180        	srai	a8, a8, 1
42012769:	c08890        	sub	a8, a8, a9
4201276c:	0b0c      	movi.n	a11, 0
4201276e:	190c      	movi.n	a9, 1
42012770:	000186        	j	4201277a <__s2b+0x22>
42012773:	00          	.byte 00
42012774:	00          	.byte 00
42012775:	00          	.byte 00
42012776:	999a      	add.n	a9, a9, a9
42012778:	bb1b      	addi.n	a11, a11, 1
4201277a:	f82987        	blt	a9, a8, 42012776 <__s2b+0x1e>
4201277d:	02ad      	mov.n	a10, a2
4201277f:	ffe865        	call8	42012604 <_Balloc>
42012782:	facc      	bnez.n	a10, 42012795 <__s2b+0x3d>
42012784:	0acd      	mov.n	a12, a10
42012786:	b952d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012789:	b94fa1        	l32r	a10, 42000cc8 <_stext+0xca8>
4201278c:	cea0b2        	movi	a11, 206
4201278f:	b63d81        	l32r	a8, 42000084 <_stext+0x64>
42012792:	0008e0        	callx8	a8
42012795:	5a69      	s32i.n	a6, a10, 20
42012797:	160c      	movi.n	a6, 1
42012799:	4a69      	s32i.n	a6, a10, 16
4201279b:	960c      	movi.n	a6, 9
4201279d:	28a647        	bge	a6, a4, 420127c9 <__s2b+0x71>
420127a0:	736a      	add.n	a7, a3, a6
420127a2:	076d      	mov.n	a6, a7
420127a4:	334a      	add.n	a3, a3, a4
420127a6:	0aa082        	movi	a8, 10
420127a9:	0006d2        	l8ui	a13, a6, 0
420127ac:	08cd      	mov.n	a12, a8
420127ae:	0abd      	mov.n	a11, a10
420127b0:	d0cdd2        	addi	a13, a13, -48
420127b3:	02ad      	mov.n	a10, a2
420127b5:	0189      	s32i.n	a8, a1, 0
420127b7:	661b      	addi.n	a6, a6, 1
420127b9:	fff165        	call8	420126d0 <__multadd>
420127bc:	0188      	l32i.n	a8, a1, 0
420127be:	e79637        	bne	a6, a3, 420127a9 <__s2b+0x51>
420127c1:	f8c432        	addi	a3, a4, -8
420127c4:	773a      	add.n	a7, a7, a3
420127c6:	0000c6        	j	420127cd <__s2b+0x75>
420127c9:	73ab      	addi.n	a7, a3, 10
420127cb:	064d      	mov.n	a4, a6
420127cd:	043d      	mov.n	a3, a4
420127cf:	a80c      	movi.n	a8, 10
420127d1:	000646        	j	420127ee <__s2b+0x96>
420127d4:	c06340        	sub	a6, a3, a4
420127d7:	676a      	add.n	a6, a7, a6
420127d9:	0006d2        	l8ui	a13, a6, 0
420127dc:	08cd      	mov.n	a12, a8
420127de:	0abd      	mov.n	a11, a10
420127e0:	d0cdd2        	addi	a13, a13, -48
420127e3:	02ad      	mov.n	a10, a2
420127e5:	0189      	s32i.n	a8, a1, 0
420127e7:	ffeea5        	call8	420126d0 <__multadd>
420127ea:	0188      	l32i.n	a8, a1, 0
420127ec:	331b      	addi.n	a3, a3, 1
420127ee:	e22357        	blt	a3, a5, 420127d4 <__s2b+0x7c>
420127f1:	0a2d      	mov.n	a2, a10
420127f3:	f01d      	retw.n
420127f5:	000000        	ill

420127f8 <__hi0bits>:
420127f8:	004136        	entry	a1, 32
420127fb:	f97c      	movi.n	a9, -1
420127fd:	028d      	mov.n	a8, a2
420127ff:	119900        	slli	a9, a9, 16
42012802:	020c      	movi.n	a2, 0
42012804:	048897        	bany	a8, a9, 4201280c <__hi0bits+0x14>
42012807:	118800        	slli	a8, a8, 16
4201280a:	021c      	movi.n	a2, 16
4201280c:	f97c      	movi.n	a9, -1
4201280e:	019980        	slli	a9, a9, 24
42012811:	048897        	bany	a8, a9, 42012819 <__hi0bits+0x21>
42012814:	228b      	addi.n	a2, a2, 8
42012816:	118880        	slli	a8, a8, 8
42012819:	f97c      	movi.n	a9, -1
4201281b:	019940        	slli	a9, a9, 28
4201281e:	048897        	bany	a8, a9, 42012826 <__hi0bits+0x2e>
42012821:	224b      	addi.n	a2, a2, 4
42012823:	1188c0        	slli	a8, a8, 4
42012826:	f97c      	movi.n	a9, -1
42012828:	019920        	slli	a9, a9, 30
4201282b:	058897        	bany	a8, a9, 42012834 <__hi0bits+0x3c>
4201282e:	02c222        	addi	a2, a2, 2
42012831:	1188e0        	slli	a8, a8, 2
42012834:	009896        	bltz	a8, 42012841 <__hi0bits+0x49>
42012837:	221b      	addi.n	a2, a2, 1
42012839:	058e80        	extui	a8, a8, 30, 1
4201283c:	092c      	movi.n	a9, 32
4201283e:	832980        	moveqz	a2, a9, a8
42012841:	f01d      	retw.n
	...

42012844 <__lo0bits>:
42012844:	004136        	entry	a1, 32
42012847:	0288      	l32i.n	a8, a2, 0
42012849:	02ad      	mov.n	a10, a2
4201284b:	249080        	extui	a9, a8, 0, 3
4201284e:	e99c      	beqz.n	a9, 42012870 <__lo0bits+0x2c>
42012850:	020c      	movi.n	a2, 0
42012852:	5cd827        	bbs	a8, a2, 420128b2 <__lo0bits+0x6e>
42012855:	290c      	movi.n	a9, 2
42012857:	090897        	bnone	a8, a9, 42012864 <__lo0bits+0x20>
4201285a:	418180        	srli	a8, a8, 1
4201285d:	0a89      	s32i.n	a8, a10, 0
4201285f:	120c      	movi.n	a2, 1
42012861:	001346        	j	420128b2 <__lo0bits+0x6e>
42012864:	418280        	srli	a8, a8, 2
42012867:	0a89      	s32i.n	a8, a10, 0
42012869:	092d      	mov.n	a2, a9
4201286b:	0010c6        	j	420128b2 <__lo0bits+0x6e>
4201286e:	00          	.byte 00
4201286f:	00          	.byte 00
42012870:	f4b080        	extui	a11, a8, 0, 16
42012873:	092d      	mov.n	a2, a9
42012875:	3bcc      	bnez.n	a11, 4201287c <__lo0bits+0x38>
42012877:	f58080        	extui	a8, a8, 16, 16
4201287a:	021c      	movi.n	a2, 16
4201287c:	749080        	extui	a9, a8, 0, 8
4201287f:	005956        	bnez	a9, 42012888 <__lo0bits+0x44>
42012882:	08c222        	addi	a2, a2, 8
42012885:	418880        	srli	a8, a8, 8
42012888:	349080        	extui	a9, a8, 0, 4
4201288b:	005956        	bnez	a9, 42012894 <__lo0bits+0x50>
4201288e:	04c222        	addi	a2, a2, 4
42012891:	418480        	srli	a8, a8, 4
42012894:	149080        	extui	a9, a8, 0, 2
42012897:	005956        	bnez	a9, 420128a0 <__lo0bits+0x5c>
4201289a:	02c222        	addi	a2, a2, 2
4201289d:	418280        	srli	a8, a8, 2
420128a0:	06e807        	bbsi	a8, 0, 420128aa <__lo0bits+0x66>
420128a3:	418180        	srli	a8, a8, 1
420128a6:	221b      	addi.n	a2, a2, 1
420128a8:	488c      	beqz.n	a8, 420128b0 <__lo0bits+0x6c>
420128aa:	0a89      	s32i.n	a8, a10, 0
420128ac:	000086        	j	420128b2 <__lo0bits+0x6e>
420128af:	00          	.byte 00
420128b0:	022c      	movi.n	a2, 32
420128b2:	f01d      	retw.n

420128b4 <__i2b>:
420128b4:	004136        	entry	a1, 32
420128b7:	1b0c      	movi.n	a11, 1
420128b9:	02ad      	mov.n	a10, a2
420128bb:	ffd4a5        	call8	42012604 <_Balloc>
420128be:	facc      	bnez.n	a10, 420128d1 <__i2b+0x1d>
420128c0:	0acd      	mov.n	a12, a10
420128c2:	b903d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
420128c5:	b900a1        	l32r	a10, 42000cc8 <_stext+0xca8>
420128c8:	40a1b2        	movi	a11, 0x140
420128cb:	b5ee81        	l32r	a8, 42000084 <_stext+0x64>
420128ce:	0008e0        	callx8	a8
420128d1:	180c      	movi.n	a8, 1
420128d3:	5a39      	s32i.n	a3, a10, 20
420128d5:	4a89      	s32i.n	a8, a10, 16
420128d7:	0a2d      	mov.n	a2, a10
420128d9:	f01d      	retw.n
	...

420128dc <__multiply>:
420128dc:	008136        	entry	a1, 64
420128df:	4368      	l32i.n	a6, a3, 16
420128e1:	4458      	l32i.n	a5, a4, 16
420128e3:	06a657        	bge	a6, a5, 420128ed <__multiply+0x11>
420128e6:	035d      	mov.n	a5, a3
420128e8:	043d      	mov.n	a3, a4
420128ea:	204550        	or	a4, a5, a5
420128ed:	4378      	l32i.n	a7, a3, 16
420128ef:	4468      	l32i.n	a6, a4, 16
420128f1:	2388      	l32i.n	a8, a3, 8
420128f3:	576a      	add.n	a5, a7, a6
420128f5:	13b8      	l32i.n	a11, a3, 4
420128f7:	01a857        	bge	a8, a5, 420128fc <__multiply+0x20>
420128fa:	bb1b      	addi.n	a11, a11, 1
420128fc:	02ad      	mov.n	a10, a2
420128fe:	ffd065        	call8	42012604 <_Balloc>
42012901:	facc      	bnez.n	a10, 42012914 <__multiply+0x38>
42012903:	0acd      	mov.n	a12, a10
42012905:	b8f2d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012908:	b8f0a1        	l32r	a10, 42000cc8 <_stext+0xca8>
4201290b:	5da1b2        	movi	a11, 0x15d
4201290e:	b5dd81        	l32r	a8, 42000084 <_stext+0x64>
42012911:	0008e0        	callx8	a8
42012914:	14cae2        	addi	a14, a10, 20
42012917:	a025e0        	addx4	a2, a5, a14
4201291a:	0129      	s32i.n	a2, a1, 0
4201291c:	080c      	movi.n	a8, 0
4201291e:	0e2d      	mov.n	a2, a14
42012920:	000106        	j	42012928 <__multiply+0x4c>
42012923:	00          	.byte 00
42012924:	0289      	s32i.n	a8, a2, 0
42012926:	224b      	addi.n	a2, a2, 4
42012928:	0198      	l32i.n	a9, a1, 0
4201292a:	f63297        	bltu	a2, a9, 42012924 <__multiply+0x48>
4201292d:	14c442        	addi	a4, a4, 20
42012930:	a06640        	addx4	a6, a6, a4
42012933:	14c3b2        	addi	a11, a3, 20
42012936:	4169      	s32i.n	a6, a1, 16
42012938:	460c      	movi.n	a6, 4
4201293a:	11b9      	s32i.n	a11, a1, 4
4201293c:	a097b0        	addx4	a9, a7, a11
4201293f:	15c322        	addi	a2, a3, 21
42012942:	3169      	s32i.n	a6, a1, 12
42012944:	02b927        	bgeu	a9, a2, 4201294a <__multiply+0x6e>
42012947:	0039c6        	j	42012a32 <__multiply+0x156>
4201294a:	c02930        	sub	a2, a9, a3
4201294d:	ebc222        	addi	a2, a2, -21
42012950:	412220        	srli	a2, a2, 2
42012953:	221b      	addi.n	a2, a2, 1
42012955:	1122e0        	slli	a2, a2, 2
42012958:	3129      	s32i.n	a2, a1, 12
4201295a:	003506        	j	42012a32 <__multiply+0x156>
4201295d:	001462        	l16ui	a6, a4, 0
42012960:	068616        	beqz	a6, 420129cc <__multiply+0xf0>
42012963:	1188      	l32i.n	a8, a1, 4
42012965:	11b8      	l32i.n	a11, a1, 4
42012967:	2189      	s32i.n	a8, a1, 8
42012969:	f87c      	movi.n	a8, -1
4201296b:	308b80        	xor	a8, a11, a8
4201296e:	898a      	add.n	a8, a9, a8
42012970:	418280        	srli	a8, a8, 2
42012973:	7b4b      	addi.n	a7, a11, 4
42012975:	b93b      	addi.n	a11, a9, 3
42012977:	20cee0        	or	a12, a14, a14
4201297a:	00a022        	movi	a2, 0
4201297d:	01c882        	addi	a8, a8, 1
42012980:	023b77        	bltu	a11, a7, 42012986 <__multiply+0xaa>
42012983:	019927        	bne	a9, a2, 42012988 <__multiply+0xac>
42012986:	180c      	movi.n	a8, 1
42012988:	f03d      	nop.n
4201298a:	388876        	loop	a8, 420129c6 <__multiply+0xea>
4201298d:	21b8      	l32i.n	a11, a1, 8
4201298f:	0cd8      	l32i.n	a13, a12, 0
42012991:	0bf8      	l32i.n	a15, a11, 0
42012993:	f470d0        	extui	a7, a13, 0, 16
42012996:	f4b0f0        	extui	a11, a15, 0, 16
42012999:	82bb60        	mull	a11, a11, a6
4201299c:	f5f0f0        	extui	a15, a15, 16, 16
4201299f:	bb7a      	add.n	a11, a11, a7
420129a1:	82ff60        	mull	a15, a15, a6
420129a4:	bb2a      	add.n	a11, a11, a2
420129a6:	f5d0d0        	extui	a13, a13, 16, 16
420129a9:	2128      	l32i.n	a2, a1, 8
420129ab:	f570b0        	extui	a7, a11, 16, 16
420129ae:	dfda      	add.n	a13, a15, a13
420129b0:	224b      	addi.n	a2, a2, 4
420129b2:	7d7a      	add.n	a7, a13, a7
420129b4:	2129      	s32i.n	a2, a1, 8
420129b6:	f4b0b0        	extui	a11, a11, 0, 16
420129b9:	f52070        	extui	a2, a7, 16, 16
420129bc:	117700        	slli	a7, a7, 16
420129bf:	2077b0        	or	a7, a7, a11
420129c2:	0c79      	s32i.n	a7, a12, 0
420129c4:	cc4b      	addi.n	a12, a12, 4
420129c6:	3188      	l32i.n	a8, a1, 12
420129c8:	6e8a      	add.n	a6, a14, a8
420129ca:	0629      	s32i.n	a2, a6, 0
420129cc:	011422        	l16ui	a2, a4, 2
420129cf:	05b216        	beqz	a2, 42012a2e <__multiply+0x152>
420129d2:	14c3f2        	addi	a15, a3, 20
420129d5:	f87c      	movi.n	a8, -1
420129d7:	3088f0        	xor	a8, a8, a15
420129da:	898a      	add.n	a8, a9, a8
420129dc:	418280        	srli	a8, a8, 2
420129df:	18c3d2        	addi	a13, a3, 24
420129e2:	793b      	addi.n	a7, a9, 3
420129e4:	0eb8      	l32i.n	a11, a14, 0
420129e6:	0ecd      	mov.n	a12, a14
420129e8:	060c      	movi.n	a6, 0
420129ea:	881b      	addi.n	a8, a8, 1
420129ec:	0237d7        	bltu	a7, a13, 420129f2 <__multiply+0x116>
420129ef:	019967        	bne	a9, a6, 420129f4 <__multiply+0x118>
420129f2:	180c      	movi.n	a8, 1
420129f4:	f03d      	nop.n
420129f6:	2e8876        	loop	a8, 42012a28 <__multiply+0x14c>
420129f9:	001fd2        	l16ui	a13, a15, 0
420129fc:	011c72        	l16ui	a7, a12, 2
420129ff:	82dd20        	mull	a13, a13, a2
42012a02:	f4b0b0        	extui	a11, a11, 0, 16
42012a05:	dd7a      	add.n	a13, a13, a7
42012a07:	dd6a      	add.n	a13, a13, a6
42012a09:	116d00        	slli	a6, a13, 16
42012a0c:	2066b0        	or	a6, a6, a11
42012a0f:	0c69      	s32i.n	a6, a12, 0
42012a11:	011f62        	l16ui	a6, a15, 2
42012a14:	021cb2        	l16ui	a11, a12, 4
42012a17:	826620        	mull	a6, a6, a2
42012a1a:	f5d0d0        	extui	a13, a13, 16, 16
42012a1d:	b6ba      	add.n	a11, a6, a11
42012a1f:	bbda      	add.n	a11, a11, a13
42012a21:	f560b0        	extui	a6, a11, 16, 16
42012a24:	ff4b      	addi.n	a15, a15, 4
42012a26:	cc4b      	addi.n	a12, a12, 4
42012a28:	3168      	l32i.n	a6, a1, 12
42012a2a:	2e6a      	add.n	a2, a14, a6
42012a2c:	02b9      	s32i.n	a11, a2, 0
42012a2e:	444b      	addi.n	a4, a4, 4
42012a30:	ee4b      	addi.n	a14, a14, 4
42012a32:	4188      	l32i.n	a8, a1, 16
42012a34:	02b487        	bgeu	a4, a8, 42012a3a <__multiply+0x15e>
42012a37:	ffc886        	j	4201295d <__multiply+0x81>
42012a3a:	000046        	j	42012a3f <__multiply+0x163>
42012a3d:	550b      	addi.n	a5, a5, -1
42012a3f:	0b15a6        	blti	a5, 1, 42012a4e <__multiply+0x172>
42012a42:	0198      	l32i.n	a9, a1, 0
42012a44:	fcc992        	addi	a9, a9, -4
42012a47:	0928      	l32i.n	a2, a9, 0
42012a49:	0199      	s32i.n	a9, a1, 0
42012a4b:	fee216        	beqz	a2, 42012a3d <__multiply+0x161>
42012a4e:	4a59      	s32i.n	a5, a10, 16
42012a50:	0a2d      	mov.n	a2, a10
42012a52:	f01d      	retw.n

42012a54 <__pow5mult>:
42012a54:	004136        	entry	a1, 32
42012a57:	145040        	extui	a5, a4, 0, 2
42012a5a:	659c      	beqz.n	a5, 42012a74 <__pow5mult+0x20>
42012a5c:	b89f61        	l32r	a6, 42000cd8 <_stext+0xcb8>
42012a5f:	550b      	addi.n	a5, a5, -1
42012a61:	a05560        	addx4	a5, a5, a6
42012a64:	05c8      	l32i.n	a12, a5, 0
42012a66:	20b330        	or	a11, a3, a3
42012a69:	00a0d2        	movi	a13, 0
42012a6c:	20a220        	or	a10, a2, a2
42012a6f:	ffc625        	call8	420126d0 <__multadd>
42012a72:	0a3d      	mov.n	a3, a10
42012a74:	214240        	srai	a4, a4, 2
42012a77:	07c416        	beqz	a4, 42012af7 <__pow5mult+0xa3>
42012a7a:	9258      	l32i.n	a5, a2, 36
42012a7c:	45ec      	bnez.n	a5, 42012aa4 <__pow5mult+0x50>
42012a7e:	0a1c      	movi.n	a10, 16
42012a80:	b57281        	l32r	a8, 42000048 <_stext+0x28>
42012a83:	0008e0        	callx8	a8
42012a86:	92a9      	s32i.n	a10, a2, 36
42012a88:	010a56        	bnez	a10, 42012a9c <__pow5mult+0x48>
42012a8b:	0acd      	mov.n	a12, a10
42012a8d:	b88dd1        	l32r	a13, 42000cc4 <_stext+0xca4>
42012a90:	b88ea1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012a93:	aea1b2        	movi	a11, 0x1ae
42012a96:	b57b81        	l32r	a8, 42000084 <_stext+0x64>
42012a99:	0008e0        	callx8	a8
42012a9c:	1a59      	s32i.n	a5, a10, 4
42012a9e:	2a59      	s32i.n	a5, a10, 8
42012aa0:	0a59      	s32i.n	a5, a10, 0
42012aa2:	3a59      	s32i.n	a5, a10, 12
42012aa4:	9268      	l32i.n	a6, a2, 36
42012aa6:	2658      	l32i.n	a5, a6, 8
42012aa8:	e5cc      	bnez.n	a5, 42012aba <__pow5mult+0x66>
42012aaa:	71a2b2        	movi	a11, 0x271
42012aad:	02ad      	mov.n	a10, a2
42012aaf:	ffe065        	call8	420128b4 <__i2b>
42012ab2:	26a9      	s32i.n	a10, a6, 8
42012ab4:	060c      	movi.n	a6, 0
42012ab6:	0a5d      	mov.n	a5, a10
42012ab8:	0a69      	s32i.n	a6, a10, 0
42012aba:	060c      	movi.n	a6, 0
42012abc:	000106        	j	42012ac4 <__pow5mult+0x70>
42012abf:	00          	.byte 00
42012ac0:	00          	.byte 00
42012ac1:	00          	.byte 00
42012ac2:	0a5d      	mov.n	a5, a10
42012ac4:	156407        	bbci	a4, 0, 42012add <__pow5mult+0x89>
42012ac7:	03bd      	mov.n	a11, a3
42012ac9:	05cd      	mov.n	a12, a5
42012acb:	02ad      	mov.n	a10, a2
42012acd:	ffe0e5        	call8	420128dc <__multiply>
42012ad0:	0a7d      	mov.n	a7, a10
42012ad2:	03bd      	mov.n	a11, a3
42012ad4:	20a220        	or	a10, a2, a2
42012ad7:	ffbba5        	call8	42012690 <_Bfree>
42012ada:	203770        	or	a3, a7, a7
42012add:	214140        	srai	a4, a4, 1
42012ae0:	349c      	beqz.n	a4, 42012af7 <__pow5mult+0xa3>
42012ae2:	05a8      	l32i.n	a10, a5, 0
42012ae4:	fdaa56        	bnez	a10, 42012ac2 <__pow5mult+0x6e>
42012ae7:	05cd      	mov.n	a12, a5
42012ae9:	05bd      	mov.n	a11, a5
42012aeb:	02ad      	mov.n	a10, a2
42012aed:	ffdee5        	call8	420128dc <__multiply>
42012af0:	05a9      	s32i.n	a10, a5, 0
42012af2:	0a69      	s32i.n	a6, a10, 0
42012af4:	fff286        	j	42012ac2 <__pow5mult+0x6e>
42012af7:	032d      	mov.n	a2, a3
42012af9:	f01d      	retw.n
	...

42012afc <__lshift>:
42012afc:	006136        	entry	a1, 48
42012aff:	4378      	l32i.n	a7, a3, 16
42012b01:	04cd      	mov.n	a12, a4
42012b03:	214540        	srai	a4, a4, 5
42012b06:	747a      	add.n	a7, a4, a7
42012b08:	026d      	mov.n	a6, a2
42012b0a:	13b8      	l32i.n	a11, a3, 4
42012b0c:	2328      	l32i.n	a2, a3, 8
42012b0e:	571b      	addi.n	a5, a7, 1
42012b10:	000106        	j	42012b18 <__lshift+0x1c>
42012b13:	00          	.byte 00
42012b14:	bb1b      	addi.n	a11, a11, 1
42012b16:	222a      	add.n	a2, a2, a2
42012b18:	f82257        	blt	a2, a5, 42012b14 <__lshift+0x18>
42012b1b:	06ad      	mov.n	a10, a6
42012b1d:	11c9      	s32i.n	a12, a1, 4
42012b1f:	ffae65        	call8	42012604 <_Balloc>
42012b22:	0a2d      	mov.n	a2, a10
42012b24:	080c      	movi.n	a8, 0
42012b26:	14caa2        	addi	a10, a10, 20
42012b29:	11c8      	l32i.n	a12, a1, 4
42012b2b:	209aa0        	or	a9, a10, a10
42012b2e:	20b880        	or	a11, a8, a8
42012b31:	189287        	bne	a2, a8, 42012b4d <__lshift+0x51>
42012b34:	b867d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012b37:	b864a1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012b3a:	20c220        	or	a12, a2, a2
42012b3d:	d9a1b2        	movi	a11, 0x1d9
42012b40:	b55181        	l32r	a8, 42000084 <_stext+0x64>
42012b43:	0008e0        	callx8	a8
42012b46:	09b9      	s32i.n	a11, a9, 0
42012b48:	881b      	addi.n	a8, a8, 1
42012b4a:	04c992        	addi	a9, a9, 4
42012b4d:	f52847        	blt	a8, a4, 42012b46 <__lshift+0x4a>
42012b50:	5394b0        	max	a9, a4, a11
42012b53:	43b8      	l32i.n	a11, a3, 16
42012b55:	14c382        	addi	a8, a3, 20
42012b58:	4440c0        	extui	a4, a12, 0, 5
42012b5b:	a099a0        	addx4	a9, a9, a10
42012b5e:	a0bb80        	addx4	a11, a11, a8
42012b61:	065416        	beqz	a4, 42012bca <__lshift+0xce>
42012b64:	0a2c      	movi.n	a10, 32
42012b66:	c0aa40        	sub	a10, a10, a4
42012b69:	01a9      	s32i.n	a10, a1, 0
42012b6b:	fa7c      	movi.n	a10, -1
42012b6d:	30a8a0        	xor	a10, a8, a10
42012b70:	abaa      	add.n	a10, a11, a10
42012b72:	41a2a0        	srli	a10, a10, 2
42012b75:	18c3e2        	addi	a14, a3, 24
42012b78:	fb3b      	addi.n	a15, a11, 3
42012b7a:	09cd      	mov.n	a12, a9
42012b7c:	0d0c      	movi.n	a13, 0
42012b7e:	aa1b      	addi.n	a10, a10, 1
42012b80:	023fe7        	bltu	a15, a14, 42012b86 <__lshift+0x8a>
42012b83:	019bd7        	bne	a11, a13, 42012b88 <__lshift+0x8c>
42012b86:	1a0c      	movi.n	a10, 1
42012b88:	f03d      	nop.n
42012b8a:	1a8a76        	loop	a10, 42012ba8 <__lshift+0xac>
42012b8d:	08e8      	l32i.n	a14, a8, 0
42012b8f:	401400        	ssl	a4
42012b92:	a1ee00        	sll	a14, a14
42012b95:	20ded0        	or	a13, a14, a13
42012b98:	0cd9      	s32i.n	a13, a12, 0
42012b9a:	08d8      	l32i.n	a13, a8, 0
42012b9c:	01e8      	l32i.n	a14, a1, 0
42012b9e:	884b      	addi.n	a8, a8, 4
42012ba0:	400e00        	ssr	a14
42012ba3:	91d0d0        	srl	a13, a13
42012ba6:	cc4b      	addi.n	a12, a12, 4
42012ba8:	15c382        	addi	a8, a3, 21
42012bab:	440c      	movi.n	a4, 4
42012bad:	0d3b87        	bltu	a11, a8, 42012bbe <__lshift+0xc2>
42012bb0:	c04b30        	sub	a4, a11, a3
42012bb3:	ebc442        	addi	a4, a4, -21
42012bb6:	414240        	srli	a4, a4, 2
42012bb9:	441b      	addi.n	a4, a4, 1
42012bbb:	1144e0        	slli	a4, a4, 2
42012bbe:	494a      	add.n	a4, a9, a4
42012bc0:	04d9      	s32i.n	a13, a4, 0
42012bc2:	bdac      	beqz.n	a13, 42012bf1 <__lshift+0xf5>
42012bc4:	572b      	addi.n	a5, a7, 2
42012bc6:	0009c6        	j	42012bf1 <__lshift+0xf5>
42012bc9:	00          	.byte 00
42012bca:	f47c      	movi.n	a4, -1
42012bcc:	304840        	xor	a4, a8, a4
42012bcf:	4b4a      	add.n	a4, a11, a4
42012bd1:	414240        	srli	a4, a4, 2
42012bd4:	18c372        	addi	a7, a3, 24
42012bd7:	ab3b      	addi.n	a10, a11, 3
42012bd9:	441b      	addi.n	a4, a4, 1
42012bdb:	013a77        	bltu	a10, a7, 42012be0 <__lshift+0xe4>
42012bde:	0bcc      	bnez.n	a11, 42012be2 <__lshift+0xe6>
42012be0:	140c      	movi.n	a4, 1
42012be2:	0878      	l32i.n	a7, a8, 0
42012be4:	884b      	addi.n	a8, a8, 4
42012be6:	0979      	s32i.n	a7, a9, 0
42012be8:	04c992        	addi	a9, a9, 4
42012beb:	ffc442        	addi	a4, a4, -1
42012bee:	ff0456        	bnez	a4, 42012be2 <__lshift+0xe6>
42012bf1:	550b      	addi.n	a5, a5, -1
42012bf3:	4259      	s32i.n	a5, a2, 16
42012bf5:	03bd      	mov.n	a11, a3
42012bf7:	06ad      	mov.n	a10, a6
42012bf9:	ffa965        	call8	42012690 <_Bfree>
42012bfc:	f01d      	retw.n
	...

42012c00 <__mcmp>:
42012c00:	004136        	entry	a1, 32
42012c03:	42a8      	l32i.n	a10, a2, 16
42012c05:	4388      	l32i.n	a8, a3, 16
42012c07:	209220        	or	a9, a2, a2
42012c0a:	c02a80        	sub	a2, a10, a8
42012c0d:	279a87        	bne	a10, a8, 42012c38 <__mcmp+0x38>
42012c10:	14c992        	addi	a9, a9, 20
42012c13:	14c332        	addi	a3, a3, 20
42012c16:	a0a890        	addx4	a10, a8, a9
42012c19:	a08830        	addx4	a8, a8, a3
42012c1c:	fccaa2        	addi	a10, a10, -4
42012c1f:	fcc882        	addi	a8, a8, -4
42012c22:	0ab8      	l32i.n	a11, a10, 0
42012c24:	0838      	l32i.n	a3, a8, 0
42012c26:	0b1b37        	beq	a11, a3, 42012c35 <__mcmp+0x35>
42012c29:	f27c      	movi.n	a2, -1
42012c2b:	093b37        	bltu	a11, a3, 42012c38 <__mcmp+0x38>
42012c2e:	120c      	movi.n	a2, 1
42012c30:	000106        	j	42012c38 <__mcmp+0x38>
42012c33:	00          	.byte 00
42012c34:	00          	.byte 00
42012c35:	e339a7        	bltu	a9, a10, 42012c1c <__mcmp+0x1c>
42012c38:	f01d      	retw.n
	...

42012c3c <__mdiff>:
42012c3c:	004136        	entry	a1, 32
42012c3f:	04bd      	mov.n	a11, a4
42012c41:	03ad      	mov.n	a10, a3
42012c43:	fffbe5        	call8	42012c00 <__mcmp>
42012c46:	0a5d      	mov.n	a5, a10
42012c48:	dadc      	bnez.n	a10, 42012c69 <__mdiff+0x2d>
42012c4a:	0abd      	mov.n	a11, a10
42012c4c:	02ad      	mov.n	a10, a2
42012c4e:	ff9b65        	call8	42012604 <_Balloc>
42012c51:	9acc      	bnez.n	a10, 42012c5e <__mdiff+0x22>
42012c53:	b81fd1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012c56:	0acd      	mov.n	a12, a10
42012c58:	32a2b2        	movi	a11, 0x232
42012c5b:	000a86        	j	42012c89 <__mdiff+0x4d>
42012c5e:	120c      	movi.n	a2, 1
42012c60:	4a29      	s32i.n	a2, a10, 16
42012c62:	5a59      	s32i.n	a5, a10, 20
42012c64:	003f46        	j	42012d65 <__mdiff+0x129>
42012c67:	00          	.byte 00
42012c68:	00          	.byte 00
42012c69:	160c      	movi.n	a6, 1
42012c6b:	007a96        	bltz	a10, 42012c76 <__mdiff+0x3a>
42012c6e:	045d      	mov.n	a5, a4
42012c70:	060c      	movi.n	a6, 0
42012c72:	034d      	mov.n	a4, a3
42012c74:	053d      	mov.n	a3, a5
42012c76:	14b8      	l32i.n	a11, a4, 4
42012c78:	20a220        	or	a10, a2, a2
42012c7b:	ff98a5        	call8	42012604 <_Balloc>
42012c7e:	0adc      	bnez.n	a10, 42012c92 <__mdiff+0x56>
42012c80:	b814d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012c83:	20caa0        	or	a12, a10, a10
42012c86:	40a2b2        	movi	a11, 0x240
42012c89:	b80fa1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012c8c:	b4fe81        	l32r	a8, 42000084 <_stext+0x64>
42012c8f:	0008e0        	callx8	a8
42012c92:	4388      	l32i.n	a8, a3, 16
42012c94:	14c322        	addi	a2, a3, 20
42012c97:	a08820        	addx4	a8, a8, a2
42012c9a:	ebc822        	addi	a2, a8, -21
42012c9d:	4498      	l32i.n	a9, a4, 16
42012c9f:	c02230        	sub	a2, a2, a3
42012ca2:	3a69      	s32i.n	a6, a10, 12
42012ca4:	14c4e2        	addi	a14, a4, 20
42012ca7:	412220        	srli	a2, a2, 2
42012caa:	18c352        	addi	a5, a3, 24
42012cad:	783b      	addi.n	a7, a8, 3
42012caf:	a0c9e0        	addx4	a12, a9, a14
42012cb2:	14caf2        	addi	a15, a10, 20
42012cb5:	461c      	movi.n	a6, 20
42012cb7:	0d0c      	movi.n	a13, 0
42012cb9:	01c222        	addi	a2, a2, 1
42012cbc:	023757        	bltu	a7, a5, 42012cc2 <__mdiff+0x86>
42012cbf:	0198d7        	bne	a8, a13, 42012cc4 <__mdiff+0x88>
42012cc2:	120c      	movi.n	a2, 1
42012cc4:	f03d      	nop.n
42012cc6:	328276        	loop	a2, 42012cfc <__mdiff+0xc0>
42012cc9:	546a      	add.n	a5, a4, a6
42012ccb:	05b8      	l32i.n	a11, a5, 0
42012ccd:	536a      	add.n	a5, a3, a6
42012ccf:	0578      	l32i.n	a7, a5, 0
42012cd1:	f450b0        	extui	a5, a11, 0, 16
42012cd4:	55da      	add.n	a5, a5, a13
42012cd6:	f4d070        	extui	a13, a7, 0, 16
42012cd9:	c055d0        	sub	a5, a5, a13
42012cdc:	f57070        	extui	a7, a7, 16, 16
42012cdf:	f5b0b0        	extui	a11, a11, 16, 16
42012ce2:	c0bb70        	sub	a11, a11, a7
42012ce5:	317050        	srai	a7, a5, 16
42012ce8:	bb7a      	add.n	a11, a11, a7
42012cea:	31d0b0        	srai	a13, a11, 16
42012ced:	f45050        	extui	a5, a5, 0, 16
42012cf0:	11bb00        	slli	a11, a11, 16
42012cf3:	7a6a      	add.n	a7, a10, a6
42012cf5:	20bb50        	or	a11, a11, a5
42012cf8:	07b9      	s32i.n	a11, a7, 0
42012cfa:	664b      	addi.n	a6, a6, 4
42012cfc:	15c342        	addi	a4, a3, 21
42012cff:	420c      	movi.n	a2, 4
42012d01:	0d3847        	bltu	a8, a4, 42012d12 <__mdiff+0xd6>
42012d04:	c08830        	sub	a8, a8, a3
42012d07:	ebc882        	addi	a8, a8, -21
42012d0a:	418280        	srli	a8, a8, 2
42012d0d:	881b      	addi.n	a8, a8, 1
42012d0f:	1128e0        	slli	a2, a8, 2
42012d12:	ee2a      	add.n	a14, a14, a2
42012d14:	2f2a      	add.n	a2, a15, a2
42012d16:	025d      	mov.n	a5, a2
42012d18:	0e4d      	mov.n	a4, a14
42012d1a:	000806        	j	42012d3e <__mdiff+0x102>
42012d1d:	0488      	l32i.n	a8, a4, 0
42012d1f:	444b      	addi.n	a4, a4, 4
42012d21:	f43080        	extui	a3, a8, 0, 16
42012d24:	33da      	add.n	a3, a3, a13
42012d26:	316030        	srai	a6, a3, 16
42012d29:	f58080        	extui	a8, a8, 16, 16
42012d2c:	886a      	add.n	a8, a8, a6
42012d2e:	31d080        	srai	a13, a8, 16
42012d31:	f43030        	extui	a3, a3, 0, 16
42012d34:	118800        	slli	a8, a8, 16
42012d37:	208830        	or	a8, a8, a3
42012d3a:	0589      	s32i.n	a8, a5, 0
42012d3c:	554b      	addi.n	a5, a5, 4
42012d3e:	db34c7        	bltu	a4, a12, 42012d1d <__mdiff+0xe1>
42012d41:	fdce32        	addi	a3, a14, -3
42012d44:	040c      	movi.n	a4, 0
42012d46:	0a3c37        	bltu	a12, a3, 42012d54 <__mdiff+0x118>
42012d49:	8c3b      	addi.n	a8, a12, 3
42012d4b:	c088e0        	sub	a8, a8, a14
42012d4e:	418280        	srli	a8, a8, 2
42012d51:	1148e0        	slli	a4, a8, 2
42012d54:	224a      	add.n	a2, a2, a4
42012d56:	000046        	j	42012d5b <__mdiff+0x11f>
42012d59:	990b      	addi.n	a9, a9, -1
42012d5b:	fcc222        	addi	a2, a2, -4
42012d5e:	0238      	l32i.n	a3, a2, 0
42012d60:	ff5316        	beqz	a3, 42012d59 <__mdiff+0x11d>
42012d63:	4a99      	s32i.n	a9, a10, 16
42012d65:	0a2d      	mov.n	a2, a10
42012d67:	f01d      	retw.n
42012d69:	000000        	ill

42012d6c <__ulp>:
42012d6c:	004136        	entry	a1, 32
42012d6f:	ffa782        	movi	a8, 0x7ff
42012d72:	0188c0        	slli	a8, a8, 20
42012d75:	327c      	movi.n	a2, -13
42012d77:	0122a0        	slli	a2, a2, 22
42012d7a:	103830        	and	a3, a8, a3
42012d7d:	332a      	add.n	a3, a3, a2
42012d7f:	020c      	movi.n	a2, 0
42012d81:	2f13e6        	bgei	a3, 1, 42012db4 <__ulp+0x48>
42012d84:	603030        	neg	a3, a3
42012d87:	318430        	srai	a8, a3, 20
42012d8a:	331c      	movi.n	a3, 19
42012d8c:	0d2387        	blt	a3, a8, 42012d9d <__ulp+0x31>
42012d8f:	130c      	movi.n	a3, 1
42012d91:	0133d0        	slli	a3, a3, 19
42012d94:	400800        	ssr	a8
42012d97:	b13030        	sra	a3, a3
42012d9a:	000586        	j	42012db4 <__ulp+0x48>
42012d9d:	ecc882        	addi	a8, a8, -20
42012da0:	e31c      	movi.n	a3, 30
42012da2:	120c      	movi.n	a2, 1
42012da4:	0a2387        	blt	a3, a8, 42012db2 <__ulp+0x46>
42012da7:	f27c      	movi.n	a2, -1
42012da9:	012210        	slli	a2, a2, 31
42012dac:	400800        	ssr	a8
42012daf:	912020        	srl	a2, a2
42012db2:	030c      	movi.n	a3, 0
42012db4:	f01d      	retw.n
	...

42012db8 <__b2d>:
42012db8:	004136        	entry	a1, 32
42012dbb:	4278      	l32i.n	a7, a2, 16
42012dbd:	14c252        	addi	a5, a2, 20
42012dc0:	a07750        	addx4	a7, a7, a5
42012dc3:	fcc742        	addi	a4, a7, -4
42012dc6:	0468      	l32i.n	a6, a4, 0
42012dc8:	20a022        	movi	a2, 32
42012dcb:	06ad      	mov.n	a10, a6
42012dcd:	ffa2a5        	call8	420127f8 <__hi0bits>
42012dd0:	c022a0        	sub	a2, a2, a10
42012dd3:	0329      	s32i.n	a2, a3, 0
42012dd5:	ffa322        	movi	a2, 0x3ff
42012dd8:	a30c      	movi.n	a3, 10
42012dda:	0122c0        	slli	a2, a2, 20
42012ddd:	2d23a7        	blt	a3, a10, 42012e0e <__b2d+0x56>
42012de0:	bb0c      	movi.n	a11, 11
42012de2:	c0bba0        	sub	a11, a11, a10
42012de5:	400b00        	ssr	a11
42012de8:	913060        	srl	a3, a6
42012deb:	080c      	movi.n	a8, 0
42012ded:	209320        	or	a9, a3, a2
42012df0:	202880        	or	a2, a8, a8
42012df3:	05b547        	bgeu	a5, a4, 42012dfc <__b2d+0x44>
42012df6:	f8c772        	addi	a7, a7, -8
42012df9:	002722        	l32i	a2, a7, 0
42012dfc:	15caa2        	addi	a10, a10, 21
42012dff:	401a00        	ssl	a10
42012e02:	a1a600        	sll	a10, a6
42012e05:	400b00        	ssr	a11
42012e08:	912020        	srl	a2, a2
42012e0b:	001186        	j	42012e55 <__b2d+0x9d>
42012e0e:	0d0c      	movi.n	a13, 0
42012e10:	04b547        	bgeu	a5, a4, 42012e18 <__b2d+0x60>
42012e13:	f8c742        	addi	a4, a7, -8
42012e16:	04d8      	l32i.n	a13, a4, 0
42012e18:	f5caa2        	addi	a10, a10, -11
42012e1b:	209620        	or	a9, a6, a2
42012e1e:	aabc      	beqz.n	a10, 42012e5c <__b2d+0xa4>
42012e20:	072c      	movi.n	a7, 32
42012e22:	c077a0        	sub	a7, a7, a10
42012e25:	400700        	ssr	a7
42012e28:	9120d0        	srl	a2, a13
42012e2b:	401a00        	ssl	a10
42012e2e:	a1c600        	sll	a12, a6
42012e31:	ffa3b2        	movi	a11, 0x3ff
42012e34:	20cc20        	or	a12, a12, a2
42012e37:	01bbc0        	slli	a11, a11, 20
42012e3a:	080c      	movi.n	a8, 0
42012e3c:	209cb0        	or	a9, a12, a11
42012e3f:	082d      	mov.n	a2, a8
42012e41:	04b547        	bgeu	a5, a4, 42012e49 <__b2d+0x91>
42012e44:	fcc432        	addi	a3, a4, -4
42012e47:	0328      	l32i.n	a2, a3, 0
42012e49:	401a00        	ssl	a10
42012e4c:	a1ad00        	sll	a10, a13
42012e4f:	400700        	ssr	a7
42012e52:	912020        	srl	a2, a2
42012e55:	20da20        	or	a13, a10, a2
42012e58:	000006        	j	42012e5c <__b2d+0xa4>
42012e5b:	00          	.byte 00
42012e5c:	0d2d      	mov.n	a2, a13
42012e5e:	093d      	mov.n	a3, a9
42012e60:	f01d      	retw.n
	...

42012e64 <__d2b>:
42012e64:	006136        	entry	a1, 48
42012e67:	02ad      	mov.n	a10, a2
42012e69:	1b0c      	movi.n	a11, 1
42012e6b:	ff79a5        	call8	42012604 <_Balloc>
42012e6e:	0a2d      	mov.n	a2, a10
42012e70:	0adc      	bnez.n	a10, 42012e84 <__d2b+0x20>
42012e72:	20caa0        	or	a12, a10, a10
42012e75:	b796d1        	l32r	a13, 42000cd0 <_stext+0xcb0>
42012e78:	b794a1        	l32r	a10, 42000cc8 <_stext+0xca8>
42012e7b:	0aa3b2        	movi	a11, 0x30a
42012e7e:	b48181        	l32r	a8, 42000084 <_stext+0x64>
42012e81:	0008e0        	callx8	a8
42012e84:	b72a31        	l32r	a3, 42000b2c <_stext+0xb0c>
42012e87:	103350        	and	a3, a3, a5
42012e8a:	a55450        	extui	a5, a5, 20, 11
42012e8d:	15cc      	bnez.n	a5, 42012e92 <__d2b+0x2e>
42012e8f:	0001c6        	j	42012e9a <__d2b+0x36>
42012e92:	180c      	movi.n	a8, 1
42012e94:	0188c0        	slli	a8, a8, 20
42012e97:	203380        	or	a3, a3, a8
42012e9a:	0139      	s32i.n	a3, a1, 0
42012e9c:	44bc      	beqz.n	a4, 42012ed4 <__d2b+0x70>
42012e9e:	a14b      	addi.n	a10, a1, 4
42012ea0:	1149      	s32i.n	a4, a1, 4
42012ea2:	ff9a25        	call8	42012844 <__lo0bits>
42012ea5:	0188      	l32i.n	a8, a1, 0
42012ea7:	1148      	l32i.n	a4, a1, 4
42012ea9:	7a9c      	beqz.n	a10, 42012ec4 <__d2b+0x60>
42012eab:	6030a0        	neg	a3, a10
42012eae:	401300        	ssl	a3
42012eb1:	a13800        	sll	a3, a8
42012eb4:	203340        	or	a3, a3, a4
42012eb7:	400a00        	ssr	a10
42012eba:	918080        	srl	a8, a8
42012ebd:	5239      	s32i.n	a3, a2, 20
42012ebf:	0189      	s32i.n	a8, a1, 0
42012ec1:	000046        	j	42012ec6 <__d2b+0x62>
42012ec4:	5249      	s32i.n	a4, a2, 20
42012ec6:	0148      	l32i.n	a4, a1, 0
42012ec8:	230c      	movi.n	a3, 2
42012eca:	180c      	movi.n	a8, 1
42012ecc:	6249      	s32i.n	a4, a2, 24
42012ece:	833840        	moveqz	a3, a8, a4
42012ed1:	000346        	j	42012ee2 <__d2b+0x7e>
42012ed4:	01ad      	mov.n	a10, a1
42012ed6:	ff96e5        	call8	42012844 <__lo0bits>
42012ed9:	0138      	l32i.n	a3, a1, 0
42012edb:	20caa2        	addi	a10, a10, 32
42012ede:	5239      	s32i.n	a3, a2, 20
42012ee0:	130c      	movi.n	a3, 1
42012ee2:	4239      	s32i.n	a3, a2, 16
42012ee4:	c58c      	beqz.n	a5, 42012ef4 <__d2b+0x90>
42012ee6:	cdab32        	movi	a3, 0xfffffbcd
42012ee9:	553a      	add.n	a5, a5, a3
42012eeb:	55aa      	add.n	a5, a5, a10
42012eed:	0659      	s32i.n	a5, a6, 0
42012eef:	533c      	movi.n	a3, 53
42012ef1:	0004c6        	j	42012f08 <__d2b+0xa4>
42012ef4:	ceab42        	movi	a4, 0xfffffbce
42012ef7:	aa4a      	add.n	a10, a10, a4
42012ef9:	a04320        	addx4	a4, a3, a2
42012efc:	0066a2        	s32i	a10, a6, 0
42012eff:	0424a2        	l32i	a10, a4, 16
42012f02:	1133b0        	slli	a3, a3, 5
42012f05:	ff8f25        	call8	420127f8 <__hi0bits>
42012f08:	c0a3a0        	sub	a10, a3, a10
42012f0b:	07a9      	s32i.n	a10, a7, 0
42012f0d:	f01d      	retw.n
	...

42012f10 <__ratio>:
42012f10:	006136        	entry	a1, 48
42012f13:	b14b      	addi.n	a11, a1, 4
42012f15:	02ad      	mov.n	a10, a2
42012f17:	ffea25        	call8	42012db8 <__b2d>
42012f1a:	036d      	mov.n	a6, a3
42012f1c:	0a4d      	mov.n	a4, a10
42012f1e:	0b3d      	mov.n	a3, a11
42012f20:	06ad      	mov.n	a10, a6
42012f22:	0b5d      	mov.n	a5, a11
42012f24:	01bd      	mov.n	a11, a1
42012f26:	ffe925        	call8	42012db8 <__b2d>
42012f29:	4288      	l32i.n	a8, a2, 16
42012f2b:	4668      	l32i.n	a6, a6, 16
42012f2d:	1198      	l32i.n	a9, a1, 4
42012f2f:	c08860        	sub	a8, a8, a6
42012f32:	0168      	l32i.n	a6, a1, 0
42012f34:	1188b0        	slli	a8, a8, 5
42012f37:	c09960        	sub	a9, a9, a6
42012f3a:	889a      	add.n	a8, a8, a9
42012f3c:	027d      	mov.n	a7, a2
42012f3e:	0acd      	mov.n	a12, a10
42012f40:	0bdd      	mov.n	a13, a11
42012f42:	0718a6        	blti	a8, 1, 42012f4d <__ratio+0x3d>
42012f45:	0188c0        	slli	a8, a8, 20
42012f48:	583a      	add.n	a5, a8, a3
42012f4a:	000146        	j	42012f53 <__ratio+0x43>
42012f4d:	0188c0        	slli	a8, a8, 20
42012f50:	c0db80        	sub	a13, a11, a8
42012f53:	04ad      	mov.n	a10, a4
42012f55:	05bd      	mov.n	a11, a5
42012f57:	b6ce81        	l32r	a8, 42000a90 <_stext+0xa70>
42012f5a:	0008e0        	callx8	a8
42012f5d:	0a2d      	mov.n	a2, a10
42012f5f:	0b3d      	mov.n	a3, a11
42012f61:	f01d      	retw.n
	...

42012f64 <_mprec_log10>:
42012f64:	004136        	entry	a1, 32
42012f67:	781c      	movi.n	a8, 23
42012f69:	b621a1        	l32r	a10, 420007f0 <_stext+0x7d0>
42012f6c:	b74db1        	l32r	a11, 42000ca0 <_stext+0xc80>
42012f6f:	0d2827        	blt	a8, a2, 42012f80 <_mprec_log10+0x1c>
42012f72:	b74881        	l32r	a8, 42000c94 <_stext+0xc74>
42012f75:	b02280        	addx8	a2, a2, a8
42012f78:	02a8      	l32i.n	a10, a2, 0
42012f7a:	12b8      	l32i.n	a11, a2, 4
42012f7c:	000446        	j	42012f91 <_mprec_log10+0x2d>
42012f7f:	00          	.byte 00
42012f80:	b61cc1        	l32r	a12, 420007f0 <_stext+0x7d0>
42012f83:	b748d1        	l32r	a13, 42000ca4 <_stext+0xc84>
42012f86:	220b      	addi.n	a2, a2, -1
42012f88:	b71f81        	l32r	a8, 42000c04 <_stext+0xbe4>
42012f8b:	0008e0        	callx8	a8
42012f8e:	fee256        	bnez	a2, 42012f80 <_mprec_log10+0x1c>
42012f91:	0a2d      	mov.n	a2, a10
42012f93:	0b3d      	mov.n	a3, a11
42012f95:	f01d      	retw.n
	...

42012f98 <__copybits>:
42012f98:	004136        	entry	a1, 32
42012f9b:	930b      	addi.n	a9, a3, -1
42012f9d:	4488      	l32i.n	a8, a4, 16
42012f9f:	219590        	srai	a9, a9, 5
42012fa2:	991b      	addi.n	a9, a9, 1
42012fa4:	14c4a2        	addi	a10, a4, 20
42012fa7:	a09920        	addx4	a9, a9, a2
42012faa:	a088a0        	addx4	a8, a8, a10
42012fad:	02bd      	mov.n	a11, a2
42012faf:	0001c6        	j	42012fba <__copybits+0x22>
42012fb2:	0ac8      	l32i.n	a12, a10, 0
42012fb4:	aa4b      	addi.n	a10, a10, 4
42012fb6:	0bc9      	s32i.n	a12, a11, 0
42012fb8:	bb4b      	addi.n	a11, a11, 4
42012fba:	f43a87        	bltu	a10, a8, 42012fb2 <__copybits+0x1a>
42012fbd:	11c4a2        	addi	a10, a4, 17
42012fc0:	0b0c      	movi.n	a11, 0
42012fc2:	0b38a7        	bltu	a8, a10, 42012fd1 <__copybits+0x39>
42012fc5:	c08840        	sub	a8, a8, a4
42012fc8:	efc882        	addi	a8, a8, -17
42012fcb:	418280        	srli	a8, a8, 2
42012fce:	11b8e0        	slli	a11, a8, 2
42012fd1:	22ba      	add.n	a2, a2, a11
42012fd3:	040c      	movi.n	a4, 0
42012fd5:	0000c6        	j	42012fdc <__copybits+0x44>
42012fd8:	0249      	s32i.n	a4, a2, 0
42012fda:	224b      	addi.n	a2, a2, 4
42012fdc:	f83297        	bltu	a2, a9, 42012fd8 <__copybits+0x40>
42012fdf:	f01d      	retw.n
42012fe1:	000000        	ill

42012fe4 <__any_on>:
42012fe4:	004136        	entry	a1, 32
42012fe7:	14c292        	addi	a9, a2, 20
42012fea:	4228      	l32i.n	a2, a2, 16
42012fec:	218530        	srai	a8, a3, 5
42012fef:	232287        	blt	a2, a8, 42013016 <__any_on+0x32>
42012ff2:	22a827        	bge	a8, a2, 42013018 <__any_on+0x34>
42012ff5:	443030        	extui	a3, a3, 0, 5
42012ff8:	c39c      	beqz.n	a3, 42013018 <__any_on+0x34>
42012ffa:	a02890        	addx4	a2, a8, a9
42012ffd:	02a8      	l32i.n	a10, a2, 0
42012fff:	400300        	ssr	a3
42013002:	9120a0        	srl	a2, a10
42013005:	401300        	ssl	a3
42013008:	a13200        	sll	a3, a2
4201300b:	120c      	movi.n	a2, 1
4201300d:	219a37        	bne	a10, a3, 42013032 <__any_on+0x4e>
42013010:	000106        	j	42013018 <__any_on+0x34>
42013013:	00          	.byte 00
42013014:	00          	.byte 00
42013015:	00          	.byte 00
42013016:	028d      	mov.n	a8, a2
42013018:	a08890        	addx4	a8, a8, a9
4201301b:	000206        	j	42013027 <__any_on+0x43>
4201301e:	00          	.byte 00
4201301f:	00          	.byte 00
42013020:	fcc882        	addi	a8, a8, -4
42013023:	0828      	l32i.n	a2, a8, 0
42013025:	72cc      	bnez.n	a2, 42013030 <__any_on+0x4c>
42013027:	f53987        	bltu	a9, a8, 42013020 <__any_on+0x3c>
4201302a:	020c      	movi.n	a2, 0
4201302c:	000086        	j	42013032 <__any_on+0x4e>
4201302f:	00          	.byte 00
42013030:	120c      	movi.n	a2, 1
42013032:	f01d      	retw.n

42013034 <frexp>:
42013034:	004136        	entry	a1, 32
42013037:	0c0c      	movi.n	a12, 0
42013039:	02ad      	mov.n	a10, a2
4201303b:	b4e521        	l32r	a2, 420003d0 <_stext+0x3b0>
4201303e:	04c9      	s32i.n	a12, a4, 0
42013040:	b6e7c1        	l32r	a12, 42000bdc <_stext+0xbbc>
42013043:	108230        	and	a8, a2, a3
42013046:	20b330        	or	a11, a3, a3
42013049:	039d      	mov.n	a9, a3
4201304b:	412c87        	blt	a12, a8, 42013090 <frexp+0x5c>
4201304e:	20c8a0        	or	a12, a8, a10
42013051:	bcbc      	beqz.n	a12, 42013090 <frexp+0x5c>
42013053:	ffa7c2        	movi	a12, 0x7ff
42013056:	01ccc0        	slli	a12, a12, 20
42013059:	1583c7        	bany	a3, a12, 42013072 <frexp+0x3e>
4201305c:	b5e5c1        	l32r	a12, 420007f0 <_stext+0x7d0>
4201305f:	b71fd1        	l32r	a13, 42000cdc <_stext+0xcbc>
42013062:	b6e881        	l32r	a8, 42000c04 <_stext+0xbe4>
42013065:	0008e0        	callx8	a8
42013068:	1082b0        	and	a8, a2, a11
4201306b:	caaf22        	movi	a2, -54
4201306e:	0b9d      	mov.n	a9, a11
42013070:	0429      	s32i.n	a2, a4, 0
42013072:	04c8      	l32i.n	a12, a4, 0
42013074:	02ac22        	movi	a2, 0xfffffc02
42013077:	318480        	srai	a8, a8, 20
4201307a:	882a      	add.n	a8, a8, a2
4201307c:	8c8a      	add.n	a8, a12, a8
4201307e:	b71821        	l32r	a2, 42000ce0 <_stext+0xcc0>
42013081:	006482        	s32i	a8, a4, 0
42013084:	ffa142        	movi	a4, 0x1ff
42013087:	109920        	and	a9, a9, a2
4201308a:	0144b0        	slli	a4, a4, 21
4201308d:	20b940        	or	a11, a9, a4
42013090:	0a2d      	mov.n	a2, a10
42013092:	0b3d      	mov.n	a3, a11
42013094:	f01d      	retw.n
	...

42013098 <get_arg$constprop$0>:
42013098:	008136        	entry	a1, 64
4201309b:	102182        	l32i	a8, a1, 64
4201309e:	2129      	s32i.n	a2, a1, 8
420130a0:	2198      	l32i.n	a9, a1, 8
420130a2:	0528      	l32i.n	a2, a5, 0
420130a4:	3159      	s32i.n	a5, a1, 12
420130a6:	0858      	l32i.n	a5, a8, 0
420130a8:	933550        	movnez	a3, a5, a5
420130ab:	0199      	s32i.n	a9, a1, 0
420130ad:	00ea46        	j	4201345a <get_arg$constprop$0+0x3c2>
420130b0:	00          	.byte 00
420130b1:	00          	.byte 00
420130b2:	331b      	addi.n	a3, a3, 1
420130b4:	000352        	l8ui	a5, a3, 0
420130b7:	180c      	movi.n	a8, 1
420130b9:	838950        	moveqz	a8, a9, a5
420130bc:	748080        	extui	a8, a8, 0, 8
420130bf:	d88c      	beqz.n	a8, 420130d0 <get_arg$constprop$0+0x38>
420130c1:	dbc5a2        	addi	a10, a5, -37
420130c4:	01a082        	movi	a8, 1
420130c7:	8389a0        	moveqz	a8, a9, a10
420130ca:	748080        	extui	a8, a8, 0, 8
420130cd:	fe1856        	bnez	a8, 420130b2 <get_arg$constprop$0+0x1a>
420130d0:	43c516        	beqz	a5, 42013510 <get_arg$constprop$0+0x478>
420130d3:	050c      	movi.n	a5, 0
420130d5:	a31b      	addi.n	a10, a3, 1
420130d7:	05ed      	mov.n	a14, a5
420130d9:	f97c      	movi.n	a9, -1
420130db:	05dd      	mov.n	a13, a5
420130dd:	1159      	s32i.n	a5, a1, 4
420130df:	000046        	j	420130e4 <get_arg$constprop$0+0x4c>
420130e2:	03ad      	mov.n	a10, a3
420130e4:	b6aec1        	l32r	a12, 42000b9c <_stext+0xb7c>
420130e7:	000a82        	l8ui	a8, a10, 0
420130ea:	3a1b      	addi.n	a3, a10, 1
420130ec:	bc8a      	add.n	a11, a12, a8
420130ee:	000bc2        	l8ui	a12, a11, 0
420130f1:	11b8      	l32i.n	a11, a1, 4
420130f3:	b0fbb0        	addx8	a15, a11, a11
420130f6:	b6aab1        	l32r	a11, 42000ba0 <_stext+0xb80>
420130f9:	bbfa      	add.n	a11, a11, a15
420130fb:	bbca      	add.n	a11, a11, a12
420130fd:	000bb2        	l8ui	a11, a11, 0
42013100:	11b9      	s32i.n	a11, a1, 4
42013102:	b6a8b1        	l32r	a11, 42000ba4 <_stext+0xb84>
42013105:	bbfa      	add.n	a11, a11, a15
42013107:	bbca      	add.n	a11, a11, a12
42013109:	000bb2        	l8ui	a11, a11, 0
4201310c:	bb0b      	addi.n	a11, a11, -1
4201310e:	74b0b0        	extui	a11, a11, 0, 8
42013111:	028bb6        	bltui	a11, 8, 42013117 <get_arg$constprop$0+0x7f>
42013114:	00ce06        	j	42013450 <get_arg$constprop$0+0x3b8>
42013117:	b6f3c1        	l32r	a12, 42000ce4 <_stext+0xcc4>
4201311a:	a0bbc0        	addx4	a11, a11, a12
4201311d:	0bb8      	l32i.n	a11, a11, 0
4201311f:	000ba0        	jx	a11
42013122:	00          	.byte 00
42013123:	9a0c      	movi.n	a10, 9
42013125:	00c586        	j	4201343f <get_arg$constprop$0+0x3a7>
42013128:	6aa0b2        	movi	a11, 106
4201312b:	3318b7        	beq	a8, a11, 42013162 <get_arg$constprop$0+0xca>
4201312e:	0a3b87        	bltu	a11, a8, 4201313c <get_arg$constprop$0+0xa4>
42013131:	cb4c      	movi.n	a11, 76
42013133:	2618b7        	beq	a8, a11, 4201315d <get_arg$constprop$0+0xc5>
42013136:	68a0b2        	movi	a11, 104
42013139:	0005c6        	j	42013154 <get_arg$constprop$0+0xbc>
4201313c:	71a0b2        	movi	a11, 113
4201313f:	1f18b7        	beq	a8, a11, 42013162 <get_arg$constprop$0+0xca>
42013142:	70a0b2        	movi	a11, 112
42013145:	1fbb87        	bgeu	a11, a8, 42013168 <get_arg$constprop$0+0xd0>
42013148:	74a0b2        	movi	a11, 116
4201314b:	0298b7        	bne	a8, a11, 42013151 <get_arg$constprop$0+0xb9>
4201314e:	00bf86        	j	42013450 <get_arg$constprop$0+0x3b8>
42013151:	7aa0b2        	movi	a11, 122
42013154:	0298b7        	bne	a8, a11, 4201315a <get_arg$constprop$0+0xc2>
42013157:	00bd46        	j	42013450 <get_arg$constprop$0+0x3b8>
4201315a:	000286        	j	42013168 <get_arg$constprop$0+0xd0>
4201315d:	880c      	movi.n	a8, 8
4201315f:	0006c6        	j	4201317e <get_arg$constprop$0+0xe6>
42013162:	082c      	movi.n	a8, 32
42013164:	000586        	j	4201317e <get_arg$constprop$0+0xe6>
42013167:	00          	.byte 00
42013168:	010ab2        	l8ui	a11, a10, 1
4201316b:	6ca082        	movi	a8, 108
4201316e:	0a9b87        	bne	a11, a8, 4201317c <get_arg$constprop$0+0xe4>
42013171:	032c      	movi.n	a3, 32
42013173:	20dd30        	or	a13, a13, a3
42013176:	3a2b      	addi.n	a3, a10, 2
42013178:	00b506        	j	42013450 <get_arg$constprop$0+0x3b8>
4201317b:	00          	.byte 00
4201317c:	081c      	movi.n	a8, 16
4201317e:	20dd80        	or	a13, a13, a8
42013181:	00b2c6        	j	42013450 <get_arg$constprop$0+0x3b8>
42013184:	61a0a2        	movi	a10, 97
42013187:	442020        	extui	a2, a2, 0, 5
4201318a:	0298a7        	bne	a8, a10, 42013190 <get_arg$constprop$0+0xf8>
4201318d:	00f806        	j	42013571 <get_arg$constprop$0+0x4d9>
42013190:	3c3a87        	bltu	a10, a8, 420131d0 <get_arg$constprop$0+0x138>
42013193:	bfc882        	addi	a8, a8, -65
42013196:	748080        	extui	a8, a8, 0, 8
42013199:	7a1c      	movi.n	a10, 23
4201319b:	25ba87        	bgeu	a10, a8, 420131c4 <get_arg$constprop$0+0x12c>
4201319e:	0016c6        	j	420131fd <get_arg$constprop$0+0x165>
420131a1:	1c0c      	movi.n	a12, 1
420131a3:	b682a1        	l32r	a10, 42000bac <_stext+0xb8c>
420131a6:	401800        	ssl	a8
420131a9:	a18c00        	sll	a8, a12
420131ac:	3488a7        	bany	a8, a10, 420131e4 <get_arg$constprop$0+0x14c>
420131af:	5a2c      	movi.n	a10, 37
420131b1:	11aa60        	slli	a10, a10, 10
420131b4:	0208a7        	bnone	a8, a10, 420131ba <get_arg$constprop$0+0x122>
420131b7:	00eac6        	j	42013566 <get_arg$constprop$0+0x4ce>
420131ba:	ea0c      	movi.n	a10, 14
420131bc:	3d08a7        	bnone	a8, a10, 420131fd <get_arg$constprop$0+0x165>
420131bf:	00eb86        	j	42013571 <get_arg$constprop$0+0x4d9>
420131c2:	00          	.byte 00
420131c3:	00          	.byte 00
420131c4:	b6c9a1        	l32r	a10, 42000ce8 <_stext+0xcc8>
420131c7:	a088a0        	addx4	a8, a8, a10
420131ca:	0888      	l32i.n	a8, a8, 0
420131cc:	0008a0        	jx	a8
420131cf:	00          	.byte 00
420131d0:	63a0a2        	movi	a10, 99
420131d3:	1d18a7        	beq	a8, a10, 420131f4 <get_arg$constprop$0+0x15c>
420131d6:	9cc882        	addi	a8, a8, -100
420131d9:	748080        	extui	a8, a8, 0, 8
420131dc:	4a1c      	movi.n	a10, 20
420131de:	bfba87        	bgeu	a10, a8, 420131a1 <get_arg$constprop$0+0x109>
420131e1:	000606        	j	420131fd <get_arg$constprop$0+0x165>
420131e4:	026d47        	bbci	a13, 4, 420131ea <get_arg$constprop$0+0x152>
420131e7:	00d346        	j	42013538 <get_arg$constprop$0+0x4a0>
420131ea:	026d57        	bbci	a13, 5, 420131f0 <get_arg$constprop$0+0x158>
420131ed:	00d4c6        	j	42013544 <get_arg$constprop$0+0x4ac>
420131f0:	00d9c6        	j	4201355b <get_arg$constprop$0+0x4c3>
420131f3:	00          	.byte 00
420131f4:	026d47        	bbci	a13, 4, 420131fa <get_arg$constprop$0+0x162>
420131f7:	00d546        	j	42013550 <get_arg$constprop$0+0x4b8>
420131fa:	00d746        	j	4201355b <get_arg$constprop$0+0x4c3>
420131fd:	070926        	beqi	a9, -1, 42013208 <get_arg$constprop$0+0x170>
42013200:	a08970        	addx4	a8, a9, a7
42013203:	0859      	s32i.n	a5, a8, 0
42013205:	0091c6        	j	42013450 <get_arg$constprop$0+0x3b8>
42013208:	850b      	addi.n	a8, a5, -1
4201320a:	0268b6        	bltui	a8, 6, 42013210 <get_arg$constprop$0+0x178>
4201320d:	002b06        	j	420132bd <get_arg$constprop$0+0x225>
42013210:	b6b7a1        	l32r	a10, 42000cec <_stext+0xccc>
42013213:	a088a0        	addx4	a8, a8, a10
42013216:	0888      	l32i.n	a8, a8, 0
42013218:	0008a0        	jx	a8
4201321b:	2488      	l32i.n	a8, a4, 8
4201321d:	891c      	movi.n	a9, 24
4201321f:	584b      	addi.n	a5, a8, 4
42013221:	2459      	s32i.n	a5, a4, 8
42013223:	a21b      	addi.n	a10, a2, 1
42013225:	b02260        	addx8	a2, a2, a6
42013228:	042957        	blt	a9, a5, 42013230 <get_arg$constprop$0+0x198>
4201322b:	1458      	l32i.n	a5, a4, 4
4201322d:	000206        	j	42013239 <get_arg$constprop$0+0x1a1>
42013230:	012987        	blt	a9, a8, 42013235 <get_arg$constprop$0+0x19d>
42013233:	452c      	movi.n	a5, 36
42013235:	2459      	s32i.n	a5, a4, 8
42013237:	0458      	l32i.n	a5, a4, 0
42013239:	2488      	l32i.n	a8, a4, 8
4201323b:	f97c      	movi.n	a9, -1
4201323d:	558a      	add.n	a5, a5, a8
4201323f:	fcc552        	addi	a5, a5, -4
42013242:	0558      	l32i.n	a5, a5, 0
42013244:	0259      	s32i.n	a5, a2, 0
42013246:	0a2d      	mov.n	a2, a10
42013248:	150c      	movi.n	a5, 1
4201324a:	008086        	j	42013450 <get_arg$constprop$0+0x3b8>
4201324d:	2458      	l32i.n	a5, a4, 8
4201324f:	887c      	movi.n	a8, -8
42013251:	557b      	addi.n	a5, a5, 7
42013253:	105580        	and	a5, a5, a8
42013256:	858b      	addi.n	a8, a5, 8
42013258:	2489      	s32i.n	a8, a4, 8
4201325a:	891c      	movi.n	a9, 24
4201325c:	a21b      	addi.n	a10, a2, 1
4201325e:	b02260        	addx8	a2, a2, a6
42013261:	042987        	blt	a9, a8, 42013269 <get_arg$constprop$0+0x1d1>
42013264:	1458      	l32i.n	a5, a4, 4
42013266:	000206        	j	42013272 <get_arg$constprop$0+0x1da>
42013269:	012957        	blt	a9, a5, 4201326e <get_arg$constprop$0+0x1d6>
4201326c:	882c      	movi.n	a8, 40
4201326e:	0458      	l32i.n	a5, a4, 0
42013270:	2489      	s32i.n	a8, a4, 8
42013272:	2488      	l32i.n	a8, a4, 8
42013274:	558a      	add.n	a5, a5, a8
42013276:	f8c552        	addi	a5, a5, -8
42013279:	1598      	l32i.n	a9, a5, 4
4201327b:	0588      	l32i.n	a8, a5, 0
4201327d:	1299      	s32i.n	a9, a2, 4
4201327f:	0289      	s32i.n	a8, a2, 0
42013281:	f97c      	movi.n	a9, -1
42013283:	0a2d      	mov.n	a2, a10
42013285:	250c      	movi.n	a5, 2
42013287:	007146        	j	42013450 <get_arg$constprop$0+0x3b8>
4201328a:	2488      	l32i.n	a8, a4, 8
4201328c:	891c      	movi.n	a9, 24
4201328e:	584b      	addi.n	a5, a8, 4
42013290:	2459      	s32i.n	a5, a4, 8
42013292:	a21b      	addi.n	a10, a2, 1
42013294:	b02260        	addx8	a2, a2, a6
42013297:	052957        	blt	a9, a5, 420132a0 <get_arg$constprop$0+0x208>
4201329a:	1458      	l32i.n	a5, a4, 4
4201329c:	000246        	j	420132a9 <get_arg$constprop$0+0x211>
4201329f:	00          	.byte 00
420132a0:	012987        	blt	a9, a8, 420132a5 <get_arg$constprop$0+0x20d>
420132a3:	452c      	movi.n	a5, 36
420132a5:	2459      	s32i.n	a5, a4, 8
420132a7:	0458      	l32i.n	a5, a4, 0
420132a9:	2488      	l32i.n	a8, a4, 8
420132ab:	f97c      	movi.n	a9, -1
420132ad:	558a      	add.n	a5, a5, a8
420132af:	fcc552        	addi	a5, a5, -4
420132b2:	0558      	l32i.n	a5, a5, 0
420132b4:	0259      	s32i.n	a5, a2, 0
420132b6:	0a2d      	mov.n	a2, a10
420132b8:	650c      	movi.n	a5, 6
420132ba:	006486        	j	42013450 <get_arg$constprop$0+0x3b8>
420132bd:	2488      	l32i.n	a8, a4, 8
420132bf:	891c      	movi.n	a9, 24
420132c1:	584b      	addi.n	a5, a8, 4
420132c3:	2459      	s32i.n	a5, a4, 8
420132c5:	a21b      	addi.n	a10, a2, 1
420132c7:	b02260        	addx8	a2, a2, a6
420132ca:	062957        	blt	a9, a5, 420132d4 <get_arg$constprop$0+0x23c>
420132cd:	1458      	l32i.n	a5, a4, 4
420132cf:	000286        	j	420132dd <get_arg$constprop$0+0x245>
420132d2:	00          	.byte 00
420132d3:	00          	.byte 00
420132d4:	012987        	blt	a9, a8, 420132d9 <get_arg$constprop$0+0x241>
420132d7:	452c      	movi.n	a5, 36
420132d9:	2459      	s32i.n	a5, a4, 8
420132db:	0458      	l32i.n	a5, a4, 0
420132dd:	2488      	l32i.n	a8, a4, 8
420132df:	f97c      	movi.n	a9, -1
420132e1:	558a      	add.n	a5, a5, a8
420132e3:	fcc552        	addi	a5, a5, -4
420132e6:	0558      	l32i.n	a5, a5, 0
420132e8:	0259      	s32i.n	a5, a2, 0
420132ea:	0a2d      	mov.n	a2, a10
420132ec:	050c      	movi.n	a5, 0
420132ee:	005786        	j	42013450 <get_arg$constprop$0+0x3b8>
420132f1:	2488      	l32i.n	a8, a4, 8
420132f3:	891c      	movi.n	a9, 24
420132f5:	584b      	addi.n	a5, a8, 4
420132f7:	2459      	s32i.n	a5, a4, 8
420132f9:	a21b      	addi.n	a10, a2, 1
420132fb:	b02260        	addx8	a2, a2, a6
420132fe:	062957        	blt	a9, a5, 42013308 <get_arg$constprop$0+0x270>
42013301:	1458      	l32i.n	a5, a4, 4
42013303:	000286        	j	42013311 <get_arg$constprop$0+0x279>
42013306:	00          	.byte 00
42013307:	00          	.byte 00
42013308:	012987        	blt	a9, a8, 4201330d <get_arg$constprop$0+0x275>
4201330b:	452c      	movi.n	a5, 36
4201330d:	2459      	s32i.n	a5, a4, 8
4201330f:	0458      	l32i.n	a5, a4, 0
42013311:	2488      	l32i.n	a8, a4, 8
42013313:	f97c      	movi.n	a9, -1
42013315:	558a      	add.n	a5, a5, a8
42013317:	fcc552        	addi	a5, a5, -4
4201331a:	0558      	l32i.n	a5, a5, 0
4201331c:	0259      	s32i.n	a5, a2, 0
4201331e:	0a2d      	mov.n	a2, a10
42013320:	350c      	movi.n	a5, 3
42013322:	004a86        	j	42013450 <get_arg$constprop$0+0x3b8>
42013325:	2458      	l32i.n	a5, a4, 8
42013327:	887c      	movi.n	a8, -8
42013329:	557b      	addi.n	a5, a5, 7
4201332b:	105580        	and	a5, a5, a8
4201332e:	858b      	addi.n	a8, a5, 8
42013330:	2489      	s32i.n	a8, a4, 8
42013332:	891c      	movi.n	a9, 24
42013334:	a21b      	addi.n	a10, a2, 1
42013336:	b02260        	addx8	a2, a2, a6
42013339:	042987        	blt	a9, a8, 42013341 <get_arg$constprop$0+0x2a9>
4201333c:	1458      	l32i.n	a5, a4, 4
4201333e:	000206        	j	4201334a <get_arg$constprop$0+0x2b2>
42013341:	012957        	blt	a9, a5, 42013346 <get_arg$constprop$0+0x2ae>
42013344:	882c      	movi.n	a8, 40
42013346:	0458      	l32i.n	a5, a4, 0
42013348:	2489      	s32i.n	a8, a4, 8
4201334a:	2488      	l32i.n	a8, a4, 8
4201334c:	558a      	add.n	a5, a5, a8
4201334e:	f8c552        	addi	a5, a5, -8
42013351:	1598      	l32i.n	a9, a5, 4
42013353:	0588      	l32i.n	a8, a5, 0
42013355:	1299      	s32i.n	a9, a2, 4
42013357:	0289      	s32i.n	a8, a2, 0
42013359:	f97c      	movi.n	a9, -1
4201335b:	0a2d      	mov.n	a2, a10
4201335d:	450c      	movi.n	a5, 4
4201335f:	003b46        	j	42013450 <get_arg$constprop$0+0x3b8>
42013362:	2488      	l32i.n	a8, a4, 8
42013364:	8a7c      	movi.n	a10, -8
42013366:	887b      	addi.n	a8, a8, 7
42013368:	1088a0        	and	a8, a8, a10
4201336b:	a88b      	addi.n	a10, a8, 8
4201336d:	24a9      	s32i.n	a10, a4, 8
4201336f:	8b1c      	movi.n	a11, 24
42013371:	b0c260        	addx8	a12, a2, a6
42013374:	052ba7        	blt	a11, a10, 4201337d <get_arg$constprop$0+0x2e5>
42013377:	1488      	l32i.n	a8, a4, 4
42013379:	000246        	j	42013386 <get_arg$constprop$0+0x2ee>
4201337c:	00          	.byte 00
4201337d:	012b87        	blt	a11, a8, 42013382 <get_arg$constprop$0+0x2ea>
42013380:	8a2c      	movi.n	a10, 40
42013382:	0488      	l32i.n	a8, a4, 0
42013384:	24a9      	s32i.n	a10, a4, 8
42013386:	24a8      	l32i.n	a10, a4, 8
42013388:	221b      	addi.n	a2, a2, 1
4201338a:	88aa      	add.n	a8, a8, a10
4201338c:	f8c882        	addi	a8, a8, -8
4201338f:	08a8      	l32i.n	a10, a8, 0
42013391:	18b8      	l32i.n	a11, a8, 4
42013393:	0ca9      	s32i.n	a10, a12, 0
42013395:	1cb9      	s32i.n	a11, a12, 4
42013397:	002d46        	j	42013450 <get_arg$constprop$0+0x3b8>
4201339a:	0788      	l32i.n	a8, a7, 0
4201339c:	140866        	bnei	a8, -1, 420133b4 <get_arg$constprop$0+0x31c>
4201339f:	80a0c2        	movi	a12, 128
420133a2:	0b0c      	movi.n	a11, 0
420133a4:	07ad      	mov.n	a10, a7
420133a6:	51d9      	s32i.n	a13, a1, 20
420133a8:	61e9      	s32i.n	a14, a1, 24
420133aa:	b37b81        	l32r	a8, 42000198 <_stext+0x178>
420133ad:	0008e0        	callx8	a8
420133b0:	61e8      	l32i.n	a14, a1, 24
420133b2:	51d8      	l32i.n	a13, a1, 20
420133b4:	0188      	l32i.n	a8, a1, 0
420133b6:	9e0b      	addi.n	a9, a14, -1
420133b8:	538890        	max	a8, a8, a9
420133bb:	000ac6        	j	420133ea <get_arg$constprop$0+0x352>
420133be:	0788      	l32i.n	a8, a7, 0
420133c0:	180866        	bnei	a8, -1, 420133dc <get_arg$constprop$0+0x344>
420133c3:	80a0c2        	movi	a12, 128
420133c6:	0b0c      	movi.n	a11, 0
420133c8:	07ad      	mov.n	a10, a7
420133ca:	4199      	s32i.n	a9, a1, 16
420133cc:	51d9      	s32i.n	a13, a1, 20
420133ce:	61e9      	s32i.n	a14, a1, 24
420133d0:	b37281        	l32r	a8, 42000198 <_stext+0x178>
420133d3:	0008e0        	callx8	a8
420133d6:	61e8      	l32i.n	a14, a1, 24
420133d8:	51d8      	l32i.n	a13, a1, 20
420133da:	4198      	l32i.n	a9, a1, 16
420133dc:	ee0b      	addi.n	a14, a14, -1
420133de:	a08e70        	addx4	a8, a14, a7
420133e1:	0a0c      	movi.n	a10, 0
420133e3:	08a9      	s32i.n	a10, a8, 0
420133e5:	0188      	l32i.n	a8, a1, 0
420133e7:	5388e0        	max	a8, a8, a14
420133ea:	0189      	s32i.n	a8, a1, 0
420133ec:	001806        	j	42013450 <get_arg$constprop$0+0x3b8>
420133ef:	0a3d      	mov.n	a3, a10
420133f1:	24a8      	l32i.n	a10, a4, 8
420133f3:	8b1c      	movi.n	a11, 24
420133f5:	8a4b      	addi.n	a8, a10, 4
420133f7:	2489      	s32i.n	a8, a4, 8
420133f9:	c21b      	addi.n	a12, a2, 1
420133fb:	b02260        	addx8	a2, a2, a6
420133fe:	062b87        	blt	a11, a8, 42013408 <get_arg$constprop$0+0x370>
42013401:	1488      	l32i.n	a8, a4, 4
42013403:	000286        	j	42013411 <get_arg$constprop$0+0x379>
42013406:	00          	.byte 00
42013407:	00          	.byte 00
42013408:	012ba7        	blt	a11, a10, 4201340d <get_arg$constprop$0+0x375>
4201340b:	482c      	movi.n	a8, 36
4201340d:	2489      	s32i.n	a8, a4, 8
4201340f:	0488      	l32i.n	a8, a4, 0
42013411:	24a8      	l32i.n	a10, a4, 8
42013413:	88aa      	add.n	a8, a8, a10
42013415:	fcc882        	addi	a8, a8, -4
42013418:	0888      	l32i.n	a8, a8, 0
4201341a:	0289      	s32i.n	a8, a2, 0
4201341c:	0c2d      	mov.n	a2, a12
4201341e:	000b86        	j	42013450 <get_arg$constprop$0+0x3b8>
42013421:	d0c8e2        	addi	a14, a8, -48
42013424:	9a0c      	movi.n	a10, 9
42013426:	0001c6        	j	42013431 <get_arg$constprop$0+0x399>
42013429:	a0eee0        	addx4	a14, a14, a14
4201342c:	90ee80        	addx2	a14, a14, a8
4201342f:	331b      	addi.n	a3, a3, 1
42013431:	000382        	l8ui	a8, a3, 0
42013434:	889c      	beqz.n	a8, 42013450 <get_arg$constprop$0+0x3b8>
42013436:	d0c882        	addi	a8, a8, -48
42013439:	ecba87        	bgeu	a10, a8, 42013429 <get_arg$constprop$0+0x391>
4201343c:	000406        	j	42013450 <get_arg$constprop$0+0x3b8>
4201343f:	000382        	l8ui	a8, a3, 0
42013442:	d0c882        	addi	a8, a8, -48
42013445:	748080        	extui	a8, a8, 0, 8
42013448:	043a87        	bltu	a10, a8, 42013450 <get_arg$constprop$0+0x3b8>
4201344b:	331b      	addi.n	a3, a3, 1
4201344d:	fffb86        	j	4201343f <get_arg$constprop$0+0x3a7>
42013450:	11a8      	l32i.n	a10, a1, 4
42013452:	b80c      	movi.n	a8, 11
42013454:	021a87        	beq	a10, a8, 4201345a <get_arg$constprop$0+0x3c2>
42013457:	ff21c6        	j	420130e2 <get_arg$constprop$0+0x4a>
4201345a:	2188      	l32i.n	a8, a1, 8
4201345c:	000352        	l8ui	a5, a3, 0
4201345f:	072827        	blt	a8, a2, 4201346a <get_arg$constprop$0+0x3d2>
42013462:	090c      	movi.n	a9, 0
42013464:	021597        	beq	a5, a9, 4201346a <get_arg$constprop$0+0x3d2>
42013467:	ff1246        	j	420130b4 <get_arg$constprop$0+0x1c>
4201346a:	0188      	l32i.n	a8, a1, 0
4201346c:	2198      	l32i.n	a9, a1, 8
4201346e:	839850        	moveqz	a9, a8, a5
42013471:	0199      	s32i.n	a9, a1, 0
42013473:	002646        	j	42013510 <get_arg$constprop$0+0x478>
42013476:	00          	.byte 00
42013477:	00          	.byte 00
42013478:	a05c70        	addx4	a5, a12, a7
4201347b:	0588      	l32i.n	a8, a5, 0
4201347d:	cc1b      	addi.n	a12, a12, 1
4201347f:	880b      	addi.n	a8, a8, -1
42013481:	2458      	l32i.n	a5, a4, 8
42013483:	6568f6        	bgeui	a8, 6, 420134ec <get_arg$constprop$0+0x454>
42013486:	b61a91        	l32r	a9, 42000cf0 <_stext+0xcd0>
42013489:	a08890        	addx4	a8, a8, a9
4201348c:	0888      	l32i.n	a8, a8, 0
4201348e:	0008a0        	jx	a8
42013491:	557b      	addi.n	a5, a5, 7
42013493:	1055f0        	and	a5, a5, a15
42013496:	858b      	addi.n	a8, a5, 8
42013498:	2489      	s32i.n	a8, a4, 8
4201349a:	062a87        	blt	a10, a8, 420134a4 <get_arg$constprop$0+0x40c>
4201349d:	1458      	l32i.n	a5, a4, 4
4201349f:	000286        	j	420134ad <get_arg$constprop$0+0x415>
420134a2:	00          	.byte 00
420134a3:	00          	.byte 00
420134a4:	012a57        	blt	a10, a5, 420134a9 <get_arg$constprop$0+0x411>
420134a7:	0e8d      	mov.n	a8, a14
420134a9:	0458      	l32i.n	a5, a4, 0
420134ab:	2489      	s32i.n	a8, a4, 8
420134ad:	2488      	l32i.n	a8, a4, 8
420134af:	558a      	add.n	a5, a5, a8
420134b1:	f8c552        	addi	a5, a5, -8
420134b4:	0588      	l32i.n	a8, a5, 0
420134b6:	1598      	l32i.n	a9, a5, 4
420134b8:	0b89      	s32i.n	a8, a11, 0
420134ba:	1b99      	s32i.n	a9, a11, 4
420134bc:	001806        	j	42013520 <get_arg$constprop$0+0x488>
420134bf:	557b      	addi.n	a5, a5, 7
420134c1:	1055f0        	and	a5, a5, a15
420134c4:	858b      	addi.n	a8, a5, 8
420134c6:	2489      	s32i.n	a8, a4, 8
420134c8:	042a87        	blt	a10, a8, 420134d0 <get_arg$constprop$0+0x438>
420134cb:	1458      	l32i.n	a5, a4, 4
420134cd:	000206        	j	420134d9 <get_arg$constprop$0+0x441>
420134d0:	012a57        	blt	a10, a5, 420134d5 <get_arg$constprop$0+0x43d>
420134d3:	0e8d      	mov.n	a8, a14
420134d5:	0458      	l32i.n	a5, a4, 0
420134d7:	2489      	s32i.n	a8, a4, 8
420134d9:	2488      	l32i.n	a8, a4, 8
420134db:	558a      	add.n	a5, a5, a8
420134dd:	f8c552        	addi	a5, a5, -8
420134e0:	0588      	l32i.n	a8, a5, 0
420134e2:	1598      	l32i.n	a9, a5, 4
420134e4:	0b89      	s32i.n	a8, a11, 0
420134e6:	1b99      	s32i.n	a9, a11, 4
420134e8:	000d06        	j	42013520 <get_arg$constprop$0+0x488>
420134eb:	00          	.byte 00
420134ec:	854b      	addi.n	a8, a5, 4
420134ee:	2489      	s32i.n	a8, a4, 8
420134f0:	042a87        	blt	a10, a8, 420134f8 <get_arg$constprop$0+0x460>
420134f3:	1458      	l32i.n	a5, a4, 4
420134f5:	000206        	j	42013501 <get_arg$constprop$0+0x469>
420134f8:	012a57        	blt	a10, a5, 420134fd <get_arg$constprop$0+0x465>
420134fb:	0d8d      	mov.n	a8, a13
420134fd:	0458      	l32i.n	a5, a4, 0
420134ff:	2489      	s32i.n	a8, a4, 8
42013501:	2488      	l32i.n	a8, a4, 8
42013503:	558a      	add.n	a5, a5, a8
42013505:	fcc552        	addi	a5, a5, -4
42013508:	0558      	l32i.n	a5, a5, 0
4201350a:	0b59      	s32i.n	a5, a11, 0
4201350c:	000406        	j	42013520 <get_arg$constprop$0+0x488>
4201350f:	00          	.byte 00
42013510:	b0b260        	addx8	a11, a2, a6
42013513:	02cd      	mov.n	a12, a2
42013515:	8a1c      	movi.n	a10, 24
42013517:	4d2c      	movi.n	a13, 36
42013519:	8f7c      	movi.n	a15, -8
4201351b:	8e2c      	movi.n	a14, 40
4201351d:	000046        	j	42013522 <get_arg$constprop$0+0x48a>
42013520:	bb8b      	addi.n	a11, a11, 8
42013522:	0158      	l32i.n	a5, a1, 0
42013524:	0225c7        	blt	a5, a12, 4201352a <get_arg$constprop$0+0x492>
42013527:	ffd346        	j	42013478 <get_arg$constprop$0+0x3e0>
4201352a:	551b      	addi.n	a5, a5, 1
4201352c:	040c      	movi.n	a4, 0
4201352e:	4a2527        	blt	a5, a2, 4201357c <get_arg$constprop$0+0x4e4>
42013531:	c04520        	sub	a4, a5, a2
42013534:	001106        	j	4201357c <get_arg$constprop$0+0x4e4>
42013537:	00          	.byte 00
42013538:	150c      	movi.n	a5, 1
4201353a:	020926        	beqi	a9, -1, 42013540 <get_arg$constprop$0+0x4a8>
4201353d:	ff2fc6        	j	42013200 <get_arg$constprop$0+0x168>
42013540:	ff35c6        	j	4201321b <get_arg$constprop$0+0x183>
42013543:	00          	.byte 00
42013544:	250c      	movi.n	a5, 2
42013546:	020926        	beqi	a9, -1, 4201354c <get_arg$constprop$0+0x4b4>
42013549:	ff2cc6        	j	42013200 <get_arg$constprop$0+0x168>
4201354c:	ff3f46        	j	4201324d <get_arg$constprop$0+0x1b5>
4201354f:	00          	.byte 00
42013550:	650c      	movi.n	a5, 6
42013552:	020926        	beqi	a9, -1, 42013558 <get_arg$constprop$0+0x4c0>
42013555:	ff29c6        	j	42013200 <get_arg$constprop$0+0x168>
42013558:	ff4b86        	j	4201328a <get_arg$constprop$0+0x1f2>
4201355b:	050c      	movi.n	a5, 0
4201355d:	020926        	beqi	a9, -1, 42013563 <get_arg$constprop$0+0x4cb>
42013560:	ff2706        	j	42013200 <get_arg$constprop$0+0x168>
42013563:	ff5586        	j	420132bd <get_arg$constprop$0+0x225>
42013566:	350c      	movi.n	a5, 3
42013568:	020926        	beqi	a9, -1, 4201356e <get_arg$constprop$0+0x4d6>
4201356b:	ff2446        	j	42013200 <get_arg$constprop$0+0x168>
4201356e:	ff5fc6        	j	420132f1 <get_arg$constprop$0+0x259>
42013571:	450c      	movi.n	a5, 4
42013573:	020926        	beqi	a9, -1, 42013579 <get_arg$constprop$0+0x4e1>
42013576:	ff2186        	j	42013200 <get_arg$constprop$0+0x168>
42013579:	ff6a06        	j	42013325 <get_arg$constprop$0+0x28d>
4201357c:	3188      	l32i.n	a8, a1, 12
4201357e:	424a      	add.n	a4, a2, a4
42013580:	0849      	s32i.n	a4, a8, 0
42013582:	102192        	l32i	a9, a1, 64
42013585:	2188      	l32i.n	a8, a1, 8
42013587:	0939      	s32i.n	a3, a9, 0
42013589:	b02860        	addx8	a2, a8, a6
4201358c:	f01d      	retw.n
	...

42013590 <__ssprint_r>:
42013590:	006136        	entry	a1, 48
42013593:	0458      	l32i.n	a5, a4, 0
42013595:	2468      	l32i.n	a6, a4, 8
42013597:	0159      	s32i.n	a5, a1, 0
42013599:	050c      	movi.n	a5, 0
4201359b:	2159      	s32i.n	a5, a1, 8
4201359d:	057d      	mov.n	a7, a5
4201359f:	159657        	bne	a6, a5, 420135b8 <__ssprint_r+0x28>
420135a2:	020c      	movi.n	a2, 0
420135a4:	003ac6        	j	42013693 <__ssprint_r+0x103>
420135a7:	00          	.byte 00
420135a8:	0168      	l32i.n	a6, a1, 0
420135aa:	0658      	l32i.n	a5, a6, 0
420135ac:	1678      	l32i.n	a7, a6, 4
420135ae:	668b      	addi.n	a6, a6, 8
420135b0:	0169      	s32i.n	a6, a1, 0
420135b2:	000086        	j	420135b8 <__ssprint_r+0x28>
420135b5:	00          	.byte 00
420135b6:	2178      	l32i.n	a7, a1, 8
420135b8:	23e8      	l32i.n	a14, a3, 8
420135ba:	0368      	l32i.n	a6, a3, 0
420135bc:	fe8716        	beqz	a7, 420135a8 <__ssprint_r+0x18>
420135bf:	02b7e7        	bgeu	a7, a14, 420135c5 <__ssprint_r+0x35>
420135c2:	002286        	j	42013650 <__ssprint_r+0xc0>
420135c5:	0613c2        	l16ui	a12, a3, 12
420135c8:	80a492        	movi	a9, 0x480
420135cb:	7e0c97        	bnone	a12, a9, 4201364d <__ssprint_r+0xbd>
420135ce:	43b8      	l32i.n	a11, a3, 16
420135d0:	53a8      	l32i.n	a10, a3, 20
420135d2:	c066b0        	sub	a6, a6, a11
420135d5:	1169      	s32i.n	a6, a1, 4
420135d7:	90aaa0        	addx2	a10, a10, a10
420135da:	1188      	l32i.n	a8, a1, 4
420135dc:	059fa0        	extui	a9, a10, 31, 1
420135df:	99aa      	add.n	a9, a9, a10
420135e1:	a81b      	addi.n	a10, a8, 1
420135e3:	216190        	srai	a6, a9, 1
420135e6:	aa7a      	add.n	a10, a10, a7
420135e8:	7366a0        	maxu	a6, a6, a10
420135eb:	316ca7        	bbci	a12, 10, 42013620 <__ssprint_r+0x90>
420135ee:	06bd      	mov.n	a11, a6
420135f0:	20a220        	or	a10, a2, a2
420135f3:	b55881        	l32r	a8, 42000b54 <_stext+0xb34>
420135f6:	0008e0        	callx8	a8
420135f9:	081a16        	beqz	a10, 4201367e <__ssprint_r+0xee>
420135fc:	43b8      	l32i.n	a11, a3, 16
420135fe:	11c8      	l32i.n	a12, a1, 4
42013600:	31a9      	s32i.n	a10, a1, 12
42013602:	b2f281        	l32r	a8, 420001cc <_stext+0x1ac>
42013605:	0008e0        	callx8	a8
42013608:	0613a2        	l16ui	a10, a3, 12
4201360b:	7fabb2        	movi	a11, 0xfffffb7f
4201360e:	10aab0        	and	a10, a10, a11
42013611:	80a0b2        	movi	a11, 128
42013614:	20aab0        	or	a10, a10, a11
42013617:	31e8      	l32i.n	a14, a1, 12
42013619:	0653a2        	s16i	a10, a3, 12
4201361c:	000706        	j	4201363c <__ssprint_r+0xac>
4201361f:	00          	.byte 00
42013620:	06cd      	mov.n	a12, a6
42013622:	02ad      	mov.n	a10, a2
42013624:	b55a81        	l32r	a8, 42000b8c <_stext+0xb6c>
42013627:	0008e0        	callx8	a8
4201362a:	0aed      	mov.n	a14, a10
4201362c:	cacc      	bnez.n	a10, 4201363c <__ssprint_r+0xac>
4201362e:	43b8      	l32i.n	a11, a3, 16
42013630:	02ad      	mov.n	a10, a2
42013632:	b55381        	l32r	a8, 42000b80 <_stext+0xb60>
42013635:	0008e0        	callx8	a8
42013638:	001086        	j	4201367e <__ssprint_r+0xee>
4201363b:	00          	.byte 00
4201363c:	1188      	l32i.n	a8, a1, 4
4201363e:	43e9      	s32i.n	a14, a3, 16
42013640:	c09680        	sub	a9, a6, a8
42013643:	ee8a      	add.n	a14, a14, a8
42013645:	03e9      	s32i.n	a14, a3, 0
42013647:	5369      	s32i.n	a6, a3, 20
42013649:	07ed      	mov.n	a14, a7
4201364b:	2399      	s32i.n	a9, a3, 8
4201364d:	01b7e7        	bgeu	a7, a14, 42013652 <__ssprint_r+0xc2>
42013650:	07ed      	mov.n	a14, a7
42013652:	03a8      	l32i.n	a10, a3, 0
42013654:	0ecd      	mov.n	a12, a14
42013656:	05bd      	mov.n	a11, a5
42013658:	31e9      	s32i.n	a14, a1, 12
4201365a:	b54d81        	l32r	a8, 42000b90 <_stext+0xb70>
4201365d:	0008e0        	callx8	a8
42013660:	31e8      	l32i.n	a14, a1, 12
42013662:	2368      	l32i.n	a6, a3, 8
42013664:	557a      	add.n	a5, a5, a7
42013666:	c066e0        	sub	a6, a6, a14
42013669:	2369      	s32i.n	a6, a3, 8
4201366b:	0368      	l32i.n	a6, a3, 0
4201366d:	66ea      	add.n	a6, a6, a14
4201366f:	0369      	s32i.n	a6, a3, 0
42013671:	2468      	l32i.n	a6, a4, 8
42013673:	c06670        	sub	a6, a6, a7
42013676:	2469      	s32i.n	a6, a4, 8
42013678:	f3a656        	bnez	a6, 420135b6 <__ssprint_r+0x26>
4201367b:	ffc8c6        	j	420135a2 <__ssprint_r+0x12>
4201367e:	c50c      	movi.n	a5, 12
42013680:	0259      	s32i.n	a5, a2, 0
42013682:	061322        	l16ui	a2, a3, 12
42013685:	054c      	movi.n	a5, 64
42013687:	202250        	or	a2, a2, a5
4201368a:	065322        	s16i	a2, a3, 12
4201368d:	020c      	movi.n	a2, 0
4201368f:	2429      	s32i.n	a2, a4, 8
42013691:	f27c      	movi.n	a2, -1
42013693:	030c      	movi.n	a3, 0
42013695:	1439      	s32i.n	a3, a4, 4
42013697:	f01d      	retw.n
42013699:	000000        	ill

4201369c <_svfiprintf_r>:
4201369c:	058136        	entry	a1, 0x2c0
4201369f:	9b6132        	s32i	a3, a1, 0x26c
420136a2:	9b2182        	l32i	a8, a1, 0x26c
420136a5:	9c6122        	s32i	a2, a1, 0x270
420136a8:	061822        	l16ui	a2, a8, 12
420136ab:	9a6142        	s32i	a4, a1, 0x268
420136ae:	946152        	s32i	a5, a1, 0x250
420136b1:	956162        	s32i	a6, a1, 0x254
420136b4:	966172        	s32i	a7, a1, 0x258
420136b7:	10c132        	addi	a3, a1, 16
420136ba:	2a6277        	bbci	a2, 7, 420136e8 <_svfiprintf_r+0x4c>
420136bd:	4828      	l32i.n	a2, a8, 16
420136bf:	52ec      	bnez.n	a2, 420136e8 <_svfiprintf_r+0x4c>
420136c1:	9c21a2        	l32i	a10, a1, 0x270
420136c4:	0b4c      	movi.n	a11, 64
420136c6:	b52381        	l32r	a8, 42000b54 <_stext+0xb34>
420136c9:	0008e0        	callx8	a8
420136cc:	9b2192        	l32i	a9, a1, 0x26c
420136cf:	09a9      	s32i.n	a10, a9, 0
420136d1:	49a9      	s32i.n	a10, a9, 16
420136d3:	aacc      	bnez.n	a10, 420136e1 <_svfiprintf_r+0x45>
420136d5:	9c2182        	l32i	a8, a1, 0x270
420136d8:	c20c      	movi.n	a2, 12
420136da:	0829      	s32i.n	a2, a8, 0
420136dc:	f97c      	movi.n	a9, -1
420136de:	07a0c6        	j	42015565 <_svfiprintf_r+0x1ec9>
420136e1:	9b2132        	l32i	a3, a1, 0x26c
420136e4:	024c      	movi.n	a2, 64
420136e6:	5329      	s32i.n	a2, a3, 20
420136e8:	90a162        	movi	a6, 0x190
420136eb:	10c152        	addi	a5, a1, 16
420136ee:	e4a132        	movi	a3, 0x1e4
420136f1:	661a      	add.n	a6, a6, a1
420136f3:	020c      	movi.n	a2, 0
420136f5:	353a      	add.n	a3, a5, a3
420136f7:	f47c      	movi.n	a4, -1
420136f9:	64c662        	addi	a6, a6, 100
420136fc:	446142        	s32i	a4, a1, 0x110
420136ff:	8d6132        	s32i	a3, a1, 0x234
42013702:	8f6122        	s32i	a2, a1, 0x23c
42013705:	8e6122        	s32i	a2, a1, 0x238
42013708:	906122        	s32i	a2, a1, 0x240
4201370b:	916122        	s32i	a2, a1, 0x244
4201370e:	986132        	s32i	a3, a1, 0x260
42013711:	9f6122        	s32i	a2, a1, 0x27c
42013714:	a16122        	s32i	a2, a1, 0x284
42013717:	a26122        	s32i	a2, a1, 0x288
4201371a:	a36122        	s32i	a2, a1, 0x28c
4201371d:	9e6122        	s32i	a2, a1, 0x278
42013720:	024d      	mov.n	a4, a2
42013722:	a46162        	s32i	a6, a1, 0x290
42013725:	9a2122        	l32i	a2, a1, 0x268
42013728:	000086        	j	4201372e <_svfiprintf_r+0x92>
4201372b:	00          	.byte 00
4201372c:	221b      	addi.n	a2, a2, 1
4201372e:	000232        	l8ui	a3, a2, 0
42013731:	438c      	beqz.n	a3, 42013739 <_svfiprintf_r+0x9d>
42013733:	dbc332        	addi	a3, a3, -37
42013736:	ff2356        	bnez	a3, 4201372c <_svfiprintf_r+0x90>
42013739:	9a2182        	l32i	a8, a1, 0x268
4201373c:	c05280        	sub	a5, a2, a8
4201373f:	521287        	beq	a2, a8, 42013795 <_svfiprintf_r+0xf9>
42013742:	8f2132        	l32i	a3, a1, 0x23c
42013745:	982192        	l32i	a9, a1, 0x260
42013748:	335a      	add.n	a3, a3, a5
4201374a:	8f6132        	s32i	a3, a1, 0x23c
4201374d:	8e2132        	l32i	a3, a1, 0x238
42013750:	10c1a2        	addi	a10, a1, 16
42013753:	331b      	addi.n	a3, a3, 1
42013755:	0989      	s32i.n	a8, a9, 0
42013757:	1959      	s32i.n	a5, a9, 4
42013759:	8e6132        	s32i	a3, a1, 0x238
4201375c:	02da62        	addmi	a6, a10, 0x200
4201375f:	0983e6        	bgei	a3, 8, 4201376c <_svfiprintf_r+0xd0>
42013762:	998b      	addi.n	a9, a9, 8
42013764:	986192        	s32i	a9, a1, 0x260
42013767:	000886        	j	4201378d <_svfiprintf_r+0xf1>
4201376a:	00          	.byte 00
4201376b:	00          	.byte 00
4201376c:	24a2c2        	movi	a12, 0x224
4201376f:	10c1d2        	addi	a13, a1, 16
42013772:	9b21b2        	l32i	a11, a1, 0x26c
42013775:	9c21a2        	l32i	a10, a1, 0x270
42013778:	cdca      	add.n	a12, a13, a12
4201377a:	ffe165        	call8	42013590 <__ssprint_r>
4201377d:	1a8c      	beqz.n	a10, 42013782 <_svfiprintf_r+0xe6>
4201377f:	077446        	j	42015554 <_svfiprintf_r+0x1eb8>
42013782:	e4a132        	movi	a3, 0x1e4
42013785:	10c162        	addi	a6, a1, 16
42013788:	663a      	add.n	a6, a6, a3
4201378a:	986162        	s32i	a6, a1, 0x260
4201378d:	9e2182        	l32i	a8, a1, 0x278
42013790:	885a      	add.n	a8, a8, a5
42013792:	9e6182        	s32i	a8, a1, 0x278
42013795:	000232        	l8ui	a3, a2, 0
42013798:	13cc      	bnez.n	a3, 4201379d <_svfiprintf_r+0x101>
4201379a:	076786        	j	4201553c <_svfiprintf_r+0x1ea0>
4201379d:	10c192        	addi	a9, a1, 16
420137a0:	02d932        	addmi	a3, a9, 0x200
420137a3:	060c      	movi.n	a6, 0
420137a5:	34a272        	movi	a7, 0x234
420137a8:	080c      	movi.n	a8, 0
420137aa:	3a4362        	s8i	a6, a3, 58
420137ad:	997a      	add.n	a9, a9, a7
420137af:	f67c      	movi.n	a6, -1
420137b1:	996162        	s32i	a6, a1, 0x264
420137b4:	521b      	addi.n	a5, a2, 1
420137b6:	043d      	mov.n	a3, a4
420137b8:	9d6182        	s32i	a8, a1, 0x274
420137bb:	086d      	mov.n	a6, a8
420137bd:	976182        	s32i	a8, a1, 0x25c
420137c0:	a06192        	s32i	a9, a1, 0x280
420137c3:	0001c6        	j	420137ce <_svfiprintf_r+0x132>
420137c6:	9a6172        	s32i	a7, a1, 0x268
420137c9:	060c      	movi.n	a6, 0
420137cb:	9a2152        	l32i	a5, a1, 0x268
420137ce:	851b      	addi.n	a8, a5, 1
420137d0:	9a6182        	s32i	a8, a1, 0x268
420137d3:	000552        	l8ui	a5, a5, 0
420137d6:	b549d1        	l32r	a13, 42000cfc <_stext+0xcdc>
420137d9:	080c      	movi.n	a8, 0
420137db:	990c      	movi.n	a9, 9
420137dd:	4b2c      	movi.n	a11, 36
420137df:	ac2c      	movi.n	a12, 42
420137e1:	000086        	j	420137e7 <_svfiprintf_r+0x14b>
420137e4:	9d6172        	s32i	a7, a1, 0x274
420137e7:	e0c572        	addi	a7, a5, -32
420137ea:	aa5c      	movi.n	a10, 90
420137ec:	02ba77        	bgeu	a10, a7, 420137f2 <_svfiprintf_r+0x156>
420137ef:	065846        	j	42015154 <_svfiprintf_r+0x1ab8>
420137f2:	a077d0        	addx4	a7, a7, a13
420137f5:	0778      	l32i.n	a7, a7, 0
420137f7:	0007a0        	jx	a7
420137fa:	00          	.byte 00
420137fb:	00          	.byte 00
420137fc:	9c21a2        	l32i	a10, a1, 0x270
420137ff:	201110        	or	a1, a1, a1
42013802:	fede25        	call8	420125e4 <_localeconv_r>
42013805:	1aa8      	l32i.n	a10, a10, 4
42013807:	a361a2        	s32i	a10, a1, 0x28c
4201380a:	b3a281        	l32r	a8, 42000694 <_stext+0x674>
4201380d:	0008e0        	callx8	a8
42013810:	a261a2        	s32i	a10, a1, 0x288
42013813:	9c21a2        	l32i	a10, a1, 0x270
42013816:	201110        	or	a1, a1, a1
42013819:	fedca5        	call8	420125e4 <_localeconv_r>
4201381c:	2aa8      	l32i.n	a10, a10, 8
4201381e:	a22152        	l32i	a5, a1, 0x288
42013821:	a161a2        	s32i	a10, a1, 0x284
42013824:	fa3516        	beqz	a5, 420137cb <_svfiprintf_r+0x12f>
42013827:	fa0a16        	beqz	a10, 420137cb <_svfiprintf_r+0x12f>
4201382a:	000a52        	l8ui	a5, a10, 0
4201382d:	f9a516        	beqz	a5, 420137cb <_svfiprintf_r+0x12f>
42013830:	00a452        	movi	a5, 0x400
42013833:	00b046        	j	42013af8 <_svfiprintf_r+0x45c>
42013836:	10c192        	addi	a9, a1, 16
42013839:	02d952        	addmi	a5, a9, 0x200
4201383c:	3a0572        	l8ui	a7, a5, 58
4201383f:	f88756        	bnez	a7, 420137cb <_svfiprintf_r+0x12f>
42013842:	072c      	movi.n	a7, 32
42013844:	004246        	j	42013951 <_svfiprintf_r+0x2b5>
42013847:	150c      	movi.n	a5, 1
42013849:	00aac6        	j	42013af8 <_svfiprintf_r+0x45c>
4201384c:	9a2192        	l32i	a9, a1, 0x268
4201384f:	980c      	movi.n	a8, 9
42013851:	000972        	l8ui	a7, a9, 0
42013854:	d0c752        	addi	a5, a7, -48
42013857:	02b857        	bgeu	a8, a5, 4201385d <_svfiprintf_r+0x1c1>
4201385a:	074386        	j	4201556c <_svfiprintf_r+0x1ed0>
4201385d:	591b      	addi.n	a5, a9, 1
4201385f:	0a0c      	movi.n	a10, 0
42013861:	d0c772        	addi	a7, a7, -48
42013864:	a0aaa0        	addx4	a10, a10, a10
42013867:	90aa70        	addx2	a10, a10, a7
4201386a:	000572        	l8ui	a7, a5, 0
4201386d:	551b      	addi.n	a5, a5, 1
4201386f:	d0c792        	addi	a9, a7, -48
42013872:	ebb897        	bgeu	a8, a9, 42013861 <_svfiprintf_r+0x1c5>
42013875:	482c      	movi.n	a8, 36
42013877:	021787        	beq	a7, a8, 4201387d <_svfiprintf_r+0x1e1>
4201387a:	ffd2c6        	j	420137c9 <_svfiprintf_r+0x12d>
4201387d:	072c      	movi.n	a7, 32
4201387f:	02a7a7        	bge	a7, a10, 42013885 <_svfiprintf_r+0x1e9>
42013882:	073386        	j	42015554 <_svfiprintf_r+0x1eb8>
42013885:	912172        	l32i	a7, a1, 0x244
42013888:	aa0b      	addi.n	a10, a10, -1
4201388a:	0aaa77        	bge	a10, a7, 42013898 <_svfiprintf_r+0x1fc>
4201388d:	10c1c2        	addi	a12, a1, 16
42013890:	b0aac0        	addx8	a10, a10, a12
42013893:	000746        	j	420138b4 <_svfiprintf_r+0x218>
42013896:	00          	.byte 00
42013897:	00          	.byte 00
42013898:	10c1d2        	addi	a13, a1, 16
4201389b:	30a272        	movi	a7, 0x230
4201389e:	7d7a      	add.n	a7, a13, a7
420138a0:	0ded      	mov.n	a14, a13
420138a2:	01ddf2        	addmi	a15, a13, 0x100
420138a5:	40a2c2        	movi	a12, 0x240
420138a8:	a021d2        	l32i	a13, a1, 0x280
420138ab:	0179      	s32i.n	a7, a1, 0
420138ad:	ceca      	add.n	a12, a14, a12
420138af:	02bd      	mov.n	a11, a2
420138b1:	ff7e65        	call8	42013098 <get_arg$constprop$0>
420138b4:	0aa8      	l32i.n	a10, a10, 0
420138b6:	049d      	mov.n	a9, a4
420138b8:	9d61a2        	s32i	a10, a1, 0x274
420138bb:	9a6152        	s32i	a5, a1, 0x268
420138be:	001c86        	j	42013934 <_svfiprintf_r+0x298>
420138c1:	10c1e2        	addi	a14, a1, 16
420138c4:	b043e0        	addx8	a4, a3, a14
420138c7:	001906        	j	4201392f <_svfiprintf_r+0x293>
420138ca:	10c1f2        	addi	a15, a1, 16
420138cd:	922fa2        	l32i	a10, a15, 0x248
420138d0:	fb1c      	movi.n	a11, 31
420138d2:	02df72        	addmi	a7, a15, 0x200
420138d5:	4a4b      	addi.n	a4, a10, 4
420138d7:	881c      	movi.n	a8, 24
420138d9:	332b57        	blt	a11, a5, 42013910 <_svfiprintf_r+0x274>
420138dc:	b51b      	addi.n	a11, a5, 1
420138de:	9161b2        	s32i	a11, a1, 0x244
420138e1:	126742        	s32i	a4, a7, 72
420138e4:	052847        	blt	a8, a4, 420138ed <_svfiprintf_r+0x251>
420138e7:	112742        	l32i	a4, a7, 68
420138ea:	000286        	j	420138f8 <_svfiprintf_r+0x25c>
420138ed:	0128a7        	blt	a8, a10, 420138f2 <_svfiprintf_r+0x256>
420138f0:	442c      	movi.n	a4, 36
420138f2:	966142        	s32i	a4, a1, 0x258
420138f5:	942142        	l32i	a4, a1, 0x250
420138f8:	962172        	l32i	a7, a1, 0x258
420138fb:	10c1a2        	addi	a10, a1, 16
420138fe:	447a      	add.n	a4, a4, a7
42013900:	fcc442        	addi	a4, a4, -4
42013903:	0448      	l32i.n	a4, a4, 0
42013905:	b055a0        	addx8	a5, a5, a10
42013908:	9d6142        	s32i	a4, a1, 0x274
4201390b:	0549      	s32i.n	a4, a5, 0
4201390d:	0008c6        	j	42013934 <_svfiprintf_r+0x298>
42013910:	126742        	s32i	a4, a7, 72
42013913:	052847        	blt	a8, a4, 4201391c <_svfiprintf_r+0x280>
42013916:	112742        	l32i	a4, a7, 68
42013919:	000286        	j	42013927 <_svfiprintf_r+0x28b>
4201391c:	0128a7        	blt	a8, a10, 42013921 <_svfiprintf_r+0x285>
4201391f:	442c      	movi.n	a4, 36
42013921:	966142        	s32i	a4, a1, 0x258
42013924:	942142        	l32i	a4, a1, 0x250
42013927:	962152        	l32i	a5, a1, 0x258
4201392a:	445a      	add.n	a4, a4, a5
4201392c:	fcc442        	addi	a4, a4, -4
4201392f:	0448      	l32i.n	a4, a4, 0
42013931:	9d6142        	s32i	a4, a1, 0x274
42013934:	9d2152        	l32i	a5, a1, 0x274
42013937:	094d      	mov.n	a4, a9
42013939:	e8e5d6        	bgez	a5, 420137cb <_svfiprintf_r+0x12f>
4201393c:	605050        	neg	a5, a5
4201393f:	9d6152        	s32i	a5, a1, 0x274
42013942:	450c      	movi.n	a5, 4
42013944:	006c06        	j	42013af8 <_svfiprintf_r+0x45c>
42013947:	00          	.byte 00
42013948:	00          	.byte 00
42013949:	10c192        	addi	a9, a1, 16
4201394c:	b72c      	movi.n	a7, 43
4201394e:	02d952        	addmi	a5, a9, 0x200
42013951:	3a4572        	s8i	a7, a5, 58
42013954:	ff9cc6        	j	420137cb <_svfiprintf_r+0x12f>
42013957:	9a21a2        	l32i	a10, a1, 0x268
4201395a:	000a52        	l8ui	a5, a10, 0
4201395d:	7a1b      	addi.n	a7, a10, 1
4201395f:	0515c7        	beq	a5, a12, 42013968 <_svfiprintf_r+0x2cc>
42013962:	996182        	s32i	a8, a1, 0x264
42013965:	004146        	j	42013a6e <_svfiprintf_r+0x3d2>
42013968:	9a2192        	l32i	a9, a1, 0x268
4201396b:	010982        	l8ui	a8, a9, 1
4201396e:	990c      	movi.n	a9, 9
42013970:	d0c852        	addi	a5, a8, -48
42013973:	02b957        	bgeu	a9, a5, 42013979 <_svfiprintf_r+0x2dd>
42013976:	070086        	j	4201557c <_svfiprintf_r+0x1ee0>
42013979:	9a21a2        	l32i	a10, a1, 0x268
4201397c:	5a2b      	addi.n	a5, a10, 2
4201397e:	0a0c      	movi.n	a10, 0
42013980:	d0c882        	addi	a8, a8, -48
42013983:	a0aaa0        	addx4	a10, a10, a10
42013986:	90aa80        	addx2	a10, a10, a8
42013989:	000582        	l8ui	a8, a5, 0
4201398c:	551b      	addi.n	a5, a5, 1
4201398e:	d0c8b2        	addi	a11, a8, -48
42013991:	ebb9b7        	bgeu	a9, a11, 42013980 <_svfiprintf_r+0x2e4>
42013994:	492c      	movi.n	a9, 36
42013996:	021897        	beq	a8, a9, 4201399c <_svfiprintf_r+0x300>
42013999:	ff8a46        	j	420137c6 <_svfiprintf_r+0x12a>
4201399c:	072c      	movi.n	a7, 32
4201399e:	02a7a7        	bge	a7, a10, 420139a4 <_svfiprintf_r+0x308>
420139a1:	06ebc6        	j	42015554 <_svfiprintf_r+0x1eb8>
420139a4:	912172        	l32i	a7, a1, 0x244
420139a7:	aa0b      	addi.n	a10, a10, -1
420139a9:	08aa77        	bge	a10, a7, 420139b5 <_svfiprintf_r+0x319>
420139ac:	10c1c2        	addi	a12, a1, 16
420139af:	b0aac0        	addx8	a10, a10, a12
420139b2:	0006c6        	j	420139d1 <_svfiprintf_r+0x335>
420139b5:	10c1d2        	addi	a13, a1, 16
420139b8:	30a272        	movi	a7, 0x230
420139bb:	7d7a      	add.n	a7, a13, a7
420139bd:	0ded      	mov.n	a14, a13
420139bf:	01ddf2        	addmi	a15, a13, 0x100
420139c2:	40a2c2        	movi	a12, 0x240
420139c5:	a021d2        	l32i	a13, a1, 0x280
420139c8:	0179      	s32i.n	a7, a1, 0
420139ca:	ceca      	add.n	a12, a14, a12
420139cc:	02bd      	mov.n	a11, a2
420139ce:	ff6ca5        	call8	42013098 <get_arg$constprop$0>
420139d1:	0a88      	l32i.n	a8, a10, 0
420139d3:	057d      	mov.n	a7, a5
420139d5:	049d      	mov.n	a9, a4
420139d7:	001c86        	j	42013a4d <_svfiprintf_r+0x3b1>
420139da:	00          	.byte 00
420139db:	00          	.byte 00
420139dc:	10c1e2        	addi	a14, a1, 16
420139df:	b043e0        	addx8	a4, a3, a14
420139e2:	001946        	j	42013a4b <_svfiprintf_r+0x3af>
420139e5:	10c1f2        	addi	a15, a1, 16
420139e8:	922fa2        	l32i	a10, a15, 0x248
420139eb:	fb1c      	movi.n	a11, 31
420139ed:	02df82        	addmi	a8, a15, 0x200
420139f0:	4a4b      	addi.n	a4, a10, 4
420139f2:	322b57        	blt	a11, a5, 42013a28 <_svfiprintf_r+0x38c>
420139f5:	b51b      	addi.n	a11, a5, 1
420139f7:	9161b2        	s32i	a11, a1, 0x244
420139fa:	126842        	s32i	a4, a8, 72
420139fd:	8b1c      	movi.n	a11, 24
420139ff:	052b47        	blt	a11, a4, 42013a08 <_svfiprintf_r+0x36c>
42013a02:	112842        	l32i	a4, a8, 68
42013a05:	000286        	j	42013a13 <_svfiprintf_r+0x377>
42013a08:	012ba7        	blt	a11, a10, 42013a0d <_svfiprintf_r+0x371>
42013a0b:	442c      	movi.n	a4, 36
42013a0d:	966142        	s32i	a4, a1, 0x258
42013a10:	942142        	l32i	a4, a1, 0x250
42013a13:	962182        	l32i	a8, a1, 0x258
42013a16:	10c1c2        	addi	a12, a1, 16
42013a19:	448a      	add.n	a4, a4, a8
42013a1b:	fcc442        	addi	a4, a4, -4
42013a1e:	0488      	l32i.n	a8, a4, 0
42013a20:	b055c0        	addx8	a5, a5, a12
42013a23:	0589      	s32i.n	a8, a5, 0
42013a25:	000906        	j	42013a4d <_svfiprintf_r+0x3b1>
42013a28:	126842        	s32i	a4, a8, 72
42013a2b:	851c      	movi.n	a5, 24
42013a2d:	072547        	blt	a5, a4, 42013a38 <_svfiprintf_r+0x39c>
42013a30:	112842        	l32i	a4, a8, 68
42013a33:	000306        	j	42013a43 <_svfiprintf_r+0x3a7>
42013a36:	00          	.byte 00
42013a37:	00          	.byte 00
42013a38:	0125a7        	blt	a5, a10, 42013a3d <_svfiprintf_r+0x3a1>
42013a3b:	442c      	movi.n	a4, 36
42013a3d:	966142        	s32i	a4, a1, 0x258
42013a40:	942142        	l32i	a4, a1, 0x250
42013a43:	962152        	l32i	a5, a1, 0x258
42013a46:	445a      	add.n	a4, a4, a5
42013a48:	fcc442        	addi	a4, a4, -4
42013a4b:	0488      	l32i.n	a8, a4, 0
42013a4d:	f47c      	movi.n	a4, -1
42013a4f:	534840        	max	a4, a8, a4
42013a52:	996142        	s32i	a4, a1, 0x264
42013a55:	9a6172        	s32i	a7, a1, 0x268
42013a58:	094d      	mov.n	a4, a9
42013a5a:	ff5b46        	j	420137cb <_svfiprintf_r+0x12f>
42013a5d:	9921e2        	l32i	a14, a1, 0x264
42013a60:	a05ee0        	addx4	a5, a14, a14
42013a63:	9055a0        	addx2	a5, a5, a10
42013a66:	996152        	s32i	a5, a1, 0x264
42013a69:	000752        	l8ui	a5, a7, 0
42013a6c:	771b      	addi.n	a7, a7, 1
42013a6e:	9a6172        	s32i	a7, a1, 0x268
42013a71:	d0c5a2        	addi	a10, a5, -48
42013a74:	e5b9a7        	bgeu	a9, a10, 42013a5d <_svfiprintf_r+0x3c1>
42013a77:	9d2172        	l32i	a7, a1, 0x274
42013a7a:	ff5986        	j	420137e4 <_svfiprintf_r+0x148>
42013a7d:	80a052        	movi	a5, 128
42013a80:	001d06        	j	42013af8 <_svfiprintf_r+0x45c>
42013a83:	087d      	mov.n	a7, a8
42013a85:	d0c552        	addi	a5, a5, -48
42013a88:	a07770        	addx4	a7, a7, a7
42013a8b:	907750        	addx2	a7, a7, a5
42013a8e:	9a2152        	l32i	a5, a1, 0x268
42013a91:	9a21a2        	l32i	a10, a1, 0x268
42013a94:	000552        	l8ui	a5, a5, 0
42013a97:	aa1b      	addi.n	a10, a10, 1
42013a99:	9a61a2        	s32i	a10, a1, 0x268
42013a9c:	d0c5a2        	addi	a10, a5, -48
42013a9f:	e2b9a7        	bgeu	a9, a10, 42013a85 <_svfiprintf_r+0x3e9>
42013aa2:	0215b7        	beq	a5, a11, 42013aa8 <_svfiprintf_r+0x40c>
42013aa5:	ff4ec6        	j	420137e4 <_svfiprintf_r+0x148>
42013aa8:	032c      	movi.n	a3, 32
42013aaa:	02a377        	bge	a3, a7, 42013ab0 <_svfiprintf_r+0x414>
42013aad:	06a8c6        	j	42015554 <_svfiprintf_r+0x1eb8>
42013ab0:	370b      	addi.n	a3, a7, -1
42013ab2:	160c      	movi.n	a6, 1
42013ab4:	ff44c6        	j	420137cb <_svfiprintf_r+0x12f>
42013ab7:	9a2182        	l32i	a8, a1, 0x268
42013aba:	68a052        	movi	a5, 104
42013abd:	000872        	l8ui	a7, a8, 0
42013ac0:	0a9757        	bne	a7, a5, 42013ace <_svfiprintf_r+0x432>
42013ac3:	881b      	addi.n	a8, a8, 1
42013ac5:	9a6182        	s32i	a8, a1, 0x268
42013ac8:	00a252        	movi	a5, 0x200
42013acb:	0006c6        	j	42013aea <_svfiprintf_r+0x44e>
42013ace:	054c      	movi.n	a5, 64
42013ad0:	000906        	j	42013af8 <_svfiprintf_r+0x45c>
42013ad3:	00          	.byte 00
42013ad4:	9a2192        	l32i	a9, a1, 0x268
42013ad7:	6ca052        	movi	a5, 108
42013ada:	000972        	l8ui	a7, a9, 0
42013add:	079757        	bne	a7, a5, 42013ae8 <_svfiprintf_r+0x44c>
42013ae0:	991b      	addi.n	a9, a9, 1
42013ae2:	9a6192        	s32i	a9, a1, 0x268
42013ae5:	000346        	j	42013af6 <_svfiprintf_r+0x45a>
42013ae8:	051c      	movi.n	a5, 16
42013aea:	972192        	l32i	a9, a1, 0x25c
42013aed:	209950        	or	a9, a9, a5
42013af0:	976192        	s32i	a9, a1, 0x25c
42013af3:	ff3506        	j	420137cb <_svfiprintf_r+0x12f>
42013af6:	052c      	movi.n	a5, 32
42013af8:	972182        	l32i	a8, a1, 0x25c
42013afb:	208850        	or	a8, a8, a5
42013afe:	976182        	s32i	a8, a1, 0x25c
42013b01:	ff3186        	j	420137cb <_svfiprintf_r+0x12f>
42013b04:	912152        	l32i	a5, a1, 0x244
42013b07:	56bc      	beqz.n	a6, 42013b40 <_svfiprintf_r+0x4a4>
42013b09:	0ba357        	bge	a3, a5, 42013b18 <_svfiprintf_r+0x47c>
42013b0c:	10c192        	addi	a9, a1, 16
42013b0f:	b03390        	addx8	a3, a3, a9
42013b12:	000332        	l8ui	a3, a3, 0
42013b15:	000886        	j	42013b3b <_svfiprintf_r+0x49f>
42013b18:	10c1a2        	addi	a10, a1, 16
42013b1b:	30a252        	movi	a5, 0x230
42013b1e:	5a5a      	add.n	a5, a10, a5
42013b20:	34a2d2        	movi	a13, 0x234
42013b23:	40a2c2        	movi	a12, 0x240
42013b26:	01daf2        	addmi	a15, a10, 0x100
42013b29:	0aed      	mov.n	a14, a10
42013b2b:	dada      	add.n	a13, a10, a13
42013b2d:	caca      	add.n	a12, a10, a12
42013b2f:	0159      	s32i.n	a5, a1, 0
42013b31:	03ad      	mov.n	a10, a3
42013b33:	02bd      	mov.n	a11, a2
42013b35:	ff5625        	call8	42013098 <get_arg$constprop$0>
42013b38:	000a32        	l8ui	a3, a10, 0
42013b3b:	042d      	mov.n	a2, a4
42013b3d:	001d86        	j	42013bb7 <_svfiprintf_r+0x51b>
42013b40:	10c1c2        	addi	a12, a1, 16
42013b43:	241b      	addi.n	a2, a4, 1
42013b45:	b033c0        	addx8	a3, a3, a12
42013b48:	682457        	blt	a4, a5, 42013bb4 <_svfiprintf_r+0x518>
42013b4b:	10c1d2        	addi	a13, a1, 16
42013b4e:	922d72        	l32i	a7, a13, 0x248
42013b51:	f81c      	movi.n	a8, 31
42013b53:	02dd42        	addmi	a4, a13, 0x200
42013b56:	374b      	addi.n	a3, a7, 4
42013b58:	861c      	movi.n	a6, 24
42013b5a:	352857        	blt	a8, a5, 42013b93 <_svfiprintf_r+0x4f7>
42013b5d:	851b      	addi.n	a8, a5, 1
42013b5f:	916182        	s32i	a8, a1, 0x244
42013b62:	126432        	s32i	a3, a4, 72
42013b65:	072637        	blt	a6, a3, 42013b70 <_svfiprintf_r+0x4d4>
42013b68:	112432        	l32i	a3, a4, 68
42013b6b:	000306        	j	42013b7b <_svfiprintf_r+0x4df>
42013b6e:	00          	.byte 00
42013b6f:	00          	.byte 00
42013b70:	012677        	blt	a6, a7, 42013b75 <_svfiprintf_r+0x4d9>
42013b73:	432c      	movi.n	a3, 36
42013b75:	966132        	s32i	a3, a1, 0x258
42013b78:	942132        	l32i	a3, a1, 0x250
42013b7b:	962142        	l32i	a4, a1, 0x258
42013b7e:	10c1f2        	addi	a15, a1, 16
42013b81:	334a      	add.n	a3, a3, a4
42013b83:	fcc332        	addi	a3, a3, -4
42013b86:	0338      	l32i.n	a3, a3, 0
42013b88:	b045f0        	addx8	a4, a5, a15
42013b8b:	0439      	s32i.n	a3, a4, 0
42013b8d:	743030        	extui	a3, a3, 0, 8
42013b90:	0008c6        	j	42013bb7 <_svfiprintf_r+0x51b>
42013b93:	126432        	s32i	a3, a4, 72
42013b96:	062637        	blt	a6, a3, 42013ba0 <_svfiprintf_r+0x504>
42013b99:	112432        	l32i	a3, a4, 68
42013b9c:	0002c6        	j	42013bab <_svfiprintf_r+0x50f>
42013b9f:	00          	.byte 00
42013ba0:	012677        	blt	a6, a7, 42013ba5 <_svfiprintf_r+0x509>
42013ba3:	432c      	movi.n	a3, 36
42013ba5:	966132        	s32i	a3, a1, 0x258
42013ba8:	942132        	l32i	a3, a1, 0x250
42013bab:	962142        	l32i	a4, a1, 0x258
42013bae:	803340        	add	a3, a3, a4
42013bb1:	fcc332        	addi	a3, a3, -4
42013bb4:	000332        	l8ui	a3, a3, 0
42013bb7:	10c162        	addi	a6, a1, 16
42013bba:	01d642        	addmi	a4, a6, 0x100
42013bbd:	804432        	s8i	a3, a4, 128
42013bc0:	180c      	movi.n	a8, 1
42013bc2:	040c      	movi.n	a4, 0
42013bc4:	02d632        	addmi	a3, a6, 0x200
42013bc7:	90a192        	movi	a9, 0x190
42013bca:	3a4342        	s8i	a4, a3, 58
42013bcd:	996182        	s32i	a8, a1, 0x264
42013bd0:	040c      	movi.n	a4, 0
42013bd2:	319a      	add.n	a3, a1, a9
42013bd4:	056846        	j	42015179 <_svfiprintf_r+0x1add>
42013bd7:	972182        	l32i	a8, a1, 0x25c
42013bda:	051c      	movi.n	a5, 16
42013bdc:	208850        	or	a8, a8, a5
42013bdf:	976182        	s32i	a8, a1, 0x25c
42013be2:	972192        	l32i	a9, a1, 0x25c
42013be5:	912152        	l32i	a5, a1, 0x244
42013be8:	02e957        	bbsi	a9, 5, 42013bee <_svfiprintf_r+0x552>
42013beb:	002f46        	j	42013cac <_svfiprintf_r+0x610>
42013bee:	76bc      	beqz.n	a6, 42013c29 <_svfiprintf_r+0x58d>
42013bf0:	0ca357        	bge	a3, a5, 42013c00 <_svfiprintf_r+0x564>
42013bf3:	10c1a2        	addi	a10, a1, 16
42013bf6:	b033a0        	addx8	a3, a3, a10
42013bf9:	0368      	l32i.n	a6, a3, 0
42013bfb:	1378      	l32i.n	a7, a3, 4
42013bfd:	0008c6        	j	42013c24 <_svfiprintf_r+0x588>
42013c00:	10c1c2        	addi	a12, a1, 16
42013c03:	30a252        	movi	a5, 0x230
42013c06:	34a2d2        	movi	a13, 0x234
42013c09:	0ced      	mov.n	a14, a12
42013c0b:	5c5a      	add.n	a5, a12, a5
42013c0d:	01dcf2        	addmi	a15, a12, 0x100
42013c10:	dcda      	add.n	a13, a12, a13
42013c12:	40a2c2        	movi	a12, 0x240
42013c15:	0159      	s32i.n	a5, a1, 0
42013c17:	ceca      	add.n	a12, a14, a12
42013c19:	02bd      	mov.n	a11, a2
42013c1b:	03ad      	mov.n	a10, a3
42013c1d:	ff47a5        	call8	42013098 <get_arg$constprop$0>
42013c20:	0a68      	l32i.n	a6, a10, 0
42013c22:	1a78      	l32i.n	a7, a10, 4
42013c24:	042d      	mov.n	a2, a4
42013c26:	00cac6        	j	42013f55 <_svfiprintf_r+0x8b9>
42013c29:	10c1d2        	addi	a13, a1, 16
42013c2c:	241b      	addi.n	a2, a4, 1
42013c2e:	b033d0        	addx8	a3, a3, a13
42013c31:	6f2457        	blt	a4, a5, 42013ca4 <_svfiprintf_r+0x608>
42013c34:	10c1e2        	addi	a14, a1, 16
42013c37:	922e42        	l32i	a4, a14, 0x248
42013c3a:	837c      	movi.n	a3, -8
42013c3c:	447b      	addi.n	a4, a4, 7
42013c3e:	104430        	and	a4, a4, a3
42013c41:	f81c      	movi.n	a8, 31
42013c43:	02de62        	addmi	a6, a14, 0x200
42013c46:	348b      	addi.n	a3, a4, 8
42013c48:	871c      	movi.n	a7, 24
42013c4a:	362857        	blt	a8, a5, 42013c84 <_svfiprintf_r+0x5e8>
42013c4d:	851b      	addi.n	a8, a5, 1
42013c4f:	916182        	s32i	a8, a1, 0x244
42013c52:	126632        	s32i	a3, a6, 72
42013c55:	072737        	blt	a7, a3, 42013c60 <_svfiprintf_r+0x5c4>
42013c58:	112632        	l32i	a3, a6, 68
42013c5b:	000306        	j	42013c6b <_svfiprintf_r+0x5cf>
42013c5e:	00          	.byte 00
42013c5f:	00          	.byte 00
42013c60:	012747        	blt	a7, a4, 42013c65 <_svfiprintf_r+0x5c9>
42013c63:	832c      	movi.n	a3, 40
42013c65:	966132        	s32i	a3, a1, 0x258
42013c68:	942132        	l32i	a3, a1, 0x250
42013c6b:	962142        	l32i	a4, a1, 0x258
42013c6e:	334a      	add.n	a3, a3, a4
42013c70:	f8c332        	addi	a3, a3, -8
42013c73:	0368      	l32i.n	a6, a3, 0
42013c75:	1378      	l32i.n	a7, a3, 4
42013c77:	10c132        	addi	a3, a1, 16
42013c7a:	b05530        	addx8	a5, a5, a3
42013c7d:	0569      	s32i.n	a6, a5, 0
42013c7f:	1579      	s32i.n	a7, a5, 4
42013c81:	00b406        	j	42013f55 <_svfiprintf_r+0x8b9>
42013c84:	126632        	s32i	a3, a6, 72
42013c87:	052737        	blt	a7, a3, 42013c90 <_svfiprintf_r+0x5f4>
42013c8a:	112632        	l32i	a3, a6, 68
42013c8d:	000286        	j	42013c9b <_svfiprintf_r+0x5ff>
42013c90:	012747        	blt	a7, a4, 42013c95 <_svfiprintf_r+0x5f9>
42013c93:	832c      	movi.n	a3, 40
42013c95:	966132        	s32i	a3, a1, 0x258
42013c98:	942132        	l32i	a3, a1, 0x250
42013c9b:	962142        	l32i	a4, a1, 0x258
42013c9e:	803340        	add	a3, a3, a4
42013ca1:	f8c332        	addi	a3, a3, -8
42013ca4:	0368      	l32i.n	a6, a3, 0
42013ca6:	1378      	l32i.n	a7, a3, 4
42013ca8:	00aa46        	j	42013f55 <_svfiprintf_r+0x8b9>
42013cab:	00          	.byte 00
42013cac:	972182        	l32i	a8, a1, 0x25c
42013caf:	756847        	bbci	a8, 4, 42013d28 <_svfiprintf_r+0x68c>
42013cb2:	e69c      	beqz.n	a6, 42013cd4 <_svfiprintf_r+0x638>
42013cb4:	08a357        	bge	a3, a5, 42013cc0 <_svfiprintf_r+0x624>
42013cb7:	10c192        	addi	a9, a1, 16
42013cba:	b03390        	addx8	a3, a3, a9
42013cbd:	007cc6        	j	42013eb4 <_svfiprintf_r+0x818>
42013cc0:	10c1a2        	addi	a10, a1, 16
42013cc3:	30a252        	movi	a5, 0x230
42013cc6:	5a5a      	add.n	a5, a10, a5
42013cc8:	0159      	s32i.n	a5, a1, 0
42013cca:	01daf2        	addmi	a15, a10, 0x100
42013ccd:	0aed      	mov.n	a14, a10
42013ccf:	007d46        	j	42013ec8 <_svfiprintf_r+0x82c>
42013cd2:	00          	.byte 00
42013cd3:	00          	.byte 00
42013cd4:	10c1c2        	addi	a12, a1, 16
42013cd7:	241b      	addi.n	a2, a4, 1
42013cd9:	b033c0        	addx8	a3, a3, a12
42013cdc:	02a457        	bge	a4, a5, 42013ce2 <_svfiprintf_r+0x646>
42013cdf:	009b46        	j	42013f50 <_svfiprintf_r+0x8b4>
42013ce2:	10c1d2        	addi	a13, a1, 16
42013ce5:	922d72        	l32i	a7, a13, 0x248
42013ce8:	f81c      	movi.n	a8, 31
42013cea:	02dd42        	addmi	a4, a13, 0x200
42013ced:	374b      	addi.n	a3, a7, 4
42013cef:	861c      	movi.n	a6, 24
42013cf1:	02a857        	bge	a8, a5, 42013cf7 <_svfiprintf_r+0x65b>
42013cf4:	008e06        	j	42013f30 <_svfiprintf_r+0x894>
42013cf7:	851b      	addi.n	a8, a5, 1
42013cf9:	916182        	s32i	a8, a1, 0x244
42013cfc:	126432        	s32i	a3, a4, 72
42013cff:	052637        	blt	a6, a3, 42013d08 <_svfiprintf_r+0x66c>
42013d02:	112432        	l32i	a3, a4, 68
42013d05:	000286        	j	42013d13 <_svfiprintf_r+0x677>
42013d08:	012677        	blt	a6, a7, 42013d0d <_svfiprintf_r+0x671>
42013d0b:	432c      	movi.n	a3, 36
42013d0d:	966132        	s32i	a3, a1, 0x258
42013d10:	942132        	l32i	a3, a1, 0x250
42013d13:	962142        	l32i	a4, a1, 0x258
42013d16:	10c1f2        	addi	a15, a1, 16
42013d19:	334a      	add.n	a3, a3, a4
42013d1b:	fcc332        	addi	a3, a3, -4
42013d1e:	0368      	l32i.n	a6, a3, 0
42013d20:	b055f0        	addx8	a5, a5, a15
42013d23:	008106        	j	42013f2b <_svfiprintf_r+0x88f>
42013d26:	00          	.byte 00
42013d27:	00          	.byte 00
42013d28:	972182        	l32i	a8, a1, 0x25c
42013d2b:	02e867        	bbsi	a8, 6, 42013d31 <_svfiprintf_r+0x695>
42013d2e:	002d86        	j	42013de8 <_svfiprintf_r+0x74c>
42013d31:	76bc      	beqz.n	a6, 42013d6c <_svfiprintf_r+0x6d0>
42013d33:	0da357        	bge	a3, a5, 42013d44 <_svfiprintf_r+0x6a8>
42013d36:	10c192        	addi	a9, a1, 16
42013d39:	b03390        	addx8	a3, a3, a9
42013d3c:	009362        	l16si	a6, a3, 0
42013d3f:	006606        	j	42013edb <_svfiprintf_r+0x83f>
42013d42:	00          	.byte 00
42013d43:	00          	.byte 00
42013d44:	10c1a2        	addi	a10, a1, 16
42013d47:	30a252        	movi	a5, 0x230
42013d4a:	5a5a      	add.n	a5, a10, a5
42013d4c:	34a2d2        	movi	a13, 0x234
42013d4f:	40a2c2        	movi	a12, 0x240
42013d52:	01daf2        	addmi	a15, a10, 0x100
42013d55:	0aed      	mov.n	a14, a10
42013d57:	dada      	add.n	a13, a10, a13
42013d59:	caca      	add.n	a12, a10, a12
42013d5b:	0159      	s32i.n	a5, a1, 0
42013d5d:	02bd      	mov.n	a11, a2
42013d5f:	03ad      	mov.n	a10, a3
42013d61:	ff3365        	call8	42013098 <get_arg$constprop$0>
42013d64:	009a62        	l16si	a6, a10, 0
42013d67:	005c06        	j	42013edb <_svfiprintf_r+0x83f>
42013d6a:	00          	.byte 00
42013d6b:	00          	.byte 00
42013d6c:	10c1c2        	addi	a12, a1, 16
42013d6f:	241b      	addi.n	a2, a4, 1
42013d71:	b033c0        	addx8	a3, a3, a12
42013d74:	682457        	blt	a4, a5, 42013de0 <_svfiprintf_r+0x744>
42013d77:	10c1d2        	addi	a13, a1, 16
42013d7a:	922d72        	l32i	a7, a13, 0x248
42013d7d:	f81c      	movi.n	a8, 31
42013d7f:	02dd42        	addmi	a4, a13, 0x200
42013d82:	374b      	addi.n	a3, a7, 4
42013d84:	861c      	movi.n	a6, 24
42013d86:	362857        	blt	a8, a5, 42013dc0 <_svfiprintf_r+0x724>
42013d89:	851b      	addi.n	a8, a5, 1
42013d8b:	916182        	s32i	a8, a1, 0x244
42013d8e:	126432        	s32i	a3, a4, 72
42013d91:	072637        	blt	a6, a3, 42013d9c <_svfiprintf_r+0x700>
42013d94:	112432        	l32i	a3, a4, 68
42013d97:	000306        	j	42013da7 <_svfiprintf_r+0x70b>
42013d9a:	00          	.byte 00
42013d9b:	00          	.byte 00
42013d9c:	012677        	blt	a6, a7, 42013da1 <_svfiprintf_r+0x705>
42013d9f:	432c      	movi.n	a3, 36
42013da1:	966132        	s32i	a3, a1, 0x258
42013da4:	942132        	l32i	a3, a1, 0x250
42013da7:	962142        	l32i	a4, a1, 0x258
42013daa:	10c1f2        	addi	a15, a1, 16
42013dad:	334a      	add.n	a3, a3, a4
42013daf:	fcc332        	addi	a3, a3, -4
42013db2:	0368      	l32i.n	a6, a3, 0
42013db4:	b055f0        	addx8	a5, a5, a15
42013db7:	0569      	s32i.n	a6, a5, 0
42013db9:	236680        	sext	a6, a6, 15
42013dbc:	006486        	j	42013f52 <_svfiprintf_r+0x8b6>
42013dbf:	00          	.byte 00
42013dc0:	126432        	s32i	a3, a4, 72
42013dc3:	052637        	blt	a6, a3, 42013dcc <_svfiprintf_r+0x730>
42013dc6:	112432        	l32i	a3, a4, 68
42013dc9:	000286        	j	42013dd7 <_svfiprintf_r+0x73b>
42013dcc:	012677        	blt	a6, a7, 42013dd1 <_svfiprintf_r+0x735>
42013dcf:	432c      	movi.n	a3, 36
42013dd1:	966132        	s32i	a3, a1, 0x258
42013dd4:	942132        	l32i	a3, a1, 0x250
42013dd7:	962142        	l32i	a4, a1, 0x258
42013dda:	803340        	add	a3, a3, a4
42013ddd:	fcc332        	addi	a3, a3, -4
42013de0:	009362        	l16si	a6, a3, 0
42013de3:	005ac6        	j	42013f52 <_svfiprintf_r+0x8b6>
42013de6:	00          	.byte 00
42013de7:	00          	.byte 00
42013de8:	972182        	l32i	a8, a1, 0x25c
42013deb:	02e897        	bbsi	a8, 9, 42013df1 <_svfiprintf_r+0x755>
42013dee:	002dc6        	j	42013ea9 <_svfiprintf_r+0x80d>
42013df1:	76bc      	beqz.n	a6, 42013e2c <_svfiprintf_r+0x790>
42013df3:	0da357        	bge	a3, a5, 42013e04 <_svfiprintf_r+0x768>
42013df6:	10c192        	addi	a9, a1, 16
42013df9:	b03390        	addx8	a3, a3, a9
42013dfc:	000362        	l8ui	a6, a3, 0
42013dff:	000906        	j	42013e27 <_svfiprintf_r+0x78b>
42013e02:	00          	.byte 00
42013e03:	00          	.byte 00
42013e04:	10c1a2        	addi	a10, a1, 16
42013e07:	30a252        	movi	a5, 0x230
42013e0a:	5a5a      	add.n	a5, a10, a5
42013e0c:	34a2d2        	movi	a13, 0x234
42013e0f:	40a2c2        	movi	a12, 0x240
42013e12:	01daf2        	addmi	a15, a10, 0x100
42013e15:	0aed      	mov.n	a14, a10
42013e17:	dada      	add.n	a13, a10, a13
42013e19:	caca      	add.n	a12, a10, a12
42013e1b:	0159      	s32i.n	a5, a1, 0
42013e1d:	02bd      	mov.n	a11, a2
42013e1f:	03ad      	mov.n	a10, a3
42013e21:	ff2765        	call8	42013098 <get_arg$constprop$0>
42013e24:	000a62        	l8ui	a6, a10, 0
42013e27:	042d      	mov.n	a2, a4
42013e29:	001d86        	j	42013ea3 <_svfiprintf_r+0x807>
42013e2c:	10c1c2        	addi	a12, a1, 16
42013e2f:	241b      	addi.n	a2, a4, 1
42013e31:	b033c0        	addx8	a3, a3, a12
42013e34:	682457        	blt	a4, a5, 42013ea0 <_svfiprintf_r+0x804>
42013e37:	10c1d2        	addi	a13, a1, 16
42013e3a:	922d72        	l32i	a7, a13, 0x248
42013e3d:	f81c      	movi.n	a8, 31
42013e3f:	02dd42        	addmi	a4, a13, 0x200
42013e42:	374b      	addi.n	a3, a7, 4
42013e44:	861c      	movi.n	a6, 24
42013e46:	352857        	blt	a8, a5, 42013e7f <_svfiprintf_r+0x7e3>
42013e49:	851b      	addi.n	a8, a5, 1
42013e4b:	916182        	s32i	a8, a1, 0x244
42013e4e:	126432        	s32i	a3, a4, 72
42013e51:	072637        	blt	a6, a3, 42013e5c <_svfiprintf_r+0x7c0>
42013e54:	112432        	l32i	a3, a4, 68
42013e57:	000306        	j	42013e67 <_svfiprintf_r+0x7cb>
42013e5a:	00          	.byte 00
42013e5b:	00          	.byte 00
42013e5c:	012677        	blt	a6, a7, 42013e61 <_svfiprintf_r+0x7c5>
42013e5f:	432c      	movi.n	a3, 36
42013e61:	966132        	s32i	a3, a1, 0x258
42013e64:	942132        	l32i	a3, a1, 0x250
42013e67:	962142        	l32i	a4, a1, 0x258
42013e6a:	10c1f2        	addi	a15, a1, 16
42013e6d:	334a      	add.n	a3, a3, a4
42013e6f:	fcc332        	addi	a3, a3, -4
42013e72:	0368      	l32i.n	a6, a3, 0
42013e74:	b055f0        	addx8	a5, a5, a15
42013e77:	0569      	s32i.n	a6, a5, 0
42013e79:	746060        	extui	a6, a6, 0, 8
42013e7c:	0008c6        	j	42013ea3 <_svfiprintf_r+0x807>
42013e7f:	126432        	s32i	a3, a4, 72
42013e82:	062637        	blt	a6, a3, 42013e8c <_svfiprintf_r+0x7f0>
42013e85:	112432        	l32i	a3, a4, 68
42013e88:	0002c6        	j	42013e97 <_svfiprintf_r+0x7fb>
42013e8b:	00          	.byte 00
42013e8c:	012677        	blt	a6, a7, 42013e91 <_svfiprintf_r+0x7f5>
42013e8f:	432c      	movi.n	a3, 36
42013e91:	966132        	s32i	a3, a1, 0x258
42013e94:	942132        	l32i	a3, a1, 0x250
42013e97:	962142        	l32i	a4, a1, 0x258
42013e9a:	803340        	add	a3, a3, a4
42013e9d:	fcc332        	addi	a3, a3, -4
42013ea0:	000362        	l8ui	a6, a3, 0
42013ea3:	236600        	sext	a6, a6, 7
42013ea6:	002a06        	j	42013f52 <_svfiprintf_r+0x8b6>
42013ea9:	36bc      	beqz.n	a6, 42013ee0 <_svfiprintf_r+0x844>
42013eab:	0aa357        	bge	a3, a5, 42013eb9 <_svfiprintf_r+0x81d>
42013eae:	10c162        	addi	a6, a1, 16
42013eb1:	b03360        	addx8	a3, a3, a6
42013eb4:	0368      	l32i.n	a6, a3, 0
42013eb6:	000846        	j	42013edb <_svfiprintf_r+0x83f>
42013eb9:	10c182        	addi	a8, a1, 16
42013ebc:	30a252        	movi	a5, 0x230
42013ebf:	585a      	add.n	a5, a8, a5
42013ec1:	0159      	s32i.n	a5, a1, 0
42013ec3:	01d8f2        	addmi	a15, a8, 0x100
42013ec6:	08ed      	mov.n	a14, a8
42013ec8:	34a2d2        	movi	a13, 0x234
42013ecb:	40a2c2        	movi	a12, 0x240
42013ece:	deda      	add.n	a13, a14, a13
42013ed0:	ceca      	add.n	a12, a14, a12
42013ed2:	02bd      	mov.n	a11, a2
42013ed4:	03ad      	mov.n	a10, a3
42013ed6:	ff1c25        	call8	42013098 <get_arg$constprop$0>
42013ed9:	0a68      	l32i.n	a6, a10, 0
42013edb:	042d      	mov.n	a2, a4
42013edd:	001c46        	j	42013f52 <_svfiprintf_r+0x8b6>
42013ee0:	10c192        	addi	a9, a1, 16
42013ee3:	241b      	addi.n	a2, a4, 1
42013ee5:	b03390        	addx8	a3, a3, a9
42013ee8:	642457        	blt	a4, a5, 42013f50 <_svfiprintf_r+0x8b4>
42013eeb:	10c1a2        	addi	a10, a1, 16
42013eee:	922a72        	l32i	a7, a10, 0x248
42013ef1:	f81c      	movi.n	a8, 31
42013ef3:	02da42        	addmi	a4, a10, 0x200
42013ef6:	374b      	addi.n	a3, a7, 4
42013ef8:	861c      	movi.n	a6, 24
42013efa:	322857        	blt	a8, a5, 42013f30 <_svfiprintf_r+0x894>
42013efd:	851b      	addi.n	a8, a5, 1
42013eff:	916182        	s32i	a8, a1, 0x244
42013f02:	126432        	s32i	a3, a4, 72
42013f05:	072637        	blt	a6, a3, 42013f10 <_svfiprintf_r+0x874>
42013f08:	112432        	l32i	a3, a4, 68
42013f0b:	000306        	j	42013f1b <_svfiprintf_r+0x87f>
42013f0e:	00          	.byte 00
42013f0f:	00          	.byte 00
42013f10:	012677        	blt	a6, a7, 42013f15 <_svfiprintf_r+0x879>
42013f13:	432c      	movi.n	a3, 36
42013f15:	966132        	s32i	a3, a1, 0x258
42013f18:	942132        	l32i	a3, a1, 0x250
42013f1b:	962142        	l32i	a4, a1, 0x258
42013f1e:	10c1d2        	addi	a13, a1, 16
42013f21:	334a      	add.n	a3, a3, a4
42013f23:	fcc332        	addi	a3, a3, -4
42013f26:	0368      	l32i.n	a6, a3, 0
42013f28:	b055d0        	addx8	a5, a5, a13
42013f2b:	0569      	s32i.n	a6, a5, 0
42013f2d:	000846        	j	42013f52 <_svfiprintf_r+0x8b6>
42013f30:	126432        	s32i	a3, a4, 72
42013f33:	052637        	blt	a6, a3, 42013f3c <_svfiprintf_r+0x8a0>
42013f36:	112432        	l32i	a3, a4, 68
42013f39:	000286        	j	42013f47 <_svfiprintf_r+0x8ab>
42013f3c:	012677        	blt	a6, a7, 42013f41 <_svfiprintf_r+0x8a5>
42013f3f:	432c      	movi.n	a3, 36
42013f41:	966132        	s32i	a3, a1, 0x258
42013f44:	942132        	l32i	a3, a1, 0x250
42013f47:	962142        	l32i	a4, a1, 0x258
42013f4a:	803340        	add	a3, a3, a4
42013f4d:	fcc332        	addi	a3, a3, -4
42013f50:	0368      	l32i.n	a6, a3, 0
42013f52:	317f60        	srai	a7, a6, 31
42013f55:	002796        	bltz	a7, 42013f5b <_svfiprintf_r+0x8bf>
42013f58:	058c06        	j	4201558c <_svfiprintf_r+0x1ef0>
42013f5b:	606060        	neg	a6, a6
42013f5e:	140c      	movi.n	a4, 1
42013f60:	030c      	movi.n	a3, 0
42013f62:	933460        	movnez	a3, a4, a6
42013f65:	607070        	neg	a7, a7
42013f68:	c07730        	sub	a7, a7, a3
42013f6b:	d32c      	movi.n	a3, 45
42013f6d:	041046        	j	42014fb2 <_svfiprintf_r+0x1916>
42013f70:	972182        	l32i	a8, a1, 0x25c
42013f73:	912152        	l32i	a5, a1, 0x244
42013f76:	02e857        	bbsi	a8, 5, 42013f7c <_svfiprintf_r+0x8e0>
42013f79:	002ec6        	j	42014038 <_svfiprintf_r+0x99c>
42013f7c:	46bc      	beqz.n	a6, 42013fb4 <_svfiprintf_r+0x918>
42013f7e:	0aa357        	bge	a3, a5, 42013f8c <_svfiprintf_r+0x8f0>
42013f81:	10c192        	addi	a9, a1, 16
42013f84:	b03390        	addx8	a3, a3, a9
42013f87:	0328      	l32i.n	a2, a3, 0
42013f89:	000846        	j	42013fae <_svfiprintf_r+0x912>
42013f8c:	10c1a2        	addi	a10, a1, 16
42013f8f:	30a252        	movi	a5, 0x230
42013f92:	5a5a      	add.n	a5, a10, a5
42013f94:	34a2d2        	movi	a13, 0x234
42013f97:	40a2c2        	movi	a12, 0x240
42013f9a:	01daf2        	addmi	a15, a10, 0x100
42013f9d:	0aed      	mov.n	a14, a10
42013f9f:	dada      	add.n	a13, a10, a13
42013fa1:	caca      	add.n	a12, a10, a12
42013fa3:	02bd      	mov.n	a11, a2
42013fa5:	0159      	s32i.n	a5, a1, 0
42013fa7:	03ad      	mov.n	a10, a3
42013fa9:	ff0ee5        	call8	42013098 <get_arg$constprop$0>
42013fac:	0a28      	l32i.n	a2, a10, 0
42013fae:	046d      	mov.n	a6, a4
42013fb0:	001d46        	j	42014029 <_svfiprintf_r+0x98d>
42013fb3:	00          	.byte 00
42013fb4:	641b      	addi.n	a6, a4, 1
42013fb6:	0aa457        	bge	a4, a5, 42013fc4 <_svfiprintf_r+0x928>
42013fb9:	10c1c2        	addi	a12, a1, 16
42013fbc:	b033c0        	addx8	a3, a3, a12
42013fbf:	0328      	l32i.n	a2, a3, 0
42013fc1:	001906        	j	42014029 <_svfiprintf_r+0x98d>
42013fc4:	10c1d2        	addi	a13, a1, 16
42013fc7:	922d72        	l32i	a7, a13, 0x248
42013fca:	f81c      	movi.n	a8, 31
42013fcc:	02dd32        	addmi	a3, a13, 0x200
42013fcf:	274b      	addi.n	a2, a7, 4
42013fd1:	841c      	movi.n	a4, 24
42013fd3:	312857        	blt	a8, a5, 42014008 <_svfiprintf_r+0x96c>
42013fd6:	851b      	addi.n	a8, a5, 1
42013fd8:	916182        	s32i	a8, a1, 0x244
42013fdb:	126322        	s32i	a2, a3, 72
42013fde:	062427        	blt	a4, a2, 42013fe8 <_svfiprintf_r+0x94c>
42013fe1:	112322        	l32i	a2, a3, 68
42013fe4:	0002c6        	j	42013ff3 <_svfiprintf_r+0x957>
42013fe7:	00          	.byte 00
42013fe8:	012477        	blt	a4, a7, 42013fed <_svfiprintf_r+0x951>
42013feb:	422c      	movi.n	a2, 36
42013fed:	966122        	s32i	a2, a1, 0x258
42013ff0:	942122        	l32i	a2, a1, 0x250
42013ff3:	962132        	l32i	a3, a1, 0x258
42013ff6:	10c1f2        	addi	a15, a1, 16
42013ff9:	223a      	add.n	a2, a2, a3
42013ffb:	fcc222        	addi	a2, a2, -4
42013ffe:	0228      	l32i.n	a2, a2, 0
42014000:	b055f0        	addx8	a5, a5, a15
42014003:	0529      	s32i.n	a2, a5, 0
42014005:	000806        	j	42014029 <_svfiprintf_r+0x98d>
42014008:	126322        	s32i	a2, a3, 72
4201400b:	052427        	blt	a4, a2, 42014014 <_svfiprintf_r+0x978>
4201400e:	112322        	l32i	a2, a3, 68
42014011:	000286        	j	4201401f <_svfiprintf_r+0x983>
42014014:	012477        	blt	a4, a7, 42014019 <_svfiprintf_r+0x97d>
42014017:	422c      	movi.n	a2, 36
42014019:	966122        	s32i	a2, a1, 0x258
4201401c:	942122        	l32i	a2, a1, 0x250
4201401f:	962132        	l32i	a3, a1, 0x258
42014022:	223a      	add.n	a2, a2, a3
42014024:	fcc222        	addi	a2, a2, -4
42014027:	0228      	l32i.n	a2, a2, 0
42014029:	9e2152        	l32i	a5, a1, 0x278
4201402c:	313f50        	srai	a3, a5, 31
4201402f:	0259      	s32i.n	a5, a2, 0
42014031:	1239      	s32i.n	a3, a2, 4
42014033:	00bcc6        	j	4201432a <_svfiprintf_r+0xc8e>
42014036:	00          	.byte 00
42014037:	00          	.byte 00
42014038:	972182        	l32i	a8, a1, 0x25c
4201403b:	02e847        	bbsi	a8, 4, 42014041 <_svfiprintf_r+0x9a5>
4201403e:	002cc6        	j	420140f5 <_svfiprintf_r+0xa59>
42014041:	36bc      	beqz.n	a6, 42014078 <_svfiprintf_r+0x9dc>
42014043:	0aa357        	bge	a3, a5, 42014051 <_svfiprintf_r+0x9b5>
42014046:	10c192        	addi	a9, a1, 16
42014049:	b03390        	addx8	a3, a3, a9
4201404c:	0328      	l32i.n	a2, a3, 0
4201404e:	000846        	j	42014073 <_svfiprintf_r+0x9d7>
42014051:	10c1a2        	addi	a10, a1, 16
42014054:	30a252        	movi	a5, 0x230
42014057:	5a5a      	add.n	a5, a10, a5
42014059:	34a2d2        	movi	a13, 0x234
4201405c:	40a2c2        	movi	a12, 0x240
4201405f:	01daf2        	addmi	a15, a10, 0x100
42014062:	0aed      	mov.n	a14, a10
42014064:	dada      	add.n	a13, a10, a13
42014066:	caca      	add.n	a12, a10, a12
42014068:	02bd      	mov.n	a11, a2
4201406a:	0159      	s32i.n	a5, a1, 0
4201406c:	03ad      	mov.n	a10, a3
4201406e:	ff02a5        	call8	42013098 <get_arg$constprop$0>
42014071:	0a28      	l32i.n	a2, a10, 0
42014073:	046d      	mov.n	a6, a4
42014075:	001d06        	j	420140ed <_svfiprintf_r+0xa51>
42014078:	641b      	addi.n	a6, a4, 1
4201407a:	0aa457        	bge	a4, a5, 42014088 <_svfiprintf_r+0x9ec>
4201407d:	10c1c2        	addi	a12, a1, 16
42014080:	b033c0        	addx8	a3, a3, a12
42014083:	0328      	l32i.n	a2, a3, 0
42014085:	001906        	j	420140ed <_svfiprintf_r+0xa51>
42014088:	10c1d2        	addi	a13, a1, 16
4201408b:	922d72        	l32i	a7, a13, 0x248
4201408e:	f81c      	movi.n	a8, 31
42014090:	02dd32        	addmi	a3, a13, 0x200
42014093:	274b      	addi.n	a2, a7, 4
42014095:	841c      	movi.n	a4, 24
42014097:	312857        	blt	a8, a5, 420140cc <_svfiprintf_r+0xa30>
4201409a:	851b      	addi.n	a8, a5, 1
4201409c:	916182        	s32i	a8, a1, 0x244
4201409f:	126322        	s32i	a2, a3, 72
420140a2:	062427        	blt	a4, a2, 420140ac <_svfiprintf_r+0xa10>
420140a5:	112322        	l32i	a2, a3, 68
420140a8:	0002c6        	j	420140b7 <_svfiprintf_r+0xa1b>
420140ab:	00          	.byte 00
420140ac:	012477        	blt	a4, a7, 420140b1 <_svfiprintf_r+0xa15>
420140af:	422c      	movi.n	a2, 36
420140b1:	966122        	s32i	a2, a1, 0x258
420140b4:	942122        	l32i	a2, a1, 0x250
420140b7:	962132        	l32i	a3, a1, 0x258
420140ba:	10c1f2        	addi	a15, a1, 16
420140bd:	223a      	add.n	a2, a2, a3
420140bf:	fcc222        	addi	a2, a2, -4
420140c2:	0228      	l32i.n	a2, a2, 0
420140c4:	b055f0        	addx8	a5, a5, a15
420140c7:	0529      	s32i.n	a2, a5, 0
420140c9:	000806        	j	420140ed <_svfiprintf_r+0xa51>
420140cc:	126322        	s32i	a2, a3, 72
420140cf:	052427        	blt	a4, a2, 420140d8 <_svfiprintf_r+0xa3c>
420140d2:	112322        	l32i	a2, a3, 68
420140d5:	000286        	j	420140e3 <_svfiprintf_r+0xa47>
420140d8:	012477        	blt	a4, a7, 420140dd <_svfiprintf_r+0xa41>
420140db:	422c      	movi.n	a2, 36
420140dd:	966122        	s32i	a2, a1, 0x258
420140e0:	942122        	l32i	a2, a1, 0x250
420140e3:	962132        	l32i	a3, a1, 0x258
420140e6:	223a      	add.n	a2, a2, a3
420140e8:	fcc222        	addi	a2, a2, -4
420140eb:	0228      	l32i.n	a2, a2, 0
420140ed:	9e2152        	l32i	a5, a1, 0x278
420140f0:	0259      	s32i.n	a5, a2, 0
420140f2:	008d06        	j	4201432a <_svfiprintf_r+0xc8e>
420140f5:	972182        	l32i	a8, a1, 0x25c
420140f8:	02e867        	bbsi	a8, 6, 420140fe <_svfiprintf_r+0xa62>
420140fb:	002e46        	j	420141b8 <_svfiprintf_r+0xb1c>
420140fe:	66bc      	beqz.n	a6, 42014138 <_svfiprintf_r+0xa9c>
42014100:	0ca357        	bge	a3, a5, 42014110 <_svfiprintf_r+0xa74>
42014103:	10c192        	addi	a9, a1, 16
42014106:	b03390        	addx8	a3, a3, a9
42014109:	0328      	l32i.n	a2, a3, 0
4201410b:	0008c6        	j	42014132 <_svfiprintf_r+0xa96>
4201410e:	00          	.byte 00
4201410f:	00          	.byte 00
42014110:	10c1a2        	addi	a10, a1, 16
42014113:	30a252        	movi	a5, 0x230
42014116:	5a5a      	add.n	a5, a10, a5
42014118:	34a2d2        	movi	a13, 0x234
4201411b:	40a2c2        	movi	a12, 0x240
4201411e:	01daf2        	addmi	a15, a10, 0x100
42014121:	0aed      	mov.n	a14, a10
42014123:	dada      	add.n	a13, a10, a13
42014125:	caca      	add.n	a12, a10, a12
42014127:	02bd      	mov.n	a11, a2
42014129:	0159      	s32i.n	a5, a1, 0
4201412b:	03ad      	mov.n	a10, a3
4201412d:	fef6a5        	call8	42013098 <get_arg$constprop$0>
42014130:	0a28      	l32i.n	a2, a10, 0
42014132:	046d      	mov.n	a6, a4
42014134:	001d46        	j	420141ad <_svfiprintf_r+0xb11>
42014137:	00          	.byte 00
42014138:	641b      	addi.n	a6, a4, 1
4201413a:	0aa457        	bge	a4, a5, 42014148 <_svfiprintf_r+0xaac>
4201413d:	10c1c2        	addi	a12, a1, 16
42014140:	b033c0        	addx8	a3, a3, a12
42014143:	0328      	l32i.n	a2, a3, 0
42014145:	001906        	j	420141ad <_svfiprintf_r+0xb11>
42014148:	10c1d2        	addi	a13, a1, 16
4201414b:	922d72        	l32i	a7, a13, 0x248
4201414e:	f81c      	movi.n	a8, 31
42014150:	02dd32        	addmi	a3, a13, 0x200
42014153:	274b      	addi.n	a2, a7, 4
42014155:	841c      	movi.n	a4, 24
42014157:	312857        	blt	a8, a5, 4201418c <_svfiprintf_r+0xaf0>
4201415a:	851b      	addi.n	a8, a5, 1
4201415c:	916182        	s32i	a8, a1, 0x244
4201415f:	126322        	s32i	a2, a3, 72
42014162:	062427        	blt	a4, a2, 4201416c <_svfiprintf_r+0xad0>
42014165:	112322        	l32i	a2, a3, 68
42014168:	0002c6        	j	42014177 <_svfiprintf_r+0xadb>
4201416b:	00          	.byte 00
4201416c:	012477        	blt	a4, a7, 42014171 <_svfiprintf_r+0xad5>
4201416f:	422c      	movi.n	a2, 36
42014171:	966122        	s32i	a2, a1, 0x258
42014174:	942122        	l32i	a2, a1, 0x250
42014177:	962132        	l32i	a3, a1, 0x258
4201417a:	10c1f2        	addi	a15, a1, 16
4201417d:	223a      	add.n	a2, a2, a3
4201417f:	fcc222        	addi	a2, a2, -4
42014182:	0228      	l32i.n	a2, a2, 0
42014184:	b055f0        	addx8	a5, a5, a15
42014187:	0529      	s32i.n	a2, a5, 0
42014189:	000806        	j	420141ad <_svfiprintf_r+0xb11>
4201418c:	126322        	s32i	a2, a3, 72
4201418f:	052427        	blt	a4, a2, 42014198 <_svfiprintf_r+0xafc>
42014192:	112322        	l32i	a2, a3, 68
42014195:	000286        	j	420141a3 <_svfiprintf_r+0xb07>
42014198:	012477        	blt	a4, a7, 4201419d <_svfiprintf_r+0xb01>
4201419b:	422c      	movi.n	a2, 36
4201419d:	966122        	s32i	a2, a1, 0x258
420141a0:	942122        	l32i	a2, a1, 0x250
420141a3:	962132        	l32i	a3, a1, 0x258
420141a6:	223a      	add.n	a2, a2, a3
420141a8:	fcc222        	addi	a2, a2, -4
420141ab:	0228      	l32i.n	a2, a2, 0
420141ad:	9e2152        	l32i	a5, a1, 0x278
420141b0:	005252        	s16i	a5, a2, 0
420141b3:	005cc6        	j	4201432a <_svfiprintf_r+0xc8e>
420141b6:	00          	.byte 00
420141b7:	00          	.byte 00
420141b8:	972182        	l32i	a8, a1, 0x25c
420141bb:	02e897        	bbsi	a8, 9, 420141c1 <_svfiprintf_r+0xb25>
420141be:	002d06        	j	42014276 <_svfiprintf_r+0xbda>
420141c1:	36bc      	beqz.n	a6, 420141f8 <_svfiprintf_r+0xb5c>
420141c3:	0aa357        	bge	a3, a5, 420141d1 <_svfiprintf_r+0xb35>
420141c6:	10c192        	addi	a9, a1, 16
420141c9:	b03390        	addx8	a3, a3, a9
420141cc:	0328      	l32i.n	a2, a3, 0
420141ce:	000846        	j	420141f3 <_svfiprintf_r+0xb57>
420141d1:	10c1a2        	addi	a10, a1, 16
420141d4:	30a252        	movi	a5, 0x230
420141d7:	5a5a      	add.n	a5, a10, a5
420141d9:	34a2d2        	movi	a13, 0x234
420141dc:	40a2c2        	movi	a12, 0x240
420141df:	01daf2        	addmi	a15, a10, 0x100
420141e2:	0aed      	mov.n	a14, a10
420141e4:	dada      	add.n	a13, a10, a13
420141e6:	caca      	add.n	a12, a10, a12
420141e8:	02bd      	mov.n	a11, a2
420141ea:	0159      	s32i.n	a5, a1, 0
420141ec:	03ad      	mov.n	a10, a3
420141ee:	feeaa5        	call8	42013098 <get_arg$constprop$0>
420141f1:	0a28      	l32i.n	a2, a10, 0
420141f3:	046d      	mov.n	a6, a4
420141f5:	001d06        	j	4201426d <_svfiprintf_r+0xbd1>
420141f8:	641b      	addi.n	a6, a4, 1
420141fa:	0aa457        	bge	a4, a5, 42014208 <_svfiprintf_r+0xb6c>
420141fd:	10c1c2        	addi	a12, a1, 16
42014200:	b033c0        	addx8	a3, a3, a12
42014203:	0328      	l32i.n	a2, a3, 0
42014205:	001906        	j	4201426d <_svfiprintf_r+0xbd1>
42014208:	10c1d2        	addi	a13, a1, 16
4201420b:	922d72        	l32i	a7, a13, 0x248
4201420e:	f81c      	movi.n	a8, 31
42014210:	02dd32        	addmi	a3, a13, 0x200
42014213:	274b      	addi.n	a2, a7, 4
42014215:	841c      	movi.n	a4, 24
42014217:	312857        	blt	a8, a5, 4201424c <_svfiprintf_r+0xbb0>
4201421a:	851b      	addi.n	a8, a5, 1
4201421c:	916182        	s32i	a8, a1, 0x244
4201421f:	126322        	s32i	a2, a3, 72
42014222:	052427        	blt	a4, a2, 4201422b <_svfiprintf_r+0xb8f>
42014225:	112322        	l32i	a2, a3, 68
42014228:	000286        	j	42014236 <_svfiprintf_r+0xb9a>
4201422b:	012477        	blt	a4, a7, 42014230 <_svfiprintf_r+0xb94>
4201422e:	422c      	movi.n	a2, 36
42014230:	966122        	s32i	a2, a1, 0x258
42014233:	942122        	l32i	a2, a1, 0x250
42014236:	962132        	l32i	a3, a1, 0x258
42014239:	10c1f2        	addi	a15, a1, 16
4201423c:	223a      	add.n	a2, a2, a3
4201423e:	fcc222        	addi	a2, a2, -4
42014241:	0228      	l32i.n	a2, a2, 0
42014243:	b055f0        	addx8	a5, a5, a15
42014246:	0529      	s32i.n	a2, a5, 0
42014248:	000846        	j	4201426d <_svfiprintf_r+0xbd1>
4201424b:	00          	.byte 00
4201424c:	126322        	s32i	a2, a3, 72
4201424f:	052427        	blt	a4, a2, 42014258 <_svfiprintf_r+0xbbc>
42014252:	112322        	l32i	a2, a3, 68
42014255:	000286        	j	42014263 <_svfiprintf_r+0xbc7>
42014258:	012477        	blt	a4, a7, 4201425d <_svfiprintf_r+0xbc1>
4201425b:	422c      	movi.n	a2, 36
4201425d:	966122        	s32i	a2, a1, 0x258
42014260:	942122        	l32i	a2, a1, 0x250
42014263:	962132        	l32i	a3, a1, 0x258
42014266:	223a      	add.n	a2, a2, a3
42014268:	fcc222        	addi	a2, a2, -4
4201426b:	0228      	l32i.n	a2, a2, 0
4201426d:	9e2152        	l32i	a5, a1, 0x278
42014270:	004252        	s8i	a5, a2, 0
42014273:	002cc6        	j	4201432a <_svfiprintf_r+0xc8e>
42014276:	66bc      	beqz.n	a6, 420142b0 <_svfiprintf_r+0xc14>
42014278:	0ca357        	bge	a3, a5, 42014288 <_svfiprintf_r+0xbec>
4201427b:	10c162        	addi	a6, a1, 16
4201427e:	b03360        	addx8	a3, a3, a6
42014281:	0328      	l32i.n	a2, a3, 0
42014283:	0008c6        	j	420142aa <_svfiprintf_r+0xc0e>
42014286:	00          	.byte 00
42014287:	00          	.byte 00
42014288:	10c182        	addi	a8, a1, 16
4201428b:	30a252        	movi	a5, 0x230
4201428e:	585a      	add.n	a5, a8, a5
42014290:	34a2d2        	movi	a13, 0x234
42014293:	40a2c2        	movi	a12, 0x240
42014296:	02bd      	mov.n	a11, a2
42014298:	0159      	s32i.n	a5, a1, 0
4201429a:	01d8f2        	addmi	a15, a8, 0x100
4201429d:	08ed      	mov.n	a14, a8
4201429f:	d8da      	add.n	a13, a8, a13
420142a1:	c8ca      	add.n	a12, a8, a12
420142a3:	03ad      	mov.n	a10, a3
420142a5:	fedf25        	call8	42013098 <get_arg$constprop$0>
420142a8:	0a28      	l32i.n	a2, a10, 0
420142aa:	046d      	mov.n	a6, a4
420142ac:	001d46        	j	42014325 <_svfiprintf_r+0xc89>
420142af:	00          	.byte 00
420142b0:	641b      	addi.n	a6, a4, 1
420142b2:	0aa457        	bge	a4, a5, 420142c0 <_svfiprintf_r+0xc24>
420142b5:	10c192        	addi	a9, a1, 16
420142b8:	b03390        	addx8	a3, a3, a9
420142bb:	0328      	l32i.n	a2, a3, 0
420142bd:	001906        	j	42014325 <_svfiprintf_r+0xc89>
420142c0:	10c1a2        	addi	a10, a1, 16
420142c3:	922a72        	l32i	a7, a10, 0x248
420142c6:	f81c      	movi.n	a8, 31
420142c8:	02da32        	addmi	a3, a10, 0x200
420142cb:	274b      	addi.n	a2, a7, 4
420142cd:	841c      	movi.n	a4, 24
420142cf:	312857        	blt	a8, a5, 42014304 <_svfiprintf_r+0xc68>
420142d2:	851b      	addi.n	a8, a5, 1
420142d4:	916182        	s32i	a8, a1, 0x244
420142d7:	126322        	s32i	a2, a3, 72
420142da:	062427        	blt	a4, a2, 420142e4 <_svfiprintf_r+0xc48>
420142dd:	112322        	l32i	a2, a3, 68
420142e0:	0002c6        	j	420142ef <_svfiprintf_r+0xc53>
420142e3:	00          	.byte 00
420142e4:	012477        	blt	a4, a7, 420142e9 <_svfiprintf_r+0xc4d>
420142e7:	422c      	movi.n	a2, 36
420142e9:	966122        	s32i	a2, a1, 0x258
420142ec:	942122        	l32i	a2, a1, 0x250
420142ef:	962132        	l32i	a3, a1, 0x258
420142f2:	10c1d2        	addi	a13, a1, 16
420142f5:	223a      	add.n	a2, a2, a3
420142f7:	fcc222        	addi	a2, a2, -4
420142fa:	0228      	l32i.n	a2, a2, 0
420142fc:	b055d0        	addx8	a5, a5, a13
420142ff:	0529      	s32i.n	a2, a5, 0
42014301:	000806        	j	42014325 <_svfiprintf_r+0xc89>
42014304:	126322        	s32i	a2, a3, 72
42014307:	052427        	blt	a4, a2, 42014310 <_svfiprintf_r+0xc74>
4201430a:	112322        	l32i	a2, a3, 68
4201430d:	000286        	j	4201431b <_svfiprintf_r+0xc7f>
42014310:	012477        	blt	a4, a7, 42014315 <_svfiprintf_r+0xc79>
42014313:	422c      	movi.n	a2, 36
42014315:	966122        	s32i	a2, a1, 0x258
42014318:	942122        	l32i	a2, a1, 0x250
4201431b:	962132        	l32i	a3, a1, 0x258
4201431e:	223a      	add.n	a2, a2, a3
42014320:	fcc222        	addi	a2, a2, -4
42014323:	0228      	l32i.n	a2, a2, 0
42014325:	9e2132        	l32i	a3, a1, 0x278
42014328:	0239      	s32i.n	a3, a2, 0
4201432a:	064d      	mov.n	a4, a6
4201432c:	fcfd46        	j	42013725 <_svfiprintf_r+0x89>
4201432f:	972182        	l32i	a8, a1, 0x25c
42014332:	051c      	movi.n	a5, 16
42014334:	208850        	or	a8, a8, a5
42014337:	976182        	s32i	a8, a1, 0x25c
4201433a:	972192        	l32i	a9, a1, 0x25c
4201433d:	912152        	l32i	a5, a1, 0x244
42014340:	02e957        	bbsi	a9, 5, 42014346 <_svfiprintf_r+0xcaa>
42014343:	002f46        	j	42014404 <_svfiprintf_r+0xd68>
42014346:	76bc      	beqz.n	a6, 42014381 <_svfiprintf_r+0xce5>
42014348:	0ca357        	bge	a3, a5, 42014358 <_svfiprintf_r+0xcbc>
4201434b:	10c1a2        	addi	a10, a1, 16
4201434e:	b033a0        	addx8	a3, a3, a10
42014351:	0368      	l32i.n	a6, a3, 0
42014353:	1378      	l32i.n	a7, a3, 4
42014355:	0008c6        	j	4201437c <_svfiprintf_r+0xce0>
42014358:	10c1c2        	addi	a12, a1, 16
4201435b:	30a252        	movi	a5, 0x230
4201435e:	34a2d2        	movi	a13, 0x234
42014361:	0ced      	mov.n	a14, a12
42014363:	5c5a      	add.n	a5, a12, a5
42014365:	01dcf2        	addmi	a15, a12, 0x100
42014368:	dcda      	add.n	a13, a12, a13
4201436a:	40a2c2        	movi	a12, 0x240
4201436d:	0159      	s32i.n	a5, a1, 0
4201436f:	ceca      	add.n	a12, a14, a12
42014371:	02bd      	mov.n	a11, a2
42014373:	03ad      	mov.n	a10, a3
42014375:	fed225        	call8	42013098 <get_arg$constprop$0>
42014378:	0a68      	l32i.n	a6, a10, 0
4201437a:	1a78      	l32i.n	a7, a10, 4
4201437c:	042d      	mov.n	a2, a4
4201437e:	00c886        	j	420146a4 <_svfiprintf_r+0x1008>
42014381:	10c1d2        	addi	a13, a1, 16
42014384:	241b      	addi.n	a2, a4, 1
42014386:	b033d0        	addx8	a3, a3, a13
42014389:	6f2457        	blt	a4, a5, 420143fc <_svfiprintf_r+0xd60>
4201438c:	10c1e2        	addi	a14, a1, 16
4201438f:	922e42        	l32i	a4, a14, 0x248
42014392:	837c      	movi.n	a3, -8
42014394:	447b      	addi.n	a4, a4, 7
42014396:	104430        	and	a4, a4, a3
42014399:	f81c      	movi.n	a8, 31
4201439b:	02de62        	addmi	a6, a14, 0x200
4201439e:	348b      	addi.n	a3, a4, 8
420143a0:	871c      	movi.n	a7, 24
420143a2:	362857        	blt	a8, a5, 420143dc <_svfiprintf_r+0xd40>
420143a5:	851b      	addi.n	a8, a5, 1
420143a7:	916182        	s32i	a8, a1, 0x244
420143aa:	126632        	s32i	a3, a6, 72
420143ad:	072737        	blt	a7, a3, 420143b8 <_svfiprintf_r+0xd1c>
420143b0:	112632        	l32i	a3, a6, 68
420143b3:	000306        	j	420143c3 <_svfiprintf_r+0xd27>
420143b6:	00          	.byte 00
420143b7:	00          	.byte 00
420143b8:	012747        	blt	a7, a4, 420143bd <_svfiprintf_r+0xd21>
420143bb:	832c      	movi.n	a3, 40
420143bd:	966132        	s32i	a3, a1, 0x258
420143c0:	942132        	l32i	a3, a1, 0x250
420143c3:	962142        	l32i	a4, a1, 0x258
420143c6:	334a      	add.n	a3, a3, a4
420143c8:	f8c332        	addi	a3, a3, -8
420143cb:	0368      	l32i.n	a6, a3, 0
420143cd:	1378      	l32i.n	a7, a3, 4
420143cf:	10c132        	addi	a3, a1, 16
420143d2:	b05530        	addx8	a5, a5, a3
420143d5:	0569      	s32i.n	a6, a5, 0
420143d7:	1579      	s32i.n	a7, a5, 4
420143d9:	00b1c6        	j	420146a4 <_svfiprintf_r+0x1008>
420143dc:	126632        	s32i	a3, a6, 72
420143df:	052737        	blt	a7, a3, 420143e8 <_svfiprintf_r+0xd4c>
420143e2:	112632        	l32i	a3, a6, 68
420143e5:	000286        	j	420143f3 <_svfiprintf_r+0xd57>
420143e8:	012747        	blt	a7, a4, 420143ed <_svfiprintf_r+0xd51>
420143eb:	832c      	movi.n	a3, 40
420143ed:	966132        	s32i	a3, a1, 0x258
420143f0:	942132        	l32i	a3, a1, 0x250
420143f3:	962142        	l32i	a4, a1, 0x258
420143f6:	803340        	add	a3, a3, a4
420143f9:	f8c332        	addi	a3, a3, -8
420143fc:	0368      	l32i.n	a6, a3, 0
420143fe:	1378      	l32i.n	a7, a3, 4
42014400:	00a806        	j	420146a4 <_svfiprintf_r+0x1008>
42014403:	00          	.byte 00
42014404:	972182        	l32i	a8, a1, 0x25c
42014407:	756847        	bbci	a8, 4, 42014480 <_svfiprintf_r+0xde4>
4201440a:	e69c      	beqz.n	a6, 4201442c <_svfiprintf_r+0xd90>
4201440c:	08a357        	bge	a3, a5, 42014418 <_svfiprintf_r+0xd7c>
4201440f:	10c192        	addi	a9, a1, 16
42014412:	b03390        	addx8	a3, a3, a9
42014415:	007b06        	j	42014605 <_svfiprintf_r+0xf69>
42014418:	10c1a2        	addi	a10, a1, 16
4201441b:	30a252        	movi	a5, 0x230
4201441e:	5a5a      	add.n	a5, a10, a5
42014420:	0159      	s32i.n	a5, a1, 0
42014422:	01daf2        	addmi	a15, a10, 0x100
42014425:	0aed      	mov.n	a14, a10
42014427:	007b86        	j	42014619 <_svfiprintf_r+0xf7d>
4201442a:	00          	.byte 00
4201442b:	00          	.byte 00
4201442c:	10c1c2        	addi	a12, a1, 16
4201442f:	241b      	addi.n	a2, a4, 1
42014431:	b033c0        	addx8	a3, a3, a12
42014434:	02a457        	bge	a4, a5, 4201443a <_svfiprintf_r+0xd9e>
42014437:	009946        	j	420146a0 <_svfiprintf_r+0x1004>
4201443a:	10c1d2        	addi	a13, a1, 16
4201443d:	922d72        	l32i	a7, a13, 0x248
42014440:	f81c      	movi.n	a8, 31
42014442:	02dd42        	addmi	a4, a13, 0x200
42014445:	374b      	addi.n	a3, a7, 4
42014447:	861c      	movi.n	a6, 24
42014449:	02a857        	bge	a8, a5, 4201444f <_svfiprintf_r+0xdb3>
4201444c:	008c06        	j	42014680 <_svfiprintf_r+0xfe4>
4201444f:	851b      	addi.n	a8, a5, 1
42014451:	916182        	s32i	a8, a1, 0x244
42014454:	126432        	s32i	a3, a4, 72
42014457:	052637        	blt	a6, a3, 42014460 <_svfiprintf_r+0xdc4>
4201445a:	112432        	l32i	a3, a4, 68
4201445d:	000286        	j	4201446b <_svfiprintf_r+0xdcf>
42014460:	012677        	blt	a6, a7, 42014465 <_svfiprintf_r+0xdc9>
42014463:	432c      	movi.n	a3, 36
42014465:	966132        	s32i	a3, a1, 0x258
42014468:	942132        	l32i	a3, a1, 0x250
4201446b:	962142        	l32i	a4, a1, 0x258
4201446e:	10c1f2        	addi	a15, a1, 16
42014471:	334a      	add.n	a3, a3, a4
42014473:	fcc332        	addi	a3, a3, -4
42014476:	0368      	l32i.n	a6, a3, 0
42014478:	b055f0        	addx8	a5, a5, a15
4201447b:	007f06        	j	4201467b <_svfiprintf_r+0xfdf>
4201447e:	00          	.byte 00
4201447f:	00          	.byte 00
42014480:	972182        	l32i	a8, a1, 0x25c
42014483:	02e867        	bbsi	a8, 6, 42014489 <_svfiprintf_r+0xded>
42014486:	002c86        	j	4201453c <_svfiprintf_r+0xea0>
42014489:	56bc      	beqz.n	a6, 420144c2 <_svfiprintf_r+0xe26>
4201448b:	0da357        	bge	a3, a5, 4201449c <_svfiprintf_r+0xe00>
4201448e:	10c192        	addi	a9, a1, 16
42014491:	b03390        	addx8	a3, a3, a9
42014494:	001362        	l16ui	a6, a3, 0
42014497:	006446        	j	4201462c <_svfiprintf_r+0xf90>
4201449a:	00          	.byte 00
4201449b:	00          	.byte 00
4201449c:	10c1a2        	addi	a10, a1, 16
4201449f:	30a252        	movi	a5, 0x230
420144a2:	5a5a      	add.n	a5, a10, a5
420144a4:	34a2d2        	movi	a13, 0x234
420144a7:	40a2c2        	movi	a12, 0x240
420144aa:	01daf2        	addmi	a15, a10, 0x100
420144ad:	0aed      	mov.n	a14, a10
420144af:	dada      	add.n	a13, a10, a13
420144b1:	caca      	add.n	a12, a10, a12
420144b3:	0159      	s32i.n	a5, a1, 0
420144b5:	02bd      	mov.n	a11, a2
420144b7:	03ad      	mov.n	a10, a3
420144b9:	febde5        	call8	42013098 <get_arg$constprop$0>
420144bc:	001a62        	l16ui	a6, a10, 0
420144bf:	005a46        	j	4201462c <_svfiprintf_r+0xf90>
420144c2:	10c1c2        	addi	a12, a1, 16
420144c5:	241b      	addi.n	a2, a4, 1
420144c7:	b033c0        	addx8	a3, a3, a12
420144ca:	662457        	blt	a4, a5, 42014534 <_svfiprintf_r+0xe98>
420144cd:	10c1d2        	addi	a13, a1, 16
420144d0:	922d72        	l32i	a7, a13, 0x248
420144d3:	f81c      	movi.n	a8, 31
420144d5:	02dd42        	addmi	a4, a13, 0x200
420144d8:	374b      	addi.n	a3, a7, 4
420144da:	861c      	movi.n	a6, 24
420144dc:	342857        	blt	a8, a5, 42014514 <_svfiprintf_r+0xe78>
420144df:	851b      	addi.n	a8, a5, 1
420144e1:	916182        	s32i	a8, a1, 0x244
420144e4:	126432        	s32i	a3, a4, 72
420144e7:	052637        	blt	a6, a3, 420144f0 <_svfiprintf_r+0xe54>
420144ea:	112432        	l32i	a3, a4, 68
420144ed:	000286        	j	420144fb <_svfiprintf_r+0xe5f>
420144f0:	012677        	blt	a6, a7, 420144f5 <_svfiprintf_r+0xe59>
420144f3:	432c      	movi.n	a3, 36
420144f5:	966132        	s32i	a3, a1, 0x258
420144f8:	942132        	l32i	a3, a1, 0x250
420144fb:	962142        	l32i	a4, a1, 0x258
420144fe:	10c1f2        	addi	a15, a1, 16
42014501:	334a      	add.n	a3, a3, a4
42014503:	fcc332        	addi	a3, a3, -4
42014506:	0368      	l32i.n	a6, a3, 0
42014508:	b055f0        	addx8	a5, a5, a15
4201450b:	0569      	s32i.n	a6, a5, 0
4201450d:	f46060        	extui	a6, a6, 0, 16
42014510:	006386        	j	420146a2 <_svfiprintf_r+0x1006>
42014513:	00          	.byte 00
42014514:	126432        	s32i	a3, a4, 72
42014517:	052637        	blt	a6, a3, 42014520 <_svfiprintf_r+0xe84>
4201451a:	112432        	l32i	a3, a4, 68
4201451d:	000286        	j	4201452b <_svfiprintf_r+0xe8f>
42014520:	012677        	blt	a6, a7, 42014525 <_svfiprintf_r+0xe89>
42014523:	432c      	movi.n	a3, 36
42014525:	966132        	s32i	a3, a1, 0x258
42014528:	942132        	l32i	a3, a1, 0x250
4201452b:	962142        	l32i	a4, a1, 0x258
4201452e:	803340        	add	a3, a3, a4
42014531:	fcc332        	addi	a3, a3, -4
42014534:	001362        	l16ui	a6, a3, 0
42014537:	0059c6        	j	420146a2 <_svfiprintf_r+0x1006>
4201453a:	00          	.byte 00
4201453b:	00          	.byte 00
4201453c:	972182        	l32i	a8, a1, 0x25c
4201453f:	02e897        	bbsi	a8, 9, 42014545 <_svfiprintf_r+0xea9>
42014542:	002d06        	j	420145fa <_svfiprintf_r+0xf5e>
42014545:	76bc      	beqz.n	a6, 42014580 <_svfiprintf_r+0xee4>
42014547:	0da357        	bge	a3, a5, 42014558 <_svfiprintf_r+0xebc>
4201454a:	10c192        	addi	a9, a1, 16
4201454d:	b03390        	addx8	a3, a3, a9
42014550:	000362        	l8ui	a6, a3, 0
42014553:	003546        	j	4201462c <_svfiprintf_r+0xf90>
42014556:	00          	.byte 00
42014557:	00          	.byte 00
42014558:	10c1a2        	addi	a10, a1, 16
4201455b:	30a252        	movi	a5, 0x230
4201455e:	5a5a      	add.n	a5, a10, a5
42014560:	34a2d2        	movi	a13, 0x234
42014563:	40a2c2        	movi	a12, 0x240
42014566:	01daf2        	addmi	a15, a10, 0x100
42014569:	0aed      	mov.n	a14, a10
4201456b:	dada      	add.n	a13, a10, a13
4201456d:	caca      	add.n	a12, a10, a12
4201456f:	0159      	s32i.n	a5, a1, 0
42014571:	02bd      	mov.n	a11, a2
42014573:	03ad      	mov.n	a10, a3
42014575:	feb225        	call8	42013098 <get_arg$constprop$0>
42014578:	000a62        	l8ui	a6, a10, 0
4201457b:	002b46        	j	4201462c <_svfiprintf_r+0xf90>
4201457e:	00          	.byte 00
4201457f:	00          	.byte 00
42014580:	10c1c2        	addi	a12, a1, 16
42014583:	241b      	addi.n	a2, a4, 1
42014585:	b033c0        	addx8	a3, a3, a12
42014588:	682457        	blt	a4, a5, 420145f4 <_svfiprintf_r+0xf58>
4201458b:	10c1d2        	addi	a13, a1, 16
4201458e:	922d72        	l32i	a7, a13, 0x248
42014591:	f81c      	movi.n	a8, 31
42014593:	02dd42        	addmi	a4, a13, 0x200
42014596:	374b      	addi.n	a3, a7, 4
42014598:	861c      	movi.n	a6, 24
4201459a:	362857        	blt	a8, a5, 420145d4 <_svfiprintf_r+0xf38>
4201459d:	851b      	addi.n	a8, a5, 1
4201459f:	916182        	s32i	a8, a1, 0x244
420145a2:	126432        	s32i	a3, a4, 72
420145a5:	072637        	blt	a6, a3, 420145b0 <_svfiprintf_r+0xf14>
420145a8:	112432        	l32i	a3, a4, 68
420145ab:	000306        	j	420145bb <_svfiprintf_r+0xf1f>
420145ae:	00          	.byte 00
420145af:	00          	.byte 00
420145b0:	012677        	blt	a6, a7, 420145b5 <_svfiprintf_r+0xf19>
420145b3:	432c      	movi.n	a3, 36
420145b5:	966132        	s32i	a3, a1, 0x258
420145b8:	942132        	l32i	a3, a1, 0x250
420145bb:	962142        	l32i	a4, a1, 0x258
420145be:	10c1f2        	addi	a15, a1, 16
420145c1:	334a      	add.n	a3, a3, a4
420145c3:	fcc332        	addi	a3, a3, -4
420145c6:	0368      	l32i.n	a6, a3, 0
420145c8:	b055f0        	addx8	a5, a5, a15
420145cb:	0569      	s32i.n	a6, a5, 0
420145cd:	746060        	extui	a6, a6, 0, 8
420145d0:	003386        	j	420146a2 <_svfiprintf_r+0x1006>
420145d3:	00          	.byte 00
420145d4:	126432        	s32i	a3, a4, 72
420145d7:	052637        	blt	a6, a3, 420145e0 <_svfiprintf_r+0xf44>
420145da:	112432        	l32i	a3, a4, 68
420145dd:	000286        	j	420145eb <_svfiprintf_r+0xf4f>
420145e0:	012677        	blt	a6, a7, 420145e5 <_svfiprintf_r+0xf49>
420145e3:	432c      	movi.n	a3, 36
420145e5:	966132        	s32i	a3, a1, 0x258
420145e8:	942132        	l32i	a3, a1, 0x250
420145eb:	962142        	l32i	a4, a1, 0x258
420145ee:	803340        	add	a3, a3, a4
420145f1:	fcc332        	addi	a3, a3, -4
420145f4:	000362        	l8ui	a6, a3, 0
420145f7:	0029c6        	j	420146a2 <_svfiprintf_r+0x1006>
420145fa:	36bc      	beqz.n	a6, 42014631 <_svfiprintf_r+0xf95>
420145fc:	0aa357        	bge	a3, a5, 4201460a <_svfiprintf_r+0xf6e>
420145ff:	10c162        	addi	a6, a1, 16
42014602:	b03360        	addx8	a3, a3, a6
42014605:	0368      	l32i.n	a6, a3, 0
42014607:	000846        	j	4201462c <_svfiprintf_r+0xf90>
4201460a:	10c182        	addi	a8, a1, 16
4201460d:	30a252        	movi	a5, 0x230
42014610:	585a      	add.n	a5, a8, a5
42014612:	0159      	s32i.n	a5, a1, 0
42014614:	01d8f2        	addmi	a15, a8, 0x100
42014617:	08ed      	mov.n	a14, a8
42014619:	34a2d2        	movi	a13, 0x234
4201461c:	40a2c2        	movi	a12, 0x240
4201461f:	deda      	add.n	a13, a14, a13
42014621:	ceca      	add.n	a12, a14, a12
42014623:	02bd      	mov.n	a11, a2
42014625:	03ad      	mov.n	a10, a3
42014627:	fea725        	call8	42013098 <get_arg$constprop$0>
4201462a:	0a68      	l32i.n	a6, a10, 0
4201462c:	042d      	mov.n	a2, a4
4201462e:	001c06        	j	420146a2 <_svfiprintf_r+0x1006>
42014631:	10c192        	addi	a9, a1, 16
42014634:	241b      	addi.n	a2, a4, 1
42014636:	b03390        	addx8	a3, a3, a9
42014639:	632457        	blt	a4, a5, 420146a0 <_svfiprintf_r+0x1004>
4201463c:	10c1a2        	addi	a10, a1, 16
4201463f:	922a72        	l32i	a7, a10, 0x248
42014642:	f81c      	movi.n	a8, 31
42014644:	02da42        	addmi	a4, a10, 0x200
42014647:	374b      	addi.n	a3, a7, 4
42014649:	861c      	movi.n	a6, 24
4201464b:	312857        	blt	a8, a5, 42014680 <_svfiprintf_r+0xfe4>
4201464e:	851b      	addi.n	a8, a5, 1
42014650:	916182        	s32i	a8, a1, 0x244
42014653:	126432        	s32i	a3, a4, 72
42014656:	062637        	blt	a6, a3, 42014660 <_svfiprintf_r+0xfc4>
42014659:	112432        	l32i	a3, a4, 68
4201465c:	0002c6        	j	4201466b <_svfiprintf_r+0xfcf>
4201465f:	00          	.byte 00
42014660:	012677        	blt	a6, a7, 42014665 <_svfiprintf_r+0xfc9>
42014663:	432c      	movi.n	a3, 36
42014665:	966132        	s32i	a3, a1, 0x258
42014668:	942132        	l32i	a3, a1, 0x250
4201466b:	962142        	l32i	a4, a1, 0x258
4201466e:	10c1d2        	addi	a13, a1, 16
42014671:	334a      	add.n	a3, a3, a4
42014673:	fcc332        	addi	a3, a3, -4
42014676:	0368      	l32i.n	a6, a3, 0
42014678:	b055d0        	addx8	a5, a5, a13
4201467b:	0569      	s32i.n	a6, a5, 0
4201467d:	000846        	j	420146a2 <_svfiprintf_r+0x1006>
42014680:	126432        	s32i	a3, a4, 72
42014683:	052637        	blt	a6, a3, 4201468c <_svfiprintf_r+0xff0>
42014686:	112432        	l32i	a3, a4, 68
42014689:	000286        	j	42014697 <_svfiprintf_r+0xffb>
4201468c:	012677        	blt	a6, a7, 42014691 <_svfiprintf_r+0xff5>
4201468f:	432c      	movi.n	a3, 36
42014691:	966132        	s32i	a3, a1, 0x258
42014694:	942132        	l32i	a3, a1, 0x250
42014697:	962142        	l32i	a4, a1, 0x258
4201469a:	803340        	add	a3, a3, a4
4201469d:	fcc332        	addi	a3, a3, -4
420146a0:	0368      	l32i.n	a6, a3, 0
420146a2:	070c      	movi.n	a7, 0
420146a4:	972142        	l32i	a4, a1, 0x25c
420146a7:	ffab32        	movi	a3, 0xfffffbff
420146aa:	104430        	and	a4, a4, a3
420146ad:	976142        	s32i	a4, a1, 0x25c
420146b0:	040c      	movi.n	a4, 0
420146b2:	023e46        	j	42014faf <_svfiprintf_r+0x1913>
420146b5:	912152        	l32i	a5, a1, 0x244
420146b8:	46bc      	beqz.n	a6, 420146f0 <_svfiprintf_r+0x1054>
420146ba:	0aa357        	bge	a3, a5, 420146c8 <_svfiprintf_r+0x102c>
420146bd:	10c152        	addi	a5, a1, 16
420146c0:	b03350        	addx8	a3, a3, a5
420146c3:	0368      	l32i.n	a6, a3, 0
420146c5:	000846        	j	420146ea <_svfiprintf_r+0x104e>
420146c8:	10c162        	addi	a6, a1, 16
420146cb:	30a252        	movi	a5, 0x230
420146ce:	565a      	add.n	a5, a6, a5
420146d0:	34a2d2        	movi	a13, 0x234
420146d3:	40a2c2        	movi	a12, 0x240
420146d6:	01d6f2        	addmi	a15, a6, 0x100
420146d9:	06ed      	mov.n	a14, a6
420146db:	d6da      	add.n	a13, a6, a13
420146dd:	c6ca      	add.n	a12, a6, a12
420146df:	0159      	s32i.n	a5, a1, 0
420146e1:	02bd      	mov.n	a11, a2
420146e3:	03ad      	mov.n	a10, a3
420146e5:	fe9b25        	call8	42013098 <get_arg$constprop$0>
420146e8:	0a68      	l32i.n	a6, a10, 0
420146ea:	042d      	mov.n	a2, a4
420146ec:	001c86        	j	42014762 <_svfiprintf_r+0x10c6>
420146ef:	00          	.byte 00
420146f0:	10c182        	addi	a8, a1, 16
420146f3:	241b      	addi.n	a2, a4, 1
420146f5:	b03380        	addx8	a3, a3, a8
420146f8:	642457        	blt	a4, a5, 42014760 <_svfiprintf_r+0x10c4>
420146fb:	10c192        	addi	a9, a1, 16
420146fe:	922972        	l32i	a7, a9, 0x248
42014701:	f81c      	movi.n	a8, 31
42014703:	02d942        	addmi	a4, a9, 0x200
42014706:	374b      	addi.n	a3, a7, 4
42014708:	861c      	movi.n	a6, 24
4201470a:	322857        	blt	a8, a5, 42014740 <_svfiprintf_r+0x10a4>
4201470d:	851b      	addi.n	a8, a5, 1
4201470f:	916182        	s32i	a8, a1, 0x244
42014712:	126432        	s32i	a3, a4, 72
42014715:	072637        	blt	a6, a3, 42014720 <_svfiprintf_r+0x1084>
42014718:	112432        	l32i	a3, a4, 68
4201471b:	000306        	j	4201472b <_svfiprintf_r+0x108f>
4201471e:	00          	.byte 00
4201471f:	00          	.byte 00
42014720:	012677        	blt	a6, a7, 42014725 <_svfiprintf_r+0x1089>
42014723:	432c      	movi.n	a3, 36
42014725:	966132        	s32i	a3, a1, 0x258
42014728:	942132        	l32i	a3, a1, 0x250
4201472b:	962142        	l32i	a4, a1, 0x258
4201472e:	10c1c2        	addi	a12, a1, 16
42014731:	334a      	add.n	a3, a3, a4
42014733:	fcc332        	addi	a3, a3, -4
42014736:	0368      	l32i.n	a6, a3, 0
42014738:	b035c0        	addx8	a3, a5, a12
4201473b:	0369      	s32i.n	a6, a3, 0
4201473d:	000846        	j	42014762 <_svfiprintf_r+0x10c6>
42014740:	126432        	s32i	a3, a4, 72
42014743:	052637        	blt	a6, a3, 4201474c <_svfiprintf_r+0x10b0>
42014746:	112432        	l32i	a3, a4, 68
42014749:	000286        	j	42014757 <_svfiprintf_r+0x10bb>
4201474c:	012677        	blt	a6, a7, 42014751 <_svfiprintf_r+0x10b5>
4201474f:	432c      	movi.n	a3, 36
42014751:	966132        	s32i	a3, a1, 0x258
42014754:	942132        	l32i	a3, a1, 0x250
42014757:	962142        	l32i	a4, a1, 0x258
4201475a:	803340        	add	a3, a3, a4
4201475d:	fcc332        	addi	a3, a3, -4
42014760:	0368      	l32i.n	a6, a3, 0
42014762:	972132        	l32i	a3, a1, 0x25c
42014765:	240c      	movi.n	a4, 2
42014767:	203340        	or	a3, a3, a4
4201476a:	10c182        	addi	a8, a1, 16
4201476d:	053c      	movi.n	a5, 48
4201476f:	b16291        	l32r	a9, 42000cf8 <_stext+0xcd8>
42014772:	976132        	s32i	a3, a1, 0x25c
42014775:	02d832        	addmi	a3, a8, 0x200
42014778:	384352        	s8i	a5, a3, 56
4201477b:	78a052        	movi	a5, 120
4201477e:	070c      	movi.n	a7, 0
42014780:	394352        	s8i	a5, a3, 57
42014783:	9f6192        	s32i	a9, a1, 0x27c
42014786:	020946        	j	42014faf <_svfiprintf_r+0x1913>
42014789:	912152        	l32i	a5, a1, 0x244
4201478c:	46bc      	beqz.n	a6, 420147c4 <_svfiprintf_r+0x1128>
4201478e:	0aa357        	bge	a3, a5, 4201479c <_svfiprintf_r+0x1100>
42014791:	10c1a2        	addi	a10, a1, 16
42014794:	b033a0        	addx8	a3, a3, a10
42014797:	0338      	l32i.n	a3, a3, 0
42014799:	000846        	j	420147be <_svfiprintf_r+0x1122>
4201479c:	10c1c2        	addi	a12, a1, 16
4201479f:	30a252        	movi	a5, 0x230
420147a2:	34a2d2        	movi	a13, 0x234
420147a5:	0ced      	mov.n	a14, a12
420147a7:	5c5a      	add.n	a5, a12, a5
420147a9:	01dcf2        	addmi	a15, a12, 0x100
420147ac:	dcda      	add.n	a13, a12, a13
420147ae:	40a2c2        	movi	a12, 0x240
420147b1:	03ad      	mov.n	a10, a3
420147b3:	0159      	s32i.n	a5, a1, 0
420147b5:	ceca      	add.n	a12, a14, a12
420147b7:	02bd      	mov.n	a11, a2
420147b9:	fe8de5        	call8	42013098 <get_arg$constprop$0>
420147bc:	0a38      	l32i.n	a3, a10, 0
420147be:	042d      	mov.n	a2, a4
420147c0:	001c86        	j	42014836 <_svfiprintf_r+0x119a>
420147c3:	00          	.byte 00
420147c4:	10c1d2        	addi	a13, a1, 16
420147c7:	241b      	addi.n	a2, a4, 1
420147c9:	b033d0        	addx8	a3, a3, a13
420147cc:	642457        	blt	a4, a5, 42014834 <_svfiprintf_r+0x1198>
420147cf:	10c1e2        	addi	a14, a1, 16
420147d2:	922e72        	l32i	a7, a14, 0x248
420147d5:	f81c      	movi.n	a8, 31
420147d7:	02de42        	addmi	a4, a14, 0x200
420147da:	374b      	addi.n	a3, a7, 4
420147dc:	861c      	movi.n	a6, 24
420147de:	322857        	blt	a8, a5, 42014814 <_svfiprintf_r+0x1178>
420147e1:	851b      	addi.n	a8, a5, 1
420147e3:	916182        	s32i	a8, a1, 0x244
420147e6:	126432        	s32i	a3, a4, 72
420147e9:	072637        	blt	a6, a3, 420147f4 <_svfiprintf_r+0x1158>
420147ec:	112432        	l32i	a3, a4, 68
420147ef:	000306        	j	420147ff <_svfiprintf_r+0x1163>
420147f2:	00          	.byte 00
420147f3:	00          	.byte 00
420147f4:	012677        	blt	a6, a7, 420147f9 <_svfiprintf_r+0x115d>
420147f7:	432c      	movi.n	a3, 36
420147f9:	966132        	s32i	a3, a1, 0x258
420147fc:	942132        	l32i	a3, a1, 0x250
420147ff:	962142        	l32i	a4, a1, 0x258
42014802:	10c162        	addi	a6, a1, 16
42014805:	334a      	add.n	a3, a3, a4
42014807:	fcc332        	addi	a3, a3, -4
4201480a:	0338      	l32i.n	a3, a3, 0
4201480c:	b04560        	addx8	a4, a5, a6
4201480f:	0439      	s32i.n	a3, a4, 0
42014811:	000846        	j	42014836 <_svfiprintf_r+0x119a>
42014814:	126432        	s32i	a3, a4, 72
42014817:	052637        	blt	a6, a3, 42014820 <_svfiprintf_r+0x1184>
4201481a:	112432        	l32i	a3, a4, 68
4201481d:	000286        	j	4201482b <_svfiprintf_r+0x118f>
42014820:	012677        	blt	a6, a7, 42014825 <_svfiprintf_r+0x1189>
42014823:	432c      	movi.n	a3, 36
42014825:	966132        	s32i	a3, a1, 0x258
42014828:	942132        	l32i	a3, a1, 0x250
4201482b:	962142        	l32i	a4, a1, 0x258
4201482e:	803340        	add	a3, a3, a4
42014831:	fcc332        	addi	a3, a3, -4
42014834:	0338      	l32i.n	a3, a3, 0
42014836:	10c192        	addi	a9, a1, 16
42014839:	02d942        	addmi	a4, a9, 0x200
4201483c:	050c      	movi.n	a5, 0
4201483e:	3a4452        	s8i	a5, a4, 58
42014841:	992142        	l32i	a4, a1, 0x264
42014844:	1d0426        	beqi	a4, -1, 42014865 <_svfiprintf_r+0x11c9>
42014847:	04cd      	mov.n	a12, a4
42014849:	0b0c      	movi.n	a11, 0
4201484b:	20a330        	or	a10, a3, a3
4201484e:	b0d181        	l32r	a8, 42000b94 <_stext+0xb74>
42014851:	0008e0        	callx8	a8
42014854:	040c      	movi.n	a4, 0
42014856:	029a47        	bne	a10, a4, 4201485c <_svfiprintf_r+0x11c0>
42014859:	024706        	j	42015179 <_svfiprintf_r+0x1add>
4201485c:	c0aa30        	sub	a10, a10, a3
4201485f:	9961a2        	s32i	a10, a1, 0x264
42014862:	0244c6        	j	42015179 <_svfiprintf_r+0x1add>
42014865:	03ad      	mov.n	a10, a3
42014867:	af8b81        	l32r	a8, 42000694 <_stext+0x674>
4201486a:	0008e0        	callx8	a8
4201486d:	9961a2        	s32i	a10, a1, 0x264
42014870:	040c      	movi.n	a4, 0
42014872:	0240c6        	j	42015179 <_svfiprintf_r+0x1add>
42014875:	00          	.byte 00
42014876:	00          	.byte 00
42014877:	972182        	l32i	a8, a1, 0x25c
4201487a:	051c      	movi.n	a5, 16
4201487c:	208850        	or	a8, a8, a5
4201487f:	976182        	s32i	a8, a1, 0x25c
42014882:	972192        	l32i	a9, a1, 0x25c
42014885:	912152        	l32i	a5, a1, 0x244
42014888:	02e957        	bbsi	a9, 5, 4201488e <_svfiprintf_r+0x11f2>
4201488b:	002f46        	j	4201494c <_svfiprintf_r+0x12b0>
4201488e:	76bc      	beqz.n	a6, 420148c9 <_svfiprintf_r+0x122d>
42014890:	0ca357        	bge	a3, a5, 420148a0 <_svfiprintf_r+0x1204>
42014893:	10c1a2        	addi	a10, a1, 16
42014896:	b033a0        	addx8	a3, a3, a10
42014899:	0368      	l32i.n	a6, a3, 0
4201489b:	1378      	l32i.n	a7, a3, 4
4201489d:	0008c6        	j	420148c4 <_svfiprintf_r+0x1228>
420148a0:	10c1c2        	addi	a12, a1, 16
420148a3:	30a252        	movi	a5, 0x230
420148a6:	34a2d2        	movi	a13, 0x234
420148a9:	0ced      	mov.n	a14, a12
420148ab:	5c5a      	add.n	a5, a12, a5
420148ad:	01dcf2        	addmi	a15, a12, 0x100
420148b0:	dcda      	add.n	a13, a12, a13
420148b2:	40a2c2        	movi	a12, 0x240
420148b5:	0159      	s32i.n	a5, a1, 0
420148b7:	ceca      	add.n	a12, a14, a12
420148b9:	02bd      	mov.n	a11, a2
420148bb:	03ad      	mov.n	a10, a3
420148bd:	fe7da5        	call8	42013098 <get_arg$constprop$0>
420148c0:	0a68      	l32i.n	a6, a10, 0
420148c2:	1a78      	l32i.n	a7, a10, 4
420148c4:	042d      	mov.n	a2, a4
420148c6:	009ec6        	j	42014b45 <_svfiprintf_r+0x14a9>
420148c9:	10c1d2        	addi	a13, a1, 16
420148cc:	241b      	addi.n	a2, a4, 1
420148ce:	b033d0        	addx8	a3, a3, a13
420148d1:	6f2457        	blt	a4, a5, 42014944 <_svfiprintf_r+0x12a8>
420148d4:	10c1e2        	addi	a14, a1, 16
420148d7:	922e42        	l32i	a4, a14, 0x248
420148da:	837c      	movi.n	a3, -8
420148dc:	447b      	addi.n	a4, a4, 7
420148de:	104430        	and	a4, a4, a3
420148e1:	f81c      	movi.n	a8, 31
420148e3:	02de62        	addmi	a6, a14, 0x200
420148e6:	348b      	addi.n	a3, a4, 8
420148e8:	871c      	movi.n	a7, 24
420148ea:	362857        	blt	a8, a5, 42014924 <_svfiprintf_r+0x1288>
420148ed:	851b      	addi.n	a8, a5, 1
420148ef:	916182        	s32i	a8, a1, 0x244
420148f2:	126632        	s32i	a3, a6, 72
420148f5:	072737        	blt	a7, a3, 42014900 <_svfiprintf_r+0x1264>
420148f8:	112632        	l32i	a3, a6, 68
420148fb:	000306        	j	4201490b <_svfiprintf_r+0x126f>
420148fe:	00          	.byte 00
420148ff:	00          	.byte 00
42014900:	012747        	blt	a7, a4, 42014905 <_svfiprintf_r+0x1269>
42014903:	832c      	movi.n	a3, 40
42014905:	966132        	s32i	a3, a1, 0x258
42014908:	942132        	l32i	a3, a1, 0x250
4201490b:	962142        	l32i	a4, a1, 0x258
4201490e:	334a      	add.n	a3, a3, a4
42014910:	f8c332        	addi	a3, a3, -8
42014913:	0368      	l32i.n	a6, a3, 0
42014915:	1378      	l32i.n	a7, a3, 4
42014917:	10c132        	addi	a3, a1, 16
4201491a:	b05530        	addx8	a5, a5, a3
4201491d:	0569      	s32i.n	a6, a5, 0
4201491f:	1579      	s32i.n	a7, a5, 4
42014921:	008806        	j	42014b45 <_svfiprintf_r+0x14a9>
42014924:	126632        	s32i	a3, a6, 72
42014927:	052737        	blt	a7, a3, 42014930 <_svfiprintf_r+0x1294>
4201492a:	112632        	l32i	a3, a6, 68
4201492d:	000286        	j	4201493b <_svfiprintf_r+0x129f>
42014930:	012747        	blt	a7, a4, 42014935 <_svfiprintf_r+0x1299>
42014933:	832c      	movi.n	a3, 40
42014935:	966132        	s32i	a3, a1, 0x258
42014938:	942132        	l32i	a3, a1, 0x250
4201493b:	962142        	l32i	a4, a1, 0x258
4201493e:	803340        	add	a3, a3, a4
42014941:	f8c332        	addi	a3, a3, -8
42014944:	0368      	l32i.n	a6, a3, 0
42014946:	1378      	l32i.n	a7, a3, 4
42014948:	007e46        	j	42014b45 <_svfiprintf_r+0x14a9>
4201494b:	00          	.byte 00
4201494c:	972182        	l32i	a8, a1, 0x25c
4201494f:	756847        	bbci	a8, 4, 420149c8 <_svfiprintf_r+0x132c>
42014952:	e69c      	beqz.n	a6, 42014974 <_svfiprintf_r+0x12d8>
42014954:	08a357        	bge	a3, a5, 42014960 <_svfiprintf_r+0x12c4>
42014957:	10c192        	addi	a9, a1, 16
4201495a:	b03390        	addx8	a3, a3, a9
4201495d:	007d06        	j	42014b55 <_svfiprintf_r+0x14b9>
42014960:	10c1a2        	addi	a10, a1, 16
42014963:	30a252        	movi	a5, 0x230
42014966:	5a5a      	add.n	a5, a10, a5
42014968:	0159      	s32i.n	a5, a1, 0
4201496a:	01daf2        	addmi	a15, a10, 0x100
4201496d:	0aed      	mov.n	a14, a10
4201496f:	007e06        	j	42014b6b <_svfiprintf_r+0x14cf>
42014972:	00          	.byte 00
42014973:	00          	.byte 00
42014974:	10c1c2        	addi	a12, a1, 16
42014977:	241b      	addi.n	a2, a4, 1
42014979:	b033c0        	addx8	a3, a3, a12
4201497c:	02a457        	bge	a4, a5, 42014982 <_svfiprintf_r+0x12e6>
4201497f:	009c46        	j	42014bf4 <_svfiprintf_r+0x1558>
42014982:	10c1d2        	addi	a13, a1, 16
42014985:	922d72        	l32i	a7, a13, 0x248
42014988:	f81c      	movi.n	a8, 31
4201498a:	02dd42        	addmi	a4, a13, 0x200
4201498d:	374b      	addi.n	a3, a7, 4
4201498f:	861c      	movi.n	a6, 24
42014991:	02a857        	bge	a8, a5, 42014997 <_svfiprintf_r+0x12fb>
42014994:	008f06        	j	42014bd4 <_svfiprintf_r+0x1538>
42014997:	851b      	addi.n	a8, a5, 1
42014999:	916182        	s32i	a8, a1, 0x244
4201499c:	126432        	s32i	a3, a4, 72
4201499f:	052637        	blt	a6, a3, 420149a8 <_svfiprintf_r+0x130c>
420149a2:	112432        	l32i	a3, a4, 68
420149a5:	000286        	j	420149b3 <_svfiprintf_r+0x1317>
420149a8:	012677        	blt	a6, a7, 420149ad <_svfiprintf_r+0x1311>
420149ab:	432c      	movi.n	a3, 36
420149ad:	966132        	s32i	a3, a1, 0x258
420149b0:	942132        	l32i	a3, a1, 0x250
420149b3:	962142        	l32i	a4, a1, 0x258
420149b6:	10c1f2        	addi	a15, a1, 16
420149b9:	334a      	add.n	a3, a3, a4
420149bb:	fcc332        	addi	a3, a3, -4
420149be:	0368      	l32i.n	a6, a3, 0
420149c0:	b055f0        	addx8	a5, a5, a15
420149c3:	008206        	j	42014bcf <_svfiprintf_r+0x1533>
420149c6:	00          	.byte 00
420149c7:	00          	.byte 00
420149c8:	972182        	l32i	a8, a1, 0x25c
420149cb:	02e867        	bbsi	a8, 6, 420149d1 <_svfiprintf_r+0x1335>
420149ce:	002d86        	j	42014a88 <_svfiprintf_r+0x13ec>
420149d1:	76bc      	beqz.n	a6, 42014a0c <_svfiprintf_r+0x1370>
420149d3:	0da357        	bge	a3, a5, 420149e4 <_svfiprintf_r+0x1348>
420149d6:	10c192        	addi	a9, a1, 16
420149d9:	b03390        	addx8	a3, a3, a9
420149dc:	001362        	l16ui	a6, a3, 0
420149df:	0066c6        	j	42014b7e <_svfiprintf_r+0x14e2>
420149e2:	00          	.byte 00
420149e3:	00          	.byte 00
420149e4:	10c1a2        	addi	a10, a1, 16
420149e7:	30a252        	movi	a5, 0x230
420149ea:	5a5a      	add.n	a5, a10, a5
420149ec:	34a2d2        	movi	a13, 0x234
420149ef:	40a2c2        	movi	a12, 0x240
420149f2:	01daf2        	addmi	a15, a10, 0x100
420149f5:	0aed      	mov.n	a14, a10
420149f7:	dada      	add.n	a13, a10, a13
420149f9:	caca      	add.n	a12, a10, a12
420149fb:	0159      	s32i.n	a5, a1, 0
420149fd:	02bd      	mov.n	a11, a2
420149ff:	03ad      	mov.n	a10, a3
42014a01:	fe6965        	call8	42013098 <get_arg$constprop$0>
42014a04:	001a62        	l16ui	a6, a10, 0
42014a07:	005cc6        	j	42014b7e <_svfiprintf_r+0x14e2>
42014a0a:	00          	.byte 00
42014a0b:	00          	.byte 00
42014a0c:	10c1c2        	addi	a12, a1, 16
42014a0f:	241b      	addi.n	a2, a4, 1
42014a11:	b033c0        	addx8	a3, a3, a12
42014a14:	682457        	blt	a4, a5, 42014a80 <_svfiprintf_r+0x13e4>
42014a17:	10c1d2        	addi	a13, a1, 16
42014a1a:	922d72        	l32i	a7, a13, 0x248
42014a1d:	f81c      	movi.n	a8, 31
42014a1f:	02dd42        	addmi	a4, a13, 0x200
42014a22:	374b      	addi.n	a3, a7, 4
42014a24:	861c      	movi.n	a6, 24
42014a26:	362857        	blt	a8, a5, 42014a60 <_svfiprintf_r+0x13c4>
42014a29:	851b      	addi.n	a8, a5, 1
42014a2b:	916182        	s32i	a8, a1, 0x244
42014a2e:	126432        	s32i	a3, a4, 72
42014a31:	072637        	blt	a6, a3, 42014a3c <_svfiprintf_r+0x13a0>
42014a34:	112432        	l32i	a3, a4, 68
42014a37:	000306        	j	42014a47 <_svfiprintf_r+0x13ab>
42014a3a:	00          	.byte 00
42014a3b:	00          	.byte 00
42014a3c:	012677        	blt	a6, a7, 42014a41 <_svfiprintf_r+0x13a5>
42014a3f:	432c      	movi.n	a3, 36
42014a41:	966132        	s32i	a3, a1, 0x258
42014a44:	942132        	l32i	a3, a1, 0x250
42014a47:	962142        	l32i	a4, a1, 0x258
42014a4a:	10c1f2        	addi	a15, a1, 16
42014a4d:	334a      	add.n	a3, a3, a4
42014a4f:	fcc332        	addi	a3, a3, -4
42014a52:	0368      	l32i.n	a6, a3, 0
42014a54:	b055f0        	addx8	a5, a5, a15
42014a57:	0569      	s32i.n	a6, a5, 0
42014a59:	f46060        	extui	a6, a6, 0, 16
42014a5c:	0038c6        	j	42014b43 <_svfiprintf_r+0x14a7>
42014a5f:	00          	.byte 00
42014a60:	126432        	s32i	a3, a4, 72
42014a63:	052637        	blt	a6, a3, 42014a6c <_svfiprintf_r+0x13d0>
42014a66:	112432        	l32i	a3, a4, 68
42014a69:	000286        	j	42014a77 <_svfiprintf_r+0x13db>
42014a6c:	012677        	blt	a6, a7, 42014a71 <_svfiprintf_r+0x13d5>
42014a6f:	432c      	movi.n	a3, 36
42014a71:	966132        	s32i	a3, a1, 0x258
42014a74:	942132        	l32i	a3, a1, 0x250
42014a77:	962142        	l32i	a4, a1, 0x258
42014a7a:	803340        	add	a3, a3, a4
42014a7d:	fcc332        	addi	a3, a3, -4
42014a80:	001362        	l16ui	a6, a3, 0
42014a83:	002f06        	j	42014b43 <_svfiprintf_r+0x14a7>
42014a86:	00          	.byte 00
42014a87:	00          	.byte 00
42014a88:	972182        	l32i	a8, a1, 0x25c
42014a8b:	02e897        	bbsi	a8, 9, 42014a91 <_svfiprintf_r+0x13f5>
42014a8e:	002e06        	j	42014b4a <_svfiprintf_r+0x14ae>
42014a91:	76bc      	beqz.n	a6, 42014acc <_svfiprintf_r+0x1430>
42014a93:	0da357        	bge	a3, a5, 42014aa4 <_svfiprintf_r+0x1408>
42014a96:	10c192        	addi	a9, a1, 16
42014a99:	b03390        	addx8	a3, a3, a9
42014a9c:	000362        	l8ui	a6, a3, 0
42014a9f:	0036c6        	j	42014b7e <_svfiprintf_r+0x14e2>
42014aa2:	00          	.byte 00
42014aa3:	00          	.byte 00
42014aa4:	10c1a2        	addi	a10, a1, 16
42014aa7:	30a252        	movi	a5, 0x230
42014aaa:	5a5a      	add.n	a5, a10, a5
42014aac:	34a2d2        	movi	a13, 0x234
42014aaf:	40a2c2        	movi	a12, 0x240
42014ab2:	01daf2        	addmi	a15, a10, 0x100
42014ab5:	0aed      	mov.n	a14, a10
42014ab7:	dada      	add.n	a13, a10, a13
42014ab9:	caca      	add.n	a12, a10, a12
42014abb:	0159      	s32i.n	a5, a1, 0
42014abd:	02bd      	mov.n	a11, a2
42014abf:	03ad      	mov.n	a10, a3
42014ac1:	fe5d65        	call8	42013098 <get_arg$constprop$0>
42014ac4:	000a62        	l8ui	a6, a10, 0
42014ac7:	002cc6        	j	42014b7e <_svfiprintf_r+0x14e2>
42014aca:	00          	.byte 00
42014acb:	00          	.byte 00
42014acc:	10c1c2        	addi	a12, a1, 16
42014acf:	241b      	addi.n	a2, a4, 1
42014ad1:	b033c0        	addx8	a3, a3, a12
42014ad4:	682457        	blt	a4, a5, 42014b40 <_svfiprintf_r+0x14a4>
42014ad7:	10c1d2        	addi	a13, a1, 16
42014ada:	922d72        	l32i	a7, a13, 0x248
42014add:	f81c      	movi.n	a8, 31
42014adf:	02dd42        	addmi	a4, a13, 0x200
42014ae2:	374b      	addi.n	a3, a7, 4
42014ae4:	861c      	movi.n	a6, 24
42014ae6:	362857        	blt	a8, a5, 42014b20 <_svfiprintf_r+0x1484>
42014ae9:	851b      	addi.n	a8, a5, 1
42014aeb:	916182        	s32i	a8, a1, 0x244
42014aee:	126432        	s32i	a3, a4, 72
42014af1:	072637        	blt	a6, a3, 42014afc <_svfiprintf_r+0x1460>
42014af4:	112432        	l32i	a3, a4, 68
42014af7:	000306        	j	42014b07 <_svfiprintf_r+0x146b>
42014afa:	00          	.byte 00
42014afb:	00          	.byte 00
42014afc:	012677        	blt	a6, a7, 42014b01 <_svfiprintf_r+0x1465>
42014aff:	432c      	movi.n	a3, 36
42014b01:	966132        	s32i	a3, a1, 0x258
42014b04:	942132        	l32i	a3, a1, 0x250
42014b07:	962142        	l32i	a4, a1, 0x258
42014b0a:	10c1f2        	addi	a15, a1, 16
42014b0d:	334a      	add.n	a3, a3, a4
42014b0f:	fcc332        	addi	a3, a3, -4
42014b12:	0368      	l32i.n	a6, a3, 0
42014b14:	b055f0        	addx8	a5, a5, a15
42014b17:	0569      	s32i.n	a6, a5, 0
42014b19:	746060        	extui	a6, a6, 0, 8
42014b1c:	0008c6        	j	42014b43 <_svfiprintf_r+0x14a7>
42014b1f:	00          	.byte 00
42014b20:	126432        	s32i	a3, a4, 72
42014b23:	052637        	blt	a6, a3, 42014b2c <_svfiprintf_r+0x1490>
42014b26:	112432        	l32i	a3, a4, 68
42014b29:	000286        	j	42014b37 <_svfiprintf_r+0x149b>
42014b2c:	012677        	blt	a6, a7, 42014b31 <_svfiprintf_r+0x1495>
42014b2f:	432c      	movi.n	a3, 36
42014b31:	966132        	s32i	a3, a1, 0x258
42014b34:	942132        	l32i	a3, a1, 0x250
42014b37:	962142        	l32i	a4, a1, 0x258
42014b3a:	803340        	add	a3, a3, a4
42014b3d:	fcc332        	addi	a3, a3, -4
42014b40:	000362        	l8ui	a6, a3, 0
42014b43:	070c      	movi.n	a7, 0
42014b45:	140c      	movi.n	a4, 1
42014b47:	011906        	j	42014faf <_svfiprintf_r+0x1913>
42014b4a:	66bc      	beqz.n	a6, 42014b84 <_svfiprintf_r+0x14e8>
42014b4c:	0ca357        	bge	a3, a5, 42014b5c <_svfiprintf_r+0x14c0>
42014b4f:	10c162        	addi	a6, a1, 16
42014b52:	b03360        	addx8	a3, a3, a6
42014b55:	0368      	l32i.n	a6, a3, 0
42014b57:	0008c6        	j	42014b7e <_svfiprintf_r+0x14e2>
42014b5a:	00          	.byte 00
42014b5b:	00          	.byte 00
42014b5c:	10c182        	addi	a8, a1, 16
42014b5f:	30a252        	movi	a5, 0x230
42014b62:	585a      	add.n	a5, a8, a5
42014b64:	0159      	s32i.n	a5, a1, 0
42014b66:	01d8f2        	addmi	a15, a8, 0x100
42014b69:	08ed      	mov.n	a14, a8
42014b6b:	34a2d2        	movi	a13, 0x234
42014b6e:	40a2c2        	movi	a12, 0x240
42014b71:	deda      	add.n	a13, a14, a13
42014b73:	ceca      	add.n	a12, a14, a12
42014b75:	02bd      	mov.n	a11, a2
42014b77:	03ad      	mov.n	a10, a3
42014b79:	fe51e5        	call8	42013098 <get_arg$constprop$0>
42014b7c:	0a68      	l32i.n	a6, a10, 0
42014b7e:	042d      	mov.n	a2, a4
42014b80:	ffefc6        	j	42014b43 <_svfiprintf_r+0x14a7>
42014b83:	00          	.byte 00
42014b84:	10c192        	addi	a9, a1, 16
42014b87:	241b      	addi.n	a2, a4, 1
42014b89:	b03390        	addx8	a3, a3, a9
42014b8c:	642457        	blt	a4, a5, 42014bf4 <_svfiprintf_r+0x1558>
42014b8f:	10c1a2        	addi	a10, a1, 16
42014b92:	922a72        	l32i	a7, a10, 0x248
42014b95:	f81c      	movi.n	a8, 31
42014b97:	02da42        	addmi	a4, a10, 0x200
42014b9a:	374b      	addi.n	a3, a7, 4
42014b9c:	861c      	movi.n	a6, 24
42014b9e:	322857        	blt	a8, a5, 42014bd4 <_svfiprintf_r+0x1538>
42014ba1:	851b      	addi.n	a8, a5, 1
42014ba3:	916182        	s32i	a8, a1, 0x244
42014ba6:	126432        	s32i	a3, a4, 72
42014ba9:	072637        	blt	a6, a3, 42014bb4 <_svfiprintf_r+0x1518>
42014bac:	112432        	l32i	a3, a4, 68
42014baf:	000306        	j	42014bbf <_svfiprintf_r+0x1523>
42014bb2:	00          	.byte 00
42014bb3:	00          	.byte 00
42014bb4:	012677        	blt	a6, a7, 42014bb9 <_svfiprintf_r+0x151d>
42014bb7:	432c      	movi.n	a3, 36
42014bb9:	966132        	s32i	a3, a1, 0x258
42014bbc:	942132        	l32i	a3, a1, 0x250
42014bbf:	962142        	l32i	a4, a1, 0x258
42014bc2:	10c1d2        	addi	a13, a1, 16
42014bc5:	334a      	add.n	a3, a3, a4
42014bc7:	fcc332        	addi	a3, a3, -4
42014bca:	0368      	l32i.n	a6, a3, 0
42014bcc:	b055d0        	addx8	a5, a5, a13
42014bcf:	0569      	s32i.n	a6, a5, 0
42014bd1:	ffdb86        	j	42014b43 <_svfiprintf_r+0x14a7>
42014bd4:	126432        	s32i	a3, a4, 72
42014bd7:	052637        	blt	a6, a3, 42014be0 <_svfiprintf_r+0x1544>
42014bda:	112432        	l32i	a3, a4, 68
42014bdd:	000286        	j	42014beb <_svfiprintf_r+0x154f>
42014be0:	012677        	blt	a6, a7, 42014be5 <_svfiprintf_r+0x1549>
42014be3:	432c      	movi.n	a3, 36
42014be5:	966132        	s32i	a3, a1, 0x258
42014be8:	942132        	l32i	a3, a1, 0x250
42014beb:	962142        	l32i	a4, a1, 0x258
42014bee:	803340        	add	a3, a3, a4
42014bf1:	fcc332        	addi	a3, a3, -4
42014bf4:	0368      	l32i.n	a6, a3, 0
42014bf6:	ffd246        	j	42014b43 <_svfiprintf_r+0x14a7>
42014bf9:	00          	.byte 00
42014bfa:	00          	.byte 00
42014bfb:	b03e81        	l32r	a8, 42000cf4 <_stext+0xcd4>
42014bfe:	9f6182        	s32i	a8, a1, 0x27c
42014c01:	000146        	j	42014c0a <_svfiprintf_r+0x156e>
42014c04:	b03d91        	l32r	a9, 42000cf8 <_stext+0xcd8>
42014c07:	9f6192        	s32i	a9, a1, 0x27c
42014c0a:	972192        	l32i	a9, a1, 0x25c
42014c0d:	912182        	l32i	a8, a1, 0x244
42014c10:	02e957        	bbsi	a9, 5, 42014c16 <_svfiprintf_r+0x157a>
42014c13:	002f46        	j	42014cd4 <_svfiprintf_r+0x1638>
42014c16:	76bc      	beqz.n	a6, 42014c51 <_svfiprintf_r+0x15b5>
42014c18:	0ca387        	bge	a3, a8, 42014c28 <_svfiprintf_r+0x158c>
42014c1b:	10c1a2        	addi	a10, a1, 16
42014c1e:	b033a0        	addx8	a3, a3, a10
42014c21:	0368      	l32i.n	a6, a3, 0
42014c23:	1378      	l32i.n	a7, a3, 4
42014c25:	0008c6        	j	42014c4c <_svfiprintf_r+0x15b0>
42014c28:	10c1c2        	addi	a12, a1, 16
42014c2b:	30a262        	movi	a6, 0x230
42014c2e:	34a2d2        	movi	a13, 0x234
42014c31:	6c6a      	add.n	a6, a12, a6
42014c33:	0ced      	mov.n	a14, a12
42014c35:	01dcf2        	addmi	a15, a12, 0x100
42014c38:	dcda      	add.n	a13, a12, a13
42014c3a:	40a2c2        	movi	a12, 0x240
42014c3d:	0169      	s32i.n	a6, a1, 0
42014c3f:	ceca      	add.n	a12, a14, a12
42014c41:	02bd      	mov.n	a11, a2
42014c43:	03ad      	mov.n	a10, a3
42014c45:	fe4525        	call8	42013098 <get_arg$constprop$0>
42014c48:	0a68      	l32i.n	a6, a10, 0
42014c4a:	1a78      	l32i.n	a7, a10, 4
42014c4c:	042d      	mov.n	a2, a4
42014c4e:	00ca86        	j	42014f7c <_svfiprintf_r+0x18e0>
42014c51:	10c1d2        	addi	a13, a1, 16
42014c54:	241b      	addi.n	a2, a4, 1
42014c56:	b033d0        	addx8	a3, a3, a13
42014c59:	6f2487        	blt	a4, a8, 42014ccc <_svfiprintf_r+0x1630>
42014c5c:	10c1e2        	addi	a14, a1, 16
42014c5f:	922e42        	l32i	a4, a14, 0x248
42014c62:	837c      	movi.n	a3, -8
42014c64:	447b      	addi.n	a4, a4, 7
42014c66:	104430        	and	a4, a4, a3
42014c69:	f91c      	movi.n	a9, 31
42014c6b:	02de62        	addmi	a6, a14, 0x200
42014c6e:	348b      	addi.n	a3, a4, 8
42014c70:	871c      	movi.n	a7, 24
42014c72:	362987        	blt	a9, a8, 42014cac <_svfiprintf_r+0x1610>
42014c75:	981b      	addi.n	a9, a8, 1
42014c77:	916192        	s32i	a9, a1, 0x244
42014c7a:	126632        	s32i	a3, a6, 72
42014c7d:	072737        	blt	a7, a3, 42014c88 <_svfiprintf_r+0x15ec>
42014c80:	112632        	l32i	a3, a6, 68
42014c83:	000306        	j	42014c93 <_svfiprintf_r+0x15f7>
42014c86:	00          	.byte 00
42014c87:	00          	.byte 00
42014c88:	012747        	blt	a7, a4, 42014c8d <_svfiprintf_r+0x15f1>
42014c8b:	832c      	movi.n	a3, 40
42014c8d:	966132        	s32i	a3, a1, 0x258
42014c90:	942132        	l32i	a3, a1, 0x250
42014c93:	962142        	l32i	a4, a1, 0x258
42014c96:	334a      	add.n	a3, a3, a4
42014c98:	f8c332        	addi	a3, a3, -8
42014c9b:	0368      	l32i.n	a6, a3, 0
42014c9d:	1378      	l32i.n	a7, a3, 4
42014c9f:	10c132        	addi	a3, a1, 16
42014ca2:	b08830        	addx8	a8, a8, a3
42014ca5:	0869      	s32i.n	a6, a8, 0
42014ca7:	1879      	s32i.n	a7, a8, 4
42014ca9:	00b3c6        	j	42014f7c <_svfiprintf_r+0x18e0>
42014cac:	126632        	s32i	a3, a6, 72
42014caf:	052737        	blt	a7, a3, 42014cb8 <_svfiprintf_r+0x161c>
42014cb2:	112632        	l32i	a3, a6, 68
42014cb5:	000286        	j	42014cc3 <_svfiprintf_r+0x1627>
42014cb8:	012747        	blt	a7, a4, 42014cbd <_svfiprintf_r+0x1621>
42014cbb:	832c      	movi.n	a3, 40
42014cbd:	966132        	s32i	a3, a1, 0x258
42014cc0:	942132        	l32i	a3, a1, 0x250
42014cc3:	962142        	l32i	a4, a1, 0x258
42014cc6:	803340        	add	a3, a3, a4
42014cc9:	f8c332        	addi	a3, a3, -8
42014ccc:	0368      	l32i.n	a6, a3, 0
42014cce:	1378      	l32i.n	a7, a3, 4
42014cd0:	00aa06        	j	42014f7c <_svfiprintf_r+0x18e0>
42014cd3:	00          	.byte 00
42014cd4:	972192        	l32i	a9, a1, 0x25c
42014cd7:	756947        	bbci	a9, 4, 42014d50 <_svfiprintf_r+0x16b4>
42014cda:	c69c      	beqz.n	a6, 42014cfa <_svfiprintf_r+0x165e>
42014cdc:	08a387        	bge	a3, a8, 42014ce8 <_svfiprintf_r+0x164c>
42014cdf:	10c1a2        	addi	a10, a1, 16
42014ce2:	b033a0        	addx8	a3, a3, a10
42014ce5:	007c06        	j	42014ed9 <_svfiprintf_r+0x183d>
42014ce8:	10c1c2        	addi	a12, a1, 16
42014ceb:	30a262        	movi	a6, 0x230
42014cee:	6c6a      	add.n	a6, a12, a6
42014cf0:	0169      	s32i.n	a6, a1, 0
42014cf2:	01dcf2        	addmi	a15, a12, 0x100
42014cf5:	0ced      	mov.n	a14, a12
42014cf7:	007d06        	j	42014eef <_svfiprintf_r+0x1853>
42014cfa:	10c1d2        	addi	a13, a1, 16
42014cfd:	241b      	addi.n	a2, a4, 1
42014cff:	b033d0        	addx8	a3, a3, a13
42014d02:	02a487        	bge	a4, a8, 42014d08 <_svfiprintf_r+0x166c>
42014d05:	009bc6        	j	42014f78 <_svfiprintf_r+0x18dc>
42014d08:	10c1e2        	addi	a14, a1, 16
42014d0b:	922e72        	l32i	a7, a14, 0x248
42014d0e:	f91c      	movi.n	a9, 31
42014d10:	02de42        	addmi	a4, a14, 0x200
42014d13:	374b      	addi.n	a3, a7, 4
42014d15:	861c      	movi.n	a6, 24
42014d17:	02a987        	bge	a9, a8, 42014d1d <_svfiprintf_r+0x1681>
42014d1a:	008e86        	j	42014f58 <_svfiprintf_r+0x18bc>
42014d1d:	981b      	addi.n	a9, a8, 1
42014d1f:	916192        	s32i	a9, a1, 0x244
42014d22:	126432        	s32i	a3, a4, 72
42014d25:	072637        	blt	a6, a3, 42014d30 <_svfiprintf_r+0x1694>
42014d28:	112432        	l32i	a3, a4, 68
42014d2b:	000306        	j	42014d3b <_svfiprintf_r+0x169f>
42014d2e:	00          	.byte 00
42014d2f:	00          	.byte 00
42014d30:	012677        	blt	a6, a7, 42014d35 <_svfiprintf_r+0x1699>
42014d33:	432c      	movi.n	a3, 36
42014d35:	966132        	s32i	a3, a1, 0x258
42014d38:	942132        	l32i	a3, a1, 0x250
42014d3b:	962142        	l32i	a4, a1, 0x258
42014d3e:	334a      	add.n	a3, a3, a4
42014d40:	fcc332        	addi	a3, a3, -4
42014d43:	0368      	l32i.n	a6, a3, 0
42014d45:	10c132        	addi	a3, a1, 16
42014d48:	b08830        	addx8	a8, a8, a3
42014d4b:	008106        	j	42014f53 <_svfiprintf_r+0x18b7>
42014d4e:	00          	.byte 00
42014d4f:	00          	.byte 00
42014d50:	972192        	l32i	a9, a1, 0x25c
42014d53:	02e967        	bbsi	a9, 6, 42014d59 <_svfiprintf_r+0x16bd>
42014d56:	002d86        	j	42014e10 <_svfiprintf_r+0x1774>
42014d59:	76bc      	beqz.n	a6, 42014d94 <_svfiprintf_r+0x16f8>
42014d5b:	0da387        	bge	a3, a8, 42014d6c <_svfiprintf_r+0x16d0>
42014d5e:	10c1a2        	addi	a10, a1, 16
42014d61:	b033a0        	addx8	a3, a3, a10
42014d64:	001362        	l16ui	a6, a3, 0
42014d67:	0065c6        	j	42014f02 <_svfiprintf_r+0x1866>
42014d6a:	00          	.byte 00
42014d6b:	00          	.byte 00
42014d6c:	10c1c2        	addi	a12, a1, 16
42014d6f:	30a262        	movi	a6, 0x230
42014d72:	34a2d2        	movi	a13, 0x234
42014d75:	6c6a      	add.n	a6, a12, a6
42014d77:	0ced      	mov.n	a14, a12
42014d79:	01dcf2        	addmi	a15, a12, 0x100
42014d7c:	dcda      	add.n	a13, a12, a13
42014d7e:	40a2c2        	movi	a12, 0x240
42014d81:	0169      	s32i.n	a6, a1, 0
42014d83:	ceca      	add.n	a12, a14, a12
42014d85:	02bd      	mov.n	a11, a2
42014d87:	03ad      	mov.n	a10, a3
42014d89:	fe30e5        	call8	42013098 <get_arg$constprop$0>
42014d8c:	001a62        	l16ui	a6, a10, 0
42014d8f:	005bc6        	j	42014f02 <_svfiprintf_r+0x1866>
42014d92:	00          	.byte 00
42014d93:	00          	.byte 00
42014d94:	10c1d2        	addi	a13, a1, 16
42014d97:	241b      	addi.n	a2, a4, 1
42014d99:	b033d0        	addx8	a3, a3, a13
42014d9c:	682487        	blt	a4, a8, 42014e08 <_svfiprintf_r+0x176c>
42014d9f:	10c1e2        	addi	a14, a1, 16
42014da2:	922e72        	l32i	a7, a14, 0x248
42014da5:	f91c      	movi.n	a9, 31
42014da7:	02de42        	addmi	a4, a14, 0x200
42014daa:	374b      	addi.n	a3, a7, 4
42014dac:	861c      	movi.n	a6, 24
42014dae:	362987        	blt	a9, a8, 42014de8 <_svfiprintf_r+0x174c>
42014db1:	981b      	addi.n	a9, a8, 1
42014db3:	916192        	s32i	a9, a1, 0x244
42014db6:	126432        	s32i	a3, a4, 72
42014db9:	072637        	blt	a6, a3, 42014dc4 <_svfiprintf_r+0x1728>
42014dbc:	112432        	l32i	a3, a4, 68
42014dbf:	000306        	j	42014dcf <_svfiprintf_r+0x1733>
42014dc2:	00          	.byte 00
42014dc3:	00          	.byte 00
42014dc4:	012677        	blt	a6, a7, 42014dc9 <_svfiprintf_r+0x172d>
42014dc7:	432c      	movi.n	a3, 36
42014dc9:	966132        	s32i	a3, a1, 0x258
42014dcc:	942132        	l32i	a3, a1, 0x250
42014dcf:	962142        	l32i	a4, a1, 0x258
42014dd2:	334a      	add.n	a3, a3, a4
42014dd4:	fcc332        	addi	a3, a3, -4
42014dd7:	0368      	l32i.n	a6, a3, 0
42014dd9:	10c132        	addi	a3, a1, 16
42014ddc:	b08830        	addx8	a8, a8, a3
42014ddf:	0869      	s32i.n	a6, a8, 0
42014de1:	f46060        	extui	a6, a6, 0, 16
42014de4:	006486        	j	42014f7a <_svfiprintf_r+0x18de>
42014de7:	00          	.byte 00
42014de8:	126432        	s32i	a3, a4, 72
42014deb:	052637        	blt	a6, a3, 42014df4 <_svfiprintf_r+0x1758>
42014dee:	112432        	l32i	a3, a4, 68
42014df1:	000286        	j	42014dff <_svfiprintf_r+0x1763>
42014df4:	012677        	blt	a6, a7, 42014df9 <_svfiprintf_r+0x175d>
42014df7:	432c      	movi.n	a3, 36
42014df9:	966132        	s32i	a3, a1, 0x258
42014dfc:	942132        	l32i	a3, a1, 0x250
42014dff:	962142        	l32i	a4, a1, 0x258
42014e02:	803340        	add	a3, a3, a4
42014e05:	fcc332        	addi	a3, a3, -4
42014e08:	001362        	l16ui	a6, a3, 0
42014e0b:	005ac6        	j	42014f7a <_svfiprintf_r+0x18de>
42014e0e:	00          	.byte 00
42014e0f:	00          	.byte 00
42014e10:	972192        	l32i	a9, a1, 0x25c
42014e13:	02e997        	bbsi	a9, 9, 42014e19 <_svfiprintf_r+0x177d>
42014e16:	002d06        	j	42014ece <_svfiprintf_r+0x1832>
42014e19:	76bc      	beqz.n	a6, 42014e54 <_svfiprintf_r+0x17b8>
42014e1b:	0da387        	bge	a3, a8, 42014e2c <_svfiprintf_r+0x1790>
42014e1e:	10c1a2        	addi	a10, a1, 16
42014e21:	b033a0        	addx8	a3, a3, a10
42014e24:	000362        	l8ui	a6, a3, 0
42014e27:	0035c6        	j	42014f02 <_svfiprintf_r+0x1866>
42014e2a:	00          	.byte 00
42014e2b:	00          	.byte 00
42014e2c:	10c1c2        	addi	a12, a1, 16
42014e2f:	30a262        	movi	a6, 0x230
42014e32:	34a2d2        	movi	a13, 0x234
42014e35:	6c6a      	add.n	a6, a12, a6
42014e37:	0ced      	mov.n	a14, a12
42014e39:	01dcf2        	addmi	a15, a12, 0x100
42014e3c:	dcda      	add.n	a13, a12, a13
42014e3e:	40a2c2        	movi	a12, 0x240
42014e41:	0169      	s32i.n	a6, a1, 0
42014e43:	ceca      	add.n	a12, a14, a12
42014e45:	02bd      	mov.n	a11, a2
42014e47:	03ad      	mov.n	a10, a3
42014e49:	fe24e5        	call8	42013098 <get_arg$constprop$0>
42014e4c:	000a62        	l8ui	a6, a10, 0
42014e4f:	002bc6        	j	42014f02 <_svfiprintf_r+0x1866>
42014e52:	00          	.byte 00
42014e53:	00          	.byte 00
42014e54:	10c1d2        	addi	a13, a1, 16
42014e57:	241b      	addi.n	a2, a4, 1
42014e59:	b033d0        	addx8	a3, a3, a13
42014e5c:	682487        	blt	a4, a8, 42014ec8 <_svfiprintf_r+0x182c>
42014e5f:	10c1e2        	addi	a14, a1, 16
42014e62:	922e72        	l32i	a7, a14, 0x248
42014e65:	f91c      	movi.n	a9, 31
42014e67:	02de42        	addmi	a4, a14, 0x200
42014e6a:	374b      	addi.n	a3, a7, 4
42014e6c:	861c      	movi.n	a6, 24
42014e6e:	362987        	blt	a9, a8, 42014ea8 <_svfiprintf_r+0x180c>
42014e71:	981b      	addi.n	a9, a8, 1
42014e73:	916192        	s32i	a9, a1, 0x244
42014e76:	126432        	s32i	a3, a4, 72
42014e79:	052637        	blt	a6, a3, 42014e82 <_svfiprintf_r+0x17e6>
42014e7c:	112432        	l32i	a3, a4, 68
42014e7f:	0002c6        	j	42014e8e <_svfiprintf_r+0x17f2>
42014e82:	022677        	blt	a6, a7, 42014e88 <_svfiprintf_r+0x17ec>
42014e85:	24a032        	movi	a3, 36
42014e88:	966132        	s32i	a3, a1, 0x258
42014e8b:	942132        	l32i	a3, a1, 0x250
42014e8e:	962142        	l32i	a4, a1, 0x258
42014e91:	334a      	add.n	a3, a3, a4
42014e93:	fcc332        	addi	a3, a3, -4
42014e96:	0368      	l32i.n	a6, a3, 0
42014e98:	10c132        	addi	a3, a1, 16
42014e9b:	b08830        	addx8	a8, a8, a3
42014e9e:	0869      	s32i.n	a6, a8, 0
42014ea0:	746060        	extui	a6, a6, 0, 8
42014ea3:	0034c6        	j	42014f7a <_svfiprintf_r+0x18de>
42014ea6:	00          	.byte 00
42014ea7:	00          	.byte 00
42014ea8:	126432        	s32i	a3, a4, 72
42014eab:	052637        	blt	a6, a3, 42014eb4 <_svfiprintf_r+0x1818>
42014eae:	112432        	l32i	a3, a4, 68
42014eb1:	000286        	j	42014ebf <_svfiprintf_r+0x1823>
42014eb4:	012677        	blt	a6, a7, 42014eb9 <_svfiprintf_r+0x181d>
42014eb7:	432c      	movi.n	a3, 36
42014eb9:	966132        	s32i	a3, a1, 0x258
42014ebc:	942132        	l32i	a3, a1, 0x250
42014ebf:	962142        	l32i	a4, a1, 0x258
42014ec2:	803340        	add	a3, a3, a4
42014ec5:	fcc332        	addi	a3, a3, -4
42014ec8:	000362        	l8ui	a6, a3, 0
42014ecb:	002ac6        	j	42014f7a <_svfiprintf_r+0x18de>
42014ece:	66bc      	beqz.n	a6, 42014f08 <_svfiprintf_r+0x186c>
42014ed0:	0ca387        	bge	a3, a8, 42014ee0 <_svfiprintf_r+0x1844>
42014ed3:	10c182        	addi	a8, a1, 16
42014ed6:	b03380        	addx8	a3, a3, a8
42014ed9:	0368      	l32i.n	a6, a3, 0
42014edb:	0008c6        	j	42014f02 <_svfiprintf_r+0x1866>
42014ede:	00          	.byte 00
42014edf:	00          	.byte 00
42014ee0:	10c192        	addi	a9, a1, 16
42014ee3:	30a262        	movi	a6, 0x230
42014ee6:	696a      	add.n	a6, a9, a6
42014ee8:	0169      	s32i.n	a6, a1, 0
42014eea:	01d9f2        	addmi	a15, a9, 0x100
42014eed:	09ed      	mov.n	a14, a9
42014eef:	34a2d2        	movi	a13, 0x234
42014ef2:	40a2c2        	movi	a12, 0x240
42014ef5:	deda      	add.n	a13, a14, a13
42014ef7:	ceca      	add.n	a12, a14, a12
42014ef9:	02bd      	mov.n	a11, a2
42014efb:	03ad      	mov.n	a10, a3
42014efd:	fe19a5        	call8	42013098 <get_arg$constprop$0>
42014f00:	0a68      	l32i.n	a6, a10, 0
42014f02:	042d      	mov.n	a2, a4
42014f04:	001c86        	j	42014f7a <_svfiprintf_r+0x18de>
42014f07:	00          	.byte 00
42014f08:	10c1a2        	addi	a10, a1, 16
42014f0b:	241b      	addi.n	a2, a4, 1
42014f0d:	b033a0        	addx8	a3, a3, a10
42014f10:	642487        	blt	a4, a8, 42014f78 <_svfiprintf_r+0x18dc>
42014f13:	10c1c2        	addi	a12, a1, 16
42014f16:	922c72        	l32i	a7, a12, 0x248
42014f19:	f91c      	movi.n	a9, 31
42014f1b:	02dc42        	addmi	a4, a12, 0x200
42014f1e:	374b      	addi.n	a3, a7, 4
42014f20:	861c      	movi.n	a6, 24
42014f22:	322987        	blt	a9, a8, 42014f58 <_svfiprintf_r+0x18bc>
42014f25:	981b      	addi.n	a9, a8, 1
42014f27:	916192        	s32i	a9, a1, 0x244
42014f2a:	126432        	s32i	a3, a4, 72
42014f2d:	072637        	blt	a6, a3, 42014f38 <_svfiprintf_r+0x189c>
42014f30:	112432        	l32i	a3, a4, 68
42014f33:	000306        	j	42014f43 <_svfiprintf_r+0x18a7>
42014f36:	00          	.byte 00
42014f37:	00          	.byte 00
42014f38:	012677        	blt	a6, a7, 42014f3d <_svfiprintf_r+0x18a1>
42014f3b:	432c      	movi.n	a3, 36
42014f3d:	966132        	s32i	a3, a1, 0x258
42014f40:	942132        	l32i	a3, a1, 0x250
42014f43:	962142        	l32i	a4, a1, 0x258
42014f46:	10c1e2        	addi	a14, a1, 16
42014f49:	334a      	add.n	a3, a3, a4
42014f4b:	fcc332        	addi	a3, a3, -4
42014f4e:	0368      	l32i.n	a6, a3, 0
42014f50:	b088e0        	addx8	a8, a8, a14
42014f53:	0869      	s32i.n	a6, a8, 0
42014f55:	000846        	j	42014f7a <_svfiprintf_r+0x18de>
42014f58:	126432        	s32i	a3, a4, 72
42014f5b:	052637        	blt	a6, a3, 42014f64 <_svfiprintf_r+0x18c8>
42014f5e:	112432        	l32i	a3, a4, 68
42014f61:	000286        	j	42014f6f <_svfiprintf_r+0x18d3>
42014f64:	012677        	blt	a6, a7, 42014f69 <_svfiprintf_r+0x18cd>
42014f67:	432c      	movi.n	a3, 36
42014f69:	966132        	s32i	a3, a1, 0x258
42014f6c:	942132        	l32i	a3, a1, 0x250
42014f6f:	962142        	l32i	a4, a1, 0x258
42014f72:	803340        	add	a3, a3, a4
42014f75:	fcc332        	addi	a3, a3, -4
42014f78:	0368      	l32i.n	a6, a3, 0
42014f7a:	070c      	movi.n	a7, 0
42014f7c:	203670        	or	a3, a6, a7
42014f7f:	e39c      	beqz.n	a3, 42014fa1 <_svfiprintf_r+0x1905>
42014f81:	972132        	l32i	a3, a1, 0x25c
42014f84:	196307        	bbci	a3, 0, 42014fa1 <_svfiprintf_r+0x1905>
42014f87:	10c182        	addi	a8, a1, 16
42014f8a:	02d832        	addmi	a3, a8, 0x200
42014f8d:	972192        	l32i	a9, a1, 0x25c
42014f90:	043c      	movi.n	a4, 48
42014f92:	384342        	s8i	a4, a3, 56
42014f95:	394352        	s8i	a5, a3, 57
42014f98:	02a032        	movi	a3, 2
42014f9b:	209930        	or	a9, a9, a3
42014f9e:	976192        	s32i	a9, a1, 0x25c
42014fa1:	972142        	l32i	a4, a1, 0x25c
42014fa4:	ffab32        	movi	a3, 0xfffffbff
42014fa7:	104430        	and	a4, a4, a3
42014faa:	976142        	s32i	a4, a1, 0x25c
42014fad:	240c      	movi.n	a4, 2
42014faf:	00a032        	movi	a3, 0
42014fb2:	10c182        	addi	a8, a1, 16
42014fb5:	02d852        	addmi	a5, a8, 0x200
42014fb8:	992192        	l32i	a9, a1, 0x264
42014fbb:	3a4532        	s8i	a3, a5, 58
42014fbe:	260926        	beqi	a9, -1, 42014fe8 <_svfiprintf_r+0x194c>
42014fc1:	972152        	l32i	a5, a1, 0x25c
42014fc4:	972182        	l32i	a8, a1, 0x25c
42014fc7:	7faf32        	movi	a3, -129
42014fca:	108830        	and	a8, a8, a3
42014fcd:	209670        	or	a9, a6, a7
42014fd0:	976182        	s32i	a8, a1, 0x25c
42014fd3:	130c      	movi.n	a3, 1
42014fd5:	080c      	movi.n	a8, 0
42014fd7:	938390        	movnez	a8, a3, a9
42014fda:	749080        	extui	a9, a8, 0, 8
42014fdd:	78cc      	bnez.n	a8, 42014fe8 <_svfiprintf_r+0x194c>
42014fdf:	992182        	l32i	a8, a1, 0x264
42014fe2:	833980        	moveqz	a3, a9, a8
42014fe5:	134316        	beqz	a3, 4201511d <_svfiprintf_r+0x1a81>
42014fe8:	501426        	beqi	a4, 1, 4201503c <_svfiprintf_r+0x19a0>
42014feb:	90a192        	movi	a9, 0x190
42014fee:	991a      	add.n	a9, a9, a1
42014ff0:	64c932        	addi	a3, a9, 100
42014ff3:	022466        	bnei	a4, 2, 42014ff9 <_svfiprintf_r+0x195d>
42014ff6:	003f86        	j	420150f8 <_svfiprintf_r+0x1a5c>
42014ff9:	018730        	slli	a8, a7, 29
42014ffc:	244060        	extui	a4, a6, 0, 3
42014fff:	416360        	srli	a6, a6, 3
42015002:	035d      	mov.n	a5, a3
42015004:	30c442        	addi	a4, a4, 48
42015007:	330b      	addi.n	a3, a3, -1
42015009:	206860        	or	a6, a8, a6
4201500c:	417370        	srli	a7, a7, 3
4201500f:	004342        	s8i	a4, a3, 0
42015012:	208670        	or	a8, a6, a7
42015015:	fe0856        	bnez	a8, 42014ff9 <_svfiprintf_r+0x195d>
42015018:	d0c462        	addi	a6, a4, -48
4201501b:	140c      	movi.n	a4, 1
4201501d:	834860        	moveqz	a4, a8, a6
42015020:	744040        	extui	a4, a4, 0, 8
42015023:	11d416        	beqz	a4, 42015144 <_svfiprintf_r+0x1aa8>
42015026:	972142        	l32i	a4, a1, 0x25c
42015029:	02e407        	bbsi	a4, 0, 4201502f <_svfiprintf_r+0x1993>
4201502c:	004506        	j	42015144 <_svfiprintf_r+0x1aa8>
4201502f:	330b      	addi.n	a3, a3, -1
42015031:	043c      	movi.n	a4, 48
42015033:	004342        	s8i	a4, a3, 0
42015036:	fec532        	addi	a3, a5, -2
42015039:	0041c6        	j	42015144 <_svfiprintf_r+0x1aa8>
4201503c:	87dc      	bnez.n	a7, 42015058 <_svfiprintf_r+0x19bc>
4201503e:	930c      	movi.n	a3, 9
42015040:	143367        	bltu	a3, a6, 42015058 <_svfiprintf_r+0x19bc>
42015043:	10c152        	addi	a5, a1, 16
42015046:	30c662        	addi	a6, a6, 48
42015049:	01d532        	addmi	a3, a5, 0x100
4201504c:	e34362        	s8i	a6, a3, 227
4201504f:	90a162        	movi	a6, 0x190
42015052:	661a      	add.n	a6, a6, a1
42015054:	003a46        	j	42015141 <_svfiprintf_r+0x1aa5>
42015057:	00          	.byte 00
42015058:	972182        	l32i	a8, a1, 0x25c
4201505b:	00a442        	movi	a4, 0x400
4201505e:	a42132        	l32i	a3, a1, 0x290
42015061:	050c      	movi.n	a5, 0
42015063:	104840        	and	a4, a8, a4
42015066:	0000c6        	j	4201506d <_svfiprintf_r+0x19d1>
42015069:	0a6d      	mov.n	a6, a10
4201506b:	0b7d      	mov.n	a7, a11
4201506d:	ac0c      	movi.n	a12, 10
4201506f:	0d0c      	movi.n	a13, 0
42015071:	20a660        	or	a10, a6, a6
42015074:	07bd      	mov.n	a11, a7
42015076:	aee781        	l32r	a8, 42000c14 <_stext+0xbf4>
42015079:	0008e0        	callx8	a8
4201507c:	330b      	addi.n	a3, a3, -1
4201507e:	30caa2        	addi	a10, a10, 48
42015081:	0043a2        	s8i	a10, a3, 0
42015084:	551b      	addi.n	a5, a5, 1
42015086:	050416        	beqz	a4, 420150da <_svfiprintf_r+0x1a3e>
42015089:	a12192        	l32i	a9, a1, 0x284
4201508c:	1c0c      	movi.n	a12, 1
4201508e:	0009b2        	l8ui	a11, a9, 0
42015091:	77cc      	bnez.n	a7, 4201509c <_svfiprintf_r+0x1a00>
42015093:	09a082        	movi	a8, 9
42015096:	023867        	bltu	a8, a6, 4201509c <_svfiprintf_r+0x1a00>
42015099:	20c770        	or	a12, a7, a7
4201509c:	01afa2        	movi	a10, -255
4201509f:	abaa      	add.n	a10, a11, a10
420150a1:	090c      	movi.n	a9, 0
420150a3:	180c      	movi.n	a8, 1
420150a5:	8389a0        	moveqz	a8, a9, a10
420150a8:	2e08c7        	bnone	a8, a12, 420150da <_svfiprintf_r+0x1a3e>
420150ab:	2b9b57        	bne	a11, a5, 420150da <_svfiprintf_r+0x1a3e>
420150ae:	a22152        	l32i	a5, a1, 0x288
420150b1:	a321b2        	l32i	a11, a1, 0x28c
420150b4:	c03350        	sub	a3, a3, a5
420150b7:	05cd      	mov.n	a12, a5
420150b9:	20a330        	or	a10, a3, a3
420150bc:	a66192        	s32i	a9, a1, 0x298
420150bf:	ae9181        	l32r	a8, 42000b04 <_stext+0xae4>
420150c2:	0008e0        	callx8	a8
420150c5:	a12152        	l32i	a5, a1, 0x284
420150c8:	a62192        	l32i	a9, a1, 0x298
420150cb:	010582        	l8ui	a8, a5, 1
420150ce:	095d      	mov.n	a5, a9
420150d0:	688c      	beqz.n	a8, 420150da <_svfiprintf_r+0x1a3e>
420150d2:	a12182        	l32i	a8, a1, 0x284
420150d5:	881b      	addi.n	a8, a8, 1
420150d7:	a16182        	s32i	a8, a1, 0x284
420150da:	ac0c      	movi.n	a12, 10
420150dc:	0d0c      	movi.n	a13, 0
420150de:	06ad      	mov.n	a10, a6
420150e0:	07bd      	mov.n	a11, a7
420150e2:	abef81        	l32r	a8, 420000a0 <_stext+0x80>
420150e5:	0008e0        	callx8	a8
420150e8:	f7d756        	bnez	a7, 42015069 <_svfiprintf_r+0x19cd>
420150eb:	970c      	movi.n	a7, 9
420150ed:	02b767        	bgeu	a7, a6, 420150f3 <_svfiprintf_r+0x1a57>
420150f0:	ffdd46        	j	42015069 <_svfiprintf_r+0x19cd>
420150f3:	001346        	j	42015144 <_svfiprintf_r+0x1aa8>
420150f6:	00          	.byte 00
420150f7:	00          	.byte 00
420150f8:	9f2152        	l32i	a5, a1, 0x27c
420150fb:	344060        	extui	a4, a6, 0, 4
420150fe:	454a      	add.n	a4, a5, a4
42015100:	000442        	l8ui	a4, a4, 0
42015103:	330b      	addi.n	a3, a3, -1
42015105:	004342        	s8i	a4, a3, 0
42015108:	416460        	srli	a6, a6, 4
4201510b:	014740        	slli	a4, a7, 28
4201510e:	206460        	or	a6, a4, a6
42015111:	417470        	srli	a7, a7, 4
42015114:	204670        	or	a4, a6, a7
42015117:	fdd456        	bnez	a4, 420150f8 <_svfiprintf_r+0x1a5c>
4201511a:	000986        	j	42015144 <_svfiprintf_r+0x1aa8>
4201511d:	90a162        	movi	a6, 0x190
42015120:	996132        	s32i	a3, a1, 0x264
42015123:	661a      	add.n	a6, a6, a1
42015125:	64c632        	addi	a3, a6, 100
42015128:	84dc      	bnez.n	a4, 42015144 <_svfiprintf_r+0x1aa8>
4201512a:	045050        	extui	a5, a5, 0, 1
4201512d:	996152        	s32i	a5, a1, 0x264
42015130:	059c      	beqz.n	a5, 42015144 <_svfiprintf_r+0x1aa8>
42015132:	10c182        	addi	a8, a1, 16
42015135:	30a052        	movi	a5, 48
42015138:	01d832        	addmi	a3, a8, 0x100
4201513b:	e34352        	s8i	a5, a3, 227
4201513e:	996142        	s32i	a4, a1, 0x264
42015141:	63c632        	addi	a3, a6, 99
42015144:	a42192        	l32i	a9, a1, 0x290
42015147:	992142        	l32i	a4, a1, 0x264
4201514a:	c09930        	sub	a9, a9, a3
4201514d:	996192        	s32i	a9, a1, 0x264
42015150:	000946        	j	42015179 <_svfiprintf_r+0x1add>
42015153:	00          	.byte 00
42015154:	3e4516        	beqz	a5, 4201553c <_svfiprintf_r+0x1ea0>
42015157:	10c1a2        	addi	a10, a1, 16
4201515a:	01da22        	addmi	a2, a10, 0x100
4201515d:	804252        	s8i	a5, a2, 128
42015160:	030c      	movi.n	a3, 0
42015162:	02da22        	addmi	a2, a10, 0x200
42015165:	3a4232        	s8i	a3, a2, 58
42015168:	90a152        	movi	a5, 0x190
4201516b:	130c      	movi.n	a3, 1
4201516d:	202440        	or	a2, a4, a4
42015170:	996132        	s32i	a3, a1, 0x264
42015173:	00a042        	movi	a4, 0
42015176:	803150        	add	a3, a1, a5
42015179:	992162        	l32i	a6, a1, 0x264
4201517c:	10c182        	addi	a8, a1, 16
4201517f:	535460        	max	a5, a4, a6
42015182:	02d862        	addmi	a6, a8, 0x200
42015185:	3a0662        	l8ui	a6, a6, 58
42015188:	068c      	beqz.n	a6, 4201518c <_svfiprintf_r+0x1af0>
4201518a:	551b      	addi.n	a5, a5, 1
4201518c:	972192        	l32i	a9, a1, 0x25c
4201518f:	270c      	movi.n	a7, 2
42015191:	107970        	and	a7, a9, a7
42015194:	078c      	beqz.n	a7, 42015198 <_svfiprintf_r+0x1afc>
42015196:	552b      	addi.n	a5, a5, 2
42015198:	972182        	l32i	a8, a1, 0x25c
4201519b:	84a062        	movi	a6, 132
4201519e:	106860        	and	a6, a8, a6
420151a1:	0a1656        	bnez	a6, 42015246 <_svfiprintf_r+0x1baa>
420151a4:	9d2192        	l32i	a9, a1, 0x274
420151a7:	c08950        	sub	a8, a9, a5
420151aa:	0218e6        	bgei	a8, 1, 420151b0 <_svfiprintf_r+0x1b14>
420151ad:	002546        	j	42015246 <_svfiprintf_r+0x1baa>
420151b0:	0e1c      	movi.n	a14, 16
420151b2:	24a2d2        	movi	a13, 0x224
420151b5:	f1ea      	add.n	a15, a1, a14
420151b7:	ffda      	add.n	a15, a15, a13
420151b9:	a061f2        	s32i	a15, a1, 0x280
420151bc:	000fc6        	j	420151ff <_svfiprintf_r+0x1b63>
420151bf:	00          	.byte 00
420151c0:	9821d2        	l32i	a13, a1, 0x260
420151c3:	aecff1        	l32r	a15, 42000d00 <_stext+0xce0>
420151c6:	10ccc2        	addi	a12, a12, 16
420151c9:	0df9      	s32i.n	a15, a13, 0
420151cb:	016de2        	s32i	a14, a13, 4
420151ce:	bac9      	s32i.n	a12, a10, 44
420151d0:	0a6a92        	s32i	a9, a10, 40
420151d3:	2289a6        	blti	a9, 8, 420151f9 <_svfiprintf_r+0x1b5d>
420151d6:	a021c2        	l32i	a12, a1, 0x280
420151d9:	9b21b2        	l32i	a11, a1, 0x26c
420151dc:	9c21a2        	l32i	a10, a1, 0x270
420151df:	a76182        	s32i	a8, a1, 0x29c
420151e2:	a561e2        	s32i	a14, a1, 0x294
420151e5:	fe3aa5        	call8	42013590 <__ssprint_r>
420151e8:	a72182        	l32i	a8, a1, 0x29c
420151eb:	a521e2        	l32i	a14, a1, 0x294
420151ee:	362a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
420151f1:	e4a1b2        	movi	a11, 0x1e4
420151f4:	10c192        	addi	a9, a1, 16
420151f7:	b9ba      	add.n	a11, a9, a11
420151f9:	f0c882        	addi	a8, a8, -16
420151fc:	9861b2        	s32i	a11, a1, 0x260
420151ff:	10c1c2        	addi	a12, a1, 16
42015202:	9821d2        	l32i	a13, a1, 0x260
42015205:	8a2c92        	l32i	a9, a12, 0x228
42015208:	02dca2        	addmi	a10, a12, 0x200
4201520b:	bac8      	l32i.n	a12, a10, 44
4201520d:	991b      	addi.n	a9, a9, 1
4201520f:	bd8b      	addi.n	a11, a13, 8
42015211:	ab2e87        	blt	a14, a8, 420151c0 <_svfiprintf_r+0x1b24>
42015214:	aebbe1        	l32r	a14, 42000d00 <_stext+0xce0>
42015217:	1d89      	s32i.n	a8, a13, 4
42015219:	88ca      	add.n	a8, a8, a12
4201521b:	0de9      	s32i.n	a14, a13, 0
4201521d:	ba89      	s32i.n	a8, a10, 44
4201521f:	aa99      	s32i.n	a9, a10, 40
42015221:	9861b2        	s32i	a11, a1, 0x260
42015224:	1e89a6        	blti	a9, 8, 42015246 <_svfiprintf_r+0x1baa>
42015227:	24a2c2        	movi	a12, 0x224
4201522a:	10c1f2        	addi	a15, a1, 16
4201522d:	9b21b2        	l32i	a11, a1, 0x26c
42015230:	9c21a2        	l32i	a10, a1, 0x270
42015233:	cfca      	add.n	a12, a15, a12
42015235:	fe35a5        	call8	42013590 <__ssprint_r>
42015238:	318a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
4201523b:	e4a182        	movi	a8, 0x1e4
4201523e:	10c192        	addi	a9, a1, 16
42015241:	998a      	add.n	a9, a9, a8
42015243:	986192        	s32i	a9, a1, 0x260
42015246:	10c1c2        	addi	a12, a1, 16
42015249:	02dca2        	addmi	a10, a12, 0x200
4201524c:	3a0a92        	l8ui	a9, a10, 58
4201524f:	8f2182        	l32i	a8, a1, 0x23c
42015252:	8e21b2        	l32i	a11, a1, 0x238
42015255:	043916        	beqz	a9, 4201529c <_svfiprintf_r+0x1c00>
42015258:	9821d2        	l32i	a13, a1, 0x260
4201525b:	3aa292        	movi	a9, 0x23a
4201525e:	9c9a      	add.n	a9, a12, a9
42015260:	0d99      	s32i.n	a9, a13, 0
42015262:	190c      	movi.n	a9, 1
42015264:	bb1b      	addi.n	a11, a11, 1
42015266:	889a      	add.n	a8, a8, a9
42015268:	1d99      	s32i.n	a9, a13, 4
4201526a:	8f6182        	s32i	a8, a1, 0x23c
4201526d:	8e61b2        	s32i	a11, a1, 0x238
42015270:	088be6        	bgei	a11, 8, 4201527c <_svfiprintf_r+0x1be0>
42015273:	dd8b      	addi.n	a13, a13, 8
42015275:	9861d2        	s32i	a13, a1, 0x260
42015278:	000806        	j	4201529c <_svfiprintf_r+0x1c00>
4201527b:	00          	.byte 00
4201527c:	24a2c2        	movi	a12, 0x224
4201527f:	10c1e2        	addi	a14, a1, 16
42015282:	9b21b2        	l32i	a11, a1, 0x26c
42015285:	9c21a2        	l32i	a10, a1, 0x270
42015288:	ceca      	add.n	a12, a14, a12
4201528a:	fe3065        	call8	42013590 <__ssprint_r>
4201528d:	2c3a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
42015290:	e4a182        	movi	a8, 0x1e4
42015293:	10c192        	addi	a9, a1, 16
42015296:	809980        	add	a9, a9, a8
42015299:	986192        	s32i	a9, a1, 0x260
4201529c:	8f21b2        	l32i	a11, a1, 0x23c
4201529f:	8e2192        	l32i	a9, a1, 0x238
420152a2:	10c1c2        	addi	a12, a1, 16
420152a5:	043716        	beqz	a7, 420152ec <_svfiprintf_r+0x1c50>
420152a8:	9821d2        	l32i	a13, a1, 0x260
420152ab:	270c      	movi.n	a7, 2
420152ad:	38a282        	movi	a8, 0x238
420152b0:	991b      	addi.n	a9, a9, 1
420152b2:	8c8a      	add.n	a8, a12, a8
420152b4:	1d79      	s32i.n	a7, a13, 4
420152b6:	7b7a      	add.n	a7, a11, a7
420152b8:	0d89      	s32i.n	a8, a13, 0
420152ba:	8f6172        	s32i	a7, a1, 0x23c
420152bd:	8e6192        	s32i	a9, a1, 0x238
420152c0:	0889e6        	bgei	a9, 8, 420152cc <_svfiprintf_r+0x1c30>
420152c3:	dd8b      	addi.n	a13, a13, 8
420152c5:	9861d2        	s32i	a13, a1, 0x260
420152c8:	000806        	j	420152ec <_svfiprintf_r+0x1c50>
420152cb:	00          	.byte 00
420152cc:	24a2c2        	movi	a12, 0x224
420152cf:	10c1e2        	addi	a14, a1, 16
420152d2:	9b21b2        	l32i	a11, a1, 0x26c
420152d5:	9c21a2        	l32i	a10, a1, 0x270
420152d8:	ceca      	add.n	a12, a14, a12
420152da:	fe2b65        	call8	42013590 <__ssprint_r>
420152dd:	273a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
420152e0:	e4a172        	movi	a7, 0x1e4
420152e3:	10c182        	addi	a8, a1, 16
420152e6:	808870        	add	a8, a8, a7
420152e9:	986182        	s32i	a8, a1, 0x260
420152ec:	02e626        	beqi	a6, 128, 420152f2 <_svfiprintf_r+0x1c56>
420152ef:	0027c6        	j	42015392 <_svfiprintf_r+0x1cf6>
420152f2:	9d2192        	l32i	a9, a1, 0x274
420152f5:	c06950        	sub	a6, a9, a5
420152f8:	0216e6        	bgei	a6, 1, 420152fe <_svfiprintf_r+0x1c62>
420152fb:	0024c6        	j	42015392 <_svfiprintf_r+0x1cf6>
420152fe:	0d1c      	movi.n	a13, 16
42015300:	24a292        	movi	a9, 0x224
42015303:	a1da      	add.n	a10, a1, a13
42015305:	9a9a      	add.n	a9, a10, a9
42015307:	000f06        	j	42015347 <_svfiprintf_r+0x1cab>
4201530a:	00          	.byte 00
4201530b:	00          	.byte 00
4201530c:	9821e2        	l32i	a14, a1, 0x260
4201530f:	10cbb2        	addi	a11, a11, 16
42015312:	0ec9      	s32i.n	a12, a14, 0
42015314:	1ed9      	s32i.n	a13, a14, 4
42015316:	0b68b2        	s32i	a11, a8, 44
42015319:	0a6872        	s32i	a7, a8, 40
4201531c:	2187a6        	blti	a7, 8, 42015341 <_svfiprintf_r+0x1ca5>
4201531f:	9b21b2        	l32i	a11, a1, 0x26c
42015322:	9c21a2        	l32i	a10, a1, 0x270
42015325:	09cd      	mov.n	a12, a9
42015327:	a66192        	s32i	a9, a1, 0x298
4201532a:	a561d2        	s32i	a13, a1, 0x294
4201532d:	fe2625        	call8	42013590 <__ssprint_r>
42015330:	a62192        	l32i	a9, a1, 0x298
42015333:	a521d2        	l32i	a13, a1, 0x294
42015336:	21aa56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
42015339:	e4a1a2        	movi	a10, 0x1e4
4201533c:	10c1f2        	addi	a15, a1, 16
4201533f:	afaa      	add.n	a10, a15, a10
42015341:	f0c662        	addi	a6, a6, -16
42015344:	9861a2        	s32i	a10, a1, 0x260
42015347:	10c1a2        	addi	a10, a1, 16
4201534a:	9821c2        	l32i	a12, a1, 0x260
4201534d:	8a2a72        	l32i	a7, a10, 0x228
42015350:	02da82        	addmi	a8, a10, 0x200
42015353:	771b      	addi.n	a7, a7, 1
42015355:	ac8b      	addi.n	a10, a12, 8
42015357:	b8b8      	l32i.n	a11, a8, 44
42015359:	ae6ac1        	l32r	a12, 42000d04 <_stext+0xce4>
4201535c:	ac2d67        	blt	a13, a6, 4201530c <_svfiprintf_r+0x1c70>
4201535f:	982192        	l32i	a9, a1, 0x260
42015362:	a879      	s32i.n	a7, a8, 40
42015364:	1969      	s32i.n	a6, a9, 4
42015366:	66ba      	add.n	a6, a6, a11
42015368:	09c9      	s32i.n	a12, a9, 0
4201536a:	0b6862        	s32i	a6, a8, 44
4201536d:	9861a2        	s32i	a10, a1, 0x260
42015370:	1e87a6        	blti	a7, 8, 42015392 <_svfiprintf_r+0x1cf6>
42015373:	10c1a2        	addi	a10, a1, 16
42015376:	24a2c2        	movi	a12, 0x224
42015379:	caca      	add.n	a12, a10, a12
4201537b:	9b21b2        	l32i	a11, a1, 0x26c
4201537e:	9c21a2        	l32i	a10, a1, 0x270
42015381:	fe20e5        	call8	42013590 <__ssprint_r>
42015384:	1cca56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
42015387:	e4a162        	movi	a6, 0x1e4
4201538a:	10c182        	addi	a8, a1, 16
4201538d:	886a      	add.n	a8, a8, a6
4201538f:	986182        	s32i	a8, a1, 0x260
42015392:	992192        	l32i	a9, a1, 0x264
42015395:	c04490        	sub	a4, a4, a9
42015398:	0214e6        	bgei	a4, 1, 4201539e <_svfiprintf_r+0x1d02>
4201539b:	0023c6        	j	4201542e <_svfiprintf_r+0x1d92>
4201539e:	091c      	movi.n	a9, 16
420153a0:	24a282        	movi	a8, 0x224
420153a3:	a19a      	add.n	a10, a1, a9
420153a5:	8a8a      	add.n	a8, a10, a8
420153a7:	000f06        	j	420153e7 <_svfiprintf_r+0x1d4b>
420153aa:	00          	.byte 00
420153ab:	00          	.byte 00
420153ac:	9821d2        	l32i	a13, a1, 0x260
420153af:	10cbb2        	addi	a11, a11, 16
420153b2:	0dc9      	s32i.n	a12, a13, 0
420153b4:	1d99      	s32i.n	a9, a13, 4
420153b6:	0b67b2        	s32i	a11, a7, 44
420153b9:	a769      	s32i.n	a6, a7, 40
420153bb:	2286a6        	blti	a6, 8, 420153e1 <_svfiprintf_r+0x1d45>
420153be:	9b21b2        	l32i	a11, a1, 0x26c
420153c1:	9c21a2        	l32i	a10, a1, 0x270
420153c4:	20c880        	or	a12, a8, a8
420153c7:	a76182        	s32i	a8, a1, 0x29c
420153ca:	a66192        	s32i	a9, a1, 0x298
420153cd:	fe1c25        	call8	42013590 <__ssprint_r>
420153d0:	a72182        	l32i	a8, a1, 0x29c
420153d3:	a62192        	l32i	a9, a1, 0x298
420153d6:	17aa56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
420153d9:	e4a1a2        	movi	a10, 0x1e4
420153dc:	10c1e2        	addi	a14, a1, 16
420153df:	aeaa      	add.n	a10, a14, a10
420153e1:	f0c442        	addi	a4, a4, -16
420153e4:	9861a2        	s32i	a10, a1, 0x260
420153e7:	10c1f2        	addi	a15, a1, 16
420153ea:	9821c2        	l32i	a12, a1, 0x260
420153ed:	8a2f62        	l32i	a6, a15, 0x228
420153f0:	02df72        	addmi	a7, a15, 0x200
420153f3:	ac8b      	addi.n	a10, a12, 8
420153f5:	661b      	addi.n	a6, a6, 1
420153f7:	ae43c1        	l32r	a12, 42000d04 <_stext+0xce4>
420153fa:	b7b8      	l32i.n	a11, a7, 44
420153fc:	ac2947        	blt	a9, a4, 420153ac <_svfiprintf_r+0x1d10>
420153ff:	982182        	l32i	a8, a1, 0x260
42015402:	a769      	s32i.n	a6, a7, 40
42015404:	1849      	s32i.n	a4, a8, 4
42015406:	44ba      	add.n	a4, a4, a11
42015408:	08c9      	s32i.n	a12, a8, 0
4201540a:	b749      	s32i.n	a4, a7, 44
4201540c:	9861a2        	s32i	a10, a1, 0x260
4201540f:	1b86a6        	blti	a6, 8, 4201542e <_svfiprintf_r+0x1d92>
42015412:	24a2c2        	movi	a12, 0x224
42015415:	9b21b2        	l32i	a11, a1, 0x26c
42015418:	9c21a2        	l32i	a10, a1, 0x270
4201541b:	cfca      	add.n	a12, a15, a12
4201541d:	fe1725        	call8	42013590 <__ssprint_r>
42015420:	130a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
42015423:	e4a142        	movi	a4, 0x1e4
42015426:	10c192        	addi	a9, a1, 16
42015429:	994a      	add.n	a9, a9, a4
4201542b:	986192        	s32i	a9, a1, 0x260
4201542e:	982142        	l32i	a4, a1, 0x260
42015431:	992162        	l32i	a6, a1, 0x264
42015434:	0439      	s32i.n	a3, a4, 0
42015436:	8f2132        	l32i	a3, a1, 0x23c
42015439:	1469      	s32i.n	a6, a4, 4
4201543b:	336a      	add.n	a3, a3, a6
4201543d:	8f6132        	s32i	a3, a1, 0x23c
42015440:	8e2132        	l32i	a3, a1, 0x238
42015443:	10c182        	addi	a8, a1, 16
42015446:	331b      	addi.n	a3, a3, 1
42015448:	8e6132        	s32i	a3, a1, 0x238
4201544b:	02d842        	addmi	a4, a8, 0x200
4201544e:	0783e6        	bgei	a3, 8, 42015459 <_svfiprintf_r+0x1dbd>
42015451:	982192        	l32i	a9, a1, 0x260
42015454:	398b      	addi.n	a3, a9, 8
42015456:	000706        	j	42015476 <_svfiprintf_r+0x1dda>
42015459:	10c1a2        	addi	a10, a1, 16
4201545c:	24a2c2        	movi	a12, 0x224
4201545f:	caca      	add.n	a12, a10, a12
42015461:	9b21b2        	l32i	a11, a1, 0x26c
42015464:	9c21a2        	l32i	a10, a1, 0x270
42015467:	fe12a5        	call8	42013590 <__ssprint_r>
4201546a:	0e6a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
4201546d:	e4a132        	movi	a3, 0x1e4
42015470:	10c1c2        	addi	a12, a1, 16
42015473:	803c30        	add	a3, a12, a3
42015476:	972142        	l32i	a4, a1, 0x25c
42015479:	17e427        	bbsi	a4, 2, 42015494 <_svfiprintf_r+0x1df8>
4201547c:	9d2162        	l32i	a6, a1, 0x274
4201547f:	9e2182        	l32i	a8, a1, 0x278
42015482:	535650        	max	a5, a6, a5
42015485:	885a      	add.n	a8, a8, a5
42015487:	8f2132        	l32i	a3, a1, 0x23c
4201548a:	9e6182        	s32i	a8, a1, 0x278
4201548d:	07b316        	beqz	a3, 4201550c <_svfiprintf_r+0x1e70>
42015490:	0023c6        	j	42015523 <_svfiprintf_r+0x1e87>
42015493:	00          	.byte 00
42015494:	9d2192        	l32i	a9, a1, 0x274
42015497:	c04950        	sub	a4, a9, a5
4201549a:	de14a6        	blti	a4, 1, 4201547c <_svfiprintf_r+0x1de0>
4201549d:	081c      	movi.n	a8, 16
4201549f:	24a272        	movi	a7, 0x224
420154a2:	a18a      	add.n	a10, a1, a8
420154a4:	7a7a      	add.n	a7, a10, a7
420154a6:	000b46        	j	420154d7 <_svfiprintf_r+0x1e3b>
420154a9:	10caa2        	addi	a10, a10, 16
420154ac:	1389      	s32i.n	a8, a3, 4
420154ae:	b9a9      	s32i.n	a10, a9, 44
420154b0:	a969      	s32i.n	a6, a9, 40
420154b2:	338b      	addi.n	a3, a3, 8
420154b4:	1c86a6        	blti	a6, 8, 420154d4 <_svfiprintf_r+0x1e38>
420154b7:	9b21b2        	l32i	a11, a1, 0x26c
420154ba:	9c21a2        	l32i	a10, a1, 0x270
420154bd:	07cd      	mov.n	a12, a7
420154bf:	a76182        	s32i	a8, a1, 0x29c
420154c2:	fe0ce5        	call8	42013590 <__ssprint_r>
420154c5:	a72182        	l32i	a8, a1, 0x29c
420154c8:	088a56        	bnez	a10, 42015554 <_svfiprintf_r+0x1eb8>
420154cb:	e4a132        	movi	a3, 0x1e4
420154ce:	10c1c2        	addi	a12, a1, 16
420154d1:	803c30        	add	a3, a12, a3
420154d4:	f0c442        	addi	a4, a4, -16
420154d7:	10c1d2        	addi	a13, a1, 16
420154da:	ae09b1        	l32r	a11, 42000d00 <_stext+0xce0>
420154dd:	8a2d62        	l32i	a6, a13, 0x228
420154e0:	03b9      	s32i.n	a11, a3, 0
420154e2:	02dd92        	addmi	a9, a13, 0x200
420154e5:	661b      	addi.n	a6, a6, 1
420154e7:	b9a8      	l32i.n	a10, a9, 44
420154e9:	bc2847        	blt	a8, a4, 420154a9 <_svfiprintf_r+0x1e0d>
420154ec:	1349      	s32i.n	a4, a3, 4
420154ee:	44aa      	add.n	a4, a4, a10
420154f0:	b949      	s32i.n	a4, a9, 44
420154f2:	a969      	s32i.n	a6, a9, 40
420154f4:	8486a6        	blti	a6, 8, 4201547c <_svfiprintf_r+0x1de0>
420154f7:	24a2c2        	movi	a12, 0x224
420154fa:	9b21b2        	l32i	a11, a1, 0x26c
420154fd:	9c21a2        	l32i	a10, a1, 0x270
42015500:	cdca      	add.n	a12, a13, a12
42015502:	fe08e5        	call8	42013590 <__ssprint_r>
42015505:	f73a16        	beqz	a10, 4201547c <_svfiprintf_r+0x1de0>
42015508:	001206        	j	42015554 <_svfiprintf_r+0x1eb8>
4201550b:	00          	.byte 00
4201550c:	040c      	movi.n	a4, 0
4201550e:	10c1e2        	addi	a14, a1, 16
42015511:	8e6142        	s32i	a4, a1, 0x238
42015514:	024d      	mov.n	a4, a2
42015516:	e4a122        	movi	a2, 0x1e4
42015519:	3e2a      	add.n	a3, a14, a2
4201551b:	986132        	s32i	a3, a1, 0x260
4201551e:	f880c6        	j	42013725 <_svfiprintf_r+0x89>
42015521:	00          	.byte 00
42015522:	00          	.byte 00
42015523:	24a2c2        	movi	a12, 0x224
42015526:	10c142        	addi	a4, a1, 16
42015529:	9b21b2        	l32i	a11, a1, 0x26c
4201552c:	9c21a2        	l32i	a10, a1, 0x270
4201552f:	c4ca      	add.n	a12, a4, a12
42015531:	fe05e5        	call8	42013590 <__ssprint_r>
42015534:	fd4a16        	beqz	a10, 4201550c <_svfiprintf_r+0x1e70>
42015537:	000646        	j	42015554 <_svfiprintf_r+0x1eb8>
4201553a:	00          	.byte 00
4201553b:	00          	.byte 00
4201553c:	8f2122        	l32i	a2, a1, 0x23c
4201553f:	011216        	beqz	a2, 42015554 <_svfiprintf_r+0x1eb8>
42015542:	24a2c2        	movi	a12, 0x224
42015545:	10c152        	addi	a5, a1, 16
42015548:	9b21b2        	l32i	a11, a1, 0x26c
4201554b:	9c21a2        	l32i	a10, a1, 0x270
4201554e:	80c5c0        	add	a12, a5, a12
42015551:	fe03e5        	call8	42013590 <__ssprint_r>
42015554:	9b2182        	l32i	a8, a1, 0x26c
42015557:	9e2192        	l32i	a9, a1, 0x278
4201555a:	061822        	l16ui	a2, a8, 12
4201555d:	f37c      	movi.n	a3, -1
4201555f:	042620        	extui	a2, a2, 6, 1
42015562:	939320        	movnez	a9, a3, a2
42015565:	9e6192        	s32i	a9, a1, 0x278
42015568:	000c46        	j	4201559d <_svfiprintf_r+0x1f01>
4201556b:	00          	.byte 00
4201556c:	912152        	l32i	a5, a1, 0x244
4201556f:	941b      	addi.n	a9, a4, 1
42015571:	02a457        	bge	a4, a5, 42015577 <_svfiprintf_r+0x1edb>
42015574:	f8d246        	j	420138c1 <_svfiprintf_r+0x225>
42015577:	f8d3c6        	j	420138ca <_svfiprintf_r+0x22e>
4201557a:	00          	.byte 00
4201557b:	00          	.byte 00
4201557c:	912152        	l32i	a5, a1, 0x244
4201557f:	941b      	addi.n	a9, a4, 1
42015581:	02a457        	bge	a4, a5, 42015587 <_svfiprintf_r+0x1eeb>
42015584:	f91506        	j	420139dc <_svfiprintf_r+0x340>
42015587:	f91686        	j	420139e5 <_svfiprintf_r+0x349>
4201558a:	00          	.byte 00
4201558b:	00          	.byte 00
4201558c:	992132        	l32i	a3, a1, 0x264
4201558f:	972152        	l32i	a5, a1, 0x25c
42015592:	140c      	movi.n	a4, 1
42015594:	020326        	beqi	a3, -1, 4201559a <_svfiprintf_r+0x1efe>
42015597:	fe8a46        	j	42014fc4 <_svfiprintf_r+0x1928>
4201559a:	fea786        	j	4201503c <_svfiprintf_r+0x19a0>
4201559d:	9e2122        	l32i	a2, a1, 0x278
420155a0:	f01d      	retw.n
	...

420155a4 <get_arg$constprop$0>:
420155a4:	008136        	entry	a1, 64
420155a7:	102182        	l32i	a8, a1, 64
420155aa:	2129      	s32i.n	a2, a1, 8
420155ac:	2198      	l32i.n	a9, a1, 8
420155ae:	0528      	l32i.n	a2, a5, 0
420155b0:	3159      	s32i.n	a5, a1, 12
420155b2:	0858      	l32i.n	a5, a8, 0
420155b4:	933550        	movnez	a3, a5, a5
420155b7:	0199      	s32i.n	a9, a1, 0
420155b9:	00ea46        	j	42015966 <get_arg$constprop$0+0x3c2>
420155bc:	00          	.byte 00
420155bd:	00          	.byte 00
420155be:	331b      	addi.n	a3, a3, 1
420155c0:	000352        	l8ui	a5, a3, 0
420155c3:	180c      	movi.n	a8, 1
420155c5:	838950        	moveqz	a8, a9, a5
420155c8:	748080        	extui	a8, a8, 0, 8
420155cb:	d88c      	beqz.n	a8, 420155dc <get_arg$constprop$0+0x38>
420155cd:	dbc5a2        	addi	a10, a5, -37
420155d0:	01a082        	movi	a8, 1
420155d3:	8389a0        	moveqz	a8, a9, a10
420155d6:	748080        	extui	a8, a8, 0, 8
420155d9:	fe1856        	bnez	a8, 420155be <get_arg$constprop$0+0x1a>
420155dc:	43c516        	beqz	a5, 42015a1c <get_arg$constprop$0+0x478>
420155df:	050c      	movi.n	a5, 0
420155e1:	a31b      	addi.n	a10, a3, 1
420155e3:	05ed      	mov.n	a14, a5
420155e5:	f97c      	movi.n	a9, -1
420155e7:	05dd      	mov.n	a13, a5
420155e9:	1159      	s32i.n	a5, a1, 4
420155eb:	000046        	j	420155f0 <get_arg$constprop$0+0x4c>
420155ee:	03ad      	mov.n	a10, a3
420155f0:	ad6bc1        	l32r	a12, 42000b9c <_stext+0xb7c>
420155f3:	000a82        	l8ui	a8, a10, 0
420155f6:	3a1b      	addi.n	a3, a10, 1
420155f8:	bc8a      	add.n	a11, a12, a8
420155fa:	000bc2        	l8ui	a12, a11, 0
420155fd:	11b8      	l32i.n	a11, a1, 4
420155ff:	b0fbb0        	addx8	a15, a11, a11
42015602:	ad67b1        	l32r	a11, 42000ba0 <_stext+0xb80>
42015605:	bbfa      	add.n	a11, a11, a15
42015607:	bbca      	add.n	a11, a11, a12
42015609:	000bb2        	l8ui	a11, a11, 0
4201560c:	11b9      	s32i.n	a11, a1, 4
4201560e:	ad65b1        	l32r	a11, 42000ba4 <_stext+0xb84>
42015611:	bbfa      	add.n	a11, a11, a15
42015613:	bbca      	add.n	a11, a11, a12
42015615:	000bb2        	l8ui	a11, a11, 0
42015618:	bb0b      	addi.n	a11, a11, -1
4201561a:	74b0b0        	extui	a11, a11, 0, 8
4201561d:	028bb6        	bltui	a11, 8, 42015623 <get_arg$constprop$0+0x7f>
42015620:	00ce06        	j	4201595c <get_arg$constprop$0+0x3b8>
42015623:	adb9c1        	l32r	a12, 42000d08 <_stext+0xce8>
42015626:	a0bbc0        	addx4	a11, a11, a12
42015629:	0bb8      	l32i.n	a11, a11, 0
4201562b:	000ba0        	jx	a11
4201562e:	00          	.byte 00
4201562f:	9a0c      	movi.n	a10, 9
42015631:	00c586        	j	4201594b <get_arg$constprop$0+0x3a7>
42015634:	6aa0b2        	movi	a11, 106
42015637:	3318b7        	beq	a8, a11, 4201566e <get_arg$constprop$0+0xca>
4201563a:	0a3b87        	bltu	a11, a8, 42015648 <get_arg$constprop$0+0xa4>
4201563d:	cb4c      	movi.n	a11, 76
4201563f:	2618b7        	beq	a8, a11, 42015669 <get_arg$constprop$0+0xc5>
42015642:	68a0b2        	movi	a11, 104
42015645:	0005c6        	j	42015660 <get_arg$constprop$0+0xbc>
42015648:	71a0b2        	movi	a11, 113
4201564b:	1f18b7        	beq	a8, a11, 4201566e <get_arg$constprop$0+0xca>
4201564e:	70a0b2        	movi	a11, 112
42015651:	1fbb87        	bgeu	a11, a8, 42015674 <get_arg$constprop$0+0xd0>
42015654:	74a0b2        	movi	a11, 116
42015657:	0298b7        	bne	a8, a11, 4201565d <get_arg$constprop$0+0xb9>
4201565a:	00bf86        	j	4201595c <get_arg$constprop$0+0x3b8>
4201565d:	7aa0b2        	movi	a11, 122
42015660:	0298b7        	bne	a8, a11, 42015666 <get_arg$constprop$0+0xc2>
42015663:	00bd46        	j	4201595c <get_arg$constprop$0+0x3b8>
42015666:	000286        	j	42015674 <get_arg$constprop$0+0xd0>
42015669:	880c      	movi.n	a8, 8
4201566b:	0006c6        	j	4201568a <get_arg$constprop$0+0xe6>
4201566e:	082c      	movi.n	a8, 32
42015670:	000586        	j	4201568a <get_arg$constprop$0+0xe6>
42015673:	00          	.byte 00
42015674:	010ab2        	l8ui	a11, a10, 1
42015677:	6ca082        	movi	a8, 108
4201567a:	0a9b87        	bne	a11, a8, 42015688 <get_arg$constprop$0+0xe4>
4201567d:	032c      	movi.n	a3, 32
4201567f:	20dd30        	or	a13, a13, a3
42015682:	3a2b      	addi.n	a3, a10, 2
42015684:	00b506        	j	4201595c <get_arg$constprop$0+0x3b8>
42015687:	00          	.byte 00
42015688:	081c      	movi.n	a8, 16
4201568a:	20dd80        	or	a13, a13, a8
4201568d:	00b2c6        	j	4201595c <get_arg$constprop$0+0x3b8>
42015690:	61a0a2        	movi	a10, 97
42015693:	442020        	extui	a2, a2, 0, 5
42015696:	0298a7        	bne	a8, a10, 4201569c <get_arg$constprop$0+0xf8>
42015699:	00f806        	j	42015a7d <get_arg$constprop$0+0x4d9>
4201569c:	3c3a87        	bltu	a10, a8, 420156dc <get_arg$constprop$0+0x138>
4201569f:	bfc882        	addi	a8, a8, -65
420156a2:	748080        	extui	a8, a8, 0, 8
420156a5:	7a1c      	movi.n	a10, 23
420156a7:	25ba87        	bgeu	a10, a8, 420156d0 <get_arg$constprop$0+0x12c>
420156aa:	0016c6        	j	42015709 <get_arg$constprop$0+0x165>
420156ad:	1c0c      	movi.n	a12, 1
420156af:	ad3fa1        	l32r	a10, 42000bac <_stext+0xb8c>
420156b2:	401800        	ssl	a8
420156b5:	a18c00        	sll	a8, a12
420156b8:	3488a7        	bany	a8, a10, 420156f0 <get_arg$constprop$0+0x14c>
420156bb:	5a2c      	movi.n	a10, 37
420156bd:	11aa60        	slli	a10, a10, 10
420156c0:	0208a7        	bnone	a8, a10, 420156c6 <get_arg$constprop$0+0x122>
420156c3:	00eac6        	j	42015a72 <get_arg$constprop$0+0x4ce>
420156c6:	ea0c      	movi.n	a10, 14
420156c8:	3d08a7        	bnone	a8, a10, 42015709 <get_arg$constprop$0+0x165>
420156cb:	00eb86        	j	42015a7d <get_arg$constprop$0+0x4d9>
420156ce:	00          	.byte 00
420156cf:	00          	.byte 00
420156d0:	ad8fa1        	l32r	a10, 42000d0c <_stext+0xcec>
420156d3:	a088a0        	addx4	a8, a8, a10
420156d6:	0888      	l32i.n	a8, a8, 0
420156d8:	0008a0        	jx	a8
420156db:	00          	.byte 00
420156dc:	63a0a2        	movi	a10, 99
420156df:	1d18a7        	beq	a8, a10, 42015700 <get_arg$constprop$0+0x15c>
420156e2:	9cc882        	addi	a8, a8, -100
420156e5:	748080        	extui	a8, a8, 0, 8
420156e8:	4a1c      	movi.n	a10, 20
420156ea:	bfba87        	bgeu	a10, a8, 420156ad <get_arg$constprop$0+0x109>
420156ed:	000606        	j	42015709 <get_arg$constprop$0+0x165>
420156f0:	026d47        	bbci	a13, 4, 420156f6 <get_arg$constprop$0+0x152>
420156f3:	00d346        	j	42015a44 <get_arg$constprop$0+0x4a0>
420156f6:	026d57        	bbci	a13, 5, 420156fc <get_arg$constprop$0+0x158>
420156f9:	00d4c6        	j	42015a50 <get_arg$constprop$0+0x4ac>
420156fc:	00d9c6        	j	42015a67 <get_arg$constprop$0+0x4c3>
420156ff:	00          	.byte 00
42015700:	026d47        	bbci	a13, 4, 42015706 <get_arg$constprop$0+0x162>
42015703:	00d546        	j	42015a5c <get_arg$constprop$0+0x4b8>
42015706:	00d746        	j	42015a67 <get_arg$constprop$0+0x4c3>
42015709:	070926        	beqi	a9, -1, 42015714 <get_arg$constprop$0+0x170>
4201570c:	a08970        	addx4	a8, a9, a7
4201570f:	0859      	s32i.n	a5, a8, 0
42015711:	0091c6        	j	4201595c <get_arg$constprop$0+0x3b8>
42015714:	850b      	addi.n	a8, a5, -1
42015716:	0268b6        	bltui	a8, 6, 4201571c <get_arg$constprop$0+0x178>
42015719:	002b06        	j	420157c9 <get_arg$constprop$0+0x225>
4201571c:	ad7da1        	l32r	a10, 42000d10 <_stext+0xcf0>
4201571f:	a088a0        	addx4	a8, a8, a10
42015722:	0888      	l32i.n	a8, a8, 0
42015724:	0008a0        	jx	a8
42015727:	2488      	l32i.n	a8, a4, 8
42015729:	891c      	movi.n	a9, 24
4201572b:	584b      	addi.n	a5, a8, 4
4201572d:	2459      	s32i.n	a5, a4, 8
4201572f:	a21b      	addi.n	a10, a2, 1
42015731:	b02260        	addx8	a2, a2, a6
42015734:	042957        	blt	a9, a5, 4201573c <get_arg$constprop$0+0x198>
42015737:	1458      	l32i.n	a5, a4, 4
42015739:	000206        	j	42015745 <get_arg$constprop$0+0x1a1>
4201573c:	012987        	blt	a9, a8, 42015741 <get_arg$constprop$0+0x19d>
4201573f:	452c      	movi.n	a5, 36
42015741:	2459      	s32i.n	a5, a4, 8
42015743:	0458      	l32i.n	a5, a4, 0
42015745:	2488      	l32i.n	a8, a4, 8
42015747:	f97c      	movi.n	a9, -1
42015749:	558a      	add.n	a5, a5, a8
4201574b:	fcc552        	addi	a5, a5, -4
4201574e:	0558      	l32i.n	a5, a5, 0
42015750:	0259      	s32i.n	a5, a2, 0
42015752:	0a2d      	mov.n	a2, a10
42015754:	150c      	movi.n	a5, 1
42015756:	008086        	j	4201595c <get_arg$constprop$0+0x3b8>
42015759:	2458      	l32i.n	a5, a4, 8
4201575b:	887c      	movi.n	a8, -8
4201575d:	557b      	addi.n	a5, a5, 7
4201575f:	105580        	and	a5, a5, a8
42015762:	858b      	addi.n	a8, a5, 8
42015764:	2489      	s32i.n	a8, a4, 8
42015766:	891c      	movi.n	a9, 24
42015768:	a21b      	addi.n	a10, a2, 1
4201576a:	b02260        	addx8	a2, a2, a6
4201576d:	042987        	blt	a9, a8, 42015775 <get_arg$constprop$0+0x1d1>
42015770:	1458      	l32i.n	a5, a4, 4
42015772:	000206        	j	4201577e <get_arg$constprop$0+0x1da>
42015775:	012957        	blt	a9, a5, 4201577a <get_arg$constprop$0+0x1d6>
42015778:	882c      	movi.n	a8, 40
4201577a:	0458      	l32i.n	a5, a4, 0
4201577c:	2489      	s32i.n	a8, a4, 8
4201577e:	2488      	l32i.n	a8, a4, 8
42015780:	558a      	add.n	a5, a5, a8
42015782:	f8c552        	addi	a5, a5, -8
42015785:	1598      	l32i.n	a9, a5, 4
42015787:	0588      	l32i.n	a8, a5, 0
42015789:	1299      	s32i.n	a9, a2, 4
4201578b:	0289      	s32i.n	a8, a2, 0
4201578d:	f97c      	movi.n	a9, -1
4201578f:	0a2d      	mov.n	a2, a10
42015791:	250c      	movi.n	a5, 2
42015793:	007146        	j	4201595c <get_arg$constprop$0+0x3b8>
42015796:	2488      	l32i.n	a8, a4, 8
42015798:	891c      	movi.n	a9, 24
4201579a:	584b      	addi.n	a5, a8, 4
4201579c:	2459      	s32i.n	a5, a4, 8
4201579e:	a21b      	addi.n	a10, a2, 1
420157a0:	b02260        	addx8	a2, a2, a6
420157a3:	052957        	blt	a9, a5, 420157ac <get_arg$constprop$0+0x208>
420157a6:	1458      	l32i.n	a5, a4, 4
420157a8:	000246        	j	420157b5 <get_arg$constprop$0+0x211>
420157ab:	00          	.byte 00
420157ac:	012987        	blt	a9, a8, 420157b1 <get_arg$constprop$0+0x20d>
420157af:	452c      	movi.n	a5, 36
420157b1:	2459      	s32i.n	a5, a4, 8
420157b3:	0458      	l32i.n	a5, a4, 0
420157b5:	2488      	l32i.n	a8, a4, 8
420157b7:	f97c      	movi.n	a9, -1
420157b9:	558a      	add.n	a5, a5, a8
420157bb:	fcc552        	addi	a5, a5, -4
420157be:	0558      	l32i.n	a5, a5, 0
420157c0:	0259      	s32i.n	a5, a2, 0
420157c2:	0a2d      	mov.n	a2, a10
420157c4:	650c      	movi.n	a5, 6
420157c6:	006486        	j	4201595c <get_arg$constprop$0+0x3b8>
420157c9:	2488      	l32i.n	a8, a4, 8
420157cb:	891c      	movi.n	a9, 24
420157cd:	584b      	addi.n	a5, a8, 4
420157cf:	2459      	s32i.n	a5, a4, 8
420157d1:	a21b      	addi.n	a10, a2, 1
420157d3:	b02260        	addx8	a2, a2, a6
420157d6:	062957        	blt	a9, a5, 420157e0 <get_arg$constprop$0+0x23c>
420157d9:	1458      	l32i.n	a5, a4, 4
420157db:	000286        	j	420157e9 <get_arg$constprop$0+0x245>
420157de:	00          	.byte 00
420157df:	00          	.byte 00
420157e0:	012987        	blt	a9, a8, 420157e5 <get_arg$constprop$0+0x241>
420157e3:	452c      	movi.n	a5, 36
420157e5:	2459      	s32i.n	a5, a4, 8
420157e7:	0458      	l32i.n	a5, a4, 0
420157e9:	2488      	l32i.n	a8, a4, 8
420157eb:	f97c      	movi.n	a9, -1
420157ed:	558a      	add.n	a5, a5, a8
420157ef:	fcc552        	addi	a5, a5, -4
420157f2:	0558      	l32i.n	a5, a5, 0
420157f4:	0259      	s32i.n	a5, a2, 0
420157f6:	0a2d      	mov.n	a2, a10
420157f8:	050c      	movi.n	a5, 0
420157fa:	005786        	j	4201595c <get_arg$constprop$0+0x3b8>
420157fd:	2488      	l32i.n	a8, a4, 8
420157ff:	891c      	movi.n	a9, 24
42015801:	584b      	addi.n	a5, a8, 4
42015803:	2459      	s32i.n	a5, a4, 8
42015805:	a21b      	addi.n	a10, a2, 1
42015807:	b02260        	addx8	a2, a2, a6
4201580a:	062957        	blt	a9, a5, 42015814 <get_arg$constprop$0+0x270>
4201580d:	1458      	l32i.n	a5, a4, 4
4201580f:	000286        	j	4201581d <get_arg$constprop$0+0x279>
42015812:	00          	.byte 00
42015813:	00          	.byte 00
42015814:	012987        	blt	a9, a8, 42015819 <get_arg$constprop$0+0x275>
42015817:	452c      	movi.n	a5, 36
42015819:	2459      	s32i.n	a5, a4, 8
4201581b:	0458      	l32i.n	a5, a4, 0
4201581d:	2488      	l32i.n	a8, a4, 8
4201581f:	f97c      	movi.n	a9, -1
42015821:	558a      	add.n	a5, a5, a8
42015823:	fcc552        	addi	a5, a5, -4
42015826:	0558      	l32i.n	a5, a5, 0
42015828:	0259      	s32i.n	a5, a2, 0
4201582a:	0a2d      	mov.n	a2, a10
4201582c:	350c      	movi.n	a5, 3
4201582e:	004a86        	j	4201595c <get_arg$constprop$0+0x3b8>
42015831:	2458      	l32i.n	a5, a4, 8
42015833:	887c      	movi.n	a8, -8
42015835:	557b      	addi.n	a5, a5, 7
42015837:	105580        	and	a5, a5, a8
4201583a:	858b      	addi.n	a8, a5, 8
4201583c:	2489      	s32i.n	a8, a4, 8
4201583e:	891c      	movi.n	a9, 24
42015840:	a21b      	addi.n	a10, a2, 1
42015842:	b02260        	addx8	a2, a2, a6
42015845:	042987        	blt	a9, a8, 4201584d <get_arg$constprop$0+0x2a9>
42015848:	1458      	l32i.n	a5, a4, 4
4201584a:	000206        	j	42015856 <get_arg$constprop$0+0x2b2>
4201584d:	012957        	blt	a9, a5, 42015852 <get_arg$constprop$0+0x2ae>
42015850:	882c      	movi.n	a8, 40
42015852:	0458      	l32i.n	a5, a4, 0
42015854:	2489      	s32i.n	a8, a4, 8
42015856:	2488      	l32i.n	a8, a4, 8
42015858:	558a      	add.n	a5, a5, a8
4201585a:	f8c552        	addi	a5, a5, -8
4201585d:	1598      	l32i.n	a9, a5, 4
4201585f:	0588      	l32i.n	a8, a5, 0
42015861:	1299      	s32i.n	a9, a2, 4
42015863:	0289      	s32i.n	a8, a2, 0
42015865:	f97c      	movi.n	a9, -1
42015867:	0a2d      	mov.n	a2, a10
42015869:	450c      	movi.n	a5, 4
4201586b:	003b46        	j	4201595c <get_arg$constprop$0+0x3b8>
4201586e:	2488      	l32i.n	a8, a4, 8
42015870:	8a7c      	movi.n	a10, -8
42015872:	887b      	addi.n	a8, a8, 7
42015874:	1088a0        	and	a8, a8, a10
42015877:	a88b      	addi.n	a10, a8, 8
42015879:	24a9      	s32i.n	a10, a4, 8
4201587b:	8b1c      	movi.n	a11, 24
4201587d:	b0c260        	addx8	a12, a2, a6
42015880:	052ba7        	blt	a11, a10, 42015889 <get_arg$constprop$0+0x2e5>
42015883:	1488      	l32i.n	a8, a4, 4
42015885:	000246        	j	42015892 <get_arg$constprop$0+0x2ee>
42015888:	00          	.byte 00
42015889:	012b87        	blt	a11, a8, 4201588e <get_arg$constprop$0+0x2ea>
4201588c:	8a2c      	movi.n	a10, 40
4201588e:	0488      	l32i.n	a8, a4, 0
42015890:	24a9      	s32i.n	a10, a4, 8
42015892:	24a8      	l32i.n	a10, a4, 8
42015894:	221b      	addi.n	a2, a2, 1
42015896:	88aa      	add.n	a8, a8, a10
42015898:	f8c882        	addi	a8, a8, -8
4201589b:	08a8      	l32i.n	a10, a8, 0
4201589d:	18b8      	l32i.n	a11, a8, 4
4201589f:	0ca9      	s32i.n	a10, a12, 0
420158a1:	1cb9      	s32i.n	a11, a12, 4
420158a3:	002d46        	j	4201595c <get_arg$constprop$0+0x3b8>
420158a6:	0788      	l32i.n	a8, a7, 0
420158a8:	140866        	bnei	a8, -1, 420158c0 <get_arg$constprop$0+0x31c>
420158ab:	80a0c2        	movi	a12, 128
420158ae:	0b0c      	movi.n	a11, 0
420158b0:	07ad      	mov.n	a10, a7
420158b2:	51d9      	s32i.n	a13, a1, 20
420158b4:	61e9      	s32i.n	a14, a1, 24
420158b6:	aa3881        	l32r	a8, 42000198 <_stext+0x178>
420158b9:	0008e0        	callx8	a8
420158bc:	61e8      	l32i.n	a14, a1, 24
420158be:	51d8      	l32i.n	a13, a1, 20
420158c0:	0188      	l32i.n	a8, a1, 0
420158c2:	9e0b      	addi.n	a9, a14, -1
420158c4:	538890        	max	a8, a8, a9
420158c7:	000ac6        	j	420158f6 <get_arg$constprop$0+0x352>
420158ca:	0788      	l32i.n	a8, a7, 0
420158cc:	180866        	bnei	a8, -1, 420158e8 <get_arg$constprop$0+0x344>
420158cf:	80a0c2        	movi	a12, 128
420158d2:	0b0c      	movi.n	a11, 0
420158d4:	07ad      	mov.n	a10, a7
420158d6:	4199      	s32i.n	a9, a1, 16
420158d8:	51d9      	s32i.n	a13, a1, 20
420158da:	61e9      	s32i.n	a14, a1, 24
420158dc:	aa2f81        	l32r	a8, 42000198 <_stext+0x178>
420158df:	0008e0        	callx8	a8
420158e2:	61e8      	l32i.n	a14, a1, 24
420158e4:	51d8      	l32i.n	a13, a1, 20
420158e6:	4198      	l32i.n	a9, a1, 16
420158e8:	ee0b      	addi.n	a14, a14, -1
420158ea:	a08e70        	addx4	a8, a14, a7
420158ed:	0a0c      	movi.n	a10, 0
420158ef:	08a9      	s32i.n	a10, a8, 0
420158f1:	0188      	l32i.n	a8, a1, 0
420158f3:	5388e0        	max	a8, a8, a14
420158f6:	0189      	s32i.n	a8, a1, 0
420158f8:	001806        	j	4201595c <get_arg$constprop$0+0x3b8>
420158fb:	0a3d      	mov.n	a3, a10
420158fd:	24a8      	l32i.n	a10, a4, 8
420158ff:	8b1c      	movi.n	a11, 24
42015901:	8a4b      	addi.n	a8, a10, 4
42015903:	2489      	s32i.n	a8, a4, 8
42015905:	c21b      	addi.n	a12, a2, 1
42015907:	b02260        	addx8	a2, a2, a6
4201590a:	062b87        	blt	a11, a8, 42015914 <get_arg$constprop$0+0x370>
4201590d:	1488      	l32i.n	a8, a4, 4
4201590f:	000286        	j	4201591d <get_arg$constprop$0+0x379>
42015912:	00          	.byte 00
42015913:	00          	.byte 00
42015914:	012ba7        	blt	a11, a10, 42015919 <get_arg$constprop$0+0x375>
42015917:	482c      	movi.n	a8, 36
42015919:	2489      	s32i.n	a8, a4, 8
4201591b:	0488      	l32i.n	a8, a4, 0
4201591d:	24a8      	l32i.n	a10, a4, 8
4201591f:	88aa      	add.n	a8, a8, a10
42015921:	fcc882        	addi	a8, a8, -4
42015924:	0888      	l32i.n	a8, a8, 0
42015926:	0289      	s32i.n	a8, a2, 0
42015928:	0c2d      	mov.n	a2, a12
4201592a:	000b86        	j	4201595c <get_arg$constprop$0+0x3b8>
4201592d:	d0c8e2        	addi	a14, a8, -48
42015930:	9a0c      	movi.n	a10, 9
42015932:	0001c6        	j	4201593d <get_arg$constprop$0+0x399>
42015935:	a0eee0        	addx4	a14, a14, a14
42015938:	90ee80        	addx2	a14, a14, a8
4201593b:	331b      	addi.n	a3, a3, 1
4201593d:	000382        	l8ui	a8, a3, 0
42015940:	889c      	beqz.n	a8, 4201595c <get_arg$constprop$0+0x3b8>
42015942:	d0c882        	addi	a8, a8, -48
42015945:	ecba87        	bgeu	a10, a8, 42015935 <get_arg$constprop$0+0x391>
42015948:	000406        	j	4201595c <get_arg$constprop$0+0x3b8>
4201594b:	000382        	l8ui	a8, a3, 0
4201594e:	d0c882        	addi	a8, a8, -48
42015951:	748080        	extui	a8, a8, 0, 8
42015954:	043a87        	bltu	a10, a8, 4201595c <get_arg$constprop$0+0x3b8>
42015957:	331b      	addi.n	a3, a3, 1
42015959:	fffb86        	j	4201594b <get_arg$constprop$0+0x3a7>
4201595c:	11a8      	l32i.n	a10, a1, 4
4201595e:	b80c      	movi.n	a8, 11
42015960:	021a87        	beq	a10, a8, 42015966 <get_arg$constprop$0+0x3c2>
42015963:	ff21c6        	j	420155ee <get_arg$constprop$0+0x4a>
42015966:	2188      	l32i.n	a8, a1, 8
42015968:	000352        	l8ui	a5, a3, 0
4201596b:	072827        	blt	a8, a2, 42015976 <get_arg$constprop$0+0x3d2>
4201596e:	090c      	movi.n	a9, 0
42015970:	021597        	beq	a5, a9, 42015976 <get_arg$constprop$0+0x3d2>
42015973:	ff1246        	j	420155c0 <get_arg$constprop$0+0x1c>
42015976:	0188      	l32i.n	a8, a1, 0
42015978:	2198      	l32i.n	a9, a1, 8
4201597a:	839850        	moveqz	a9, a8, a5
4201597d:	0199      	s32i.n	a9, a1, 0
4201597f:	002646        	j	42015a1c <get_arg$constprop$0+0x478>
42015982:	00          	.byte 00
42015983:	00          	.byte 00
42015984:	a05c70        	addx4	a5, a12, a7
42015987:	0588      	l32i.n	a8, a5, 0
42015989:	cc1b      	addi.n	a12, a12, 1
4201598b:	880b      	addi.n	a8, a8, -1
4201598d:	2458      	l32i.n	a5, a4, 8
4201598f:	6568f6        	bgeui	a8, 6, 420159f8 <get_arg$constprop$0+0x454>
42015992:	ace091        	l32r	a9, 42000d14 <_stext+0xcf4>
42015995:	a08890        	addx4	a8, a8, a9
42015998:	0888      	l32i.n	a8, a8, 0
4201599a:	0008a0        	jx	a8
4201599d:	557b      	addi.n	a5, a5, 7
4201599f:	1055f0        	and	a5, a5, a15
420159a2:	858b      	addi.n	a8, a5, 8
420159a4:	2489      	s32i.n	a8, a4, 8
420159a6:	062a87        	blt	a10, a8, 420159b0 <get_arg$constprop$0+0x40c>
420159a9:	1458      	l32i.n	a5, a4, 4
420159ab:	000286        	j	420159b9 <get_arg$constprop$0+0x415>
420159ae:	00          	.byte 00
420159af:	00          	.byte 00
420159b0:	012a57        	blt	a10, a5, 420159b5 <get_arg$constprop$0+0x411>
420159b3:	0e8d      	mov.n	a8, a14
420159b5:	0458      	l32i.n	a5, a4, 0
420159b7:	2489      	s32i.n	a8, a4, 8
420159b9:	2488      	l32i.n	a8, a4, 8
420159bb:	558a      	add.n	a5, a5, a8
420159bd:	f8c552        	addi	a5, a5, -8
420159c0:	0588      	l32i.n	a8, a5, 0
420159c2:	1598      	l32i.n	a9, a5, 4
420159c4:	0b89      	s32i.n	a8, a11, 0
420159c6:	1b99      	s32i.n	a9, a11, 4
420159c8:	001806        	j	42015a2c <get_arg$constprop$0+0x488>
420159cb:	557b      	addi.n	a5, a5, 7
420159cd:	1055f0        	and	a5, a5, a15
420159d0:	858b      	addi.n	a8, a5, 8
420159d2:	2489      	s32i.n	a8, a4, 8
420159d4:	042a87        	blt	a10, a8, 420159dc <get_arg$constprop$0+0x438>
420159d7:	1458      	l32i.n	a5, a4, 4
420159d9:	000206        	j	420159e5 <get_arg$constprop$0+0x441>
420159dc:	012a57        	blt	a10, a5, 420159e1 <get_arg$constprop$0+0x43d>
420159df:	0e8d      	mov.n	a8, a14
420159e1:	0458      	l32i.n	a5, a4, 0
420159e3:	2489      	s32i.n	a8, a4, 8
420159e5:	2488      	l32i.n	a8, a4, 8
420159e7:	558a      	add.n	a5, a5, a8
420159e9:	f8c552        	addi	a5, a5, -8
420159ec:	0588      	l32i.n	a8, a5, 0
420159ee:	1598      	l32i.n	a9, a5, 4
420159f0:	0b89      	s32i.n	a8, a11, 0
420159f2:	1b99      	s32i.n	a9, a11, 4
420159f4:	000d06        	j	42015a2c <get_arg$constprop$0+0x488>
420159f7:	00          	.byte 00
420159f8:	854b      	addi.n	a8, a5, 4
420159fa:	2489      	s32i.n	a8, a4, 8
420159fc:	042a87        	blt	a10, a8, 42015a04 <get_arg$constprop$0+0x460>
420159ff:	1458      	l32i.n	a5, a4, 4
42015a01:	000206        	j	42015a0d <get_arg$constprop$0+0x469>
42015a04:	012a57        	blt	a10, a5, 42015a09 <get_arg$constprop$0+0x465>
42015a07:	0d8d      	mov.n	a8, a13
42015a09:	0458      	l32i.n	a5, a4, 0
42015a0b:	2489      	s32i.n	a8, a4, 8
42015a0d:	2488      	l32i.n	a8, a4, 8
42015a0f:	558a      	add.n	a5, a5, a8
42015a11:	fcc552        	addi	a5, a5, -4
42015a14:	0558      	l32i.n	a5, a5, 0
42015a16:	0b59      	s32i.n	a5, a11, 0
42015a18:	000406        	j	42015a2c <get_arg$constprop$0+0x488>
42015a1b:	00          	.byte 00
42015a1c:	b0b260        	addx8	a11, a2, a6
42015a1f:	02cd      	mov.n	a12, a2
42015a21:	8a1c      	movi.n	a10, 24
42015a23:	4d2c      	movi.n	a13, 36
42015a25:	8f7c      	movi.n	a15, -8
42015a27:	8e2c      	movi.n	a14, 40
42015a29:	000046        	j	42015a2e <get_arg$constprop$0+0x48a>
42015a2c:	bb8b      	addi.n	a11, a11, 8
42015a2e:	0158      	l32i.n	a5, a1, 0
42015a30:	0225c7        	blt	a5, a12, 42015a36 <get_arg$constprop$0+0x492>
42015a33:	ffd346        	j	42015984 <get_arg$constprop$0+0x3e0>
42015a36:	551b      	addi.n	a5, a5, 1
42015a38:	040c      	movi.n	a4, 0
42015a3a:	4a2527        	blt	a5, a2, 42015a88 <get_arg$constprop$0+0x4e4>
42015a3d:	c04520        	sub	a4, a5, a2
42015a40:	001106        	j	42015a88 <get_arg$constprop$0+0x4e4>
42015a43:	00          	.byte 00
42015a44:	150c      	movi.n	a5, 1
42015a46:	020926        	beqi	a9, -1, 42015a4c <get_arg$constprop$0+0x4a8>
42015a49:	ff2fc6        	j	4201570c <get_arg$constprop$0+0x168>
42015a4c:	ff35c6        	j	42015727 <get_arg$constprop$0+0x183>
42015a4f:	00          	.byte 00
42015a50:	250c      	movi.n	a5, 2
42015a52:	020926        	beqi	a9, -1, 42015a58 <get_arg$constprop$0+0x4b4>
42015a55:	ff2cc6        	j	4201570c <get_arg$constprop$0+0x168>
42015a58:	ff3f46        	j	42015759 <get_arg$constprop$0+0x1b5>
42015a5b:	00          	.byte 00
42015a5c:	650c      	movi.n	a5, 6
42015a5e:	020926        	beqi	a9, -1, 42015a64 <get_arg$constprop$0+0x4c0>
42015a61:	ff29c6        	j	4201570c <get_arg$constprop$0+0x168>
42015a64:	ff4b86        	j	42015796 <get_arg$constprop$0+0x1f2>
42015a67:	050c      	movi.n	a5, 0
42015a69:	020926        	beqi	a9, -1, 42015a6f <get_arg$constprop$0+0x4cb>
42015a6c:	ff2706        	j	4201570c <get_arg$constprop$0+0x168>
42015a6f:	ff5586        	j	420157c9 <get_arg$constprop$0+0x225>
42015a72:	350c      	movi.n	a5, 3
42015a74:	020926        	beqi	a9, -1, 42015a7a <get_arg$constprop$0+0x4d6>
42015a77:	ff2446        	j	4201570c <get_arg$constprop$0+0x168>
42015a7a:	ff5fc6        	j	420157fd <get_arg$constprop$0+0x259>
42015a7d:	450c      	movi.n	a5, 4
42015a7f:	020926        	beqi	a9, -1, 42015a85 <get_arg$constprop$0+0x4e1>
42015a82:	ff2186        	j	4201570c <get_arg$constprop$0+0x168>
42015a85:	ff6a06        	j	42015831 <get_arg$constprop$0+0x28d>
42015a88:	3188      	l32i.n	a8, a1, 12
42015a8a:	424a      	add.n	a4, a2, a4
42015a8c:	0849      	s32i.n	a4, a8, 0
42015a8e:	102192        	l32i	a9, a1, 64
42015a91:	2188      	l32i.n	a8, a1, 8
42015a93:	0939      	s32i.n	a3, a9, 0
42015a95:	b02860        	addx8	a2, a8, a6
42015a98:	f01d      	retw.n
	...

42015a9c <__sprint_r>:
42015a9c:	004136        	entry	a1, 32
42015a9f:	2498      	l32i.n	a9, a4, 8
42015aa1:	02ad      	mov.n	a10, a2
42015aa3:	020c      	movi.n	a2, 0
42015aa5:	03bd      	mov.n	a11, a3
42015aa7:	0d1927        	beq	a9, a2, 42015ab8 <__sprint_r+0x1c>
42015aaa:	04cd      	mov.n	a12, a4
42015aac:	201110        	or	a1, a1, a1
42015aaf:	f44f25        	call8	42009fa0 <__sfvwrite_r>
42015ab2:	090c      	movi.n	a9, 0
42015ab4:	0a2d      	mov.n	a2, a10
42015ab6:	2499      	s32i.n	a9, a4, 8
42015ab8:	090c      	movi.n	a9, 0
42015aba:	1499      	s32i.n	a9, a4, 4
42015abc:	f01d      	retw.n
	...

42015ac0 <_vfiprintf_r>:
42015ac0:	058136        	entry	a1, 0x2c0
42015ac3:	9c6122        	s32i	a2, a1, 0x270
42015ac6:	9c2182        	l32i	a8, a1, 0x270
42015ac9:	996132        	s32i	a3, a1, 0x264
42015acc:	9b6142        	s32i	a4, a1, 0x26c
42015acf:	946152        	s32i	a5, a1, 0x250
42015ad2:	956162        	s32i	a6, a1, 0x254
42015ad5:	966172        	s32i	a7, a1, 0x258
42015ad8:	c88c      	beqz.n	a8, 42015ae8 <_vfiprintf_r+0x28>
42015ada:	6828      	l32i.n	a2, a8, 24
42015adc:	008256        	bnez	a2, 42015ae8 <_vfiprintf_r+0x28>
42015adf:	20a880        	or	a10, a8, a8
42015ae2:	201110        	or	a1, a1, a1
42015ae5:	f3ece5        	call8	420099b4 <__sinit>
42015ae8:	ac2221        	l32r	a2, 42000b70 <_stext+0xb50>
42015aeb:	992192        	l32i	a9, a1, 0x264
42015aee:	079927        	bne	a9, a2, 42015af9 <_vfiprintf_r+0x39>
42015af1:	9c2122        	l32i	a2, a1, 0x270
42015af4:	1228      	l32i.n	a2, a2, 4
42015af6:	000846        	j	42015b1b <_vfiprintf_r+0x5b>
42015af9:	ac1e21        	l32r	a2, 42000b74 <_stext+0xb54>
42015afc:	992132        	l32i	a3, a1, 0x264
42015aff:	0a9327        	bne	a3, a2, 42015b0d <_vfiprintf_r+0x4d>
42015b02:	9c2182        	l32i	a8, a1, 0x270
42015b05:	2888      	l32i.n	a8, a8, 8
42015b07:	996182        	s32i	a8, a1, 0x264
42015b0a:	000406        	j	42015b1e <_vfiprintf_r+0x5e>
42015b0d:	ac1a21        	l32r	a2, 42000b78 <_stext+0xb58>
42015b10:	992192        	l32i	a9, a1, 0x264
42015b13:	079927        	bne	a9, a2, 42015b1e <_vfiprintf_r+0x5e>
42015b16:	9c2122        	l32i	a2, a1, 0x270
42015b19:	3228      	l32i.n	a2, a2, 12
42015b1b:	996122        	s32i	a2, a1, 0x264
42015b1e:	30a2b2        	movi	a11, 0x230
42015b21:	10c132        	addi	a3, a1, 16
42015b24:	80b3b0        	add	a11, a3, a11
42015b27:	01a0a2        	movi	a10, 1
42015b2a:	201110        	or	a1, a1, a1
42015b2d:	023e65        	call8	42017f14 <pthread_setcancelstate>
42015b30:	992182        	l32i	a8, a1, 0x264
42015b33:	192822        	l32i	a2, a8, 100
42015b36:	0ee207        	bbsi	a2, 0, 42015b48 <_vfiprintf_r+0x88>
42015b39:	061822        	l16ui	a2, a8, 12
42015b3c:	08e297        	bbsi	a2, 9, 42015b48 <_vfiprintf_r+0x88>
42015b3f:	1628a2        	l32i	a10, a8, 88
42015b42:	ac0281        	l32r	a8, 42000b4c <_stext+0xb2c>
42015b45:	0008e0        	callx8	a8
42015b48:	992192        	l32i	a9, a1, 0x264
42015b4b:	061922        	l16ui	a2, a9, 12
42015b4e:	046237        	bbci	a2, 3, 42015b56 <_vfiprintf_r+0x96>
42015b51:	4928      	l32i.n	a2, a9, 16
42015b53:	042256        	bnez	a2, 42015b99 <_vfiprintf_r+0xd9>
42015b56:	9921b2        	l32i	a11, a1, 0x264
42015b59:	9c21a2        	l32i	a10, a1, 0x270
42015b5c:	201110        	or	a1, a1, a1
42015b5f:	fb8025        	call8	42011360 <__swsetup_r>
42015b62:	3abc      	beqz.n	a10, 42015b99 <_vfiprintf_r+0xd9>
42015b64:	992132        	l32i	a3, a1, 0x264
42015b67:	192322        	l32i	a2, a3, 100
42015b6a:	0ee207        	bbsi	a2, 0, 42015b7c <_vfiprintf_r+0xbc>
42015b6d:	061322        	l16ui	a2, a3, 12
42015b70:	08e297        	bbsi	a2, 9, 42015b7c <_vfiprintf_r+0xbc>
42015b73:	1623a2        	l32i	a10, a3, 88
42015b76:	abf681        	l32r	a8, 42000b50 <_stext+0xb30>
42015b79:	0008e0        	callx8	a8
42015b7c:	9021a2        	l32i	a10, a1, 0x240
42015b7f:	30a2b2        	movi	a11, 0x230
42015b82:	10c142        	addi	a4, a1, 16
42015b85:	b4ba      	add.n	a11, a4, a11
42015b87:	ffaf52        	movi	a5, -1
42015b8a:	201110        	or	a1, a1, a1
42015b8d:	023865        	call8	42017f14 <pthread_setcancelstate>
42015b90:	9e6152        	s32i	a5, a1, 0x278
42015b93:	07ce86        	j	42017ad1 <_vfiprintf_r+0x2011>
42015b96:	00          	.byte 00
42015b97:	00          	.byte 00
42015b98:	00          	.byte 00
42015b99:	992182        	l32i	a8, a1, 0x264
42015b9c:	1aa022        	movi	a2, 26
42015b9f:	061832        	l16ui	a3, a8, 12
42015ba2:	102320        	and	a2, a3, a2
42015ba5:	479266        	bnei	a2, 10, 42015bf0 <_vfiprintf_r+0x130>
42015ba8:	079822        	l16si	a2, a8, 14
42015bab:	041296        	bltz	a2, 42015bf0 <_vfiprintf_r+0x130>
42015bae:	192822        	l32i	a2, a8, 100
42015bb1:	0be207        	bbsi	a2, 0, 42015bc0 <_vfiprintf_r+0x100>
42015bb4:	08e397        	bbsi	a3, 9, 42015bc0 <_vfiprintf_r+0x100>
42015bb7:	1628a2        	l32i	a10, a8, 88
42015bba:	abe581        	l32r	a8, 42000b50 <_stext+0xb30>
42015bbd:	0008e0        	callx8	a8
42015bc0:	10c192        	addi	a9, a1, 16
42015bc3:	9021a2        	l32i	a10, a1, 0x240
42015bc6:	30a2b2        	movi	a11, 0x230
42015bc9:	b9ba      	add.n	a11, a9, a11
42015bcb:	201110        	or	a1, a1, a1
42015bce:	023465        	call8	42017f14 <pthread_setcancelstate>
42015bd1:	9421d2        	l32i	a13, a1, 0x250
42015bd4:	9521e2        	l32i	a14, a1, 0x254
42015bd7:	9621f2        	l32i	a15, a1, 0x258
42015bda:	9b21c2        	l32i	a12, a1, 0x26c
42015bdd:	9921b2        	l32i	a11, a1, 0x264
42015be0:	9c21a2        	l32i	a10, a1, 0x270
42015be3:	201110        	or	a1, a1, a1
42015be6:	01f165        	call8	42017afc <__sbprintf>
42015be9:	9e61a2        	s32i	a10, a1, 0x278
42015bec:	07b846        	j	42017ad1 <_vfiprintf_r+0x2011>
42015bef:	00          	.byte 00
42015bf0:	020c      	movi.n	a2, 0
42015bf2:	f47c      	movi.n	a4, -1
42015bf4:	8f6122        	s32i	a2, a1, 0x23c
42015bf7:	8e6122        	s32i	a2, a1, 0x238
42015bfa:	916122        	s32i	a2, a1, 0x244
42015bfd:	446142        	s32i	a4, a1, 0x110
42015c00:	926122        	s32i	a2, a1, 0x248
42015c03:	9f6122        	s32i	a2, a1, 0x27c
42015c06:	a16122        	s32i	a2, a1, 0x284
42015c09:	a26122        	s32i	a2, a1, 0x288
42015c0c:	a36122        	s32i	a2, a1, 0x28c
42015c0f:	9e6122        	s32i	a2, a1, 0x278
42015c12:	024d      	mov.n	a4, a2
42015c14:	90a122        	movi	a2, 0x190
42015c17:	10c1c2        	addi	a12, a1, 16
42015c1a:	e4a132        	movi	a3, 0x1e4
42015c1d:	221a      	add.n	a2, a2, a1
42015c1f:	3c3a      	add.n	a3, a12, a3
42015c21:	64c222        	addi	a2, a2, 100
42015c24:	8d6132        	s32i	a3, a1, 0x234
42015c27:	986132        	s32i	a3, a1, 0x260
42015c2a:	a46122        	s32i	a2, a1, 0x290
42015c2d:	9b2122        	l32i	a2, a1, 0x26c
42015c30:	000086        	j	42015c36 <_vfiprintf_r+0x176>
42015c33:	00          	.byte 00
42015c34:	221b      	addi.n	a2, a2, 1
42015c36:	000232        	l8ui	a3, a2, 0
42015c39:	438c      	beqz.n	a3, 42015c41 <_vfiprintf_r+0x181>
42015c3b:	dbc332        	addi	a3, a3, -37
42015c3e:	ff2356        	bnez	a3, 42015c34 <_vfiprintf_r+0x174>
42015c41:	9b2132        	l32i	a3, a1, 0x26c
42015c44:	c05230        	sub	a5, a2, a3
42015c47:	551237        	beq	a2, a3, 42015ca0 <_vfiprintf_r+0x1e0>
42015c4a:	982162        	l32i	a6, a1, 0x260
42015c4d:	10c182        	addi	a8, a1, 16
42015c50:	0639      	s32i.n	a3, a6, 0
42015c52:	8f2132        	l32i	a3, a1, 0x23c
42015c55:	1659      	s32i.n	a5, a6, 4
42015c57:	335a      	add.n	a3, a3, a5
42015c59:	8f6132        	s32i	a3, a1, 0x23c
42015c5c:	8e2132        	l32i	a3, a1, 0x238
42015c5f:	02d862        	addmi	a6, a8, 0x200
42015c62:	331b      	addi.n	a3, a3, 1
42015c64:	8e6132        	s32i	a3, a1, 0x238
42015c67:	0a83e6        	bgei	a3, 8, 42015c75 <_vfiprintf_r+0x1b5>
42015c6a:	982192        	l32i	a9, a1, 0x260
42015c6d:	998b      	addi.n	a9, a9, 8
42015c6f:	986192        	s32i	a9, a1, 0x260
42015c72:	000846        	j	42015c97 <_vfiprintf_r+0x1d7>
42015c75:	10c1a2        	addi	a10, a1, 16
42015c78:	24a2c2        	movi	a12, 0x224
42015c7b:	caca      	add.n	a12, a10, a12
42015c7d:	9921b2        	l32i	a11, a1, 0x264
42015c80:	9c21a2        	l32i	a10, a1, 0x270
42015c83:	ffe1a5        	call8	42015a9c <__sprint_r>
42015c86:	1a8c      	beqz.n	a10, 42015c8b <_vfiprintf_r+0x1cb>
42015c88:	077606        	j	42017a64 <_vfiprintf_r+0x1fa4>
42015c8b:	e4a132        	movi	a3, 0x1e4
42015c8e:	10c162        	addi	a6, a1, 16
42015c91:	806630        	add	a6, a6, a3
42015c94:	986162        	s32i	a6, a1, 0x260
42015c97:	9e2182        	l32i	a8, a1, 0x278
42015c9a:	808850        	add	a8, a8, a5
42015c9d:	9e6182        	s32i	a8, a1, 0x278
42015ca0:	000232        	l8ui	a3, a2, 0
42015ca3:	13cc      	bnez.n	a3, 42015ca8 <_vfiprintf_r+0x1e8>
42015ca5:	0765c6        	j	42017a40 <_vfiprintf_r+0x1f80>
42015ca8:	10c192        	addi	a9, a1, 16
42015cab:	02d932        	addmi	a3, a9, 0x200
42015cae:	050c      	movi.n	a5, 0
42015cb0:	38a272        	movi	a7, 0x238
42015cb3:	080c      	movi.n	a8, 0
42015cb5:	3e4352        	s8i	a5, a3, 62
42015cb8:	997a      	add.n	a9, a9, a7
42015cba:	f57c      	movi.n	a5, -1
42015cbc:	9a6152        	s32i	a5, a1, 0x268
42015cbf:	621b      	addi.n	a6, a2, 1
42015cc1:	043d      	mov.n	a3, a4
42015cc3:	9d6182        	s32i	a8, a1, 0x274
42015cc6:	085d      	mov.n	a5, a8
42015cc8:	976182        	s32i	a8, a1, 0x25c
42015ccb:	a06192        	s32i	a9, a1, 0x280
42015cce:	0001c6        	j	42015cd9 <_vfiprintf_r+0x219>
42015cd1:	9b6172        	s32i	a7, a1, 0x26c
42015cd4:	050c      	movi.n	a5, 0
42015cd6:	9b2162        	l32i	a6, a1, 0x26c
42015cd9:	861b      	addi.n	a8, a6, 1
42015cdb:	9b6182        	s32i	a8, a1, 0x26c
42015cde:	000662        	l8ui	a6, a6, 0
42015ce1:	ac0fd1        	l32r	a13, 42000d20 <_stext+0xd00>
42015ce4:	080c      	movi.n	a8, 0
42015ce6:	990c      	movi.n	a9, 9
42015ce8:	4b2c      	movi.n	a11, 36
42015cea:	ac2c      	movi.n	a12, 42
42015cec:	0000c6        	j	42015cf3 <_vfiprintf_r+0x233>
42015cef:	00          	.byte 00
42015cf0:	9d6172        	s32i	a7, a1, 0x274
42015cf3:	e0c672        	addi	a7, a6, -32
42015cf6:	aa5c      	movi.n	a10, 90
42015cf8:	02ba77        	bgeu	a10, a7, 42015cfe <_vfiprintf_r+0x23e>
42015cfb:	065846        	j	42017660 <_vfiprintf_r+0x1ba0>
42015cfe:	a077d0        	addx4	a7, a7, a13
42015d01:	0778      	l32i.n	a7, a7, 0
42015d03:	0007a0        	jx	a7
42015d06:	9c21a2        	l32i	a10, a1, 0x270
42015d09:	201110        	or	a1, a1, a1
42015d0c:	fc8d65        	call8	420125e4 <_localeconv_r>
42015d0f:	1aa8      	l32i.n	a10, a10, 4
42015d11:	a361a2        	s32i	a10, a1, 0x28c
42015d14:	aa6081        	l32r	a8, 42000694 <_stext+0x674>
42015d17:	0008e0        	callx8	a8
42015d1a:	a261a2        	s32i	a10, a1, 0x288
42015d1d:	9c21a2        	l32i	a10, a1, 0x270
42015d20:	201110        	or	a1, a1, a1
42015d23:	fc8c25        	call8	420125e4 <_localeconv_r>
42015d26:	2aa8      	l32i.n	a10, a10, 8
42015d28:	a22162        	l32i	a6, a1, 0x288
42015d2b:	a161a2        	s32i	a10, a1, 0x284
42015d2e:	fa4616        	beqz	a6, 42015cd6 <_vfiprintf_r+0x216>
42015d31:	fa1a16        	beqz	a10, 42015cd6 <_vfiprintf_r+0x216>
42015d34:	000a62        	l8ui	a6, a10, 0
42015d37:	f9b616        	beqz	a6, 42015cd6 <_vfiprintf_r+0x216>
42015d3a:	00a462        	movi	a6, 0x400
42015d3d:	00b0c6        	j	42016004 <_vfiprintf_r+0x544>
42015d40:	10c192        	addi	a9, a1, 16
42015d43:	02d962        	addmi	a6, a9, 0x200
42015d46:	3e0672        	l8ui	a7, a6, 62
42015d49:	f89756        	bnez	a7, 42015cd6 <_vfiprintf_r+0x216>
42015d4c:	072c      	movi.n	a7, 32
42015d4e:	004246        	j	42015e5b <_vfiprintf_r+0x39b>
42015d51:	160c      	movi.n	a6, 1
42015d53:	00ab46        	j	42016004 <_vfiprintf_r+0x544>
42015d56:	00          	.byte 00
42015d57:	9b2192        	l32i	a9, a1, 0x26c
42015d5a:	980c      	movi.n	a8, 9
42015d5c:	000972        	l8ui	a7, a9, 0
42015d5f:	d0c762        	addi	a6, a7, -48
42015d62:	02b867        	bgeu	a8, a6, 42015d68 <_vfiprintf_r+0x2a8>
42015d65:	074e06        	j	42017aa1 <_vfiprintf_r+0x1fe1>
42015d68:	691b      	addi.n	a6, a9, 1
42015d6a:	0a0c      	movi.n	a10, 0
42015d6c:	d0c772        	addi	a7, a7, -48
42015d6f:	a0aaa0        	addx4	a10, a10, a10
42015d72:	90aa70        	addx2	a10, a10, a7
42015d75:	000672        	l8ui	a7, a6, 0
42015d78:	661b      	addi.n	a6, a6, 1
42015d7a:	d0c792        	addi	a9, a7, -48
42015d7d:	ebb897        	bgeu	a8, a9, 42015d6c <_vfiprintf_r+0x2ac>
42015d80:	482c      	movi.n	a8, 36
42015d82:	021787        	beq	a7, a8, 42015d88 <_vfiprintf_r+0x2c8>
42015d85:	ffd2c6        	j	42015cd4 <_vfiprintf_r+0x214>
42015d88:	072c      	movi.n	a7, 32
42015d8a:	02a7a7        	bge	a7, a10, 42015d90 <_vfiprintf_r+0x2d0>
42015d8d:	0734c6        	j	42017a64 <_vfiprintf_r+0x1fa4>
42015d90:	922172        	l32i	a7, a1, 0x248
42015d93:	aa0b      	addi.n	a10, a10, -1
42015d95:	08aa77        	bge	a10, a7, 42015da1 <_vfiprintf_r+0x2e1>
42015d98:	10c1c2        	addi	a12, a1, 16
42015d9b:	b0aac0        	addx8	a10, a10, a12
42015d9e:	0006c6        	j	42015dbd <_vfiprintf_r+0x2fd>
42015da1:	10c1d2        	addi	a13, a1, 16
42015da4:	34a272        	movi	a7, 0x234
42015da7:	7d7a      	add.n	a7, a13, a7
42015da9:	0ded      	mov.n	a14, a13
42015dab:	01ddf2        	addmi	a15, a13, 0x100
42015dae:	40a2c2        	movi	a12, 0x240
42015db1:	a021d2        	l32i	a13, a1, 0x280
42015db4:	0179      	s32i.n	a7, a1, 0
42015db6:	ceca      	add.n	a12, a14, a12
42015db8:	02bd      	mov.n	a11, a2
42015dba:	ff7ea5        	call8	420155a4 <get_arg$constprop$0>
42015dbd:	0aa8      	l32i.n	a10, a10, 0
42015dbf:	049d      	mov.n	a9, a4
42015dc1:	9d61a2        	s32i	a10, a1, 0x274
42015dc4:	9b6162        	s32i	a6, a1, 0x26c
42015dc7:	001d46        	j	42015e40 <_vfiprintf_r+0x380>
42015dca:	00          	.byte 00
42015dcb:	00          	.byte 00
42015dcc:	10c1e2        	addi	a14, a1, 16
42015dcf:	b043e0        	addx8	a4, a3, a14
42015dd2:	001946        	j	42015e3b <_vfiprintf_r+0x37b>
42015dd5:	10c1f2        	addi	a15, a1, 16
42015dd8:	922fa2        	l32i	a10, a15, 0x248
42015ddb:	fb1c      	movi.n	a11, 31
42015ddd:	02df72        	addmi	a7, a15, 0x200
42015de0:	4a4b      	addi.n	a4, a10, 4
42015de2:	881c      	movi.n	a8, 24
42015de4:	342b67        	blt	a11, a6, 42015e1c <_vfiprintf_r+0x35c>
42015de7:	b61b      	addi.n	a11, a6, 1
42015de9:	9261b2        	s32i	a11, a1, 0x248
42015dec:	126742        	s32i	a4, a7, 72
42015def:	052847        	blt	a8, a4, 42015df8 <_vfiprintf_r+0x338>
42015df2:	112742        	l32i	a4, a7, 68
42015df5:	000286        	j	42015e03 <_vfiprintf_r+0x343>
42015df8:	0128a7        	blt	a8, a10, 42015dfd <_vfiprintf_r+0x33d>
42015dfb:	442c      	movi.n	a4, 36
42015dfd:	966142        	s32i	a4, a1, 0x258
42015e00:	942142        	l32i	a4, a1, 0x250
42015e03:	962172        	l32i	a7, a1, 0x258
42015e06:	10c1a2        	addi	a10, a1, 16
42015e09:	447a      	add.n	a4, a4, a7
42015e0b:	fcc442        	addi	a4, a4, -4
42015e0e:	0448      	l32i.n	a4, a4, 0
42015e10:	b066a0        	addx8	a6, a6, a10
42015e13:	9d6142        	s32i	a4, a1, 0x274
42015e16:	0649      	s32i.n	a4, a6, 0
42015e18:	000906        	j	42015e40 <_vfiprintf_r+0x380>
42015e1b:	00          	.byte 00
42015e1c:	126742        	s32i	a4, a7, 72
42015e1f:	052847        	blt	a8, a4, 42015e28 <_vfiprintf_r+0x368>
42015e22:	112742        	l32i	a4, a7, 68
42015e25:	000286        	j	42015e33 <_vfiprintf_r+0x373>
42015e28:	0128a7        	blt	a8, a10, 42015e2d <_vfiprintf_r+0x36d>
42015e2b:	442c      	movi.n	a4, 36
42015e2d:	966142        	s32i	a4, a1, 0x258
42015e30:	942142        	l32i	a4, a1, 0x250
42015e33:	962162        	l32i	a6, a1, 0x258
42015e36:	446a      	add.n	a4, a4, a6
42015e38:	fcc442        	addi	a4, a4, -4
42015e3b:	0448      	l32i.n	a4, a4, 0
42015e3d:	9d6142        	s32i	a4, a1, 0x274
42015e40:	9d2162        	l32i	a6, a1, 0x274
42015e43:	094d      	mov.n	a4, a9
42015e45:	e8d6d6        	bgez	a6, 42015cd6 <_vfiprintf_r+0x216>
42015e48:	606060        	neg	a6, a6
42015e4b:	9d6162        	s32i	a6, a1, 0x274
42015e4e:	460c      	movi.n	a6, 4
42015e50:	006c06        	j	42016004 <_vfiprintf_r+0x544>
42015e53:	10c192        	addi	a9, a1, 16
42015e56:	b72c      	movi.n	a7, 43
42015e58:	02d962        	addmi	a6, a9, 0x200
42015e5b:	3e4672        	s8i	a7, a6, 62
42015e5e:	ff9d06        	j	42015cd6 <_vfiprintf_r+0x216>
42015e61:	9b21a2        	l32i	a10, a1, 0x26c
42015e64:	000a62        	l8ui	a6, a10, 0
42015e67:	7a1b      	addi.n	a7, a10, 1
42015e69:	0716c7        	beq	a6, a12, 42015e74 <_vfiprintf_r+0x3b4>
42015e6c:	9a6182        	s32i	a8, a1, 0x268
42015e6f:	0041c6        	j	42015f7a <_vfiprintf_r+0x4ba>
42015e72:	00          	.byte 00
42015e73:	00          	.byte 00
42015e74:	9b2192        	l32i	a9, a1, 0x26c
42015e77:	010982        	l8ui	a8, a9, 1
42015e7a:	990c      	movi.n	a9, 9
42015e7c:	d0c862        	addi	a6, a8, -48
42015e7f:	02b967        	bgeu	a9, a6, 42015e85 <_vfiprintf_r+0x3c5>
42015e82:	070a86        	j	42017ab0 <_vfiprintf_r+0x1ff0>
42015e85:	9b21a2        	l32i	a10, a1, 0x26c
42015e88:	6a2b      	addi.n	a6, a10, 2
42015e8a:	0a0c      	movi.n	a10, 0
42015e8c:	d0c882        	addi	a8, a8, -48
42015e8f:	a0aaa0        	addx4	a10, a10, a10
42015e92:	90aa80        	addx2	a10, a10, a8
42015e95:	000682        	l8ui	a8, a6, 0
42015e98:	661b      	addi.n	a6, a6, 1
42015e9a:	d0c8b2        	addi	a11, a8, -48
42015e9d:	ebb9b7        	bgeu	a9, a11, 42015e8c <_vfiprintf_r+0x3cc>
42015ea0:	492c      	movi.n	a9, 36
42015ea2:	021897        	beq	a8, a9, 42015ea8 <_vfiprintf_r+0x3e8>
42015ea5:	ff8a06        	j	42015cd1 <_vfiprintf_r+0x211>
42015ea8:	072c      	movi.n	a7, 32
42015eaa:	02a7a7        	bge	a7, a10, 42015eb0 <_vfiprintf_r+0x3f0>
42015ead:	06ecc6        	j	42017a64 <_vfiprintf_r+0x1fa4>
42015eb0:	922172        	l32i	a7, a1, 0x248
42015eb3:	aa0b      	addi.n	a10, a10, -1
42015eb5:	08aa77        	bge	a10, a7, 42015ec1 <_vfiprintf_r+0x401>
42015eb8:	10c1c2        	addi	a12, a1, 16
42015ebb:	b0aac0        	addx8	a10, a10, a12
42015ebe:	0006c6        	j	42015edd <_vfiprintf_r+0x41d>
42015ec1:	10c1d2        	addi	a13, a1, 16
42015ec4:	34a272        	movi	a7, 0x234
42015ec7:	7d7a      	add.n	a7, a13, a7
42015ec9:	0ded      	mov.n	a14, a13
42015ecb:	01ddf2        	addmi	a15, a13, 0x100
42015ece:	40a2c2        	movi	a12, 0x240
42015ed1:	a021d2        	l32i	a13, a1, 0x280
42015ed4:	0179      	s32i.n	a7, a1, 0
42015ed6:	ceca      	add.n	a12, a14, a12
42015ed8:	02bd      	mov.n	a11, a2
42015eda:	ff6ca5        	call8	420155a4 <get_arg$constprop$0>
42015edd:	0a88      	l32i.n	a8, a10, 0
42015edf:	067d      	mov.n	a7, a6
42015ee1:	049d      	mov.n	a9, a4
42015ee3:	001c86        	j	42015f59 <_vfiprintf_r+0x499>
42015ee6:	00          	.byte 00
42015ee7:	00          	.byte 00
42015ee8:	10c1e2        	addi	a14, a1, 16
42015eeb:	b043e0        	addx8	a4, a3, a14
42015eee:	001946        	j	42015f57 <_vfiprintf_r+0x497>
42015ef1:	10c1f2        	addi	a15, a1, 16
42015ef4:	922fa2        	l32i	a10, a15, 0x248
42015ef7:	fb1c      	movi.n	a11, 31
42015ef9:	02df82        	addmi	a8, a15, 0x200
42015efc:	4a4b      	addi.n	a4, a10, 4
42015efe:	322b67        	blt	a11, a6, 42015f34 <_vfiprintf_r+0x474>
42015f01:	b61b      	addi.n	a11, a6, 1
42015f03:	9261b2        	s32i	a11, a1, 0x248
42015f06:	126842        	s32i	a4, a8, 72
42015f09:	8b1c      	movi.n	a11, 24
42015f0b:	052b47        	blt	a11, a4, 42015f14 <_vfiprintf_r+0x454>
42015f0e:	112842        	l32i	a4, a8, 68
42015f11:	000286        	j	42015f1f <_vfiprintf_r+0x45f>
42015f14:	012ba7        	blt	a11, a10, 42015f19 <_vfiprintf_r+0x459>
42015f17:	442c      	movi.n	a4, 36
42015f19:	966142        	s32i	a4, a1, 0x258
42015f1c:	942142        	l32i	a4, a1, 0x250
42015f1f:	962182        	l32i	a8, a1, 0x258
42015f22:	10c1c2        	addi	a12, a1, 16
42015f25:	448a      	add.n	a4, a4, a8
42015f27:	fcc442        	addi	a4, a4, -4
42015f2a:	0488      	l32i.n	a8, a4, 0
42015f2c:	b066c0        	addx8	a6, a6, a12
42015f2f:	0689      	s32i.n	a8, a6, 0
42015f31:	000906        	j	42015f59 <_vfiprintf_r+0x499>
42015f34:	126842        	s32i	a4, a8, 72
42015f37:	861c      	movi.n	a6, 24
42015f39:	072647        	blt	a6, a4, 42015f44 <_vfiprintf_r+0x484>
42015f3c:	112842        	l32i	a4, a8, 68
42015f3f:	000306        	j	42015f4f <_vfiprintf_r+0x48f>
42015f42:	00          	.byte 00
42015f43:	00          	.byte 00
42015f44:	0126a7        	blt	a6, a10, 42015f49 <_vfiprintf_r+0x489>
42015f47:	442c      	movi.n	a4, 36
42015f49:	966142        	s32i	a4, a1, 0x258
42015f4c:	942142        	l32i	a4, a1, 0x250
42015f4f:	962162        	l32i	a6, a1, 0x258
42015f52:	446a      	add.n	a4, a4, a6
42015f54:	fcc442        	addi	a4, a4, -4
42015f57:	0488      	l32i.n	a8, a4, 0
42015f59:	f47c      	movi.n	a4, -1
42015f5b:	534840        	max	a4, a8, a4
42015f5e:	9a6142        	s32i	a4, a1, 0x268
42015f61:	9b6172        	s32i	a7, a1, 0x26c
42015f64:	094d      	mov.n	a4, a9
42015f66:	ff5b06        	j	42015cd6 <_vfiprintf_r+0x216>
42015f69:	9a21e2        	l32i	a14, a1, 0x268
42015f6c:	a06ee0        	addx4	a6, a14, a14
42015f6f:	9066a0        	addx2	a6, a6, a10
42015f72:	9a6162        	s32i	a6, a1, 0x268
42015f75:	000762        	l8ui	a6, a7, 0
42015f78:	771b      	addi.n	a7, a7, 1
42015f7a:	9b6172        	s32i	a7, a1, 0x26c
42015f7d:	d0c6a2        	addi	a10, a6, -48
42015f80:	e5b9a7        	bgeu	a9, a10, 42015f69 <_vfiprintf_r+0x4a9>
42015f83:	9d2172        	l32i	a7, a1, 0x274
42015f86:	ff5986        	j	42015cf0 <_vfiprintf_r+0x230>
42015f89:	80a062        	movi	a6, 128
42015f8c:	001d06        	j	42016004 <_vfiprintf_r+0x544>
42015f8f:	087d      	mov.n	a7, a8
42015f91:	d0c662        	addi	a6, a6, -48
42015f94:	a07770        	addx4	a7, a7, a7
42015f97:	907760        	addx2	a7, a7, a6
42015f9a:	9b2162        	l32i	a6, a1, 0x26c
42015f9d:	9b21a2        	l32i	a10, a1, 0x26c
42015fa0:	000662        	l8ui	a6, a6, 0
42015fa3:	aa1b      	addi.n	a10, a10, 1
42015fa5:	9b61a2        	s32i	a10, a1, 0x26c
42015fa8:	d0c6a2        	addi	a10, a6, -48
42015fab:	e2b9a7        	bgeu	a9, a10, 42015f91 <_vfiprintf_r+0x4d1>
42015fae:	0216b7        	beq	a6, a11, 42015fb4 <_vfiprintf_r+0x4f4>
42015fb1:	ff4ec6        	j	42015cf0 <_vfiprintf_r+0x230>
42015fb4:	032c      	movi.n	a3, 32
42015fb6:	02a377        	bge	a3, a7, 42015fbc <_vfiprintf_r+0x4fc>
42015fb9:	06a9c6        	j	42017a64 <_vfiprintf_r+0x1fa4>
42015fbc:	370b      	addi.n	a3, a7, -1
42015fbe:	150c      	movi.n	a5, 1
42015fc0:	ff4486        	j	42015cd6 <_vfiprintf_r+0x216>
42015fc3:	9b2182        	l32i	a8, a1, 0x26c
42015fc6:	68a062        	movi	a6, 104
42015fc9:	000872        	l8ui	a7, a8, 0
42015fcc:	0a9767        	bne	a7, a6, 42015fda <_vfiprintf_r+0x51a>
42015fcf:	881b      	addi.n	a8, a8, 1
42015fd1:	9b6182        	s32i	a8, a1, 0x26c
42015fd4:	00a262        	movi	a6, 0x200
42015fd7:	0006c6        	j	42015ff6 <_vfiprintf_r+0x536>
42015fda:	064c      	movi.n	a6, 64
42015fdc:	000906        	j	42016004 <_vfiprintf_r+0x544>
42015fdf:	00          	.byte 00
42015fe0:	9b2192        	l32i	a9, a1, 0x26c
42015fe3:	6ca062        	movi	a6, 108
42015fe6:	000972        	l8ui	a7, a9, 0
42015fe9:	079767        	bne	a7, a6, 42015ff4 <_vfiprintf_r+0x534>
42015fec:	991b      	addi.n	a9, a9, 1
42015fee:	9b6192        	s32i	a9, a1, 0x26c
42015ff1:	000346        	j	42016002 <_vfiprintf_r+0x542>
42015ff4:	061c      	movi.n	a6, 16
42015ff6:	972192        	l32i	a9, a1, 0x25c
42015ff9:	209960        	or	a9, a9, a6
42015ffc:	976192        	s32i	a9, a1, 0x25c
42015fff:	ff34c6        	j	42015cd6 <_vfiprintf_r+0x216>
42016002:	062c      	movi.n	a6, 32
42016004:	972182        	l32i	a8, a1, 0x25c
42016007:	208860        	or	a8, a8, a6
4201600a:	976182        	s32i	a8, a1, 0x25c
4201600d:	ff3146        	j	42015cd6 <_vfiprintf_r+0x216>
42016010:	922162        	l32i	a6, a1, 0x248
42016013:	55bc      	beqz.n	a5, 4201604c <_vfiprintf_r+0x58c>
42016015:	0ba367        	bge	a3, a6, 42016024 <_vfiprintf_r+0x564>
42016018:	10c192        	addi	a9, a1, 16
4201601b:	b03390        	addx8	a3, a3, a9
4201601e:	000332        	l8ui	a3, a3, 0
42016021:	000886        	j	42016047 <_vfiprintf_r+0x587>
42016024:	10c1a2        	addi	a10, a1, 16
42016027:	34a252        	movi	a5, 0x234
4201602a:	5a5a      	add.n	a5, a10, a5
4201602c:	38a2d2        	movi	a13, 0x238
4201602f:	40a2c2        	movi	a12, 0x240
42016032:	01daf2        	addmi	a15, a10, 0x100
42016035:	0aed      	mov.n	a14, a10
42016037:	dada      	add.n	a13, a10, a13
42016039:	caca      	add.n	a12, a10, a12
4201603b:	0159      	s32i.n	a5, a1, 0
4201603d:	03ad      	mov.n	a10, a3
4201603f:	02bd      	mov.n	a11, a2
42016041:	ff5625        	call8	420155a4 <get_arg$constprop$0>
42016044:	000a32        	l8ui	a3, a10, 0
42016047:	042d      	mov.n	a2, a4
42016049:	001d86        	j	420160c3 <_vfiprintf_r+0x603>
4201604c:	10c1c2        	addi	a12, a1, 16
4201604f:	241b      	addi.n	a2, a4, 1
42016051:	b033c0        	addx8	a3, a3, a12
42016054:	682467        	blt	a4, a6, 420160c0 <_vfiprintf_r+0x600>
42016057:	10c1d2        	addi	a13, a1, 16
4201605a:	922d72        	l32i	a7, a13, 0x248
4201605d:	f81c      	movi.n	a8, 31
4201605f:	02dd42        	addmi	a4, a13, 0x200
42016062:	374b      	addi.n	a3, a7, 4
42016064:	851c      	movi.n	a5, 24
42016066:	362867        	blt	a8, a6, 420160a0 <_vfiprintf_r+0x5e0>
42016069:	861b      	addi.n	a8, a6, 1
4201606b:	926182        	s32i	a8, a1, 0x248
4201606e:	126432        	s32i	a3, a4, 72
42016071:	072537        	blt	a5, a3, 4201607c <_vfiprintf_r+0x5bc>
42016074:	112432        	l32i	a3, a4, 68
42016077:	000306        	j	42016087 <_vfiprintf_r+0x5c7>
4201607a:	00          	.byte 00
4201607b:	00          	.byte 00
4201607c:	012577        	blt	a5, a7, 42016081 <_vfiprintf_r+0x5c1>
4201607f:	432c      	movi.n	a3, 36
42016081:	966132        	s32i	a3, a1, 0x258
42016084:	942132        	l32i	a3, a1, 0x250
42016087:	962142        	l32i	a4, a1, 0x258
4201608a:	10c1f2        	addi	a15, a1, 16
4201608d:	334a      	add.n	a3, a3, a4
4201608f:	fcc332        	addi	a3, a3, -4
42016092:	0338      	l32i.n	a3, a3, 0
42016094:	b046f0        	addx8	a4, a6, a15
42016097:	0439      	s32i.n	a3, a4, 0
42016099:	743030        	extui	a3, a3, 0, 8
4201609c:	0008c6        	j	420160c3 <_vfiprintf_r+0x603>
4201609f:	00          	.byte 00
420160a0:	126432        	s32i	a3, a4, 72
420160a3:	052537        	blt	a5, a3, 420160ac <_vfiprintf_r+0x5ec>
420160a6:	112432        	l32i	a3, a4, 68
420160a9:	000286        	j	420160b7 <_vfiprintf_r+0x5f7>
420160ac:	012577        	blt	a5, a7, 420160b1 <_vfiprintf_r+0x5f1>
420160af:	432c      	movi.n	a3, 36
420160b1:	966132        	s32i	a3, a1, 0x258
420160b4:	942132        	l32i	a3, a1, 0x250
420160b7:	962142        	l32i	a4, a1, 0x258
420160ba:	803340        	add	a3, a3, a4
420160bd:	fcc332        	addi	a3, a3, -4
420160c0:	000332        	l8ui	a3, a3, 0
420160c3:	10c162        	addi	a6, a1, 16
420160c6:	01d642        	addmi	a4, a6, 0x100
420160c9:	804432        	s8i	a3, a4, 128
420160cc:	180c      	movi.n	a8, 1
420160ce:	040c      	movi.n	a4, 0
420160d0:	02d632        	addmi	a3, a6, 0x200
420160d3:	90a192        	movi	a9, 0x190
420160d6:	3e4342        	s8i	a4, a3, 62
420160d9:	9a6182        	s32i	a8, a1, 0x268
420160dc:	040c      	movi.n	a4, 0
420160de:	319a      	add.n	a3, a1, a9
420160e0:	056846        	j	42017685 <_vfiprintf_r+0x1bc5>
420160e3:	972182        	l32i	a8, a1, 0x25c
420160e6:	061c      	movi.n	a6, 16
420160e8:	208860        	or	a8, a8, a6
420160eb:	976182        	s32i	a8, a1, 0x25c
420160ee:	972192        	l32i	a9, a1, 0x25c
420160f1:	922162        	l32i	a6, a1, 0x248
420160f4:	02e957        	bbsi	a9, 5, 420160fa <_vfiprintf_r+0x63a>
420160f7:	002f46        	j	420161b8 <_vfiprintf_r+0x6f8>
420160fa:	75bc      	beqz.n	a5, 42016135 <_vfiprintf_r+0x675>
420160fc:	0ca367        	bge	a3, a6, 4201610c <_vfiprintf_r+0x64c>
420160ff:	10c1a2        	addi	a10, a1, 16
42016102:	b033a0        	addx8	a3, a3, a10
42016105:	0358      	l32i.n	a5, a3, 0
42016107:	1378      	l32i.n	a7, a3, 4
42016109:	0008c6        	j	42016130 <_vfiprintf_r+0x670>
4201610c:	10c1c2        	addi	a12, a1, 16
4201610f:	34a252        	movi	a5, 0x234
42016112:	38a2d2        	movi	a13, 0x238
42016115:	5c5a      	add.n	a5, a12, a5
42016117:	0ced      	mov.n	a14, a12
42016119:	01dcf2        	addmi	a15, a12, 0x100
4201611c:	dcda      	add.n	a13, a12, a13
4201611e:	40a2c2        	movi	a12, 0x240
42016121:	0159      	s32i.n	a5, a1, 0
42016123:	ceca      	add.n	a12, a14, a12
42016125:	02bd      	mov.n	a11, a2
42016127:	03ad      	mov.n	a10, a3
42016129:	ff47a5        	call8	420155a4 <get_arg$constprop$0>
4201612c:	0a58      	l32i.n	a5, a10, 0
4201612e:	1a78      	l32i.n	a7, a10, 4
42016130:	042d      	mov.n	a2, a4
42016132:	00cac6        	j	42016461 <_vfiprintf_r+0x9a1>
42016135:	10c1d2        	addi	a13, a1, 16
42016138:	241b      	addi.n	a2, a4, 1
4201613a:	b033d0        	addx8	a3, a3, a13
4201613d:	6f2467        	blt	a4, a6, 420161b0 <_vfiprintf_r+0x6f0>
42016140:	10c1e2        	addi	a14, a1, 16
42016143:	922e42        	l32i	a4, a14, 0x248
42016146:	837c      	movi.n	a3, -8
42016148:	447b      	addi.n	a4, a4, 7
4201614a:	104430        	and	a4, a4, a3
4201614d:	f81c      	movi.n	a8, 31
4201614f:	02de52        	addmi	a5, a14, 0x200
42016152:	348b      	addi.n	a3, a4, 8
42016154:	871c      	movi.n	a7, 24
42016156:	362867        	blt	a8, a6, 42016190 <_vfiprintf_r+0x6d0>
42016159:	861b      	addi.n	a8, a6, 1
4201615b:	926182        	s32i	a8, a1, 0x248
4201615e:	126532        	s32i	a3, a5, 72
42016161:	072737        	blt	a7, a3, 4201616c <_vfiprintf_r+0x6ac>
42016164:	112532        	l32i	a3, a5, 68
42016167:	000306        	j	42016177 <_vfiprintf_r+0x6b7>
4201616a:	00          	.byte 00
4201616b:	00          	.byte 00
4201616c:	012747        	blt	a7, a4, 42016171 <_vfiprintf_r+0x6b1>
4201616f:	832c      	movi.n	a3, 40
42016171:	966132        	s32i	a3, a1, 0x258
42016174:	942132        	l32i	a3, a1, 0x250
42016177:	962142        	l32i	a4, a1, 0x258
4201617a:	334a      	add.n	a3, a3, a4
4201617c:	f8c332        	addi	a3, a3, -8
4201617f:	0358      	l32i.n	a5, a3, 0
42016181:	1378      	l32i.n	a7, a3, 4
42016183:	10c132        	addi	a3, a1, 16
42016186:	b06630        	addx8	a6, a6, a3
42016189:	0659      	s32i.n	a5, a6, 0
4201618b:	1679      	s32i.n	a7, a6, 4
4201618d:	00b406        	j	42016461 <_vfiprintf_r+0x9a1>
42016190:	126532        	s32i	a3, a5, 72
42016193:	052737        	blt	a7, a3, 4201619c <_vfiprintf_r+0x6dc>
42016196:	112532        	l32i	a3, a5, 68
42016199:	000286        	j	420161a7 <_vfiprintf_r+0x6e7>
4201619c:	012747        	blt	a7, a4, 420161a1 <_vfiprintf_r+0x6e1>
4201619f:	832c      	movi.n	a3, 40
420161a1:	966132        	s32i	a3, a1, 0x258
420161a4:	942132        	l32i	a3, a1, 0x250
420161a7:	962142        	l32i	a4, a1, 0x258
420161aa:	803340        	add	a3, a3, a4
420161ad:	f8c332        	addi	a3, a3, -8
420161b0:	0358      	l32i.n	a5, a3, 0
420161b2:	1378      	l32i.n	a7, a3, 4
420161b4:	00aa46        	j	42016461 <_vfiprintf_r+0x9a1>
420161b7:	00          	.byte 00
420161b8:	972182        	l32i	a8, a1, 0x25c
420161bb:	756847        	bbci	a8, 4, 42016234 <_vfiprintf_r+0x774>
420161be:	e59c      	beqz.n	a5, 420161e0 <_vfiprintf_r+0x720>
420161c0:	08a367        	bge	a3, a6, 420161cc <_vfiprintf_r+0x70c>
420161c3:	10c192        	addi	a9, a1, 16
420161c6:	b03390        	addx8	a3, a3, a9
420161c9:	007cc6        	j	420163c0 <_vfiprintf_r+0x900>
420161cc:	10c1a2        	addi	a10, a1, 16
420161cf:	34a252        	movi	a5, 0x234
420161d2:	5a5a      	add.n	a5, a10, a5
420161d4:	0159      	s32i.n	a5, a1, 0
420161d6:	01daf2        	addmi	a15, a10, 0x100
420161d9:	0aed      	mov.n	a14, a10
420161db:	007d46        	j	420163d4 <_vfiprintf_r+0x914>
420161de:	00          	.byte 00
420161df:	00          	.byte 00
420161e0:	10c1c2        	addi	a12, a1, 16
420161e3:	241b      	addi.n	a2, a4, 1
420161e5:	b033c0        	addx8	a3, a3, a12
420161e8:	02a467        	bge	a4, a6, 420161ee <_vfiprintf_r+0x72e>
420161eb:	009b46        	j	4201645c <_vfiprintf_r+0x99c>
420161ee:	10c1d2        	addi	a13, a1, 16
420161f1:	922d72        	l32i	a7, a13, 0x248
420161f4:	f81c      	movi.n	a8, 31
420161f6:	02dd42        	addmi	a4, a13, 0x200
420161f9:	374b      	addi.n	a3, a7, 4
420161fb:	851c      	movi.n	a5, 24
420161fd:	02a867        	bge	a8, a6, 42016203 <_vfiprintf_r+0x743>
42016200:	008e06        	j	4201643c <_vfiprintf_r+0x97c>
42016203:	861b      	addi.n	a8, a6, 1
42016205:	926182        	s32i	a8, a1, 0x248
42016208:	126432        	s32i	a3, a4, 72
4201620b:	052537        	blt	a5, a3, 42016214 <_vfiprintf_r+0x754>
4201620e:	112432        	l32i	a3, a4, 68
42016211:	000286        	j	4201621f <_vfiprintf_r+0x75f>
42016214:	012577        	blt	a5, a7, 42016219 <_vfiprintf_r+0x759>
42016217:	432c      	movi.n	a3, 36
42016219:	966132        	s32i	a3, a1, 0x258
4201621c:	942132        	l32i	a3, a1, 0x250
4201621f:	962142        	l32i	a4, a1, 0x258
42016222:	10c1f2        	addi	a15, a1, 16
42016225:	334a      	add.n	a3, a3, a4
42016227:	fcc332        	addi	a3, a3, -4
4201622a:	0358      	l32i.n	a5, a3, 0
4201622c:	b066f0        	addx8	a6, a6, a15
4201622f:	008106        	j	42016437 <_vfiprintf_r+0x977>
42016232:	00          	.byte 00
42016233:	00          	.byte 00
42016234:	972182        	l32i	a8, a1, 0x25c
42016237:	02e867        	bbsi	a8, 6, 4201623d <_vfiprintf_r+0x77d>
4201623a:	002d86        	j	420162f4 <_vfiprintf_r+0x834>
4201623d:	75bc      	beqz.n	a5, 42016278 <_vfiprintf_r+0x7b8>
4201623f:	0ba367        	bge	a3, a6, 4201624e <_vfiprintf_r+0x78e>
42016242:	10c192        	addi	a9, a1, 16
42016245:	b03390        	addx8	a3, a3, a9
42016248:	009352        	l16si	a5, a3, 0
4201624b:	006606        	j	420163e7 <_vfiprintf_r+0x927>
4201624e:	10c1a2        	addi	a10, a1, 16
42016251:	34a252        	movi	a5, 0x234
42016254:	5a5a      	add.n	a5, a10, a5
42016256:	38a2d2        	movi	a13, 0x238
42016259:	40a2c2        	movi	a12, 0x240
4201625c:	0159      	s32i.n	a5, a1, 0
4201625e:	01daf2        	addmi	a15, a10, 0x100
42016261:	0aed      	mov.n	a14, a10
42016263:	dada      	add.n	a13, a10, a13
42016265:	caca      	add.n	a12, a10, a12
42016267:	20b220        	or	a11, a2, a2
4201626a:	20a330        	or	a10, a3, a3
4201626d:	ff3365        	call8	420155a4 <get_arg$constprop$0>
42016270:	009a52        	l16si	a5, a10, 0
42016273:	005c06        	j	420163e7 <_vfiprintf_r+0x927>
42016276:	00          	.byte 00
42016277:	00          	.byte 00
42016278:	10c1c2        	addi	a12, a1, 16
4201627b:	241b      	addi.n	a2, a4, 1
4201627d:	b033c0        	addx8	a3, a3, a12
42016280:	682467        	blt	a4, a6, 420162ec <_vfiprintf_r+0x82c>
42016283:	10c1d2        	addi	a13, a1, 16
42016286:	922d72        	l32i	a7, a13, 0x248
42016289:	f81c      	movi.n	a8, 31
4201628b:	02dd42        	addmi	a4, a13, 0x200
4201628e:	374b      	addi.n	a3, a7, 4
42016290:	851c      	movi.n	a5, 24
42016292:	362867        	blt	a8, a6, 420162cc <_vfiprintf_r+0x80c>
42016295:	861b      	addi.n	a8, a6, 1
42016297:	926182        	s32i	a8, a1, 0x248
4201629a:	126432        	s32i	a3, a4, 72
4201629d:	072537        	blt	a5, a3, 420162a8 <_vfiprintf_r+0x7e8>
420162a0:	112432        	l32i	a3, a4, 68
420162a3:	000306        	j	420162b3 <_vfiprintf_r+0x7f3>
420162a6:	00          	.byte 00
420162a7:	00          	.byte 00
420162a8:	012577        	blt	a5, a7, 420162ad <_vfiprintf_r+0x7ed>
420162ab:	432c      	movi.n	a3, 36
420162ad:	966132        	s32i	a3, a1, 0x258
420162b0:	942132        	l32i	a3, a1, 0x250
420162b3:	962142        	l32i	a4, a1, 0x258
420162b6:	10c1f2        	addi	a15, a1, 16
420162b9:	334a      	add.n	a3, a3, a4
420162bb:	fcc332        	addi	a3, a3, -4
420162be:	0358      	l32i.n	a5, a3, 0
420162c0:	b066f0        	addx8	a6, a6, a15
420162c3:	0659      	s32i.n	a5, a6, 0
420162c5:	235580        	sext	a5, a5, 15
420162c8:	006486        	j	4201645e <_vfiprintf_r+0x99e>
420162cb:	00          	.byte 00
420162cc:	126432        	s32i	a3, a4, 72
420162cf:	052537        	blt	a5, a3, 420162d8 <_vfiprintf_r+0x818>
420162d2:	112432        	l32i	a3, a4, 68
420162d5:	000286        	j	420162e3 <_vfiprintf_r+0x823>
420162d8:	012577        	blt	a5, a7, 420162dd <_vfiprintf_r+0x81d>
420162db:	432c      	movi.n	a3, 36
420162dd:	966132        	s32i	a3, a1, 0x258
420162e0:	942132        	l32i	a3, a1, 0x250
420162e3:	962142        	l32i	a4, a1, 0x258
420162e6:	803340        	add	a3, a3, a4
420162e9:	fcc332        	addi	a3, a3, -4
420162ec:	009352        	l16si	a5, a3, 0
420162ef:	005ac6        	j	4201645e <_vfiprintf_r+0x99e>
420162f2:	00          	.byte 00
420162f3:	00          	.byte 00
420162f4:	972182        	l32i	a8, a1, 0x25c
420162f7:	02e897        	bbsi	a8, 9, 420162fd <_vfiprintf_r+0x83d>
420162fa:	002dc6        	j	420163b5 <_vfiprintf_r+0x8f5>
420162fd:	75bc      	beqz.n	a5, 42016338 <_vfiprintf_r+0x878>
420162ff:	0da367        	bge	a3, a6, 42016310 <_vfiprintf_r+0x850>
42016302:	10c192        	addi	a9, a1, 16
42016305:	b03390        	addx8	a3, a3, a9
42016308:	000352        	l8ui	a5, a3, 0
4201630b:	000906        	j	42016333 <_vfiprintf_r+0x873>
4201630e:	00          	.byte 00
4201630f:	00          	.byte 00
42016310:	10c1a2        	addi	a10, a1, 16
42016313:	34a252        	movi	a5, 0x234
42016316:	5a5a      	add.n	a5, a10, a5
42016318:	38a2d2        	movi	a13, 0x238
4201631b:	40a2c2        	movi	a12, 0x240
4201631e:	0159      	s32i.n	a5, a1, 0
42016320:	01daf2        	addmi	a15, a10, 0x100
42016323:	0aed      	mov.n	a14, a10
42016325:	dada      	add.n	a13, a10, a13
42016327:	caca      	add.n	a12, a10, a12
42016329:	02bd      	mov.n	a11, a2
4201632b:	03ad      	mov.n	a10, a3
4201632d:	ff2765        	call8	420155a4 <get_arg$constprop$0>
42016330:	000a52        	l8ui	a5, a10, 0
42016333:	042d      	mov.n	a2, a4
42016335:	001d86        	j	420163af <_vfiprintf_r+0x8ef>
42016338:	10c1c2        	addi	a12, a1, 16
4201633b:	241b      	addi.n	a2, a4, 1
4201633d:	b033c0        	addx8	a3, a3, a12
42016340:	682467        	blt	a4, a6, 420163ac <_vfiprintf_r+0x8ec>
42016343:	10c1d2        	addi	a13, a1, 16
42016346:	922d72        	l32i	a7, a13, 0x248
42016349:	f81c      	movi.n	a8, 31
4201634b:	02dd42        	addmi	a4, a13, 0x200
4201634e:	374b      	addi.n	a3, a7, 4
42016350:	851c      	movi.n	a5, 24
42016352:	362867        	blt	a8, a6, 4201638c <_vfiprintf_r+0x8cc>
42016355:	861b      	addi.n	a8, a6, 1
42016357:	926182        	s32i	a8, a1, 0x248
4201635a:	126432        	s32i	a3, a4, 72
4201635d:	072537        	blt	a5, a3, 42016368 <_vfiprintf_r+0x8a8>
42016360:	112432        	l32i	a3, a4, 68
42016363:	000306        	j	42016373 <_vfiprintf_r+0x8b3>
42016366:	00          	.byte 00
42016367:	00          	.byte 00
42016368:	012577        	blt	a5, a7, 4201636d <_vfiprintf_r+0x8ad>
4201636b:	432c      	movi.n	a3, 36
4201636d:	966132        	s32i	a3, a1, 0x258
42016370:	942132        	l32i	a3, a1, 0x250
42016373:	962142        	l32i	a4, a1, 0x258
42016376:	10c1f2        	addi	a15, a1, 16
42016379:	334a      	add.n	a3, a3, a4
4201637b:	fcc332        	addi	a3, a3, -4
4201637e:	0358      	l32i.n	a5, a3, 0
42016380:	b066f0        	addx8	a6, a6, a15
42016383:	0659      	s32i.n	a5, a6, 0
42016385:	745050        	extui	a5, a5, 0, 8
42016388:	0008c6        	j	420163af <_vfiprintf_r+0x8ef>
4201638b:	00          	.byte 00
4201638c:	126432        	s32i	a3, a4, 72
4201638f:	052537        	blt	a5, a3, 42016398 <_vfiprintf_r+0x8d8>
42016392:	112432        	l32i	a3, a4, 68
42016395:	000286        	j	420163a3 <_vfiprintf_r+0x8e3>
42016398:	012577        	blt	a5, a7, 4201639d <_vfiprintf_r+0x8dd>
4201639b:	432c      	movi.n	a3, 36
4201639d:	966132        	s32i	a3, a1, 0x258
420163a0:	942132        	l32i	a3, a1, 0x250
420163a3:	962142        	l32i	a4, a1, 0x258
420163a6:	803340        	add	a3, a3, a4
420163a9:	fcc332        	addi	a3, a3, -4
420163ac:	000352        	l8ui	a5, a3, 0
420163af:	235500        	sext	a5, a5, 7
420163b2:	002a06        	j	4201645e <_vfiprintf_r+0x99e>
420163b5:	35bc      	beqz.n	a5, 420163ec <_vfiprintf_r+0x92c>
420163b7:	0aa367        	bge	a3, a6, 420163c5 <_vfiprintf_r+0x905>
420163ba:	10c162        	addi	a6, a1, 16
420163bd:	b03360        	addx8	a3, a3, a6
420163c0:	0358      	l32i.n	a5, a3, 0
420163c2:	000846        	j	420163e7 <_vfiprintf_r+0x927>
420163c5:	10c182        	addi	a8, a1, 16
420163c8:	34a252        	movi	a5, 0x234
420163cb:	585a      	add.n	a5, a8, a5
420163cd:	0159      	s32i.n	a5, a1, 0
420163cf:	01d8f2        	addmi	a15, a8, 0x100
420163d2:	08ed      	mov.n	a14, a8
420163d4:	38a2d2        	movi	a13, 0x238
420163d7:	40a2c2        	movi	a12, 0x240
420163da:	deda      	add.n	a13, a14, a13
420163dc:	ceca      	add.n	a12, a14, a12
420163de:	02bd      	mov.n	a11, a2
420163e0:	03ad      	mov.n	a10, a3
420163e2:	ff1c25        	call8	420155a4 <get_arg$constprop$0>
420163e5:	0a58      	l32i.n	a5, a10, 0
420163e7:	042d      	mov.n	a2, a4
420163e9:	001c46        	j	4201645e <_vfiprintf_r+0x99e>
420163ec:	10c192        	addi	a9, a1, 16
420163ef:	241b      	addi.n	a2, a4, 1
420163f1:	b03390        	addx8	a3, a3, a9
420163f4:	642467        	blt	a4, a6, 4201645c <_vfiprintf_r+0x99c>
420163f7:	10c1a2        	addi	a10, a1, 16
420163fa:	922a72        	l32i	a7, a10, 0x248
420163fd:	f81c      	movi.n	a8, 31
420163ff:	02da42        	addmi	a4, a10, 0x200
42016402:	374b      	addi.n	a3, a7, 4
42016404:	851c      	movi.n	a5, 24
42016406:	322867        	blt	a8, a6, 4201643c <_vfiprintf_r+0x97c>
42016409:	861b      	addi.n	a8, a6, 1
4201640b:	926182        	s32i	a8, a1, 0x248
4201640e:	126432        	s32i	a3, a4, 72
42016411:	072537        	blt	a5, a3, 4201641c <_vfiprintf_r+0x95c>
42016414:	112432        	l32i	a3, a4, 68
42016417:	000306        	j	42016427 <_vfiprintf_r+0x967>
4201641a:	00          	.byte 00
4201641b:	00          	.byte 00
4201641c:	012577        	blt	a5, a7, 42016421 <_vfiprintf_r+0x961>
4201641f:	432c      	movi.n	a3, 36
42016421:	966132        	s32i	a3, a1, 0x258
42016424:	942132        	l32i	a3, a1, 0x250
42016427:	962142        	l32i	a4, a1, 0x258
4201642a:	10c1d2        	addi	a13, a1, 16
4201642d:	334a      	add.n	a3, a3, a4
4201642f:	fcc332        	addi	a3, a3, -4
42016432:	0358      	l32i.n	a5, a3, 0
42016434:	b066d0        	addx8	a6, a6, a13
42016437:	0659      	s32i.n	a5, a6, 0
42016439:	000846        	j	4201645e <_vfiprintf_r+0x99e>
4201643c:	126432        	s32i	a3, a4, 72
4201643f:	052537        	blt	a5, a3, 42016448 <_vfiprintf_r+0x988>
42016442:	112432        	l32i	a3, a4, 68
42016445:	000286        	j	42016453 <_vfiprintf_r+0x993>
42016448:	012577        	blt	a5, a7, 4201644d <_vfiprintf_r+0x98d>
4201644b:	432c      	movi.n	a3, 36
4201644d:	966132        	s32i	a3, a1, 0x258
42016450:	942132        	l32i	a3, a1, 0x250
42016453:	962142        	l32i	a4, a1, 0x258
42016456:	803340        	add	a3, a3, a4
42016459:	fcc332        	addi	a3, a3, -4
4201645c:	0358      	l32i.n	a5, a3, 0
4201645e:	317f50        	srai	a7, a5, 31
42016461:	002796        	bltz	a7, 42016467 <_vfiprintf_r+0x9a7>
42016464:	059606        	j	42017ac0 <_vfiprintf_r+0x2000>
42016467:	605050        	neg	a5, a5
4201646a:	140c      	movi.n	a4, 1
4201646c:	030c      	movi.n	a3, 0
4201646e:	933450        	movnez	a3, a4, a5
42016471:	607070        	neg	a7, a7
42016474:	c07730        	sub	a7, a7, a3
42016477:	d32c      	movi.n	a3, 45
42016479:	041046        	j	420174be <_vfiprintf_r+0x19fe>
4201647c:	972182        	l32i	a8, a1, 0x25c
4201647f:	922162        	l32i	a6, a1, 0x248
42016482:	02e857        	bbsi	a8, 5, 42016488 <_vfiprintf_r+0x9c8>
42016485:	002ec6        	j	42016544 <_vfiprintf_r+0xa84>
42016488:	45bc      	beqz.n	a5, 420164c0 <_vfiprintf_r+0xa00>
4201648a:	0aa367        	bge	a3, a6, 42016498 <_vfiprintf_r+0x9d8>
4201648d:	10c192        	addi	a9, a1, 16
42016490:	b03390        	addx8	a3, a3, a9
42016493:	0328      	l32i.n	a2, a3, 0
42016495:	000846        	j	420164ba <_vfiprintf_r+0x9fa>
42016498:	10c1a2        	addi	a10, a1, 16
4201649b:	34a252        	movi	a5, 0x234
4201649e:	5a5a      	add.n	a5, a10, a5
420164a0:	38a2d2        	movi	a13, 0x238
420164a3:	40a2c2        	movi	a12, 0x240
420164a6:	01daf2        	addmi	a15, a10, 0x100
420164a9:	0aed      	mov.n	a14, a10
420164ab:	dada      	add.n	a13, a10, a13
420164ad:	caca      	add.n	a12, a10, a12
420164af:	02bd      	mov.n	a11, a2
420164b1:	0159      	s32i.n	a5, a1, 0
420164b3:	03ad      	mov.n	a10, a3
420164b5:	ff0ee5        	call8	420155a4 <get_arg$constprop$0>
420164b8:	0a28      	l32i.n	a2, a10, 0
420164ba:	045d      	mov.n	a5, a4
420164bc:	001d46        	j	42016535 <_vfiprintf_r+0xa75>
420164bf:	00          	.byte 00
420164c0:	541b      	addi.n	a5, a4, 1
420164c2:	0aa467        	bge	a4, a6, 420164d0 <_vfiprintf_r+0xa10>
420164c5:	10c1c2        	addi	a12, a1, 16
420164c8:	b033c0        	addx8	a3, a3, a12
420164cb:	0328      	l32i.n	a2, a3, 0
420164cd:	001906        	j	42016535 <_vfiprintf_r+0xa75>
420164d0:	10c1d2        	addi	a13, a1, 16
420164d3:	922d72        	l32i	a7, a13, 0x248
420164d6:	f81c      	movi.n	a8, 31
420164d8:	02dd32        	addmi	a3, a13, 0x200
420164db:	274b      	addi.n	a2, a7, 4
420164dd:	841c      	movi.n	a4, 24
420164df:	312867        	blt	a8, a6, 42016514 <_vfiprintf_r+0xa54>
420164e2:	861b      	addi.n	a8, a6, 1
420164e4:	926182        	s32i	a8, a1, 0x248
420164e7:	126322        	s32i	a2, a3, 72
420164ea:	062427        	blt	a4, a2, 420164f4 <_vfiprintf_r+0xa34>
420164ed:	112322        	l32i	a2, a3, 68
420164f0:	0002c6        	j	420164ff <_vfiprintf_r+0xa3f>
420164f3:	00          	.byte 00
420164f4:	012477        	blt	a4, a7, 420164f9 <_vfiprintf_r+0xa39>
420164f7:	422c      	movi.n	a2, 36
420164f9:	966122        	s32i	a2, a1, 0x258
420164fc:	942122        	l32i	a2, a1, 0x250
420164ff:	962132        	l32i	a3, a1, 0x258
42016502:	10c1f2        	addi	a15, a1, 16
42016505:	223a      	add.n	a2, a2, a3
42016507:	fcc222        	addi	a2, a2, -4
4201650a:	0228      	l32i.n	a2, a2, 0
4201650c:	b066f0        	addx8	a6, a6, a15
4201650f:	0629      	s32i.n	a2, a6, 0
42016511:	000806        	j	42016535 <_vfiprintf_r+0xa75>
42016514:	126322        	s32i	a2, a3, 72
42016517:	052427        	blt	a4, a2, 42016520 <_vfiprintf_r+0xa60>
4201651a:	112322        	l32i	a2, a3, 68
4201651d:	000286        	j	4201652b <_vfiprintf_r+0xa6b>
42016520:	012477        	blt	a4, a7, 42016525 <_vfiprintf_r+0xa65>
42016523:	422c      	movi.n	a2, 36
42016525:	966122        	s32i	a2, a1, 0x258
42016528:	942122        	l32i	a2, a1, 0x250
4201652b:	962132        	l32i	a3, a1, 0x258
4201652e:	223a      	add.n	a2, a2, a3
42016530:	fcc222        	addi	a2, a2, -4
42016533:	0228      	l32i.n	a2, a2, 0
42016535:	9e2162        	l32i	a6, a1, 0x278
42016538:	313f60        	srai	a3, a6, 31
4201653b:	0269      	s32i.n	a6, a2, 0
4201653d:	1239      	s32i.n	a3, a2, 4
4201653f:	00bcc6        	j	42016836 <_vfiprintf_r+0xd76>
42016542:	00          	.byte 00
42016543:	00          	.byte 00
42016544:	972182        	l32i	a8, a1, 0x25c
42016547:	02e847        	bbsi	a8, 4, 4201654d <_vfiprintf_r+0xa8d>
4201654a:	002cc6        	j	42016601 <_vfiprintf_r+0xb41>
4201654d:	35bc      	beqz.n	a5, 42016584 <_vfiprintf_r+0xac4>
4201654f:	0aa367        	bge	a3, a6, 4201655d <_vfiprintf_r+0xa9d>
42016552:	10c192        	addi	a9, a1, 16
42016555:	b03390        	addx8	a3, a3, a9
42016558:	0328      	l32i.n	a2, a3, 0
4201655a:	000846        	j	4201657f <_vfiprintf_r+0xabf>
4201655d:	10c1a2        	addi	a10, a1, 16
42016560:	34a252        	movi	a5, 0x234
42016563:	5a5a      	add.n	a5, a10, a5
42016565:	38a2d2        	movi	a13, 0x238
42016568:	40a2c2        	movi	a12, 0x240
4201656b:	01daf2        	addmi	a15, a10, 0x100
4201656e:	0aed      	mov.n	a14, a10
42016570:	dada      	add.n	a13, a10, a13
42016572:	caca      	add.n	a12, a10, a12
42016574:	02bd      	mov.n	a11, a2
42016576:	0159      	s32i.n	a5, a1, 0
42016578:	03ad      	mov.n	a10, a3
4201657a:	ff02a5        	call8	420155a4 <get_arg$constprop$0>
4201657d:	0a28      	l32i.n	a2, a10, 0
4201657f:	045d      	mov.n	a5, a4
42016581:	001d06        	j	420165f9 <_vfiprintf_r+0xb39>
42016584:	541b      	addi.n	a5, a4, 1
42016586:	0aa467        	bge	a4, a6, 42016594 <_vfiprintf_r+0xad4>
42016589:	10c1c2        	addi	a12, a1, 16
4201658c:	b033c0        	addx8	a3, a3, a12
4201658f:	0328      	l32i.n	a2, a3, 0
42016591:	001906        	j	420165f9 <_vfiprintf_r+0xb39>
42016594:	10c1d2        	addi	a13, a1, 16
42016597:	922d72        	l32i	a7, a13, 0x248
4201659a:	f81c      	movi.n	a8, 31
4201659c:	02dd32        	addmi	a3, a13, 0x200
4201659f:	274b      	addi.n	a2, a7, 4
420165a1:	841c      	movi.n	a4, 24
420165a3:	312867        	blt	a8, a6, 420165d8 <_vfiprintf_r+0xb18>
420165a6:	861b      	addi.n	a8, a6, 1
420165a8:	926182        	s32i	a8, a1, 0x248
420165ab:	126322        	s32i	a2, a3, 72
420165ae:	062427        	blt	a4, a2, 420165b8 <_vfiprintf_r+0xaf8>
420165b1:	112322        	l32i	a2, a3, 68
420165b4:	0002c6        	j	420165c3 <_vfiprintf_r+0xb03>
420165b7:	00          	.byte 00
420165b8:	012477        	blt	a4, a7, 420165bd <_vfiprintf_r+0xafd>
420165bb:	422c      	movi.n	a2, 36
420165bd:	966122        	s32i	a2, a1, 0x258
420165c0:	942122        	l32i	a2, a1, 0x250
420165c3:	962132        	l32i	a3, a1, 0x258
420165c6:	10c1f2        	addi	a15, a1, 16
420165c9:	223a      	add.n	a2, a2, a3
420165cb:	fcc222        	addi	a2, a2, -4
420165ce:	0228      	l32i.n	a2, a2, 0
420165d0:	b066f0        	addx8	a6, a6, a15
420165d3:	0629      	s32i.n	a2, a6, 0
420165d5:	000806        	j	420165f9 <_vfiprintf_r+0xb39>
420165d8:	126322        	s32i	a2, a3, 72
420165db:	052427        	blt	a4, a2, 420165e4 <_vfiprintf_r+0xb24>
420165de:	112322        	l32i	a2, a3, 68
420165e1:	000286        	j	420165ef <_vfiprintf_r+0xb2f>
420165e4:	012477        	blt	a4, a7, 420165e9 <_vfiprintf_r+0xb29>
420165e7:	422c      	movi.n	a2, 36
420165e9:	966122        	s32i	a2, a1, 0x258
420165ec:	942122        	l32i	a2, a1, 0x250
420165ef:	962132        	l32i	a3, a1, 0x258
420165f2:	223a      	add.n	a2, a2, a3
420165f4:	fcc222        	addi	a2, a2, -4
420165f7:	0228      	l32i.n	a2, a2, 0
420165f9:	9e2162        	l32i	a6, a1, 0x278
420165fc:	0269      	s32i.n	a6, a2, 0
420165fe:	008d06        	j	42016836 <_vfiprintf_r+0xd76>
42016601:	972182        	l32i	a8, a1, 0x25c
42016604:	02e867        	bbsi	a8, 6, 4201660a <_vfiprintf_r+0xb4a>
42016607:	002e46        	j	420166c4 <_vfiprintf_r+0xc04>
4201660a:	55bc      	beqz.n	a5, 42016643 <_vfiprintf_r+0xb83>
4201660c:	0ca367        	bge	a3, a6, 4201661c <_vfiprintf_r+0xb5c>
4201660f:	10c192        	addi	a9, a1, 16
42016612:	b03390        	addx8	a3, a3, a9
42016615:	0328      	l32i.n	a2, a3, 0
42016617:	0008c6        	j	4201663e <_vfiprintf_r+0xb7e>
4201661a:	00          	.byte 00
4201661b:	00          	.byte 00
4201661c:	10c1a2        	addi	a10, a1, 16
4201661f:	34a252        	movi	a5, 0x234
42016622:	5a5a      	add.n	a5, a10, a5
42016624:	38a2d2        	movi	a13, 0x238
42016627:	40a2c2        	movi	a12, 0x240
4201662a:	01daf2        	addmi	a15, a10, 0x100
4201662d:	0aed      	mov.n	a14, a10
4201662f:	dada      	add.n	a13, a10, a13
42016631:	caca      	add.n	a12, a10, a12
42016633:	02bd      	mov.n	a11, a2
42016635:	0159      	s32i.n	a5, a1, 0
42016637:	03ad      	mov.n	a10, a3
42016639:	fef6a5        	call8	420155a4 <get_arg$constprop$0>
4201663c:	0a28      	l32i.n	a2, a10, 0
4201663e:	045d      	mov.n	a5, a4
42016640:	001d46        	j	420166b9 <_vfiprintf_r+0xbf9>
42016643:	541b      	addi.n	a5, a4, 1
42016645:	0ba467        	bge	a4, a6, 42016654 <_vfiprintf_r+0xb94>
42016648:	10c1c2        	addi	a12, a1, 16
4201664b:	b033c0        	addx8	a3, a3, a12
4201664e:	0328      	l32i.n	a2, a3, 0
42016650:	001946        	j	420166b9 <_vfiprintf_r+0xbf9>
42016653:	00          	.byte 00
42016654:	10c1d2        	addi	a13, a1, 16
42016657:	922d72        	l32i	a7, a13, 0x248
4201665a:	f81c      	movi.n	a8, 31
4201665c:	02dd32        	addmi	a3, a13, 0x200
4201665f:	274b      	addi.n	a2, a7, 4
42016661:	841c      	movi.n	a4, 24
42016663:	312867        	blt	a8, a6, 42016698 <_vfiprintf_r+0xbd8>
42016666:	861b      	addi.n	a8, a6, 1
42016668:	926182        	s32i	a8, a1, 0x248
4201666b:	126322        	s32i	a2, a3, 72
4201666e:	062427        	blt	a4, a2, 42016678 <_vfiprintf_r+0xbb8>
42016671:	112322        	l32i	a2, a3, 68
42016674:	0002c6        	j	42016683 <_vfiprintf_r+0xbc3>
42016677:	00          	.byte 00
42016678:	012477        	blt	a4, a7, 4201667d <_vfiprintf_r+0xbbd>
4201667b:	422c      	movi.n	a2, 36
4201667d:	966122        	s32i	a2, a1, 0x258
42016680:	942122        	l32i	a2, a1, 0x250
42016683:	962132        	l32i	a3, a1, 0x258
42016686:	10c1f2        	addi	a15, a1, 16
42016689:	223a      	add.n	a2, a2, a3
4201668b:	fcc222        	addi	a2, a2, -4
4201668e:	0228      	l32i.n	a2, a2, 0
42016690:	b066f0        	addx8	a6, a6, a15
42016693:	0629      	s32i.n	a2, a6, 0
42016695:	000806        	j	420166b9 <_vfiprintf_r+0xbf9>
42016698:	126322        	s32i	a2, a3, 72
4201669b:	052427        	blt	a4, a2, 420166a4 <_vfiprintf_r+0xbe4>
4201669e:	112322        	l32i	a2, a3, 68
420166a1:	000286        	j	420166af <_vfiprintf_r+0xbef>
420166a4:	012477        	blt	a4, a7, 420166a9 <_vfiprintf_r+0xbe9>
420166a7:	422c      	movi.n	a2, 36
420166a9:	966122        	s32i	a2, a1, 0x258
420166ac:	942122        	l32i	a2, a1, 0x250
420166af:	962132        	l32i	a3, a1, 0x258
420166b2:	223a      	add.n	a2, a2, a3
420166b4:	fcc222        	addi	a2, a2, -4
420166b7:	0228      	l32i.n	a2, a2, 0
420166b9:	9e2162        	l32i	a6, a1, 0x278
420166bc:	005262        	s16i	a6, a2, 0
420166bf:	005cc6        	j	42016836 <_vfiprintf_r+0xd76>
420166c2:	00          	.byte 00
420166c3:	00          	.byte 00
420166c4:	972182        	l32i	a8, a1, 0x25c
420166c7:	02e897        	bbsi	a8, 9, 420166cd <_vfiprintf_r+0xc0d>
420166ca:	002d06        	j	42016782 <_vfiprintf_r+0xcc2>
420166cd:	35bc      	beqz.n	a5, 42016704 <_vfiprintf_r+0xc44>
420166cf:	0aa367        	bge	a3, a6, 420166dd <_vfiprintf_r+0xc1d>
420166d2:	10c192        	addi	a9, a1, 16
420166d5:	b03390        	addx8	a3, a3, a9
420166d8:	0328      	l32i.n	a2, a3, 0
420166da:	000846        	j	420166ff <_vfiprintf_r+0xc3f>
420166dd:	10c1a2        	addi	a10, a1, 16
420166e0:	34a252        	movi	a5, 0x234
420166e3:	5a5a      	add.n	a5, a10, a5
420166e5:	38a2d2        	movi	a13, 0x238
420166e8:	40a2c2        	movi	a12, 0x240
420166eb:	01daf2        	addmi	a15, a10, 0x100
420166ee:	0aed      	mov.n	a14, a10
420166f0:	dada      	add.n	a13, a10, a13
420166f2:	caca      	add.n	a12, a10, a12
420166f4:	02bd      	mov.n	a11, a2
420166f6:	0159      	s32i.n	a5, a1, 0
420166f8:	03ad      	mov.n	a10, a3
420166fa:	feeaa5        	call8	420155a4 <get_arg$constprop$0>
420166fd:	0a28      	l32i.n	a2, a10, 0
420166ff:	045d      	mov.n	a5, a4
42016701:	001d06        	j	42016779 <_vfiprintf_r+0xcb9>
42016704:	541b      	addi.n	a5, a4, 1
42016706:	0aa467        	bge	a4, a6, 42016714 <_vfiprintf_r+0xc54>
42016709:	10c1c2        	addi	a12, a1, 16
4201670c:	b033c0        	addx8	a3, a3, a12
4201670f:	0328      	l32i.n	a2, a3, 0
42016711:	001906        	j	42016779 <_vfiprintf_r+0xcb9>
42016714:	10c1d2        	addi	a13, a1, 16
42016717:	922d72        	l32i	a7, a13, 0x248
4201671a:	f81c      	movi.n	a8, 31
4201671c:	02dd32        	addmi	a3, a13, 0x200
4201671f:	274b      	addi.n	a2, a7, 4
42016721:	841c      	movi.n	a4, 24
42016723:	312867        	blt	a8, a6, 42016758 <_vfiprintf_r+0xc98>
42016726:	861b      	addi.n	a8, a6, 1
42016728:	926182        	s32i	a8, a1, 0x248
4201672b:	126322        	s32i	a2, a3, 72
4201672e:	062427        	blt	a4, a2, 42016738 <_vfiprintf_r+0xc78>
42016731:	112322        	l32i	a2, a3, 68
42016734:	0002c6        	j	42016743 <_vfiprintf_r+0xc83>
42016737:	00          	.byte 00
42016738:	012477        	blt	a4, a7, 4201673d <_vfiprintf_r+0xc7d>
4201673b:	422c      	movi.n	a2, 36
4201673d:	966122        	s32i	a2, a1, 0x258
42016740:	942122        	l32i	a2, a1, 0x250
42016743:	962132        	l32i	a3, a1, 0x258
42016746:	10c1f2        	addi	a15, a1, 16
42016749:	223a      	add.n	a2, a2, a3
4201674b:	fcc222        	addi	a2, a2, -4
4201674e:	0228      	l32i.n	a2, a2, 0
42016750:	b066f0        	addx8	a6, a6, a15
42016753:	0629      	s32i.n	a2, a6, 0
42016755:	000806        	j	42016779 <_vfiprintf_r+0xcb9>
42016758:	126322        	s32i	a2, a3, 72
4201675b:	052427        	blt	a4, a2, 42016764 <_vfiprintf_r+0xca4>
4201675e:	112322        	l32i	a2, a3, 68
42016761:	000286        	j	4201676f <_vfiprintf_r+0xcaf>
42016764:	012477        	blt	a4, a7, 42016769 <_vfiprintf_r+0xca9>
42016767:	422c      	movi.n	a2, 36
42016769:	966122        	s32i	a2, a1, 0x258
4201676c:	942122        	l32i	a2, a1, 0x250
4201676f:	962132        	l32i	a3, a1, 0x258
42016772:	223a      	add.n	a2, a2, a3
42016774:	fcc222        	addi	a2, a2, -4
42016777:	0228      	l32i.n	a2, a2, 0
42016779:	9e2162        	l32i	a6, a1, 0x278
4201677c:	004262        	s8i	a6, a2, 0
4201677f:	002cc6        	j	42016836 <_vfiprintf_r+0xd76>
42016782:	65bc      	beqz.n	a5, 420167bc <_vfiprintf_r+0xcfc>
42016784:	0ca367        	bge	a3, a6, 42016794 <_vfiprintf_r+0xcd4>
42016787:	10c182        	addi	a8, a1, 16
4201678a:	b03380        	addx8	a3, a3, a8
4201678d:	0328      	l32i.n	a2, a3, 0
4201678f:	0008c6        	j	420167b6 <_vfiprintf_r+0xcf6>
42016792:	00          	.byte 00
42016793:	00          	.byte 00
42016794:	10c192        	addi	a9, a1, 16
42016797:	34a252        	movi	a5, 0x234
4201679a:	595a      	add.n	a5, a9, a5
4201679c:	38a2d2        	movi	a13, 0x238
4201679f:	40a2c2        	movi	a12, 0x240
420167a2:	02bd      	mov.n	a11, a2
420167a4:	0159      	s32i.n	a5, a1, 0
420167a6:	01d9f2        	addmi	a15, a9, 0x100
420167a9:	09ed      	mov.n	a14, a9
420167ab:	d9da      	add.n	a13, a9, a13
420167ad:	c9ca      	add.n	a12, a9, a12
420167af:	03ad      	mov.n	a10, a3
420167b1:	fedf25        	call8	420155a4 <get_arg$constprop$0>
420167b4:	0a28      	l32i.n	a2, a10, 0
420167b6:	045d      	mov.n	a5, a4
420167b8:	001d46        	j	42016831 <_vfiprintf_r+0xd71>
420167bb:	00          	.byte 00
420167bc:	541b      	addi.n	a5, a4, 1
420167be:	0aa467        	bge	a4, a6, 420167cc <_vfiprintf_r+0xd0c>
420167c1:	10c1a2        	addi	a10, a1, 16
420167c4:	b033a0        	addx8	a3, a3, a10
420167c7:	0328      	l32i.n	a2, a3, 0
420167c9:	001906        	j	42016831 <_vfiprintf_r+0xd71>
420167cc:	10c1c2        	addi	a12, a1, 16
420167cf:	922c72        	l32i	a7, a12, 0x248
420167d2:	f81c      	movi.n	a8, 31
420167d4:	02dc32        	addmi	a3, a12, 0x200
420167d7:	274b      	addi.n	a2, a7, 4
420167d9:	841c      	movi.n	a4, 24
420167db:	312867        	blt	a8, a6, 42016810 <_vfiprintf_r+0xd50>
420167de:	861b      	addi.n	a8, a6, 1
420167e0:	926182        	s32i	a8, a1, 0x248
420167e3:	126322        	s32i	a2, a3, 72
420167e6:	062427        	blt	a4, a2, 420167f0 <_vfiprintf_r+0xd30>
420167e9:	112322        	l32i	a2, a3, 68
420167ec:	0002c6        	j	420167fb <_vfiprintf_r+0xd3b>
420167ef:	00          	.byte 00
420167f0:	012477        	blt	a4, a7, 420167f5 <_vfiprintf_r+0xd35>
420167f3:	422c      	movi.n	a2, 36
420167f5:	966122        	s32i	a2, a1, 0x258
420167f8:	942122        	l32i	a2, a1, 0x250
420167fb:	962132        	l32i	a3, a1, 0x258
420167fe:	10c1e2        	addi	a14, a1, 16
42016801:	223a      	add.n	a2, a2, a3
42016803:	fcc222        	addi	a2, a2, -4
42016806:	0228      	l32i.n	a2, a2, 0
42016808:	b066e0        	addx8	a6, a6, a14
4201680b:	0629      	s32i.n	a2, a6, 0
4201680d:	000806        	j	42016831 <_vfiprintf_r+0xd71>
42016810:	126322        	s32i	a2, a3, 72
42016813:	052427        	blt	a4, a2, 4201681c <_vfiprintf_r+0xd5c>
42016816:	112322        	l32i	a2, a3, 68
42016819:	000286        	j	42016827 <_vfiprintf_r+0xd67>
4201681c:	012477        	blt	a4, a7, 42016821 <_vfiprintf_r+0xd61>
4201681f:	422c      	movi.n	a2, 36
42016821:	966122        	s32i	a2, a1, 0x258
42016824:	942122        	l32i	a2, a1, 0x250
42016827:	962132        	l32i	a3, a1, 0x258
4201682a:	223a      	add.n	a2, a2, a3
4201682c:	fcc222        	addi	a2, a2, -4
4201682f:	0228      	l32i.n	a2, a2, 0
42016831:	9e2132        	l32i	a3, a1, 0x278
42016834:	0239      	s32i.n	a3, a2, 0
42016836:	054d      	mov.n	a4, a5
42016838:	fcfc46        	j	42015c2d <_vfiprintf_r+0x16d>
4201683b:	972182        	l32i	a8, a1, 0x25c
4201683e:	061c      	movi.n	a6, 16
42016840:	208860        	or	a8, a8, a6
42016843:	976182        	s32i	a8, a1, 0x25c
42016846:	972192        	l32i	a9, a1, 0x25c
42016849:	922162        	l32i	a6, a1, 0x248
4201684c:	02e957        	bbsi	a9, 5, 42016852 <_vfiprintf_r+0xd92>
4201684f:	002f46        	j	42016910 <_vfiprintf_r+0xe50>
42016852:	75bc      	beqz.n	a5, 4201688d <_vfiprintf_r+0xdcd>
42016854:	0ca367        	bge	a3, a6, 42016864 <_vfiprintf_r+0xda4>
42016857:	10c1a2        	addi	a10, a1, 16
4201685a:	b033a0        	addx8	a3, a3, a10
4201685d:	0358      	l32i.n	a5, a3, 0
4201685f:	1378      	l32i.n	a7, a3, 4
42016861:	0008c6        	j	42016888 <_vfiprintf_r+0xdc8>
42016864:	10c1c2        	addi	a12, a1, 16
42016867:	34a252        	movi	a5, 0x234
4201686a:	38a2d2        	movi	a13, 0x238
4201686d:	5c5a      	add.n	a5, a12, a5
4201686f:	0ced      	mov.n	a14, a12
42016871:	01dcf2        	addmi	a15, a12, 0x100
42016874:	dcda      	add.n	a13, a12, a13
42016876:	40a2c2        	movi	a12, 0x240
42016879:	0159      	s32i.n	a5, a1, 0
4201687b:	ceca      	add.n	a12, a14, a12
4201687d:	02bd      	mov.n	a11, a2
4201687f:	03ad      	mov.n	a10, a3
42016881:	fed225        	call8	420155a4 <get_arg$constprop$0>
42016884:	0a58      	l32i.n	a5, a10, 0
42016886:	1a78      	l32i.n	a7, a10, 4
42016888:	042d      	mov.n	a2, a4
4201688a:	00ca86        	j	42016bb8 <_vfiprintf_r+0x10f8>
4201688d:	10c1d2        	addi	a13, a1, 16
42016890:	241b      	addi.n	a2, a4, 1
42016892:	b033d0        	addx8	a3, a3, a13
42016895:	6f2467        	blt	a4, a6, 42016908 <_vfiprintf_r+0xe48>
42016898:	10c1e2        	addi	a14, a1, 16
4201689b:	922e42        	l32i	a4, a14, 0x248
4201689e:	837c      	movi.n	a3, -8
420168a0:	447b      	addi.n	a4, a4, 7
420168a2:	104430        	and	a4, a4, a3
420168a5:	f81c      	movi.n	a8, 31
420168a7:	02de52        	addmi	a5, a14, 0x200
420168aa:	348b      	addi.n	a3, a4, 8
420168ac:	871c      	movi.n	a7, 24
420168ae:	362867        	blt	a8, a6, 420168e8 <_vfiprintf_r+0xe28>
420168b1:	861b      	addi.n	a8, a6, 1
420168b3:	926182        	s32i	a8, a1, 0x248
420168b6:	126532        	s32i	a3, a5, 72
420168b9:	052737        	blt	a7, a3, 420168c2 <_vfiprintf_r+0xe02>
420168bc:	112532        	l32i	a3, a5, 68
420168bf:	0002c6        	j	420168ce <_vfiprintf_r+0xe0e>
420168c2:	022747        	blt	a7, a4, 420168c8 <_vfiprintf_r+0xe08>
420168c5:	28a032        	movi	a3, 40
420168c8:	966132        	s32i	a3, a1, 0x258
420168cb:	942132        	l32i	a3, a1, 0x250
420168ce:	962142        	l32i	a4, a1, 0x258
420168d1:	334a      	add.n	a3, a3, a4
420168d3:	f8c332        	addi	a3, a3, -8
420168d6:	0358      	l32i.n	a5, a3, 0
420168d8:	1378      	l32i.n	a7, a3, 4
420168da:	10c132        	addi	a3, a1, 16
420168dd:	b06630        	addx8	a6, a6, a3
420168e0:	0659      	s32i.n	a5, a6, 0
420168e2:	1679      	s32i.n	a7, a6, 4
420168e4:	00b406        	j	42016bb8 <_vfiprintf_r+0x10f8>
420168e7:	00          	.byte 00
420168e8:	126532        	s32i	a3, a5, 72
420168eb:	052737        	blt	a7, a3, 420168f4 <_vfiprintf_r+0xe34>
420168ee:	112532        	l32i	a3, a5, 68
420168f1:	000286        	j	420168ff <_vfiprintf_r+0xe3f>
420168f4:	012747        	blt	a7, a4, 420168f9 <_vfiprintf_r+0xe39>
420168f7:	832c      	movi.n	a3, 40
420168f9:	966132        	s32i	a3, a1, 0x258
420168fc:	942132        	l32i	a3, a1, 0x250
420168ff:	962142        	l32i	a4, a1, 0x258
42016902:	803340        	add	a3, a3, a4
42016905:	f8c332        	addi	a3, a3, -8
42016908:	0358      	l32i.n	a5, a3, 0
4201690a:	1378      	l32i.n	a7, a3, 4
4201690c:	00aa06        	j	42016bb8 <_vfiprintf_r+0x10f8>
4201690f:	00          	.byte 00
42016910:	972182        	l32i	a8, a1, 0x25c
42016913:	756847        	bbci	a8, 4, 4201698c <_vfiprintf_r+0xecc>
42016916:	e59c      	beqz.n	a5, 42016938 <_vfiprintf_r+0xe78>
42016918:	08a367        	bge	a3, a6, 42016924 <_vfiprintf_r+0xe64>
4201691b:	10c192        	addi	a9, a1, 16
4201691e:	b03390        	addx8	a3, a3, a9
42016921:	007c06        	j	42016b15 <_vfiprintf_r+0x1055>
42016924:	10c1a2        	addi	a10, a1, 16
42016927:	34a252        	movi	a5, 0x234
4201692a:	5a5a      	add.n	a5, a10, a5
4201692c:	0159      	s32i.n	a5, a1, 0
4201692e:	01daf2        	addmi	a15, a10, 0x100
42016931:	0aed      	mov.n	a14, a10
42016933:	007d06        	j	42016b2b <_vfiprintf_r+0x106b>
42016936:	00          	.byte 00
42016937:	00          	.byte 00
42016938:	10c1c2        	addi	a12, a1, 16
4201693b:	241b      	addi.n	a2, a4, 1
4201693d:	b033c0        	addx8	a3, a3, a12
42016940:	02a467        	bge	a4, a6, 42016946 <_vfiprintf_r+0xe86>
42016943:	009b46        	j	42016bb4 <_vfiprintf_r+0x10f4>
42016946:	10c1d2        	addi	a13, a1, 16
42016949:	922d72        	l32i	a7, a13, 0x248
4201694c:	f81c      	movi.n	a8, 31
4201694e:	02dd42        	addmi	a4, a13, 0x200
42016951:	374b      	addi.n	a3, a7, 4
42016953:	851c      	movi.n	a5, 24
42016955:	02a867        	bge	a8, a6, 4201695b <_vfiprintf_r+0xe9b>
42016958:	008e06        	j	42016b94 <_vfiprintf_r+0x10d4>
4201695b:	861b      	addi.n	a8, a6, 1
4201695d:	926182        	s32i	a8, a1, 0x248
42016960:	126432        	s32i	a3, a4, 72
42016963:	052537        	blt	a5, a3, 4201696c <_vfiprintf_r+0xeac>
42016966:	112432        	l32i	a3, a4, 68
42016969:	000286        	j	42016977 <_vfiprintf_r+0xeb7>
4201696c:	012577        	blt	a5, a7, 42016971 <_vfiprintf_r+0xeb1>
4201696f:	432c      	movi.n	a3, 36
42016971:	966132        	s32i	a3, a1, 0x258
42016974:	942132        	l32i	a3, a1, 0x250
42016977:	962142        	l32i	a4, a1, 0x258
4201697a:	10c1f2        	addi	a15, a1, 16
4201697d:	334a      	add.n	a3, a3, a4
4201697f:	fcc332        	addi	a3, a3, -4
42016982:	0358      	l32i.n	a5, a3, 0
42016984:	b066f0        	addx8	a6, a6, a15
42016987:	0080c6        	j	42016b8e <_vfiprintf_r+0x10ce>
4201698a:	00          	.byte 00
4201698b:	00          	.byte 00
4201698c:	972182        	l32i	a8, a1, 0x25c
4201698f:	02e867        	bbsi	a8, 6, 42016995 <_vfiprintf_r+0xed5>
42016992:	002d86        	j	42016a4c <_vfiprintf_r+0xf8c>
42016995:	75bc      	beqz.n	a5, 420169d0 <_vfiprintf_r+0xf10>
42016997:	0da367        	bge	a3, a6, 420169a8 <_vfiprintf_r+0xee8>
4201699a:	10c192        	addi	a9, a1, 16
4201699d:	b03390        	addx8	a3, a3, a9
420169a0:	001352        	l16ui	a5, a3, 0
420169a3:	0065c6        	j	42016b3e <_vfiprintf_r+0x107e>
420169a6:	00          	.byte 00
420169a7:	00          	.byte 00
420169a8:	10c1a2        	addi	a10, a1, 16
420169ab:	34a252        	movi	a5, 0x234
420169ae:	5a5a      	add.n	a5, a10, a5
420169b0:	38a2d2        	movi	a13, 0x238
420169b3:	40a2c2        	movi	a12, 0x240
420169b6:	0159      	s32i.n	a5, a1, 0
420169b8:	01daf2        	addmi	a15, a10, 0x100
420169bb:	0aed      	mov.n	a14, a10
420169bd:	dada      	add.n	a13, a10, a13
420169bf:	caca      	add.n	a12, a10, a12
420169c1:	02bd      	mov.n	a11, a2
420169c3:	03ad      	mov.n	a10, a3
420169c5:	febde5        	call8	420155a4 <get_arg$constprop$0>
420169c8:	001a52        	l16ui	a5, a10, 0
420169cb:	005bc6        	j	42016b3e <_vfiprintf_r+0x107e>
420169ce:	00          	.byte 00
420169cf:	00          	.byte 00
420169d0:	10c1c2        	addi	a12, a1, 16
420169d3:	241b      	addi.n	a2, a4, 1
420169d5:	b033c0        	addx8	a3, a3, a12
420169d8:	682467        	blt	a4, a6, 42016a44 <_vfiprintf_r+0xf84>
420169db:	10c1d2        	addi	a13, a1, 16
420169de:	922d72        	l32i	a7, a13, 0x248
420169e1:	f81c      	movi.n	a8, 31
420169e3:	02dd42        	addmi	a4, a13, 0x200
420169e6:	374b      	addi.n	a3, a7, 4
420169e8:	851c      	movi.n	a5, 24
420169ea:	352867        	blt	a8, a6, 42016a23 <_vfiprintf_r+0xf63>
420169ed:	861b      	addi.n	a8, a6, 1
420169ef:	926182        	s32i	a8, a1, 0x248
420169f2:	126432        	s32i	a3, a4, 72
420169f5:	072537        	blt	a5, a3, 42016a00 <_vfiprintf_r+0xf40>
420169f8:	112432        	l32i	a3, a4, 68
420169fb:	000306        	j	42016a0b <_vfiprintf_r+0xf4b>
420169fe:	00          	.byte 00
420169ff:	00          	.byte 00
42016a00:	012577        	blt	a5, a7, 42016a05 <_vfiprintf_r+0xf45>
42016a03:	432c      	movi.n	a3, 36
42016a05:	966132        	s32i	a3, a1, 0x258
42016a08:	942132        	l32i	a3, a1, 0x250
42016a0b:	962142        	l32i	a4, a1, 0x258
42016a0e:	10c1f2        	addi	a15, a1, 16
42016a11:	334a      	add.n	a3, a3, a4
42016a13:	fcc332        	addi	a3, a3, -4
42016a16:	0358      	l32i.n	a5, a3, 0
42016a18:	b066f0        	addx8	a6, a6, a15
42016a1b:	0659      	s32i.n	a5, a6, 0
42016a1d:	f45050        	extui	a5, a5, 0, 16
42016a20:	006486        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016a23:	126432        	s32i	a3, a4, 72
42016a26:	062537        	blt	a5, a3, 42016a30 <_vfiprintf_r+0xf70>
42016a29:	112432        	l32i	a3, a4, 68
42016a2c:	0002c6        	j	42016a3b <_vfiprintf_r+0xf7b>
42016a2f:	00          	.byte 00
42016a30:	012577        	blt	a5, a7, 42016a35 <_vfiprintf_r+0xf75>
42016a33:	432c      	movi.n	a3, 36
42016a35:	966132        	s32i	a3, a1, 0x258
42016a38:	942132        	l32i	a3, a1, 0x250
42016a3b:	962142        	l32i	a4, a1, 0x258
42016a3e:	803340        	add	a3, a3, a4
42016a41:	fcc332        	addi	a3, a3, -4
42016a44:	001352        	l16ui	a5, a3, 0
42016a47:	005ac6        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016a4a:	00          	.byte 00
42016a4b:	00          	.byte 00
42016a4c:	972182        	l32i	a8, a1, 0x25c
42016a4f:	02e897        	bbsi	a8, 9, 42016a55 <_vfiprintf_r+0xf95>
42016a52:	002d06        	j	42016b0a <_vfiprintf_r+0x104a>
42016a55:	75bc      	beqz.n	a5, 42016a90 <_vfiprintf_r+0xfd0>
42016a57:	0da367        	bge	a3, a6, 42016a68 <_vfiprintf_r+0xfa8>
42016a5a:	10c192        	addi	a9, a1, 16
42016a5d:	b03390        	addx8	a3, a3, a9
42016a60:	000352        	l8ui	a5, a3, 0
42016a63:	0035c6        	j	42016b3e <_vfiprintf_r+0x107e>
42016a66:	00          	.byte 00
42016a67:	00          	.byte 00
42016a68:	10c1a2        	addi	a10, a1, 16
42016a6b:	34a252        	movi	a5, 0x234
42016a6e:	5a5a      	add.n	a5, a10, a5
42016a70:	38a2d2        	movi	a13, 0x238
42016a73:	40a2c2        	movi	a12, 0x240
42016a76:	0159      	s32i.n	a5, a1, 0
42016a78:	01daf2        	addmi	a15, a10, 0x100
42016a7b:	0aed      	mov.n	a14, a10
42016a7d:	dada      	add.n	a13, a10, a13
42016a7f:	caca      	add.n	a12, a10, a12
42016a81:	02bd      	mov.n	a11, a2
42016a83:	03ad      	mov.n	a10, a3
42016a85:	feb1e5        	call8	420155a4 <get_arg$constprop$0>
42016a88:	000a52        	l8ui	a5, a10, 0
42016a8b:	002bc6        	j	42016b3e <_vfiprintf_r+0x107e>
42016a8e:	00          	.byte 00
42016a8f:	00          	.byte 00
42016a90:	10c1c2        	addi	a12, a1, 16
42016a93:	241b      	addi.n	a2, a4, 1
42016a95:	b033c0        	addx8	a3, a3, a12
42016a98:	682467        	blt	a4, a6, 42016b04 <_vfiprintf_r+0x1044>
42016a9b:	10c1d2        	addi	a13, a1, 16
42016a9e:	922d72        	l32i	a7, a13, 0x248
42016aa1:	f81c      	movi.n	a8, 31
42016aa3:	02dd42        	addmi	a4, a13, 0x200
42016aa6:	374b      	addi.n	a3, a7, 4
42016aa8:	851c      	movi.n	a5, 24
42016aaa:	362867        	blt	a8, a6, 42016ae4 <_vfiprintf_r+0x1024>
42016aad:	861b      	addi.n	a8, a6, 1
42016aaf:	926182        	s32i	a8, a1, 0x248
42016ab2:	126432        	s32i	a3, a4, 72
42016ab5:	072537        	blt	a5, a3, 42016ac0 <_vfiprintf_r+0x1000>
42016ab8:	112432        	l32i	a3, a4, 68
42016abb:	000306        	j	42016acb <_vfiprintf_r+0x100b>
42016abe:	00          	.byte 00
42016abf:	00          	.byte 00
42016ac0:	012577        	blt	a5, a7, 42016ac5 <_vfiprintf_r+0x1005>
42016ac3:	432c      	movi.n	a3, 36
42016ac5:	966132        	s32i	a3, a1, 0x258
42016ac8:	942132        	l32i	a3, a1, 0x250
42016acb:	962142        	l32i	a4, a1, 0x258
42016ace:	10c1f2        	addi	a15, a1, 16
42016ad1:	334a      	add.n	a3, a3, a4
42016ad3:	fcc332        	addi	a3, a3, -4
42016ad6:	0358      	l32i.n	a5, a3, 0
42016ad8:	b066f0        	addx8	a6, a6, a15
42016adb:	0659      	s32i.n	a5, a6, 0
42016add:	745050        	extui	a5, a5, 0, 8
42016ae0:	003486        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016ae3:	00          	.byte 00
42016ae4:	126432        	s32i	a3, a4, 72
42016ae7:	052537        	blt	a5, a3, 42016af0 <_vfiprintf_r+0x1030>
42016aea:	112432        	l32i	a3, a4, 68
42016aed:	000286        	j	42016afb <_vfiprintf_r+0x103b>
42016af0:	012577        	blt	a5, a7, 42016af5 <_vfiprintf_r+0x1035>
42016af3:	432c      	movi.n	a3, 36
42016af5:	966132        	s32i	a3, a1, 0x258
42016af8:	942132        	l32i	a3, a1, 0x250
42016afb:	962142        	l32i	a4, a1, 0x258
42016afe:	803340        	add	a3, a3, a4
42016b01:	fcc332        	addi	a3, a3, -4
42016b04:	000352        	l8ui	a5, a3, 0
42016b07:	002ac6        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016b0a:	65bc      	beqz.n	a5, 42016b44 <_vfiprintf_r+0x1084>
42016b0c:	0ca367        	bge	a3, a6, 42016b1c <_vfiprintf_r+0x105c>
42016b0f:	10c162        	addi	a6, a1, 16
42016b12:	b03360        	addx8	a3, a3, a6
42016b15:	0358      	l32i.n	a5, a3, 0
42016b17:	0008c6        	j	42016b3e <_vfiprintf_r+0x107e>
42016b1a:	00          	.byte 00
42016b1b:	00          	.byte 00
42016b1c:	10c182        	addi	a8, a1, 16
42016b1f:	34a252        	movi	a5, 0x234
42016b22:	585a      	add.n	a5, a8, a5
42016b24:	0159      	s32i.n	a5, a1, 0
42016b26:	01d8f2        	addmi	a15, a8, 0x100
42016b29:	08ed      	mov.n	a14, a8
42016b2b:	38a2d2        	movi	a13, 0x238
42016b2e:	40a2c2        	movi	a12, 0x240
42016b31:	deda      	add.n	a13, a14, a13
42016b33:	ceca      	add.n	a12, a14, a12
42016b35:	02bd      	mov.n	a11, a2
42016b37:	03ad      	mov.n	a10, a3
42016b39:	fea6a5        	call8	420155a4 <get_arg$constprop$0>
42016b3c:	0a58      	l32i.n	a5, a10, 0
42016b3e:	042d      	mov.n	a2, a4
42016b40:	001c86        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016b43:	00          	.byte 00
42016b44:	10c192        	addi	a9, a1, 16
42016b47:	241b      	addi.n	a2, a4, 1
42016b49:	b03390        	addx8	a3, a3, a9
42016b4c:	642467        	blt	a4, a6, 42016bb4 <_vfiprintf_r+0x10f4>
42016b4f:	10c1a2        	addi	a10, a1, 16
42016b52:	922a72        	l32i	a7, a10, 0x248
42016b55:	f81c      	movi.n	a8, 31
42016b57:	02da42        	addmi	a4, a10, 0x200
42016b5a:	374b      	addi.n	a3, a7, 4
42016b5c:	851c      	movi.n	a5, 24
42016b5e:	322867        	blt	a8, a6, 42016b94 <_vfiprintf_r+0x10d4>
42016b61:	861b      	addi.n	a8, a6, 1
42016b63:	926182        	s32i	a8, a1, 0x248
42016b66:	126432        	s32i	a3, a4, 72
42016b69:	052537        	blt	a5, a3, 42016b72 <_vfiprintf_r+0x10b2>
42016b6c:	112432        	l32i	a3, a4, 68
42016b6f:	0002c6        	j	42016b7e <_vfiprintf_r+0x10be>
42016b72:	022577        	blt	a5, a7, 42016b78 <_vfiprintf_r+0x10b8>
42016b75:	24a032        	movi	a3, 36
42016b78:	966132        	s32i	a3, a1, 0x258
42016b7b:	942132        	l32i	a3, a1, 0x250
42016b7e:	962142        	l32i	a4, a1, 0x258
42016b81:	10c1d2        	addi	a13, a1, 16
42016b84:	334a      	add.n	a3, a3, a4
42016b86:	fcc332        	addi	a3, a3, -4
42016b89:	0358      	l32i.n	a5, a3, 0
42016b8b:	b066d0        	addx8	a6, a6, a13
42016b8e:	0659      	s32i.n	a5, a6, 0
42016b90:	000886        	j	42016bb6 <_vfiprintf_r+0x10f6>
42016b93:	00          	.byte 00
42016b94:	126432        	s32i	a3, a4, 72
42016b97:	052537        	blt	a5, a3, 42016ba0 <_vfiprintf_r+0x10e0>
42016b9a:	112432        	l32i	a3, a4, 68
42016b9d:	000286        	j	42016bab <_vfiprintf_r+0x10eb>
42016ba0:	012577        	blt	a5, a7, 42016ba5 <_vfiprintf_r+0x10e5>
42016ba3:	432c      	movi.n	a3, 36
42016ba5:	966132        	s32i	a3, a1, 0x258
42016ba8:	942132        	l32i	a3, a1, 0x250
42016bab:	962142        	l32i	a4, a1, 0x258
42016bae:	803340        	add	a3, a3, a4
42016bb1:	fcc332        	addi	a3, a3, -4
42016bb4:	0358      	l32i.n	a5, a3, 0
42016bb6:	070c      	movi.n	a7, 0
42016bb8:	972142        	l32i	a4, a1, 0x25c
42016bbb:	ffab32        	movi	a3, 0xfffffbff
42016bbe:	104430        	and	a4, a4, a3
42016bc1:	976142        	s32i	a4, a1, 0x25c
42016bc4:	040c      	movi.n	a4, 0
42016bc6:	023c46        	j	420174bb <_vfiprintf_r+0x19fb>
42016bc9:	922162        	l32i	a6, a1, 0x248
42016bcc:	45bc      	beqz.n	a5, 42016c04 <_vfiprintf_r+0x1144>
42016bce:	0aa367        	bge	a3, a6, 42016bdc <_vfiprintf_r+0x111c>
42016bd1:	10c152        	addi	a5, a1, 16
42016bd4:	b03350        	addx8	a3, a3, a5
42016bd7:	0358      	l32i.n	a5, a3, 0
42016bd9:	000846        	j	42016bfe <_vfiprintf_r+0x113e>
42016bdc:	10c162        	addi	a6, a1, 16
42016bdf:	34a252        	movi	a5, 0x234
42016be2:	565a      	add.n	a5, a6, a5
42016be4:	38a2d2        	movi	a13, 0x238
42016be7:	40a2c2        	movi	a12, 0x240
42016bea:	0159      	s32i.n	a5, a1, 0
42016bec:	01d6f2        	addmi	a15, a6, 0x100
42016bef:	06ed      	mov.n	a14, a6
42016bf1:	d6da      	add.n	a13, a6, a13
42016bf3:	c6ca      	add.n	a12, a6, a12
42016bf5:	02bd      	mov.n	a11, a2
42016bf7:	03ad      	mov.n	a10, a3
42016bf9:	fe9aa5        	call8	420155a4 <get_arg$constprop$0>
42016bfc:	0a58      	l32i.n	a5, a10, 0
42016bfe:	042d      	mov.n	a2, a4
42016c00:	001c86        	j	42016c76 <_vfiprintf_r+0x11b6>
42016c03:	00          	.byte 00
42016c04:	10c182        	addi	a8, a1, 16
42016c07:	241b      	addi.n	a2, a4, 1
42016c09:	b03380        	addx8	a3, a3, a8
42016c0c:	642467        	blt	a4, a6, 42016c74 <_vfiprintf_r+0x11b4>
42016c0f:	10c192        	addi	a9, a1, 16
42016c12:	922972        	l32i	a7, a9, 0x248
42016c15:	f81c      	movi.n	a8, 31
42016c17:	02d942        	addmi	a4, a9, 0x200
42016c1a:	374b      	addi.n	a3, a7, 4
42016c1c:	851c      	movi.n	a5, 24
42016c1e:	322867        	blt	a8, a6, 42016c54 <_vfiprintf_r+0x1194>
42016c21:	861b      	addi.n	a8, a6, 1
42016c23:	926182        	s32i	a8, a1, 0x248
42016c26:	126432        	s32i	a3, a4, 72
42016c29:	072537        	blt	a5, a3, 42016c34 <_vfiprintf_r+0x1174>
42016c2c:	112432        	l32i	a3, a4, 68
42016c2f:	000306        	j	42016c3f <_vfiprintf_r+0x117f>
42016c32:	00          	.byte 00
42016c33:	00          	.byte 00
42016c34:	012577        	blt	a5, a7, 42016c39 <_vfiprintf_r+0x1179>
42016c37:	432c      	movi.n	a3, 36
42016c39:	966132        	s32i	a3, a1, 0x258
42016c3c:	942132        	l32i	a3, a1, 0x250
42016c3f:	962142        	l32i	a4, a1, 0x258
42016c42:	10c1c2        	addi	a12, a1, 16
42016c45:	334a      	add.n	a3, a3, a4
42016c47:	fcc332        	addi	a3, a3, -4
42016c4a:	0358      	l32i.n	a5, a3, 0
42016c4c:	b036c0        	addx8	a3, a6, a12
42016c4f:	0359      	s32i.n	a5, a3, 0
42016c51:	000846        	j	42016c76 <_vfiprintf_r+0x11b6>
42016c54:	126432        	s32i	a3, a4, 72
42016c57:	052537        	blt	a5, a3, 42016c60 <_vfiprintf_r+0x11a0>
42016c5a:	112432        	l32i	a3, a4, 68
42016c5d:	000286        	j	42016c6b <_vfiprintf_r+0x11ab>
42016c60:	012577        	blt	a5, a7, 42016c65 <_vfiprintf_r+0x11a5>
42016c63:	432c      	movi.n	a3, 36
42016c65:	966132        	s32i	a3, a1, 0x258
42016c68:	942132        	l32i	a3, a1, 0x250
42016c6b:	962142        	l32i	a4, a1, 0x258
42016c6e:	803340        	add	a3, a3, a4
42016c71:	fcc332        	addi	a3, a3, -4
42016c74:	0358      	l32i.n	a5, a3, 0
42016c76:	972132        	l32i	a3, a1, 0x25c
42016c79:	240c      	movi.n	a4, 2
42016c7b:	203340        	or	a3, a3, a4
42016c7e:	10c182        	addi	a8, a1, 16
42016c81:	063c      	movi.n	a6, 48
42016c83:	a82691        	l32r	a9, 42000d1c <_stext+0xcfc>
42016c86:	976132        	s32i	a3, a1, 0x25c
42016c89:	02d832        	addmi	a3, a8, 0x200
42016c8c:	3c4362        	s8i	a6, a3, 60
42016c8f:	78a062        	movi	a6, 120
42016c92:	070c      	movi.n	a7, 0
42016c94:	3d4362        	s8i	a6, a3, 61
42016c97:	9f6192        	s32i	a9, a1, 0x27c
42016c9a:	020746        	j	420174bb <_vfiprintf_r+0x19fb>
42016c9d:	922162        	l32i	a6, a1, 0x248
42016ca0:	35bc      	beqz.n	a5, 42016cd7 <_vfiprintf_r+0x1217>
42016ca2:	0aa367        	bge	a3, a6, 42016cb0 <_vfiprintf_r+0x11f0>
42016ca5:	10c1a2        	addi	a10, a1, 16
42016ca8:	b033a0        	addx8	a3, a3, a10
42016cab:	0338      	l32i.n	a3, a3, 0
42016cad:	000846        	j	42016cd2 <_vfiprintf_r+0x1212>
42016cb0:	10c1c2        	addi	a12, a1, 16
42016cb3:	34a252        	movi	a5, 0x234
42016cb6:	38a2d2        	movi	a13, 0x238
42016cb9:	0ced      	mov.n	a14, a12
42016cbb:	5c5a      	add.n	a5, a12, a5
42016cbd:	01dcf2        	addmi	a15, a12, 0x100
42016cc0:	dcda      	add.n	a13, a12, a13
42016cc2:	40a2c2        	movi	a12, 0x240
42016cc5:	03ad      	mov.n	a10, a3
42016cc7:	0159      	s32i.n	a5, a1, 0
42016cc9:	ceca      	add.n	a12, a14, a12
42016ccb:	02bd      	mov.n	a11, a2
42016ccd:	fe8d65        	call8	420155a4 <get_arg$constprop$0>
42016cd0:	0a38      	l32i.n	a3, a10, 0
42016cd2:	042d      	mov.n	a2, a4
42016cd4:	001bc6        	j	42016d47 <_vfiprintf_r+0x1287>
42016cd7:	10c1d2        	addi	a13, a1, 16
42016cda:	241b      	addi.n	a2, a4, 1
42016cdc:	b033d0        	addx8	a3, a3, a13
42016cdf:	622467        	blt	a4, a6, 42016d45 <_vfiprintf_r+0x1285>
42016ce2:	10c1e2        	addi	a14, a1, 16
42016ce5:	922e72        	l32i	a7, a14, 0x248
42016ce8:	f81c      	movi.n	a8, 31
42016cea:	02de42        	addmi	a4, a14, 0x200
42016ced:	374b      	addi.n	a3, a7, 4
42016cef:	851c      	movi.n	a5, 24
42016cf1:	302867        	blt	a8, a6, 42016d25 <_vfiprintf_r+0x1265>
42016cf4:	861b      	addi.n	a8, a6, 1
42016cf6:	926182        	s32i	a8, a1, 0x248
42016cf9:	126432        	s32i	a3, a4, 72
42016cfc:	052537        	blt	a5, a3, 42016d05 <_vfiprintf_r+0x1245>
42016cff:	112432        	l32i	a3, a4, 68
42016d02:	000286        	j	42016d10 <_vfiprintf_r+0x1250>
42016d05:	012577        	blt	a5, a7, 42016d0a <_vfiprintf_r+0x124a>
42016d08:	432c      	movi.n	a3, 36
42016d0a:	966132        	s32i	a3, a1, 0x258
42016d0d:	942132        	l32i	a3, a1, 0x250
42016d10:	962142        	l32i	a4, a1, 0x258
42016d13:	10c152        	addi	a5, a1, 16
42016d16:	334a      	add.n	a3, a3, a4
42016d18:	fcc332        	addi	a3, a3, -4
42016d1b:	0338      	l32i.n	a3, a3, 0
42016d1d:	b04650        	addx8	a4, a6, a5
42016d20:	0439      	s32i.n	a3, a4, 0
42016d22:	000846        	j	42016d47 <_vfiprintf_r+0x1287>
42016d25:	126432        	s32i	a3, a4, 72
42016d28:	052537        	blt	a5, a3, 42016d31 <_vfiprintf_r+0x1271>
42016d2b:	112432        	l32i	a3, a4, 68
42016d2e:	000286        	j	42016d3c <_vfiprintf_r+0x127c>
42016d31:	012577        	blt	a5, a7, 42016d36 <_vfiprintf_r+0x1276>
42016d34:	432c      	movi.n	a3, 36
42016d36:	966132        	s32i	a3, a1, 0x258
42016d39:	942132        	l32i	a3, a1, 0x250
42016d3c:	962142        	l32i	a4, a1, 0x258
42016d3f:	803340        	add	a3, a3, a4
42016d42:	fcc332        	addi	a3, a3, -4
42016d45:	0338      	l32i.n	a3, a3, 0
42016d47:	10c182        	addi	a8, a1, 16
42016d4a:	050c      	movi.n	a5, 0
42016d4c:	02d842        	addmi	a4, a8, 0x200
42016d4f:	9a2192        	l32i	a9, a1, 0x268
42016d52:	3e4452        	s8i	a5, a4, 62
42016d55:	1c0926        	beqi	a9, -1, 42016d75 <_vfiprintf_r+0x12b5>
42016d58:	09cd      	mov.n	a12, a9
42016d5a:	0b0c      	movi.n	a11, 0
42016d5c:	03ad      	mov.n	a10, a3
42016d5e:	a78d81        	l32r	a8, 42000b94 <_stext+0xb74>
42016d61:	0008e0        	callx8	a8
42016d64:	040c      	movi.n	a4, 0
42016d66:	029a47        	bne	a10, a4, 42016d6c <_vfiprintf_r+0x12ac>
42016d69:	024606        	j	42017685 <_vfiprintf_r+0x1bc5>
42016d6c:	c0aa30        	sub	a10, a10, a3
42016d6f:	9a61a2        	s32i	a10, a1, 0x268
42016d72:	0243c6        	j	42017685 <_vfiprintf_r+0x1bc5>
42016d75:	03ad      	mov.n	a10, a3
42016d77:	a64781        	l32r	a8, 42000694 <_stext+0x674>
42016d7a:	0008e0        	callx8	a8
42016d7d:	9a61a2        	s32i	a10, a1, 0x268
42016d80:	040c      	movi.n	a4, 0
42016d82:	023fc6        	j	42017685 <_vfiprintf_r+0x1bc5>
42016d85:	00          	.byte 00
42016d86:	00          	.byte 00
42016d87:	972182        	l32i	a8, a1, 0x25c
42016d8a:	061c      	movi.n	a6, 16
42016d8c:	208860        	or	a8, a8, a6
42016d8f:	976182        	s32i	a8, a1, 0x25c
42016d92:	972192        	l32i	a9, a1, 0x25c
42016d95:	922162        	l32i	a6, a1, 0x248
42016d98:	02e957        	bbsi	a9, 5, 42016d9e <_vfiprintf_r+0x12de>
42016d9b:	002f06        	j	42016e5b <_vfiprintf_r+0x139b>
42016d9e:	75bc      	beqz.n	a5, 42016dd9 <_vfiprintf_r+0x1319>
42016da0:	0ca367        	bge	a3, a6, 42016db0 <_vfiprintf_r+0x12f0>
42016da3:	10c1a2        	addi	a10, a1, 16
42016da6:	b033a0        	addx8	a3, a3, a10
42016da9:	0358      	l32i.n	a5, a3, 0
42016dab:	1378      	l32i.n	a7, a3, 4
42016dad:	0008c6        	j	42016dd4 <_vfiprintf_r+0x1314>
42016db0:	10c1c2        	addi	a12, a1, 16
42016db3:	34a252        	movi	a5, 0x234
42016db6:	38a2d2        	movi	a13, 0x238
42016db9:	5c5a      	add.n	a5, a12, a5
42016dbb:	0ced      	mov.n	a14, a12
42016dbd:	01dcf2        	addmi	a15, a12, 0x100
42016dc0:	dcda      	add.n	a13, a12, a13
42016dc2:	40a2c2        	movi	a12, 0x240
42016dc5:	0159      	s32i.n	a5, a1, 0
42016dc7:	ceca      	add.n	a12, a14, a12
42016dc9:	02bd      	mov.n	a11, a2
42016dcb:	03ad      	mov.n	a10, a3
42016dcd:	fe7d65        	call8	420155a4 <get_arg$constprop$0>
42016dd0:	0a58      	l32i.n	a5, a10, 0
42016dd2:	1a78      	l32i.n	a7, a10, 4
42016dd4:	042d      	mov.n	a2, a4
42016dd6:	009ec6        	j	42017055 <_vfiprintf_r+0x1595>
42016dd9:	10c1d2        	addi	a13, a1, 16
42016ddc:	241b      	addi.n	a2, a4, 1
42016dde:	b033d0        	addx8	a3, a3, a13
42016de1:	6f2467        	blt	a4, a6, 42016e54 <_vfiprintf_r+0x1394>
42016de4:	10c1e2        	addi	a14, a1, 16
42016de7:	922e42        	l32i	a4, a14, 0x248
42016dea:	837c      	movi.n	a3, -8
42016dec:	447b      	addi.n	a4, a4, 7
42016dee:	104430        	and	a4, a4, a3
42016df1:	f81c      	movi.n	a8, 31
42016df3:	02de52        	addmi	a5, a14, 0x200
42016df6:	348b      	addi.n	a3, a4, 8
42016df8:	871c      	movi.n	a7, 24
42016dfa:	362867        	blt	a8, a6, 42016e34 <_vfiprintf_r+0x1374>
42016dfd:	861b      	addi.n	a8, a6, 1
42016dff:	926182        	s32i	a8, a1, 0x248
42016e02:	126532        	s32i	a3, a5, 72
42016e05:	072737        	blt	a7, a3, 42016e10 <_vfiprintf_r+0x1350>
42016e08:	112532        	l32i	a3, a5, 68
42016e0b:	000306        	j	42016e1b <_vfiprintf_r+0x135b>
42016e0e:	00          	.byte 00
42016e0f:	00          	.byte 00
42016e10:	012747        	blt	a7, a4, 42016e15 <_vfiprintf_r+0x1355>
42016e13:	832c      	movi.n	a3, 40
42016e15:	966132        	s32i	a3, a1, 0x258
42016e18:	942132        	l32i	a3, a1, 0x250
42016e1b:	962142        	l32i	a4, a1, 0x258
42016e1e:	334a      	add.n	a3, a3, a4
42016e20:	f8c332        	addi	a3, a3, -8
42016e23:	0358      	l32i.n	a5, a3, 0
42016e25:	1378      	l32i.n	a7, a3, 4
42016e27:	10c132        	addi	a3, a1, 16
42016e2a:	b06630        	addx8	a6, a6, a3
42016e2d:	0659      	s32i.n	a5, a6, 0
42016e2f:	1679      	s32i.n	a7, a6, 4
42016e31:	008806        	j	42017055 <_vfiprintf_r+0x1595>
42016e34:	126532        	s32i	a3, a5, 72
42016e37:	052737        	blt	a7, a3, 42016e40 <_vfiprintf_r+0x1380>
42016e3a:	112532        	l32i	a3, a5, 68
42016e3d:	000286        	j	42016e4b <_vfiprintf_r+0x138b>
42016e40:	012747        	blt	a7, a4, 42016e45 <_vfiprintf_r+0x1385>
42016e43:	832c      	movi.n	a3, 40
42016e45:	966132        	s32i	a3, a1, 0x258
42016e48:	942132        	l32i	a3, a1, 0x250
42016e4b:	962142        	l32i	a4, a1, 0x258
42016e4e:	803340        	add	a3, a3, a4
42016e51:	f8c332        	addi	a3, a3, -8
42016e54:	0358      	l32i.n	a5, a3, 0
42016e56:	1378      	l32i.n	a7, a3, 4
42016e58:	007e46        	j	42017055 <_vfiprintf_r+0x1595>
42016e5b:	972182        	l32i	a8, a1, 0x25c
42016e5e:	766847        	bbci	a8, 4, 42016ed8 <_vfiprintf_r+0x1418>
42016e61:	f59c      	beqz.n	a5, 42016e84 <_vfiprintf_r+0x13c4>
42016e63:	09a367        	bge	a3, a6, 42016e70 <_vfiprintf_r+0x13b0>
42016e66:	10c192        	addi	a9, a1, 16
42016e69:	b03390        	addx8	a3, a3, a9
42016e6c:	007d46        	j	42017065 <_vfiprintf_r+0x15a5>
42016e6f:	00          	.byte 00
42016e70:	10c1a2        	addi	a10, a1, 16
42016e73:	34a252        	movi	a5, 0x234
42016e76:	5a5a      	add.n	a5, a10, a5
42016e78:	0159      	s32i.n	a5, a1, 0
42016e7a:	01daf2        	addmi	a15, a10, 0x100
42016e7d:	0aed      	mov.n	a14, a10
42016e7f:	007e06        	j	4201707b <_vfiprintf_r+0x15bb>
42016e82:	00          	.byte 00
42016e83:	00          	.byte 00
42016e84:	10c1c2        	addi	a12, a1, 16
42016e87:	241b      	addi.n	a2, a4, 1
42016e89:	b033c0        	addx8	a3, a3, a12
42016e8c:	02a467        	bge	a4, a6, 42016e92 <_vfiprintf_r+0x13d2>
42016e8f:	009c46        	j	42017104 <_vfiprintf_r+0x1644>
42016e92:	10c1d2        	addi	a13, a1, 16
42016e95:	922d72        	l32i	a7, a13, 0x248
42016e98:	f81c      	movi.n	a8, 31
42016e9a:	02dd42        	addmi	a4, a13, 0x200
42016e9d:	374b      	addi.n	a3, a7, 4
42016e9f:	851c      	movi.n	a5, 24
42016ea1:	02a867        	bge	a8, a6, 42016ea7 <_vfiprintf_r+0x13e7>
42016ea4:	008f06        	j	420170e4 <_vfiprintf_r+0x1624>
42016ea7:	861b      	addi.n	a8, a6, 1
42016ea9:	926182        	s32i	a8, a1, 0x248
42016eac:	126432        	s32i	a3, a4, 72
42016eaf:	052537        	blt	a5, a3, 42016eb8 <_vfiprintf_r+0x13f8>
42016eb2:	112432        	l32i	a3, a4, 68
42016eb5:	000286        	j	42016ec3 <_vfiprintf_r+0x1403>
42016eb8:	012577        	blt	a5, a7, 42016ebd <_vfiprintf_r+0x13fd>
42016ebb:	432c      	movi.n	a3, 36
42016ebd:	966132        	s32i	a3, a1, 0x258
42016ec0:	942132        	l32i	a3, a1, 0x250
42016ec3:	962142        	l32i	a4, a1, 0x258
42016ec6:	10c1f2        	addi	a15, a1, 16
42016ec9:	334a      	add.n	a3, a3, a4
42016ecb:	fcc332        	addi	a3, a3, -4
42016ece:	0358      	l32i.n	a5, a3, 0
42016ed0:	b066f0        	addx8	a6, a6, a15
42016ed3:	008206        	j	420170df <_vfiprintf_r+0x161f>
42016ed6:	00          	.byte 00
42016ed7:	00          	.byte 00
42016ed8:	972182        	l32i	a8, a1, 0x25c
42016edb:	02e867        	bbsi	a8, 6, 42016ee1 <_vfiprintf_r+0x1421>
42016ede:	002d86        	j	42016f98 <_vfiprintf_r+0x14d8>
42016ee1:	75bc      	beqz.n	a5, 42016f1c <_vfiprintf_r+0x145c>
42016ee3:	0da367        	bge	a3, a6, 42016ef4 <_vfiprintf_r+0x1434>
42016ee6:	10c192        	addi	a9, a1, 16
42016ee9:	b03390        	addx8	a3, a3, a9
42016eec:	001352        	l16ui	a5, a3, 0
42016eef:	0066c6        	j	4201708e <_vfiprintf_r+0x15ce>
42016ef2:	00          	.byte 00
42016ef3:	00          	.byte 00
42016ef4:	10c1a2        	addi	a10, a1, 16
42016ef7:	34a252        	movi	a5, 0x234
42016efa:	5a5a      	add.n	a5, a10, a5
42016efc:	38a2d2        	movi	a13, 0x238
42016eff:	40a2c2        	movi	a12, 0x240
42016f02:	0159      	s32i.n	a5, a1, 0
42016f04:	01daf2        	addmi	a15, a10, 0x100
42016f07:	0aed      	mov.n	a14, a10
42016f09:	dada      	add.n	a13, a10, a13
42016f0b:	caca      	add.n	a12, a10, a12
42016f0d:	02bd      	mov.n	a11, a2
42016f0f:	03ad      	mov.n	a10, a3
42016f11:	fe6925        	call8	420155a4 <get_arg$constprop$0>
42016f14:	001a52        	l16ui	a5, a10, 0
42016f17:	005cc6        	j	4201708e <_vfiprintf_r+0x15ce>
42016f1a:	00          	.byte 00
42016f1b:	00          	.byte 00
42016f1c:	10c1c2        	addi	a12, a1, 16
42016f1f:	241b      	addi.n	a2, a4, 1
42016f21:	b033c0        	addx8	a3, a3, a12
42016f24:	682467        	blt	a4, a6, 42016f90 <_vfiprintf_r+0x14d0>
42016f27:	10c1d2        	addi	a13, a1, 16
42016f2a:	922d72        	l32i	a7, a13, 0x248
42016f2d:	f81c      	movi.n	a8, 31
42016f2f:	02dd42        	addmi	a4, a13, 0x200
42016f32:	374b      	addi.n	a3, a7, 4
42016f34:	851c      	movi.n	a5, 24
42016f36:	362867        	blt	a8, a6, 42016f70 <_vfiprintf_r+0x14b0>
42016f39:	861b      	addi.n	a8, a6, 1
42016f3b:	926182        	s32i	a8, a1, 0x248
42016f3e:	126432        	s32i	a3, a4, 72
42016f41:	072537        	blt	a5, a3, 42016f4c <_vfiprintf_r+0x148c>
42016f44:	112432        	l32i	a3, a4, 68
42016f47:	000306        	j	42016f57 <_vfiprintf_r+0x1497>
42016f4a:	00          	.byte 00
42016f4b:	00          	.byte 00
42016f4c:	012577        	blt	a5, a7, 42016f51 <_vfiprintf_r+0x1491>
42016f4f:	432c      	movi.n	a3, 36
42016f51:	966132        	s32i	a3, a1, 0x258
42016f54:	942132        	l32i	a3, a1, 0x250
42016f57:	962142        	l32i	a4, a1, 0x258
42016f5a:	10c1f2        	addi	a15, a1, 16
42016f5d:	334a      	add.n	a3, a3, a4
42016f5f:	fcc332        	addi	a3, a3, -4
42016f62:	0358      	l32i.n	a5, a3, 0
42016f64:	b066f0        	addx8	a6, a6, a15
42016f67:	0659      	s32i.n	a5, a6, 0
42016f69:	f45050        	extui	a5, a5, 0, 16
42016f6c:	0038c6        	j	42017053 <_vfiprintf_r+0x1593>
42016f6f:	00          	.byte 00
42016f70:	126432        	s32i	a3, a4, 72
42016f73:	052537        	blt	a5, a3, 42016f7c <_vfiprintf_r+0x14bc>
42016f76:	112432        	l32i	a3, a4, 68
42016f79:	000286        	j	42016f87 <_vfiprintf_r+0x14c7>
42016f7c:	012577        	blt	a5, a7, 42016f81 <_vfiprintf_r+0x14c1>
42016f7f:	432c      	movi.n	a3, 36
42016f81:	966132        	s32i	a3, a1, 0x258
42016f84:	942132        	l32i	a3, a1, 0x250
42016f87:	962142        	l32i	a4, a1, 0x258
42016f8a:	803340        	add	a3, a3, a4
42016f8d:	fcc332        	addi	a3, a3, -4
42016f90:	001352        	l16ui	a5, a3, 0
42016f93:	002f06        	j	42017053 <_vfiprintf_r+0x1593>
42016f96:	00          	.byte 00
42016f97:	00          	.byte 00
42016f98:	972182        	l32i	a8, a1, 0x25c
42016f9b:	02e897        	bbsi	a8, 9, 42016fa1 <_vfiprintf_r+0x14e1>
42016f9e:	002e06        	j	4201705a <_vfiprintf_r+0x159a>
42016fa1:	75bc      	beqz.n	a5, 42016fdc <_vfiprintf_r+0x151c>
42016fa3:	0ba367        	bge	a3, a6, 42016fb2 <_vfiprintf_r+0x14f2>
42016fa6:	10c192        	addi	a9, a1, 16
42016fa9:	b03390        	addx8	a3, a3, a9
42016fac:	000352        	l8ui	a5, a3, 0
42016faf:	0036c6        	j	4201708e <_vfiprintf_r+0x15ce>
42016fb2:	10c1a2        	addi	a10, a1, 16
42016fb5:	34a252        	movi	a5, 0x234
42016fb8:	5a5a      	add.n	a5, a10, a5
42016fba:	38a2d2        	movi	a13, 0x238
42016fbd:	40a2c2        	movi	a12, 0x240
42016fc0:	0159      	s32i.n	a5, a1, 0
42016fc2:	01daf2        	addmi	a15, a10, 0x100
42016fc5:	0aed      	mov.n	a14, a10
42016fc7:	dada      	add.n	a13, a10, a13
42016fc9:	caca      	add.n	a12, a10, a12
42016fcb:	20b220        	or	a11, a2, a2
42016fce:	20a330        	or	a10, a3, a3
42016fd1:	fe5d25        	call8	420155a4 <get_arg$constprop$0>
42016fd4:	000a52        	l8ui	a5, a10, 0
42016fd7:	002cc6        	j	4201708e <_vfiprintf_r+0x15ce>
42016fda:	00          	.byte 00
42016fdb:	00          	.byte 00
42016fdc:	10c1c2        	addi	a12, a1, 16
42016fdf:	241b      	addi.n	a2, a4, 1
42016fe1:	b033c0        	addx8	a3, a3, a12
42016fe4:	682467        	blt	a4, a6, 42017050 <_vfiprintf_r+0x1590>
42016fe7:	10c1d2        	addi	a13, a1, 16
42016fea:	922d72        	l32i	a7, a13, 0x248
42016fed:	f81c      	movi.n	a8, 31
42016fef:	02dd42        	addmi	a4, a13, 0x200
42016ff2:	374b      	addi.n	a3, a7, 4
42016ff4:	851c      	movi.n	a5, 24
42016ff6:	362867        	blt	a8, a6, 42017030 <_vfiprintf_r+0x1570>
42016ff9:	861b      	addi.n	a8, a6, 1
42016ffb:	926182        	s32i	a8, a1, 0x248
42016ffe:	126432        	s32i	a3, a4, 72
42017001:	072537        	blt	a5, a3, 4201700c <_vfiprintf_r+0x154c>
42017004:	112432        	l32i	a3, a4, 68
42017007:	000306        	j	42017017 <_vfiprintf_r+0x1557>
4201700a:	00          	.byte 00
4201700b:	00          	.byte 00
4201700c:	012577        	blt	a5, a7, 42017011 <_vfiprintf_r+0x1551>
4201700f:	432c      	movi.n	a3, 36
42017011:	966132        	s32i	a3, a1, 0x258
42017014:	942132        	l32i	a3, a1, 0x250
42017017:	962142        	l32i	a4, a1, 0x258
4201701a:	10c1f2        	addi	a15, a1, 16
4201701d:	334a      	add.n	a3, a3, a4
4201701f:	fcc332        	addi	a3, a3, -4
42017022:	0358      	l32i.n	a5, a3, 0
42017024:	b066f0        	addx8	a6, a6, a15
42017027:	0659      	s32i.n	a5, a6, 0
42017029:	745050        	extui	a5, a5, 0, 8
4201702c:	0008c6        	j	42017053 <_vfiprintf_r+0x1593>
4201702f:	00          	.byte 00
42017030:	126432        	s32i	a3, a4, 72
42017033:	052537        	blt	a5, a3, 4201703c <_vfiprintf_r+0x157c>
42017036:	112432        	l32i	a3, a4, 68
42017039:	000286        	j	42017047 <_vfiprintf_r+0x1587>
4201703c:	012577        	blt	a5, a7, 42017041 <_vfiprintf_r+0x1581>
4201703f:	432c      	movi.n	a3, 36
42017041:	966132        	s32i	a3, a1, 0x258
42017044:	942132        	l32i	a3, a1, 0x250
42017047:	962142        	l32i	a4, a1, 0x258
4201704a:	803340        	add	a3, a3, a4
4201704d:	fcc332        	addi	a3, a3, -4
42017050:	000352        	l8ui	a5, a3, 0
42017053:	070c      	movi.n	a7, 0
42017055:	140c      	movi.n	a4, 1
42017057:	011806        	j	420174bb <_vfiprintf_r+0x19fb>
4201705a:	65bc      	beqz.n	a5, 42017094 <_vfiprintf_r+0x15d4>
4201705c:	0ca367        	bge	a3, a6, 4201706c <_vfiprintf_r+0x15ac>
4201705f:	10c162        	addi	a6, a1, 16
42017062:	b03360        	addx8	a3, a3, a6
42017065:	0358      	l32i.n	a5, a3, 0
42017067:	0008c6        	j	4201708e <_vfiprintf_r+0x15ce>
4201706a:	00          	.byte 00
4201706b:	00          	.byte 00
4201706c:	10c182        	addi	a8, a1, 16
4201706f:	34a252        	movi	a5, 0x234
42017072:	585a      	add.n	a5, a8, a5
42017074:	0159      	s32i.n	a5, a1, 0
42017076:	01d8f2        	addmi	a15, a8, 0x100
42017079:	08ed      	mov.n	a14, a8
4201707b:	38a2d2        	movi	a13, 0x238
4201707e:	40a2c2        	movi	a12, 0x240
42017081:	deda      	add.n	a13, a14, a13
42017083:	ceca      	add.n	a12, a14, a12
42017085:	02bd      	mov.n	a11, a2
42017087:	03ad      	mov.n	a10, a3
42017089:	fe51a5        	call8	420155a4 <get_arg$constprop$0>
4201708c:	0a58      	l32i.n	a5, a10, 0
4201708e:	042d      	mov.n	a2, a4
42017090:	ffefc6        	j	42017053 <_vfiprintf_r+0x1593>
42017093:	00          	.byte 00
42017094:	10c192        	addi	a9, a1, 16
42017097:	241b      	addi.n	a2, a4, 1
42017099:	b03390        	addx8	a3, a3, a9
4201709c:	642467        	blt	a4, a6, 42017104 <_vfiprintf_r+0x1644>
4201709f:	10c1a2        	addi	a10, a1, 16
420170a2:	922a72        	l32i	a7, a10, 0x248
420170a5:	f81c      	movi.n	a8, 31
420170a7:	02da42        	addmi	a4, a10, 0x200
420170aa:	374b      	addi.n	a3, a7, 4
420170ac:	851c      	movi.n	a5, 24
420170ae:	322867        	blt	a8, a6, 420170e4 <_vfiprintf_r+0x1624>
420170b1:	861b      	addi.n	a8, a6, 1
420170b3:	926182        	s32i	a8, a1, 0x248
420170b6:	126432        	s32i	a3, a4, 72
420170b9:	072537        	blt	a5, a3, 420170c4 <_vfiprintf_r+0x1604>
420170bc:	112432        	l32i	a3, a4, 68
420170bf:	000306        	j	420170cf <_vfiprintf_r+0x160f>
420170c2:	00          	.byte 00
420170c3:	00          	.byte 00
420170c4:	012577        	blt	a5, a7, 420170c9 <_vfiprintf_r+0x1609>
420170c7:	432c      	movi.n	a3, 36
420170c9:	966132        	s32i	a3, a1, 0x258
420170cc:	942132        	l32i	a3, a1, 0x250
420170cf:	962142        	l32i	a4, a1, 0x258
420170d2:	10c1d2        	addi	a13, a1, 16
420170d5:	334a      	add.n	a3, a3, a4
420170d7:	fcc332        	addi	a3, a3, -4
420170da:	0358      	l32i.n	a5, a3, 0
420170dc:	b066d0        	addx8	a6, a6, a13
420170df:	0659      	s32i.n	a5, a6, 0
420170e1:	ffdb86        	j	42017053 <_vfiprintf_r+0x1593>
420170e4:	126432        	s32i	a3, a4, 72
420170e7:	052537        	blt	a5, a3, 420170f0 <_vfiprintf_r+0x1630>
420170ea:	112432        	l32i	a3, a4, 68
420170ed:	000286        	j	420170fb <_vfiprintf_r+0x163b>
420170f0:	012577        	blt	a5, a7, 420170f5 <_vfiprintf_r+0x1635>
420170f3:	432c      	movi.n	a3, 36
420170f5:	966132        	s32i	a3, a1, 0x258
420170f8:	942132        	l32i	a3, a1, 0x250
420170fb:	962142        	l32i	a4, a1, 0x258
420170fe:	803340        	add	a3, a3, a4
42017101:	fcc332        	addi	a3, a3, -4
42017104:	0358      	l32i.n	a5, a3, 0
42017106:	ffd246        	j	42017053 <_vfiprintf_r+0x1593>
42017109:	a70381        	l32r	a8, 42000d18 <_stext+0xcf8>
4201710c:	9f6182        	s32i	a8, a1, 0x27c
4201710f:	0001c6        	j	4201711a <_vfiprintf_r+0x165a>
42017112:	00          	.byte 00
42017113:	00          	.byte 00
42017114:	a70291        	l32r	a9, 42000d1c <_stext+0xcfc>
42017117:	9f6192        	s32i	a9, a1, 0x27c
4201711a:	972192        	l32i	a9, a1, 0x25c
4201711d:	922182        	l32i	a8, a1, 0x248
42017120:	02e957        	bbsi	a9, 5, 42017126 <_vfiprintf_r+0x1666>
42017123:	002f46        	j	420171e4 <_vfiprintf_r+0x1724>
42017126:	75bc      	beqz.n	a5, 42017161 <_vfiprintf_r+0x16a1>
42017128:	0ca387        	bge	a3, a8, 42017138 <_vfiprintf_r+0x1678>
4201712b:	10c1a2        	addi	a10, a1, 16
4201712e:	b033a0        	addx8	a3, a3, a10
42017131:	0358      	l32i.n	a5, a3, 0
42017133:	1378      	l32i.n	a7, a3, 4
42017135:	0008c6        	j	4201715c <_vfiprintf_r+0x169c>
42017138:	10c1c2        	addi	a12, a1, 16
4201713b:	34a252        	movi	a5, 0x234
4201713e:	38a2d2        	movi	a13, 0x238
42017141:	5c5a      	add.n	a5, a12, a5
42017143:	0ced      	mov.n	a14, a12
42017145:	01dcf2        	addmi	a15, a12, 0x100
42017148:	dcda      	add.n	a13, a12, a13
4201714a:	40a2c2        	movi	a12, 0x240
4201714d:	0159      	s32i.n	a5, a1, 0
4201714f:	ceca      	add.n	a12, a14, a12
42017151:	02bd      	mov.n	a11, a2
42017153:	03ad      	mov.n	a10, a3
42017155:	fe44e5        	call8	420155a4 <get_arg$constprop$0>
42017158:	0a58      	l32i.n	a5, a10, 0
4201715a:	1a78      	l32i.n	a7, a10, 4
4201715c:	042d      	mov.n	a2, a4
4201715e:	00c986        	j	42017488 <_vfiprintf_r+0x19c8>
42017161:	10c1d2        	addi	a13, a1, 16
42017164:	241b      	addi.n	a2, a4, 1
42017166:	b033d0        	addx8	a3, a3, a13
42017169:	6f2487        	blt	a4, a8, 420171dc <_vfiprintf_r+0x171c>
4201716c:	10c1e2        	addi	a14, a1, 16
4201716f:	922e42        	l32i	a4, a14, 0x248
42017172:	837c      	movi.n	a3, -8
42017174:	447b      	addi.n	a4, a4, 7
42017176:	104430        	and	a4, a4, a3
42017179:	f91c      	movi.n	a9, 31
4201717b:	02de52        	addmi	a5, a14, 0x200
4201717e:	348b      	addi.n	a3, a4, 8
42017180:	871c      	movi.n	a7, 24
42017182:	362987        	blt	a9, a8, 420171bc <_vfiprintf_r+0x16fc>
42017185:	981b      	addi.n	a9, a8, 1
42017187:	926192        	s32i	a9, a1, 0x248
4201718a:	126532        	s32i	a3, a5, 72
4201718d:	072737        	blt	a7, a3, 42017198 <_vfiprintf_r+0x16d8>
42017190:	112532        	l32i	a3, a5, 68
42017193:	000306        	j	420171a3 <_vfiprintf_r+0x16e3>
42017196:	00          	.byte 00
42017197:	00          	.byte 00
42017198:	012747        	blt	a7, a4, 4201719d <_vfiprintf_r+0x16dd>
4201719b:	832c      	movi.n	a3, 40
4201719d:	966132        	s32i	a3, a1, 0x258
420171a0:	942132        	l32i	a3, a1, 0x250
420171a3:	962142        	l32i	a4, a1, 0x258
420171a6:	334a      	add.n	a3, a3, a4
420171a8:	f8c332        	addi	a3, a3, -8
420171ab:	0358      	l32i.n	a5, a3, 0
420171ad:	1378      	l32i.n	a7, a3, 4
420171af:	10c132        	addi	a3, a1, 16
420171b2:	b08830        	addx8	a8, a8, a3
420171b5:	0859      	s32i.n	a5, a8, 0
420171b7:	1879      	s32i.n	a7, a8, 4
420171b9:	00b2c6        	j	42017488 <_vfiprintf_r+0x19c8>
420171bc:	126532        	s32i	a3, a5, 72
420171bf:	052737        	blt	a7, a3, 420171c8 <_vfiprintf_r+0x1708>
420171c2:	112532        	l32i	a3, a5, 68
420171c5:	000286        	j	420171d3 <_vfiprintf_r+0x1713>
420171c8:	012747        	blt	a7, a4, 420171cd <_vfiprintf_r+0x170d>
420171cb:	832c      	movi.n	a3, 40
420171cd:	966132        	s32i	a3, a1, 0x258
420171d0:	942132        	l32i	a3, a1, 0x250
420171d3:	962142        	l32i	a4, a1, 0x258
420171d6:	803340        	add	a3, a3, a4
420171d9:	f8c332        	addi	a3, a3, -8
420171dc:	0358      	l32i.n	a5, a3, 0
420171de:	1378      	l32i.n	a7, a3, 4
420171e0:	00a906        	j	42017488 <_vfiprintf_r+0x19c8>
420171e3:	00          	.byte 00
420171e4:	972192        	l32i	a9, a1, 0x25c
420171e7:	736947        	bbci	a9, 4, 4201725e <_vfiprintf_r+0x179e>
420171ea:	e59c      	beqz.n	a5, 4201720c <_vfiprintf_r+0x174c>
420171ec:	08a387        	bge	a3, a8, 420171f8 <_vfiprintf_r+0x1738>
420171ef:	10c1a2        	addi	a10, a1, 16
420171f2:	b033a0        	addx8	a3, a3, a10
420171f5:	007b06        	j	420173e5 <_vfiprintf_r+0x1925>
420171f8:	10c1c2        	addi	a12, a1, 16
420171fb:	34a252        	movi	a5, 0x234
420171fe:	5c5a      	add.n	a5, a12, a5
42017200:	0159      	s32i.n	a5, a1, 0
42017202:	01dcf2        	addmi	a15, a12, 0x100
42017205:	0ced      	mov.n	a14, a12
42017207:	007c06        	j	420173fb <_vfiprintf_r+0x193b>
4201720a:	00          	.byte 00
4201720b:	00          	.byte 00
4201720c:	10c1d2        	addi	a13, a1, 16
4201720f:	241b      	addi.n	a2, a4, 1
42017211:	b033d0        	addx8	a3, a3, a13
42017214:	02a487        	bge	a4, a8, 4201721a <_vfiprintf_r+0x175a>
42017217:	009a46        	j	42017484 <_vfiprintf_r+0x19c4>
4201721a:	10c1e2        	addi	a14, a1, 16
4201721d:	922e72        	l32i	a7, a14, 0x248
42017220:	f91c      	movi.n	a9, 31
42017222:	02de42        	addmi	a4, a14, 0x200
42017225:	374b      	addi.n	a3, a7, 4
42017227:	851c      	movi.n	a5, 24
42017229:	02a987        	bge	a9, a8, 4201722f <_vfiprintf_r+0x176f>
4201722c:	008d06        	j	42017464 <_vfiprintf_r+0x19a4>
4201722f:	981b      	addi.n	a9, a8, 1
42017231:	926192        	s32i	a9, a1, 0x248
42017234:	126432        	s32i	a3, a4, 72
42017237:	052537        	blt	a5, a3, 42017240 <_vfiprintf_r+0x1780>
4201723a:	112432        	l32i	a3, a4, 68
4201723d:	000286        	j	4201724b <_vfiprintf_r+0x178b>
42017240:	012577        	blt	a5, a7, 42017245 <_vfiprintf_r+0x1785>
42017243:	432c      	movi.n	a3, 36
42017245:	966132        	s32i	a3, a1, 0x258
42017248:	942132        	l32i	a3, a1, 0x250
4201724b:	962142        	l32i	a4, a1, 0x258
4201724e:	334a      	add.n	a3, a3, a4
42017250:	fcc332        	addi	a3, a3, -4
42017253:	0358      	l32i.n	a5, a3, 0
42017255:	10c132        	addi	a3, a1, 16
42017258:	b08830        	addx8	a8, a8, a3
4201725b:	008006        	j	4201745f <_vfiprintf_r+0x199f>
4201725e:	972192        	l32i	a9, a1, 0x25c
42017261:	02e967        	bbsi	a9, 6, 42017267 <_vfiprintf_r+0x17a7>
42017264:	002d06        	j	4201731c <_vfiprintf_r+0x185c>
42017267:	55bc      	beqz.n	a5, 420172a0 <_vfiprintf_r+0x17e0>
42017269:	0ba387        	bge	a3, a8, 42017278 <_vfiprintf_r+0x17b8>
4201726c:	10c1a2        	addi	a10, a1, 16
4201726f:	b033a0        	addx8	a3, a3, a10
42017272:	001352        	l16ui	a5, a3, 0
42017275:	006546        	j	4201740e <_vfiprintf_r+0x194e>
42017278:	10c1c2        	addi	a12, a1, 16
4201727b:	34a252        	movi	a5, 0x234
4201727e:	38a2d2        	movi	a13, 0x238
42017281:	5c5a      	add.n	a5, a12, a5
42017283:	0ced      	mov.n	a14, a12
42017285:	01dcf2        	addmi	a15, a12, 0x100
42017288:	dcda      	add.n	a13, a12, a13
4201728a:	40a2c2        	movi	a12, 0x240
4201728d:	0159      	s32i.n	a5, a1, 0
4201728f:	ceca      	add.n	a12, a14, a12
42017291:	02bd      	mov.n	a11, a2
42017293:	03ad      	mov.n	a10, a3
42017295:	fe30e5        	call8	420155a4 <get_arg$constprop$0>
42017298:	001a52        	l16ui	a5, a10, 0
4201729b:	005bc6        	j	4201740e <_vfiprintf_r+0x194e>
4201729e:	00          	.byte 00
4201729f:	00          	.byte 00
420172a0:	10c1d2        	addi	a13, a1, 16
420172a3:	241b      	addi.n	a2, a4, 1
420172a5:	b033d0        	addx8	a3, a3, a13
420172a8:	682487        	blt	a4, a8, 42017314 <_vfiprintf_r+0x1854>
420172ab:	10c1e2        	addi	a14, a1, 16
420172ae:	922e72        	l32i	a7, a14, 0x248
420172b1:	f91c      	movi.n	a9, 31
420172b3:	02de42        	addmi	a4, a14, 0x200
420172b6:	374b      	addi.n	a3, a7, 4
420172b8:	851c      	movi.n	a5, 24
420172ba:	362987        	blt	a9, a8, 420172f4 <_vfiprintf_r+0x1834>
420172bd:	981b      	addi.n	a9, a8, 1
420172bf:	926192        	s32i	a9, a1, 0x248
420172c2:	126432        	s32i	a3, a4, 72
420172c5:	072537        	blt	a5, a3, 420172d0 <_vfiprintf_r+0x1810>
420172c8:	112432        	l32i	a3, a4, 68
420172cb:	000306        	j	420172db <_vfiprintf_r+0x181b>
420172ce:	00          	.byte 00
420172cf:	00          	.byte 00
420172d0:	012577        	blt	a5, a7, 420172d5 <_vfiprintf_r+0x1815>
420172d3:	432c      	movi.n	a3, 36
420172d5:	966132        	s32i	a3, a1, 0x258
420172d8:	942132        	l32i	a3, a1, 0x250
420172db:	962142        	l32i	a4, a1, 0x258
420172de:	334a      	add.n	a3, a3, a4
420172e0:	fcc332        	addi	a3, a3, -4
420172e3:	0358      	l32i.n	a5, a3, 0
420172e5:	10c132        	addi	a3, a1, 16
420172e8:	b08830        	addx8	a8, a8, a3
420172eb:	0859      	s32i.n	a5, a8, 0
420172ed:	f45050        	extui	a5, a5, 0, 16
420172f0:	006486        	j	42017486 <_vfiprintf_r+0x19c6>
420172f3:	00          	.byte 00
420172f4:	126432        	s32i	a3, a4, 72
420172f7:	052537        	blt	a5, a3, 42017300 <_vfiprintf_r+0x1840>
420172fa:	112432        	l32i	a3, a4, 68
420172fd:	000286        	j	4201730b <_vfiprintf_r+0x184b>
42017300:	012577        	blt	a5, a7, 42017305 <_vfiprintf_r+0x1845>
42017303:	432c      	movi.n	a3, 36
42017305:	966132        	s32i	a3, a1, 0x258
42017308:	942132        	l32i	a3, a1, 0x250
4201730b:	962142        	l32i	a4, a1, 0x258
4201730e:	803340        	add	a3, a3, a4
42017311:	fcc332        	addi	a3, a3, -4
42017314:	001352        	l16ui	a5, a3, 0
42017317:	005ac6        	j	42017486 <_vfiprintf_r+0x19c6>
4201731a:	00          	.byte 00
4201731b:	00          	.byte 00
4201731c:	972192        	l32i	a9, a1, 0x25c
4201731f:	02e997        	bbsi	a9, 9, 42017325 <_vfiprintf_r+0x1865>
42017322:	002d06        	j	420173da <_vfiprintf_r+0x191a>
42017325:	75bc      	beqz.n	a5, 42017360 <_vfiprintf_r+0x18a0>
42017327:	0da387        	bge	a3, a8, 42017338 <_vfiprintf_r+0x1878>
4201732a:	10c1a2        	addi	a10, a1, 16
4201732d:	b033a0        	addx8	a3, a3, a10
42017330:	000352        	l8ui	a5, a3, 0
42017333:	0035c6        	j	4201740e <_vfiprintf_r+0x194e>
42017336:	00          	.byte 00
42017337:	00          	.byte 00
42017338:	10c1c2        	addi	a12, a1, 16
4201733b:	34a252        	movi	a5, 0x234
4201733e:	38a2d2        	movi	a13, 0x238
42017341:	5c5a      	add.n	a5, a12, a5
42017343:	0ced      	mov.n	a14, a12
42017345:	01dcf2        	addmi	a15, a12, 0x100
42017348:	dcda      	add.n	a13, a12, a13
4201734a:	40a2c2        	movi	a12, 0x240
4201734d:	0159      	s32i.n	a5, a1, 0
4201734f:	ceca      	add.n	a12, a14, a12
42017351:	02bd      	mov.n	a11, a2
42017353:	03ad      	mov.n	a10, a3
42017355:	fe24e5        	call8	420155a4 <get_arg$constprop$0>
42017358:	000a52        	l8ui	a5, a10, 0
4201735b:	002bc6        	j	4201740e <_vfiprintf_r+0x194e>
4201735e:	00          	.byte 00
4201735f:	00          	.byte 00
42017360:	10c1d2        	addi	a13, a1, 16
42017363:	241b      	addi.n	a2, a4, 1
42017365:	b033d0        	addx8	a3, a3, a13
42017368:	682487        	blt	a4, a8, 420173d4 <_vfiprintf_r+0x1914>
4201736b:	10c1e2        	addi	a14, a1, 16
4201736e:	922e72        	l32i	a7, a14, 0x248
42017371:	f91c      	movi.n	a9, 31
42017373:	02de42        	addmi	a4, a14, 0x200
42017376:	374b      	addi.n	a3, a7, 4
42017378:	851c      	movi.n	a5, 24
4201737a:	362987        	blt	a9, a8, 420173b4 <_vfiprintf_r+0x18f4>
4201737d:	981b      	addi.n	a9, a8, 1
4201737f:	926192        	s32i	a9, a1, 0x248
42017382:	126432        	s32i	a3, a4, 72
42017385:	072537        	blt	a5, a3, 42017390 <_vfiprintf_r+0x18d0>
42017388:	112432        	l32i	a3, a4, 68
4201738b:	000306        	j	4201739b <_vfiprintf_r+0x18db>
4201738e:	00          	.byte 00
4201738f:	00          	.byte 00
42017390:	012577        	blt	a5, a7, 42017395 <_vfiprintf_r+0x18d5>
42017393:	432c      	movi.n	a3, 36
42017395:	966132        	s32i	a3, a1, 0x258
42017398:	942132        	l32i	a3, a1, 0x250
4201739b:	962142        	l32i	a4, a1, 0x258
4201739e:	334a      	add.n	a3, a3, a4
420173a0:	fcc332        	addi	a3, a3, -4
420173a3:	0358      	l32i.n	a5, a3, 0
420173a5:	10c132        	addi	a3, a1, 16
420173a8:	b08830        	addx8	a8, a8, a3
420173ab:	0859      	s32i.n	a5, a8, 0
420173ad:	745050        	extui	a5, a5, 0, 8
420173b0:	003486        	j	42017486 <_vfiprintf_r+0x19c6>
420173b3:	00          	.byte 00
420173b4:	126432        	s32i	a3, a4, 72
420173b7:	052537        	blt	a5, a3, 420173c0 <_vfiprintf_r+0x1900>
420173ba:	112432        	l32i	a3, a4, 68
420173bd:	000286        	j	420173cb <_vfiprintf_r+0x190b>
420173c0:	012577        	blt	a5, a7, 420173c5 <_vfiprintf_r+0x1905>
420173c3:	432c      	movi.n	a3, 36
420173c5:	966132        	s32i	a3, a1, 0x258
420173c8:	942132        	l32i	a3, a1, 0x250
420173cb:	962142        	l32i	a4, a1, 0x258
420173ce:	803340        	add	a3, a3, a4
420173d1:	fcc332        	addi	a3, a3, -4
420173d4:	000352        	l8ui	a5, a3, 0
420173d7:	002ac6        	j	42017486 <_vfiprintf_r+0x19c6>
420173da:	65bc      	beqz.n	a5, 42017414 <_vfiprintf_r+0x1954>
420173dc:	0ca387        	bge	a3, a8, 420173ec <_vfiprintf_r+0x192c>
420173df:	10c182        	addi	a8, a1, 16
420173e2:	b03380        	addx8	a3, a3, a8
420173e5:	0358      	l32i.n	a5, a3, 0
420173e7:	0008c6        	j	4201740e <_vfiprintf_r+0x194e>
420173ea:	00          	.byte 00
420173eb:	00          	.byte 00
420173ec:	10c192        	addi	a9, a1, 16
420173ef:	34a252        	movi	a5, 0x234
420173f2:	595a      	add.n	a5, a9, a5
420173f4:	0159      	s32i.n	a5, a1, 0
420173f6:	01d9f2        	addmi	a15, a9, 0x100
420173f9:	09ed      	mov.n	a14, a9
420173fb:	38a2d2        	movi	a13, 0x238
420173fe:	40a2c2        	movi	a12, 0x240
42017401:	deda      	add.n	a13, a14, a13
42017403:	ceca      	add.n	a12, a14, a12
42017405:	02bd      	mov.n	a11, a2
42017407:	03ad      	mov.n	a10, a3
42017409:	fe19a5        	call8	420155a4 <get_arg$constprop$0>
4201740c:	0a58      	l32i.n	a5, a10, 0
4201740e:	042d      	mov.n	a2, a4
42017410:	001c86        	j	42017486 <_vfiprintf_r+0x19c6>
42017413:	00          	.byte 00
42017414:	10c1a2        	addi	a10, a1, 16
42017417:	241b      	addi.n	a2, a4, 1
42017419:	b033a0        	addx8	a3, a3, a10
4201741c:	642487        	blt	a4, a8, 42017484 <_vfiprintf_r+0x19c4>
4201741f:	10c1c2        	addi	a12, a1, 16
42017422:	922c72        	l32i	a7, a12, 0x248
42017425:	f91c      	movi.n	a9, 31
42017427:	02dc42        	addmi	a4, a12, 0x200
4201742a:	374b      	addi.n	a3, a7, 4
4201742c:	851c      	movi.n	a5, 24
4201742e:	322987        	blt	a9, a8, 42017464 <_vfiprintf_r+0x19a4>
42017431:	981b      	addi.n	a9, a8, 1
42017433:	926192        	s32i	a9, a1, 0x248
42017436:	126432        	s32i	a3, a4, 72
42017439:	072537        	blt	a5, a3, 42017444 <_vfiprintf_r+0x1984>
4201743c:	112432        	l32i	a3, a4, 68
4201743f:	000306        	j	4201744f <_vfiprintf_r+0x198f>
42017442:	00          	.byte 00
42017443:	00          	.byte 00
42017444:	012577        	blt	a5, a7, 42017449 <_vfiprintf_r+0x1989>
42017447:	432c      	movi.n	a3, 36
42017449:	966132        	s32i	a3, a1, 0x258
4201744c:	942132        	l32i	a3, a1, 0x250
4201744f:	962142        	l32i	a4, a1, 0x258
42017452:	10c1e2        	addi	a14, a1, 16
42017455:	334a      	add.n	a3, a3, a4
42017457:	fcc332        	addi	a3, a3, -4
4201745a:	0358      	l32i.n	a5, a3, 0
4201745c:	b088e0        	addx8	a8, a8, a14
4201745f:	0859      	s32i.n	a5, a8, 0
42017461:	000846        	j	42017486 <_vfiprintf_r+0x19c6>
42017464:	126432        	s32i	a3, a4, 72
42017467:	052537        	blt	a5, a3, 42017470 <_vfiprintf_r+0x19b0>
4201746a:	112432        	l32i	a3, a4, 68
4201746d:	000286        	j	4201747b <_vfiprintf_r+0x19bb>
42017470:	012577        	blt	a5, a7, 42017475 <_vfiprintf_r+0x19b5>
42017473:	432c      	movi.n	a3, 36
42017475:	966132        	s32i	a3, a1, 0x258
42017478:	942132        	l32i	a3, a1, 0x250
4201747b:	962142        	l32i	a4, a1, 0x258
4201747e:	803340        	add	a3, a3, a4
42017481:	fcc332        	addi	a3, a3, -4
42017484:	0358      	l32i.n	a5, a3, 0
42017486:	070c      	movi.n	a7, 0
42017488:	203570        	or	a3, a5, a7
4201748b:	e39c      	beqz.n	a3, 420174ad <_vfiprintf_r+0x19ed>
4201748d:	972132        	l32i	a3, a1, 0x25c
42017490:	196307        	bbci	a3, 0, 420174ad <_vfiprintf_r+0x19ed>
42017493:	10c182        	addi	a8, a1, 16
42017496:	02d832        	addmi	a3, a8, 0x200
42017499:	972192        	l32i	a9, a1, 0x25c
4201749c:	043c      	movi.n	a4, 48
4201749e:	3c4342        	s8i	a4, a3, 60
420174a1:	3d4362        	s8i	a6, a3, 61
420174a4:	02a032        	movi	a3, 2
420174a7:	209930        	or	a9, a9, a3
420174aa:	976192        	s32i	a9, a1, 0x25c
420174ad:	972142        	l32i	a4, a1, 0x25c
420174b0:	ffab32        	movi	a3, 0xfffffbff
420174b3:	104430        	and	a4, a4, a3
420174b6:	976142        	s32i	a4, a1, 0x25c
420174b9:	240c      	movi.n	a4, 2
420174bb:	00a032        	movi	a3, 0
420174be:	10c182        	addi	a8, a1, 16
420174c1:	02d862        	addmi	a6, a8, 0x200
420174c4:	9a2192        	l32i	a9, a1, 0x268
420174c7:	3e4632        	s8i	a3, a6, 62
420174ca:	260926        	beqi	a9, -1, 420174f4 <_vfiprintf_r+0x1a34>
420174cd:	972162        	l32i	a6, a1, 0x25c
420174d0:	972182        	l32i	a8, a1, 0x25c
420174d3:	7faf32        	movi	a3, -129
420174d6:	108830        	and	a8, a8, a3
420174d9:	209570        	or	a9, a5, a7
420174dc:	976182        	s32i	a8, a1, 0x25c
420174df:	130c      	movi.n	a3, 1
420174e1:	080c      	movi.n	a8, 0
420174e3:	938390        	movnez	a8, a3, a9
420174e6:	749080        	extui	a9, a8, 0, 8
420174e9:	78cc      	bnez.n	a8, 420174f4 <_vfiprintf_r+0x1a34>
420174eb:	9a2182        	l32i	a8, a1, 0x268
420174ee:	833980        	moveqz	a3, a9, a8
420174f1:	134316        	beqz	a3, 42017629 <_vfiprintf_r+0x1b69>
420174f4:	501426        	beqi	a4, 1, 42017548 <_vfiprintf_r+0x1a88>
420174f7:	90a192        	movi	a9, 0x190
420174fa:	991a      	add.n	a9, a9, a1
420174fc:	64c932        	addi	a3, a9, 100
420174ff:	022466        	bnei	a4, 2, 42017505 <_vfiprintf_r+0x1a45>
42017502:	003f86        	j	42017604 <_vfiprintf_r+0x1b44>
42017505:	018730        	slli	a8, a7, 29
42017508:	244050        	extui	a4, a5, 0, 3
4201750b:	415350        	srli	a5, a5, 3
4201750e:	036d      	mov.n	a6, a3
42017510:	30c442        	addi	a4, a4, 48
42017513:	330b      	addi.n	a3, a3, -1
42017515:	205850        	or	a5, a8, a5
42017518:	417370        	srli	a7, a7, 3
4201751b:	004342        	s8i	a4, a3, 0
4201751e:	208570        	or	a8, a5, a7
42017521:	fe0856        	bnez	a8, 42017505 <_vfiprintf_r+0x1a45>
42017524:	d0c452        	addi	a5, a4, -48
42017527:	140c      	movi.n	a4, 1
42017529:	834850        	moveqz	a4, a8, a5
4201752c:	744040        	extui	a4, a4, 0, 8
4201752f:	11d416        	beqz	a4, 42017650 <_vfiprintf_r+0x1b90>
42017532:	972142        	l32i	a4, a1, 0x25c
42017535:	02e407        	bbsi	a4, 0, 4201753b <_vfiprintf_r+0x1a7b>
42017538:	004506        	j	42017650 <_vfiprintf_r+0x1b90>
4201753b:	330b      	addi.n	a3, a3, -1
4201753d:	043c      	movi.n	a4, 48
4201753f:	004342        	s8i	a4, a3, 0
42017542:	fec632        	addi	a3, a6, -2
42017545:	0041c6        	j	42017650 <_vfiprintf_r+0x1b90>
42017548:	87dc      	bnez.n	a7, 42017564 <_vfiprintf_r+0x1aa4>
4201754a:	930c      	movi.n	a3, 9
4201754c:	143357        	bltu	a3, a5, 42017564 <_vfiprintf_r+0x1aa4>
4201754f:	10c162        	addi	a6, a1, 16
42017552:	30c552        	addi	a5, a5, 48
42017555:	01d632        	addmi	a3, a6, 0x100
42017558:	90a182        	movi	a8, 0x190
4201755b:	e34352        	s8i	a5, a3, 227
4201755e:	881a      	add.n	a8, a8, a1
42017560:	003a46        	j	4201764d <_vfiprintf_r+0x1b8d>
42017563:	00          	.byte 00
42017564:	972192        	l32i	a9, a1, 0x25c
42017567:	00a442        	movi	a4, 0x400
4201756a:	a42132        	l32i	a3, a1, 0x290
4201756d:	060c      	movi.n	a6, 0
4201756f:	104940        	and	a4, a9, a4
42017572:	000106        	j	4201757a <_vfiprintf_r+0x1aba>
42017575:	00          	.byte 00
42017576:	0a5d      	mov.n	a5, a10
42017578:	0b7d      	mov.n	a7, a11
4201757a:	ac0c      	movi.n	a12, 10
4201757c:	0d0c      	movi.n	a13, 0
4201757e:	20a550        	or	a10, a5, a5
42017581:	20b770        	or	a11, a7, a7
42017584:	a5a481        	l32r	a8, 42000c14 <_stext+0xbf4>
42017587:	0008e0        	callx8	a8
4201758a:	330b      	addi.n	a3, a3, -1
4201758c:	30caa2        	addi	a10, a10, 48
4201758f:	0043a2        	s8i	a10, a3, 0
42017592:	661b      	addi.n	a6, a6, 1
42017594:	04e416        	beqz	a4, 420175e6 <_vfiprintf_r+0x1b26>
42017597:	a12182        	l32i	a8, a1, 0x284
4201759a:	1c0c      	movi.n	a12, 1
4201759c:	0008b2        	l8ui	a11, a8, 0
4201759f:	57cc      	bnez.n	a7, 420175a8 <_vfiprintf_r+0x1ae8>
420175a1:	980c      	movi.n	a8, 9
420175a3:	013857        	bltu	a8, a5, 420175a8 <_vfiprintf_r+0x1ae8>
420175a6:	07cd      	mov.n	a12, a7
420175a8:	01afa2        	movi	a10, -255
420175ab:	abaa      	add.n	a10, a11, a10
420175ad:	090c      	movi.n	a9, 0
420175af:	180c      	movi.n	a8, 1
420175b1:	8389a0        	moveqz	a8, a9, a10
420175b4:	2e08c7        	bnone	a8, a12, 420175e6 <_vfiprintf_r+0x1b26>
420175b7:	2b9b67        	bne	a11, a6, 420175e6 <_vfiprintf_r+0x1b26>
420175ba:	a22162        	l32i	a6, a1, 0x288
420175bd:	a321b2        	l32i	a11, a1, 0x28c
420175c0:	c03360        	sub	a3, a3, a6
420175c3:	06cd      	mov.n	a12, a6
420175c5:	20a330        	or	a10, a3, a3
420175c8:	a66192        	s32i	a9, a1, 0x298
420175cb:	a54e81        	l32r	a8, 42000b04 <_stext+0xae4>
420175ce:	0008e0        	callx8	a8
420175d1:	a12162        	l32i	a6, a1, 0x284
420175d4:	a62192        	l32i	a9, a1, 0x298
420175d7:	010682        	l8ui	a8, a6, 1
420175da:	096d      	mov.n	a6, a9
420175dc:	688c      	beqz.n	a8, 420175e6 <_vfiprintf_r+0x1b26>
420175de:	a12182        	l32i	a8, a1, 0x284
420175e1:	881b      	addi.n	a8, a8, 1
420175e3:	a16182        	s32i	a8, a1, 0x284
420175e6:	ac0c      	movi.n	a12, 10
420175e8:	0d0c      	movi.n	a13, 0
420175ea:	05ad      	mov.n	a10, a5
420175ec:	07bd      	mov.n	a11, a7
420175ee:	a2ac81        	l32r	a8, 420000a0 <_stext+0x80>
420175f1:	0008e0        	callx8	a8
420175f4:	f7e756        	bnez	a7, 42017576 <_vfiprintf_r+0x1ab6>
420175f7:	970c      	movi.n	a7, 9
420175f9:	02b757        	bgeu	a7, a5, 420175ff <_vfiprintf_r+0x1b3f>
420175fc:	ffdd86        	j	42017576 <_vfiprintf_r+0x1ab6>
420175ff:	001346        	j	42017650 <_vfiprintf_r+0x1b90>
42017602:	00          	.byte 00
42017603:	00          	.byte 00
42017604:	9f2162        	l32i	a6, a1, 0x27c
42017607:	344050        	extui	a4, a5, 0, 4
4201760a:	464a      	add.n	a4, a6, a4
4201760c:	000442        	l8ui	a4, a4, 0
4201760f:	330b      	addi.n	a3, a3, -1
42017611:	004342        	s8i	a4, a3, 0
42017614:	415450        	srli	a5, a5, 4
42017617:	014740        	slli	a4, a7, 28
4201761a:	205450        	or	a5, a4, a5
4201761d:	417470        	srli	a7, a7, 4
42017620:	204570        	or	a4, a5, a7
42017623:	fdd456        	bnez	a4, 42017604 <_vfiprintf_r+0x1b44>
42017626:	000986        	j	42017650 <_vfiprintf_r+0x1b90>
42017629:	90a182        	movi	a8, 0x190
4201762c:	9a6132        	s32i	a3, a1, 0x268
4201762f:	881a      	add.n	a8, a8, a1
42017631:	64c832        	addi	a3, a8, 100
42017634:	84dc      	bnez.n	a4, 42017650 <_vfiprintf_r+0x1b90>
42017636:	046060        	extui	a6, a6, 0, 1
42017639:	9a6162        	s32i	a6, a1, 0x268
4201763c:	069c      	beqz.n	a6, 42017650 <_vfiprintf_r+0x1b90>
4201763e:	10c192        	addi	a9, a1, 16
42017641:	30a052        	movi	a5, 48
42017644:	01d932        	addmi	a3, a9, 0x100
42017647:	e34352        	s8i	a5, a3, 227
4201764a:	9a6142        	s32i	a4, a1, 0x268
4201764d:	63c832        	addi	a3, a8, 99
42017650:	a42152        	l32i	a5, a1, 0x290
42017653:	9a2142        	l32i	a4, a1, 0x268
42017656:	c05530        	sub	a5, a5, a3
42017659:	9a6152        	s32i	a5, a1, 0x268
4201765c:	000946        	j	42017685 <_vfiprintf_r+0x1bc5>
4201765f:	00          	.byte 00
42017660:	3dc616        	beqz	a6, 42017a40 <_vfiprintf_r+0x1f80>
42017663:	10c182        	addi	a8, a1, 16
42017666:	01d822        	addmi	a2, a8, 0x100
42017669:	030c      	movi.n	a3, 0
4201766b:	804262        	s8i	a6, a2, 128
4201766e:	190c      	movi.n	a9, 1
42017670:	02d822        	addmi	a2, a8, 0x200
42017673:	90a1a2        	movi	a10, 0x190
42017676:	3e4232        	s8i	a3, a2, 62
42017679:	9a6192        	s32i	a9, a1, 0x268
4201767c:	202440        	or	a2, a4, a4
4201767f:	8031a0        	add	a3, a1, a10
42017682:	00a042        	movi	a4, 0
42017685:	9a2162        	l32i	a6, a1, 0x268
42017688:	10c182        	addi	a8, a1, 16
4201768b:	535460        	max	a5, a4, a6
4201768e:	02d862        	addmi	a6, a8, 0x200
42017691:	3e0662        	l8ui	a6, a6, 62
42017694:	068c      	beqz.n	a6, 42017698 <_vfiprintf_r+0x1bd8>
42017696:	551b      	addi.n	a5, a5, 1
42017698:	972192        	l32i	a9, a1, 0x25c
4201769b:	270c      	movi.n	a7, 2
4201769d:	107970        	and	a7, a9, a7
420176a0:	078c      	beqz.n	a7, 420176a4 <_vfiprintf_r+0x1be4>
420176a2:	552b      	addi.n	a5, a5, 2
420176a4:	972182        	l32i	a8, a1, 0x25c
420176a7:	84a062        	movi	a6, 132
420176aa:	106860        	and	a6, a8, a6
420176ad:	0a1656        	bnez	a6, 42017752 <_vfiprintf_r+0x1c92>
420176b0:	9d2192        	l32i	a9, a1, 0x274
420176b3:	c08950        	sub	a8, a9, a5
420176b6:	0218e6        	bgei	a8, 1, 420176bc <_vfiprintf_r+0x1bfc>
420176b9:	002546        	j	42017752 <_vfiprintf_r+0x1c92>
420176bc:	0e1c      	movi.n	a14, 16
420176be:	24a2d2        	movi	a13, 0x224
420176c1:	f1ea      	add.n	a15, a1, a14
420176c3:	ffda      	add.n	a15, a15, a13
420176c5:	a061f2        	s32i	a15, a1, 0x280
420176c8:	000fc6        	j	4201770b <_vfiprintf_r+0x1c4b>
420176cb:	00          	.byte 00
420176cc:	9821d2        	l32i	a13, a1, 0x260
420176cf:	a595f1        	l32r	a15, 42000d24 <_stext+0xd04>
420176d2:	10ccc2        	addi	a12, a12, 16
420176d5:	0df9      	s32i.n	a15, a13, 0
420176d7:	016de2        	s32i	a14, a13, 4
420176da:	bac9      	s32i.n	a12, a10, 44
420176dc:	0a6a92        	s32i	a9, a10, 40
420176df:	2289a6        	blti	a9, 8, 42017705 <_vfiprintf_r+0x1c45>
420176e2:	a021c2        	l32i	a12, a1, 0x280
420176e5:	9921b2        	l32i	a11, a1, 0x264
420176e8:	9c21a2        	l32i	a10, a1, 0x270
420176eb:	a76182        	s32i	a8, a1, 0x29c
420176ee:	a561e2        	s32i	a14, a1, 0x294
420176f1:	fe3aa5        	call8	42015a9c <__sprint_r>
420176f4:	a72182        	l32i	a8, a1, 0x29c
420176f7:	a521e2        	l32i	a14, a1, 0x294
420176fa:	366a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
420176fd:	e4a1b2        	movi	a11, 0x1e4
42017700:	10c192        	addi	a9, a1, 16
42017703:	b9ba      	add.n	a11, a9, a11
42017705:	f0c882        	addi	a8, a8, -16
42017708:	9861b2        	s32i	a11, a1, 0x260
4201770b:	10c1c2        	addi	a12, a1, 16
4201770e:	9821d2        	l32i	a13, a1, 0x260
42017711:	8a2c92        	l32i	a9, a12, 0x228
42017714:	02dca2        	addmi	a10, a12, 0x200
42017717:	bac8      	l32i.n	a12, a10, 44
42017719:	991b      	addi.n	a9, a9, 1
4201771b:	bd8b      	addi.n	a11, a13, 8
4201771d:	ab2e87        	blt	a14, a8, 420176cc <_vfiprintf_r+0x1c0c>
42017720:	a581e1        	l32r	a14, 42000d24 <_stext+0xd04>
42017723:	1d89      	s32i.n	a8, a13, 4
42017725:	88ca      	add.n	a8, a8, a12
42017727:	0de9      	s32i.n	a14, a13, 0
42017729:	ba89      	s32i.n	a8, a10, 44
4201772b:	aa99      	s32i.n	a9, a10, 40
4201772d:	9861b2        	s32i	a11, a1, 0x260
42017730:	1e89a6        	blti	a9, 8, 42017752 <_vfiprintf_r+0x1c92>
42017733:	24a2c2        	movi	a12, 0x224
42017736:	10c1f2        	addi	a15, a1, 16
42017739:	9921b2        	l32i	a11, a1, 0x264
4201773c:	9c21a2        	l32i	a10, a1, 0x270
4201773f:	cfca      	add.n	a12, a15, a12
42017741:	fe35a5        	call8	42015a9c <__sprint_r>
42017744:	31ca56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
42017747:	e4a182        	movi	a8, 0x1e4
4201774a:	10c192        	addi	a9, a1, 16
4201774d:	998a      	add.n	a9, a9, a8
4201774f:	986192        	s32i	a9, a1, 0x260
42017752:	10c1c2        	addi	a12, a1, 16
42017755:	02dca2        	addmi	a10, a12, 0x200
42017758:	3e0a92        	l8ui	a9, a10, 62
4201775b:	8f2182        	l32i	a8, a1, 0x23c
4201775e:	8e21b2        	l32i	a11, a1, 0x238
42017761:	043916        	beqz	a9, 420177a8 <_vfiprintf_r+0x1ce8>
42017764:	9821d2        	l32i	a13, a1, 0x260
42017767:	3ea292        	movi	a9, 0x23e
4201776a:	9c9a      	add.n	a9, a12, a9
4201776c:	0d99      	s32i.n	a9, a13, 0
4201776e:	190c      	movi.n	a9, 1
42017770:	bb1b      	addi.n	a11, a11, 1
42017772:	889a      	add.n	a8, a8, a9
42017774:	1d99      	s32i.n	a9, a13, 4
42017776:	8f6182        	s32i	a8, a1, 0x23c
42017779:	8e61b2        	s32i	a11, a1, 0x238
4201777c:	088be6        	bgei	a11, 8, 42017788 <_vfiprintf_r+0x1cc8>
4201777f:	dd8b      	addi.n	a13, a13, 8
42017781:	9861d2        	s32i	a13, a1, 0x260
42017784:	000806        	j	420177a8 <_vfiprintf_r+0x1ce8>
42017787:	00          	.byte 00
42017788:	24a2c2        	movi	a12, 0x224
4201778b:	10c1e2        	addi	a14, a1, 16
4201778e:	9921b2        	l32i	a11, a1, 0x264
42017791:	9c21a2        	l32i	a10, a1, 0x270
42017794:	ceca      	add.n	a12, a14, a12
42017796:	fe3065        	call8	42015a9c <__sprint_r>
42017799:	2c7a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
4201779c:	e4a182        	movi	a8, 0x1e4
4201779f:	10c192        	addi	a9, a1, 16
420177a2:	809980        	add	a9, a9, a8
420177a5:	986192        	s32i	a9, a1, 0x260
420177a8:	8f21b2        	l32i	a11, a1, 0x23c
420177ab:	8e2192        	l32i	a9, a1, 0x238
420177ae:	10c1c2        	addi	a12, a1, 16
420177b1:	043716        	beqz	a7, 420177f8 <_vfiprintf_r+0x1d38>
420177b4:	9821d2        	l32i	a13, a1, 0x260
420177b7:	270c      	movi.n	a7, 2
420177b9:	3ca282        	movi	a8, 0x23c
420177bc:	991b      	addi.n	a9, a9, 1
420177be:	8c8a      	add.n	a8, a12, a8
420177c0:	1d79      	s32i.n	a7, a13, 4
420177c2:	7b7a      	add.n	a7, a11, a7
420177c4:	0d89      	s32i.n	a8, a13, 0
420177c6:	8f6172        	s32i	a7, a1, 0x23c
420177c9:	8e6192        	s32i	a9, a1, 0x238
420177cc:	0889e6        	bgei	a9, 8, 420177d8 <_vfiprintf_r+0x1d18>
420177cf:	dd8b      	addi.n	a13, a13, 8
420177d1:	9861d2        	s32i	a13, a1, 0x260
420177d4:	000806        	j	420177f8 <_vfiprintf_r+0x1d38>
420177d7:	00          	.byte 00
420177d8:	24a2c2        	movi	a12, 0x224
420177db:	10c1e2        	addi	a14, a1, 16
420177de:	9921b2        	l32i	a11, a1, 0x264
420177e1:	9c21a2        	l32i	a10, a1, 0x270
420177e4:	ceca      	add.n	a12, a14, a12
420177e6:	fe2b65        	call8	42015a9c <__sprint_r>
420177e9:	277a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
420177ec:	e4a172        	movi	a7, 0x1e4
420177ef:	10c182        	addi	a8, a1, 16
420177f2:	808870        	add	a8, a8, a7
420177f5:	986182        	s32i	a8, a1, 0x260
420177f8:	02e626        	beqi	a6, 128, 420177fe <_vfiprintf_r+0x1d3e>
420177fb:	0027c6        	j	4201789e <_vfiprintf_r+0x1dde>
420177fe:	9d2192        	l32i	a9, a1, 0x274
42017801:	c06950        	sub	a6, a9, a5
42017804:	0216e6        	bgei	a6, 1, 4201780a <_vfiprintf_r+0x1d4a>
42017807:	0024c6        	j	4201789e <_vfiprintf_r+0x1dde>
4201780a:	0d1c      	movi.n	a13, 16
4201780c:	24a292        	movi	a9, 0x224
4201780f:	a1da      	add.n	a10, a1, a13
42017811:	9a9a      	add.n	a9, a10, a9
42017813:	000f06        	j	42017853 <_vfiprintf_r+0x1d93>
42017816:	00          	.byte 00
42017817:	00          	.byte 00
42017818:	9821e2        	l32i	a14, a1, 0x260
4201781b:	10cbb2        	addi	a11, a11, 16
4201781e:	0ec9      	s32i.n	a12, a14, 0
42017820:	1ed9      	s32i.n	a13, a14, 4
42017822:	0b68b2        	s32i	a11, a8, 44
42017825:	0a6872        	s32i	a7, a8, 40
42017828:	2187a6        	blti	a7, 8, 4201784d <_vfiprintf_r+0x1d8d>
4201782b:	9921b2        	l32i	a11, a1, 0x264
4201782e:	9c21a2        	l32i	a10, a1, 0x270
42017831:	09cd      	mov.n	a12, a9
42017833:	a66192        	s32i	a9, a1, 0x298
42017836:	a561d2        	s32i	a13, a1, 0x294
42017839:	fe2625        	call8	42015a9c <__sprint_r>
4201783c:	a62192        	l32i	a9, a1, 0x298
4201783f:	a521d2        	l32i	a13, a1, 0x294
42017842:	21ea56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
42017845:	e4a1a2        	movi	a10, 0x1e4
42017848:	10c1f2        	addi	a15, a1, 16
4201784b:	afaa      	add.n	a10, a15, a10
4201784d:	f0c662        	addi	a6, a6, -16
42017850:	9861a2        	s32i	a10, a1, 0x260
42017853:	10c1a2        	addi	a10, a1, 16
42017856:	9821c2        	l32i	a12, a1, 0x260
42017859:	8a2a72        	l32i	a7, a10, 0x228
4201785c:	02da82        	addmi	a8, a10, 0x200
4201785f:	771b      	addi.n	a7, a7, 1
42017861:	ac8b      	addi.n	a10, a12, 8
42017863:	b8b8      	l32i.n	a11, a8, 44
42017865:	a530c1        	l32r	a12, 42000d28 <_stext+0xd08>
42017868:	ac2d67        	blt	a13, a6, 42017818 <_vfiprintf_r+0x1d58>
4201786b:	982192        	l32i	a9, a1, 0x260
4201786e:	a879      	s32i.n	a7, a8, 40
42017870:	1969      	s32i.n	a6, a9, 4
42017872:	66ba      	add.n	a6, a6, a11
42017874:	09c9      	s32i.n	a12, a9, 0
42017876:	0b6862        	s32i	a6, a8, 44
42017879:	9861a2        	s32i	a10, a1, 0x260
4201787c:	1e87a6        	blti	a7, 8, 4201789e <_vfiprintf_r+0x1dde>
4201787f:	10c1a2        	addi	a10, a1, 16
42017882:	24a2c2        	movi	a12, 0x224
42017885:	caca      	add.n	a12, a10, a12
42017887:	9921b2        	l32i	a11, a1, 0x264
4201788a:	9c21a2        	l32i	a10, a1, 0x270
4201788d:	fe20e5        	call8	42015a9c <__sprint_r>
42017890:	1d0a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
42017893:	e4a162        	movi	a6, 0x1e4
42017896:	10c182        	addi	a8, a1, 16
42017899:	886a      	add.n	a8, a8, a6
4201789b:	986182        	s32i	a8, a1, 0x260
4201789e:	9a2192        	l32i	a9, a1, 0x268
420178a1:	c04490        	sub	a4, a4, a9
420178a4:	0214e6        	bgei	a4, 1, 420178aa <_vfiprintf_r+0x1dea>
420178a7:	0023c6        	j	4201793a <_vfiprintf_r+0x1e7a>
420178aa:	091c      	movi.n	a9, 16
420178ac:	24a282        	movi	a8, 0x224
420178af:	a19a      	add.n	a10, a1, a9
420178b1:	8a8a      	add.n	a8, a10, a8
420178b3:	000f06        	j	420178f3 <_vfiprintf_r+0x1e33>
420178b6:	00          	.byte 00
420178b7:	00          	.byte 00
420178b8:	9821d2        	l32i	a13, a1, 0x260
420178bb:	10cbb2        	addi	a11, a11, 16
420178be:	0dc9      	s32i.n	a12, a13, 0
420178c0:	1d99      	s32i.n	a9, a13, 4
420178c2:	0b67b2        	s32i	a11, a7, 44
420178c5:	a769      	s32i.n	a6, a7, 40
420178c7:	2286a6        	blti	a6, 8, 420178ed <_vfiprintf_r+0x1e2d>
420178ca:	9921b2        	l32i	a11, a1, 0x264
420178cd:	9c21a2        	l32i	a10, a1, 0x270
420178d0:	20c880        	or	a12, a8, a8
420178d3:	a76182        	s32i	a8, a1, 0x29c
420178d6:	a66192        	s32i	a9, a1, 0x298
420178d9:	fe1c25        	call8	42015a9c <__sprint_r>
420178dc:	a72182        	l32i	a8, a1, 0x29c
420178df:	a62192        	l32i	a9, a1, 0x298
420178e2:	17ea56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
420178e5:	e4a1a2        	movi	a10, 0x1e4
420178e8:	10c1e2        	addi	a14, a1, 16
420178eb:	aeaa      	add.n	a10, a14, a10
420178ed:	f0c442        	addi	a4, a4, -16
420178f0:	9861a2        	s32i	a10, a1, 0x260
420178f3:	10c1f2        	addi	a15, a1, 16
420178f6:	9821c2        	l32i	a12, a1, 0x260
420178f9:	8a2f62        	l32i	a6, a15, 0x228
420178fc:	02df72        	addmi	a7, a15, 0x200
420178ff:	ac8b      	addi.n	a10, a12, 8
42017901:	661b      	addi.n	a6, a6, 1
42017903:	a509c1        	l32r	a12, 42000d28 <_stext+0xd08>
42017906:	b7b8      	l32i.n	a11, a7, 44
42017908:	ac2947        	blt	a9, a4, 420178b8 <_vfiprintf_r+0x1df8>
4201790b:	982182        	l32i	a8, a1, 0x260
4201790e:	a769      	s32i.n	a6, a7, 40
42017910:	1849      	s32i.n	a4, a8, 4
42017912:	44ba      	add.n	a4, a4, a11
42017914:	08c9      	s32i.n	a12, a8, 0
42017916:	b749      	s32i.n	a4, a7, 44
42017918:	9861a2        	s32i	a10, a1, 0x260
4201791b:	1b86a6        	blti	a6, 8, 4201793a <_vfiprintf_r+0x1e7a>
4201791e:	24a2c2        	movi	a12, 0x224
42017921:	9921b2        	l32i	a11, a1, 0x264
42017924:	9c21a2        	l32i	a10, a1, 0x270
42017927:	cfca      	add.n	a12, a15, a12
42017929:	fe1725        	call8	42015a9c <__sprint_r>
4201792c:	134a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
4201792f:	e4a142        	movi	a4, 0x1e4
42017932:	10c192        	addi	a9, a1, 16
42017935:	994a      	add.n	a9, a9, a4
42017937:	986192        	s32i	a9, a1, 0x260
4201793a:	982142        	l32i	a4, a1, 0x260
4201793d:	9a2162        	l32i	a6, a1, 0x268
42017940:	0439      	s32i.n	a3, a4, 0
42017942:	8f2132        	l32i	a3, a1, 0x23c
42017945:	1469      	s32i.n	a6, a4, 4
42017947:	336a      	add.n	a3, a3, a6
42017949:	8f6132        	s32i	a3, a1, 0x23c
4201794c:	8e2132        	l32i	a3, a1, 0x238
4201794f:	331b      	addi.n	a3, a3, 1
42017951:	8e6132        	s32i	a3, a1, 0x238
42017954:	0883e6        	bgei	a3, 8, 42017960 <_vfiprintf_r+0x1ea0>
42017957:	982192        	l32i	a9, a1, 0x260
4201795a:	398b      	addi.n	a3, a9, 8
4201795c:	000706        	j	4201797c <_vfiprintf_r+0x1ebc>
4201795f:	00          	.byte 00
42017960:	10c1a2        	addi	a10, a1, 16
42017963:	24a2c2        	movi	a12, 0x224
42017966:	caca      	add.n	a12, a10, a12
42017968:	9921b2        	l32i	a11, a1, 0x264
4201796b:	9c21a2        	l32i	a10, a1, 0x270
4201796e:	fe12e5        	call8	42015a9c <__sprint_r>
42017971:	0efa56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
42017974:	e4a132        	movi	a3, 0x1e4
42017977:	10c1c2        	addi	a12, a1, 16
4201797a:	3c3a      	add.n	a3, a12, a3
4201797c:	972142        	l32i	a4, a1, 0x25c
4201797f:	16e427        	bbsi	a4, 2, 42017999 <_vfiprintf_r+0x1ed9>
42017982:	9d2162        	l32i	a6, a1, 0x274
42017985:	9e2182        	l32i	a8, a1, 0x278
42017988:	535650        	max	a5, a6, a5
4201798b:	885a      	add.n	a8, a8, a5
4201798d:	8f2132        	l32i	a3, a1, 0x23c
42017990:	9e6182        	s32i	a8, a1, 0x278
42017993:	07d316        	beqz	a3, 42017a14 <_vfiprintf_r+0x1f54>
42017996:	0023c6        	j	42017a29 <_vfiprintf_r+0x1f69>
42017999:	9d2192        	l32i	a9, a1, 0x274
4201799c:	c04950        	sub	a4, a9, a5
4201799f:	df14a6        	blti	a4, 1, 42017982 <_vfiprintf_r+0x1ec2>
420179a2:	081c      	movi.n	a8, 16
420179a4:	24a272        	movi	a7, 0x224
420179a7:	a18a      	add.n	a10, a1, a8
420179a9:	7a7a      	add.n	a7, a10, a7
420179ab:	000c06        	j	420179df <_vfiprintf_r+0x1f1f>
420179ae:	00          	.byte 00
420179af:	00          	.byte 00
420179b0:	00          	.byte 00
420179b1:	10caa2        	addi	a10, a10, 16
420179b4:	1389      	s32i.n	a8, a3, 4
420179b6:	b9a9      	s32i.n	a10, a9, 44
420179b8:	a969      	s32i.n	a6, a9, 40
420179ba:	338b      	addi.n	a3, a3, 8
420179bc:	1c86a6        	blti	a6, 8, 420179dc <_vfiprintf_r+0x1f1c>
420179bf:	9921b2        	l32i	a11, a1, 0x264
420179c2:	9c21a2        	l32i	a10, a1, 0x270
420179c5:	07cd      	mov.n	a12, a7
420179c7:	a76182        	s32i	a8, a1, 0x29c
420179ca:	fe0d25        	call8	42015a9c <__sprint_r>
420179cd:	a72182        	l32i	a8, a1, 0x29c
420179d0:	090a56        	bnez	a10, 42017a64 <_vfiprintf_r+0x1fa4>
420179d3:	e4a132        	movi	a3, 0x1e4
420179d6:	10c1c2        	addi	a12, a1, 16
420179d9:	803c30        	add	a3, a12, a3
420179dc:	f0c442        	addi	a4, a4, -16
420179df:	10c1d2        	addi	a13, a1, 16
420179e2:	a4d0b1        	l32r	a11, 42000d24 <_stext+0xd04>
420179e5:	8a2d62        	l32i	a6, a13, 0x228
420179e8:	03b9      	s32i.n	a11, a3, 0
420179ea:	02dd92        	addmi	a9, a13, 0x200
420179ed:	661b      	addi.n	a6, a6, 1
420179ef:	b9a8      	l32i.n	a10, a9, 44
420179f1:	bc2847        	blt	a8, a4, 420179b1 <_vfiprintf_r+0x1ef1>
420179f4:	1349      	s32i.n	a4, a3, 4
420179f6:	44aa      	add.n	a4, a4, a10
420179f8:	b949      	s32i.n	a4, a9, 44
420179fa:	a969      	s32i.n	a6, a9, 40
420179fc:	8286a6        	blti	a6, 8, 42017982 <_vfiprintf_r+0x1ec2>
420179ff:	24a2c2        	movi	a12, 0x224
42017a02:	9921b2        	l32i	a11, a1, 0x264
42017a05:	9c21a2        	l32i	a10, a1, 0x270
42017a08:	cdca      	add.n	a12, a13, a12
42017a0a:	fe0925        	call8	42015a9c <__sprint_r>
42017a0d:	f71a16        	beqz	a10, 42017982 <_vfiprintf_r+0x1ec2>
42017a10:	001406        	j	42017a64 <_vfiprintf_r+0x1fa4>
42017a13:	00          	.byte 00
42017a14:	040c      	movi.n	a4, 0
42017a16:	10c1e2        	addi	a14, a1, 16
42017a19:	8e6142        	s32i	a4, a1, 0x238
42017a1c:	024d      	mov.n	a4, a2
42017a1e:	e4a122        	movi	a2, 0x1e4
42017a21:	3e2a      	add.n	a3, a14, a2
42017a23:	986132        	s32i	a3, a1, 0x260
42017a26:	f880c6        	j	42015c2d <_vfiprintf_r+0x16d>
42017a29:	24a2c2        	movi	a12, 0x224
42017a2c:	10c142        	addi	a4, a1, 16
42017a2f:	9921b2        	l32i	a11, a1, 0x264
42017a32:	9c21a2        	l32i	a10, a1, 0x270
42017a35:	c4ca      	add.n	a12, a4, a12
42017a37:	fe0665        	call8	42015a9c <__sprint_r>
42017a3a:	fd6a16        	beqz	a10, 42017a14 <_vfiprintf_r+0x1f54>
42017a3d:	0008c6        	j	42017a64 <_vfiprintf_r+0x1fa4>
42017a40:	8f2122        	l32i	a2, a1, 0x23c
42017a43:	92cc      	bnez.n	a2, 42017a50 <_vfiprintf_r+0x1f90>
42017a45:	030c      	movi.n	a3, 0
42017a47:	10c152        	addi	a5, a1, 16
42017a4a:	8e6132        	s32i	a3, a1, 0x238
42017a4d:	0004c6        	j	42017a64 <_vfiprintf_r+0x1fa4>
42017a50:	24a2c2        	movi	a12, 0x224
42017a53:	10c162        	addi	a6, a1, 16
42017a56:	9921b2        	l32i	a11, a1, 0x264
42017a59:	9c21a2        	l32i	a10, a1, 0x270
42017a5c:	c6ca      	add.n	a12, a6, a12
42017a5e:	fe03e5        	call8	42015a9c <__sprint_r>
42017a61:	fe0a16        	beqz	a10, 42017a45 <_vfiprintf_r+0x1f85>
42017a64:	992182        	l32i	a8, a1, 0x264
42017a67:	192822        	l32i	a2, a8, 100
42017a6a:	0ee207        	bbsi	a2, 0, 42017a7c <_vfiprintf_r+0x1fbc>
42017a6d:	061822        	l16ui	a2, a8, 12
42017a70:	08e297        	bbsi	a2, 9, 42017a7c <_vfiprintf_r+0x1fbc>
42017a73:	1628a2        	l32i	a10, a8, 88
42017a76:	a43681        	l32r	a8, 42000b50 <_stext+0xb30>
42017a79:	0008e0        	callx8	a8
42017a7c:	9021a2        	l32i	a10, a1, 0x240
42017a7f:	40a2b2        	movi	a11, 0x240
42017a82:	b1ba      	add.n	a11, a1, a11
42017a84:	201110        	or	a1, a1, a1
42017a87:	0048e5        	call8	42017f14 <pthread_setcancelstate>
42017a8a:	992192        	l32i	a9, a1, 0x264
42017a8d:	9e2142        	l32i	a4, a1, 0x278
42017a90:	061922        	l16ui	a2, a9, 12
42017a93:	f37c      	movi.n	a3, -1
42017a95:	042620        	extui	a2, a2, 6, 1
42017a98:	934320        	movnez	a4, a3, a2
42017a9b:	9e6142        	s32i	a4, a1, 0x278
42017a9e:	000bc6        	j	42017ad1 <_vfiprintf_r+0x2011>
42017aa1:	922162        	l32i	a6, a1, 0x248
42017aa4:	941b      	addi.n	a9, a4, 1
42017aa6:	02a467        	bge	a4, a6, 42017aac <_vfiprintf_r+0x1fec>
42017aa9:	f8c7c6        	j	42015dcc <_vfiprintf_r+0x30c>
42017aac:	f8c946        	j	42015dd5 <_vfiprintf_r+0x315>
42017aaf:	00          	.byte 00
42017ab0:	922162        	l32i	a6, a1, 0x248
42017ab3:	941b      	addi.n	a9, a4, 1
42017ab5:	02a467        	bge	a4, a6, 42017abb <_vfiprintf_r+0x1ffb>
42017ab8:	f90b06        	j	42015ee8 <_vfiprintf_r+0x428>
42017abb:	f90c86        	j	42015ef1 <_vfiprintf_r+0x431>
42017abe:	00          	.byte 00
42017abf:	00          	.byte 00
42017ac0:	9a2182        	l32i	a8, a1, 0x268
42017ac3:	972162        	l32i	a6, a1, 0x25c
42017ac6:	140c      	movi.n	a4, 1
42017ac8:	020826        	beqi	a8, -1, 42017ace <_vfiprintf_r+0x200e>
42017acb:	fe8046        	j	420174d0 <_vfiprintf_r+0x1a10>
42017ace:	fe9d86        	j	42017548 <_vfiprintf_r+0x1a88>
42017ad1:	9e2122        	l32i	a2, a1, 0x278
42017ad4:	f01d      	retw.n
	...

42017ad8 <vfiprintf>:
42017ad8:	006136        	entry	a1, 48
42017adb:	0149      	s32i.n	a4, a1, 0
42017add:	1159      	s32i.n	a5, a1, 4
42017adf:	026162        	s32i	a6, a1, 8
42017ae2:	a41481        	l32r	a8, 42000b34 <_stext+0xb14>
42017ae5:	0008e0        	callx8	a8
42017ae8:	01d8      	l32i.n	a13, a1, 0
42017aea:	11e8      	l32i.n	a14, a1, 4
42017aec:	21f8      	l32i.n	a15, a1, 8
42017aee:	02bd      	mov.n	a11, a2
42017af0:	03cd      	mov.n	a12, a3
42017af2:	fdfce5        	call8	42015ac0 <_vfiprintf_r>
42017af5:	0a2d      	mov.n	a2, a10
42017af7:	f01d      	retw.n
42017af9:	000000        	ill

42017afc <__sbprintf>:
42017afc:	024136        	entry	a1, 0x120
42017aff:	078d      	mov.n	a8, a7
42017b01:	027d      	mov.n	a7, a2
42017b03:	061322        	l16ui	a2, a3, 12
42017b06:	3e6182        	s32i	a8, a1, 248
42017b09:	d87c      	movi.n	a8, -3
42017b0b:	102280        	and	a2, a2, a8
42017b0e:	465122        	s16i	a2, a1, 140
42017b11:	192322        	l32i	a2, a3, 100
42017b14:	80a082        	movi	a8, 128
42017b17:	396122        	s32i	a2, a1, 228
42017b1a:	071322        	l16ui	a2, a3, 14
42017b1d:	226182        	s32i	a8, a1, 136
42017b20:	475122        	s16i	a2, a1, 142
42017b23:	8328      	l32i.n	a2, a3, 32
42017b25:	256182        	s32i	a8, a1, 148
42017b28:	286122        	s32i	a2, a1, 160
42017b2b:	a328      	l32i.n	a2, a3, 40
42017b2d:	3c6152        	s32i	a5, a1, 240
42017b30:	2a6122        	s32i	a2, a1, 168
42017b33:	020c      	movi.n	a2, 0
42017b35:	266122        	s32i	a2, a1, 152
42017b38:	281a      	add.n	a2, a8, a1
42017b3a:	58c2a2        	addi	a10, a2, 88
42017b3d:	3d6162        	s32i	a6, a1, 244
42017b40:	206112        	s32i	a1, a1, 128
42017b43:	246112        	s32i	a1, a1, 144
42017b46:	a40681        	l32r	a8, 42000b60 <_stext+0xb40>
42017b49:	0008e0        	callx8	a8
42017b4c:	3c21d2        	l32i	a13, a1, 240
42017b4f:	3d21e2        	l32i	a14, a1, 244
42017b52:	3e21f2        	l32i	a15, a1, 248
42017b55:	02bd      	mov.n	a11, a2
42017b57:	04cd      	mov.n	a12, a4
42017b59:	07ad      	mov.n	a10, a7
42017b5b:	fdf665        	call8	42015ac0 <_vfiprintf_r>
42017b5e:	0a2d      	mov.n	a2, a10
42017b60:	011a96        	bltz	a10, 42017b75 <__sbprintf+0x79>
42017b63:	80a0b2        	movi	a11, 128
42017b66:	07ad      	mov.n	a10, a7
42017b68:	bb1a      	add.n	a11, a11, a1
42017b6a:	201110        	or	a1, a1, a1
42017b6d:	fa9b65        	call8	42012524 <_fflush_r>
42017b70:	f77c      	movi.n	a7, -1
42017b72:	9327a0        	movnez	a2, a7, a10
42017b75:	461182        	l16ui	a8, a1, 140
42017b78:	074c      	movi.n	a7, 64
42017b7a:	080877        	bnone	a8, a7, 42017b86 <__sbprintf+0x8a>
42017b7d:	061382        	l16ui	a8, a3, 12
42017b80:	208870        	or	a8, a8, a7
42017b83:	065382        	s16i	a8, a3, 12
42017b86:	3621a2        	l32i	a10, a1, 216
42017b89:	a3f881        	l32r	a8, 42000b6c <_stext+0xb4c>
42017b8c:	0008e0        	callx8	a8
42017b8f:	f01d      	retw.n
42017b91:	000000        	ill

42017b94 <_mbtowc_r>:
42017b94:	004136        	entry	a1, 32
42017b97:	a44a81        	l32r	a8, 42000cc0 <_stext+0xca0>
42017b9a:	06ed      	mov.n	a14, a6
42017b9c:	0888      	l32i.n	a8, a8, 0
42017b9e:	05dd      	mov.n	a13, a5
42017ba0:	392882        	l32i	a8, a8, 228
42017ba3:	04cd      	mov.n	a12, a4
42017ba5:	03bd      	mov.n	a11, a3
42017ba7:	02ad      	mov.n	a10, a2
42017ba9:	0008e0        	callx8	a8
42017bac:	0a2d      	mov.n	a2, a10
42017bae:	f01d      	retw.n

42017bb0 <__ascii_mbtowc>:
42017bb0:	006136        	entry	a1, 48
42017bb3:	13cc      	bnez.n	a3, 42017bb8 <__ascii_mbtowc+0x8>
42017bb5:	203110        	or	a3, a1, a1
42017bb8:	042d      	mov.n	a2, a4
42017bba:	249c      	beqz.n	a4, 42017bd0 <__ascii_mbtowc+0x20>
42017bbc:	e27c      	movi.n	a2, -2
42017bbe:	e58c      	beqz.n	a5, 42017bd0 <__ascii_mbtowc+0x20>
42017bc0:	000422        	l8ui	a2, a4, 0
42017bc3:	005322        	s16i	a2, a3, 0
42017bc6:	000442        	l8ui	a4, a4, 0
42017bc9:	120c      	movi.n	a2, 1
42017bcb:	030c      	movi.n	a3, 0
42017bcd:	832340        	moveqz	a2, a3, a4
42017bd0:	f01d      	retw.n
	...

42017bd4 <_wctomb_r>:
42017bd4:	004136        	entry	a1, 32
42017bd7:	a43a81        	l32r	a8, 42000cc0 <_stext+0xca0>
42017bda:	05dd      	mov.n	a13, a5
42017bdc:	0888      	l32i.n	a8, a8, 0
42017bde:	f4c040        	extui	a12, a4, 0, 16
42017be1:	382882        	l32i	a8, a8, 224
42017be4:	03bd      	mov.n	a11, a3
42017be6:	20a220        	or	a10, a2, a2
42017be9:	0008e0        	callx8	a8
42017bec:	0a2d      	mov.n	a2, a10
42017bee:	f01d      	retw.n

42017bf0 <__ascii_wctomb>:
42017bf0:	004136        	entry	a1, 32
42017bf3:	f44040        	extui	a4, a4, 0, 16
42017bf6:	038d      	mov.n	a8, a3
42017bf8:	539c      	beqz.n	a3, 42017c11 <__ascii_wctomb+0x21>
42017bfa:	ffa082        	movi	a8, 255
42017bfd:	0bb847        	bgeu	a8, a4, 42017c0c <__ascii_wctomb+0x1c>
42017c00:	8aa032        	movi	a3, 138
42017c03:	0239      	s32i.n	a3, a2, 0
42017c05:	f87c      	movi.n	a8, -1
42017c07:	000186        	j	42017c11 <__ascii_wctomb+0x21>
42017c0a:	00          	.byte 00
42017c0b:	00          	.byte 00
42017c0c:	004342        	s8i	a4, a3, 0
42017c0f:	180c      	movi.n	a8, 1
42017c11:	082d      	mov.n	a2, a8
42017c13:	f01d      	retw.n
42017c15:	000000        	ill

42017c18 <pthread_include_pthread_impl>:
    return EINVAL;
}

/* Hook function to force linking this file */
void pthread_include_pthread_impl(void)
{
42017c18:	004136        	entry	a1, 32
}
42017c1b:	f01d      	retw.n
42017c1d:	000000        	ill

42017c20 <pthread_include_pthread_local_storage_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_local_storage_impl(void)
{
42017c20:	004136        	entry	a1, 32
}
42017c23:	f01d      	retw.n
42017c25:	000000        	ill

42017c28 <pthread_include_pthread_rwlock_impl>:
    return 0;
}

/* Hook function to force linking this file */
void pthread_include_pthread_rwlock_impl(void)
{
42017c28:	004136        	entry	a1, 32
}
42017c2b:	f01d      	retw.n
42017c2d:	000000        	ill

42017c30 <panic_get_address>:
{
42017c30:	004136        	entry	a1, 32
}
42017c33:	1228      	l32i.n	a2, a2, 4
42017c35:	f01d      	retw.n
	...

42017c38 <panic_get_cause>:
{
42017c38:	004136        	entry	a1, 32
}
42017c3b:	142222        	l32i	a2, a2, 80
42017c3e:	f01d      	retw.n

42017c40 <panic_set_address>:
{
42017c40:	004136        	entry	a1, 32
    ((XtExcFrame *)f)->pc = addr;
42017c43:	1239      	s32i.n	a3, a2, 4
}
42017c45:	f01d      	retw.n
	...

42017c48 <uart_hal_tx_break>:

void uart_hal_tx_break(uart_hal_context_t *hal, uint32_t break_num)
{
42017c48:	006136        	entry	a1, 48
    uart_ll_tx_break(hal->dev, break_num);
42017c4b:	0288      	l32i.n	a8, a2, 0
    if (break_num > 0) {
42017c4d:	c3bc      	beqz.n	a3, 42017c8d <uart_hal_tx_break+0x45>
        HAL_FORCE_MODIFY_U32_REG_FIELD(hw->txbrk_conf, tx_brk_num, break_num);
42017c4f:	0020c0        	memw
42017c52:	112892        	l32i	a9, a8, 68
42017c55:	00afa2        	movi	a10, 0xffffff00
42017c58:	0020c0        	memw
42017c5b:	0199      	s32i.n	a9, a1, 0
42017c5d:	0020c0        	memw
42017c60:	0198      	l32i.n	a9, a1, 0
42017c62:	743030        	extui	a3, a3, 0, 8
42017c65:	1099a0        	and	a9, a9, a10
42017c68:	209930        	or	a9, a9, a3
42017c6b:	0020c0        	memw
42017c6e:	0199      	s32i.n	a9, a1, 0
42017c70:	0020c0        	memw
42017c73:	0138      	l32i.n	a3, a1, 0
        hw->conf0.txd_brk = 1;
42017c75:	00a192        	movi	a9, 0x100
        HAL_FORCE_MODIFY_U32_REG_FIELD(hw->txbrk_conf, tx_brk_num, break_num);
42017c78:	0020c0        	memw
42017c7b:	116832        	s32i	a3, a8, 68
        hw->conf0.txd_brk = 1;
42017c7e:	0020c0        	memw
42017c81:	8838      	l32i.n	a3, a8, 32
42017c83:	203390        	or	a3, a3, a9
        hw->conf0.txd_brk = 0;
42017c86:	0020c0        	memw
42017c89:	8839      	s32i.n	a3, a8, 32
}
42017c8b:	f01d      	retw.n
42017c8d:	0020c0        	memw
42017c90:	8838      	l32i.n	a3, a8, 32
42017c92:	ffae92        	movi	a9, 0xfffffeff
42017c95:	103390        	and	a3, a3, a9
42017c98:	fffa86        	j	42017c86 <uart_hal_tx_break+0x3e>
	...

42017c9c <uart_hal_write_txfifo>:

void uart_hal_write_txfifo(uart_hal_context_t *hal, const uint8_t *buf, uint32_t data_size, uint32_t *write_size)
{
42017c9c:	004136        	entry	a1, 32
    uint16_t fill_len = uart_ll_get_txfifo_len(hal->dev);
42017c9f:	02a8      	l32i.n	a10, a2, 0
    return UART_LL_FIFO_DEF_LEN - hw->status.txfifo_cnt;
42017ca1:	80a082        	movi	a8, 128
42017ca4:	0020c0        	memw
42017ca7:	072a92        	l32i	a9, a10, 28
42017caa:	959090        	extui	a9, a9, 16, 10
42017cad:	c08890        	sub	a8, a8, a9
    if (fill_len > data_size) {
42017cb0:	f4b080        	extui	a11, a8, 0, 16
        fill_len = data_size;
42017cb3:	f49040        	extui	a9, a4, 0, 16
    if (fill_len > data_size) {
42017cb6:	0234b7        	bltu	a4, a11, 42017cbc <uart_hal_write_txfifo+0x20>
    uint16_t fill_len = uart_ll_get_txfifo_len(hal->dev);
42017cb9:	f49080        	extui	a9, a8, 0, 16
    }
    *write_size = fill_len;
42017cbc:	0599      	s32i.n	a9, a5, 0
    for (int i = 0; i < (int)wr_len; i++) {
42017cbe:	080c      	movi.n	a8, 0
42017cc0:	012897        	blt	a8, a9, 42017cc5 <uart_hal_write_txfifo+0x29>
    uart_ll_write_txfifo(hal->dev, buf, fill_len);
}
42017cc3:	f01d      	retw.n
        hw->fifo.rxfifo_rd_byte = buf[i];
42017cc5:	438a      	add.n	a4, a3, a8
42017cc7:	000442        	l8ui	a4, a4, 0
    for (int i = 0; i < (int)wr_len; i++) {
42017cca:	881b      	addi.n	a8, a8, 1
        hw->fifo.rxfifo_rd_byte = buf[i];
42017ccc:	0020c0        	memw
42017ccf:	0a49      	s32i.n	a4, a10, 0
    for (int i = 0; i < (int)wr_len; i++) {
42017cd1:	fffac6        	j	42017cc0 <uart_hal_write_txfifo+0x24>

42017cd4 <uart_hal_read_rxfifo>:

void uart_hal_read_rxfifo(uart_hal_context_t *hal, uint8_t *buf, int *inout_rd_len)
{
42017cd4:	004136        	entry	a1, 32
    if (*inout_rd_len <= 0) {
42017cd7:	0488      	l32i.n	a8, a4, 0
        *inout_rd_len = uart_ll_get_rxfifo_len(hal->dev);
42017cd9:	0298      	l32i.n	a9, a2, 0
    if (*inout_rd_len <= 0) {
42017cdb:	0918e6        	bgei	a8, 1, 42017ce8 <uart_hal_read_rxfifo+0x14>
    return hw->status.rxfifo_cnt;
42017cde:	0020c0        	memw
42017ce1:	7988      	l32i.n	a8, a9, 28
42017ce3:	948080        	extui	a8, a8, 0, 10
        *inout_rd_len = uart_ll_get_rxfifo_len(hal->dev);
42017ce6:	0489      	s32i.n	a8, a4, 0
    }
    uart_ll_read_rxfifo(hal->dev, buf, *inout_rd_len);
42017ce8:	0448      	l32i.n	a4, a4, 0
    for (int i = 0; i < (int)rd_len; i++) {
42017cea:	080c      	movi.n	a8, 0
42017cec:	012847        	blt	a8, a4, 42017cf1 <uart_hal_read_rxfifo+0x1d>
}
42017cef:	f01d      	retw.n
        buf[i] = hw->fifo.rxfifo_rd_byte;
42017cf1:	0020c0        	memw
42017cf4:	09b8      	l32i.n	a11, a9, 0
42017cf6:	a38a      	add.n	a10, a3, a8
42017cf8:	004ab2        	s8i	a11, a10, 0
    for (int i = 0; i < (int)rd_len; i++) {
42017cfb:	881b      	addi.n	a8, a8, 1
42017cfd:	fffac6        	j	42017cec <uart_hal_read_rxfifo+0x18>

42017d00 <heap_caps_match>:
{
42017d00:	004136        	entry	a1, 32
    return heap->heap != NULL && ((get_all_caps(heap) & caps) == caps);
42017d03:	7288      	l32i.n	a8, a2, 28
{
42017d05:	029d      	mov.n	a9, a2
    return heap->heap != NULL && ((get_all_caps(heap) & caps) == caps);
42017d07:	020c      	movi.n	a2, 0
42017d09:	171827        	beq	a8, a2, 42017d24 <heap_caps_match+0x24>
42017d0c:	0988      	l32i.n	a8, a9, 0
42017d0e:	19a8      	l32i.n	a10, a9, 4
42017d10:	2998      	l32i.n	a9, a9, 8
42017d12:	2088a0        	or	a8, a8, a10
42017d15:	208890        	or	a8, a8, a9
42017d18:	108830        	and	a8, a8, a3
42017d1b:	c08830        	sub	a8, a8, a3
42017d1e:	01a032        	movi	a3, 1
42017d21:	832380        	moveqz	a2, a3, a8
}
42017d24:	f01d      	retw.n
	...

42017d28 <s_compare_reserved_regions>:
{
42017d28:	004136        	entry	a1, 32
    return (int)r_a->start - (int)r_b->start;
42017d2b:	0228      	l32i.n	a2, a2, 0
42017d2d:	0388      	l32i.n	a8, a3, 0
}
42017d2f:	c02280        	sub	a2, a2, a8
42017d32:	f01d      	retw.n

42017d34 <esp_intr_get_cpu>:
{
42017d34:	004136        	entry	a1, 32
    return handle->vector_desc->cpu;
42017d37:	0228      	l32i.n	a2, a2, 0
42017d39:	0228      	l32i.n	a2, a2, 0
}
42017d3b:	052020        	extui	a2, a2, 16, 1
42017d3e:	f01d      	retw.n

42017d40 <periph_ll_get_rst_en_mask>:
{
42017d40:	004136        	entry	a1, 32
    switch (periph) {
42017d43:	391c      	movi.n	a9, 19
        return SYSTEM_PCNT_RST;
42017d45:	00a482        	movi	a8, 0x400
    switch (periph) {
42017d48:	361297        	beq	a2, a9, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017d4b:	02b927        	bgeu	a9, a2, 42017d51 <periph_ll_get_rst_en_mask+0x11>
42017d4e:	003386        	j	42017e20 <periph_ll_get_rst_en_mask+0xe0>
        return SYSTEM_I2S1_RST;
42017d51:	180c      	movi.n	a8, 1
42017d53:	0188b0        	slli	a8, a8, 21
    switch (periph) {
42017d56:	288226        	beqi	a2, 8, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017d59:	830c      	movi.n	a3, 8
42017d5b:	553327        	bltu	a3, a2, 42017db4 <periph_ll_get_rst_en_mask+0x74>
        return SYSTEM_USB_RST;
42017d5e:	180c      	movi.n	a8, 1
42017d60:	018890        	slli	a8, a8, 23
    switch (periph) {
42017d63:	1b4226        	beqi	a2, 4, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017d66:	2c52f6        	bgeui	a2, 5, 42017d96 <periph_ll_get_rst_en_mask+0x56>
        return SYSTEM_UART1_RST;
42017d69:	082c      	movi.n	a8, 32
    switch (periph) {
42017d6b:	132226        	beqi	a2, 2, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017d6e:	190c      	movi.n	a9, 1
42017d70:	1432f6        	bgeui	a2, 3, 42017d88 <periph_ll_get_rst_en_mask+0x48>
        return SYSTEM_LEDC_RST;
42017d73:	118950        	slli	a8, a9, 11
    switch (periph) {
42017d76:	828c      	beqz.n	a2, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017d78:	820b      	addi.n	a8, a2, -1
42017d7a:	030c      	movi.n	a3, 0
42017d7c:	939380        	movnez	a9, a3, a8
42017d7f:	1189e0        	slli	a8, a9, 2
}
42017d82:	082d      	mov.n	a2, a8
42017d84:	f01d      	retw.n
42017d86:	00          	.byte 00
42017d87:	00          	.byte 00
    switch (periph) {
42017d88:	fdc282        	addi	a8, a2, -3
42017d8b:	030c      	movi.n	a3, 0
42017d8d:	939380        	movnez	a9, a3, a8
42017d90:	118970        	slli	a8, a9, 9
42017d93:	fffac6        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
        return SYSTEM_I2C_EXT1_RST;
42017d96:	180c      	movi.n	a8, 1
42017d98:	0188e0        	slli	a8, a8, 18
    switch (periph) {
42017d9b:	e36226        	beqi	a2, 6, 42017d82 <periph_ll_get_rst_en_mask+0x42>
        return SYSTEM_I2S0_RST;
42017d9e:	081c      	movi.n	a8, 16
    switch (periph) {
42017da0:	de7226        	beqi	a2, 7, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017da3:	fbc222        	addi	a2, a2, -5
42017da6:	180c      	movi.n	a8, 1
42017da8:	030c      	movi.n	a3, 0
42017daa:	938320        	movnez	a8, a3, a2
42017dad:	118890        	slli	a8, a8, 7
42017db0:	fff386        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017db3:	00          	.byte 00
        return SYSTEM_PWM1_RST;
42017db4:	180c      	movi.n	a8, 1
    switch (periph) {
42017db6:	d90c      	movi.n	a9, 13
        return SYSTEM_PWM1_RST;
42017db8:	0188c0        	slli	a8, a8, 20
    switch (periph) {
42017dbb:	c31297        	beq	a2, a9, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017dbe:	363927        	bltu	a9, a2, 42017df8 <periph_ll_get_rst_en_mask+0xb8>
        return SYSTEM_TIMERGROUP1_RST;
42017dc1:	180c      	movi.n	a8, 1
    switch (periph) {
42017dc3:	b90c      	movi.n	a9, 11
        return SYSTEM_TIMERGROUP1_RST;
42017dc5:	118810        	slli	a8, a8, 15
    switch (periph) {
42017dc8:	b61297        	beq	a2, a9, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017dcb:	193927        	bltu	a9, a2, 42017de8 <periph_ll_get_rst_en_mask+0xa8>
42017dce:	930c      	movi.n	a3, 9
        return SYSTEM_LCD_CAM_RST;
42017dd0:	00a182        	movi	a8, 0x100
    switch (periph) {
42017dd3:	ab1237        	beq	a2, a3, 42017d82 <periph_ll_get_rst_en_mask+0x42>
42017dd6:	f6c222        	addi	a2, a2, -10
42017dd9:	180c      	movi.n	a8, 1
42017ddb:	030c      	movi.n	a3, 0
42017ddd:	938320        	movnez	a8, a3, a2
42017de0:	118830        	slli	a8, a8, 13
42017de3:	ffe6c6        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017de6:	00          	.byte 00
42017de7:	00          	.byte 00
42017de8:	f4c222        	addi	a2, a2, -12
42017deb:	180c      	movi.n	a8, 1
42017ded:	030c      	movi.n	a3, 0
42017def:	938320        	movnez	a8, a3, a2
42017df2:	0188f0        	slli	a8, a8, 17
42017df5:	ffe246        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
        return SYSTEM_UHCI1_RST;
42017df8:	180c      	movi.n	a8, 1
    switch (periph) {
42017dfa:	131c      	movi.n	a3, 17
        return SYSTEM_UHCI1_RST;
42017dfc:	118840        	slli	a8, a8, 12
    switch (periph) {
42017dff:	029237        	bne	a2, a3, 42017e05 <periph_ll_get_rst_en_mask+0xc5>
42017e02:	ffdf06        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e05:	231c      	movi.n	a3, 18
42017e07:	00a282        	movi	a8, 0x200
42017e0a:	029237        	bne	a2, a3, 42017e10 <periph_ll_get_rst_en_mask+0xd0>
42017e0d:	ffdc46        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e10:	f0c222        	addi	a2, a2, -16
42017e13:	180c      	movi.n	a8, 1
42017e15:	030c      	movi.n	a3, 0
42017e17:	938320        	movnez	a8, a3, a2
42017e1a:	118880        	slli	a8, a8, 8
42017e1d:	ffd846        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e20:	02c266        	bnei	a2, 32, 42017e26 <periph_ll_get_rst_en_mask+0xe6>
42017e23:	003246        	j	42017ef0 <periph_ll_get_rst_en_mask+0x1b0>
42017e26:	082c      	movi.n	a8, 32
42017e28:	643827        	bltu	a8, a2, 42017e90 <periph_ll_get_rst_en_mask+0x150>
        return SYSTEM_TWAI_RST;
42017e2b:	180c      	movi.n	a8, 1
    switch (periph) {
42017e2d:	891c      	movi.n	a9, 24
        return SYSTEM_TWAI_RST;
42017e2f:	0188d0        	slli	a8, a8, 19
    switch (periph) {
42017e32:	029297        	bne	a2, a9, 42017e38 <periph_ll_get_rst_en_mask+0xf8>
42017e35:	ffd246        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e38:	303927        	bltu	a9, a2, 42017e6c <periph_ll_get_rst_en_mask+0x12c>
        return SYSTEM_SPI3_RST;
42017e3b:	180c      	movi.n	a8, 1
    switch (periph) {
42017e3d:	691c      	movi.n	a9, 22
        return SYSTEM_SPI3_RST;
42017e3f:	118800        	slli	a8, a8, 16
    switch (periph) {
42017e42:	029297        	bne	a2, a9, 42017e48 <periph_ll_get_rst_en_mask+0x108>
42017e45:	ffce46        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e48:	193927        	bltu	a9, a2, 42017e65 <periph_ll_get_rst_en_mask+0x125>
42017e4b:	431c      	movi.n	a3, 20
        return SYSTEM_SPI01_RST;
42017e4d:	280c      	movi.n	a8, 2
    switch (periph) {
42017e4f:	029237        	bne	a2, a3, 42017e55 <periph_ll_get_rst_en_mask+0x115>
42017e52:	ffcb06        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e55:	ebc222        	addi	a2, a2, -21
42017e58:	180c      	movi.n	a8, 1
42017e5a:	030c      	movi.n	a3, 0
42017e5c:	938320        	movnez	a8, a3, a2
42017e5f:	1188a0        	slli	a8, a8, 6
42017e62:	ffc706        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e65:	e9c222        	addi	a2, a2, -23
42017e68:	ffce86        	j	42017da6 <periph_ll_get_rst_en_mask+0x66>
42017e6b:	00          	.byte 00
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
42017e6c:	c1a782        	movi	a8, 0x7c1
    switch (periph) {
42017e6f:	b91c      	movi.n	a9, 27
        return  (SYSTEM_BTBB_RST | SYSTEM_BTBB_REG_RST | SYSTEM_RW_BTMAC_RST | SYSTEM_RW_BTLP_RST | SYSTEM_RW_BTMAC_REG_RST | SYSTEM_RW_BTLP_REG_RST);
42017e71:	1188d0        	slli	a8, a8, 3
    switch (periph) {
42017e74:	029297        	bne	a2, a9, 42017e7a <periph_ll_get_rst_en_mask+0x13a>
42017e77:	ffc1c6        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e7a:	f81c      	movi.n	a8, 31
42017e7c:	651287        	beq	a2, a8, 42017ee5 <periph_ll_get_rst_en_mask+0x1a5>
42017e7f:	e6c222        	addi	a2, a2, -26
42017e82:	180c      	movi.n	a8, 1
42017e84:	030c      	movi.n	a3, 0
42017e86:	938320        	movnez	a8, a3, a2
42017e89:	1188e0        	slli	a8, a8, 2
42017e8c:	ffbc86        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e8f:	00          	.byte 00
        return SYSTEM_SYSTIMER_RST;
42017e90:	180c      	movi.n	a8, 1
    switch (periph) {
42017e92:	492c      	movi.n	a9, 36
        return SYSTEM_SYSTIMER_RST;
42017e94:	018830        	slli	a8, a8, 29
    switch (periph) {
42017e97:	029297        	bne	a2, a9, 42017e9d <periph_ll_get_rst_en_mask+0x15d>
42017e9a:	ffb906        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017e9d:	1e3927        	bltu	a9, a2, 42017ebf <periph_ll_get_rst_en_mask+0x17f>
42017ea0:	292c      	movi.n	a9, 34
        return SYSTEM_CRYPTO_DS_RST;
42017ea2:	081c      	movi.n	a8, 16
    switch (periph) {
42017ea4:	029297        	bne	a2, a9, 42017eaa <periph_ll_get_rst_en_mask+0x16a>
42017ea7:	ffb5c6        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017eaa:	382c      	movi.n	a8, 35
42017eac:	481287        	beq	a2, a8, 42017ef8 <periph_ll_get_rst_en_mask+0x1b8>
42017eaf:	dfc222        	addi	a2, a2, -33
42017eb2:	180c      	movi.n	a8, 1
42017eb4:	030c      	movi.n	a3, 0
42017eb6:	938320        	movnez	a8, a3, a2
42017eb9:	1188b0        	slli	a8, a8, 5
42017ebc:	ffb086        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017ebf:	632c      	movi.n	a3, 38
        return SYSTEM_SDIO_HOST_RST;
42017ec1:	80a082        	movi	a8, 128
    switch (periph) {
42017ec4:	029237        	bne	a2, a3, 42017eca <periph_ll_get_rst_en_mask+0x18a>
42017ec7:	ffadc6        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017eca:	190c      	movi.n	a9, 1
42017ecc:	732c      	movi.n	a3, 39
        return SYSTEM_APB_SARADC_RST;
42017ece:	018940        	slli	a8, a9, 28
    switch (periph) {
42017ed1:	029237        	bne	a2, a3, 42017ed7 <periph_ll_get_rst_en_mask+0x197>
42017ed4:	ffaa86        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017ed7:	dbc282        	addi	a8, a2, -37
42017eda:	020c      	movi.n	a2, 0
42017edc:	939280        	movnez	a9, a2, a8
42017edf:	1189a0        	slli	a8, a9, 6
42017ee2:	ffa706        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
            return SYSTEM_CRYPTO_AES_RST;
42017ee5:	281c      	movi.n	a8, 18
42017ee7:	290c      	movi.n	a9, 2
            return SYSTEM_CRYPTO_RSA_RST;
42017ee9:	838930        	moveqz	a8, a9, a3
42017eec:	ffa486        	j	42017d82 <periph_ll_get_rst_en_mask+0x42>
42017eef:	00          	.byte 00
            return SYSTEM_CRYPTO_SHA_RST;
42017ef0:	483c      	movi.n	a8, 52
42017ef2:	490c      	movi.n	a9, 4
42017ef4:	fffc46        	j	42017ee9 <periph_ll_get_rst_en_mask+0x1a9>
42017ef7:	00          	.byte 00
            return SYSTEM_CRYPTO_RSA_RST;
42017ef8:	881c      	movi.n	a8, 24
42017efa:	890c      	movi.n	a9, 8
42017efc:	fffa46        	j	42017ee9 <periph_ll_get_rst_en_mask+0x1a9>
	...

42017f00 <memprot_ll_icache_set_permissions>:
{
42017f00:	004136        	entry	a1, 32
    if (w) {
42017f03:	338c      	beqz.n	a3, 42017f0a <memprot_ll_icache_set_permissions+0xa>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_W;
42017f05:	280c      	movi.n	a8, 2
42017f07:	202280        	or	a2, a2, a8
    if (x) {
42017f0a:	348c      	beqz.n	a4, 42017f11 <memprot_ll_icache_set_permissions+0x11>
        permissions |= SENSITIVE_CORE_X_ICACHE_PMS_CONSTRAIN_SRAM_WORLD_X_F;
42017f0c:	480c      	movi.n	a8, 4
42017f0e:	202280        	or	a2, a2, a8
}
42017f11:	f01d      	retw.n
	...

42017f14 <pthread_setcancelstate>:
    ESP_LOGW(TAG, "%s: not yet supported!", __func__);
    return 0;
}

int pthread_setcancelstate(int state, int *oldstate)
{
42017f14:	004136        	entry	a1, 32
    return 0;
}
42017f17:	020c      	movi.n	a2, 0
42017f19:	f01d      	retw.n
	...

42017f1c <newlib_include_pthread_impl>:
    }
    return 0;
}

void newlib_include_pthread_impl(void)
{
42017f1c:	004136        	entry	a1, 32
    // Linker hook, exists for no other purpose
}
42017f1f:	f01d      	retw.n
42017f21:	000000        	ill

42017f24 <_getpid_r>:
{
42017f24:	004136        	entry	a1, 32
    __errno_r(r) = ENOSYS;
42017f27:	885c      	movi.n	a8, 88
42017f29:	0289      	s32i.n	a8, a2, 0
}
42017f2b:	f27c      	movi.n	a2, -1
42017f2d:	f01d      	retw.n
	...

42017f30 <newlib_include_syscalls_impl>:

/* No-op function, used to force linking this file,
   instead of the syscalls implementation from libgloss.
 */
void newlib_include_syscalls_impl(void)
{
42017f30:	004136        	entry	a1, 32
}
42017f33:	f01d      	retw.n
42017f35:	000000        	ill

42017f38 <__cxa_guard_dummy>:
/**
 * Dummy function used to force linking this file instead of the same one in libstdc++.
 * This works via -u __cxa_guard_dummy flag in component.mk
 */
extern "C" void __cxa_guard_dummy(void)
{
42017f38:	004136        	entry	a1, 32
}
42017f3b:	f01d      	retw.n
42017f3d:	000000        	ill

42017f40 <include_esp_phy_override>:
 */

static bool s_wifi_adc_xpd_flag;

void include_esp_phy_override(void)
{
42017f40:	004136        	entry	a1, 32
    /* When this empty function is called, all functions below will be linked. */
}
42017f43:	f01d      	retw.n
42017f45:	000000        	ill

42017f48 <vfs_include_syscalls_impl>:
void rewinddir(DIR* pdir)
    __attribute__((alias("esp_vfs_rewinddir")));
#endif // CONFIG_VFS_SUPPORT_DIR

void vfs_include_syscalls_impl(void)
{
42017f48:	004136        	entry	a1, 32
    // Linker hook function, exists to make the linker examine this fine
}
42017f4b:	f01d      	retw.n
42017f4d:	000000        	ill

42017f50 <usb_serial_jtag_close>:
{
42017f50:	004136        	entry	a1, 32
}
42017f53:	020c      	movi.n	a2, 0
42017f55:	f01d      	retw.n
	...

42017f58 <argmax>:

int argmax(const float *x, int size) {
42017f58:	004136        	entry	a1, 32
    int i, i_max = 0;
42017f5b:	090c      	movi.n	a9, 0

    for (i = 1; i < size; i++) {
42017f5d:	180c      	movi.n	a8, 1
42017f5f:	052837        	blt	a8, a3, 42017f68 <argmax+0x10>
            i_max = i;
        }
    }

    return i_max;
}
42017f62:	092d      	mov.n	a2, a9
42017f64:	f01d      	retw.n
42017f66:	00          	.byte 00
42017f67:	00          	.byte 00
        if (x[i] > x[i_max]) {
42017f68:	a0b820        	addx4	a11, a8, a2
42017f6b:	a0a920        	addx4	a10, a9, a2
42017f6e:	000b03        	lsi	f0, a11, 0
42017f71:	000a13        	lsi	f1, a10, 0
42017f74:	4b0100        	olt.s	b0, f1, f0
42017f77:	010076        	bf	b0, 42017f7c <argmax+0x24>
42017f7a:	089d      	mov.n	a9, a8
    for (i = 1; i < size; i++) {
42017f7c:	881b      	addi.n	a8, a8, 1
42017f7e:	fff746        	j	42017f5f <argmax+0x7>
42017f81:	000000        	ill

42017f84 <dequantize_s16>:

void dequantize_s16(const struct qlayer *qlayer, const int16_t *x, float *out, int size) {
42017f84:	004136        	entry	a1, 32
    float mvm_scale;

    // TODO pre-calculate this value during compile-time
    mvm_scale = (qlayer->input.scale * qlayer->weights.scale);
42017f87:	010213        	lsi	f1, a2, 4
42017f8a:	030203        	lsi	f0, a2, 12

    for (int i = 0; i < size; i++) {
42017f8d:	080c      	movi.n	a8, 0
    mvm_scale = (qlayer->input.scale * qlayer->weights.scale);
42017f8f:	2a1100        	mul.s	f1, f1, f0
    for (int i = 0; i < size; i++) {
42017f92:	022857        	blt	a8, a5, 42017f98 <dequantize_s16+0x14>
        float temp = x[i] * mvm_scale;
        out[i] = (temp - qlayer->output.zero) * qlayer->output.scale;
    }
}
42017f95:	f01d      	retw.n
42017f97:	00          	.byte 00
        float temp = x[i] * mvm_scale;
42017f98:	909830        	addx2	a9, a8, a3
42017f9b:	009992        	l16si	a9, a9, 0
42017f9e:	ca2900        	float.s	f2, a9, 0
        out[i] = (temp - qlayer->output.zero) * qlayer->output.scale;
42017fa1:	100292        	l8ui	a9, a2, 16
42017fa4:	239900        	sext	a9, a9, 7
42017fa7:	ca0900        	float.s	f0, a9, 0
42017faa:	a09840        	addx4	a9, a8, a4
42017fad:	fa0060        	neg.s	f0, f0
42017fb0:	4a0210        	madd.s	f0, f2, f1
42017fb3:	050223        	lsi	f2, a2, 20
    for (int i = 0; i < size; i++) {
42017fb6:	881b      	addi.n	a8, a8, 1
        out[i] = (temp - qlayer->output.zero) * qlayer->output.scale;
42017fb8:	2a0200        	mul.s	f0, f2, f0
42017fbb:	004903        	ssi	f0, a9, 0
    for (int i = 0; i < size; i++) {
42017fbe:	fff406        	j	42017f92 <dequantize_s16+0xe>
42017fc1:	000000        	ill

42017fc4 <esp_efuse_get_field_size>:
{
42017fc4:	004136        	entry	a1, 32
42017fc7:	028d      	mov.n	a8, a2
    int bits_counter = 0;
42017fc9:	020c      	movi.n	a2, 0
    if (field != NULL) {
42017fcb:	091827        	beq	a8, a2, 42017fd8 <esp_efuse_get_field_size+0x14>
        while (field[i] != NULL) {
42017fce:	884b      	addi.n	a8, a8, 4
42017fd0:	fcc892        	addi	a9, a8, -4
42017fd3:	0998      	l32i.n	a9, a9, 0
42017fd5:	003956        	bnez	a9, 42017fdc <esp_efuse_get_field_size+0x18>
}
42017fd8:	f01d      	retw.n
42017fda:	00          	.byte 00
42017fdb:	00          	.byte 00
            bits_counter += field[i]->bit_count;
42017fdc:	011992        	l16ui	a9, a9, 2
42017fdf:	229a      	add.n	a2, a2, a9
            ++i;
42017fe1:	fffa46        	j	42017fce <esp_efuse_get_field_size+0xa>

42017fe4 <esp_efuse_utility_get_number_of_items>:
{
42017fe4:	004136        	entry	a1, 32
    return  bits / size_of_base + (bits % size_of_base > 0 ? 1 : 0);
42017fe7:	f29230        	rems	a9, a2, a3
42017fea:	318f90        	srai	a8, a9, 31
42017fed:	c08890        	sub	a8, a8, a9
42017ff0:	058f80        	extui	a8, a8, 31, 1
42017ff3:	d22230        	quos	a2, a2, a3
}
42017ff6:	282a      	add.n	a2, a8, a2
42017ff8:	f01d      	retw.n
	...

42017ffc <esp_efuse_utility_check_errors>:
    efuse_hal_read();
    efuse_hal_clear_program_registers();
}

esp_err_t esp_efuse_utility_check_errors(void)
{
42017ffc:	004136        	entry	a1, 32
    return ESP_OK;
}
42017fff:	020c      	movi.n	a2, 0
42018001:	f01d      	retw.n
	...

42018004 <esp_flash_chip_driver_initialized>:
{
42018004:	004136        	entry	a1, 32
    if (!chip->chip_drv) return false;
42018007:	1298      	l32i.n	a9, a2, 4
42018009:	080c      	movi.n	a8, 0
4201800b:	120c      	movi.n	a2, 1
4201800d:	832890        	moveqz	a2, a8, a9
}
42018010:	f01d      	retw.n
	...

42018014 <mpu_hal_set_region_access>:
#include "hal/mpu_types.h"

#include "soc/soc_caps.h"

void mpu_hal_set_region_access(int id, mpu_access_t access)
{
42018014:	004136        	entry	a1, 32
    // 0x60000000 = 3
    // 0x80000000 = 4
    // 0xa0000000 = 5
    // 0xc0000000 = 6
    // 0xe0000000 = 7
    return id * SOC_MPU_MIN_REGION_SIZE;
42018017:	012230        	slli	a2, a2, 29
    uint32_t addr = mpu_ll_id_to_addr(id);

    switch (access)
4201801a:	1f2326        	beqi	a3, 2, 4201803d <mpu_hal_set_region_access+0x29>
4201801d:	0c33f6        	bgeui	a3, 3, 4201802d <mpu_hal_set_region_access+0x19>
42018020:	e3cc      	bnez.n	a3, 42018032 <mpu_hal_set_region_access+0x1e>
    WITLB(0x3, addr); // cached
}

static inline void mpu_ll_set_region_illegal(uint32_t addr)
{
    WITLB(0xF, addr);
42018022:	f30c      	movi.n	a3, 15
42018024:	506230        	witlb	a3, a2
42018027:	002000        	isync
4201802a:	000186        	j	42018034 <mpu_hal_set_region_access+0x20>
4201802d:	173326        	beqi	a3, 3, 42018048 <mpu_hal_set_region_access+0x34>
            mpu_ll_set_region_illegal(addr);
            break;
        default:
            break;
    }
}
42018030:	f01d      	retw.n
    WDTLB(0x0, addr); // cached, no allocate
42018032:	030c      	movi.n	a3, 0
    WDTLB(0xF, addr);
42018034:	50e230        	wdtlb	a3, a2
42018037:	002030        	dsync
4201803a:	fffc86        	j	42018030 <mpu_hal_set_region_access+0x1c>
    WITLB(0x3, addr); // cached
4201803d:	330c      	movi.n	a3, 3
4201803f:	506230        	witlb	a3, a2
42018042:	002000        	isync
}
42018045:	fff9c6        	j	42018030 <mpu_hal_set_region_access+0x1c>
    WDTLB(0x2, addr); // bypass cache
42018048:	230c      	movi.n	a3, 2
4201804a:	fff986        	j	42018034 <mpu_hal_set_region_access+0x20>
4201804d:	000000        	ill

42018050 <uart_hal_get_sclk>:
{
42018050:	004136        	entry	a1, 32
    uart_ll_get_sclk(hal->dev, sclk);
42018053:	0288      	l32i.n	a8, a2, 0
    switch (hw->clk_conf.sclk_sel) {
42018055:	990c      	movi.n	a9, 9
42018057:	0020c0        	memw
4201805a:	1e2882        	l32i	a8, a8, 120
4201805d:	158480        	extui	a8, a8, 20, 2
42018060:	092826        	beqi	a8, 2, 4201806d <uart_hal_get_sclk+0x1d>
42018063:	fdc882        	addi	a8, a8, -3
42018066:	490c      	movi.n	a9, 4
42018068:	ba0c      	movi.n	a10, 11
4201806a:	839a80        	moveqz	a9, a10, a8
            *source_clk = UART_SCLK_APB;
4201806d:	0399      	s32i.n	a9, a3, 0
}
4201806f:	f01d      	retw.n
42018071:	000000        	ill

42018074 <uart_hal_get_baudrate>:
{
42018074:	006136        	entry	a1, 48
    *baud_rate = uart_ll_get_baudrate(hal->dev, sclk_freq);
42018077:	02a8      	l32i.n	a10, a2, 0
    return ((sclk_freq << 4)) /
42018079:	1144c0        	slli	a4, a4, 4
    div_reg.val = hw->clkdiv.val;
4201807c:	0020c0        	memw
4201807f:	5a88      	l32i.n	a8, a10, 20
        (((div_reg.clkdiv << 4) | div_reg.clkdiv_frag) * (HAL_FORCE_READ_U32_REG_FIELD(hw->clk_conf, sclk_div_num) + 1));
42018081:	b49080        	extui	a9, a8, 0, 12
42018084:	1199c0        	slli	a9, a9, 4
42018087:	358480        	extui	a8, a8, 20, 4
4201808a:	209980        	or	a9, a9, a8
4201808d:	0020c0        	memw
42018090:	1e2a82        	l32i	a8, a10, 120
42018093:	0020c0        	memw
42018096:	0189      	s32i.n	a8, a1, 0
42018098:	0020c0        	memw
4201809b:	0188      	l32i.n	a8, a1, 0
4201809d:	748c80        	extui	a8, a8, 12, 8
420180a0:	881b      	addi.n	a8, a8, 1
420180a2:	828890        	mull	a8, a8, a9
    return ((sclk_freq << 4)) /
420180a5:	c24480        	quou	a4, a4, a8
420180a8:	0349      	s32i.n	a4, a3, 0
}
420180aa:	f01d      	retw.n

420180ac <uart_hal_set_stop_bits>:
{
420180ac:	004136        	entry	a1, 32
    uart_ll_set_stop_bits(hal->dev, stop_bit);
420180af:	0298      	l32i.n	a9, a2, 0
    hw->conf0.stop_bit_num = stop_bit;
420180b1:	143030        	extui	a3, a3, 0, 2
420180b4:	0020c0        	memw
420180b7:	8988      	l32i.n	a8, a9, 32
420180b9:	cfafa2        	movi	a10, -49
420180bc:	1133c0        	slli	a3, a3, 4
420180bf:	1088a0        	and	a8, a8, a10
420180c2:	208830        	or	a8, a8, a3
420180c5:	0020c0        	memw
420180c8:	8989      	s32i.n	a8, a9, 32
}
420180ca:	f01d      	retw.n

420180cc <uart_hal_get_stop_bits>:
{
420180cc:	004136        	entry	a1, 32
    uart_ll_get_stop_bits(hal->dev, stop_bit);
420180cf:	0288      	l32i.n	a8, a2, 0
    *stop_bit = (uart_stop_bits_t)hw->conf0.stop_bit_num;
420180d1:	0020c0        	memw
420180d4:	8888      	l32i.n	a8, a8, 32
420180d6:	148480        	extui	a8, a8, 4, 2
420180d9:	0389      	s32i.n	a8, a3, 0
}
420180db:	f01d      	retw.n
420180dd:	000000        	ill

420180e0 <uart_hal_set_data_bit_num>:
{
420180e0:	004136        	entry	a1, 32
    uart_ll_set_data_bit_num(hal->dev, data_bit);
420180e3:	0298      	l32i.n	a9, a2, 0
    hw->conf0.bit_num = data_bit;
420180e5:	143030        	extui	a3, a3, 0, 2
420180e8:	0020c0        	memw
420180eb:	8988      	l32i.n	a8, a9, 32
420180ed:	3a7c      	movi.n	a10, -13
420180ef:	1133e0        	slli	a3, a3, 2
420180f2:	1088a0        	and	a8, a8, a10
420180f5:	208830        	or	a8, a8, a3
420180f8:	0020c0        	memw
420180fb:	8989      	s32i.n	a8, a9, 32
}
420180fd:	f01d      	retw.n
	...

42018100 <uart_hal_get_data_bit_num>:
{
42018100:	004136        	entry	a1, 32
    uart_ll_get_data_bit_num(hal->dev, data_bit);
42018103:	0288      	l32i.n	a8, a2, 0
    *data_bit = (uart_word_length_t)hw->conf0.bit_num;
42018105:	0020c0        	memw
42018108:	8888      	l32i.n	a8, a8, 32
4201810a:	148280        	extui	a8, a8, 2, 2
4201810d:	0389      	s32i.n	a8, a3, 0
}
4201810f:	f01d      	retw.n
42018111:	000000        	ill

42018114 <uart_hal_set_parity>:
{
42018114:	004136        	entry	a1, 32
    uart_ll_set_parity(hal->dev, parity_mode);
42018117:	0298      	l32i.n	a9, a2, 0
    if (parity_mode != UART_PARITY_DISABLE) {
42018119:	339c      	beqz.n	a3, 42018130 <uart_hal_set_parity+0x1c>
        hw->conf0.parity = parity_mode & 0x1;
4201811b:	0020c0        	memw
4201811e:	8988      	l32i.n	a8, a9, 32
42018120:	eb7c      	movi.n	a11, -2
42018122:	04a030        	extui	a10, a3, 0, 1
42018125:	1088b0        	and	a8, a8, a11
42018128:	2088a0        	or	a8, a8, a10
4201812b:	0020c0        	memw
4201812e:	8989      	s32i.n	a8, a9, 32
    hw->conf0.parity_en = (parity_mode >> 1) & 0x1;
42018130:	0020c0        	memw
42018133:	8988      	l32i.n	a8, a9, 32
42018135:	043130        	extui	a3, a3, 1, 1
42018138:	da7c      	movi.n	a10, -3
4201813a:	333a      	add.n	a3, a3, a3
4201813c:	1088a0        	and	a8, a8, a10
4201813f:	208830        	or	a8, a8, a3
42018142:	0020c0        	memw
42018145:	8989      	s32i.n	a8, a9, 32
}
42018147:	f01d      	retw.n
42018149:	000000        	ill

4201814c <uart_hal_get_parity>:
{
4201814c:	004136        	entry	a1, 32
    uart_ll_get_parity(hal->dev, parity_mode);
4201814f:	0298      	l32i.n	a9, a2, 0
        *parity_mode = UART_PARITY_DISABLE;
42018151:	080c      	movi.n	a8, 0
    if (hw->conf0.parity_en) {
42018153:	0020c0        	memw
42018156:	89a8      	l32i.n	a10, a9, 32
42018158:	0c6a17        	bbci	a10, 1, 42018168 <uart_hal_get_parity+0x1c>
        *parity_mode = (uart_parity_t)(0x2 | hw->conf0.parity);
4201815b:	0020c0        	memw
4201815e:	8988      	l32i.n	a8, a9, 32
42018160:	290c      	movi.n	a9, 2
42018162:	048080        	extui	a8, a8, 0, 1
42018165:	208890        	or	a8, a8, a9
42018168:	0389      	s32i.n	a8, a3, 0
}
4201816a:	f01d      	retw.n

4201816c <uart_hal_set_rxfifo_full_thr>:
{
4201816c:	004136        	entry	a1, 32
    uart_ll_set_rxfifo_full_thr(hal->dev, full_thrhd);
4201816f:	0298      	l32i.n	a9, a2, 0
    hw->conf1.rxfifo_full_thrhd = full_thrhd;
42018171:	00aca2        	movi	a10, 0xfffffc00
42018174:	0020c0        	memw
42018177:	9988      	l32i.n	a8, a9, 36
42018179:	943030        	extui	a3, a3, 0, 10
4201817c:	1088a0        	and	a8, a8, a10
4201817f:	208830        	or	a8, a8, a3
42018182:	0020c0        	memw
42018185:	9989      	s32i.n	a8, a9, 36
}
42018187:	f01d      	retw.n
42018189:	000000        	ill

4201818c <uart_hal_get_symb_len>:
{
4201818c:	004136        	entry	a1, 32
    uart_ll_get_data_bit_num(hal->dev, &data_bit);
4201818f:	0298      	l32i.n	a9, a2, 0
        *parity_mode = UART_PARITY_DISABLE;
42018191:	080c      	movi.n	a8, 0
    *data_bit = (uart_word_length_t)hw->conf0.bit_num;
42018193:	0020c0        	memw
42018196:	8928      	l32i.n	a2, a9, 32
    *stop_bit = (uart_stop_bits_t)hw->conf0.stop_bit_num;
42018198:	0020c0        	memw
4201819b:	89a8      	l32i.n	a10, a9, 32
    if (hw->conf0.parity_en) {
4201819d:	0020c0        	memw
420181a0:	89b8      	l32i.n	a11, a9, 32
    *data_bit = (uart_word_length_t)hw->conf0.bit_num;
420181a2:	142220        	extui	a2, a2, 2, 2
    *stop_bit = (uart_stop_bits_t)hw->conf0.stop_bit_num;
420181a5:	14a4a0        	extui	a10, a10, 4, 2
    if (hw->conf0.parity_en) {
420181a8:	0d6b17        	bbci	a11, 1, 420181b9 <uart_hal_get_symb_len+0x2d>
        *parity_mode = (uart_parity_t)(0x2 | hw->conf0.parity);
420181ab:	0020c0        	memw
420181ae:	8988      	l32i.n	a8, a9, 32
420181b0:	02a092        	movi	a9, 2
420181b3:	048080        	extui	a8, a8, 0, 1
420181b6:	208890        	or	a8, a8, a9
    symbol_len += (stop_bit > UART_STOP_BITS_1) ? 2 : 1;
420181b9:	2b0c      	movi.n	a11, 2
    symbol_len += (data_bit < UART_DATA_BITS_MAX) ? (uint8_t)data_bit + 5 : 8;
420181bb:	226b      	addi.n	a2, a2, 6
    symbol_len += (stop_bit > UART_STOP_BITS_1) ? 2 : 1;
420181bd:	190c      	movi.n	a9, 1
420181bf:	01bab7        	bgeu	a10, a11, 420181c4 <uart_hal_get_symb_len+0x38>
420181c2:	09bd      	mov.n	a11, a9
    symbol_len += (parity_mode > UART_PARITY_DISABLE) ? 1 : 0;
420181c4:	0a0c      	movi.n	a10, 0
420181c6:	839a80        	moveqz	a9, a10, a8
420181c9:	229a      	add.n	a2, a2, a9
420181cb:	22ba      	add.n	a2, a2, a11
}
420181cd:	742020        	extui	a2, a2, 0, 8
420181d0:	f01d      	retw.n
	...

420181d4 <_fwalk>:
420181d4:	004136        	entry	a1, 32
420181d7:	d8a042        	movi	a4, 216
420181da:	424a      	add.n	a4, a2, a4
420181dc:	020c      	movi.n	a2, 0
420181de:	2458      	l32i.n	a5, a4, 8
420181e0:	1468      	l32i.n	a6, a4, 4
420181e2:	000586        	j	420181fc <_fwalk+0x28>
420181e5:	061582        	l16ui	a8, a5, 12
420181e8:	0d28b6        	bltui	a8, 2, 420181f9 <_fwalk+0x25>
420181eb:	079582        	l16si	a8, a5, 14
420181ee:	070826        	beqi	a8, -1, 420181f9 <_fwalk+0x25>
420181f1:	05ad      	mov.n	a10, a5
420181f3:	0003e0        	callx8	a3
420181f6:	2022a0        	or	a2, a2, a10
420181f9:	68c552        	addi	a5, a5, 104
420181fc:	660b      	addi.n	a6, a6, -1
420181fe:	fe36d6        	bgez	a6, 420181e5 <_fwalk+0x11>
42018201:	0448      	l32i.n	a4, a4, 0
42018203:	fd7456        	bnez	a4, 420181de <_fwalk+0xa>
42018206:	f01d      	retw.n

42018208 <_fwalk_reent>:
42018208:	004136        	entry	a1, 32
4201820b:	d8a042        	movi	a4, 216
4201820e:	027d      	mov.n	a7, a2
42018210:	424a      	add.n	a4, a2, a4
42018212:	020c      	movi.n	a2, 0
42018214:	2458      	l32i.n	a5, a4, 8
42018216:	1468      	l32i.n	a6, a4, 4
42018218:	0006c6        	j	42018237 <_fwalk_reent+0x2f>
4201821b:	00          	.byte 00
4201821c:	00          	.byte 00
4201821d:	061582        	l16ui	a8, a5, 12
42018220:	1028b6        	bltui	a8, 2, 42018234 <_fwalk_reent+0x2c>
42018223:	079582        	l16si	a8, a5, 14
42018226:	0a0826        	beqi	a8, -1, 42018234 <_fwalk_reent+0x2c>
42018229:	05bd      	mov.n	a11, a5
4201822b:	20a770        	or	a10, a7, a7
4201822e:	0003e0        	callx8	a3
42018231:	2022a0        	or	a2, a2, a10
42018234:	68c552        	addi	a5, a5, 104
42018237:	660b      	addi.n	a6, a6, -1
42018239:	fe06d6        	bgez	a6, 4201821d <_fwalk_reent+0x15>
4201823c:	0448      	l32i.n	a4, a4, 0
4201823e:	fd2456        	bnez	a4, 42018214 <_fwalk_reent+0xc>
42018241:	f01d      	retw.n
	...

42018244 <__sflags>:
42018244:	004136        	entry	a1, 32
42018247:	000382        	l8ui	a8, a3, 0
4201824a:	72a052        	movi	a5, 114
4201824d:	3b1857        	beq	a8, a5, 4201828c <__sflags+0x48>
42018250:	77a052        	movi	a5, 119
42018253:	3e1857        	beq	a8, a5, 42018295 <__sflags+0x51>
42018256:	61a052        	movi	a5, 97
42018259:	431857        	beq	a8, a5, 420182a0 <__sflags+0x5c>
4201825c:	631c      	movi.n	a3, 22
4201825e:	0239      	s32i.n	a3, a2, 0
42018260:	020c      	movi.n	a2, 0
42018262:	001706        	j	420182c2 <__sflags+0x7e>
42018265:	071ab7        	beq	a10, a11, 42018270 <__sflags+0x2c>
42018268:	141a57        	beq	a10, a5, 42018280 <__sflags+0x3c>
4201826b:	001186        	j	420182b5 <__sflags+0x71>
4201826e:	00          	.byte 00
4201826f:	00          	.byte 00
42018270:	1022c0        	and	a2, a2, a12
42018273:	1088e0        	and	a8, a8, a14
42018276:	2022d0        	or	a2, a2, a13
42018279:	2088f0        	or	a8, a8, a15
4201827c:	000d46        	j	420182b5 <__sflags+0x71>
4201827f:	00          	.byte 00
42018280:	1a0c      	movi.n	a10, 1
42018282:	11aa50        	slli	a10, a10, 11
42018285:	2088a0        	or	a8, a8, a10
42018288:	000a46        	j	420182b5 <__sflags+0x71>
4201828b:	00          	.byte 00
4201828c:	090c      	movi.n	a9, 0
4201828e:	098d      	mov.n	a8, a9
42018290:	420c      	movi.n	a2, 4
42018292:	000486        	j	420182a8 <__sflags+0x64>
42018295:	00a692        	movi	a9, 0x600
42018298:	180c      	movi.n	a8, 1
4201829a:	820c      	movi.n	a2, 8
4201829c:	000206        	j	420182a8 <__sflags+0x64>
4201829f:	00          	.byte 00
420182a0:	08a292        	movi	a9, 0x208
420182a3:	180c      	movi.n	a8, 1
420182a5:	08a122        	movi	a2, 0x108
420182a8:	bb2c      	movi.n	a11, 43
420182aa:	3c6c      	movi.n	a12, -29
420182ac:	0d1c      	movi.n	a13, 16
420182ae:	ce7c      	movi.n	a14, -4
420182b0:	2f0c      	movi.n	a15, 2
420182b2:	78a052        	movi	a5, 120
420182b5:	0103a2        	l8ui	a10, a3, 1
420182b8:	331b      	addi.n	a3, a3, 1
420182ba:	fa7a56        	bnez	a10, 42018265 <__sflags+0x21>
420182bd:	208890        	or	a8, a8, a9
420182c0:	0489      	s32i.n	a8, a4, 0
420182c2:	f01d      	retw.n

420182c4 <esp_cpu_intr_get_desc>:
{
420182c4:	004136        	entry	a1, 32
    assert(core_id >= 0 && core_id < SOC_CPU_CORES_NUM);
420182c7:	1122b6        	bltui	a2, 2, 420182dc <esp_cpu_intr_get_desc+0x18>
420182ca:	a298d1        	l32r	a13, 42000d2c <_stext+0xd0c>
420182cd:	a298c1        	l32r	a12, 42000d30 <_stext+0xd10>
420182d0:	a299a1        	l32r	a10, 42000d34 <_stext+0xd14>
420182d3:	00a1b2        	movi	a11, 0x100
420182d6:	9f6b81        	l32r	a8, 42000084 <_stext+0x64>
420182d9:	0008e0        	callx8	a8
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
420182dc:	a29791        	l32r	a9, 42000d38 <_stext+0xd18>
420182df:	1183c0        	slli	a8, a3, 4
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
420182e2:	a03320        	addx4	a3, a3, a2
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
420182e5:	898a      	add.n	a8, a9, a8
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
420182e7:	a03390        	addx4	a3, a3, a9
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
420182ea:	08a8      	l32i.n	a10, a8, 0
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
420182ec:	2328      	l32i.n	a2, a3, 8
    intr_desc_ret->type = intr_desc_table[intr_num].type;
420182ee:	1888      	l32i.n	a8, a8, 4
    intr_desc_ret->priority = intr_desc_table[intr_num].priority;
420182f0:	04a9      	s32i.n	a10, a4, 0
    intr_desc_ret->type = intr_desc_table[intr_num].type;
420182f2:	1489      	s32i.n	a8, a4, 4
    intr_desc_ret->flags = intr_desc_table[intr_num].flags[core_id];
420182f4:	2429      	s32i.n	a2, a4, 8
}
420182f6:	f01d      	retw.n

420182f8 <esp_cpu_configure_region_protection>:
{
420182f8:	008136        	entry	a1, 64
    const int illegal_regions[] = {0, 4, 5, 6, 7}; // 0x00000000, 0x80000000, 0xa0000000, 0xc0000000, 0xe0000000
420182fb:	a290b1        	l32r	a11, 42000d3c <_stext+0xd1c>
420182fe:	4c1c      	movi.n	a12, 20
42018300:	01ad      	mov.n	a10, a1
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
42018302:	020c      	movi.n	a2, 0
    const int illegal_regions[] = {0, 4, 5, 6, 7}; // 0x00000000, 0x80000000, 0xa0000000, 0xc0000000, 0xe0000000
42018304:	9fb281        	l32r	a8, 420001cc <_stext+0x1ac>
42018307:	0008e0        	callx8	a8
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
4201830a:	013d      	mov.n	a3, a1
        mpu_hal_set_region_access(illegal_regions[i], MPU_REGION_ILLEGAL);
4201830c:	024d      	mov.n	a4, a2
4201830e:	0023a2        	l32i	a10, a3, 0
42018311:	20b440        	or	a11, a4, a4
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
42018314:	221b      	addi.n	a2, a2, 1
        mpu_hal_set_region_access(illegal_regions[i], MPU_REGION_ILLEGAL);
42018316:	ffcfe5        	call8	42018014 <mpu_hal_set_region_access>
    for (size_t i = 0; i < sizeof(illegal_regions) / sizeof(illegal_regions[0]); ++i) {
42018319:	334b      	addi.n	a3, a3, 4
4201831b:	ef5266        	bnei	a2, 5, 4201830e <esp_cpu_configure_region_protection+0x16>
    mpu_hal_set_region_access(1, MPU_REGION_RW); // 0x20000000
4201831e:	1b0c      	movi.n	a11, 1
42018320:	0bad      	mov.n	a10, a11
42018322:	ffcf25        	call8	42018014 <mpu_hal_set_region_access>
}
42018325:	f01d      	retw.n
	...

42018328 <esp_cpu_set_breakpoint>:
{
42018328:	004136        	entry	a1, 32
    if (bp_num == 1) {
4201832b:	191266        	bnei	a2, 1, 42018348 <esp_cpu_set_breakpoint+0x20>
        WSR(IBREAKA_1, bp_addr);
4201832e:	138130        	wsr.ibreaka1	a3
    RSR(IBREAKENABLE, brk_ena_reg);
42018331:	036030        	rsr.ibreakenable	a3
    brk_ena_reg |= BIT(bp_num);
42018334:	180c      	movi.n	a8, 1
42018336:	401200        	ssl	a2
42018339:	a18800        	sll	a8, a8
4201833c:	208830        	or	a8, a8, a3
    WSR(IBREAKENABLE, brk_ena_reg);
4201833f:	136080        	wsr.ibreakenable	a8
}
42018342:	020c      	movi.n	a2, 0
42018344:	f01d      	retw.n
42018346:	00          	.byte 00
42018347:	00          	.byte 00
        WSR(IBREAKA_0, bp_addr);
42018348:	138030        	wsr.ibreaka0	a3
4201834b:	fff886        	j	42018331 <esp_cpu_set_breakpoint+0x9>
	...

42018350 <get_rtc_dbias_by_efuse$constprop$0>:
        ESP_HW_LOGW(TAG, "efuse read fail, set default dig_dbias value: %d\n", dig_dbias);
    }
    return dig_dbias;
}

static uint32_t get_rtc_dbias_by_efuse(uint8_t pvt_scheme_ver, uint32_t dig_dbias)
42018350:	006136        	entry	a1, 48
{
    assert(pvt_scheme_ver == 1);
    uint32_t rtc_dbias = 0;
    signed int k_rtc_ldo = 0, k_dig_ldo = 0, v_rtc_bias20 = 0, v_dig_bias20 = 0;
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_RTC_LDO, &k_rtc_ldo, ESP_EFUSE_K_RTC_LDO[0]->bit_count);
42018353:	a27ba1        	l32r	a10, 42000d40 <_stext+0xd20>
    signed int k_rtc_ldo = 0, k_dig_ldo = 0, v_rtc_bias20 = 0, v_dig_bias20 = 0;
42018356:	030c      	movi.n	a3, 0
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_RTC_LDO, &k_rtc_ldo, ESP_EFUSE_K_RTC_LDO[0]->bit_count);
42018358:	0a48      	l32i.n	a4, a10, 0
4201835a:	b1cb      	addi.n	a11, a1, 12
4201835c:	0114c2        	l16ui	a12, a4, 2
    signed int k_rtc_ldo = 0, k_dig_ldo = 0, v_rtc_bias20 = 0, v_dig_bias20 = 0;
4201835f:	3139      	s32i.n	a3, a1, 12
42018361:	2139      	s32i.n	a3, a1, 8
42018363:	1139      	s32i.n	a3, a1, 4
42018365:	006132        	s32i	a3, a1, 0
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_RTC_LDO, &k_rtc_ldo, ESP_EFUSE_K_RTC_LDO[0]->bit_count);
42018368:	ee1a25        	call8	4200650c <esp_efuse_read_field_blob>
4201836b:	0a4d      	mov.n	a4, a10
    esp_err_t err1 = esp_efuse_read_field_blob(ESP_EFUSE_K_DIG_LDO, &k_dig_ldo, ESP_EFUSE_K_DIG_LDO[0]->bit_count);
4201836d:	a275a1        	l32r	a10, 42000d44 <_stext+0xd24>
42018370:	b18b      	addi.n	a11, a1, 8
42018372:	0a58      	l32i.n	a5, a10, 0
42018374:	0115c2        	l16ui	a12, a5, 2
42018377:	ee1965        	call8	4200650c <esp_efuse_read_field_blob>
4201837a:	0a6d      	mov.n	a6, a10
    esp_err_t err2 = esp_efuse_read_field_blob(ESP_EFUSE_V_RTC_DBIAS20, &v_rtc_bias20, ESP_EFUSE_V_RTC_DBIAS20[0]->bit_count);
4201837c:	a273a1        	l32r	a10, 42000d48 <_stext+0xd28>
4201837f:	b14b      	addi.n	a11, a1, 4
42018381:	0a58      	l32i.n	a5, a10, 0
    esp_err_t err3 = esp_efuse_read_field_blob(ESP_EFUSE_V_DIG_DBIAS20, &v_dig_bias20, ESP_EFUSE_V_DIG_DBIAS20[0]->bit_count);
    if ((err0 != ESP_OK) | (err1 != ESP_OK) | (err2 != ESP_OK) | (err3 != ESP_OK)) {
42018383:	204460        	or	a4, a4, a6
    esp_err_t err2 = esp_efuse_read_field_blob(ESP_EFUSE_V_RTC_DBIAS20, &v_rtc_bias20, ESP_EFUSE_V_RTC_DBIAS20[0]->bit_count);
42018386:	0115c2        	l16ui	a12, a5, 2
42018389:	ee1825        	call8	4200650c <esp_efuse_read_field_blob>
4201838c:	0a5d      	mov.n	a5, a10
    esp_err_t err3 = esp_efuse_read_field_blob(ESP_EFUSE_V_DIG_DBIAS20, &v_dig_bias20, ESP_EFUSE_V_DIG_DBIAS20[0]->bit_count);
4201838e:	a26fa1        	l32r	a10, 42000d4c <_stext+0xd2c>
42018391:	20b110        	or	a11, a1, a1
42018394:	002a82        	l32i	a8, a10, 0
    if ((err0 != ESP_OK) | (err1 != ESP_OK) | (err2 != ESP_OK) | (err3 != ESP_OK)) {
42018397:	204450        	or	a4, a4, a5
    esp_err_t err3 = esp_efuse_read_field_blob(ESP_EFUSE_V_DIG_DBIAS20, &v_dig_bias20, ESP_EFUSE_V_DIG_DBIAS20[0]->bit_count);
4201839a:	0118c2        	l16ui	a12, a8, 2
4201839d:	ee16e5        	call8	4200650c <esp_efuse_read_field_blob>
    if ((err0 != ESP_OK) | (err1 != ESP_OK) | (err2 != ESP_OK) | (err3 != ESP_OK)) {
420183a0:	2044a0        	or	a4, a4, a10
420183a3:	071437        	beq	a4, a3, 420183ae <get_rtc_dbias_by_efuse$constprop$0+0x5e>
        k_rtc_ldo = 0;
420183a6:	3139      	s32i.n	a3, a1, 12
        k_dig_ldo = 0;
420183a8:	2139      	s32i.n	a3, a1, 8
        v_rtc_bias20 = 0;
420183aa:	1139      	s32i.n	a3, a1, 4
        v_dig_bias20 = 0;
420183ac:	0139      	s32i.n	a3, a1, 0
        ESP_HW_LOGW(TAG, "efuse read fail, k_rtc_ldo: %d, k_dig_ldo: %d, v_rtc_bias20: %d,  v_dig_bias20: %d\n", k_rtc_ldo, k_dig_ldo, v_rtc_bias20, v_dig_bias20);
        }

    k_rtc_ldo =  ((k_rtc_ldo & BIT(6)) != 0)? -(k_rtc_ldo & 0x3f): (uint8_t)k_rtc_ldo;
420183ae:	3138      	l32i.n	a3, a1, 12
420183b0:	084c      	movi.n	a8, 64
420183b2:	744030        	extui	a4, a3, 0, 8
420183b5:	050387        	bnone	a3, a8, 420183be <get_rtc_dbias_by_efuse$constprop$0+0x6e>
420183b8:	543030        	extui	a3, a3, 0, 6
420183bb:	604030        	neg	a4, a3
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
420183be:	2138      	l32i.n	a3, a1, 8
420183c0:	74a030        	extui	a10, a3, 0, 8
420183c3:	050387        	bnone	a3, a8, 420183cc <get_rtc_dbias_by_efuse$constprop$0+0x7c>
420183c6:	543030        	extui	a3, a3, 0, 6
420183c9:	60a030        	neg	a10, a3
    v_rtc_bias20 =  ((v_rtc_bias20 & BIT(7)) != 0)? -(v_rtc_bias20 & 0x7f): (uint8_t)v_rtc_bias20;
420183cc:	1138      	l32i.n	a3, a1, 4
420183ce:	80a0b2        	movi	a11, 128
420183d1:	748030        	extui	a8, a3, 0, 8
420183d4:	0503b7        	bnone	a3, a11, 420183dd <get_rtc_dbias_by_efuse$constprop$0+0x8d>
420183d7:	643030        	extui	a3, a3, 0, 7
420183da:	608030        	neg	a8, a3
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
420183dd:	0198      	l32i.n	a9, a1, 0
420183df:	743090        	extui	a3, a9, 0, 8
420183e2:	0509b7        	bnone	a9, a11, 420183eb <get_rtc_dbias_by_efuse$constprop$0+0x9b>
420183e5:	649090        	extui	a9, a9, 0, 7
420183e8:	603090        	neg	a3, a9

    uint32_t v_rtc_dbias20_real_mul10000 = V_RTC_MID_MUL10000 + v_rtc_bias20 * 10000 / 500;
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420183eb:	ecc292        	addi	a9, a2, -20
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420183ee:	d3a022        	movi	a2, 211
420183f1:	aa2a      	add.n	a10, a10, a2
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420183f3:	a25721        	l32r	a2, 42000d50 <_stext+0xd30>
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
420183f6:	8299a0        	mull	a9, a9, a10
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420183f9:	a03330        	addx4	a3, a3, a3
420183fc:	a03320        	addx4	a3, a3, a2
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
420183ff:	c6a022        	movi	a2, 198
    uint32_t v_dig_nearest_1v15_mul10000 = v_dig_dbias20_real_mul10000 + k_dig_ldo_real_mul10000 * (dig_dbias - 20);
42018402:	993a      	add.n	a9, a9, a3
    signed int k_rtc_ldo_real_mul10000 = K_RTC_MID_MUL10000 + k_rtc_ldo;
42018404:	342a      	add.n	a3, a4, a2
42018406:	1123e0        	slli	a2, a3, 2
42018409:	a25241        	l32r	a4, 42000d54 <_stext+0xd34>
4201840c:	602020        	neg	a2, a2
4201840f:	c02230        	sub	a2, a2, a3
42018412:	224a      	add.n	a2, a2, a4
    uint32_t v_rtc_dbias20_real_mul10000 = V_RTC_MID_MUL10000 + v_rtc_bias20 * 10000 / 500;
42018414:	a08880        	addx4	a8, a8, a8
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
        uint32_t v_rtc_nearest_1v15_mul10000 = 0;
        v_rtc_nearest_1v15_mul10000 = v_rtc_dbias20_real_mul10000 + k_rtc_ldo_real_mul10000 * (rtc_dbias - 20);
        if (v_rtc_nearest_1v15_mul10000 >= v_dig_nearest_1v15_mul10000 - 250) {
42018417:	06af42        	movi	a4, -250
4201841a:	a08820        	addx4	a8, a8, a2
4201841d:	994a      	add.n	a9, a9, a4
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
4201841f:	f20c      	movi.n	a2, 15
42018421:	10a042        	movi	a4, 16
        if (v_rtc_nearest_1v15_mul10000 >= v_dig_nearest_1v15_mul10000 - 250) {
42018424:	08b897        	bgeu	a8, a9, 42018430 <get_rtc_dbias_by_efuse$constprop$0+0xe0>
    for (rtc_dbias = 15; rtc_dbias < 31; rtc_dbias++) {
42018427:	221b      	addi.n	a2, a2, 1
42018429:	883a      	add.n	a8, a8, a3
4201842b:	440b      	addi.n	a4, a4, -1
4201842d:	ff3456        	bnez	a4, 42018424 <get_rtc_dbias_by_efuse$constprop$0+0xd4>
            break;
        }
    }
    return rtc_dbias;
}
42018430:	f01d      	retw.n
	...

42018434 <rtc_init>:
{
42018434:	00a136        	entry	a1, 80
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42018437:	a24841        	l32r	a4, 42000d58 <_stext+0xd38>
4201843a:	9fb751        	l32r	a5, 42000318 <_stext+0x2f8>
4201843d:	0020c0        	memw
42018440:	002432        	l32i	a3, a4, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_RTC_REG, 0);
42018443:	02a0e2        	movi	a14, 2
    CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42018446:	103350        	and	a3, a3, a5
42018449:	0020c0        	memw
4201844c:	006432        	s32i	a3, a4, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_RTC_REG, 0);
4201844f:	0edd      	mov.n	a13, a14
42018451:	0f0c      	movi.n	a15, 0
42018453:	dc0c      	movi.n	a12, 13
42018455:	1b0c      	movi.n	a11, 1
42018457:	6da0a2        	movi	a10, 109
4201845a:	9fb481        	l32r	a8, 4200032c <_stext+0x30c>
4201845d:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_XPD_DIG_REG, 0);
42018460:	3e0c      	movi.n	a14, 3
42018462:	0edd      	mov.n	a13, a14
42018464:	0f0c      	movi.n	a15, 0
42018466:	dc0c      	movi.n	a12, 13
42018468:	1b0c      	movi.n	a11, 1
4201846a:	6da0a2        	movi	a10, 109
4201846d:	9faf81        	l32r	a8, 4200032c <_stext+0x30c>
42018470:	0008e0        	callx8	a8
    CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_PVTMON_PU);
42018473:	a23a41        	l32r	a4, 42000d5c <_stext+0xd3c>
42018476:	9fac51        	l32r	a5, 42000328 <_stext+0x308>
42018479:	0020c0        	memw
4201847c:	0438      	l32i.n	a3, a4, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_PLL_BUF_WAIT, cfg.pll_wait);
4201847e:	a06261        	l32r	a6, 42000608 <_stext+0x5e8>
    CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_PVTMON_PU);
42018481:	103350        	and	a3, a3, a5
42018484:	0020c0        	memw
42018487:	0439      	s32i.n	a3, a4, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_PLL_BUF_WAIT, cfg.pll_wait);
42018489:	a23541        	l32r	a4, 42000d60 <_stext+0xd40>
4201848c:	753020        	extui	a3, a2, 16, 8
4201848f:	0020c0        	memw
42018492:	0458      	l32i.n	a5, a4, 0
42018494:	013380        	slli	a3, a3, 24
42018497:	105560        	and	a5, a5, a6
4201849a:	203350        	or	a3, a3, a5
4201849d:	0020c0        	memw
420184a0:	0439      	s32i.n	a3, a4, 0
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, cfg.ck8m_wait);
420184a2:	0020c0        	memw
420184a5:	0458      	l32i.n	a5, a4, 0
420184a7:	a22f61        	l32r	a6, 42000d64 <_stext+0xd44>
420184aa:	743020        	extui	a3, a2, 0, 8
420184ad:	105560        	and	a5, a5, a6
420184b0:	1133a0        	slli	a3, a3, 6
420184b3:	203350        	or	a3, a3, a5
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
420184b6:	a22c51        	l32r	a5, 42000d68 <_stext+0xd48>
    REG_SET_FIELD(RTC_CNTL_TIMER1_REG, RTC_CNTL_CK8M_WAIT, cfg.ck8m_wait);
420184b9:	0020c0        	memw
420184bc:	0439      	s32i.n	a3, a4, 0
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
420184be:	0020c0        	memw
420184c1:	0538      	l32i.n	a3, a5, 0
420184c3:	a22a41        	l32r	a4, 42000d6c <_stext+0xd4c>
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
420184c6:	a22a81        	l32r	a8, 42000d70 <_stext+0xd50>
    REG_SET_FIELD(RTC_CNTL_TIMER5_REG, RTC_CNTL_MIN_SLP_VAL, RTC_CNTL_MIN_SLP_VAL_MIN);
420184c9:	103340        	and	a3, a3, a4
420184cc:	00a242        	movi	a4, 0x200
420184cf:	203340        	or	a3, a3, a4
420184d2:	0020c0        	memw
420184d5:	0539      	s32i.n	a3, a5, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
420184d7:	0020c0        	memw
420184da:	0838      	l32i.n	a3, a8, 0
420184dc:	a22651        	l32r	a5, 42000d74 <_stext+0xd54>
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_WAIT_TIMER, rtc_init_cfg.wifi_wait_cycles);
420184df:	00aef2        	movi	a15, 0xfffffe00
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_POWERUP_TIMER, rtc_init_cfg.wifi_powerup_cycles);
420184e2:	103350        	and	a3, a3, a5
420184e5:	203340        	or	a3, a3, a4
420184e8:	0020c0        	memw
420184eb:	0839      	s32i.n	a3, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_WIFI_WAIT_TIMER, rtc_init_cfg.wifi_wait_cycles);
420184ed:	0020c0        	memw
420184f0:	0898      	l32i.n	a9, a8, 0
420184f2:	130c      	movi.n	a3, 1
420184f4:	1099f0        	and	a9, a9, a15
420184f7:	209930        	or	a9, a9, a3
420184fa:	0020c0        	memw
420184fd:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_POWERUP_TIMER, rtc_init_cfg.bt_powerup_cycles);
420184ff:	0020c0        	memw
42018502:	0898      	l32i.n	a9, a8, 0
42018504:	9f1be1        	l32r	a14, 42000170 <_stext+0x150>
42018507:	01d370        	slli	a13, a3, 25
4201850a:	1099e0        	and	a9, a9, a14
4201850d:	2099d0        	or	a9, a9, a13
42018510:	0020c0        	memw
42018513:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER3_REG, RTC_CNTL_BT_WAIT_TIMER, rtc_init_cfg.bt_wait_cycles);
42018515:	0020c0        	memw
42018518:	0898      	l32i.n	a9, a8, 0
4201851a:	a217c1        	l32r	a12, 42000d78 <_stext+0xd58>
4201851d:	11b300        	slli	a11, a3, 16
42018520:	1099c0        	and	a9, a9, a12
42018523:	2099b0        	or	a9, a9, a11
42018526:	0020c0        	memw
42018529:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_POWERUP_TIMER, rtc_init_cfg.cpu_top_powerup_cycles);
4201852b:	a21481        	l32r	a8, 42000d7c <_stext+0xd5c>
4201852e:	0020c0        	memw
42018531:	0898      	l32i.n	a9, a8, 0
42018533:	109950        	and	a9, a9, a5
42018536:	209940        	or	a9, a9, a4
42018539:	0020c0        	memw
4201853c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_CPU_TOP_WAIT_TIMER, rtc_init_cfg.cpu_top_wait_cycles);
4201853e:	0020c0        	memw
42018541:	0898      	l32i.n	a9, a8, 0
42018543:	1099f0        	and	a9, a9, a15
42018546:	209930        	or	a9, a9, a3
42018549:	0020c0        	memw
4201854c:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_POWERUP_TIMER, rtc_init_cfg.rtc_powerup_cycles);
4201854e:	a20c91        	l32r	a9, 42000d80 <_stext+0xd60>
42018551:	0020c0        	memw
42018554:	09a8      	l32i.n	a10, a9, 0
42018556:	10aa50        	and	a10, a10, a5
42018559:	20aa40        	or	a10, a10, a4
4201855c:	0020c0        	memw
4201855f:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_WAIT_TIMER, rtc_init_cfg.rtc_wait_cycles);
42018561:	0020c0        	memw
42018564:	09a8      	l32i.n	a10, a9, 0
42018566:	10aaf0        	and	a10, a10, a15
42018569:	20aa30        	or	a10, a10, a3
4201856c:	0020c0        	memw
4201856f:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_POWERUP_TIMER, rtc_init_cfg.dg_wrap_powerup_cycles);
42018571:	0020c0        	memw
42018574:	09a8      	l32i.n	a10, a9, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
42018576:	7f1c      	movi.n	a15, 23
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_POWERUP_TIMER, rtc_init_cfg.dg_wrap_powerup_cycles);
42018578:	10aae0        	and	a10, a10, a14
4201857b:	20aad0        	or	a10, a10, a13
4201857e:	0020c0        	memw
42018581:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER4_REG, RTC_CNTL_DG_WRAP_WAIT_TIMER, rtc_init_cfg.dg_wrap_wait_cycles);
42018583:	0020c0        	memw
42018586:	09a8      	l32i.n	a10, a9, 0
42018588:	10aac0        	and	a10, a10, a12
4201858b:	20aab0        	or	a10, a10, a11
4201858e:	0020c0        	memw
42018591:	09a9      	s32i.n	a10, a9, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_POWERUP_TIMER, rtc_init_cfg.dg_peri_powerup_cycles);
42018593:	0020c0        	memw
42018596:	0898      	l32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
42018598:	6da0a2        	movi	a10, 109
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_POWERUP_TIMER, rtc_init_cfg.dg_peri_powerup_cycles);
4201859b:	1099e0        	and	a9, a9, a14
4201859e:	2099d0        	or	a9, a9, a13
420185a1:	0020c0        	memw
420185a4:	0899      	s32i.n	a9, a8, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_WAIT_TIMER, rtc_init_cfg.dg_peri_wait_cycles);
420185a6:	0020c0        	memw
420185a9:	0898      	l32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
420185ab:	0e0c      	movi.n	a14, 0
    REG_SET_FIELD(RTC_CNTL_TIMER6_REG, RTC_CNTL_DG_PERI_WAIT_TIMER, rtc_init_cfg.dg_peri_wait_cycles);
420185ad:	1099c0        	and	a9, a9, a12
420185b0:	2099b0        	or	a9, a9, a11
420185b3:	0020c0        	memw
420185b6:	0899      	s32i.n	a9, a8, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG_SLEEP, RTC_CNTL_DBIAS_1V10);
420185b8:	03bd      	mov.n	a11, a3
420185ba:	4d0c      	movi.n	a13, 4
420185bc:	5c0c      	movi.n	a12, 5
420185be:	9f5b81        	l32r	a8, 4200032c <_stext+0x30c>
420185c1:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, RTC_CNTL_DBIAS_1V10);
420185c4:	4d0c      	movi.n	a13, 4
420185c6:	03bd      	mov.n	a11, a3
420185c8:	7f1c      	movi.n	a15, 23
420185ca:	0e0c      	movi.n	a14, 0
420185cc:	0dcd      	mov.n	a12, a13
420185ce:	6da0a2        	movi	a10, 109
420185d1:	9f5681        	l32r	a8, 4200032c <_stext+0x30c>
420185d4:	0008e0        	callx8	a8
    REG_SET_FIELD(RTC_CNTL_TIMER2_REG, RTC_CNTL_ULPCP_TOUCH_START_WAIT, RTC_CNTL_ULPCP_TOUCH_START_WAIT_DEFAULT);
420185d7:	a1eb41        	l32r	a4, 42000d84 <_stext+0xd64>
420185da:	a1eb51        	l32r	a5, 42000d88 <_stext+0xd68>
420185dd:	0020c0        	memw
420185e0:	0488      	l32i.n	a8, a4, 0
420185e2:	0133d0        	slli	a3, a3, 19
420185e5:	108850        	and	a8, a8, a5
420185e8:	203830        	or	a3, a8, a3
420185eb:	0020c0        	memw
420185ee:	0439      	s32i.n	a3, a4, 0
    if (cfg.cali_ocode) {
420185f0:	02f2e7        	bbsi	a2, 30, 420185f6 <rtc_init+0x1c2>
420185f3:	005586        	j	4201874d <rtc_init+0x319>
        esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_BLK_VERSION_MAJOR, &blk_ver_major, ESP_EFUSE_BLK_VERSION_MAJOR[0]->bit_count); // IDF-5366
420185f6:	a1e5a1        	l32r	a10, 42000d8c <_stext+0xd6c>
        uint32_t blk_ver_major = 0;
420185f9:	030c      	movi.n	a3, 0
        esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_BLK_VERSION_MAJOR, &blk_ver_major, ESP_EFUSE_BLK_VERSION_MAJOR[0]->bit_count); // IDF-5366
420185fb:	0a48      	l32i.n	a4, a10, 0
420185fd:	10c1b2        	addi	a11, a1, 16
42018600:	0114c2        	l16ui	a12, a4, 2
        uint32_t blk_ver_major = 0;
42018603:	4139      	s32i.n	a3, a1, 16
        esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_BLK_VERSION_MAJOR, &blk_ver_major, ESP_EFUSE_BLK_VERSION_MAJOR[0]->bit_count); // IDF-5366
42018605:	edf065        	call8	4200650c <esp_efuse_read_field_blob>
        if (err != ESP_OK) {
42018608:	029a37        	bne	a10, a3, 4201860e <rtc_init+0x1da>
4201860b:	003b46        	j	420186fc <rtc_init+0x2c8>
            blk_ver_major = 0;
4201860e:	4139      	s32i.n	a3, a1, 16
    spi_timing_change_speed_mode_cache_safe(true);
42018610:	1a0c      	movi.n	a10, 1
42018612:	a1fe81        	l32r	a8, 42000e0c <_stext+0xdec>
42018615:	0008e0        	callx8	a8
    soc_rtc_slow_clk_src_t slow_clk_src = rtc_clk_slow_src_get();
42018618:	a1fe81        	l32r	a8, 42000e10 <_stext+0xdf0>
4201861b:	0008e0        	callx8	a8
        cal_clk = RTC_CAL_32K_XTAL;
4201861e:	230c      	movi.n	a3, 2
    if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_XTAL32K) {
42018620:	091a26        	beqi	a10, 1, 4201862d <rtc_init+0x1f9>
    } else if (slow_clk_src == SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256) {
42018623:	fecaa2        	addi	a10, a10, -2
42018626:	130c      	movi.n	a3, 1
42018628:	040c      	movi.n	a4, 0
4201862a:	9334a0        	movnez	a3, a4, a10
    uint32_t slow_clk_period = rtc_clk_cal(cal_clk, 100);
4201862d:	64a0b2        	movi	a11, 100
42018630:	03ad      	mov.n	a10, a3
42018632:	9e8981        	l32r	a8, 42000058 <_stext+0x38>
42018635:	0008e0        	callx8	a8
    uint64_t max_delay_cycle = rtc_time_us_to_slowclk(max_delay_time_us, slow_clk_period);
42018638:	0acd      	mov.n	a12, a10
4201863a:	71a2a2        	movi	a10, 0x271
4201863d:	11aac0        	slli	a10, a10, 4
42018640:	0b0c      	movi.n	a11, 0
42018642:	a1f481        	l32r	a8, 42000e14 <_stext+0xdf4>
42018645:	0008e0        	callx8	a8
42018648:	0a5d      	mov.n	a5, a10
4201864a:	0b4d      	mov.n	a4, a11
    uint64_t cycle0 = rtc_time_get();
4201864c:	9f5781        	l32r	a8, 420003a8 <_stext+0x388>
4201864f:	0008e0        	callx8	a8
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
42018652:	a5aa      	add.n	a10, a5, a10
42018654:	81a9      	s32i.n	a10, a1, 32
42018656:	130c      	movi.n	a3, 1
42018658:	023a57        	bltu	a10, a5, 4201865e <rtc_init+0x22a>
4201865b:	00a032        	movi	a3, 0
    rtc_clk_cpu_freq_get_config(&old_config);
4201865e:	01ad      	mov.n	a10, a1
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
42018660:	44ba      	add.n	a4, a4, a11
    rtc_clk_cpu_freq_get_config(&old_config);
42018662:	9e9281        	l32r	a8, 420000ac <_stext+0x8c>
42018665:	0008e0        	callx8	a8
    rtc_clk_cpu_freq_set_xtal();
42018668:	a1ec81        	l32r	a8, 42000e18 <_stext+0xdf8>
4201866b:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 0);
4201866e:	0f0c      	movi.n	a15, 0
42018670:	0fed      	mov.n	a14, a15
42018672:	0fdd      	mov.n	a13, a15
42018674:	0fcd      	mov.n	a12, a15
42018676:	1b0c      	movi.n	a11, 1
42018678:	61a0a2        	movi	a10, 97
4201867b:	9f2c81        	l32r	a8, 4200032c <_stext+0x30c>
4201867e:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 1);
42018681:	0e0c      	movi.n	a14, 0
42018683:	1f0c      	movi.n	a15, 1
42018685:	0edd      	mov.n	a13, a14
42018687:	0ecd      	mov.n	a12, a14
42018689:	0fbd      	mov.n	a11, a15
4201868b:	61a0a2        	movi	a10, 97
    uint64_t timeout_cycle = cycle0 + max_delay_cycle;
4201868e:	334a      	add.n	a3, a3, a4
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_RESETB, 1);
42018690:	9f2781        	l32r	a8, 4200032c <_stext+0x30c>
42018693:	0008e0        	callx8	a8
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
42018696:	040c      	movi.n	a4, 0
42018698:	350c      	movi.n	a5, 3
4201869a:	01a062        	movi	a6, 1
4201869d:	61a072        	movi	a7, 97
420186a0:	04ed      	mov.n	a14, a4
420186a2:	04dd      	mov.n	a13, a4
420186a4:	05cd      	mov.n	a12, a5
420186a6:	06bd      	mov.n	a11, a6
420186a8:	07ad      	mov.n	a10, a7
420186aa:	a1dc81        	l32r	a8, 42000e1c <_stext+0xdfc>
420186ad:	0008e0        	callx8	a8
420186b0:	0a9d      	mov.n	a9, a10
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
420186b2:	05dd      	mov.n	a13, a5
420186b4:	05cd      	mov.n	a12, a5
420186b6:	05ed      	mov.n	a14, a5
420186b8:	06bd      	mov.n	a11, a6
420186ba:	07ad      	mov.n	a10, a7
420186bc:	a199      	s32i.n	a9, a1, 40
420186be:	a1d781        	l32r	a8, 42000e1c <_stext+0xdfc>
420186c1:	0008e0        	callx8	a8
        cycle1 = rtc_time_get();
420186c4:	91a9      	s32i.n	a10, a1, 36
420186c6:	9f3881        	l32r	a8, 420003a8 <_stext+0x388>
420186c9:	0008e0        	callx8	a8
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
420186cc:	a198      	l32i.n	a9, a1, 40
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
420186ce:	91c8      	l32i.n	a12, a1, 36
        odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_O_DONE_FLAG);
420186d0:	04dd      	mov.n	a13, a4
420186d2:	93d690        	movnez	a13, a6, a9
        bg_odone_flag = REGI2C_READ_MASK(I2C_ULP, I2C_ULP_BG_O_DONE_FLAG);
420186d5:	049d      	mov.n	a9, a4
420186d7:	9396c0        	movnez	a9, a6, a12
        if (cycle1 >= timeout_cycle) {
420186da:	0a8d97        	bany	a13, a9, 420186e8 <rtc_init+0x2b4>
420186dd:	bf3b37        	bltu	a11, a3, 420186a0 <rtc_init+0x26c>
420186e0:	0493b7        	bne	a3, a11, 420186e8 <rtc_init+0x2b4>
420186e3:	8188      	l32i.n	a8, a1, 32
420186e5:	b73a87        	bltu	a10, a8, 420186a0 <rtc_init+0x26c>
    rtc_clk_cpu_freq_set_config(&old_config);
420186e8:	01ad      	mov.n	a10, a1
420186ea:	9e7381        	l32r	a8, 420000b8 <_stext+0x98>
420186ed:	0008e0        	callx8	a8
    spi_timing_change_speed_mode_cache_safe(false);
420186f0:	0a0c      	movi.n	a10, 0
420186f2:	a1c681        	l32r	a8, 42000e0c <_stext+0xdec>
420186f5:	0008e0        	callx8	a8
}
420186f8:	001446        	j	4201874d <rtc_init+0x319>
420186fb:	00          	.byte 00
        if (ocode_efuse_cali) {
420186fc:	042132        	l32i	a3, a1, 16
420186ff:	021326        	beqi	a3, 1, 42018705 <rtc_init+0x2d1>
42018702:	ffc286        	j	42018610 <rtc_init+0x1dc>
    esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_OCODE, &ocode, 8);
42018705:	a1a2a1        	l32r	a10, 42000d90 <_stext+0xd70>
42018708:	08a0c2        	movi	a12, 8
4201870b:	20b110        	or	a11, a1, a1
4201870e:	eddfe5        	call8	4200650c <esp_efuse_read_field_blob>
    assert(err == ESP_OK);
42018711:	0a9c      	beqz.n	a10, 42018725 <rtc_init+0x2f1>
42018713:	a1a0d1        	l32r	a13, 42000d94 <_stext+0xd74>
42018716:	a1a0c1        	l32r	a12, 42000d98 <_stext+0xd78>
42018719:	a1a0a1        	l32r	a10, 42000d9c <_stext+0xd7c>
4201871c:	fda0b2        	movi	a11, 253
4201871f:	9e5981        	l32r	a8, 42000084 <_stext+0x64>
42018722:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_EXT_CODE, ocode);
42018725:	0001f2        	l8ui	a15, a1, 0
42018728:	0aed      	mov.n	a14, a10
4201872a:	7d0c      	movi.n	a13, 7
4201872c:	6c0c      	movi.n	a12, 6
4201872e:	20b330        	or	a11, a3, a3
42018731:	61a0a2        	movi	a10, 97
42018734:	9efe81        	l32r	a8, 4200032c <_stext+0x30c>
42018737:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_ULP, I2C_ULP_IR_FORCE_CODE, 1);
4201873a:	6e0c      	movi.n	a14, 6
4201873c:	03fd      	mov.n	a15, a3
4201873e:	0edd      	mov.n	a13, a14
42018740:	5c0c      	movi.n	a12, 5
42018742:	03bd      	mov.n	a11, a3
42018744:	61a0a2        	movi	a10, 97
42018747:	9ef981        	l32r	a8, 4200032c <_stext+0x30c>
4201874a:	0008e0        	callx8	a8
4201874d:	a19431        	l32r	a3, 42000da0 <_stext+0xd80>
    4. save these values for reuse
    */
    uint8_t blk_minor = efuse_ll_get_blk_version_minor();
    uint8_t blk_major = efuse_ll_get_blk_version_major();
    uint8_t pvt_scheme_ver = 0;
    if ( (blk_major <= 1 && blk_minor == 1) || blk_major > 1 || (blk_major == 1 && blk_minor >= 2) ) {
42018750:	160c      	movi.n	a6, 1
42018752:	0020c0        	memw
42018755:	142342        	l32i	a4, a3, 80
    return EFUSE.rd_sys_part1_data4.blk_version_major;
42018758:	0020c0        	memw
4201875b:	1b2332        	l32i	a3, a3, 108
    return EFUSE.rd_mac_spi_sys_3.blk_version_minor;
4201875e:	254840        	extui	a4, a4, 24, 3
    return EFUSE.rd_sys_part1_data4.blk_version_major;
42018761:	147030        	extui	a7, a3, 0, 2
42018764:	143030        	extui	a3, a3, 0, 2
42018767:	0223b6        	bltui	a3, 2, 4201876d <rtc_init+0x339>
4201876a:	00a062        	movi	a6, 0
4201876d:	940b      	addi.n	a9, a4, -1
4201876f:	150c      	movi.n	a5, 1
42018771:	080c      	movi.n	a8, 0
42018773:	935890        	movnez	a5, a8, a9
42018776:	0e8567        	bany	a5, a6, 42018788 <rtc_init+0x354>
42018779:	0b23f6        	bgeui	a3, 2, 42018788 <rtc_init+0x354>
4201877c:	0224f6        	bgeui	a4, 2, 42018782 <rtc_init+0x34e>
4201877f:	002ec6        	j	4201883e <rtc_init+0x40a>
42018782:	02d787        	bbs	a7, a8, 42018788 <rtc_init+0x354>
42018785:	002d46        	j	4201883e <rtc_init+0x40a>
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_DIG_LDO, &k_dig_ldo, ESP_EFUSE_K_DIG_LDO[0]->bit_count);
42018788:	a16fa1        	l32r	a10, 42000d44 <_stext+0xd24>
    signed int k_dig_ldo = 0, v_dig_bias20 = 0;
4201878b:	030c      	movi.n	a3, 0
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_DIG_LDO, &k_dig_ldo, ESP_EFUSE_K_DIG_LDO[0]->bit_count);
4201878d:	0a48      	l32i.n	a4, a10, 0
4201878f:	10c1b2        	addi	a11, a1, 16
42018792:	0114c2        	l16ui	a12, a4, 2
    signed int k_dig_ldo = 0, v_dig_bias20 = 0;
42018795:	4139      	s32i.n	a3, a1, 16
42018797:	006132        	s32i	a3, a1, 0
    esp_err_t err0 = esp_efuse_read_field_blob(ESP_EFUSE_K_DIG_LDO, &k_dig_ldo, ESP_EFUSE_K_DIG_LDO[0]->bit_count);
4201879a:	edd725        	call8	4200650c <esp_efuse_read_field_blob>
4201879d:	0a4d      	mov.n	a4, a10
    esp_err_t err1 = esp_efuse_read_field_blob(ESP_EFUSE_V_DIG_DBIAS20, &v_dig_bias20, ESP_EFUSE_V_DIG_DBIAS20[0]->bit_count);
4201879f:	a16ba1        	l32r	a10, 42000d4c <_stext+0xd2c>
420187a2:	01bd      	mov.n	a11, a1
420187a4:	0a58      	l32i.n	a5, a10, 0
420187a6:	0115c2        	l16ui	a12, a5, 2
420187a9:	edd625        	call8	4200650c <esp_efuse_read_field_blob>
    if ((err0 != ESP_OK) | (err1 != ESP_OK)) {
420187ac:	20a4a0        	or	a10, a4, a10
420187af:	031a37        	beq	a10, a3, 420187b6 <rtc_init+0x382>
        k_dig_ldo = 0;
420187b2:	4139      	s32i.n	a3, a1, 16
        v_dig_bias20 = 0;
420187b4:	0139      	s32i.n	a3, a1, 0
    k_dig_ldo =  ((k_dig_ldo & BIT(6)) != 0)? -(k_dig_ldo & 0x3f): (uint8_t)k_dig_ldo;
420187b6:	4138      	l32i.n	a3, a1, 16
420187b8:	749030        	extui	a9, a3, 0, 8
420187bb:	056367        	bbci	a3, 6, 420187c4 <rtc_init+0x390>
420187be:	543030        	extui	a3, a3, 0, 6
420187c1:	609030        	neg	a9, a3
    v_dig_bias20 =  ((v_dig_bias20 & BIT(7)) != 0)? -(v_dig_bias20 & 0x7f): (uint8_t)v_dig_bias20;
420187c4:	0188      	l32i.n	a8, a1, 0
420187c6:	743080        	extui	a3, a8, 0, 8
420187c9:	056877        	bbci	a8, 7, 420187d2 <rtc_init+0x39e>
420187cc:	648080        	extui	a8, a8, 0, 7
420187cf:	603080        	neg	a3, a8
    signed int k_dig_ldo_real_mul10000 = K_DIG_MID_MUL10000 + k_dig_ldo;
420187d2:	d3a042        	movi	a4, 211
420187d5:	994a      	add.n	a9, a9, a4
420187d7:	1189e0        	slli	a8, a9, 2
420187da:	a15d41        	l32r	a4, 42000d50 <_stext+0xd30>
420187dd:	608080        	neg	a8, a8
420187e0:	c08890        	sub	a8, a8, a9
420187e3:	884a      	add.n	a8, a8, a4
    uint32_t v_dig_dbias20_real_mul10000 = V_DIG_MID_MUL10000 + v_dig_bias20 * 10000 / 500;
420187e5:	a03330        	addx4	a3, a3, a3
        if (v_dig_nearest_1v3_mul10000 >= 13000) {
420187e8:	a16f61        	l32r	a6, 42000da4 <_stext+0xd84>
420187eb:	a03380        	addx4	a3, a3, a8
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
420187ee:	f50c      	movi.n	a5, 15
420187f0:	041c      	movi.n	a4, 16
420187f2:	068476        	loop	a4, 420187fc <rtc_init+0x3c8>
        if (v_dig_nearest_1v3_mul10000 >= 13000) {
420187f5:	033637        	bltu	a6, a3, 420187fc <rtc_init+0x3c8>
    for (dig_dbias = 15; dig_dbias < 31; dig_dbias++) {
420187f8:	551b      	addi.n	a5, a5, 1
420187fa:	339a      	add.n	a3, a3, a9
    esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_DIG_DBIAS_HVT, &dig_dbias, ESP_EFUSE_DIG_DBIAS_HVT[0]->bit_count);
420187fc:	a16ba1        	l32r	a10, 42000da8 <_stext+0xd88>
    uint32_t dig_dbias = 28;
420187ff:	c31c      	movi.n	a3, 28
    esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_DIG_DBIAS_HVT, &dig_dbias, ESP_EFUSE_DIG_DBIAS_HVT[0]->bit_count);
42018801:	0a48      	l32i.n	a4, a10, 0
42018803:	01bd      	mov.n	a11, a1
42018805:	0114c2        	l16ui	a12, a4, 2
    uint32_t dig_dbias = 28;
42018808:	006132        	s32i	a3, a1, 0
    esp_err_t err = esp_efuse_read_field_blob(ESP_EFUSE_DIG_DBIAS_HVT, &dig_dbias, ESP_EFUSE_DIG_DBIAS_HVT[0]->bit_count);
4201880b:	edd025        	call8	4200650c <esp_efuse_read_field_blob>
    if (err != ESP_OK) {
4201880e:	0a8c      	beqz.n	a10, 42018812 <rtc_init+0x3de>
        dig_dbias = 28;
42018810:	0139      	s32i.n	a3, a1, 0
    return dig_dbias;
42018812:	002132        	l32i	a3, a1, 0
    }

    if (pvt_scheme_ver == 1) {
        uint32_t dig1v3_dbias = get_dig1v3_dbias_by_efuse(pvt_scheme_ver);
        uint32_t dig_dbias = get_dig_dbias_by_efuse(pvt_scheme_ver);
        if (dig_dbias != 0) {
42018815:	025316        	beqz	a3, 4201883e <rtc_init+0x40a>
            g_dig_dbias_pvt_240m = MIN(dig1v3_dbias, dig_dbias + 3);
42018818:	a16541        	l32r	a4, 42000dac <_stext+0xd8c>
4201881b:	a33b      	addi.n	a10, a3, 3
4201881d:	63aa50        	minu	a10, a10, a5
42018820:	04a9      	s32i.n	a10, a4, 0
            g_dig_dbias_pvt_non_240m = MIN(dig1v3_dbias, dig_dbias + 2);
42018822:	332b      	addi.n	a3, a3, 2
42018824:	a16341        	l32r	a4, 42000db0 <_stext+0xd90>
42018827:	633350        	minu	a3, a3, a5
4201882a:	0439      	s32i.n	a3, a4, 0
            g_rtc_dbias_pvt_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_240m);
4201882c:	ffb225        	call8	42018350 <get_rtc_dbias_by_efuse$constprop$0>
4201882f:	a16131        	l32r	a3, 42000db4 <_stext+0xd94>
42018832:	03a9      	s32i.n	a10, a3, 0
            g_rtc_dbias_pvt_non_240m = get_rtc_dbias_by_efuse(pvt_scheme_ver, g_dig_dbias_pvt_non_240m);
42018834:	04a8      	l32i.n	a10, a4, 0
42018836:	ffb1a5        	call8	42018350 <get_rtc_dbias_by_efuse$constprop$0>
42018839:	a15f31        	l32r	a3, 42000db8 <_stext+0xd98>
4201883c:	03a9      	s32i.n	a10, a3, 0
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_RTC_DREG, g_rtc_dbias_pvt_non_240m);
4201883e:	a15e31        	l32r	a3, 42000db8 <_stext+0xd98>
42018841:	4d0c      	movi.n	a13, 4
42018843:	0003f2        	l8ui	a15, a3, 0
42018846:	0dcd      	mov.n	a12, a13
42018848:	0e0c      	movi.n	a14, 0
4201884a:	1b0c      	movi.n	a11, 1
4201884c:	6da0a2        	movi	a10, 109
4201884f:	9eb781        	l32r	a8, 4200032c <_stext+0x30c>
42018852:	0008e0        	callx8	a8
    REGI2C_WRITE_MASK(I2C_DIG_REG, I2C_DIG_REG_EXT_DIG_DREG, g_dig_dbias_pvt_non_240m);
42018855:	a15631        	l32r	a3, 42000db0 <_stext+0xd90>
42018858:	0e0c      	movi.n	a14, 0
4201885a:	0003f2        	l8ui	a15, a3, 0
4201885d:	4d0c      	movi.n	a13, 4
4201885f:	6c0c      	movi.n	a12, 6
42018861:	01a0b2        	movi	a11, 1
42018864:	6da0a2        	movi	a10, 109
42018867:	9eb181        	l32r	a8, 4200032c <_stext+0x30c>
4201886a:	0008e0        	callx8	a8
    if (cfg.clkctl_init) {
4201886d:	5b7287        	bbci	a2, 24, 420188cc <rtc_init+0x498>
        CLEAR_PERI_REG_MASK(EXTMEM_CACHE_MMU_POWER_CTRL_REG, EXTMEM_CACHE_MMU_MEM_FORCE_ON);
42018870:	a15351        	l32r	a5, 42000dbc <_stext+0xd9c>
42018873:	e37c      	movi.n	a3, -2
42018875:	0020c0        	memw
42018878:	0548      	l32i.n	a4, a5, 0
4201887a:	104430        	and	a4, a4, a3
4201887d:	0020c0        	memw
42018880:	0549      	s32i.n	a4, a5, 0
        REG_WRITE(SYSCON_CLKGATE_FORCE_ON_REG, 0);
42018882:	a14f41        	l32r	a4, 42000dc0 <_stext+0xda0>
42018885:	050c      	movi.n	a5, 0
42018887:	0020c0        	memw
4201888a:	0459      	s32i.n	a5, a4, 0
        CLEAR_PERI_REG_MASK(EXTMEM_DCACHE_TAG_POWER_CTRL_REG, EXTMEM_DCACHE_TAG_MEM_FORCE_ON);
4201888c:	a14e51        	l32r	a5, 42000dc4 <_stext+0xda4>
4201888f:	0020c0        	memw
42018892:	0548      	l32i.n	a4, a5, 0
42018894:	104430        	and	a4, a4, a3
42018897:	0020c0        	memw
4201889a:	0549      	s32i.n	a4, a5, 0
        CLEAR_PERI_REG_MASK(EXTMEM_ICACHE_TAG_POWER_CTRL_REG, EXTMEM_ICACHE_TAG_MEM_FORCE_ON);
4201889c:	a14b51        	l32r	a5, 42000dc8 <_stext+0xda8>
4201889f:	0020c0        	memw
420188a2:	0548      	l32i.n	a4, a5, 0
420188a4:	104430        	and	a4, a4, a3
420188a7:	0020c0        	memw
420188aa:	0549      	s32i.n	a4, a5, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(0), SPI_MEM_CLK_EN);
420188ac:	a14851        	l32r	a5, 42000dcc <_stext+0xdac>
420188af:	0020c0        	memw
420188b2:	0548      	l32i.n	a4, a5, 0
420188b4:	104430        	and	a4, a4, a3
420188b7:	0020c0        	memw
420188ba:	0549      	s32i.n	a4, a5, 0
        CLEAR_PERI_REG_MASK(SPI_MEM_CLOCK_GATE_REG(1), SPI_MEM_CLK_EN);
420188bc:	a14551        	l32r	a5, 42000dd0 <_stext+0xdb0>
420188bf:	0020c0        	memw
420188c2:	0548      	l32i.n	a4, a5, 0
420188c4:	103430        	and	a3, a4, a3
420188c7:	0020c0        	memw
420188ca:	0539      	s32i.n	a3, a5, 0
    if (cfg.pwrctl_init) {
420188cc:	02f297        	bbsi	a2, 25, 420188d2 <rtc_init+0x49e>
420188cf:	008646        	j	42018aec <rtc_init+0x6b8>
        CLEAR_PERI_REG_MASK(RTC_CNTL_CLK_CONF_REG, RTC_CNTL_CK8M_FORCE_PU);
420188d2:	a14041        	l32r	a4, 42000dd4 <_stext+0xdb4>
420188d5:	9e9451        	l32r	a5, 42000328 <_stext+0x308>
420188d8:	0020c0        	memw
420188db:	0438      	l32i.n	a3, a4, 0
420188dd:	103350        	and	a3, a3, a5
420188e0:	0020c0        	memw
420188e3:	0439      	s32i.n	a3, a4, 0
        if (!(cfg.xtal_fpu | cfg.bbpll_fpu)) {
420188e5:	053c20        	extui	a3, a2, 28, 1
420188e8:	054b20        	extui	a4, a2, 27, 1
420188eb:	204430        	or	a4, a4, a3
420188ee:	9f0a31        	l32r	a3, 42000518 <_stext+0x4f8>
420188f1:	026407        	bbci	a4, 0, 420188f7 <rtc_init+0x4c3>
420188f4:	008d06        	j	42018b2c <rtc_init+0x6f8>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
420188f7:	0020c0        	memw
420188fa:	0348      	l32i.n	a4, a3, 0
420188fc:	9ff251        	l32r	a5, 420008c4 <_stext+0x8a4>
420188ff:	104450        	and	a4, a4, a5
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42018902:	0020c0        	memw
42018905:	0349      	s32i.n	a4, a3, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
42018907:	a11541        	l32r	a4, 42000d5c <_stext+0xd3c>
4201890a:	9e8251        	l32r	a5, 42000314 <_stext+0x2f4>
4201890d:	0020c0        	memw
42018910:	0438      	l32i.n	a3, a4, 0
42018912:	9f0181        	l32r	a8, 42000518 <_stext+0x4f8>
42018915:	103350        	and	a3, a3, a5
42018918:	0020c0        	memw
4201891b:	0439      	s32i.n	a3, a4, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
4201891d:	0020c0        	memw
42018920:	0838      	l32i.n	a3, a8, 0
        if (!cfg.bbpll_fpu) {
42018922:	0272c7        	bbci	a2, 28, 42018928 <rtc_init+0x4f4>
42018925:	0084c6        	j	42018b3c <rtc_init+0x708>
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
42018928:	9fd741        	l32r	a4, 42000884 <_stext+0x864>
4201892b:	103340        	and	a3, a3, a4
4201892e:	0020c0        	memw
42018931:	0839      	s32i.n	a3, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
42018933:	0020c0        	memw
42018936:	0838      	l32i.n	a3, a8, 0
42018938:	ffad42        	movi	a4, 0xfffffdff
4201893b:	103340        	and	a3, a3, a4
4201893e:	0020c0        	memw
42018941:	0839      	s32i.n	a3, a8, 0
            CLEAR_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
42018943:	0020c0        	memw
42018946:	0838      	l32i.n	a3, a8, 0
42018948:	7faf42        	movi	a4, -129
4201894b:	103340        	and	a3, a3, a4
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
4201894e:	a12241        	l32r	a4, 42000dd8 <_stext+0xdb8>
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
42018951:	0020c0        	memw
42018954:	0839      	s32i.n	a3, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42018956:	0020c0        	memw
42018959:	0438      	l32i.n	a3, a4, 0
4201895b:	a12051        	l32r	a5, 42000ddc <_stext+0xdbc>
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_REGULATOR_FORCE_PU);
4201895e:	9e9c61        	l32r	a6, 420003d0 <_stext+0x3b0>
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42018961:	103350        	and	a3, a3, a5
42018964:	0020c0        	memw
42018967:	0439      	s32i.n	a3, a4, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_REGULATOR_FORCE_PU);
42018969:	a11d31        	l32r	a3, 42000de0 <_stext+0xdc0>
4201896c:	0020c0        	memw
4201896f:	0358      	l32i.n	a5, a3, 0
42018971:	105560        	and	a5, a5, a6
42018974:	0020c0        	memw
42018977:	0359      	s32i.n	a5, a3, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PU);
42018979:	0020c0        	memw
4201897c:	0358      	l32i.n	a5, a3, 0
4201897e:	a11961        	l32r	a6, 42000de4 <_stext+0xdc4>
42018981:	105560        	and	a5, a5, a6
42018984:	0020c0        	memw
42018987:	0359      	s32i.n	a5, a3, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_PWC_REG, RTC_CNTL_SLOWMEM_FORCE_NOISO | RTC_CNTL_FASTMEM_FORCE_NOISO);
42018989:	0020c0        	memw
4201898c:	0458      	l32i.n	a5, a4, 0
4201898e:	a67c      	movi.n	a6, -6
42018990:	105560        	and	a5, a5, a6
42018993:	0020c0        	memw
42018996:	0459      	s32i.n	a5, a4, 0
            SET_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42018998:	0020c0        	memw
4201899b:	0348      	l32i.n	a4, a3, 0
        if (cfg.rtc_dboost_fpd) {
4201899d:	02f2a7        	bbsi	a2, 26, 420189a3 <rtc_init+0x56f>
420189a0:	007106        	j	42018b68 <rtc_init+0x734>
            SET_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
420189a3:	150c      	movi.n	a5, 1
420189a5:	015540        	slli	a5, a5, 28
420189a8:	204450        	or	a4, a4, a5
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
420189ab:	a0ec51        	l32r	a5, 42000d5c <_stext+0xd3c>
            CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
420189ae:	0020c0        	memw
420189b1:	0349      	s32i.n	a4, a3, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
420189b3:	0020c0        	memw
420189b6:	0538      	l32i.n	a3, a5, 0
420189b8:	9e5741        	l32r	a4, 42000314 <_stext+0x2f4>
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
420189bb:	e67c      	movi.n	a6, -2
        CLEAR_PERI_REG_MASK(RTC_CNTL_ANA_CONF_REG, RTC_CNTL_I2C_RESET_POR_FORCE_PD);
420189bd:	103340        	and	a3, a3, a4
420189c0:	0020c0        	memw
420189c3:	0539      	s32i.n	a3, a5, 0
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
420189c5:	a10951        	l32r	a5, 42000dec <_stext+0xdcc>
        rtc_sleep_pu(pu_cfg);
420189c8:	0a0c      	movi.n	a10, 0
        CLEAR_PERI_REG_MASK(SYSTEM_MEM_PD_MASK_REG, SYSTEM_LSLP_MEM_PD_MASK);
420189ca:	0020c0        	memw
420189cd:	0538      	l32i.n	a3, a5, 0
420189cf:	103360        	and	a3, a3, a6
420189d2:	0020c0        	memw
420189d5:	0539      	s32i.n	a3, a5, 0
        rtc_sleep_pu(pu_cfg);
420189d7:	a11281        	l32r	a8, 42000e20 <_stext+0xe00>
420189da:	0008e0        	callx8	a8
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_WRAP_FORCE_PU);
420189dd:	a0de91        	l32r	a9, 42000d58 <_stext+0xd38>
420189e0:	a10451        	l32r	a5, 42000df0 <_stext+0xdd0>
420189e3:	0020c0        	memw
420189e6:	0938      	l32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_WRAP_FORCE_NOISO | RTC_CNTL_DG_WRAP_FORCE_ISO);
420189e8:	a10381        	l32r	a8, 42000df4 <_stext+0xdd4>
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_WRAP_FORCE_PU);
420189eb:	103350        	and	a3, a3, a5
420189ee:	0020c0        	memw
420189f1:	0939      	s32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_WRAP_FORCE_NOISO | RTC_CNTL_DG_WRAP_FORCE_ISO);
420189f3:	0020c0        	memw
420189f6:	0838      	l32i.n	a3, a8, 0
420189f8:	9ddd51        	l32r	a5, 4200016c <_stext+0x14c>
420189fb:	103350        	and	a3, a3, a5
420189fe:	0020c0        	memw
42018a01:	0839      	s32i.n	a3, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_NOISO | RTC_CNTL_WIFI_FORCE_ISO);
42018a03:	0020c0        	memw
42018a06:	0838      	l32i.n	a3, a8, 0
42018a08:	a0fc51        	l32r	a5, 42000df8 <_stext+0xdd8>
42018a0b:	103350        	and	a3, a3, a5
42018a0e:	0020c0        	memw
42018a11:	0839      	s32i.n	a3, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PU);
42018a13:	0020c0        	memw
42018a16:	0938      	l32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_NOISO);
42018a18:	dfaf52        	movi	a5, -33
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PU);
42018a1b:	103340        	and	a3, a3, a4
42018a1e:	0020c0        	memw
42018a21:	0939      	s32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_BT_FORCE_NOISO | RTC_CNTL_BT_FORCE_ISO);
42018a23:	0020c0        	memw
42018a26:	0838      	l32i.n	a3, a8, 0
42018a28:	a0f541        	l32r	a4, 42000dfc <_stext+0xddc>
42018a2b:	103340        	and	a3, a3, a4
42018a2e:	0020c0        	memw
42018a31:	0839      	s32i.n	a3, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_BT_FORCE_PU);
42018a33:	0020c0        	memw
42018a36:	0938      	l32i.n	a3, a9, 0
42018a38:	9fa241        	l32r	a4, 420008c0 <_stext+0x8a0>
42018a3b:	103340        	and	a3, a3, a4
42018a3e:	0020c0        	memw
42018a41:	0939      	s32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_CPU_TOP_FORCE_NOISO | RTC_CNTL_CPU_TOP_FORCE_ISO);
42018a43:	0020c0        	memw
42018a46:	0838      	l32i.n	a3, a8, 0
42018a48:	a0ee41        	l32r	a4, 42000e00 <_stext+0xde0>
42018a4b:	103340        	and	a3, a3, a4
42018a4e:	0020c0        	memw
42018a51:	0839      	s32i.n	a3, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_CPU_TOP_FORCE_PU);
42018a53:	0020c0        	memw
42018a56:	0938      	l32i.n	a3, a9, 0
42018a58:	9f0641        	l32r	a4, 42000670 <_stext+0x650>
42018a5b:	103340        	and	a3, a3, a4
42018a5e:	0020c0        	memw
42018a61:	0939      	s32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PERI_FORCE_NOISO | RTC_CNTL_DG_PERI_FORCE_ISO);
42018a63:	0020c0        	memw
42018a66:	0838      	l32i.n	a3, a8, 0
42018a68:	a0e741        	l32r	a4, 42000e04 <_stext+0xde4>
42018a6b:	103340        	and	a3, a3, a4
42018a6e:	0020c0        	memw
42018a71:	0839      	s32i.n	a3, a8, 0
        REG_CLR_BIT(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_DG_PERI_FORCE_PU);
42018a73:	0020c0        	memw
42018a76:	0938      	l32i.n	a3, a9, 0
42018a78:	9e2a41        	l32r	a4, 42000320 <_stext+0x300>
42018a7b:	103340        	and	a3, a3, a4
42018a7e:	0020c0        	memw
42018a81:	0939      	s32i.n	a3, a9, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_NOISO);
42018a83:	a0d531        	l32r	a3, 42000dd8 <_stext+0xdb8>
42018a86:	0020c0        	memw
42018a89:	0348      	l32i.n	a4, a3, 0
42018a8b:	104450        	and	a4, a4, a5
42018a8e:	0020c0        	memw
42018a91:	0349      	s32i.n	a4, a3, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_ISO);
42018a93:	0020c0        	memw
42018a96:	0348      	l32i.n	a4, a3, 0
42018a98:	f56c      	movi.n	a5, -17
42018a9a:	104450        	and	a4, a4, a5
42018a9d:	0020c0        	memw
42018aa0:	0349      	s32i.n	a4, a3, 0
        REG_CLR_BIT(RTC_CNTL_PWC_REG, RTC_CNTL_FORCE_PU);
42018aa2:	0020c0        	memw
42018aa5:	0348      	l32i.n	a4, a3, 0
42018aa7:	a0cd51        	l32r	a5, 42000ddc <_stext+0xdbc>
42018aaa:	104450        	and	a4, a4, a5
42018aad:	0020c0        	memw
42018ab0:	0349      	s32i.n	a4, a3, 0
        if (cfg.cpu_waiti_clk_gate) {
42018ab2:	a0d531        	l32r	a3, 42000e08 <_stext+0xde8>
42018ab5:	02f2d7        	bbsi	a2, 29, 42018abb <rtc_init+0x687>
42018ab8:	002d46        	j	42018b71 <rtc_init+0x73d>
            CLEAR_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42018abb:	0020c0        	memw
42018abe:	0328      	l32i.n	a2, a3, 0
42018ac0:	747c      	movi.n	a4, -9
42018ac2:	102240        	and	a2, a2, a4
            SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42018ac5:	0020c0        	memw
42018ac8:	0329      	s32i.n	a2, a3, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_UNHOLD);
42018aca:	0020c0        	memw
42018acd:	0828      	l32i.n	a2, a8, 0
42018acf:	9e1431        	l32r	a3, 42000320 <_stext+0x300>
42018ad2:	102230        	and	a2, a2, a3
42018ad5:	0020c0        	memw
42018ad8:	0829      	s32i.n	a2, a8, 0
        CLEAR_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_DG_PAD_FORCE_NOISO);
42018ada:	0020c0        	memw
42018add:	002822        	l32i	a2, a8, 0
42018ae0:	9f7831        	l32r	a3, 420008c0 <_stext+0x8a0>
42018ae3:	102230        	and	a2, a2, a3
42018ae6:	0020c0        	memw
42018ae9:	006822        	s32i	a2, a8, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_ISO_REG, RTC_CNTL_WIFI_FORCE_ISO);
42018aec:	a0c241        	l32r	a4, 42000df4 <_stext+0xdd4>
42018aef:	130c      	movi.n	a3, 1
42018af1:	0020c0        	memw
42018af4:	0428      	l32i.n	a2, a4, 0
42018af6:	013340        	slli	a3, a3, 28
42018af9:	202230        	or	a2, a2, a3
42018afc:	0020c0        	memw
42018aff:	0429      	s32i.n	a2, a4, 0
    SET_PERI_REG_MASK(RTC_CNTL_DIG_PWC_REG, RTC_CNTL_WIFI_FORCE_PD);
42018b01:	a09541        	l32r	a4, 42000d58 <_stext+0xd38>
42018b04:	130c      	movi.n	a3, 1
42018b06:	0020c0        	memw
42018b09:	0428      	l32i.n	a2, a4, 0
42018b0b:	0133f0        	slli	a3, a3, 17
42018b0e:	202230        	or	a2, a2, a3
42018b11:	0020c0        	memw
42018b14:	0429      	s32i.n	a2, a4, 0
    REG_WRITE(RTC_CNTL_INT_ENA_REG, 0);
42018b16:	9e4c21        	l32r	a2, 42000448 <_stext+0x428>
42018b19:	030c      	movi.n	a3, 0
42018b1b:	0020c0        	memw
42018b1e:	0239      	s32i.n	a3, a2, 0
    REG_WRITE(RTC_CNTL_INT_CLR_REG, UINT32_MAX);
42018b20:	9e4b21        	l32r	a2, 4200044c <_stext+0x42c>
42018b23:	f37c      	movi.n	a3, -1
42018b25:	0020c0        	memw
42018b28:	0239      	s32i.n	a3, a2, 0
}
42018b2a:	f01d      	retw.n
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_XTL_FORCE_PU);
42018b2c:	0020c0        	memw
42018b2f:	0348      	l32i.n	a4, a3, 0
42018b31:	150c      	movi.n	a5, 1
42018b33:	115530        	slli	a5, a5, 13
42018b36:	204450        	or	a4, a4, a5
42018b39:	ff7146        	j	42018902 <rtc_init+0x4ce>
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_FORCE_PU);
42018b3c:	140c      	movi.n	a4, 1
42018b3e:	114450        	slli	a4, a4, 11
42018b41:	203340        	or	a3, a3, a4
42018b44:	0020c0        	memw
42018b47:	0839      	s32i.n	a3, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BBPLL_I2C_FORCE_PU);
42018b49:	0020c0        	memw
42018b4c:	0838      	l32i.n	a3, a8, 0
42018b4e:	00a242        	movi	a4, 0x200
42018b51:	203340        	or	a3, a3, a4
42018b54:	0020c0        	memw
42018b57:	0839      	s32i.n	a3, a8, 0
            SET_PERI_REG_MASK(RTC_CNTL_OPTIONS0_REG, RTC_CNTL_BB_I2C_FORCE_PU);
42018b59:	0020c0        	memw
42018b5c:	0838      	l32i.n	a3, a8, 0
42018b5e:	80a042        	movi	a4, 128
42018b61:	203340        	or	a3, a3, a4
42018b64:	ff7986        	j	4201894e <rtc_init+0x51a>
42018b67:	00          	.byte 00
            CLEAR_PERI_REG_MASK(RTC_CNTL_REG, RTC_CNTL_DBOOST_FORCE_PD);
42018b68:	a0a051        	l32r	a5, 42000de8 <_stext+0xdc8>
42018b6b:	104450        	and	a4, a4, a5
42018b6e:	ff8e46        	j	420189ab <rtc_init+0x577>
            SET_PERI_REG_MASK(SYSTEM_CPU_PER_CONF_REG, SYSTEM_CPU_WAIT_MODE_FORCE_ON);
42018b71:	0020c0        	memw
42018b74:	0328      	l32i.n	a2, a3, 0
42018b76:	840c      	movi.n	a4, 8
42018b78:	202240        	or	a2, a2, a4
42018b7b:	ffd186        	j	42018ac5 <rtc_init+0x691>
	...

42018b80 <esp_register_shutdown_handler>:
{
42018b80:	004136        	entry	a1, 32
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
42018b83:	a0a8a1        	l32r	a10, 42000e24 <_stext+0xe04>
42018b86:	090c      	movi.n	a9, 0
42018b88:	0acd      	mov.n	a12, a10
42018b8a:	05a0b2        	movi	a11, 5
42018b8d:	138b76        	loop	a11, 42018ba4 <esp_register_shutdown_handler+0x24>
        if (shutdown_handlers[i] == handler) {
42018b90:	0a88      	l32i.n	a8, a10, 0
42018b92:	161827        	beq	a8, a2, 42018bac <esp_register_shutdown_handler+0x2c>
        } else if (shutdown_handlers[i] == NULL) {
42018b95:	78cc      	bnez.n	a8, 42018ba0 <esp_register_shutdown_handler+0x20>
            shutdown_handlers[i] = handler;
42018b97:	a099c0        	addx4	a9, a9, a12
42018b9a:	0929      	s32i.n	a2, a9, 0
            return ESP_OK;
42018b9c:	082d      	mov.n	a2, a8
}
42018b9e:	f01d      	retw.n
    for (int i = 0; i < SHUTDOWN_HANDLERS_NO; i++) {
42018ba0:	991b      	addi.n	a9, a9, 1
42018ba2:	aa4b      	addi.n	a10, a10, 4
    return ESP_ERR_NO_MEM;
42018ba4:	01a122        	movi	a2, 0x101
42018ba7:	fffcc6        	j	42018b9e <esp_register_shutdown_handler+0x1e>
42018baa:	00          	.byte 00
42018bab:	00          	.byte 00
            return ESP_ERR_INVALID_STATE;
42018bac:	03a122        	movi	a2, 0x103
42018baf:	fffac6        	j	42018b9e <esp_register_shutdown_handler+0x1e>
	...

42018bb4 <esp_startup_start_app>:
#endif // !CONFIG_FREERTOS_UNICORE

extern void esp_startup_start_app_common(void);

void esp_startup_start_app(void)
{
42018bb4:	004136        	entry	a1, 32
#if CONFIG_ESP32_ECO3_CACHE_LOCK_FIX
    assert(!soc_has_cache_lock_bug() && "ESP32 Rev 3 + Dual Core + PSRAM requires INT WDT enabled in project config!");
#endif
#endif

    esp_startup_start_app_common();
42018bb7:	a09c81        	l32r	a8, 42000e28 <_stext+0xe08>
42018bba:	0008e0        	callx8	a8

    ESP_LOGI(TAG, "Starting scheduler on PRO CPU.");
    vTaskStartScheduler();
42018bbd:	a09b81        	l32r	a8, 42000e2c <_stext+0xe0c>
42018bc0:	0008e0        	callx8	a8
}
42018bc3:	f01d      	retw.n
42018bc5:	000000        	ill

42018bc8 <esp_startup_start_app_other_cores>:
{
42018bc8:	004136        	entry	a1, 32
    asm volatile (
42018bcb:	03eb80        	rsr.prid	a8
42018bce:	048d80        	extui	a8, a8, 13, 1
    while (port_xSchedulerRunning[0] == 0) {
42018bd1:	a09791        	l32r	a9, 42000e30 <_stext+0xe10>
    if (xPortGetCoreID() >= 2) {
42018bd4:	0528a6        	blti	a8, 2, 42018bdd <esp_startup_start_app_other_cores+0x15>
    abort(); /* Only get to here if FreeRTOS somehow very broken */
42018bd7:	9d5181        	l32r	a8, 4200011c <_stext+0xfc>
42018bda:	0008e0        	callx8	a8
    while (port_xSchedulerRunning[0] == 0) {
42018bdd:	0020c0        	memw
42018be0:	0988      	l32i.n	a8, a9, 0
42018be2:	ff7816        	beqz	a8, 42018bdd <esp_startup_start_app_other_cores+0x15>
    esp_int_wdt_cpu_init();
42018be5:	e87f65        	call8	420013dc <esp_int_wdt_cpu_init>
    esp_crosscore_int_init();
42018be8:	efc1a5        	call8	42008804 <esp_crosscore_int_init>
    xPortStartScheduler();
42018beb:	a09281        	l32r	a8, 42000e34 <_stext+0xe14>
42018bee:	0008e0        	callx8	a8
42018bf1:	fff886        	j	42018bd7 <esp_startup_start_app_other_cores+0xf>

42018bf4 <main_task>:
{
42018bf4:	008136        	entry	a1, 64
42018bf7:	03eb30        	rsr.prid	a3
42018bfa:	043d30        	extui	a3, a3, 13, 1
    esp_register_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42018bfd:	020c      	movi.n	a2, 0
42018bff:	1b0c      	movi.n	a11, 1
42018c01:	93b230        	movnez	a11, a2, a3
42018c04:	a08d31        	l32r	a3, 42000e38 <_stext+0xe18>
42018c07:	20a330        	or	a10, a3, a3
42018c0a:	e8fea5        	call8	42001bf4 <esp_register_freertos_idle_hook_for_cpu>
    while (!s_other_cpu_startup_done) {
42018c0d:	a08b21        	l32r	a2, 42000e3c <_stext+0xe1c>
42018c10:	0020c0        	memw
42018c13:	000282        	l8ui	a8, a2, 0
42018c16:	748080        	extui	a8, a8, 0, 8
42018c19:	ff3816        	beqz	a8, 42018c10 <main_task+0x1c>
42018c1c:	03eb80        	rsr.prid	a8
42018c1f:	048d80        	extui	a8, a8, 13, 1
    esp_deregister_freertos_idle_hook_for_cpu(other_cpu_startup_idle_hook_cb, !xPortGetCoreID());
42018c22:	020c      	movi.n	a2, 0
42018c24:	1b0c      	movi.n	a11, 1
42018c26:	93b280        	movnez	a11, a2, a8
42018c29:	03ad      	mov.n	a10, a3
42018c2b:	e90725        	call8	42001c9c <esp_deregister_freertos_idle_hook_for_cpu>
    heap_caps_enable_nonos_stack_heaps();
42018c2e:	e95da5        	call8	42002208 <heap_caps_enable_nonos_stack_heaps>
    esp_task_wdt_config_t twdt_config = {
42018c31:	2129      	s32i.n	a2, a1, 8
42018c33:	a08321        	l32r	a2, 42000e40 <_stext+0xe20>
    ESP_ERROR_CHECK(esp_task_wdt_init(&twdt_config));
42018c36:	01ad      	mov.n	a10, a1
    esp_task_wdt_config_t twdt_config = {
42018c38:	0129      	s32i.n	a2, a1, 0
    twdt_config.idle_core_mask |= (1 << 1);
42018c3a:	320c      	movi.n	a2, 3
42018c3c:	1129      	s32i.n	a2, a1, 4
    ESP_ERROR_CHECK(esp_task_wdt_init(&twdt_config));
42018c3e:	f00ae5        	call8	42008cec <esp_task_wdt_init>
42018c41:	0a9c      	beqz.n	a10, 42018c55 <main_task+0x61>
42018c43:	a080e1        	l32r	a14, 42000e44 <_stext+0xe24>
42018c46:	a080d1        	l32r	a13, 42000e48 <_stext+0xe28>
42018c49:	a080b1        	l32r	a11, 42000e4c <_stext+0xe2c>
42018c4c:	80a0c2        	movi	a12, 128
42018c4f:	9edd81        	l32r	a8, 420007c4 <_stext+0x7a4>
42018c52:	0008e0        	callx8	a8
    app_main();
42018c55:	41a9      	s32i.n	a10, a1, 16
42018c57:	ed6365        	call8	4200628c <app_main>
    vTaskDelete(NULL);
42018c5a:	41a8      	l32i.n	a10, a1, 16
42018c5c:	9e7781        	l32r	a8, 42000638 <_stext+0x618>
42018c5f:	0008e0        	callx8	a8
}
42018c62:	f01d      	retw.n

42018c64 <multi_heap_register>:
{
42018c64:	004136        	entry	a1, 32
    assert(start_ptr);
42018c67:	011256        	bnez	a2, 42018c7c <multi_heap_register+0x18>
42018c6a:	a079d1        	l32r	a13, 42000e50 <_stext+0xe30>
42018c6d:	a079c1        	l32r	a12, 42000e54 <_stext+0xe34>
42018c70:	a07aa1        	l32r	a10, 42000e58 <_stext+0xe38>
42018c73:	83a0b2        	movi	a11, 131
42018c76:	9d0381        	l32r	a8, 42000084 <_stext+0x64>
42018c79:	0008e0        	callx8	a8
    if(size < (sizeof(heap_t))) {
42018c7c:	381c      	movi.n	a8, 19
42018c7e:	033837        	bltu	a8, a3, 42018c85 <multi_heap_register+0x21>
        return NULL;
42018c81:	020c      	movi.n	a2, 0
}
42018c83:	f01d      	retw.n
    size -= sizeof(heap_t);
42018c85:	ecc332        	addi	a3, a3, -20
    result->heap_data = tlsf_create_with_pool(start_ptr + sizeof(heap_t), size, max_bytes);
42018c88:	00a0c2        	movi	a12, 0
42018c8b:	20b330        	or	a11, a3, a3
42018c8e:	14c2a2        	addi	a10, a2, 20
42018c91:	003465        	call8	42018fd8 <tlsf_create_with_pool>
42018c94:	0462a2        	s32i	a10, a2, 16
    if(!result->heap_data) {
42018c97:	fe6a16        	beqz	a10, 42018c81 <multi_heap_register+0x1d>
    result->lock = NULL;
42018c9a:	080c      	movi.n	a8, 0
42018c9c:	0289      	s32i.n	a8, a2, 0
    result->free_bytes = size - tlsf_size(result->heap_data);
42018c9e:	a06f81        	l32r	a8, 42000e5c <_stext+0xe3c>
42018ca1:	0008e0        	callx8	a8
42018ca4:	c0a3a0        	sub	a10, a3, a10
42018ca7:	12a9      	s32i.n	a10, a2, 4
    result->pool_size = size;
42018ca9:	3239      	s32i.n	a3, a2, 12
    result->minimum_free_bytes = result->free_bytes;
42018cab:	22a9      	s32i.n	a10, a2, 8
    return result;
42018cad:	fff486        	j	42018c83 <multi_heap_register+0x1f>

42018cb0 <multi_heap_get_info>:

    info->total_blocks++;
}

void multi_heap_get_info_impl(multi_heap_handle_t heap, multi_heap_info_t *info)
{
42018cb0:	004136        	entry	a1, 32
    uint32_t overhead;

    memset(info, 0, sizeof(multi_heap_info_t));
42018cb3:	cc1c      	movi.n	a12, 28
42018cb5:	0b0c      	movi.n	a11, 0
42018cb7:	03ad      	mov.n	a10, a3
42018cb9:	9d3781        	l32r	a8, 42000198 <_stext+0x178>
42018cbc:	0008e0        	callx8	a8

    if (heap == NULL) {
42018cbf:	051216        	beqz	a2, 42018d14 <multi_heap_get_info+0x64>
        return;
    }

    multi_heap_internal_lock(heap);
42018cc2:	20a220        	or	a10, a2, a2
42018cc5:	a06781        	l32r	a8, 42000e64 <_stext+0xe44>
42018cc8:	0008e0        	callx8	a8
    tlsf_walk_pool(tlsf_get_pool(heap->heap_data), multi_heap_get_info_tlsf, info);
42018ccb:	42a8      	l32i.n	a10, a2, 16
42018ccd:	a06681        	l32r	a8, 42000e68 <_stext+0xe48>
42018cd0:	0008e0        	callx8	a8
42018cd3:	a063b1        	l32r	a11, 42000e60 <_stext+0xe40>
42018cd6:	03cd      	mov.n	a12, a3
42018cd8:	000825        	call8	42018d5c <tlsf_walk_pool>
    /* TLSF has an overhead per block. Calculate the total amount of overhead, it shall not be
     * part of the allocated bytes */
    overhead = info->allocated_blocks * tlsf_alloc_overhead();
42018cdb:	4358      	l32i.n	a5, a3, 16
42018cdd:	a06381        	l32r	a8, 42000e6c <_stext+0xe4c>
42018ce0:	0008e0        	callx8	a8
42018ce3:	8255a0        	mull	a5, a5, a10
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42018ce6:	42a8      	l32i.n	a10, a2, 16
42018ce8:	3248      	l32i.n	a4, a2, 12
42018cea:	a05c81        	l32r	a8, 42000e5c <_stext+0xe3c>
42018ced:	0008e0        	callx8	a8
42018cf0:	1298      	l32i.n	a9, a2, 4
    info->minimum_free_bytes = heap->minimum_free_bytes;
    info->total_free_bytes = heap->free_bytes;
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42018cf2:	23b8      	l32i.n	a11, a3, 8
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42018cf4:	c08490        	sub	a8, a4, a9
42018cf7:	c0a8a0        	sub	a10, a8, a10
    info->minimum_free_bytes = heap->minimum_free_bytes;
42018cfa:	2248      	l32i.n	a4, a2, 8
    info->total_allocated_bytes = (heap->pool_size - tlsf_size(heap->heap_data)) - heap->free_bytes - overhead;
42018cfc:	c0aa50        	sub	a10, a10, a5
42018cff:	13a9      	s32i.n	a10, a3, 4
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42018d01:	42a8      	l32i.n	a10, a2, 16
    info->minimum_free_bytes = heap->minimum_free_bytes;
42018d03:	3349      	s32i.n	a4, a3, 12
    info->total_free_bytes = heap->free_bytes;
42018d05:	0399      	s32i.n	a9, a3, 0
    info->largest_free_block = tlsf_fit_size(heap->heap_data, info->largest_free_block);
42018d07:	002f65        	call8	42018ffc <tlsf_fit_size>
42018d0a:	23a9      	s32i.n	a10, a3, 8
    multi_heap_internal_unlock(heap);
42018d0c:	02ad      	mov.n	a10, a2
42018d0e:	a05881        	l32r	a8, 42000e70 <_stext+0xe50>
42018d11:	0008e0        	callx8	a8
}
42018d14:	f01d      	retw.n
	...

42018d18 <multi_heap_get_info_tlsf>:
{
42018d18:	004136        	entry	a1, 32
    if(used) {
42018d1b:	d48c      	beqz.n	a4, 42018d2c <multi_heap_get_info_tlsf+0x14>
        info->allocated_blocks++;
42018d1d:	4588      	l32i.n	a8, a5, 16
42018d1f:	881b      	addi.n	a8, a8, 1
42018d21:	046582        	s32i	a8, a5, 16
    info->total_blocks++;
42018d24:	6588      	l32i.n	a8, a5, 24
42018d26:	881b      	addi.n	a8, a8, 1
42018d28:	6589      	s32i.n	a8, a5, 24
}
42018d2a:	f01d      	retw.n
        info->free_blocks++;
42018d2c:	5588      	l32i.n	a8, a5, 20
42018d2e:	881b      	addi.n	a8, a8, 1
42018d30:	5589      	s32i.n	a8, a5, 20
        if(size > info->largest_free_block ) {
42018d32:	2588      	l32i.n	a8, a5, 8
42018d34:	ecb837        	bgeu	a8, a3, 42018d24 <multi_heap_get_info_tlsf+0xc>
            info->largest_free_block = size;
42018d37:	2539      	s32i.n	a3, a5, 8
42018d39:	fff9c6        	j	42018d24 <multi_heap_get_info_tlsf+0xc>

42018d3c <default_walker>:
{
42018d3c:	004136        	entry	a1, 32
	printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, block_from_ptr(ptr));
42018d3f:	a04dc1        	l32r	a12, 42000e74 <_stext+0xe54>
{
42018d42:	20b220        	or	a11, a2, a2
42018d45:	20d330        	or	a13, a3, a3
	printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, block_from_ptr(ptr));
42018d48:	002456        	bnez	a4, 42018d4e <default_walker+0x12>
42018d4b:	a04bc1        	l32r	a12, 42000e78 <_stext+0xe58>
42018d4e:	a04ba1        	l32r	a10, 42000e7c <_stext+0xe5c>
42018d51:	f8cbe2        	addi	a14, a11, -8
42018d54:	f16425        	call8	4200a398 <printf>
}
42018d57:	000090        	retw
	...

42018d5c <tlsf_walk_pool>:
{
42018d5c:	004136        	entry	a1, 32
	tlsf_walker pool_walker = walker ? walker : default_walker;
42018d5f:	13cc      	bnez.n	a3, 42018d64 <tlsf_walk_pool+0x8>
42018d61:	a04731        	l32r	a3, 42000e80 <_stext+0xe60>
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42018d64:	fcc222        	addi	a2, a2, -4
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42018d67:	c67c      	movi.n	a6, -4
	while (block && !block_is_last(block))
42018d69:	528c      	beqz.n	a2, 42018d72 <tlsf_walk_pool+0x16>
42018d6b:	1288      	l32i.n	a8, a2, 4
42018d6d:	10b860        	and	a11, a8, a6
42018d70:	0bcc      	bnez.n	a11, 42018d74 <tlsf_walk_pool+0x18>
}
42018d72:	f01d      	retw.n
		pool_walker(
42018d74:	fc7c      	movi.n	a12, -1
	return tlsf_cast(void*,
42018d76:	528b      	addi.n	a5, a2, 8
42018d78:	30cc80        	xor	a12, a12, a8
42018d7b:	05ad      	mov.n	a10, a5
42018d7d:	20d440        	or	a13, a4, a4
42018d80:	04c0c0        	extui	a12, a12, 0, 1
42018d83:	0003e0        	callx8	a3
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42018d86:	1288      	l32i.n	a8, a2, 4
42018d88:	108680        	and	a8, a6, a8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42018d8b:	558a      	add.n	a5, a5, a8
42018d8d:	fcc522        	addi	a2, a5, -4
	tlsf_assert(!block_is_last(block));
42018d90:	fd5856        	bnez	a8, 42018d69 <tlsf_walk_pool+0xd>
42018d93:	a03cd1        	l32r	a13, 42000e84 <_stext+0xe64>
42018d96:	a03cc1        	l32r	a12, 42000e88 <_stext+0xe68>
42018d99:	a03ca1        	l32r	a10, 42000e8c <_stext+0xe6c>
42018d9c:	eb5c      	movi.n	a11, 94
42018d9e:	9cb981        	l32r	a8, 42000084 <_stext+0x64>
42018da1:	0008e0        	callx8	a8

42018da4 <tlsf_add_pool>:
{
42018da4:	004136        	entry	a1, 32
	const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);
42018da7:	f8c442        	addi	a4, a4, -8
	return x - (x & (align - 1));
42018daa:	c67c      	movi.n	a6, -4
	if (((ptrdiff_t)mem % ALIGN_SIZE) != 0)
42018dac:	145030        	extui	a5, a3, 0, 2
	return x - (x & (align - 1));
42018daf:	104460        	and	a4, a4, a6
	if (((ptrdiff_t)mem % ALIGN_SIZE) != 0)
42018db2:	c58c      	beqz.n	a5, 42018dc2 <tlsf_add_pool+0x1e>
		printf("tlsf_add_pool: Memory must be aligned by %u bytes.\n",
42018db4:	a037a1        	l32r	a10, 42000e90 <_stext+0xe70>
42018db7:	4b0c      	movi.n	a11, 4
42018db9:	f15de5        	call8	4200a398 <printf>
		return 0;
42018dbc:	030c      	movi.n	a3, 0
}
42018dbe:	032d      	mov.n	a2, a3
42018dc0:	f01d      	retw.n
	if (pool_bytes < block_size_min || pool_bytes > tlsf_block_size_max(tlsf))
42018dc2:	02ad      	mov.n	a10, a2
42018dc4:	a03981        	l32r	a8, 42000ea8 <_stext+0xe88>
42018dc7:	0008e0        	callx8	a8
42018dca:	b80c      	movi.n	a8, 11
42018dcc:	02b847        	bgeu	a8, a4, 42018dd2 <tlsf_add_pool+0x2e>
42018dcf:	0dba47        	bgeu	a10, a4, 42018de0 <tlsf_add_pool+0x3c>
		printf("tlsf_add_pool: Memory size must be between %u and %u bytes.\n", 
42018dd2:	ca8b      	addi.n	a12, a10, 8
42018dd4:	a030a1        	l32r	a10, 42000e94 <_stext+0xe74>
42018dd7:	4b1c      	movi.n	a11, 20
42018dd9:	f15be5        	call8	4200a398 <printf>
42018ddc:	fff706        	j	42018dbc <tlsf_add_pool+0x18>
42018ddf:	00          	.byte 00
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
42018de0:	0388      	l32i.n	a8, a3, 0
	block->size &= ~block_header_prev_free_bit;
42018de2:	d97c      	movi.n	a9, -3
	block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
42018de4:	148080        	extui	a8, a8, 0, 2
42018de7:	208840        	or	a8, a8, a4
	block->size &= ~block_header_prev_free_bit;
42018dea:	109890        	and	a9, a8, a9
42018ded:	140c      	movi.n	a4, 1
42018def:	209940        	or	a9, a9, a4
42018df2:	0399      	s32i.n	a9, a3, 0
	if (size < control->small_block_size)
42018df4:	4298      	l32i.n	a9, a2, 16
42018df6:	108860        	and	a8, a8, a6
42018df9:	756790        	extui	a6, a9, 23, 8
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42018dfc:	fcc3b2        	addi	a11, a3, -4
42018dff:	2db867        	bgeu	a8, a6, 42018e30 <tlsf_add_pool+0x8c>
		sl = tlsf_cast(int, size) / (control->small_block_size / control->sl_index_count);
42018e02:	544e90        	extui	a4, a9, 14, 6
42018e05:	d26640        	quos	a6, a6, a4
42018e08:	d28860        	quos	a8, a8, a6
		fl = 0;
42018e0b:	05ad      	mov.n	a10, a5
	block_header_t* current = control->blocks[fl * control->sl_index_count + sl];
42018e0d:	549e90        	extui	a9, a9, 14, 6
42018e10:	8299a0        	mull	a9, a9, a10
42018e13:	82c8      	l32i.n	a12, a2, 32
42018e15:	998a      	add.n	a9, a9, a8
42018e17:	a099c0        	addx4	a9, a9, a12
42018e1a:	0948      	l32i.n	a4, a9, 0
	tlsf_assert(current && "free list cannot have a null entry");
42018e1c:	c4fc      	bnez.n	a4, 42018e5c <tlsf_add_pool+0xb8>
42018e1e:	a01ed1        	l32r	a13, 42000e98 <_stext+0xe78>
42018e21:	a01ec1        	l32r	a12, 42000e9c <_stext+0xe7c>
42018e24:	66a1b2        	movi	a11, 0x166
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
42018e27:	a01ea1        	l32r	a10, 42000ea0 <_stext+0xe80>
42018e2a:	9c9681        	l32r	a8, 42000084 <_stext+0x64>
42018e2d:	0008e0        	callx8	a8
	const int bit = word ? 32 - __builtin_clz(word) : 0;
42018e30:	40f850        	nsau	a5, a8
	return bit - 1;
42018e33:	fc1c      	movi.n	a12, 31
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
42018e35:	256490        	extui	a6, a9, 20, 3
	return bit - 1;
42018e38:	c0cc50        	sub	a12, a12, a5
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
42018e3b:	c0cc60        	sub	a12, a12, a6
42018e3e:	401600        	ssl	a6
42018e41:	a14400        	sll	a4, a4
42018e44:	400c00        	ssr	a12
42018e47:	918080        	srl	a8, a8
	const int bit = word ? 32 - __builtin_clz(word) : 0;
42018e4a:	0a2c      	movi.n	a10, 32
		sl = tlsf_cast(int, size >> (fl - control->sl_index_count_log2)) ^ (1 << control->sl_index_count_log2);
42018e4c:	308840        	xor	a8, a8, a4
	const int bit = word ? 32 - __builtin_clz(word) : 0;
42018e4f:	c0aa50        	sub	a10, a10, a5
		fl -= (control->fl_index_shift - 1);
42018e52:	244590        	extui	a4, a9, 5, 3
42018e55:	c0aa40        	sub	a10, a10, a4
42018e58:	ffec46        	j	42018e0d <tlsf_add_pool+0x69>
42018e5b:	00          	.byte 00
	block->next_free = current;
42018e5c:	2b49      	s32i.n	a4, a11, 8
	block->prev_free = &control->block_null;
42018e5e:	3b29      	s32i.n	a2, a11, 12
	current->prev_free = block;
42018e60:	34b9      	s32i.n	a11, a4, 12
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42018e62:	ce7c      	movi.n	a14, -4
42018e64:	4bbb      	addi.n	a4, a11, 11
	return tlsf_cast(void*,
42018e66:	db8b      	addi.n	a13, a11, 8
42018e68:	1044e0        	and	a4, a4, a14
	tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
42018e6b:	0b1d47        	beq	a13, a4, 42018e7a <tlsf_add_pool+0xd6>
42018e6e:	a00dd1        	l32r	a13, 42000ea4 <_stext+0xe84>
42018e71:	a00ac1        	l32r	a12, 42000e9c <_stext+0xe7c>
42018e74:	6ca1b2        	movi	a11, 0x16c
42018e77:	ffeb06        	j	42018e27 <tlsf_add_pool+0x83>
	control->blocks[fl * control->sl_index_count + sl] = block;
42018e7a:	4298      	l32i.n	a9, a2, 16
	control->fl_bitmap |= (1U << fl);
42018e7c:	6258      	l32i.n	a5, a2, 24
	control->blocks[fl * control->sl_index_count + sl] = block;
42018e7e:	549e90        	extui	a9, a9, 14, 6
42018e81:	8299a0        	mull	a9, a9, a10
	control->fl_bitmap |= (1U << fl);
42018e84:	140c      	movi.n	a4, 1
	control->blocks[fl * control->sl_index_count + sl] = block;
42018e86:	998a      	add.n	a9, a9, a8
	control->fl_bitmap |= (1U << fl);
42018e88:	401a00        	ssl	a10
42018e8b:	a16400        	sll	a6, a4
	control->blocks[fl * control->sl_index_count + sl] = block;
42018e8e:	a099c0        	addx4	a9, a9, a12
42018e91:	09b9      	s32i.n	a11, a9, 0
	control->fl_bitmap |= (1U << fl);
42018e93:	205560        	or	a5, a5, a6
42018e96:	6259      	s32i.n	a5, a2, 24
	control->sl_bitmap[fl] |= (1U << sl);
42018e98:	7228      	l32i.n	a2, a2, 28
42018e9a:	401800        	ssl	a8
42018e9d:	a14400        	sll	a4, a4
42018ea0:	a0aa20        	addx4	a10, a10, a2
42018ea3:	0a28      	l32i.n	a2, a10, 0
42018ea5:	202240        	or	a2, a2, a4
42018ea8:	0a29      	s32i.n	a2, a10, 0
	return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
42018eaa:	1b28      	l32i.n	a2, a11, 4
42018eac:	10ee20        	and	a14, a14, a2
	return tlsf_cast(block_header_t*, tlsf_cast(tlsfptr_t, ptr) + size);
42018eaf:	2eda      	add.n	a2, a14, a13
42018eb1:	fcc222        	addi	a2, a2, -4
	tlsf_assert(!block_is_last(block));
42018eb4:	cecc      	bnez.n	a14, 42018ec4 <tlsf_add_pool+0x120>
42018eb6:	9ff3d1        	l32r	a13, 42000e84 <_stext+0xe64>
42018eb9:	9ff3c1        	l32r	a12, 42000e88 <_stext+0xe68>
42018ebc:	9ff4a1        	l32r	a10, 42000e8c <_stext+0xe6c>
42018ebf:	eb5c      	movi.n	a11, 94
42018ec1:	ffd946        	j	42018e2a <tlsf_add_pool+0x86>
	block->size |= block_header_prev_free_bit;
42018ec4:	240c      	movi.n	a4, 2
	next->prev_phys_block = block;
42018ec6:	02b9      	s32i.n	a11, a2, 0
	block->size |= block_header_prev_free_bit;
42018ec8:	1249      	s32i.n	a4, a2, 4
	return mem;
42018eca:	ffbc06        	j	42018dbe <tlsf_add_pool+0x1a>
42018ecd:	000000        	ill

42018ed0 <tlsf_create>:
{
42018ed0:	004136        	entry	a1, 32
	if (mem == NULL)
42018ed3:	22cc      	bnez.n	a2, 42018ed9 <tlsf_create+0x9>
		printf("tlsf_create: Memory must be aligned to %u bytes.\n",
42018ed5:	020c      	movi.n	a2, 0
}
42018ed7:	f01d      	retw.n
	if (((tlsfptr_t)mem % ALIGN_SIZE) != 0)
42018ed9:	148020        	extui	a8, a2, 0, 2
42018edc:	c88c      	beqz.n	a8, 42018eec <tlsf_create+0x1c>
		printf("tlsf_create: Memory must be aligned to %u bytes.\n",
42018ede:	9ff3a1        	l32r	a10, 42000eac <_stext+0xe8c>
42018ee1:	4b0c      	movi.n	a11, 4
42018ee3:	f14b65        	call8	4200a398 <printf>
42018ee6:	fffac6        	j	42018ed5 <tlsf_create+0x5>
42018ee9:	00          	.byte 00
42018eea:	00          	.byte 00
42018eeb:	00          	.byte 00
	if (bytes < sizeof(control_t))
42018eec:	382c      	movi.n	a8, 35
42018eee:	e3b837        	bgeu	a8, a3, 42018ed5 <tlsf_create+0x5>
	control->fl_index_max = 32 - __builtin_clz(bytes);
42018ef1:	40f380        	nsau	a8, a3
42018ef4:	0d2c      	movi.n	a13, 32
42018ef6:	c0dd80        	sub	a13, a13, a8
	if (bytes <= 16 * 1024) control->sl_index_count_log2 = 3;
42018ef9:	180c      	movi.n	a8, 1
42018efb:	118820        	slli	a8, a8, 14
	control->fl_index_max = 32 - __builtin_clz(bytes);
42018efe:	74d0d0        	extui	a13, a13, 0, 8
	if (bytes <= 16 * 1024) control->sl_index_count_log2 = 3;
42018f01:	3a0c      	movi.n	a10, 3
42018f03:	0bb837        	bgeu	a8, a3, 42018f12 <tlsf_create+0x42>
	else if (bytes <= 256 * 1024) control->sl_index_count_log2 = 4;
42018f06:	180c      	movi.n	a8, 1
42018f08:	0188e0        	slli	a8, a8, 18
42018f0b:	4a0c      	movi.n	a10, 4
42018f0d:	01b837        	bgeu	a8, a3, 42018f12 <tlsf_create+0x42>
42018f10:	5a0c      	movi.n	a10, 5
	control->fl_index_shift = (control->sl_index_count_log2 + ALIGN_SIZE_LOG2);
42018f12:	8a2b      	addi.n	a8, a10, 2
42018f14:	248080        	extui	a8, a8, 0, 3
	control->sl_index_count = 1 << control->sl_index_count_log2;
42018f17:	1b0c      	movi.n	a11, 1
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
42018f19:	c09b80        	sub	a9, a11, a8
42018f1c:	9d9a      	add.n	a9, a13, a9
	control->sl_index_count = 1 << control->sl_index_count_log2;
42018f1e:	401a00        	ssl	a10
42018f21:	a1cb00        	sll	a12, a11
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
42018f24:	749090        	extui	a9, a9, 0, 8
	control->small_block_size = 1 << control->fl_index_shift;
42018f27:	401800        	ssl	a8
42018f2a:	a1bb00        	sll	a11, a11
	control->fl_index_count = control->fl_index_max - control->fl_index_shift + 1;
42018f2d:	1188b0        	slli	a8, a8, 5
42018f30:	11dd80        	slli	a13, a13, 8
42018f33:	208890        	or	a8, a8, a9
42018f36:	2088d0        	or	a8, a8, a13
42018f39:	11dc20        	slli	a13, a12, 14
42018f3c:	2088d0        	or	a8, a8, a13
42018f3f:	01dac0        	slli	a13, a10, 20
42018f42:	2088d0        	or	a8, a8, a13
42018f45:	01db90        	slli	a13, a11, 23
42018f48:	2088d0        	or	a8, a8, a13
42018f4b:	9d21d1        	l32r	a13, 420003d0 <_stext+0x3b0>
42018f4e:	fe7c      	movi.n	a14, -1
42018f50:	1088d0        	and	a8, a8, a13
42018f53:	42d8      	l32i.n	a13, a2, 16
42018f55:	01ee10        	slli	a14, a14, 31
42018f58:	10dde0        	and	a13, a13, a14
42018f5b:	2088d0        	or	a8, a8, a13
42018f5e:	4289      	s32i.n	a8, a2, 16
										(sizeof(*control->blocks) * (control->fl_index_count * control->sl_index_count));
42018f60:	401a00        	ssl	a10
42018f63:	a1a900        	sll	a10, a9
	control->size = sizeof(control_t) + (sizeof(*control->sl_bitmap) * control->fl_index_count) +
42018f66:	899b      	addi.n	a8, a9, 9
42018f68:	aa8a      	add.n	a10, a10, a8
42018f6a:	11aae0        	slli	a10, a10, 2
42018f6d:	52a9      	s32i.n	a10, a2, 20
	if (bytes < control->size + block_size_min)
42018f6f:	aacb      	addi.n	a10, a10, 12
42018f71:	02b3a7        	bgeu	a3, a10, 42018f77 <tlsf_create+0xa7>
42018f74:	ffd746        	j	42018ed5 <tlsf_create+0x5>
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42018f77:	c37c      	movi.n	a3, -4
42018f79:	27c2a2        	addi	a10, a2, 39
42018f7c:	10aa30        	and	a10, a10, a3
	control->blocks = align_ptr(control->sl_bitmap + control->fl_index_count, sizeof(*control->blocks));
42018f7f:	a099a0        	addx4	a9, a9, a10
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42018f82:	993b      	addi.n	a9, a9, 3
	control->fl_bitmap = 0;
42018f84:	080c      	movi.n	a8, 0
		(tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
42018f86:	109930        	and	a9, a9, a3
	tlsf_assert(ALIGN_SIZE == control->small_block_size / control->sl_index_count); //ALIGN_SIZE does not match");
42018f89:	d2bbc0        	quos	a11, a11, a12
	control->block_null.next_free = &control->block_null;
42018f8c:	2229      	s32i.n	a2, a2, 8
	control->block_null.prev_free = &control->block_null;
42018f8e:	3229      	s32i.n	a2, a2, 12
	control->fl_bitmap = 0;
42018f90:	6289      	s32i.n	a8, a2, 24
	control->sl_bitmap = align_ptr(control + 1, sizeof(*control->sl_bitmap));
42018f92:	72a9      	s32i.n	a10, a2, 28
	control->blocks = align_ptr(control->sl_bitmap + control->fl_index_count, sizeof(*control->blocks));
42018f94:	8299      	s32i.n	a9, a2, 32
		control->sl_bitmap[i] = 0;
42018f96:	08cd      	mov.n	a12, a8
	tlsf_assert(ALIGN_SIZE == control->small_block_size / control->sl_index_count); //ALIGN_SIZE does not match");
42018f98:	224b26        	beqi	a11, 4, 42018fbe <tlsf_create+0xee>
42018f9b:	9fc5d1        	l32r	a13, 42000eb0 <_stext+0xe90>
42018f9e:	9fc5c1        	l32r	a12, 42000eb4 <_stext+0xe94>
42018fa1:	9fbfa1        	l32r	a10, 42000ea0 <_stext+0xe80>
42018fa4:	7ca2b2        	movi	a11, 0x27c
42018fa7:	9c3781        	l32r	a8, 42000084 <_stext+0x64>
42018faa:	0008e0        	callx8	a8
		control->sl_bitmap[i] = 0;
42018fad:	a038a0        	addx4	a3, a8, a10
42018fb0:	03c9      	s32i.n	a12, a3, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42018fb2:	0b0c      	movi.n	a11, 0
42018fb4:	4238      	l32i.n	a3, a2, 16
42018fb6:	543e30        	extui	a3, a3, 14, 6
42018fb9:	0c2b37        	blt	a11, a3, 42018fc9 <tlsf_create+0xf9>
	for (int i = 0; i < control->fl_index_count; ++i)
42018fbc:	881b      	addi.n	a8, a8, 1
42018fbe:	4238      	l32i.n	a3, a2, 16
42018fc0:	443030        	extui	a3, a3, 0, 5
42018fc3:	e62837        	blt	a8, a3, 42018fad <tlsf_create+0xdd>
42018fc6:	ffc346        	j	42018ed7 <tlsf_create+0x7>
			control->blocks[i * control->sl_index_count + j] = &control->block_null;
42018fc9:	823830        	mull	a3, a8, a3
42018fcc:	33ba      	add.n	a3, a3, a11
42018fce:	a03390        	addx4	a3, a3, a9
42018fd1:	0329      	s32i.n	a2, a3, 0
		for (int j = 0; j < control->sl_index_count; ++j)
42018fd3:	bb1b      	addi.n	a11, a11, 1
42018fd5:	fff6c6        	j	42018fb4 <tlsf_create+0xe4>

42018fd8 <tlsf_create_with_pool>:
{
42018fd8:	004136        	entry	a1, 32
42018fdb:	025d      	mov.n	a5, a2
42018fdd:	04bd      	mov.n	a11, a4
	tlsf_t tlsf = tlsf_create(mem, max_bytes ? max_bytes : pool_bytes);
42018fdf:	14cc      	bnez.n	a4, 42018fe4 <tlsf_create_with_pool+0xc>
42018fe1:	20b330        	or	a11, a3, a3
42018fe4:	20a550        	or	a10, a5, a5
42018fe7:	ffeea5        	call8	42018ed0 <tlsf_create>
42018fea:	202aa0        	or	a2, a10, a10
	if (tlsf != NULL)
42018fed:	8a8c      	beqz.n	a10, 42018ff9 <tlsf_create_with_pool+0x21>
	return control->size;
42018fef:	5ab8      	l32i.n	a11, a10, 20
		tlsf_add_pool(tlsf, (char*)mem + tlsf_size(tlsf), pool_bytes - tlsf_size(tlsf));
42018ff1:	c0c3b0        	sub	a12, a3, a11
42018ff4:	b5ba      	add.n	a11, a5, a11
42018ff6:	ffdae5        	call8	42018da4 <tlsf_add_pool>
}
42018ff9:	f01d      	retw.n
	...

42018ffc <tlsf_fit_size>:
{
42018ffc:	004136        	entry	a1, 32
	if (size && tlsf != NULL) 
42018fff:	e39c      	beqz.n	a3, 42019021 <tlsf_fit_size+0x25>
42019001:	c29c      	beqz.n	a2, 42019021 <tlsf_fit_size+0x25>
		sl_interval = (1 << (32 - __builtin_clz(size) - 1)) / control->sl_index_count;
42019003:	4228      	l32i.n	a2, a2, 16
42019005:	f87c      	movi.n	a8, -1
42019007:	40f390        	nsau	a9, a3
4201900a:	018810        	slli	a8, a8, 31
4201900d:	400900        	ssr	a9
42019010:	918080        	srl	a8, a8
42019013:	542e20        	extui	a2, a2, 14, 6
42019016:	d22820        	quos	a2, a8, a2
		return size & ~(sl_interval - 1);
42019019:	602020        	neg	a2, a2
4201901c:	102230        	and	a2, a2, a3
}   
4201901f:	f01d      	retw.n
	return 0;
42019021:	020c      	movi.n	a2, 0
42019023:	fffe06        	j	4201901f <tlsf_fit_size+0x23>
	...

42019028 <_fini>:
42019028:	008136        	entry	a1, 64
	...
